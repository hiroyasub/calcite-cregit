begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParsePosition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_comment
comment|/**  * Utility functions for datetime types: date, time, timestamp.  *  *<p>Used by the JDBC driver.  *  *<p>TODO: review methods for performance. Due to allocations required, it may  * be preferable to introduce a "formatter" with the required state.  */
end_comment

begin_class
specifier|public
class|class
name|DateTimeUtils
block|{
comment|/** The julian date of the epoch, 1970-01-01. */
specifier|public
specifier|static
specifier|final
name|int
name|EPOCH_JULIAN
init|=
literal|2440588
decl_stmt|;
specifier|private
name|DateTimeUtils
parameter_list|()
block|{
block|}
comment|//~ Static fields/initializers ---------------------------------------------
comment|/** The SimpleDateFormat string for ISO dates, "yyyy-MM-dd". */
specifier|public
specifier|static
specifier|final
name|String
name|DATE_FORMAT_STRING
init|=
literal|"yyyy-MM-dd"
decl_stmt|;
comment|/** The SimpleDateFormat string for ISO times, "HH:mm:ss". */
specifier|public
specifier|static
specifier|final
name|String
name|TIME_FORMAT_STRING
init|=
literal|"HH:mm:ss"
decl_stmt|;
comment|/** The SimpleDateFormat string for ISO timestamps, "yyyy-MM-dd HH:mm:ss". */
specifier|public
specifier|static
specifier|final
name|String
name|TIMESTAMP_FORMAT_STRING
init|=
name|DATE_FORMAT_STRING
operator|+
literal|" "
operator|+
name|TIME_FORMAT_STRING
decl_stmt|;
comment|/** The GMT time zone. */
specifier|public
specifier|static
specifier|final
name|TimeZone
name|GMT_ZONE
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT"
argument_list|)
decl_stmt|;
comment|/** The Java default time zone. */
specifier|public
specifier|static
specifier|final
name|TimeZone
name|DEFAULT_ZONE
init|=
name|TimeZone
operator|.
name|getDefault
argument_list|()
decl_stmt|;
comment|/**    * The number of milliseconds in a second.    */
specifier|public
specifier|static
specifier|final
name|long
name|MILLIS_PER_SECOND
init|=
literal|1000L
decl_stmt|;
comment|/**    * The number of milliseconds in a minute.    */
specifier|public
specifier|static
specifier|final
name|long
name|MILLIS_PER_MINUTE
init|=
literal|60000L
decl_stmt|;
comment|/**    * The number of milliseconds in an hour.    */
specifier|public
specifier|static
specifier|final
name|long
name|MILLIS_PER_HOUR
init|=
literal|3600000L
decl_stmt|;
comment|// = 60 * 60 * 1000
comment|/**    * The number of milliseconds in a day.    *    *<p>This is the modulo 'mask' used when converting    * TIMESTAMP values to DATE and TIME values.    */
specifier|public
specifier|static
specifier|final
name|long
name|MILLIS_PER_DAY
init|=
literal|86400000
decl_stmt|;
comment|// = 24 * 60 * 60 * 1000
comment|/**    * Calendar set to the epoch (1970-01-01 00:00:00 UTC). Useful for    * initializing other values. Calendars are not immutable, so be careful not    * to screw up this object for everyone else.    */
specifier|public
specifier|static
specifier|final
name|Calendar
name|ZERO_CALENDAR
decl_stmt|;
static|static
block|{
name|ZERO_CALENDAR
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|DateTimeUtils
operator|.
name|GMT_ZONE
argument_list|)
expr_stmt|;
name|ZERO_CALENDAR
operator|.
name|setTimeInMillis
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Calendar set to local time.    */
specifier|private
specifier|static
specifier|final
name|Calendar
name|LOCAL_CALENDAR
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Parses a string using {@link SimpleDateFormat} and a given pattern. This    * method parses a string at the specified parse position and if successful,    * updates the parse position to the index after the last character used.    * The parsing is strict and requires months to be less than 12, days to be    * less than 31, etc.    *    * @param s       string to be parsed    * @param pattern {@link SimpleDateFormat} pattern (not null)    * @param tz      time zone in which to interpret string. Defaults to the Java    *                default time zone    * @param pp      position to start parsing from    * @return a Calendar initialized with the parsed value, or null if parsing    * failed. If returned, the Calendar is configured to the GMT time zone.    */
specifier|private
specifier|static
name|Calendar
name|parseDateFormat
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|pattern
parameter_list|,
name|TimeZone
name|tz
parameter_list|,
name|ParsePosition
name|pp
parameter_list|)
block|{
assert|assert
name|pattern
operator|!=
literal|null
assert|;
name|SimpleDateFormat
name|df
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|tz
operator|==
literal|null
condition|)
block|{
name|tz
operator|=
name|DEFAULT_ZONE
expr_stmt|;
block|}
name|Calendar
name|ret
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|tz
argument_list|)
decl_stmt|;
name|df
operator|.
name|setCalendar
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|df
operator|.
name|setLenient
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|java
operator|.
name|util
operator|.
name|Date
name|d
init|=
name|df
operator|.
name|parse
argument_list|(
name|s
argument_list|,
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|d
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ret
operator|.
name|setTime
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ret
operator|.
name|setTimeZone
argument_list|(
name|GMT_ZONE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Parses a string using {@link SimpleDateFormat} and a given pattern. The    * entire string must match the pattern specified.    *    * @param s       string to be parsed    * @param pattern {@link SimpleDateFormat}  pattern    * @param tz      time zone in which to interpret string. Defaults to the Java    *                default time zone    * @return a Calendar initialized with the parsed value, or null if parsing    * failed. If returned, the Calendar is configured to the GMT time zone.    */
specifier|public
specifier|static
name|Calendar
name|parseDateFormat
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|pattern
parameter_list|,
name|TimeZone
name|tz
parameter_list|)
block|{
assert|assert
name|pattern
operator|!=
literal|null
assert|;
name|ParsePosition
name|pp
init|=
operator|new
name|ParsePosition
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Calendar
name|ret
init|=
name|parseDateFormat
argument_list|(
name|s
argument_list|,
name|pattern
argument_list|,
name|tz
argument_list|,
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|pp
operator|.
name|getIndex
argument_list|()
operator|!=
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Didn't consume entire string - not good
return|return
literal|null
return|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Parses a string using {@link SimpleDateFormat} and a given pattern, and    * if present, parses a fractional seconds component. The fractional seconds    * component must begin with a decimal point ('.') followed by numeric    * digits. The precision is rounded to a maximum of 3 digits of fractional    * seconds precision (to obtain milliseconds).    *    * @param s       string to be parsed    * @param pattern {@link SimpleDateFormat}  pattern    * @param tz      time zone in which to interpret string. Defaults to the    *                local time zone    * @return a {@link DateTimeUtils.PrecisionTime PrecisionTime} initialized    * with the parsed value, or null if parsing failed. The PrecisionTime    * contains a GMT Calendar and a precision.    */
specifier|public
specifier|static
name|PrecisionTime
name|parsePrecisionDateTimeLiteral
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|pattern
parameter_list|,
name|TimeZone
name|tz
parameter_list|)
block|{
assert|assert
name|pattern
operator|!=
literal|null
assert|;
name|ParsePosition
name|pp
init|=
operator|new
name|ParsePosition
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Calendar
name|cal
init|=
name|parseDateFormat
argument_list|(
name|s
argument_list|,
name|pattern
argument_list|,
name|tz
argument_list|,
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|cal
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// Invalid date/time format
block|}
comment|// Note: the Java SimpleDateFormat 'S' treats any number after
comment|// the decimal as milliseconds. That means 12:00:00.9 has 9
comment|// milliseconds and 12:00:00.9999 has 9999 milliseconds.
name|int
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pp
operator|.
name|getIndex
argument_list|()
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Check to see if rest is decimal portion
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|pp
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|!=
literal|'.'
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Skip decimal sign
name|pp
operator|.
name|setIndex
argument_list|(
name|pp
operator|.
name|getIndex
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Parse decimal portion
if|if
condition|(
name|pp
operator|.
name|getIndex
argument_list|()
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|String
name|secFraction
init|=
name|s
operator|.
name|substring
argument_list|(
name|pp
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|secFraction
operator|.
name|matches
argument_list|(
literal|"\\d+"
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NumberFormat
name|nf
init|=
name|NumberFormat
operator|.
name|getIntegerInstance
argument_list|()
decl_stmt|;
name|Number
name|num
init|=
name|nf
operator|.
name|parse
argument_list|(
name|s
argument_list|,
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|num
operator|==
literal|null
operator|)
operator|||
operator|(
name|pp
operator|.
name|getIndex
argument_list|()
operator|!=
name|s
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
comment|// Invalid decimal portion
return|return
literal|null
return|;
block|}
comment|// Determine precision - only support prec 3 or lower
comment|// (milliseconds) Higher precisions are quietly rounded away
name|p
operator|=
name|Math
operator|.
name|min
argument_list|(
literal|3
argument_list|,
name|secFraction
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// Calculate milliseconds
name|int
name|ms
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
name|num
operator|.
name|longValue
argument_list|()
operator|*
name|Math
operator|.
name|pow
argument_list|(
literal|10
argument_list|,
literal|3
operator|-
name|secFraction
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|cal
operator|.
name|add
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|pp
operator|.
name|getIndex
argument_list|()
operator|==
name|s
operator|.
name|length
argument_list|()
assert|;
name|PrecisionTime
name|ret
init|=
operator|new
name|PrecisionTime
argument_list|(
name|cal
argument_list|,
name|p
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Gets the active time zone based on a Calendar argument    */
specifier|public
specifier|static
name|TimeZone
name|getTimeZone
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
if|if
condition|(
name|cal
operator|==
literal|null
condition|)
block|{
return|return
name|DEFAULT_ZONE
return|;
block|}
return|return
name|cal
operator|.
name|getTimeZone
argument_list|()
return|;
block|}
comment|/**    * Checks if the date/time format is valid    *    * @param pattern {@link SimpleDateFormat}  pattern    * @throws IllegalArgumentException if the given pattern is invalid    */
specifier|public
specifier|static
name|void
name|checkDateFormat
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
operator|new
name|SimpleDateFormat
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new date formatter with Farrago specific options. Farrago    * parsing is strict and does not allow values such as day 0, month 13, etc.    *    * @param format {@link SimpleDateFormat}  pattern    */
specifier|public
specifier|static
name|SimpleDateFormat
name|newDateFormat
parameter_list|(
name|String
name|format
parameter_list|)
block|{
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|sdf
operator|.
name|setLenient
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|sdf
return|;
block|}
comment|/** Helper for CAST({timestamp} AS VARCHAR(n)). */
specifier|public
specifier|static
name|String
name|unixTimestampToString
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|17
argument_list|)
decl_stmt|;
name|int
name|date
init|=
operator|(
name|int
operator|)
operator|(
name|timestamp
operator|/
name|MILLIS_PER_DAY
operator|)
decl_stmt|;
name|int
name|time
init|=
operator|(
name|int
operator|)
operator|(
name|timestamp
operator|%
name|MILLIS_PER_DAY
operator|)
decl_stmt|;
if|if
condition|(
name|time
operator|<
literal|0
condition|)
block|{
operator|--
name|date
expr_stmt|;
name|time
operator|+=
name|MILLIS_PER_DAY
expr_stmt|;
block|}
name|unixDateToString
argument_list|(
name|buf
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|unixTimeToString
argument_list|(
name|buf
argument_list|,
name|time
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Helper for CAST({timestamp} AS VARCHAR(n)). */
specifier|public
specifier|static
name|String
name|unixTimeToString
parameter_list|(
name|int
name|time
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|unixTimeToString
argument_list|(
name|buf
argument_list|,
name|time
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|unixTimeToString
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|time
parameter_list|)
block|{
name|int
name|h
init|=
name|time
operator|/
literal|3600000
decl_stmt|;
name|int
name|time2
init|=
name|time
operator|%
literal|3600000
decl_stmt|;
name|int
name|m
init|=
name|time2
operator|/
literal|60000
decl_stmt|;
name|int
name|time3
init|=
name|time2
operator|%
literal|60000
decl_stmt|;
name|int
name|s
init|=
name|time3
operator|/
literal|1000
decl_stmt|;
name|int
name|ms
init|=
name|time3
operator|%
literal|1000
decl_stmt|;
name|int2
argument_list|(
name|buf
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int2
argument_list|(
name|buf
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int2
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|int2
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'0'
operator|+
operator|(
name|i
operator|/
literal|10
operator|)
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'0'
operator|+
name|i
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|int4
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'0'
operator|+
operator|(
name|i
operator|/
literal|1000
operator|)
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'0'
operator|+
operator|(
name|i
operator|/
literal|100
operator|)
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'0'
operator|+
operator|(
name|i
operator|/
literal|10
operator|)
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'0'
operator|+
name|i
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/** Helper for CAST({date} AS VARCHAR(n)). */
specifier|public
specifier|static
name|String
name|unixDateToString
parameter_list|(
name|int
name|date
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|unixDateToString
argument_list|(
name|buf
argument_list|,
name|date
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|unixDateToString
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|date
parameter_list|)
block|{
name|julianToString
argument_list|(
name|buf
argument_list|,
name|date
operator|+
name|EPOCH_JULIAN
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|julianToString
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|julian
parameter_list|)
block|{
comment|// this shifts the epoch back to astronomical year -4800 instead of the
comment|// start of the Christian era in year AD 1 of the proleptic Gregorian
comment|// calendar.
name|int
name|j
init|=
name|julian
operator|+
literal|32044
decl_stmt|;
name|int
name|g
init|=
name|j
operator|/
literal|146097
decl_stmt|;
name|int
name|dg
init|=
name|j
operator|%
literal|146097
decl_stmt|;
name|int
name|c
init|=
operator|(
name|dg
operator|/
literal|36524
operator|+
literal|1
operator|)
operator|*
literal|3
operator|/
literal|4
decl_stmt|;
name|int
name|dc
init|=
name|dg
operator|-
name|c
operator|*
literal|36524
decl_stmt|;
name|int
name|b
init|=
name|dc
operator|/
literal|1461
decl_stmt|;
name|int
name|db
init|=
name|dc
operator|%
literal|1461
decl_stmt|;
name|int
name|a
init|=
operator|(
name|db
operator|/
literal|365
operator|+
literal|1
operator|)
operator|*
literal|3
operator|/
literal|4
decl_stmt|;
name|int
name|da
init|=
name|db
operator|-
name|a
operator|*
literal|365
decl_stmt|;
comment|// integer number of full years elapsed since March 1, 4801 BC
name|int
name|y
init|=
name|g
operator|*
literal|400
operator|+
name|c
operator|*
literal|100
operator|+
name|b
operator|*
literal|4
operator|+
name|a
decl_stmt|;
comment|// integer number of full months elapsed since the last March 1
name|int
name|m
init|=
operator|(
name|da
operator|*
literal|5
operator|+
literal|308
operator|)
operator|/
literal|153
operator|-
literal|2
decl_stmt|;
comment|// number of days elapsed since day 1 of the month
name|int
name|d
init|=
name|da
operator|-
operator|(
name|m
operator|+
literal|4
operator|)
operator|*
literal|153
operator|/
literal|5
operator|+
literal|122
decl_stmt|;
name|int
name|year
init|=
name|y
operator|-
literal|4800
operator|+
operator|(
name|m
operator|+
literal|2
operator|)
operator|/
literal|12
decl_stmt|;
name|int
name|month
init|=
operator|(
name|m
operator|+
literal|2
operator|)
operator|%
literal|12
operator|+
literal|1
decl_stmt|;
name|int
name|day
init|=
name|d
operator|+
literal|1
decl_stmt|;
name|int4
argument_list|(
name|buf
argument_list|,
name|year
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|int2
argument_list|(
name|buf
argument_list|,
name|month
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|int2
argument_list|(
name|buf
argument_list|,
name|day
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|intervalYearMonthToString
parameter_list|(
name|int
name|v
parameter_list|,
name|TimeUnitRange
name|range
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|>=
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|v
operator|=
operator|-
name|v
expr_stmt|;
block|}
specifier|final
name|int
name|y
decl_stmt|;
specifier|final
name|int
name|m
decl_stmt|;
switch|switch
condition|(
name|range
condition|)
block|{
case|case
name|YEAR
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|y
operator|=
name|v
operator|/
literal|12
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|YEAR_TO_MONTH
case|:
name|y
operator|=
name|v
operator|/
literal|12
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|m
operator|=
name|v
operator|%
literal|12
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONTH
case|:
name|m
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|range
argument_list|)
throw|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|StringBuilder
name|number
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|v
parameter_list|,
name|int
name|n
parameter_list|)
block|{
for|for
control|(
name|int
name|k
init|=
name|digitCount
argument_list|(
name|v
argument_list|)
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|append
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|digitCount
parameter_list|(
name|int
name|v
parameter_list|)
block|{
for|for
control|(
name|int
name|n
init|=
literal|1
init|;
condition|;
name|n
operator|++
control|)
block|{
name|v
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
return|return
name|n
return|;
block|}
block|}
block|}
specifier|private
specifier|static
name|int
name|roundUp
parameter_list|(
name|int
name|dividend
parameter_list|,
name|int
name|divisor
parameter_list|)
block|{
name|int
name|remainder
init|=
name|dividend
operator|%
name|divisor
decl_stmt|;
name|dividend
operator|-=
name|remainder
expr_stmt|;
if|if
condition|(
name|remainder
operator|*
literal|2
operator|>
name|divisor
condition|)
block|{
name|dividend
operator|+=
name|divisor
expr_stmt|;
block|}
return|return
name|dividend
return|;
block|}
comment|/** Cheap, unsafe, long power. power(2, 3) returns 8. */
specifier|public
specifier|static
name|long
name|powerX
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|long
name|x
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|b
operator|>
literal|0
condition|)
block|{
name|x
operator|*=
name|a
expr_stmt|;
operator|--
name|b
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
specifier|public
specifier|static
name|String
name|intervalDayTimeToString
parameter_list|(
name|long
name|v
parameter_list|,
name|TimeUnitRange
name|range
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|>=
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|v
operator|=
operator|-
name|v
expr_stmt|;
block|}
specifier|final
name|long
name|ms
decl_stmt|;
specifier|final
name|long
name|s
decl_stmt|;
specifier|final
name|long
name|m
decl_stmt|;
specifier|final
name|long
name|h
decl_stmt|;
specifier|final
name|long
name|d
decl_stmt|;
switch|switch
condition|(
name|range
condition|)
block|{
case|case
name|DAY_TO_SECOND
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
name|powerX
argument_list|(
literal|10
argument_list|,
literal|3
operator|-
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|=
name|v
operator|%
literal|1000
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|s
operator|=
name|v
operator|%
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|m
operator|=
name|v
operator|%
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|h
operator|=
name|v
operator|%
literal|24
expr_stmt|;
name|v
operator|/=
literal|24
expr_stmt|;
name|d
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|d
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|h
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fraction
argument_list|(
name|buf
argument_list|,
name|scale
argument_list|,
name|ms
argument_list|)
expr_stmt|;
break|break;
case|case
name|DAY_TO_MINUTE
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
literal|1000
operator|*
literal|60
argument_list|)
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|m
operator|=
name|v
operator|%
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|h
operator|=
name|v
operator|%
literal|24
expr_stmt|;
name|v
operator|/=
literal|24
expr_stmt|;
name|d
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|d
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|h
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DAY_TO_HOUR
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
literal|1000
operator|*
literal|60
operator|*
literal|60
argument_list|)
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|h
operator|=
name|v
operator|%
literal|24
expr_stmt|;
name|v
operator|/=
literal|24
expr_stmt|;
name|d
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|d
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|h
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DAY
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
literal|1000
operator|*
literal|60
operator|*
literal|60
operator|*
literal|24
argument_list|)
expr_stmt|;
name|d
operator|=
name|v
operator|/
operator|(
literal|1000
operator|*
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|HOUR
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
literal|1000
operator|*
literal|60
operator|*
literal|60
argument_list|)
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|h
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
name|HOUR_TO_MINUTE
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
literal|1000
operator|*
literal|60
argument_list|)
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|m
operator|=
name|v
operator|%
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|h
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|h
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|HOUR_TO_SECOND
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
name|powerX
argument_list|(
literal|10
argument_list|,
literal|3
operator|-
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|=
name|v
operator|%
literal|1000
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|s
operator|=
name|v
operator|%
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|m
operator|=
name|v
operator|%
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|h
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|h
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fraction
argument_list|(
name|buf
argument_list|,
name|scale
argument_list|,
name|ms
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUTE_TO_SECOND
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
name|powerX
argument_list|(
literal|10
argument_list|,
literal|3
operator|-
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|=
name|v
operator|%
literal|1000
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|s
operator|=
name|v
operator|%
literal|60
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|m
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|m
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fraction
argument_list|(
name|buf
argument_list|,
name|scale
argument_list|,
name|ms
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUTE
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
literal|1000
operator|*
literal|60
argument_list|)
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|v
operator|/=
literal|60
expr_stmt|;
name|m
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECOND
case|:
name|v
operator|=
name|roundUp
argument_list|(
name|v
argument_list|,
name|powerX
argument_list|(
literal|10
argument_list|,
literal|3
operator|-
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|ms
operator|=
name|v
operator|%
literal|1000
expr_stmt|;
name|v
operator|/=
literal|1000
expr_stmt|;
name|s
operator|=
name|v
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|int
operator|)
name|s
argument_list|)
expr_stmt|;
name|fraction
argument_list|(
name|buf
argument_list|,
name|scale
argument_list|,
name|ms
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|range
argument_list|)
throw|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Rounds a dividend to the nearest divisor.    * For example roundUp(31, 10) yields 30; roundUp(37, 10) yields 40.    * @param dividend Number to be divided    * @param divisor Number to divide by    * @return Rounded dividend    */
specifier|private
specifier|static
name|long
name|roundUp
parameter_list|(
name|long
name|dividend
parameter_list|,
name|long
name|divisor
parameter_list|)
block|{
name|long
name|remainder
init|=
name|dividend
operator|%
name|divisor
decl_stmt|;
name|dividend
operator|-=
name|remainder
expr_stmt|;
if|if
condition|(
name|remainder
operator|*
literal|2
operator|>
name|divisor
condition|)
block|{
name|dividend
operator|+=
name|divisor
expr_stmt|;
block|}
return|return
name|dividend
return|;
block|}
specifier|private
specifier|static
name|void
name|fraction
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|int
name|scale
parameter_list|,
name|long
name|ms
parameter_list|)
block|{
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|long
name|v1
init|=
name|scale
operator|==
literal|3
condition|?
name|ms
else|:
name|scale
operator|==
literal|2
condition|?
name|ms
operator|/
literal|10
else|:
name|scale
operator|==
literal|1
condition|?
name|ms
operator|/
literal|100
else|:
literal|0
decl_stmt|;
name|number
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|v1
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|int
name|dateStringToUnixDate
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|int
name|hyphen1
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|d
decl_stmt|;
if|if
condition|(
name|hyphen1
operator|<
literal|0
condition|)
block|{
name|y
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|s
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|hyphen1
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|hyphen2
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|,
name|hyphen1
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|hyphen2
operator|<
literal|0
condition|)
block|{
name|m
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|hyphen1
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|hyphen1
operator|+
literal|1
argument_list|,
name|hyphen2
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|s
operator|.
name|substring
argument_list|(
name|hyphen2
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ymdToUnixDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|timeStringToUnixDate
parameter_list|(
name|String
name|v
parameter_list|)
block|{
return|return
name|timeStringToUnixDate
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|timeStringToUnixDate
parameter_list|(
name|String
name|v
parameter_list|,
name|int
name|start
parameter_list|)
block|{
specifier|final
name|int
name|colon1
init|=
name|v
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|int
name|hour
decl_stmt|;
name|int
name|minute
decl_stmt|;
name|int
name|second
decl_stmt|;
name|int
name|milli
decl_stmt|;
if|if
condition|(
name|colon1
operator|<
literal|0
condition|)
block|{
name|hour
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|minute
operator|=
literal|1
expr_stmt|;
name|second
operator|=
literal|1
expr_stmt|;
name|milli
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|hour
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|colon1
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|colon2
init|=
name|v
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|,
name|colon1
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon2
operator|<
literal|0
condition|)
block|{
name|minute
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
operator|.
name|substring
argument_list|(
name|colon1
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|second
operator|=
literal|1
expr_stmt|;
name|milli
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|minute
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
operator|.
name|substring
argument_list|(
name|colon1
operator|+
literal|1
argument_list|,
name|colon2
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|dot
init|=
name|v
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|,
name|colon2
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|<
literal|0
condition|)
block|{
name|second
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
operator|.
name|substring
argument_list|(
name|colon2
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|milli
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|second
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
operator|.
name|substring
argument_list|(
name|colon2
operator|+
literal|1
argument_list|,
name|dot
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
name|milli
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
operator|.
name|substring
argument_list|(
name|dot
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|hour
operator|*
operator|(
name|int
operator|)
name|MILLIS_PER_HOUR
operator|+
name|minute
operator|*
operator|(
name|int
operator|)
name|MILLIS_PER_MINUTE
operator|+
name|second
operator|*
operator|(
name|int
operator|)
name|MILLIS_PER_SECOND
operator|+
name|milli
return|;
block|}
specifier|public
specifier|static
name|long
name|timestampStringToUnixDate
parameter_list|(
name|String
name|s
parameter_list|)
block|{
specifier|final
name|long
name|d
decl_stmt|;
specifier|final
name|long
name|t
decl_stmt|;
name|s
operator|=
name|s
operator|.
name|trim
argument_list|()
expr_stmt|;
name|int
name|space
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|space
operator|>=
literal|0
condition|)
block|{
name|d
operator|=
name|dateStringToUnixDate
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|space
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|timeStringToUnixDate
argument_list|(
name|s
argument_list|,
name|space
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|dateStringToUnixDate
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|d
operator|*
name|MILLIS_PER_DAY
operator|+
name|t
return|;
block|}
specifier|public
specifier|static
name|long
name|unixDateExtract
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|long
name|date
parameter_list|)
block|{
return|return
name|julianExtract
argument_list|(
name|range
argument_list|,
operator|(
name|int
operator|)
name|date
operator|+
name|EPOCH_JULIAN
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|julianExtract
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|int
name|julian
parameter_list|)
block|{
comment|// this shifts the epoch back to astronomical year -4800 instead of the
comment|// start of the Christian era in year AD 1 of the proleptic Gregorian
comment|// calendar.
name|int
name|j
init|=
name|julian
operator|+
literal|32044
decl_stmt|;
name|int
name|g
init|=
name|j
operator|/
literal|146097
decl_stmt|;
name|int
name|dg
init|=
name|j
operator|%
literal|146097
decl_stmt|;
name|int
name|c
init|=
operator|(
name|dg
operator|/
literal|36524
operator|+
literal|1
operator|)
operator|*
literal|3
operator|/
literal|4
decl_stmt|;
name|int
name|dc
init|=
name|dg
operator|-
name|c
operator|*
literal|36524
decl_stmt|;
name|int
name|b
init|=
name|dc
operator|/
literal|1461
decl_stmt|;
name|int
name|db
init|=
name|dc
operator|%
literal|1461
decl_stmt|;
name|int
name|a
init|=
operator|(
name|db
operator|/
literal|365
operator|+
literal|1
operator|)
operator|*
literal|3
operator|/
literal|4
decl_stmt|;
name|int
name|da
init|=
name|db
operator|-
name|a
operator|*
literal|365
decl_stmt|;
comment|// integer number of full years elapsed since March 1, 4801 BC
name|int
name|y
init|=
name|g
operator|*
literal|400
operator|+
name|c
operator|*
literal|100
operator|+
name|b
operator|*
literal|4
operator|+
name|a
decl_stmt|;
comment|// integer number of full months elapsed since the last March 1
name|int
name|m
init|=
operator|(
name|da
operator|*
literal|5
operator|+
literal|308
operator|)
operator|/
literal|153
operator|-
literal|2
decl_stmt|;
comment|// number of days elapsed since day 1 of the month
name|int
name|d
init|=
name|da
operator|-
operator|(
name|m
operator|+
literal|4
operator|)
operator|*
literal|153
operator|/
literal|5
operator|+
literal|122
decl_stmt|;
name|int
name|year
init|=
name|y
operator|-
literal|4800
operator|+
operator|(
name|m
operator|+
literal|2
operator|)
operator|/
literal|12
decl_stmt|;
name|int
name|month
init|=
operator|(
name|m
operator|+
literal|2
operator|)
operator|%
literal|12
operator|+
literal|1
decl_stmt|;
name|int
name|day
init|=
name|d
operator|+
literal|1
decl_stmt|;
switch|switch
condition|(
name|range
condition|)
block|{
case|case
name|YEAR
case|:
return|return
name|year
return|;
case|case
name|QUARTER
case|:
return|return
operator|(
name|month
operator|+
literal|2
operator|)
operator|/
literal|3
return|;
case|case
name|MONTH
case|:
return|return
name|month
return|;
case|case
name|DAY
case|:
return|return
name|day
return|;
case|case
name|DOW
case|:
return|return
operator|(
name|int
operator|)
name|floorMod
argument_list|(
name|julian
operator|+
literal|1
argument_list|,
literal|7
argument_list|)
operator|+
literal|1
return|;
comment|// sun=1, sat=7
case|case
name|WEEK
case|:
name|long
name|fmofw
init|=
name|firstMondayOfFirstWeek
argument_list|(
name|year
argument_list|)
decl_stmt|;
if|if
condition|(
name|julian
operator|<
name|fmofw
condition|)
block|{
name|fmofw
operator|=
name|firstMondayOfFirstWeek
argument_list|(
name|year
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
operator|(
name|julian
operator|-
name|fmofw
operator|)
operator|/
literal|7
operator|+
literal|1
return|;
case|case
name|DOY
case|:
specifier|final
name|long
name|janFirst
init|=
name|ymdToJulian
argument_list|(
name|year
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|int
operator|)
operator|(
name|julian
operator|-
name|janFirst
operator|)
operator|+
literal|1
return|;
case|case
name|CENTURY
case|:
return|return
name|year
operator|>
literal|0
condition|?
operator|(
name|year
operator|+
literal|99
operator|)
operator|/
literal|100
else|:
operator|(
name|year
operator|-
literal|99
operator|)
operator|/
literal|100
return|;
case|case
name|MILLENNIUM
case|:
return|return
name|year
operator|>
literal|0
condition|?
operator|(
name|year
operator|+
literal|999
operator|)
operator|/
literal|1000
else|:
operator|(
name|year
operator|-
literal|999
operator|)
operator|/
literal|1000
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|range
argument_list|)
throw|;
block|}
block|}
comment|/** Returns the first day of the first week of a year.    * Per ISO-8601 it is the Monday of the week that contains Jan 4,    * or equivalently, it is a Monday between Dec 29 and Jan 4.    * Sometimes it is in the year before the given year. */
specifier|private
specifier|static
name|long
name|firstMondayOfFirstWeek
parameter_list|(
name|int
name|year
parameter_list|)
block|{
specifier|final
name|long
name|janFirst
init|=
name|ymdToJulian
argument_list|(
name|year
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|long
name|janFirstDow
init|=
name|floorMod
argument_list|(
name|janFirst
operator|+
literal|1
argument_list|,
literal|7
argument_list|)
decl_stmt|;
comment|// sun=0, sat=6
return|return
name|janFirst
operator|+
operator|(
literal|11
operator|-
name|janFirstDow
operator|)
operator|%
literal|7
operator|-
literal|3
return|;
block|}
comment|/** Extracts a time unit from a UNIX date (milliseconds since epoch). */
specifier|public
specifier|static
name|int
name|unixTimestampExtract
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|unixTimeExtract
argument_list|(
name|range
argument_list|,
operator|(
name|int
operator|)
name|floorMod
argument_list|(
name|timestamp
argument_list|,
name|MILLIS_PER_DAY
argument_list|)
argument_list|)
return|;
block|}
comment|/** Extracts a time unit from a time value (milliseconds since midnight). */
specifier|public
specifier|static
name|int
name|unixTimeExtract
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|int
name|time
parameter_list|)
block|{
assert|assert
name|time
operator|>=
literal|0
assert|;
assert|assert
name|time
operator|<
name|MILLIS_PER_DAY
assert|;
switch|switch
condition|(
name|range
condition|)
block|{
case|case
name|HOUR
case|:
return|return
name|time
operator|/
operator|(
name|int
operator|)
name|MILLIS_PER_HOUR
return|;
case|case
name|MINUTE
case|:
specifier|final
name|int
name|minutes
init|=
name|time
operator|/
operator|(
name|int
operator|)
name|MILLIS_PER_MINUTE
decl_stmt|;
return|return
name|minutes
operator|%
literal|60
return|;
case|case
name|SECOND
case|:
specifier|final
name|int
name|seconds
init|=
name|time
operator|/
operator|(
name|int
operator|)
name|MILLIS_PER_SECOND
decl_stmt|;
return|return
name|seconds
operator|%
literal|60
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|range
argument_list|)
throw|;
block|}
block|}
comment|/** Resets to zero the "time" part of a timestamp. */
specifier|public
specifier|static
name|long
name|resetTime
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
name|int
name|date
init|=
operator|(
name|int
operator|)
operator|(
name|timestamp
operator|/
name|MILLIS_PER_DAY
operator|)
decl_stmt|;
return|return
operator|(
name|long
operator|)
name|date
operator|*
name|MILLIS_PER_DAY
return|;
block|}
comment|/** Resets to epoch (1970-01-01) the "date" part of a timestamp. */
specifier|public
specifier|static
name|long
name|resetDate
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|floorMod
argument_list|(
name|timestamp
argument_list|,
name|MILLIS_PER_DAY
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|unixTimestampFloor
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|int
name|date
init|=
operator|(
name|int
operator|)
operator|(
name|timestamp
operator|/
name|MILLIS_PER_DAY
operator|)
decl_stmt|;
specifier|final
name|int
name|f
init|=
name|julianDateFloor
argument_list|(
name|range
argument_list|,
name|date
operator|+
name|EPOCH_JULIAN
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|(
name|long
operator|)
name|f
operator|*
name|MILLIS_PER_DAY
return|;
block|}
specifier|public
specifier|static
name|long
name|unixDateFloor
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|long
name|date
parameter_list|)
block|{
return|return
name|julianDateFloor
argument_list|(
name|range
argument_list|,
operator|(
name|int
operator|)
name|date
operator|+
name|EPOCH_JULIAN
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|unixTimestampCeil
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|int
name|date
init|=
operator|(
name|int
operator|)
operator|(
name|timestamp
operator|/
name|MILLIS_PER_DAY
operator|)
decl_stmt|;
specifier|final
name|int
name|f
init|=
name|julianDateFloor
argument_list|(
name|range
argument_list|,
name|date
operator|+
name|EPOCH_JULIAN
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|(
name|long
operator|)
name|f
operator|*
name|MILLIS_PER_DAY
return|;
block|}
specifier|public
specifier|static
name|long
name|unixDateCeil
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|long
name|date
parameter_list|)
block|{
return|return
name|julianDateFloor
argument_list|(
name|range
argument_list|,
operator|(
name|int
operator|)
name|date
operator|+
name|EPOCH_JULIAN
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|julianDateFloor
parameter_list|(
name|TimeUnitRange
name|range
parameter_list|,
name|int
name|julian
parameter_list|,
name|boolean
name|floor
parameter_list|)
block|{
comment|// this shifts the epoch back to astronomical year -4800 instead of the
comment|// start of the Christian era in year AD 1 of the proleptic Gregorian
comment|// calendar.
name|int
name|j
init|=
name|julian
operator|+
literal|32044
decl_stmt|;
name|int
name|g
init|=
name|j
operator|/
literal|146097
decl_stmt|;
name|int
name|dg
init|=
name|j
operator|%
literal|146097
decl_stmt|;
name|int
name|c
init|=
operator|(
name|dg
operator|/
literal|36524
operator|+
literal|1
operator|)
operator|*
literal|3
operator|/
literal|4
decl_stmt|;
name|int
name|dc
init|=
name|dg
operator|-
name|c
operator|*
literal|36524
decl_stmt|;
name|int
name|b
init|=
name|dc
operator|/
literal|1461
decl_stmt|;
name|int
name|db
init|=
name|dc
operator|%
literal|1461
decl_stmt|;
name|int
name|a
init|=
operator|(
name|db
operator|/
literal|365
operator|+
literal|1
operator|)
operator|*
literal|3
operator|/
literal|4
decl_stmt|;
name|int
name|da
init|=
name|db
operator|-
name|a
operator|*
literal|365
decl_stmt|;
comment|// integer number of full years elapsed since March 1, 4801 BC
name|int
name|y
init|=
name|g
operator|*
literal|400
operator|+
name|c
operator|*
literal|100
operator|+
name|b
operator|*
literal|4
operator|+
name|a
decl_stmt|;
comment|// integer number of full months elapsed since the last March 1
name|int
name|m
init|=
operator|(
name|da
operator|*
literal|5
operator|+
literal|308
operator|)
operator|/
literal|153
operator|-
literal|2
decl_stmt|;
comment|// number of days elapsed since day 1 of the month
name|int
name|d
init|=
name|da
operator|-
operator|(
name|m
operator|+
literal|4
operator|)
operator|*
literal|153
operator|/
literal|5
operator|+
literal|122
decl_stmt|;
name|int
name|year
init|=
name|y
operator|-
literal|4800
operator|+
operator|(
name|m
operator|+
literal|2
operator|)
operator|/
literal|12
decl_stmt|;
name|int
name|month
init|=
operator|(
name|m
operator|+
literal|2
operator|)
operator|%
literal|12
operator|+
literal|1
decl_stmt|;
name|int
name|day
init|=
name|d
operator|+
literal|1
decl_stmt|;
switch|switch
condition|(
name|range
condition|)
block|{
case|case
name|YEAR
case|:
if|if
condition|(
operator|!
name|floor
operator|&&
operator|(
name|month
operator|>
literal|1
operator|||
name|day
operator|>
literal|1
operator|)
condition|)
block|{
operator|++
name|year
expr_stmt|;
block|}
return|return
name|ymdToUnixDate
argument_list|(
name|year
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|MONTH
case|:
if|if
condition|(
operator|!
name|floor
operator|&&
name|day
operator|>
literal|1
condition|)
block|{
operator|++
name|month
expr_stmt|;
block|}
return|return
name|ymdToUnixDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|range
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|int
name|ymdToUnixDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
specifier|final
name|int
name|julian
init|=
name|ymdToJulian
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
return|return
name|julian
operator|-
name|EPOCH_JULIAN
return|;
block|}
specifier|public
specifier|static
name|int
name|ymdToJulian
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
name|int
name|a
init|=
operator|(
literal|14
operator|-
name|month
operator|)
operator|/
literal|12
decl_stmt|;
name|int
name|y
init|=
name|year
operator|+
literal|4800
operator|-
name|a
decl_stmt|;
name|int
name|m
init|=
name|month
operator|+
literal|12
operator|*
name|a
operator|-
literal|3
decl_stmt|;
name|int
name|j
init|=
name|day
operator|+
operator|(
literal|153
operator|*
name|m
operator|+
literal|2
operator|)
operator|/
literal|5
operator|+
literal|365
operator|*
name|y
operator|+
name|y
operator|/
literal|4
operator|-
name|y
operator|/
literal|100
operator|+
name|y
operator|/
literal|400
operator|-
literal|32045
decl_stmt|;
if|if
condition|(
name|j
operator|<
literal|2299161
condition|)
block|{
name|j
operator|=
name|day
operator|+
operator|(
literal|153
operator|*
name|m
operator|+
literal|2
operator|)
operator|/
literal|5
operator|+
literal|365
operator|*
name|y
operator|+
name|y
operator|/
literal|4
operator|-
literal|32083
expr_stmt|;
block|}
return|return
name|j
return|;
block|}
specifier|public
specifier|static
name|long
name|unixTimestamp
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|,
name|int
name|hour
parameter_list|,
name|int
name|minute
parameter_list|,
name|int
name|second
parameter_list|)
block|{
specifier|final
name|int
name|date
init|=
name|ymdToUnixDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
return|return
operator|(
name|long
operator|)
name|date
operator|*
name|MILLIS_PER_DAY
operator|+
operator|(
name|long
operator|)
name|hour
operator|*
name|MILLIS_PER_HOUR
operator|+
operator|(
name|long
operator|)
name|minute
operator|*
name|MILLIS_PER_MINUTE
operator|+
operator|(
name|long
operator|)
name|second
operator|*
name|MILLIS_PER_SECOND
return|;
block|}
comment|/** Adds a given number of months to a timestamp, represented as the number    * of milliseconds since the epoch. */
specifier|public
specifier|static
name|long
name|addMonths
parameter_list|(
name|long
name|timestamp
parameter_list|,
name|int
name|m
parameter_list|)
block|{
specifier|final
name|long
name|millis
init|=
name|DateTimeUtils
operator|.
name|floorMod
argument_list|(
name|timestamp
argument_list|,
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
decl_stmt|;
name|timestamp
operator|-=
name|millis
expr_stmt|;
specifier|final
name|long
name|x
init|=
name|addMonths
argument_list|(
operator|(
name|int
operator|)
operator|(
name|timestamp
operator|/
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
operator|)
argument_list|,
name|m
argument_list|)
decl_stmt|;
return|return
name|x
operator|*
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
operator|+
name|millis
return|;
block|}
comment|/** Adds a given number of months to a date, represented as the number of    * days since the epoch. */
specifier|public
specifier|static
name|int
name|addMonths
parameter_list|(
name|int
name|date
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|int
name|y0
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|unixDateExtract
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|,
name|date
argument_list|)
decl_stmt|;
name|int
name|m0
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|unixDateExtract
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|,
name|date
argument_list|)
decl_stmt|;
name|int
name|d0
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|unixDateExtract
argument_list|(
name|TimeUnitRange
operator|.
name|DAY
argument_list|,
name|date
argument_list|)
decl_stmt|;
name|int
name|y
init|=
name|m
operator|/
literal|12
decl_stmt|;
name|y0
operator|+=
name|y
expr_stmt|;
name|m0
operator|+=
name|m
operator|-
name|y
operator|*
literal|12
expr_stmt|;
name|int
name|last
init|=
name|lastDay
argument_list|(
name|y0
argument_list|,
name|m0
argument_list|)
decl_stmt|;
if|if
condition|(
name|d0
operator|>
name|last
condition|)
block|{
name|d0
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|m0
operator|>
literal|12
condition|)
block|{
name|m0
operator|=
literal|1
expr_stmt|;
operator|++
name|y0
expr_stmt|;
block|}
block|}
return|return
name|DateTimeUtils
operator|.
name|ymdToUnixDate
argument_list|(
name|y0
argument_list|,
name|m0
argument_list|,
name|d0
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|lastDay
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|)
block|{
switch|switch
condition|(
name|m
condition|)
block|{
case|case
literal|2
case|:
return|return
name|y
operator|%
literal|4
operator|==
literal|0
operator|&&
operator|(
name|y
operator|%
literal|100
operator|!=
literal|0
operator|||
name|y
operator|%
literal|400
operator|==
literal|0
operator|)
condition|?
literal|29
else|:
literal|28
return|;
case|case
literal|4
case|:
case|case
literal|6
case|:
case|case
literal|9
case|:
case|case
literal|11
case|:
return|return
literal|30
return|;
default|default:
return|return
literal|31
return|;
block|}
block|}
comment|/** Finds the number of months between two dates, each represented as the    * number of days since the epoch. */
specifier|public
specifier|static
name|int
name|subtractMonths
parameter_list|(
name|int
name|date0
parameter_list|,
name|int
name|date1
parameter_list|)
block|{
if|if
condition|(
name|date0
operator|<
name|date1
condition|)
block|{
return|return
operator|-
name|subtractMonths
argument_list|(
name|date1
argument_list|,
name|date0
argument_list|)
return|;
block|}
comment|// Start with an estimate.
comment|// Since no month has more than 31 days, the estimate is<= the true value.
name|int
name|m
init|=
operator|(
name|date0
operator|-
name|date1
operator|)
operator|/
literal|31
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|date2
init|=
name|addMonths
argument_list|(
name|date1
argument_list|,
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|date2
operator|>=
name|date0
condition|)
block|{
return|return
name|m
return|;
block|}
name|int
name|date3
init|=
name|addMonths
argument_list|(
name|date1
argument_list|,
name|m
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|date3
operator|>
name|date0
condition|)
block|{
return|return
name|m
return|;
block|}
operator|++
name|m
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|int
name|subtractMonths
parameter_list|(
name|long
name|t0
parameter_list|,
name|long
name|t1
parameter_list|)
block|{
specifier|final
name|long
name|millis0
init|=
name|DateTimeUtils
operator|.
name|floorMod
argument_list|(
name|t0
argument_list|,
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
decl_stmt|;
specifier|final
name|int
name|d0
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|floorDiv
argument_list|(
name|t0
operator|-
name|millis0
argument_list|,
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
decl_stmt|;
specifier|final
name|long
name|millis1
init|=
name|DateTimeUtils
operator|.
name|floorMod
argument_list|(
name|t1
argument_list|,
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
decl_stmt|;
specifier|final
name|int
name|d1
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|floorDiv
argument_list|(
name|t1
operator|-
name|millis1
argument_list|,
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
decl_stmt|;
name|int
name|x
init|=
name|subtractMonths
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
decl_stmt|;
specifier|final
name|long
name|d2
init|=
name|addMonths
argument_list|(
name|d1
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|d2
operator|==
name|d0
operator|&&
name|millis0
operator|<
name|millis1
condition|)
block|{
operator|--
name|x
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/** Divide, rounding towards negative infinity. */
specifier|public
specifier|static
name|long
name|floorDiv
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|y
parameter_list|)
block|{
name|long
name|r
init|=
name|x
operator|/
name|y
decl_stmt|;
comment|// if the signs are different and modulo not zero, round down
if|if
condition|(
operator|(
name|x
operator|^
name|y
operator|)
operator|<
literal|0
operator|&&
operator|(
name|r
operator|*
name|y
operator|!=
name|x
operator|)
condition|)
block|{
name|r
operator|--
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/** Modulo, always returning a non-negative result. */
specifier|public
specifier|static
name|long
name|floorMod
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|y
parameter_list|)
block|{
return|return
name|x
operator|-
name|floorDiv
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|*
name|y
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Helper class for {@link DateTimeUtils#parsePrecisionDateTimeLiteral}    */
specifier|public
specifier|static
class|class
name|PrecisionTime
block|{
specifier|private
specifier|final
name|Calendar
name|cal
decl_stmt|;
specifier|private
specifier|final
name|int
name|precision
decl_stmt|;
specifier|public
name|PrecisionTime
parameter_list|(
name|Calendar
name|cal
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|this
operator|.
name|cal
operator|=
name|cal
expr_stmt|;
name|this
operator|.
name|precision
operator|=
name|precision
expr_stmt|;
block|}
specifier|public
name|Calendar
name|getCalendar
parameter_list|()
block|{
return|return
name|cal
return|;
block|}
specifier|public
name|int
name|getPrecision
parameter_list|()
block|{
return|return
name|precision
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End DateTimeUtils.java
end_comment

end_unit

