begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|csv
operator|.
name|CsvSchemaFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|csv
operator|.
name|CsvStreamTableFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlToRelConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Sources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Disabled
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Timeout
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DriverManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|anyOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|isA
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|nullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|fail
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|valueOf
import|;
end_import

begin_comment
comment|/**  * Unit test of the Calcite adapter for CSV.  */
end_comment

begin_class
specifier|public
class|class
name|CsvTest
block|{
specifier|private
name|void
name|close
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|Statement
name|statement
parameter_list|)
block|{
if|if
condition|(
name|statement
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
comment|/** Quotes a string for Java or JSON. */
specifier|private
specifier|static
name|String
name|escapeString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|escapeString
argument_list|(
operator|new
name|StringBuilder
argument_list|()
argument_list|,
name|s
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Quotes a string for Java or JSON, into a builder. */
specifier|private
specifier|static
name|StringBuilder
name|escapeString
parameter_list|(
name|StringBuilder
name|buf
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|char
name|lastChar
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
if|if
condition|(
name|lastChar
operator|!=
literal|'\n'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|lastChar
operator|=
name|c
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
return|;
block|}
comment|/**    * Tests the vanity driver.    */
annotation|@
name|Disabled
annotation|@
name|Test
specifier|public
name|void
name|testVanityDriver
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:csv:"
argument_list|,
name|info
argument_list|)
decl_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests the vanity driver with properties in the URL.    */
annotation|@
name|Disabled
annotation|@
name|Test
specifier|public
name|void
name|testVanityDriverArgsInUrl
parameter_list|()
throws|throws
name|SQLException
block|{
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:csv:"
operator|+
literal|"directory='foo'"
argument_list|)
decl_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Tests an inline schema with a non-existent directory. */
annotation|@
name|Test
specifier|public
name|void
name|testBadDirectory
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
literal|"inline:"
operator|+
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       type: 'custom',\n"
operator|+
literal|"       name: 'bad',\n"
operator|+
literal|"       factory: 'org.apache.calcite.adapter.csv.CsvSchemaFactory',\n"
operator|+
literal|"       operand: {\n"
operator|+
literal|"         directory: '/does/not/exist'\n"
operator|+
literal|"       }\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
expr_stmt|;
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
decl_stmt|;
comment|// must print "directory ... not found" to stdout, but not fail
name|ResultSet
name|tables
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getTables
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tables
operator|.
name|next
argument_list|()
expr_stmt|;
name|tables
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Reads from a table.    */
annotation|@
name|Test
specifier|public
name|void
name|testSelect
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"model"
argument_list|,
literal|"select * from EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectSingleProjectGz
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"select name from EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectSingleProject
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"select name from DEPTS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-898">[CALCITE-898]    * Type inference multiplying Java long by SQL INTEGER</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSelectLongMultiplyInteger
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno * 3 as e3\n"
operator|+
literal|"from long_emps where empno = 100"
decl_stmt|;
name|sql
argument_list|(
literal|"bug"
argument_list|,
name|sql
argument_list|)
operator|.
name|checking
argument_list|(
name|resultSet
lambda|->
block|{
try|try
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|Long
name|o
init|=
operator|(
name|Long
operator|)
name|resultSet
operator|.
name|getObject
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|o
argument_list|,
name|is
argument_list|(
literal|300L
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomTable
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"model-with-custom-table"
argument_list|,
literal|"select * from CUSTOM_TABLE.EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushDownProjectDumb
parameter_list|()
throws|throws
name|SQLException
block|{
comment|// rule does not fire, because we're using 'dumb' tables in simple model
specifier|final
name|String
name|sql
init|=
literal|"explain plan for select * from EMPS"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"PLAN=EnumerableInterpreter\n"
operator|+
literal|"  BindableTableScan(table=[[SALES, EMPS]])\n"
decl_stmt|;
name|sql
argument_list|(
literal|"model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushDownProject
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"explain plan for select * from EMPS"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"PLAN=CsvTableScan(table=[[SALES, EMPS]], "
operator|+
literal|"fields=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]])\n"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushDownProject2
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"explain plan for select name, empno from EMPS"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"PLAN=CsvTableScan(table=[[SALES, EMPS]], fields=[[1, 0]])\n"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
comment|// make sure that it works...
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"select name, empno from EMPS"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Fred; EMPNO=100"
argument_list|,
literal|"NAME=Eric; EMPNO=110"
argument_list|,
literal|"NAME=John; EMPNO=110"
argument_list|,
literal|"NAME=Wilma; EMPNO=120"
argument_list|,
literal|"NAME=Alice; EMPNO=130"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushDownProjectAggregate
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"explain plan for\n"
operator|+
literal|"select gender, count(*) from EMPS group by gender"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"PLAN="
operator|+
literal|"EnumerableAggregate(group=[{0}], EXPR$1=[COUNT()])\n"
operator|+
literal|"  CsvTableScan(table=[[SALES, EMPS]], fields=[[3]])\n"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushDownProjectAggregateWithFilter
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"explain plan for\n"
operator|+
literal|"select max(empno) from EMPS where gender='F'"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"PLAN="
operator|+
literal|"EnumerableAggregate(group=[{}], EXPR$0=[MAX($0)])\n"
operator|+
literal|"  EnumerableCalc(expr#0..1=[{inputs}], expr#2=['F':VARCHAR], "
operator|+
literal|"expr#3=[=($t1, $t2)], proj#0..1=[{exprs}], $condition=[$t3])\n"
operator|+
literal|"    CsvTableScan(table=[[SALES, EMPS]], fields=[[0, 3]])\n"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushDownProjectAggregateNested
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"explain plan for\n"
operator|+
literal|"select gender, max(qty)\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select name, gender, count(*) qty\n"
operator|+
literal|"  from EMPS\n"
operator|+
literal|"  group by name, gender) t\n"
operator|+
literal|"group by gender"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"PLAN="
operator|+
literal|"EnumerableAggregate(group=[{1}], EXPR$1=[MAX($2)])\n"
operator|+
literal|"  EnumerableAggregate(group=[{0, 1}], QTY=[COUNT()])\n"
operator|+
literal|"    CsvTableScan(table=[[SALES, EMPS]], fields=[[1, 3]])\n"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFilterableSelect
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
literal|"select name from EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFilterableSelectStar
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
literal|"select * from EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Filter that can be fully handled by CsvFilterableTable. */
annotation|@
name|Test
specifier|public
name|void
name|testFilterableWhere
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, gender, name from EMPS where name = 'John'"
decl_stmt|;
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=110; GENDER=M; NAME=John"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Filter that can be partly handled by CsvFilterableTable. */
annotation|@
name|Test
specifier|public
name|void
name|testFilterableWhere2
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, gender, name from EMPS\n"
operator|+
literal|" where gender = 'F' and empno> 125"
decl_stmt|;
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=130; GENDER=F; NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Filter that can be slightly handled by CsvFilterableTable. */
annotation|@
name|Test
specifier|public
name|void
name|testFilterableWhere3
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, gender, name from EMPS\n"
operator|+
literal|" where gender<> 'M' and empno> 125"
decl_stmt|;
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=130; GENDER=F; NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2272">[CALCITE-2272]    * Incorrect result for {@code name like '%E%' and city not like '%W%'}</a>.    */
annotation|@
name|Test
specifier|public
name|void
name|testFilterableWhereWithNot1
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
literal|"select name, empno from EMPS "
operator|+
literal|"where name like '%E%' and city not like '%W%' "
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Eric; EMPNO=110"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Similar to {@link #testFilterableWhereWithNot1()};    * But use the same column. */
annotation|@
name|Test
specifier|public
name|void
name|testFilterableWhereWithNot2
parameter_list|()
throws|throws
name|SQLException
block|{
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
literal|"select name, empno from EMPS "
operator|+
literal|"where name like '%i%' and name not like '%W%' "
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Eric; EMPNO=110"
argument_list|,
literal|"NAME=Alice; EMPNO=130"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJson
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from archers\n"
decl_stmt|;
specifier|final
name|String
index|[]
name|lines
init|=
block|{
literal|"id=19990101; dow=Friday; longDate=New Years Day; title=Tractor trouble.; "
operator|+
literal|"characters=[Alice, Bob, Xavier]; script=Julian Hyde; summary=; "
operator|+
literal|"lines=[Bob's tractor got stuck in a field., "
operator|+
literal|"Alice and Xavier hatch a plan to surprise Charlie.]"
block|,
literal|"id=19990103; dow=Sunday; longDate=Sunday 3rd January; "
operator|+
literal|"title=Charlie's surprise.; characters=[Alice, Zebedee, Charlie, Xavier]; "
operator|+
literal|"script=William Shakespeare; summary=; "
operator|+
literal|"lines=[Charlie is very surprised by Alice and Xavier's surprise plan.]"
block|,     }
decl_stmt|;
name|sql
argument_list|(
literal|"bug"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|lines
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
specifier|private
name|Fluent
name|sql
parameter_list|(
name|String
name|model
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
return|return
operator|new
name|Fluent
argument_list|(
name|model
argument_list|,
name|sql
argument_list|,
name|this
operator|::
name|output
argument_list|)
return|;
block|}
comment|/** Returns a function that checks the contents of a result set against an    * expected string. */
specifier|private
specifier|static
name|Consumer
argument_list|<
name|ResultSet
argument_list|>
name|expect
parameter_list|(
specifier|final
name|String
modifier|...
name|expected
parameter_list|)
block|{
return|return
name|resultSet
lambda|->
block|{
try|try
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|lines
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|CsvTest
operator|.
name|collect
argument_list|(
name|lines
argument_list|,
name|resultSet
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|expected
argument_list|)
argument_list|,
name|lines
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|;
block|}
comment|/** Returns a function that checks the contents of a result set against an    * expected string. */
specifier|private
specifier|static
name|Consumer
argument_list|<
name|ResultSet
argument_list|>
name|expectUnordered
parameter_list|(
name|String
modifier|...
name|expected
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|expectedLines
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|immutableSortedCopy
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|expected
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|resultSet
lambda|->
block|{
try|try
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|lines
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|CsvTest
operator|.
name|collect
argument_list|(
name|lines
argument_list|,
name|resultSet
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|lines
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedLines
argument_list|,
name|lines
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|;
block|}
specifier|private
name|void
name|checkSql
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|model
parameter_list|,
name|Consumer
argument_list|<
name|ResultSet
argument_list|>
name|fn
parameter_list|)
throws|throws
name|SQLException
block|{
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|Statement
name|statement
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|statement
operator|=
name|connection
operator|.
name|createStatement
argument_list|()
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|fn
operator|.
name|accept
argument_list|(
name|resultSet
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|close
argument_list|(
name|connection
argument_list|,
name|statement
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|jsonPath
parameter_list|(
name|String
name|model
parameter_list|)
block|{
return|return
name|resourcePath
argument_list|(
name|model
operator|+
literal|".json"
argument_list|)
return|;
block|}
specifier|private
name|String
name|resourcePath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|Sources
operator|.
name|of
argument_list|(
name|CsvTest
operator|.
name|class
operator|.
name|getResource
argument_list|(
literal|"/"
operator|+
name|path
argument_list|)
argument_list|)
operator|.
name|file
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|collect
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|result
parameter_list|,
name|ResultSet
name|resultSet
parameter_list|)
throws|throws
name|SQLException
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumnCount
argument_list|()
decl_stmt|;
name|String
name|sep
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|sep
argument_list|)
operator|.
name|append
argument_list|(
name|resultSet
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumnLabel
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|resultSet
operator|.
name|getString
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|"; "
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|output
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|SQLException
block|{
specifier|final
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
specifier|final
name|int
name|columnCount
init|=
name|metaData
operator|.
name|getColumnCount
argument_list|()
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|print
argument_list|(
name|resultSet
operator|.
name|getString
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|columnCount
condition|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoinOnString
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emps\n"
operator|+
literal|"join depts on emps.name = depts.name"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWackyColumns
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from wacky_column_names where false"
decl_stmt|;
name|sql
argument_list|(
literal|"bug"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|()
operator|.
name|ok
argument_list|()
expr_stmt|;
specifier|final
name|String
name|sql2
init|=
literal|"select \"joined at\", \"naME\"\n"
operator|+
literal|"from wacky_column_names\n"
operator|+
literal|"where \"2gender\" = 'F'"
decl_stmt|;
name|sql
argument_list|(
literal|"bug"
argument_list|,
name|sql2
argument_list|)
operator|.
name|returns
argument_list|(
literal|"joined at=2005-09-07; naME=Wilma"
argument_list|,
literal|"joined at=2007-01-01; naME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1754">[CALCITE-1754]    * In Csv adapter, convert DATE and TIME values to int, and TIMESTAMP values    * to long</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testGroupByTimestampAdd
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c,\n"
operator|+
literal|"  {fn timestampadd(SQL_TSI_DAY, 1, JOINEDAT) } as t\n"
operator|+
literal|"from EMPS group by {fn timestampadd(SQL_TSI_DAY, 1, JOINEDAT ) } "
decl_stmt|;
name|sql
argument_list|(
literal|"model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"C=1; T=1996-08-04"
argument_list|,
literal|"C=1; T=2002-05-04"
argument_list|,
literal|"C=1; T=2005-09-08"
argument_list|,
literal|"C=1; T=2007-01-02"
argument_list|,
literal|"C=1; T=2001-01-02"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
specifier|final
name|String
name|sql2
init|=
literal|"select count(*) as c,\n"
operator|+
literal|"  {fn timestampadd(SQL_TSI_MONTH, 1, JOINEDAT) } as t\n"
operator|+
literal|"from EMPS group by {fn timestampadd(SQL_TSI_MONTH, 1, JOINEDAT ) } "
decl_stmt|;
name|sql
argument_list|(
literal|"model"
argument_list|,
name|sql2
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"C=1; T=2002-06-03"
argument_list|,
literal|"C=1; T=2005-10-07"
argument_list|,
literal|"C=1; T=2007-02-01"
argument_list|,
literal|"C=1; T=2001-02-01"
argument_list|,
literal|"C=1; T=1996-09-03"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnionGroupByWithoutGroupKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c1 from EMPS group by NAME\n"
operator|+
literal|"union\n"
operator|+
literal|"select count(*) as c1 from EMPS group by NAME"
decl_stmt|;
name|sql
argument_list|(
literal|"model"
argument_list|,
name|sql
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBoolean
parameter_list|()
block|{
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"select empno, slacker from emps where slacker"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=100; SLACKER=true"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReadme
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT d.name, COUNT(*) cnt"
operator|+
literal|" FROM emps AS e"
operator|+
literal|" JOIN depts AS d ON e.deptno = d.deptno"
operator|+
literal|" GROUP BY d.name"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Sales; CNT=1"
argument_list|,
literal|"NAME=Marketing; CNT=2"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-824">[CALCITE-824]    * Type inference when converting IN clause to semijoin</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testInToSemiJoinWithCast
parameter_list|()
throws|throws
name|SQLException
block|{
comment|// Note that the IN list needs at least 20 values to trigger the rewrite
comment|// to a semijoin. Try it both ways.
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.name\n"
operator|+
literal|"FROM emps AS e\n"
operator|+
literal|"WHERE cast(e.empno as bigint) in "
decl_stmt|;
specifier|final
name|int
name|threshold
init|=
name|SqlToRelConverter
operator|.
name|DEFAULT_IN_SUB_QUERY_THRESHOLD
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
operator|+
name|range
argument_list|(
literal|130
argument_list|,
name|threshold
operator|-
literal|5
argument_list|)
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
operator|+
name|range
argument_list|(
literal|130
argument_list|,
name|threshold
argument_list|)
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
operator|+
name|range
argument_list|(
literal|130
argument_list|,
name|threshold
operator|+
literal|1000
argument_list|)
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1051">[CALCITE-1051]    * Underflow exception due to scaling IN clause literals</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testInToSemiJoinWithoutCast
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.name\n"
operator|+
literal|"FROM emps AS e\n"
operator|+
literal|"WHERE e.empno in "
operator|+
name|range
argument_list|(
literal|130
argument_list|,
name|SqlToRelConverter
operator|.
name|DEFAULT_IN_SUB_QUERY_THRESHOLD
argument_list|)
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
specifier|private
name|String
name|range
parameter_list|(
name|int
name|first
parameter_list|,
name|int
name|count
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|"("
else|:
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|first
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDateType
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
name|ResultSet
name|res
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"DATE"
argument_list|,
literal|"JOINEDAT"
argument_list|)
decl_stmt|;
name|res
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|getInt
argument_list|(
literal|"DATA_TYPE"
argument_list|)
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DATE
argument_list|)
expr_stmt|;
name|res
operator|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"DATE"
argument_list|,
literal|"JOINTIME"
argument_list|)
expr_stmt|;
name|res
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|getInt
argument_list|(
literal|"DATA_TYPE"
argument_list|)
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIME
argument_list|)
expr_stmt|;
name|res
operator|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"DATE"
argument_list|,
literal|"JOINTIMES"
argument_list|)
expr_stmt|;
name|res
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|getInt
argument_list|(
literal|"DATA_TYPE"
argument_list|)
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIMESTAMP
argument_list|)
expr_stmt|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select \"JOINEDAT\", \"JOINTIME\", \"JOINTIMES\" from \"DATE\" where EMPNO = 100"
argument_list|)
decl_stmt|;
name|resultSet
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// date
name|assertEquals
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
argument_list|,
name|resultSet
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03"
argument_list|)
argument_list|,
name|resultSet
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// time
name|assertEquals
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|class
argument_list|,
name|resultSet
operator|.
name|getTime
argument_list|(
literal|2
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|valueOf
argument_list|(
literal|"00:01:02"
argument_list|)
argument_list|,
name|resultSet
operator|.
name|getTime
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// timestamp
name|assertEquals
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|class
argument_list|,
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|3
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|,
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1072">[CALCITE-1072]    * CSV adapter incorrectly parses TIMESTAMP values after noon</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testDateType2
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from \"DATE\"\n"
operator|+
literal|"where EMPNO>= 140 and EMPNO< 200"
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
specifier|final
name|int
name|empId
init|=
name|resultSet
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|date
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|String
name|time
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|String
name|timestamp
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|date
argument_list|,
name|is
argument_list|(
literal|"2015-12-31"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|empId
condition|)
block|{
case|case
literal|140
case|:
name|assertThat
argument_list|(
name|time
argument_list|,
name|is
argument_list|(
literal|"07:15:56"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
literal|"2015-12-31 07:15:56"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|150
case|:
name|assertThat
argument_list|(
name|time
argument_list|,
name|is
argument_list|(
literal|"13:31:21"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
literal|"2015-12-31 13:31:21"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
name|assertThat
argument_list|(
name|n
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1673">[CALCITE-1673]    * Query with ORDER BY or GROUP BY on TIMESTAMP column throws    * CompileException</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testTimestampGroupBy
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Use LIMIT to ensure that results are deterministic without ORDER BY
specifier|final
name|String
name|sql
init|=
literal|"select \"EMPNO\", \"JOINTIMES\"\n"
operator|+
literal|"from (select * from \"DATE\" limit 1)\n"
operator|+
literal|"group by \"EMPNO\",\"JOINTIMES\""
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
init|)
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Timestamp
name|timestamp
init|=
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|isA
argument_list|(
name|Timestamp
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|// Note: This logic is time zone specific, but the same time zone is
comment|// used in the CSV adapter and this test, so they should cancel out.
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02.0"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** As {@link #testTimestampGroupBy()} but with ORDER BY. */
annotation|@
name|Test
specifier|public
name|void
name|testTimestampOrderBy
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select \"EMPNO\",\"JOINTIMES\" from \"DATE\"\n"
operator|+
literal|"order by \"JOINTIMES\""
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
init|)
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Timestamp
name|timestamp
init|=
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** As {@link #testTimestampGroupBy()} but with ORDER BY as well as GROUP    * BY. */
annotation|@
name|Test
specifier|public
name|void
name|testTimestampGroupByAndOrderBy
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select \"EMPNO\", \"JOINTIMES\" from \"DATE\"\n"
operator|+
literal|"group by \"EMPNO\",\"JOINTIMES\" order by \"JOINTIMES\""
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
init|)
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Timestamp
name|timestamp
init|=
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1031">[CALCITE-1031]    * In prepared statement, CsvScannableTable.scan is called twice</a>. To see    * the bug, place a breakpoint in CsvScannableTable.scan, and note that it is    * called twice. It should only be called once. */
annotation|@
name|Test
specifier|public
name|void
name|testPrepared
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|properties
operator|.
name|setProperty
argument_list|(
literal|"caseSensitive"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|properties
argument_list|)
init|)
block|{
specifier|final
name|CalciteConnection
name|calciteConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|Schema
name|schema
init|=
name|CsvSchemaFactory
operator|.
name|INSTANCE
operator|.
name|create
argument_list|(
name|calciteConnection
operator|.
name|getRootSchema
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"directory"
argument_list|,
name|resourcePath
argument_list|(
literal|"sales"
argument_list|)
argument_list|,
literal|"flavor"
argument_list|,
literal|"scannable"
argument_list|)
argument_list|)
decl_stmt|;
name|calciteConnection
operator|.
name|getRootSchema
argument_list|()
operator|.
name|add
argument_list|(
literal|"TEST"
argument_list|,
name|schema
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from \"TEST\".\"DEPTS\" where \"NAME\" = ?"
decl_stmt|;
specifier|final
name|PreparedStatement
name|statement2
init|=
name|calciteConnection
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|statement2
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
literal|"Sales"
argument_list|)
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet1
init|=
name|statement2
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|Consumer
argument_list|<
name|ResultSet
argument_list|>
name|expect
init|=
name|expect
argument_list|(
literal|"DEPTNO=10; NAME=Sales"
argument_list|)
decl_stmt|;
name|expect
operator|.
name|accept
argument_list|(
name|resultSet1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1054">[CALCITE-1054]    * NPE caused by wrong code generation for Timestamp fields</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testFilterOnNullableTimestamp
parameter_list|()
throws|throws
name|Exception
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// date
specifier|final
name|String
name|sql1
init|=
literal|"select JOINEDAT from \"DATE\"\n"
operator|+
literal|"where JOINEDAT< {d '2000-01-01'}\n"
operator|+
literal|"or JOINEDAT>= {d '2017-01-01'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinedAt
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// time
specifier|final
name|String
name|sql2
init|=
literal|"select JOINTIME from \"DATE\"\n"
operator|+
literal|"where JOINTIME>= {t '07:00:00'}\n"
operator|+
literal|"and JOINTIME< {t '08:00:00'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTime
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|valueOf
argument_list|(
literal|"07:15:56"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// timestamp
specifier|final
name|String
name|sql3
init|=
literal|"select JOINTIMES,\n"
operator|+
literal|"  {fn timestampadd(SQL_TSI_DAY, 1, JOINTIMES)}\n"
operator|+
literal|"from \"DATE\"\n"
operator|+
literal|"where (JOINTIMES>= {ts '2003-01-01 00:00:00'}\n"
operator|+
literal|"and JOINTIMES< {ts '2006-01-01 00:00:00'})\n"
operator|+
literal|"or (JOINTIMES>= {ts '2003-01-01 00:00:00'}\n"
operator|+
literal|"and JOINTIMES< {ts '2007-01-01 00:00:00'})"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql3
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"2005-09-07 00:00:00"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"2005-09-08 00:00:00"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql4
init|=
literal|"select JOINTIMES, extract(year from JOINTIMES)\n"
operator|+
literal|"from \"DATE\""
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes2
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql4
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1118">[CALCITE-1118]    * NullPointerException in EXTRACT with WHERE ... IN clause if field has null    * value</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testFilterOnNullableTimestamp2
parameter_list|()
throws|throws
name|Exception
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql1
init|=
literal|"select extract(year from JOINTIMES)\n"
operator|+
literal|"from \"DATE\"\n"
operator|+
literal|"where extract(year from JOINTIMES) in (2006, 2007)"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2007
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql2
init|=
literal|"select extract(year from JOINTIMES),\n"
operator|+
literal|"  count(0) from \"DATE\"\n"
operator|+
literal|"where extract(year from JOINTIMES) between 2007 and 2016\n"
operator|+
literal|"group by extract(year from JOINTIMES)"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes2
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2007
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1L
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2015
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2L
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1427">[CALCITE-1427]    * Code generation incorrect (does not compile) for DATE, TIME and TIMESTAMP    * fields</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testNonNullFilterOnDateType
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// date
specifier|final
name|String
name|sql1
init|=
literal|"select JOINEDAT from \"DATE\"\n"
operator|+
literal|"where JOINEDAT is not null"
decl_stmt|;
specifier|final
name|ResultSet
name|joinedAt
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// time
specifier|final
name|String
name|sql2
init|=
literal|"select JOINTIME from \"DATE\"\n"
operator|+
literal|"where JOINTIME is not null"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTime
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|valueOf
argument_list|(
literal|"00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// timestamp
specifier|final
name|String
name|sql3
init|=
literal|"select JOINTIMES from \"DATE\"\n"
operator|+
literal|"where JOINTIMES is not null"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql3
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1427">[CALCITE-1427]    * Code generation incorrect (does not compile) for DATE, TIME and TIMESTAMP    * fields</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testGreaterThanFilterOnDateType
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// date
specifier|final
name|String
name|sql1
init|=
literal|"select JOINEDAT from \"DATE\"\n"
operator|+
literal|"where JOINEDAT> {d '1990-01-01'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinedAt
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// time
specifier|final
name|String
name|sql2
init|=
literal|"select JOINTIME from \"DATE\"\n"
operator|+
literal|"where JOINTIME> {t '00:00:00'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTime
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|valueOf
argument_list|(
literal|"00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// timestamp
specifier|final
name|String
name|sql3
init|=
literal|"select JOINTIMES from \"DATE\"\n"
operator|+
literal|"where JOINTIMES> {ts '1990-01-01 00:00:00'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql3
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Disabled
argument_list|(
literal|"CALCITE-1894: there's a bug in the test code, so it does not test what it should"
argument_list|)
annotation|@
name|Test
annotation|@
name|Timeout
argument_list|(
literal|10
argument_list|)
specifier|public
name|void
name|testCsvStream
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|File
name|file
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"stream"
argument_list|,
literal|"csv"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|model
init|=
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"  defaultSchema: 'STREAM',\n"
operator|+
literal|"  schemas: [\n"
operator|+
literal|"    {\n"
operator|+
literal|"      name: 'SS',\n"
operator|+
literal|"      tables: [\n"
operator|+
literal|"        {\n"
operator|+
literal|"          name: 'DEPTS',\n"
operator|+
literal|"          type: 'custom',\n"
operator|+
literal|"          factory: '"
operator|+
name|CsvStreamTableFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"          stream: {\n"
operator|+
literal|"            stream: true\n"
operator|+
literal|"          },\n"
operator|+
literal|"          operand: {\n"
operator|+
literal|"            file: "
operator|+
name|escapeString
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
operator|+
literal|",\n"
operator|+
literal|"            flavor: \"scannable\"\n"
operator|+
literal|"          }\n"
operator|+
literal|"        }\n"
operator|+
literal|"      ]\n"
operator|+
literal|"    }\n"
operator|+
literal|"  ]\n"
operator|+
literal|"}\n"
decl_stmt|;
specifier|final
name|String
index|[]
name|strings
init|=
block|{
literal|"DEPTNO:int,NAME:string"
block|,
literal|"10,\"Sales\""
block|,
literal|"20,\"Marketing\""
block|,
literal|"30,\"Engineering\""
block|}
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:model=inline:"
operator|+
name|model
argument_list|)
init|;
name|PrintWriter
name|pw
init|=
name|Util
operator|.
name|printWriter
argument_list|(
name|file
argument_list|)
init|;
name|Worker
argument_list|<
name|Void
argument_list|>
name|worker
init|=
operator|new
name|Worker
argument_list|<>
argument_list|()
init|)
block|{
specifier|final
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
name|worker
argument_list|)
decl_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Add some rows so that the table can deduce its row type.
specifier|final
name|Iterator
argument_list|<
name|String
argument_list|>
name|lines
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|strings
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|pw
operator|.
name|println
argument_list|(
name|lines
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
comment|// header
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
name|worker
operator|.
name|queue
operator|.
name|put
argument_list|(
name|writeLine
argument_list|(
name|pw
argument_list|,
name|lines
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// first row
name|worker
operator|.
name|queue
operator|.
name|put
argument_list|(
name|writeLine
argument_list|(
name|pw
argument_list|,
name|lines
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// second row
specifier|final
name|CalciteConnection
name|calciteConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select stream * from \"SS\".\"DEPTS\""
decl_stmt|;
specifier|final
name|PreparedStatement
name|statement
init|=
name|calciteConnection
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
try|try
block|{
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|lines
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|worker
operator|.
name|queue
operator|.
name|put
argument_list|(
name|sleep
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|worker
operator|.
name|queue
operator|.
name|put
argument_list|(
name|writeLine
argument_list|(
name|pw
argument_list|,
name|lines
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|worker
operator|.
name|queue
operator|.
name|put
argument_list|(
name|cancel
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fail
argument_list|(
literal|"expected exception, got end of data"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Statement canceled"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|count
argument_list|,
name|anyOf
argument_list|(
name|is
argument_list|(
name|strings
operator|.
name|length
operator|-
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
name|strings
operator|.
name|length
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|worker
operator|.
name|e
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|worker
operator|.
name|v
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|Util
operator|.
name|discard
argument_list|(
name|file
operator|.
name|delete
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Creates a command that appends a line to the CSV file. */
specifier|private
name|Callable
argument_list|<
name|Void
argument_list|>
name|writeLine
parameter_list|(
specifier|final
name|PrintWriter
name|pw
parameter_list|,
specifier|final
name|String
name|line
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
block|{
name|pw
operator|.
name|println
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|;
block|}
comment|/** Creates a command that sleeps. */
specifier|private
name|Callable
argument_list|<
name|Void
argument_list|>
name|sleep
parameter_list|(
specifier|final
name|long
name|millis
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|millis
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|;
block|}
comment|/** Creates a command that cancels a statement. */
specifier|private
name|Callable
argument_list|<
name|Void
argument_list|>
name|cancel
parameter_list|(
specifier|final
name|Statement
name|statement
parameter_list|)
block|{
return|return
parameter_list|()
lambda|->
block|{
name|statement
operator|.
name|cancel
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
return|;
block|}
specifier|private
name|Void
name|output
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
block|{
try|try
block|{
name|output
argument_list|(
name|resultSet
argument_list|,
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Receives commands on a queue and executes them on its own thread.    * Call {@link #close} to terminate.    *    * @param<E> Result value of commands    */
specifier|private
specifier|static
class|class
name|Worker
parameter_list|<
name|E
parameter_list|>
implements|implements
name|Runnable
implements|,
name|AutoCloseable
block|{
comment|/** Queue of commands. */
specifier|final
name|BlockingQueue
argument_list|<
name|Callable
argument_list|<
name|E
argument_list|>
argument_list|>
name|queue
init|=
operator|new
name|ArrayBlockingQueue
argument_list|<>
argument_list|(
literal|5
argument_list|)
decl_stmt|;
comment|/** Value returned by the most recent command. */
specifier|private
name|E
name|v
decl_stmt|;
comment|/** Exception thrown by a command or queue wait. */
specifier|private
name|Exception
name|e
decl_stmt|;
comment|/** The poison pill command. */
specifier|final
name|Callable
argument_list|<
name|E
argument_list|>
name|end
init|=
parameter_list|()
lambda|->
literal|null
decl_stmt|;
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|Callable
argument_list|<
name|E
argument_list|>
name|c
init|=
name|queue
operator|.
name|take
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|end
condition|)
block|{
return|return;
block|}
name|this
operator|.
name|v
operator|=
name|c
operator|.
name|call
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|this
operator|.
name|e
operator|=
name|e
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|queue
operator|.
name|put
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
comment|/** Fluent API to perform test actions. */
specifier|private
class|class
name|Fluent
block|{
specifier|private
specifier|final
name|String
name|model
decl_stmt|;
specifier|private
specifier|final
name|String
name|sql
decl_stmt|;
specifier|private
specifier|final
name|Consumer
argument_list|<
name|ResultSet
argument_list|>
name|expect
decl_stmt|;
name|Fluent
parameter_list|(
name|String
name|model
parameter_list|,
name|String
name|sql
parameter_list|,
name|Consumer
argument_list|<
name|ResultSet
argument_list|>
name|expect
parameter_list|)
block|{
name|this
operator|.
name|model
operator|=
name|model
expr_stmt|;
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
name|this
operator|.
name|expect
operator|=
name|expect
expr_stmt|;
block|}
comment|/** Runs the test. */
name|Fluent
name|ok
parameter_list|()
block|{
try|try
block|{
name|checkSql
argument_list|(
name|sql
argument_list|,
name|model
argument_list|,
name|expect
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Assigns a function to call to test whether output is correct. */
name|Fluent
name|checking
parameter_list|(
name|Consumer
argument_list|<
name|ResultSet
argument_list|>
name|expect
parameter_list|)
block|{
return|return
operator|new
name|Fluent
argument_list|(
name|model
argument_list|,
name|sql
argument_list|,
name|expect
argument_list|)
return|;
block|}
comment|/** Sets the rows that are expected to be returned from the SQL query. */
name|Fluent
name|returns
parameter_list|(
name|String
modifier|...
name|expectedLines
parameter_list|)
block|{
return|return
name|checking
argument_list|(
name|expect
argument_list|(
name|expectedLines
argument_list|)
argument_list|)
return|;
block|}
comment|/** Sets the rows that are expected to be returned from the SQL query,      * in no particular order. */
name|Fluent
name|returnsUnordered
parameter_list|(
name|String
modifier|...
name|expectedLines
parameter_list|)
block|{
return|return
name|checking
argument_list|(
name|expectUnordered
argument_list|(
name|expectedLines
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

