begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|file
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlToRelConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Disabled
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|extension
operator|.
name|ExtendWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|params
operator|.
name|ParameterizedTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|params
operator|.
name|provider
operator|.
name|MethodSource
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DriverManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|file
operator|.
name|FileAdapterTests
operator|.
name|sql
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|isA
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertFalse
import|;
end_import

begin_comment
comment|/**  * System test of the Calcite file adapter, which can read and parse  * HTML tables over HTTP, and also read CSV and JSON files from the filesystem.  */
end_comment

begin_class
annotation|@
name|ExtendWith
argument_list|(
name|RequiresNetworkExtension
operator|.
name|class
argument_list|)
class|class
name|FileAdapterTest
block|{
specifier|static
name|Stream
argument_list|<
name|String
argument_list|>
name|explainFormats
parameter_list|()
block|{
return|return
name|Stream
operator|.
name|of
argument_list|(
literal|"text"
argument_list|,
literal|"dot"
argument_list|)
return|;
block|}
comment|/** Reads from a local file and checks the result. */
annotation|@
name|Test
name|void
name|testFileSelect
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select H1 from T1 where H0 = 'R1C0'"
decl_stmt|;
name|sql
argument_list|(
literal|"testModel"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"H1=R1C1"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads from a local file without table headers&lt;TH&gt; and checks the    * result. */
annotation|@
name|Test
annotation|@
name|RequiresNetwork
name|void
name|testNoThSelect
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select \"col1\" from T1_NO_TH where \"col0\" like 'R0%'"
decl_stmt|;
name|sql
argument_list|(
literal|"testModel"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"col1=R0C1"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads from a local file - finds larger table even without&lt;TH&gt;    * elements. */
annotation|@
name|Test
name|void
name|testFindBiggerNoTh
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select \"col4\" from TABLEX2 where \"col0\" like 'R1%'"
decl_stmt|;
name|sql
argument_list|(
literal|"testModel"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"col4=R1C4"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads from a URL and checks the result. */
annotation|@
name|Disabled
argument_list|(
literal|"[CALCITE-1789] Wikipedia format change breaks file adapter test"
argument_list|)
annotation|@
name|Test
annotation|@
name|RequiresNetwork
name|void
name|testUrlSelect
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select \"State\", \"Statehood\" from \"States_as_of\"\n"
operator|+
literal|"where \"State\" = 'California'"
decl_stmt|;
name|sql
argument_list|(
literal|"wiki"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"State=California; Statehood=1850-09-09"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the EMPS table. */
annotation|@
name|Test
name|void
name|testSalesEmps
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emps"
decl_stmt|;
name|sql
argument_list|(
literal|"sales"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=100; NAME=Fred; DEPTNO=30"
argument_list|,
literal|"EMPNO=110; NAME=Eric; DEPTNO=20"
argument_list|,
literal|"EMPNO=110; NAME=John; DEPTNO=40"
argument_list|,
literal|"EMPNO=120; NAME=Wilma; DEPTNO=20"
argument_list|,
literal|"EMPNO=130; NAME=Alice; DEPTNO=40"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the DEPTS table. */
annotation|@
name|Test
name|void
name|testSalesDepts
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.depts"
decl_stmt|;
name|sql
argument_list|(
literal|"sales"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"DEPTNO=10; NAME=Sales"
argument_list|,
literal|"DEPTNO=20; NAME=Marketing"
argument_list|,
literal|"DEPTNO=30; NAME=Accounts"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the DEPTS table from the CSV schema. */
annotation|@
name|Test
name|void
name|testCsvSalesDepts
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.depts"
decl_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"DEPTNO=10; NAME=Sales"
argument_list|,
literal|"DEPTNO=20; NAME=Marketing"
argument_list|,
literal|"DEPTNO=30; NAME=Accounts"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the EMPS table from the CSV schema. */
annotation|@
name|Test
name|void
name|testCsvSalesEmps
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emps"
decl_stmt|;
specifier|final
name|String
index|[]
name|lines
init|=
block|{
literal|"EMPNO=100; NAME=Fred; DEPTNO=10; GENDER=; CITY=; EMPID=30; AGE=25; SLACKER=true; MANAGER=false; JOINEDAT=1996-08-03"
block|,
literal|"EMPNO=110; NAME=Eric; DEPTNO=20; GENDER=M; CITY=San Francisco; EMPID=3; AGE=80; SLACKER=null; MANAGER=false; JOINEDAT=2001-01-01"
block|,
literal|"EMPNO=110; NAME=John; DEPTNO=40; GENDER=M; CITY=Vancouver; EMPID=2; AGE=null; SLACKER=false; MANAGER=true; JOINEDAT=2002-05-03"
block|,
literal|"EMPNO=120; NAME=Wilma; DEPTNO=20; GENDER=F; CITY=; EMPID=1; AGE=5; SLACKER=null; MANAGER=true; JOINEDAT=2005-09-07"
block|,
literal|"EMPNO=130; NAME=Alice; DEPTNO=40; GENDER=F; CITY=Vancouver; EMPID=2; AGE=null; SLACKER=false; MANAGER=true; JOINEDAT=2007-01-01"
block|,     }
decl_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|lines
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the HEADER_ONLY table from the CSV schema. The CSV file has one    * line - the column headers - but no rows of data. */
annotation|@
name|Test
name|void
name|testCsvSalesHeaderOnly
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.header_only"
decl_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|()
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the EMPTY table from the CSV schema. The CSV file has no lines,    * therefore the table has a system-generated column called    * "EmptyFileHasNoColumns". */
annotation|@
name|Test
name|void
name|testCsvSalesEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.\"EMPTY\""
decl_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
name|sql
argument_list|)
operator|.
name|checking
argument_list|(
name|FileAdapterTest
operator|::
name|checkEmpty
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|checkEmpty
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
block|{
try|try
block|{
specifier|final
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnCount
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnName
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"EmptyFileHasNoColumns"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnType
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Types
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|actual
init|=
name|FileAdapterTests
operator|.
name|toString
argument_list|(
name|resultSet
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|actual
argument_list|,
name|is
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1754">[CALCITE-1754]    * In Csv adapter, convert DATE and TIME values to int, and TIMESTAMP values    * to long</a>. */
annotation|@
name|Test
name|void
name|testCsvGroupByTimestampAdd
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c,\n"
operator|+
literal|"  {fn timestampadd(SQL_TSI_DAY, 1, JOINEDAT) } as t\n"
operator|+
literal|"from EMPS group by {fn timestampadd(SQL_TSI_DAY, 1, JOINEDAT ) } "
decl_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
name|sql
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"C=1; T=1996-08-04"
argument_list|,
literal|"C=1; T=2002-05-04"
argument_list|,
literal|"C=1; T=2005-09-08"
argument_list|,
literal|"C=1; T=2007-01-02"
argument_list|,
literal|"C=1; T=2001-01-02"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
specifier|final
name|String
name|sql2
init|=
literal|"select count(*) as c,\n"
operator|+
literal|"  {fn timestampadd(SQL_TSI_MONTH, 1, JOINEDAT) } as t\n"
operator|+
literal|"from EMPS group by {fn timestampadd(SQL_TSI_MONTH, 1, JOINEDAT ) } "
decl_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
name|sql2
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"C=1; T=2002-06-03"
argument_list|,
literal|"C=1; T=2005-10-07"
argument_list|,
literal|"C=1; T=2007-02-01"
argument_list|,
literal|"C=1; T=2001-02-01"
argument_list|,
literal|"C=1; T=1996-09-03"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
specifier|final
name|String
name|sql3
init|=
literal|"select\n"
operator|+
literal|" distinct {fn timestampadd(SQL_TSI_MONTH, 1, JOINEDAT) } as t\n"
operator|+
literal|"from EMPS"
decl_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
name|sql3
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"T=2002-06-03"
argument_list|,
literal|"T=2005-10-07"
argument_list|,
literal|"T=2007-02-01"
argument_list|,
literal|"T=2001-02-01"
argument_list|,
literal|"T=1996-09-03"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the DEPTS table from the JSON schema. */
annotation|@
name|Test
name|void
name|testJsonSalesDepts
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.depts"
decl_stmt|;
name|sql
argument_list|(
literal|"sales-json"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"DEPTNO=10; NAME=Sales"
argument_list|,
literal|"DEPTNO=20; NAME=Marketing"
argument_list|,
literal|"DEPTNO=30; NAME=Accounts"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the EMPS table from the JSON schema. */
annotation|@
name|Test
name|void
name|testJsonSalesEmps
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emps"
decl_stmt|;
specifier|final
name|String
index|[]
name|lines
init|=
block|{
literal|"EMPNO=100; NAME=Fred; DEPTNO=10; GENDER=; CITY=; EMPID=30; AGE=25; SLACKER=true; MANAGER=false; JOINEDAT=1996-08-03"
block|,
literal|"EMPNO=110; NAME=Eric; DEPTNO=20; GENDER=M; CITY=San Francisco; EMPID=3; AGE=80; SLACKER=null; MANAGER=false; JOINEDAT=2001-01-01"
block|,
literal|"EMPNO=110; NAME=John; DEPTNO=40; GENDER=M; CITY=Vancouver; EMPID=2; AGE=null; SLACKER=false; MANAGER=true; JOINEDAT=2002-05-03"
block|,
literal|"EMPNO=120; NAME=Wilma; DEPTNO=20; GENDER=F; CITY=; EMPID=1; AGE=5; SLACKER=null; MANAGER=true; JOINEDAT=2005-09-07"
block|,
literal|"EMPNO=130; NAME=Alice; DEPTNO=40; GENDER=F; CITY=Vancouver; EMPID=2; AGE=null; SLACKER=false; MANAGER=true; JOINEDAT=2007-01-01"
block|,     }
decl_stmt|;
name|sql
argument_list|(
literal|"sales-json"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|lines
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Reads the EMPTY table from the JSON schema. The JSON file has no lines,    * therefore the table has a system-generated column called    * "EmptyFileHasNoColumns". */
annotation|@
name|Test
name|void
name|testJsonSalesEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.\"EMPTY\""
decl_stmt|;
name|sql
argument_list|(
literal|"sales-json"
argument_list|,
name|sql
argument_list|)
operator|.
name|checking
argument_list|(
name|FileAdapterTest
operator|::
name|checkEmpty
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test returns the result of two json file joins. */
annotation|@
name|Test
name|void
name|testJsonJoinOnString
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select emps.EMPNO, emps.NAME, depts.deptno from emps\n"
operator|+
literal|"join depts on emps.deptno = depts.deptno"
decl_stmt|;
specifier|final
name|String
index|[]
name|lines
init|=
block|{
literal|"EMPNO=100; NAME=Fred; DEPTNO=10"
block|,
literal|"EMPNO=110; NAME=Eric; DEPTNO=20"
block|,
literal|"EMPNO=120; NAME=Wilma; DEPTNO=20"
block|,     }
decl_stmt|;
name|sql
argument_list|(
literal|"sales-json"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|lines
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** The folder contains both JSON files and CSV files joins. */
annotation|@
name|Test
name|void
name|testJsonWithCsvJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select emps.empno,\n"
operator|+
literal|" NAME,\n"
operator|+
literal|" \"DATE\".JOINEDAT\n"
operator|+
literal|" from \"DATE\"\n"
operator|+
literal|"join emps on emps.empno = \"DATE\".EMPNO\n"
operator|+
literal|"order by empno, name, joinedat limit 3"
decl_stmt|;
specifier|final
name|String
index|[]
name|lines
init|=
block|{
literal|"EMPNO=100; NAME=Fred; JOINEDAT=1996-08-03"
block|,
literal|"EMPNO=110; NAME=Eric; JOINEDAT=2001-01-01"
block|,
literal|"EMPNO=110; NAME=Eric; JOINEDAT=2002-05-03"
block|,     }
decl_stmt|;
name|sql
argument_list|(
literal|"sales-json"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|lines
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Tests an inline schema with a non-existent directory. */
annotation|@
name|Test
name|void
name|testBadDirectory
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
literal|"inline:"
operator|+
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       type: 'custom',\n"
operator|+
literal|"       name: 'bad',\n"
operator|+
literal|"       factory: 'org.apache.calcite.adapter.file.FileSchemaFactory',\n"
operator|+
literal|"       operand: {\n"
operator|+
literal|"         directory: '/does/not/exist'\n"
operator|+
literal|"       }\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
expr_stmt|;
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
decl_stmt|;
comment|// must print "directory ... not found" to stdout, but not fail
name|ResultSet
name|tables
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getTables
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tables
operator|.
name|next
argument_list|()
expr_stmt|;
name|tables
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Reads from a table.    */
annotation|@
name|Test
name|void
name|testSelect
parameter_list|()
block|{
name|sql
argument_list|(
literal|"model"
argument_list|,
literal|"select * from EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSelectSingleProjectGz
parameter_list|()
block|{
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"select name from EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSelectSingleProject
parameter_list|()
block|{
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"select name from DEPTS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-898">[CALCITE-898]    * Type inference multiplying Java long by SQL INTEGER</a>. */
annotation|@
name|Test
name|void
name|testSelectLongMultiplyInteger
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno * 3 as e3\n"
operator|+
literal|"from long_emps where empno = 100"
decl_stmt|;
name|sql
argument_list|(
literal|"bug"
argument_list|,
name|sql
argument_list|)
operator|.
name|checking
argument_list|(
name|resultSet
lambda|->
block|{
try|try
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|Long
name|o
init|=
operator|(
name|Long
operator|)
name|resultSet
operator|.
name|getObject
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|o
argument_list|,
name|is
argument_list|(
literal|300L
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testCustomTable
parameter_list|()
block|{
name|sql
argument_list|(
literal|"model-with-custom-table"
argument_list|,
literal|"select * from CUSTOM_TABLE.EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPushDownProject
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"explain plan for select * from EMPS"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"PLAN=CsvTableScan(table=[[SALES, EMPS]], "
operator|+
literal|"fields=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]])\n"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPushDownProject2
parameter_list|()
block|{
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"explain plan for select name, empno from EMPS"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"PLAN=CsvTableScan(table=[[SALES, EMPS]], fields=[[1, 0]])\n"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
comment|// make sure that it works...
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"select name, empno from EMPS"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Fred; EMPNO=100"
argument_list|,
literal|"NAME=Eric; EMPNO=110"
argument_list|,
literal|"NAME=John; EMPNO=110"
argument_list|,
literal|"NAME=Wilma; EMPNO=120"
argument_list|,
literal|"NAME=Alice; EMPNO=130"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|ParameterizedTest
annotation|@
name|MethodSource
argument_list|(
literal|"explainFormats"
argument_list|)
name|void
name|testPushDownProjectAggregate
parameter_list|(
name|String
name|format
parameter_list|)
block|{
name|String
name|expected
init|=
literal|null
decl_stmt|;
name|String
name|extra
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|"dot"
case|:
name|expected
operator|=
literal|"PLAN=digraph {\n"
operator|+
literal|"\"CsvTableScan\\ntable = [SALES, EMPS\\n]\\nfields = [3]\\n\" -> "
operator|+
literal|"\"EnumerableAggregate\\ngroup = {0}\\nEXPR$1 = COUNT()\\n\" [label=\"0\"]\n"
operator|+
literal|"}\n"
expr_stmt|;
name|extra
operator|=
literal|" as dot "
expr_stmt|;
break|break;
case|case
literal|"text"
case|:
name|expected
operator|=
literal|"PLAN="
operator|+
literal|"EnumerableAggregate(group=[{0}], EXPR$1=[COUNT()])\n"
operator|+
literal|"  CsvTableScan(table=[[SALES, EMPS]], fields=[[3]])\n"
expr_stmt|;
name|extra
operator|=
literal|""
expr_stmt|;
break|break;
block|}
specifier|final
name|String
name|sql
init|=
literal|"explain plan "
operator|+
name|extra
operator|+
literal|" for\n"
operator|+
literal|"select gender, count(*) from EMPS group by gender"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|ParameterizedTest
annotation|@
name|MethodSource
argument_list|(
literal|"explainFormats"
argument_list|)
name|void
name|testPushDownProjectAggregateWithFilter
parameter_list|(
name|String
name|format
parameter_list|)
block|{
name|String
name|expected
init|=
literal|null
decl_stmt|;
name|String
name|extra
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|"dot"
case|:
name|expected
operator|=
literal|"PLAN=digraph {\n"
operator|+
literal|"\"EnumerableCalc\\nexpr#0..1 = {inputs}\\nexpr#2 = 'F':VARCHAR\\nexpr#3 = =($t1, $t2)"
operator|+
literal|"\\nproj#0..1 = {exprs}\\n$condition = $t3\" -> \"EnumerableAggregate\\ngroup = "
operator|+
literal|"{}\\nEXPR$0 = MAX($0)\\n\" [label=\"0\"]\n"
operator|+
literal|"\"CsvTableScan\\ntable = [SALES, EMPS\\n]\\nfields = [0, 3]\\n\" -> "
operator|+
literal|"\"EnumerableCalc\\nexpr#0..1 = {inputs}\\nexpr#2 = 'F':VARCHAR\\nexpr#3 = =($t1, $t2)"
operator|+
literal|"\\nproj#0..1 = {exprs}\\n$condition = $t3\" [label=\"0\"]\n"
operator|+
literal|"}\n"
expr_stmt|;
name|extra
operator|=
literal|" as dot "
expr_stmt|;
break|break;
case|case
literal|"text"
case|:
name|expected
operator|=
literal|"PLAN="
operator|+
literal|"EnumerableAggregate(group=[{}], EXPR$0=[MAX($0)])\n"
operator|+
literal|"  EnumerableCalc(expr#0..1=[{inputs}], expr#2=['F':VARCHAR], "
operator|+
literal|"expr#3=[=($t1, $t2)], proj#0..1=[{exprs}], $condition=[$t3])\n"
operator|+
literal|"    CsvTableScan(table=[[SALES, EMPS]], fields=[[0, 3]])\n"
expr_stmt|;
name|extra
operator|=
literal|""
expr_stmt|;
break|break;
block|}
specifier|final
name|String
name|sql
init|=
literal|"explain plan "
operator|+
name|extra
operator|+
literal|" for\n"
operator|+
literal|"select max(empno) from EMPS where gender='F'"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|ParameterizedTest
annotation|@
name|MethodSource
argument_list|(
literal|"explainFormats"
argument_list|)
name|void
name|testPushDownProjectAggregateNested
parameter_list|(
name|String
name|format
parameter_list|)
block|{
name|String
name|expected
init|=
literal|null
decl_stmt|;
name|String
name|extra
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|"dot"
case|:
name|expected
operator|=
literal|"PLAN=digraph {\n"
operator|+
literal|"\"EnumerableAggregate\\ngroup = {0, 1}\\nQTY = COUNT()\\n\" -> "
operator|+
literal|"\"EnumerableAggregate\\ngroup = {1}\\nEXPR$1 = MAX($2)\\n\" [label=\"0\"]\n"
operator|+
literal|"\"CsvTableScan\\ntable = [SALES, EMPS\\n]\\nfields = [1, 3]\\n\" -> "
operator|+
literal|"\"EnumerableAggregate\\ngroup = {0, 1}\\nQTY = COUNT()\\n\" [label=\"0\"]\n"
operator|+
literal|"}\n"
expr_stmt|;
name|extra
operator|=
literal|" as dot "
expr_stmt|;
break|break;
case|case
literal|"text"
case|:
name|expected
operator|=
literal|"PLAN="
operator|+
literal|"EnumerableAggregate(group=[{1}], EXPR$1=[MAX($2)])\n"
operator|+
literal|"  EnumerableAggregate(group=[{0, 1}], QTY=[COUNT()])\n"
operator|+
literal|"    CsvTableScan(table=[[SALES, EMPS]], fields=[[1, 3]])\n"
expr_stmt|;
name|extra
operator|=
literal|""
expr_stmt|;
break|break;
block|}
specifier|final
name|String
name|sql
init|=
literal|"explain plan "
operator|+
name|extra
operator|+
literal|" for\n"
operator|+
literal|"select gender, max(qty)\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select name, gender, count(*) qty\n"
operator|+
literal|"  from EMPS\n"
operator|+
literal|"  group by name, gender) t\n"
operator|+
literal|"group by gender"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testFilterableSelect
parameter_list|()
block|{
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
literal|"select name from EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testFilterableSelectStar
parameter_list|()
block|{
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
literal|"select * from EMPS"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Filter that can be fully handled by CsvFilterableTable. */
annotation|@
name|Test
name|void
name|testFilterableWhere
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, gender, name from EMPS where name = 'John'"
decl_stmt|;
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=110; GENDER=M; NAME=John"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Filter that can be partly handled by CsvFilterableTable. */
annotation|@
name|Test
name|void
name|testFilterableWhere2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, gender, name from EMPS\n"
operator|+
literal|" where gender = 'F' and empno> 125"
decl_stmt|;
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=130; GENDER=F; NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Filter that can be slightly handled by CsvFilterableTable. */
annotation|@
name|Test
name|void
name|testFilterableWhere3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, gender, name from EMPS\n"
operator|+
literal|" where gender<> 'M' and empno> 125"
decl_stmt|;
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=130; GENDER=F; NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2272">[CALCITE-2272]    * Incorrect result for {@code name like '%E%' and city not like '%W%'}</a>.    */
annotation|@
name|Test
name|void
name|testFilterableWhereWithNot1
parameter_list|()
block|{
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
literal|"select name, empno from EMPS "
operator|+
literal|"where name like '%E%' and city not like '%W%' "
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Eric; EMPNO=110"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Similar to {@link #testFilterableWhereWithNot1()};    * But use the same column. */
annotation|@
name|Test
name|void
name|testFilterableWhereWithNot2
parameter_list|()
block|{
name|sql
argument_list|(
literal|"filterable-model"
argument_list|,
literal|"select name, empno from EMPS "
operator|+
literal|"where name like '%i%' and name not like '%W%' "
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Eric; EMPNO=110"
argument_list|,
literal|"NAME=Alice; EMPNO=130"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testJson
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from archers\n"
decl_stmt|;
specifier|final
name|String
index|[]
name|lines
init|=
block|{
literal|"id=19990101; dow=Friday; longDate=New Years Day; title=Tractor trouble.; "
operator|+
literal|"characters=[Alice, Bob, Xavier]; script=Julian Hyde; summary=; "
operator|+
literal|"lines=[Bob's tractor got stuck in a field., "
operator|+
literal|"Alice and Xavier hatch a plan to surprise Charlie.]"
block|,
literal|"id=19990103; dow=Sunday; longDate=Sunday 3rd January; "
operator|+
literal|"title=Charlie's surprise.; characters=[Alice, Zebedee, Charlie, Xavier]; "
operator|+
literal|"script=William Shakespeare; summary=; "
operator|+
literal|"lines=[Charlie is very surprised by Alice and Xavier's surprise plan.]"
block|,     }
decl_stmt|;
name|sql
argument_list|(
literal|"bug"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
name|lines
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testJoinOnString
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emps\n"
operator|+
literal|"join depts on emps.name = depts.name"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testWackyColumns
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from wacky_column_names where false"
decl_stmt|;
name|sql
argument_list|(
literal|"bug"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|()
operator|.
name|ok
argument_list|()
expr_stmt|;
specifier|final
name|String
name|sql2
init|=
literal|"select \"joined at\", \"naME\"\n"
operator|+
literal|"from wacky_column_names\n"
operator|+
literal|"where \"2gender\" = 'F'"
decl_stmt|;
name|sql
argument_list|(
literal|"bug"
argument_list|,
name|sql2
argument_list|)
operator|.
name|returns
argument_list|(
literal|"joined at=2005-09-07; naME=Wilma"
argument_list|,
literal|"joined at=2007-01-01; naME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1754">[CALCITE-1754]    * In Csv adapter, convert DATE and TIME values to int, and TIMESTAMP values    * to long</a>. */
annotation|@
name|Test
name|void
name|testGroupByTimestampAdd
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c,\n"
operator|+
literal|"  {fn timestampadd(SQL_TSI_DAY, 1, JOINEDAT) } as t\n"
operator|+
literal|"from EMPS group by {fn timestampadd(SQL_TSI_DAY, 1, JOINEDAT ) } "
decl_stmt|;
name|sql
argument_list|(
literal|"model"
argument_list|,
name|sql
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"C=1; T=1996-08-04"
argument_list|,
literal|"C=1; T=2002-05-04"
argument_list|,
literal|"C=1; T=2005-09-08"
argument_list|,
literal|"C=1; T=2007-01-02"
argument_list|,
literal|"C=1; T=2001-01-02"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
specifier|final
name|String
name|sql2
init|=
literal|"select count(*) as c,\n"
operator|+
literal|"  {fn timestampadd(SQL_TSI_MONTH, 1, JOINEDAT) } as t\n"
operator|+
literal|"from EMPS group by {fn timestampadd(SQL_TSI_MONTH, 1, JOINEDAT ) } "
decl_stmt|;
name|sql
argument_list|(
literal|"model"
argument_list|,
name|sql2
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"C=1; T=2002-06-03"
argument_list|,
literal|"C=1; T=2005-10-07"
argument_list|,
literal|"C=1; T=2007-02-01"
argument_list|,
literal|"C=1; T=2001-02-01"
argument_list|,
literal|"C=1; T=1996-09-03"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testUnionGroupByWithoutGroupKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c1 from EMPS group by NAME\n"
operator|+
literal|"union\n"
operator|+
literal|"select count(*) as c1 from EMPS group by NAME"
decl_stmt|;
name|sql
argument_list|(
literal|"model"
argument_list|,
name|sql
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testBoolean
parameter_list|()
block|{
name|sql
argument_list|(
literal|"smart"
argument_list|,
literal|"select empno, slacker from emps where slacker"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=100; SLACKER=true"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testReadme
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT d.name, COUNT(*) cnt"
operator|+
literal|" FROM emps AS e"
operator|+
literal|" JOIN depts AS d ON e.deptno = d.deptno"
operator|+
literal|" GROUP BY d.name"
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Sales; CNT=1"
argument_list|,
literal|"NAME=Marketing; CNT=2"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-824">[CALCITE-824]    * Type inference when converting IN clause to semijoin</a>. */
annotation|@
name|Test
name|void
name|testInToSemiJoinWithCast
parameter_list|()
block|{
comment|// Note that the IN list needs at least 20 values to trigger the rewrite
comment|// to a semijoin. Try it both ways.
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.name\n"
operator|+
literal|"FROM emps AS e\n"
operator|+
literal|"WHERE cast(e.empno as bigint) in "
decl_stmt|;
specifier|final
name|int
name|threshold
init|=
name|SqlToRelConverter
operator|.
name|DEFAULT_IN_SUB_QUERY_THRESHOLD
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
operator|+
name|range
argument_list|(
literal|130
argument_list|,
name|threshold
operator|-
literal|5
argument_list|)
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
operator|+
name|range
argument_list|(
literal|130
argument_list|,
name|threshold
argument_list|)
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
operator|+
name|range
argument_list|(
literal|130
argument_list|,
name|threshold
operator|+
literal|1000
argument_list|)
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1051">[CALCITE-1051]    * Underflow exception due to scaling IN clause literals</a>. */
annotation|@
name|Test
name|void
name|testInToSemiJoinWithoutCast
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.name\n"
operator|+
literal|"FROM emps AS e\n"
operator|+
literal|"WHERE e.empno in "
operator|+
name|range
argument_list|(
literal|130
argument_list|,
name|SqlToRelConverter
operator|.
name|DEFAULT_IN_SUB_QUERY_THRESHOLD
argument_list|)
decl_stmt|;
name|sql
argument_list|(
literal|"smart"
argument_list|,
name|sql
argument_list|)
operator|.
name|returns
argument_list|(
literal|"NAME=Alice"
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
specifier|private
name|String
name|range
parameter_list|(
name|int
name|first
parameter_list|,
name|int
name|count
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|"("
else|:
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|first
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Test
name|void
name|testDecimalType
parameter_list|()
block|{
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
literal|"select BUDGET from sales.\"DECIMAL\""
argument_list|)
operator|.
name|checking
argument_list|(
name|resultSet
lambda|->
block|{
try|try
block|{
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"DECIMAL"
argument_list|,
name|metaData
operator|.
name|getColumnTypeName
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|18
argument_list|,
name|metaData
operator|.
name|getPrecision
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|metaData
operator|.
name|getScale
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDecimalTypeArithmeticOperations
parameter_list|()
block|{
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
literal|"select BUDGET + 100.0 from sales.\"DECIMAL\" where DEPTNO = 10"
argument_list|)
operator|.
name|checking
argument_list|(
name|resultSet
lambda|->
block|{
try|try
block|{
name|resultSet
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resultSet
operator|.
name|getBigDecimal
argument_list|(
literal|1
argument_list|)
operator|.
name|compareTo
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"200"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
literal|"select BUDGET - 100.0 from sales.\"DECIMAL\" where DEPTNO = 10"
argument_list|)
operator|.
name|checking
argument_list|(
name|resultSet
lambda|->
block|{
try|try
block|{
name|resultSet
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resultSet
operator|.
name|getBigDecimal
argument_list|(
literal|1
argument_list|)
operator|.
name|compareTo
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"0"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
literal|"select BUDGET * 0.01 from sales.\"DECIMAL\" where DEPTNO = 10"
argument_list|)
operator|.
name|checking
argument_list|(
name|resultSet
lambda|->
block|{
try|try
block|{
name|resultSet
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resultSet
operator|.
name|getBigDecimal
argument_list|(
literal|1
argument_list|)
operator|.
name|compareTo
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
name|sql
argument_list|(
literal|"sales-csv"
argument_list|,
literal|"select BUDGET / 100 from sales.\"DECIMAL\" where DEPTNO = 10"
argument_list|)
operator|.
name|checking
argument_list|(
name|resultSet
lambda|->
block|{
try|try
block|{
name|resultSet
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|resultSet
operator|.
name|getBigDecimal
argument_list|(
literal|1
argument_list|)
operator|.
name|compareTo
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"1"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
operator|.
name|ok
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDateType
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
name|ResultSet
name|res
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"DATE"
argument_list|,
literal|"JOINEDAT"
argument_list|)
decl_stmt|;
name|res
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|getInt
argument_list|(
literal|"DATA_TYPE"
argument_list|)
argument_list|,
name|Types
operator|.
name|DATE
argument_list|)
expr_stmt|;
name|res
operator|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"DATE"
argument_list|,
literal|"JOINTIME"
argument_list|)
expr_stmt|;
name|res
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|getInt
argument_list|(
literal|"DATA_TYPE"
argument_list|)
argument_list|,
name|Types
operator|.
name|TIME
argument_list|)
expr_stmt|;
name|res
operator|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"DATE"
argument_list|,
literal|"JOINTIMES"
argument_list|)
expr_stmt|;
name|res
operator|.
name|next
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|res
operator|.
name|getInt
argument_list|(
literal|"DATA_TYPE"
argument_list|)
argument_list|,
name|Types
operator|.
name|TIMESTAMP
argument_list|)
expr_stmt|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select \"JOINEDAT\", \"JOINTIME\", \"JOINTIMES\" from \"DATE\" where EMPNO = 100"
argument_list|)
decl_stmt|;
name|resultSet
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// date
name|assertEquals
argument_list|(
name|Date
operator|.
name|class
argument_list|,
name|resultSet
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03"
argument_list|)
argument_list|,
name|resultSet
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// time
name|assertEquals
argument_list|(
name|Time
operator|.
name|class
argument_list|,
name|resultSet
operator|.
name|getTime
argument_list|(
literal|2
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Time
operator|.
name|valueOf
argument_list|(
literal|"00:01:02"
argument_list|)
argument_list|,
name|resultSet
operator|.
name|getTime
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// timestamp
name|assertEquals
argument_list|(
name|Timestamp
operator|.
name|class
argument_list|,
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|3
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|,
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1072">[CALCITE-1072]    * CSV adapter incorrectly parses TIMESTAMP values after noon</a>. */
annotation|@
name|Test
name|void
name|testDateType2
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from \"DATE\"\n"
operator|+
literal|"where EMPNO>= 140 and EMPNO< 200"
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
specifier|final
name|int
name|empId
init|=
name|resultSet
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|date
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|String
name|time
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|String
name|timestamp
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|date
argument_list|,
name|is
argument_list|(
literal|"2015-12-31"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|empId
condition|)
block|{
case|case
literal|140
case|:
name|assertThat
argument_list|(
name|time
argument_list|,
name|is
argument_list|(
literal|"07:15:56"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
literal|"2015-12-31 07:15:56"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|150
case|:
name|assertThat
argument_list|(
name|time
argument_list|,
name|is
argument_list|(
literal|"13:31:21"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
literal|"2015-12-31 13:31:21"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
name|assertThat
argument_list|(
name|n
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1673">[CALCITE-1673]    * Query with ORDER BY or GROUP BY on TIMESTAMP column throws    * CompileException</a>. */
annotation|@
name|Test
name|void
name|testTimestampGroupBy
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Use LIMIT to ensure that results are deterministic without ORDER BY
specifier|final
name|String
name|sql
init|=
literal|"select \"EMPNO\", \"JOINTIMES\"\n"
operator|+
literal|"from (select * from \"DATE\" limit 1)\n"
operator|+
literal|"group by \"EMPNO\",\"JOINTIMES\""
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
init|)
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Timestamp
name|timestamp
init|=
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|isA
argument_list|(
name|Timestamp
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|// Note: This logic is time zone specific, but the same time zone is
comment|// used in the CSV adapter and this test, so they should cancel out.
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02.0"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** As {@link #testTimestampGroupBy()} but with ORDER BY. */
annotation|@
name|Test
name|void
name|testTimestampOrderBy
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select \"EMPNO\",\"JOINTIMES\" from \"DATE\"\n"
operator|+
literal|"order by \"JOINTIMES\""
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
init|)
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Timestamp
name|timestamp
init|=
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** As {@link #testTimestampGroupBy()} but with ORDER BY as well as GROUP    * BY. */
annotation|@
name|Test
name|void
name|testTimestampGroupByAndOrderBy
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select \"EMPNO\", \"JOINTIMES\" from \"DATE\"\n"
operator|+
literal|"group by \"EMPNO\",\"JOINTIMES\" order by \"JOINTIMES\""
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
init|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
init|)
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Timestamp
name|timestamp
init|=
name|resultSet
operator|.
name|getTimestamp
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|is
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1031">[CALCITE-1031]    * In prepared statement, CsvScannableTable.scan is called twice</a>. To see    * the bug, place a breakpoint in CsvScannableTable.scan, and note that it is    * called twice. It should only be called once. */
annotation|@
name|Test
name|void
name|testPrepared
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|properties
operator|.
name|setProperty
argument_list|(
literal|"caseSensitive"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|properties
argument_list|)
init|)
block|{
specifier|final
name|CalciteConnection
name|calciteConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|Schema
name|schema
init|=
name|FileSchemaFactory
operator|.
name|INSTANCE
operator|.
name|create
argument_list|(
name|calciteConnection
operator|.
name|getRootSchema
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"directory"
argument_list|,
name|FileAdapterTests
operator|.
name|resourcePath
argument_list|(
literal|"sales-csv"
argument_list|)
argument_list|,
literal|"flavor"
argument_list|,
literal|"scannable"
argument_list|)
argument_list|)
decl_stmt|;
name|calciteConnection
operator|.
name|getRootSchema
argument_list|()
operator|.
name|add
argument_list|(
literal|"TEST"
argument_list|,
name|schema
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from \"TEST\".\"DEPTS\" where \"NAME\" = ?"
decl_stmt|;
specifier|final
name|PreparedStatement
name|statement2
init|=
name|calciteConnection
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|statement2
operator|.
name|setString
argument_list|(
literal|1
argument_list|,
literal|"Sales"
argument_list|)
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet1
init|=
name|statement2
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|Consumer
argument_list|<
name|ResultSet
argument_list|>
name|expect
init|=
name|FileAdapterTests
operator|.
name|expect
argument_list|(
literal|"DEPTNO=10; NAME=Sales"
argument_list|)
decl_stmt|;
name|expect
operator|.
name|accept
argument_list|(
name|resultSet1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1054">[CALCITE-1054]    * NPE caused by wrong code generation for Timestamp fields</a>. */
annotation|@
name|Test
name|void
name|testFilterOnNullableTimestamp
parameter_list|()
throws|throws
name|Exception
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// date
specifier|final
name|String
name|sql1
init|=
literal|"select JOINEDAT from \"DATE\"\n"
operator|+
literal|"where JOINEDAT< {d '2000-01-01'}\n"
operator|+
literal|"or JOINEDAT>= {d '2017-01-01'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinedAt
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// time
specifier|final
name|String
name|sql2
init|=
literal|"select JOINTIME from \"DATE\"\n"
operator|+
literal|"where JOINTIME>= {t '07:00:00'}\n"
operator|+
literal|"and JOINTIME< {t '08:00:00'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTime
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Time
operator|.
name|valueOf
argument_list|(
literal|"07:15:56"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// timestamp
specifier|final
name|String
name|sql3
init|=
literal|"select JOINTIMES,\n"
operator|+
literal|"  {fn timestampadd(SQL_TSI_DAY, 1, JOINTIMES)}\n"
operator|+
literal|"from \"DATE\"\n"
operator|+
literal|"where (JOINTIMES>= {ts '2003-01-01 00:00:00'}\n"
operator|+
literal|"and JOINTIMES< {ts '2006-01-01 00:00:00'})\n"
operator|+
literal|"or (JOINTIMES>= {ts '2003-01-01 00:00:00'}\n"
operator|+
literal|"and JOINTIMES< {ts '2007-01-01 00:00:00'})"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql3
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"2005-09-07 00:00:00"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"2005-09-08 00:00:00"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql4
init|=
literal|"select JOINTIMES, extract(year from JOINTIMES)\n"
operator|+
literal|"from \"DATE\""
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes2
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql4
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1118">[CALCITE-1118]    * NullPointerException in EXTRACT with WHERE ... IN clause if field has null    * value</a>. */
annotation|@
name|Test
name|void
name|testFilterOnNullableTimestamp2
parameter_list|()
throws|throws
name|Exception
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql1
init|=
literal|"select extract(year from JOINTIMES)\n"
operator|+
literal|"from \"DATE\"\n"
operator|+
literal|"where extract(year from JOINTIMES) in (2006, 2007)"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2007
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql2
init|=
literal|"select extract(year from JOINTIMES),\n"
operator|+
literal|"  count(0) from \"DATE\"\n"
operator|+
literal|"where extract(year from JOINTIMES) between 2007 and 2016\n"
operator|+
literal|"group by extract(year from JOINTIMES)"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes2
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2007
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1L
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2015
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes2
operator|.
name|getLong
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2L
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1427">[CALCITE-1427]    * Code generation incorrect (does not compile) for DATE, TIME and TIMESTAMP    * fields</a>. */
annotation|@
name|Test
name|void
name|testNonNullFilterOnDateType
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// date
specifier|final
name|String
name|sql1
init|=
literal|"select JOINEDAT from \"DATE\"\n"
operator|+
literal|"where JOINEDAT is not null"
decl_stmt|;
specifier|final
name|ResultSet
name|joinedAt
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|Date
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// time
specifier|final
name|String
name|sql2
init|=
literal|"select JOINTIME from \"DATE\"\n"
operator|+
literal|"where JOINTIME is not null"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTime
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|Time
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Time
operator|.
name|valueOf
argument_list|(
literal|"00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// timestamp
specifier|final
name|String
name|sql3
init|=
literal|"select JOINTIMES from \"DATE\"\n"
operator|+
literal|"where JOINTIMES is not null"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql3
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|Timestamp
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1427">[CALCITE-1427]    * Code generation incorrect (does not compile) for DATE, TIME and TIMESTAMP    * fields</a>. */
annotation|@
name|Test
name|void
name|testGreaterThanFilterOnDateType
parameter_list|()
throws|throws
name|SQLException
block|{
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
name|FileAdapterTests
operator|.
name|jsonPath
argument_list|(
literal|"bug"
argument_list|)
argument_list|)
expr_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// date
specifier|final
name|String
name|sql1
init|=
literal|"select JOINEDAT from \"DATE\"\n"
operator|+
literal|"where JOINEDAT> {d '1990-01-01'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinedAt
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|Date
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinedAt
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// time
specifier|final
name|String
name|sql2
init|=
literal|"select JOINTIME from \"DATE\"\n"
operator|+
literal|"where JOINTIME> {t '00:00:00'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTime
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|Time
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTime
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Time
operator|.
name|valueOf
argument_list|(
literal|"00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// timestamp
specifier|final
name|String
name|sql3
init|=
literal|"select JOINTIMES from \"DATE\"\n"
operator|+
literal|"where JOINTIMES> {ts '1990-01-01 00:00:00'}"
decl_stmt|;
specifier|final
name|ResultSet
name|joinTimes
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql3
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
operator|.
name|getClass
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|Timestamp
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|joinTimes
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1996-08-03 00:01:02"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

