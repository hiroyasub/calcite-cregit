begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
operator|.
name|QueryBuilders
operator|.
name|BoolQueryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
operator|.
name|QueryBuilders
operator|.
name|QueryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
operator|.
name|QueryBuilders
operator|.
name|RangeQueryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSyntax
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
operator|.
name|QueryBuilders
operator|.
name|boolQuery
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
operator|.
name|QueryBuilders
operator|.
name|existsQuery
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
operator|.
name|QueryBuilders
operator|.
name|rangeQuery
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
operator|.
name|QueryBuilders
operator|.
name|regexpQuery
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|elasticsearch
operator|.
name|QueryBuilders
operator|.
name|termQuery
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|String
operator|.
name|format
import|;
end_import

begin_comment
comment|/**  * Query predicate analyzer. Uses visitor pattern to traverse existing expression  * and convert it to {@link QueryBuilder}.  *  *<p>Major part of this class have been copied from  *<a href="https://www.dremio.com/">dremio</a> ES adapter  * (thanks to their team for improving calcite-ES integration).  */
end_comment

begin_class
class|class
name|PredicateAnalyzer
block|{
comment|/**    * Internal exception    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|private
specifier|static
specifier|final
class|class
name|PredicateAnalyzerException
extends|extends
name|RuntimeException
block|{
name|PredicateAnalyzerException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|PredicateAnalyzerException
parameter_list|(
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Thrown when {@link org.apache.calcite.rel.RelNode} expression can't be processed    * (or converted into ES query)    */
specifier|static
class|class
name|ExpressionNotAnalyzableException
extends|extends
name|Exception
block|{
name|ExpressionNotAnalyzableException
parameter_list|(
name|String
name|message
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|PredicateAnalyzer
parameter_list|()
block|{
block|}
comment|/**    * Walks the expression tree, attempting to convert the entire tree into    * an equivalent Elasticsearch query filter. If an error occurs, or if it    * is determined that the expression cannot be converted, an exception is    * thrown and an error message logged.    *    *<p>Callers should catch ExpressionNotAnalyzableException    * and fall back to not using push-down filters.    *    * @param expression expression to analyze    * @return search query which can be used to query ES cluster    * @throws ExpressionNotAnalyzableException when expression can't processed by this analyzer    */
specifier|static
name|QueryBuilder
name|analyze
parameter_list|(
name|RexNode
name|expression
parameter_list|)
throws|throws
name|ExpressionNotAnalyzableException
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|expression
argument_list|,
literal|"expression"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// visits expression tree
name|QueryExpression
name|e
init|=
operator|(
name|QueryExpression
operator|)
name|expression
operator|.
name|accept
argument_list|(
operator|new
name|Visitor
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
operator|&&
name|e
operator|.
name|isPartial
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Can't handle partial QueryExpression: "
operator|+
name|e
argument_list|)
throw|;
block|}
return|return
name|e
operator|!=
literal|null
condition|?
name|e
operator|.
name|builder
argument_list|()
else|:
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|Throwables
operator|.
name|propagateIfPossible
argument_list|(
name|e
argument_list|,
name|UnsupportedOperationException
operator|.
name|class
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ExpressionNotAnalyzableException
argument_list|(
literal|"Can't convert "
operator|+
name|expression
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts expressions of the form NOT(LIKE(...)) into NOT_LIKE(...)    */
specifier|private
specifier|static
class|class
name|NotLikeConverter
extends|extends
name|RexShuttle
block|{
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
name|NotLikeConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|NOT
condition|)
block|{
name|RexNode
name|child
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LIKE
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|child
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|rexNode
lambda|->
name|rexNode
operator|.
name|accept
argument_list|(
name|NotLikeConverter
operator|.
name|this
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_LIKE
argument_list|,
name|operands
argument_list|)
return|;
block|}
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/**    * Traverses {@link RexNode} tree and builds ES query.    */
specifier|private
specifier|static
class|class
name|Visitor
extends|extends
name|RexVisitorImpl
argument_list|<
name|Expression
argument_list|>
block|{
specifier|private
name|Visitor
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
operator|new
name|NamedFieldExpression
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
operator|new
name|LiteralExpression
argument_list|(
name|literal
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|supportedRexCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlSyntax
name|syntax
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getSyntax
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|syntax
condition|)
block|{
case|case
name|BINARY
case|:
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|LIKE
case|:
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
case|case
name|SPECIAL
case|:
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
case|case
name|LIKE
case|:
case|case
name|OTHER_FUNCTION
case|:
return|return
literal|true
return|;
case|case
name|CASE
case|:
case|case
name|SIMILAR
case|:
default|default:
return|return
literal|false
return|;
block|}
case|case
name|FUNCTION
case|:
return|return
literal|true
return|;
case|case
name|POSTFIX
case|:
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IS_NOT_NULL
case|:
case|case
name|IS_NULL
case|:
return|return
literal|true
return|;
default|default:
comment|// fall through
block|}
comment|// fall through
case|case
name|FUNCTION_ID
case|:
case|case
name|FUNCTION_STAR
case|:
case|case
name|PREFIX
case|:
comment|// NOT()
default|default:
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Expression
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|SqlSyntax
name|syntax
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getSyntax
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|supportedRexCall
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unsupported call: [%s]"
argument_list|,
name|call
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|syntax
condition|)
block|{
case|case
name|BINARY
case|:
return|return
name|binary
argument_list|(
name|call
argument_list|)
return|;
case|case
name|POSTFIX
case|:
return|return
name|postfix
argument_list|(
name|call
argument_list|)
return|;
case|case
name|SPECIAL
case|:
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
return|return
name|toCastExpression
argument_list|(
name|call
argument_list|)
return|;
case|case
name|LIKE
case|:
return|return
name|binary
argument_list|(
name|call
argument_list|)
return|;
default|default:
comment|// manually process ITEM($0, 'foo') which in our case will be named attribute
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ITEM"
argument_list|)
condition|)
block|{
return|return
name|toNamedField
argument_list|(
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unsupported call: [%s]"
argument_list|,
name|call
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
case|case
name|FUNCTION
case|:
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"CONTAINS"
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|Expression
argument_list|>
name|operands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
specifier|final
name|Expression
name|nodeExpr
init|=
name|node
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|operands
operator|.
name|add
argument_list|(
name|nodeExpr
argument_list|)
expr_stmt|;
block|}
name|String
name|query
init|=
name|convertQueryString
argument_list|(
name|operands
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
name|operands
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
operator|new
name|NamedFieldExpression
argument_list|()
argument_list|)
operator|.
name|queryString
argument_list|(
name|query
argument_list|)
return|;
block|}
comment|// fall through
default|default:
name|String
name|message
init|=
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unsupported syntax [%s] for call: [%s]"
argument_list|,
name|syntax
argument_list|,
name|call
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|String
name|convertQueryString
parameter_list|(
name|List
argument_list|<
name|Expression
argument_list|>
name|fields
parameter_list|,
name|Expression
name|query
parameter_list|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|query
operator|instanceof
name|LiteralExpression
argument_list|,
literal|"Query string must be a string literal"
argument_list|)
expr_stmt|;
name|String
name|queryString
init|=
operator|(
operator|(
name|LiteralExpression
operator|)
name|query
operator|)
operator|.
name|stringValue
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|fieldMap
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Expression
name|expr
range|:
name|fields
control|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|NamedFieldExpression
condition|)
block|{
name|NamedFieldExpression
name|field
init|=
operator|(
name|NamedFieldExpression
operator|)
name|expr
decl_stmt|;
name|String
name|fieldIndexString
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"$%d"
argument_list|,
name|index
operator|++
argument_list|)
decl_stmt|;
name|fieldMap
operator|.
name|put
argument_list|(
name|fieldIndexString
argument_list|,
name|field
operator|.
name|getReference
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
return|return
name|queryString
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|QueryExpression
name|postfix
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_NULL
operator|||
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_NOT_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unsupported operator: [%s]"
argument_list|,
name|call
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
name|Expression
name|a
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// Elasticsearch does not want is null/is not null (exists query)
comment|// for _id and _index, although it supports for all other metadata column
name|isColumn
argument_list|(
name|a
argument_list|,
name|call
argument_list|,
name|ElasticsearchConstants
operator|.
name|ID
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|isColumn
argument_list|(
name|a
argument_list|,
name|call
argument_list|,
name|ElasticsearchConstants
operator|.
name|INDEX
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QueryExpression
name|operand
init|=
name|QueryExpression
operator|.
name|create
argument_list|(
operator|(
name|TerminalExpression
operator|)
name|a
argument_list|)
decl_stmt|;
return|return
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_NOT_NULL
condition|?
name|operand
operator|.
name|exists
argument_list|()
else|:
name|operand
operator|.
name|notExists
argument_list|()
return|;
block|}
comment|/**      * Process a call which is a binary operation, transforming into an equivalent      * query expression. Note that the incoming call may be either a simple binary      * expression, such as {@code foo> 5}, or it may be several simple expressions connected      * by {@code AND} or {@code OR} operators, such as {@code foo> 5 AND bar = 'abc' AND 'rot'< 1}      *      * @param call existing call      * @return evaluated expression      */
specifier|private
name|QueryExpression
name|binary
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
comment|// if AND/OR, do special handling
if|if
condition|(
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AND
operator|||
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OR
condition|)
block|{
return|return
name|andOr
argument_list|(
name|call
argument_list|)
return|;
block|}
name|checkForIncompatibleDateTimeOperands
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
specifier|final
name|Expression
name|a
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|Expression
name|b
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|SwapResult
name|pair
init|=
name|swap
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|swapped
init|=
name|pair
operator|.
name|isSwapped
argument_list|()
decl_stmt|;
comment|// For _id and _index columns, only equals/not_equals work!
if|if
condition|(
name|isColumn
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|,
name|call
argument_list|,
name|ElasticsearchConstants
operator|.
name|ID
argument_list|,
literal|false
argument_list|)
operator|||
name|isColumn
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|,
name|call
argument_list|,
name|ElasticsearchConstants
operator|.
name|INDEX
argument_list|,
literal|false
argument_list|)
operator|||
name|isColumn
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|,
name|call
argument_list|,
name|ElasticsearchConstants
operator|.
name|UID
argument_list|,
literal|false
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
break|break;
default|default:
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"Cannot handle "
operator|+
name|call
operator|.
name|getKind
argument_list|()
operator|+
literal|" expression for _id field, "
operator|+
name|call
argument_list|)
throw|;
block|}
block|}
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LIKE
case|:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"LIKE not yet supported"
argument_list|)
throw|;
case|case
name|EQUALS
case|:
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|notEquals
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
case|case
name|GREATER_THAN
case|:
if|if
condition|(
name|swapped
condition|)
block|{
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|lt
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|gt
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
if|if
condition|(
name|swapped
condition|)
block|{
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|lte
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|gte
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
case|case
name|LESS_THAN
case|:
if|if
condition|(
name|swapped
condition|)
block|{
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|gt
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|lt
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
if|if
condition|(
name|swapped
condition|)
block|{
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|gte
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
return|return
name|QueryExpression
operator|.
name|create
argument_list|(
name|pair
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|lte
argument_list|(
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
default|default:
break|break;
block|}
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unable to handle call: [%s]"
argument_list|,
name|call
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
specifier|private
name|QueryExpression
name|andOr
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|QueryExpression
index|[]
name|expressions
init|=
operator|new
name|QueryExpression
index|[
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|PredicateAnalyzerException
name|firstError
init|=
literal|null
decl_stmt|;
name|boolean
name|partial
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|Expression
name|expr
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|NamedFieldExpression
condition|)
block|{
comment|// nop currently
block|}
else|else
block|{
name|expressions
index|[
name|i
index|]
operator|=
operator|(
name|QueryExpression
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|partial
operator||=
name|expressions
index|[
name|i
index|]
operator|.
name|isPartial
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PredicateAnalyzerException
name|e
parameter_list|)
block|{
if|if
condition|(
name|firstError
operator|==
literal|null
condition|)
block|{
name|firstError
operator|=
name|e
expr_stmt|;
block|}
name|partial
operator|=
literal|true
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OR
case|:
if|if
condition|(
name|partial
condition|)
block|{
if|if
condition|(
name|firstError
operator|!=
literal|null
condition|)
block|{
throw|throw
name|firstError
throw|;
block|}
else|else
block|{
specifier|final
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unable to handle call: [%s]"
argument_list|,
name|call
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
return|return
name|CompoundQueryExpression
operator|.
name|or
argument_list|(
name|expressions
argument_list|)
return|;
case|case
name|AND
case|:
return|return
name|CompoundQueryExpression
operator|.
name|and
argument_list|(
name|partial
argument_list|,
name|expressions
argument_list|)
return|;
default|default:
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unable to handle call: [%s]"
argument_list|,
name|call
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
comment|/**      * Holder class for a pair of expressions. Used to convert {@code 1 = foo} into {@code foo = 1}      */
specifier|private
specifier|static
class|class
name|SwapResult
block|{
specifier|final
name|boolean
name|swapped
decl_stmt|;
specifier|final
name|TerminalExpression
name|terminal
decl_stmt|;
specifier|final
name|LiteralExpression
name|literal
decl_stmt|;
name|SwapResult
parameter_list|(
name|boolean
name|swapped
parameter_list|,
name|TerminalExpression
name|terminal
parameter_list|,
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|swapped
operator|=
name|swapped
expr_stmt|;
name|this
operator|.
name|terminal
operator|=
name|terminal
expr_stmt|;
name|this
operator|.
name|literal
operator|=
name|literal
expr_stmt|;
block|}
name|TerminalExpression
name|getKey
parameter_list|()
block|{
return|return
name|terminal
return|;
block|}
name|LiteralExpression
name|getValue
parameter_list|()
block|{
return|return
name|literal
return|;
block|}
name|boolean
name|isSwapped
parameter_list|()
block|{
return|return
name|swapped
return|;
block|}
block|}
comment|/**      * Swap order of operands such that the literal expression is always on the right.      *      *<p>NOTE: Some combinations of operands are implicitly not supported and will      * cause an exception to be thrown. For example, we currently do not support      * comparing a literal to another literal as convention {@code 5 = 5}. Nor do we support      * comparing named fields to other named fields as convention {@code $0 = $1}.      * @param left left expression      * @param right right expression      */
specifier|private
specifier|static
name|SwapResult
name|swap
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
name|TerminalExpression
name|terminal
decl_stmt|;
name|LiteralExpression
name|literal
init|=
name|expressAsLiteral
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|boolean
name|swapped
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|literal
operator|!=
literal|null
condition|)
block|{
name|swapped
operator|=
literal|true
expr_stmt|;
name|terminal
operator|=
operator|(
name|TerminalExpression
operator|)
name|right
expr_stmt|;
block|}
else|else
block|{
name|literal
operator|=
name|expressAsLiteral
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|terminal
operator|=
operator|(
name|TerminalExpression
operator|)
name|left
expr_stmt|;
block|}
if|if
condition|(
name|literal
operator|==
literal|null
operator|||
name|terminal
operator|==
literal|null
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unexpected combination of expressions [left: %s] [right: %s]"
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
if|if
condition|(
name|CastExpression
operator|.
name|isCastExpression
argument_list|(
name|terminal
argument_list|)
condition|)
block|{
name|terminal
operator|=
name|CastExpression
operator|.
name|unpack
argument_list|(
name|terminal
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SwapResult
argument_list|(
name|swapped
argument_list|,
name|terminal
argument_list|,
name|literal
argument_list|)
return|;
block|}
specifier|private
name|CastExpression
name|toCastExpression
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|TerminalExpression
name|argument
init|=
operator|(
name|TerminalExpression
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
decl_stmt|;
return|return
operator|new
name|CastExpression
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|argument
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|NamedFieldExpression
name|toNamedField
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
return|return
operator|new
name|NamedFieldExpression
argument_list|(
name|literal
argument_list|)
return|;
block|}
comment|/**      * Try to convert a generic expression into a literal expression.      */
specifier|private
specifier|static
name|LiteralExpression
name|expressAsLiteral
parameter_list|(
name|Expression
name|exp
parameter_list|)
block|{
if|if
condition|(
name|exp
operator|instanceof
name|LiteralExpression
condition|)
block|{
return|return
operator|(
name|LiteralExpression
operator|)
name|exp
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isColumn
parameter_list|(
name|Expression
name|exp
parameter_list|,
name|RexNode
name|node
parameter_list|,
name|String
name|columnName
parameter_list|,
name|boolean
name|throwException
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|exp
operator|instanceof
name|NamedFieldExpression
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|NamedFieldExpression
name|termExp
init|=
operator|(
name|NamedFieldExpression
operator|)
name|exp
decl_stmt|;
if|if
condition|(
name|columnName
operator|.
name|equals
argument_list|(
name|termExp
operator|.
name|getRootName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"Cannot handle _id field in "
operator|+
name|node
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Empty interface; exists only to define type hierarchy    */
interface|interface
name|Expression
block|{   }
comment|/**    * Main expression operators (like {@code equals}, {@code gt}, {@code exists} etc.)    */
specifier|abstract
specifier|static
class|class
name|QueryExpression
implements|implements
name|Expression
block|{
specifier|public
specifier|abstract
name|QueryBuilder
name|builder
parameter_list|()
function_decl|;
specifier|public
name|boolean
name|isPartial
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
specifier|abstract
name|QueryExpression
name|exists
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|notExists
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|like
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|notLike
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|equals
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|notEquals
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|gt
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|gte
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|lt
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|lte
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|queryString
parameter_list|(
name|String
name|query
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|QueryExpression
name|isTrue
parameter_list|()
function_decl|;
specifier|public
specifier|static
name|QueryExpression
name|create
parameter_list|(
name|TerminalExpression
name|expression
parameter_list|)
block|{
if|if
condition|(
name|expression
operator|instanceof
name|NamedFieldExpression
condition|)
block|{
return|return
operator|new
name|SimpleQueryExpression
argument_list|(
operator|(
name|NamedFieldExpression
operator|)
name|expression
argument_list|)
return|;
block|}
else|else
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"Unsupported expression: [%s]"
argument_list|,
name|expression
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Builds conjunctions / disjunctions based on existing expressions    */
specifier|static
class|class
name|CompoundQueryExpression
extends|extends
name|QueryExpression
block|{
specifier|private
specifier|final
name|boolean
name|partial
decl_stmt|;
specifier|private
specifier|final
name|BoolQueryBuilder
name|builder
init|=
name|boolQuery
argument_list|()
decl_stmt|;
specifier|public
specifier|static
name|CompoundQueryExpression
name|or
parameter_list|(
name|QueryExpression
modifier|...
name|expressions
parameter_list|)
block|{
name|CompoundQueryExpression
name|bqe
init|=
operator|new
name|CompoundQueryExpression
argument_list|(
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|QueryExpression
name|expression
range|:
name|expressions
control|)
block|{
name|bqe
operator|.
name|builder
operator|.
name|should
argument_list|(
name|expression
operator|.
name|builder
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|bqe
return|;
block|}
comment|/**      * if partial expression, we will need to complete it with a full filter      * @param partial whether we partially converted a and for push down purposes.      * @param expressions list of expressions to join with {@code and} boolean      * @return new instance of expression      */
specifier|public
specifier|static
name|CompoundQueryExpression
name|and
parameter_list|(
name|boolean
name|partial
parameter_list|,
name|QueryExpression
modifier|...
name|expressions
parameter_list|)
block|{
name|CompoundQueryExpression
name|bqe
init|=
operator|new
name|CompoundQueryExpression
argument_list|(
name|partial
argument_list|)
decl_stmt|;
for|for
control|(
name|QueryExpression
name|expression
range|:
name|expressions
control|)
block|{
if|if
condition|(
name|expression
operator|!=
literal|null
condition|)
block|{
comment|// partial expressions have nulls for missing nodes
name|bqe
operator|.
name|builder
operator|.
name|must
argument_list|(
name|expression
operator|.
name|builder
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bqe
return|;
block|}
specifier|private
name|CompoundQueryExpression
parameter_list|(
name|boolean
name|partial
parameter_list|)
block|{
name|this
operator|.
name|partial
operator|=
name|partial
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isPartial
parameter_list|()
block|{
return|return
name|partial
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryBuilder
name|builder
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|exists
parameter_list|()
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['exists'] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|notExists
parameter_list|()
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['notExists'] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|like
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['like'] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|notLike
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['notLike'] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|equals
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['='] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|notEquals
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['not'] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|gt
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['>'] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|gte
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['>='] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|lt
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['<'] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|lte
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"SqlOperatorImpl ['<='] "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|queryString
parameter_list|(
name|String
name|query
parameter_list|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"QueryString "
operator|+
literal|"cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|isTrue
parameter_list|()
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"isTrue cannot be applied to a compound expression"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Usually basic expression of type {@code a = 'val'} or {@code b> 42}.    */
specifier|static
class|class
name|SimpleQueryExpression
extends|extends
name|QueryExpression
block|{
specifier|private
specifier|final
name|NamedFieldExpression
name|rel
decl_stmt|;
specifier|private
name|QueryBuilder
name|builder
decl_stmt|;
specifier|private
name|String
name|getFieldReference
parameter_list|()
block|{
return|return
name|rel
operator|.
name|getReference
argument_list|()
return|;
block|}
specifier|private
name|SimpleQueryExpression
parameter_list|(
name|NamedFieldExpression
name|rel
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|QueryBuilder
name|builder
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|exists
parameter_list|()
block|{
name|builder
operator|=
name|existsQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|notExists
parameter_list|()
block|{
comment|// Even though Lucene doesn't allow a stand alone mustNot boolean query,
comment|// Elasticsearch handles this problem transparently on its end
name|builder
operator|=
name|boolQuery
argument_list|()
operator|.
name|mustNot
argument_list|(
name|existsQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|like
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|builder
operator|=
name|regexpQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|,
name|literal
operator|.
name|stringValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|notLike
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|builder
operator|=
name|boolQuery
argument_list|()
comment|// NOT LIKE should return false when field is NULL
operator|.
name|must
argument_list|(
name|existsQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
argument_list|)
operator|.
name|mustNot
argument_list|(
name|regexpQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|,
name|literal
operator|.
name|stringValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|equals
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|Object
name|value
init|=
name|literal
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|GregorianCalendar
condition|)
block|{
name|builder
operator|=
name|boolQuery
argument_list|()
operator|.
name|must
argument_list|(
name|addFormatIfNecessary
argument_list|(
name|literal
argument_list|,
name|rangeQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
operator|.
name|gte
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
operator|.
name|must
argument_list|(
name|addFormatIfNecessary
argument_list|(
name|literal
argument_list|,
name|rangeQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
operator|.
name|lte
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|=
name|termQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|notEquals
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|Object
name|value
init|=
name|literal
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|GregorianCalendar
condition|)
block|{
name|builder
operator|=
name|boolQuery
argument_list|()
operator|.
name|should
argument_list|(
name|addFormatIfNecessary
argument_list|(
name|literal
argument_list|,
name|rangeQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
operator|.
name|gt
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
operator|.
name|should
argument_list|(
name|addFormatIfNecessary
argument_list|(
name|literal
argument_list|,
name|rangeQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
operator|.
name|lt
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|=
name|boolQuery
argument_list|()
comment|// NOT LIKE should return false when field is NULL
operator|.
name|must
argument_list|(
name|existsQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
argument_list|)
operator|.
name|mustNot
argument_list|(
name|termQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|gt
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|Object
name|value
init|=
name|literal
operator|.
name|value
argument_list|()
decl_stmt|;
name|builder
operator|=
name|addFormatIfNecessary
argument_list|(
name|literal
argument_list|,
name|rangeQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
operator|.
name|gt
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|gte
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|Object
name|value
init|=
name|literal
operator|.
name|value
argument_list|()
decl_stmt|;
name|builder
operator|=
name|addFormatIfNecessary
argument_list|(
name|literal
argument_list|,
name|rangeQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
operator|.
name|gte
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|lt
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|Object
name|value
init|=
name|literal
operator|.
name|value
argument_list|()
decl_stmt|;
name|builder
operator|=
name|addFormatIfNecessary
argument_list|(
name|literal
argument_list|,
name|rangeQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
operator|.
name|lt
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|lte
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|)
block|{
name|Object
name|value
init|=
name|literal
operator|.
name|value
argument_list|()
decl_stmt|;
name|builder
operator|=
name|addFormatIfNecessary
argument_list|(
name|literal
argument_list|,
name|rangeQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|)
operator|.
name|lte
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|queryString
parameter_list|(
name|String
name|query
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"QueryExpression not yet supported: "
operator|+
name|query
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|QueryExpression
name|isTrue
parameter_list|()
block|{
name|builder
operator|=
name|termQuery
argument_list|(
name|getFieldReference
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/**    * By default, range queries on date/time need use the format of the source to parse the literal.    * So we need to specify that the literal has "date_time" format    * @param literal literal value    * @param rangeQueryBuilder query builder to optionally add {@code format} expression    * @return existing builder with possible {@code format} attribute    */
specifier|private
specifier|static
name|RangeQueryBuilder
name|addFormatIfNecessary
parameter_list|(
name|LiteralExpression
name|literal
parameter_list|,
name|RangeQueryBuilder
name|rangeQueryBuilder
parameter_list|)
block|{
if|if
condition|(
name|literal
operator|.
name|value
argument_list|()
operator|instanceof
name|GregorianCalendar
condition|)
block|{
name|rangeQueryBuilder
operator|.
name|format
argument_list|(
literal|"date_time"
argument_list|)
expr_stmt|;
block|}
return|return
name|rangeQueryBuilder
return|;
block|}
comment|/**    * Empty interface; exists only to define type hierarchy    */
interface|interface
name|TerminalExpression
extends|extends
name|Expression
block|{   }
comment|/**    * SQL cast: {@code cast(col as INTEGER)}    */
specifier|static
specifier|final
class|class
name|CastExpression
implements|implements
name|TerminalExpression
block|{
specifier|private
specifier|final
name|RelDataType
name|type
decl_stmt|;
specifier|private
specifier|final
name|TerminalExpression
name|argument
decl_stmt|;
specifier|private
name|CastExpression
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|TerminalExpression
name|argument
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|argument
operator|=
name|argument
expr_stmt|;
block|}
specifier|public
name|boolean
name|isCastFromLiteral
parameter_list|()
block|{
return|return
name|argument
operator|instanceof
name|LiteralExpression
return|;
block|}
specifier|static
name|TerminalExpression
name|unpack
parameter_list|(
name|TerminalExpression
name|exp
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|exp
operator|instanceof
name|CastExpression
operator|)
condition|)
block|{
return|return
name|exp
return|;
block|}
return|return
operator|(
operator|(
name|CastExpression
operator|)
name|exp
operator|)
operator|.
name|argument
return|;
block|}
specifier|static
name|boolean
name|isCastExpression
parameter_list|(
name|Expression
name|exp
parameter_list|)
block|{
return|return
name|exp
operator|instanceof
name|CastExpression
return|;
block|}
block|}
comment|/**    * Used for bind variables    */
specifier|static
specifier|final
class|class
name|NamedFieldExpression
implements|implements
name|TerminalExpression
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
name|NamedFieldExpression
parameter_list|()
block|{
name|this
operator|.
name|name
operator|=
literal|null
expr_stmt|;
block|}
specifier|private
name|NamedFieldExpression
parameter_list|(
name|RexInputRef
name|schemaField
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|schemaField
operator|==
literal|null
condition|?
literal|null
else|:
name|schemaField
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
specifier|private
name|NamedFieldExpression
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|literal
operator|==
literal|null
condition|?
literal|null
else|:
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|literal
argument_list|)
expr_stmt|;
block|}
name|String
name|getRootName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
name|boolean
name|isMetaField
parameter_list|()
block|{
return|return
name|ElasticsearchConstants
operator|.
name|META_COLUMNS
operator|.
name|contains
argument_list|(
name|getRootName
argument_list|()
argument_list|)
return|;
block|}
name|String
name|getReference
parameter_list|()
block|{
return|return
name|getRootName
argument_list|()
return|;
block|}
block|}
comment|/**    * Literal like {@code 'foo' or 42 or true} etc.    */
specifier|static
specifier|final
class|class
name|LiteralExpression
implements|implements
name|TerminalExpression
block|{
specifier|final
name|RexLiteral
name|literal
decl_stmt|;
name|LiteralExpression
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
name|this
operator|.
name|literal
operator|=
name|literal
expr_stmt|;
block|}
name|Object
name|value
parameter_list|()
block|{
if|if
condition|(
name|isIntegral
argument_list|()
condition|)
block|{
return|return
name|longValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|isFloatingPoint
argument_list|()
condition|)
block|{
return|return
name|doubleValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|isBoolean
argument_list|()
condition|)
block|{
return|return
name|booleanValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|isString
argument_list|()
condition|)
block|{
return|return
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|literal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rawValue
argument_list|()
return|;
block|}
block|}
name|boolean
name|isIntegral
parameter_list|()
block|{
return|return
name|SqlTypeName
operator|.
name|INT_TYPES
operator|.
name|contains
argument_list|(
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
return|;
block|}
name|boolean
name|isFloatingPoint
parameter_list|()
block|{
return|return
name|SqlTypeName
operator|.
name|APPROX_TYPES
operator|.
name|contains
argument_list|(
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
return|;
block|}
name|boolean
name|isBoolean
parameter_list|()
block|{
return|return
name|SqlTypeName
operator|.
name|BOOLEAN_TYPES
operator|.
name|contains
argument_list|(
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isString
parameter_list|()
block|{
return|return
name|SqlTypeName
operator|.
name|CHAR_TYPES
operator|.
name|contains
argument_list|(
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
return|;
block|}
name|long
name|longValue
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|literal
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
name|double
name|doubleValue
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|literal
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
name|boolean
name|booleanValue
parameter_list|()
block|{
return|return
name|RexLiteral
operator|.
name|booleanValue
argument_list|(
name|literal
argument_list|)
return|;
block|}
name|String
name|stringValue
parameter_list|()
block|{
return|return
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|literal
argument_list|)
return|;
block|}
name|Object
name|rawValue
parameter_list|()
block|{
return|return
name|literal
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
comment|/**    * If one operand in a binary operator is a DateTime type, but the other isn't,    * we should not push down the predicate    * @param call current node being evaluated    */
specifier|private
specifier|static
name|void
name|checkForIncompatibleDateTimeOperands
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|RelDataType
name|op1
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|op2
init|=
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|SqlTypeFamily
operator|.
name|DATETIME
operator|.
name|contains
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|SqlTypeFamily
operator|.
name|DATETIME
operator|.
name|contains
argument_list|(
name|op2
argument_list|)
operator|)
operator|||
operator|(
name|SqlTypeFamily
operator|.
name|DATETIME
operator|.
name|contains
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
name|SqlTypeFamily
operator|.
name|DATETIME
operator|.
name|contains
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|SqlTypeFamily
operator|.
name|DATE
operator|.
name|contains
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|SqlTypeFamily
operator|.
name|DATE
operator|.
name|contains
argument_list|(
name|op2
argument_list|)
operator|)
operator|||
operator|(
name|SqlTypeFamily
operator|.
name|DATE
operator|.
name|contains
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
name|SqlTypeFamily
operator|.
name|DATE
operator|.
name|contains
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|SqlTypeFamily
operator|.
name|TIMESTAMP
operator|.
name|contains
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|SqlTypeFamily
operator|.
name|TIMESTAMP
operator|.
name|contains
argument_list|(
name|op2
argument_list|)
operator|)
operator|||
operator|(
name|SqlTypeFamily
operator|.
name|TIMESTAMP
operator|.
name|contains
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
name|SqlTypeFamily
operator|.
name|TIMESTAMP
operator|.
name|contains
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|SqlTypeFamily
operator|.
name|TIME
operator|.
name|contains
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|SqlTypeFamily
operator|.
name|TIME
operator|.
name|contains
argument_list|(
name|op2
argument_list|)
operator|)
operator|||
operator|(
name|SqlTypeFamily
operator|.
name|TIME
operator|.
name|contains
argument_list|(
name|op2
argument_list|)
operator|&&
operator|!
name|SqlTypeFamily
operator|.
name|TIME
operator|.
name|contains
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|PredicateAnalyzerException
argument_list|(
literal|"Cannot handle "
operator|+
name|call
operator|.
name|getKind
argument_list|()
operator|+
literal|" expression for _id field, "
operator|+
name|call
argument_list|)
throw|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End PredicateAnalyzer.java
end_comment

end_unit

