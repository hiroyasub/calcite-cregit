begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|druid
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|core
operator|.
name|JsonGenerator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateTimeStringUtils
operator|.
name|ISO_DATETIME_FRACTIONAL_SECOND_FORMAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateTimeStringUtils
operator|.
name|getDateFormatter
import|;
end_import

begin_comment
comment|/**  * Filter element of a Druid "groupBy" or "topN" query.  */
end_comment

begin_class
specifier|abstract
class|class
name|DruidJsonFilter
implements|implements
name|DruidJson
block|{
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|SimpleDateFormat
argument_list|>
name|DATE_FORMATTER
init|=
name|ThreadLocal
operator|.
name|withInitial
argument_list|(
parameter_list|()
lambda|->
name|getDateFormatter
argument_list|(
name|ISO_DATETIME_FRACTIONAL_SECOND_FORMAT
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Converts a {@link RexNode} to a Druid JSON filter.    *    * @param rexNode    RexNode to translate to Druid Json Filter    * @param rowType    Row type associated to rexNode    * @param druidQuery Druid query    *    * @return Druid JSON filter, or null if it cannot translate    */
specifier|private
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toEqualityKindDruidFilter
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|DruidQuery
name|druidQuery
parameter_list|)
block|{
if|if
condition|(
name|rexNode
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|EQUALS
operator|&&
name|rexNode
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|NOT_EQUALS
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|DruidQuery
operator|.
name|format
argument_list|(
literal|"Expecting EQUALS or NOT_EQUALS but got [%s]"
argument_list|,
name|rexNode
operator|.
name|getKind
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|RexCall
name|rexCall
init|=
operator|(
name|RexCall
operator|)
name|rexNode
decl_stmt|;
if|if
condition|(
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|RexLiteral
name|rexLiteral
decl_stmt|;
specifier|final
name|RexNode
name|refNode
decl_stmt|;
specifier|final
name|RexNode
name|lhs
init|=
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|rhs
init|=
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|lhs
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL
operator|&&
name|rhs
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|LITERAL
condition|)
block|{
name|rexLiteral
operator|=
operator|(
name|RexLiteral
operator|)
name|lhs
expr_stmt|;
name|refNode
operator|=
name|rhs
expr_stmt|;
block|}
if|else if
condition|(
name|rhs
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL
operator|&&
name|lhs
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|LITERAL
condition|)
block|{
name|rexLiteral
operator|=
operator|(
name|RexLiteral
operator|)
name|rhs
expr_stmt|;
name|refNode
operator|=
name|lhs
expr_stmt|;
block|}
else|else
block|{
comment|// must have at least one literal
return|return
literal|null
return|;
block|}
if|if
condition|(
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|rexLiteral
argument_list|)
condition|)
block|{
comment|// we are not handling is NULL filter here thus we bail out if Literal is null
return|return
literal|null
return|;
block|}
specifier|final
name|String
name|literalValue
init|=
name|toDruidLiteral
argument_list|(
name|rexLiteral
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|literalValue
operator|==
literal|null
condition|)
block|{
comment|// cannot translate literal; better bail out
return|return
literal|null
return|;
block|}
specifier|final
name|boolean
name|isNumeric
init|=
name|refNode
operator|.
name|getType
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|NUMERIC
operator|||
name|rexLiteral
operator|.
name|getType
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|NUMERIC
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|ExtractionFunction
argument_list|>
name|druidColumn
init|=
name|DruidQuery
operator|.
name|toDruidColumn
argument_list|(
name|refNode
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
decl_stmt|;
specifier|final
name|String
name|columnName
init|=
name|druidColumn
operator|.
name|left
decl_stmt|;
specifier|final
name|ExtractionFunction
name|extractionFunction
init|=
name|druidColumn
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|columnName
operator|==
literal|null
condition|)
block|{
comment|// no column name better bail out.
return|return
literal|null
return|;
block|}
specifier|final
name|DruidJsonFilter
name|partialFilter
decl_stmt|;
if|if
condition|(
name|isNumeric
condition|)
block|{
comment|//need bound filter since it one of operands is numeric
name|partialFilter
operator|=
operator|new
name|JsonBound
argument_list|(
name|columnName
argument_list|,
name|literalValue
argument_list|,
literal|false
argument_list|,
name|literalValue
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|extractionFunction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partialFilter
operator|=
operator|new
name|JsonSelector
argument_list|(
name|columnName
argument_list|,
name|literalValue
argument_list|,
name|extractionFunction
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rexNode
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|EQUALS
condition|)
block|{
return|return
name|partialFilter
return|;
block|}
return|return
name|toNotDruidFilter
argument_list|(
name|partialFilter
argument_list|)
return|;
block|}
comment|/**    * Converts a {@link RexNode} to a Druid JSON bound filter.    *    * @param rexNode    RexNode to translate    * @param rowType    Row type associated to Filter    * @param druidQuery Druid query    *    * @return valid Druid JSON Bound Filter, or null if it cannot translate the    * RexNode    */
specifier|private
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toBoundDruidFilter
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|DruidQuery
name|druidQuery
parameter_list|)
block|{
specifier|final
name|RexCall
name|rexCall
init|=
operator|(
name|RexCall
operator|)
name|rexNode
decl_stmt|;
specifier|final
name|RexLiteral
name|rexLiteral
decl_stmt|;
if|if
condition|(
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|RexNode
name|refNode
decl_stmt|;
specifier|final
name|RexNode
name|lhs
init|=
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|rhs
init|=
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|lhsIsRef
decl_stmt|;
if|if
condition|(
name|lhs
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL
operator|&&
name|rhs
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|LITERAL
condition|)
block|{
name|rexLiteral
operator|=
operator|(
name|RexLiteral
operator|)
name|lhs
expr_stmt|;
name|refNode
operator|=
name|rhs
expr_stmt|;
name|lhsIsRef
operator|=
literal|false
expr_stmt|;
block|}
if|else if
condition|(
name|rhs
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL
operator|&&
name|lhs
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|LITERAL
condition|)
block|{
name|rexLiteral
operator|=
operator|(
name|RexLiteral
operator|)
name|rhs
expr_stmt|;
name|refNode
operator|=
name|lhs
expr_stmt|;
name|lhsIsRef
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// must have at least one literal
return|return
literal|null
return|;
block|}
if|if
condition|(
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|rexLiteral
argument_list|)
condition|)
block|{
comment|// we are not handling is NULL filter here; thus we bail out if Literal is
comment|// null
return|return
literal|null
return|;
block|}
specifier|final
name|String
name|literalValue
init|=
name|DruidJsonFilter
operator|.
name|toDruidLiteral
argument_list|(
name|rexLiteral
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|literalValue
operator|==
literal|null
condition|)
block|{
comment|// cannot translate literal; better bail out
return|return
literal|null
return|;
block|}
specifier|final
name|boolean
name|isNumeric
init|=
name|refNode
operator|.
name|getType
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|NUMERIC
operator|||
name|rexLiteral
operator|.
name|getType
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|NUMERIC
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|ExtractionFunction
argument_list|>
name|druidColumn
init|=
name|DruidQuery
operator|.
name|toDruidColumn
argument_list|(
name|refNode
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
decl_stmt|;
specifier|final
name|String
name|columnName
init|=
name|druidColumn
operator|.
name|left
decl_stmt|;
specifier|final
name|ExtractionFunction
name|extractionFunction
init|=
name|druidColumn
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|columnName
operator|==
literal|null
condition|)
block|{
comment|// no column name better bail out.
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|rexCall
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
if|if
condition|(
name|lhsIsRef
condition|)
block|{
return|return
operator|new
name|JsonBound
argument_list|(
name|columnName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|literalValue
argument_list|,
name|rexCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LESS_THAN
argument_list|,
name|isNumeric
argument_list|,
name|extractionFunction
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|JsonBound
argument_list|(
name|columnName
argument_list|,
name|literalValue
argument_list|,
name|rexCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LESS_THAN
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|isNumeric
argument_list|,
name|extractionFunction
argument_list|)
return|;
block|}
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN
case|:
if|if
condition|(
operator|!
name|lhsIsRef
condition|)
block|{
return|return
operator|new
name|JsonBound
argument_list|(
name|columnName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|literalValue
argument_list|,
name|rexCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|GREATER_THAN
argument_list|,
name|isNumeric
argument_list|,
name|extractionFunction
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|JsonBound
argument_list|(
name|columnName
argument_list|,
name|literalValue
argument_list|,
name|rexCall
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|GREATER_THAN
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|isNumeric
argument_list|,
name|extractionFunction
argument_list|)
return|;
block|}
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Converts a {@link RexNode} to a Druid literal.    *    * @param rexNode    RexNode to translate to Druid literal equivalant    * @param rowType    Row type associated to rexNode    * @param druidQuery Druid query    *    * @return non null string, or null if it cannot translate to valid Druid    * equivalent    */
specifier|private
specifier|static
annotation|@
name|Nullable
name|String
name|toDruidLiteral
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|RelDataType
name|rowType
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|DruidQuery
name|druidQuery
parameter_list|)
block|{
specifier|final
name|String
name|val
decl_stmt|;
specifier|final
name|RexLiteral
name|rhsLiteral
init|=
operator|(
name|RexLiteral
operator|)
name|rexNode
decl_stmt|;
if|if
condition|(
name|SqlTypeName
operator|.
name|NUMERIC_TYPES
operator|.
name|contains
argument_list|(
name|rhsLiteral
operator|.
name|getTypeName
argument_list|()
argument_list|)
condition|)
block|{
name|val
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|RexLiteral
operator|.
name|value
argument_list|(
name|rhsLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|SqlTypeName
operator|.
name|CHAR_TYPES
operator|.
name|contains
argument_list|(
name|rhsLiteral
operator|.
name|getTypeName
argument_list|()
argument_list|)
condition|)
block|{
name|val
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|rhsLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|SqlTypeName
operator|.
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
operator|==
name|rhsLiteral
operator|.
name|getTypeName
argument_list|()
operator|||
name|SqlTypeName
operator|.
name|TIMESTAMP
operator|==
name|rhsLiteral
operator|.
name|getTypeName
argument_list|()
operator|||
name|SqlTypeName
operator|.
name|DATE
operator|==
name|rhsLiteral
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
name|Long
name|millisSinceEpoch
init|=
name|DruidDateTimeUtils
operator|.
name|literalValue
argument_list|(
name|rexNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|millisSinceEpoch
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Cannot translate Literal"
operator|+
name|rexNode
operator|+
literal|" of type "
operator|+
name|rhsLiteral
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" to TimestampString"
argument_list|)
throw|;
block|}
name|val
operator|=
name|DATE_FORMATTER
operator|.
name|get
argument_list|()
operator|.
name|format
argument_list|(
name|millisSinceEpoch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Don't know how to filter on this kind of literal.
name|val
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toIsNullKindDruidFilter
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|DruidQuery
name|druidQuery
parameter_list|)
block|{
if|if
condition|(
name|rexNode
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NULL
operator|&&
name|rexNode
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|IS_NOT_NULL
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|DruidQuery
operator|.
name|format
argument_list|(
literal|"Expecting IS_NULL or IS_NOT_NULL but got [%s]"
argument_list|,
name|rexNode
operator|.
name|getKind
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|RexCall
name|rexCall
init|=
operator|(
name|RexCall
operator|)
name|rexNode
decl_stmt|;
specifier|final
name|RexNode
name|refNode
init|=
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Pair
argument_list|<
name|String
argument_list|,
name|ExtractionFunction
argument_list|>
name|druidColumn
init|=
name|DruidQuery
operator|.
name|toDruidColumn
argument_list|(
name|refNode
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
decl_stmt|;
specifier|final
name|String
name|columnName
init|=
name|druidColumn
operator|.
name|left
decl_stmt|;
specifier|final
name|ExtractionFunction
name|extractionFunction
init|=
name|druidColumn
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|columnName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rexNode
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_NOT_NULL
condition|)
block|{
return|return
name|toNotDruidFilter
argument_list|(
operator|new
name|JsonSelector
argument_list|(
name|columnName
argument_list|,
literal|null
argument_list|,
name|extractionFunction
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|JsonSelector
argument_list|(
name|columnName
argument_list|,
literal|null
argument_list|,
name|extractionFunction
argument_list|)
return|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toInKindDruidFilter
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|DruidQuery
name|druidQuery
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DRUID_IN
case|:
case|case
name|DRUID_NOT_IN
case|:
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|DruidQuery
operator|.
name|format
argument_list|(
literal|"Expecting IN or NOT IN but got [%s]"
argument_list|,
name|e
operator|.
name|getKind
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|String
argument_list|>
name|listBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rexNode
range|:
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
if|if
condition|(
name|rexNode
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL
condition|)
block|{
name|String
name|value
init|=
name|toDruidLiteral
argument_list|(
name|rexNode
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|listBuilder
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|Pair
argument_list|<
name|String
argument_list|,
name|ExtractionFunction
argument_list|>
name|druidColumn
init|=
name|DruidQuery
operator|.
name|toDruidColumn
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
decl_stmt|;
specifier|final
name|String
name|columnName
init|=
name|druidColumn
operator|.
name|left
decl_stmt|;
specifier|final
name|ExtractionFunction
name|extractionFunction
init|=
name|druidColumn
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|columnName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|e
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|NOT_IN
condition|)
block|{
return|return
operator|new
name|DruidJsonFilter
operator|.
name|JsonInFilter
argument_list|(
name|columnName
argument_list|,
name|listBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|extractionFunction
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|toNotDruidFilter
argument_list|(
operator|new
name|DruidJsonFilter
operator|.
name|JsonInFilter
argument_list|(
name|columnName
argument_list|,
name|listBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|extractionFunction
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toNotDruidFilter
parameter_list|(
name|DruidJsonFilter
name|druidJsonFilter
parameter_list|)
block|{
if|if
condition|(
name|druidJsonFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|JsonCompositeFilter
argument_list|(
name|Type
operator|.
name|NOT
argument_list|,
name|druidJsonFilter
argument_list|)
return|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toBetweenDruidFilter
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|DruidQuery
name|query
parameter_list|)
block|{
if|if
condition|(
name|rexNode
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|BETWEEN
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|RexCall
name|rexCall
init|=
operator|(
name|RexCall
operator|)
name|rexNode
decl_stmt|;
if|if
condition|(
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|4
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// BETWEEN (ASYMMETRIC, REF, 'lower-bound', 'upper-bound')
specifier|final
name|RexNode
name|refNode
init|=
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|lhs
init|=
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|rhs
init|=
name|rexCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|String
name|lhsLiteralValue
init|=
name|toDruidLiteral
argument_list|(
name|lhs
argument_list|,
name|rowType
argument_list|,
name|query
argument_list|)
decl_stmt|;
specifier|final
name|String
name|rhsLiteralValue
init|=
name|toDruidLiteral
argument_list|(
name|rhs
argument_list|,
name|rowType
argument_list|,
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|lhsLiteralValue
operator|==
literal|null
operator|||
name|rhsLiteralValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|boolean
name|isNumeric
init|=
name|lhs
operator|.
name|getType
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|NUMERIC
operator|||
name|rhs
operator|.
name|getType
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|NUMERIC
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|String
argument_list|,
name|ExtractionFunction
argument_list|>
name|druidColumn
init|=
name|DruidQuery
operator|.
name|toDruidColumn
argument_list|(
name|refNode
argument_list|,
name|rowType
argument_list|,
name|query
argument_list|)
decl_stmt|;
specifier|final
name|String
name|columnName
init|=
name|druidColumn
operator|.
name|left
decl_stmt|;
specifier|final
name|ExtractionFunction
name|extractionFunction
init|=
name|druidColumn
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|columnName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|JsonBound
argument_list|(
name|columnName
argument_list|,
name|lhsLiteralValue
argument_list|,
literal|false
argument_list|,
name|rhsLiteralValue
argument_list|,
literal|false
argument_list|,
name|isNumeric
argument_list|,
name|extractionFunction
argument_list|)
return|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toSimpleDruidFilter
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|DruidQuery
name|druidQuery
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|NOT_EQUALS
case|:
return|return
name|toEqualityKindDruidFilter
argument_list|(
name|e
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
return|;
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|toBoundDruidFilter
argument_list|(
name|e
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
return|;
case|case
name|BETWEEN
case|:
return|return
name|toBetweenDruidFilter
argument_list|(
name|e
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
return|;
case|case
name|DRUID_IN
case|:
case|case
name|DRUID_NOT_IN
case|:
return|return
name|toInKindDruidFilter
argument_list|(
name|e
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
return|;
case|case
name|IS_NULL
case|:
case|case
name|IS_NOT_NULL
case|:
return|return
name|toIsNullKindDruidFilter
argument_list|(
name|e
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Converts a {@link RexNode} to a Druid filter.    *    * @param rexNode    RexNode to translate to Druid Filter    * @param rowType    Row type of filter input    * @param druidQuery Druid query    * @param rexBuilder Rex builder    *    * @return Druid Json filters, or null when cannot translate to valid Druid    * filters    */
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toDruidFilters
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|DruidQuery
name|druidQuery
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|rexNode
operator|=
name|RexUtil
operator|.
name|expandSearch
argument_list|(
name|rexBuilder
argument_list|,
literal|null
argument_list|,
name|rexNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rexNode
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
name|JsonExpressionFilter
operator|.
name|alwaysTrue
argument_list|()
return|;
block|}
if|if
condition|(
name|rexNode
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return
name|JsonExpressionFilter
operator|.
name|alwaysFalse
argument_list|()
return|;
block|}
switch|switch
condition|(
name|rexNode
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IS_TRUE
case|:
case|case
name|IS_NOT_FALSE
case|:
return|return
name|toDruidFilters
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rexNode
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|,
name|rexBuilder
argument_list|)
return|;
case|case
name|IS_NOT_TRUE
case|:
case|case
name|IS_FALSE
case|:
specifier|final
name|DruidJsonFilter
name|simpleFilter
init|=
name|toDruidFilters
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|rexNode
operator|)
operator|.
name|getOperands
argument_list|()
argument_list|)
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
return|return
name|simpleFilter
operator|!=
literal|null
condition|?
operator|new
name|JsonCompositeFilter
argument_list|(
name|Type
operator|.
name|NOT
argument_list|,
name|simpleFilter
argument_list|)
else|:
name|simpleFilter
return|;
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|NOT
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|rexNode
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DruidJsonFilter
argument_list|>
name|jsonFilters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|RexNode
name|e
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
specifier|final
name|DruidJsonFilter
name|druidFilter
init|=
name|toDruidFilters
argument_list|(
name|e
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
if|if
condition|(
name|druidFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|jsonFilters
operator|.
name|add
argument_list|(
name|druidFilter
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|JsonCompositeFilter
argument_list|(
name|Type
operator|.
name|valueOf
argument_list|(
name|rexNode
operator|.
name|getKind
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
name|jsonFilters
argument_list|)
return|;
default|default:
break|break;
block|}
specifier|final
name|DruidJsonFilter
name|simpleLeafFilter
init|=
name|toSimpleDruidFilter
argument_list|(
name|rexNode
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
decl_stmt|;
return|return
name|simpleLeafFilter
operator|==
literal|null
condition|?
name|toDruidExpressionFilter
argument_list|(
name|rexNode
argument_list|,
name|rowType
argument_list|,
name|druidQuery
argument_list|)
else|:
name|simpleLeafFilter
return|;
block|}
specifier|private
specifier|static
annotation|@
name|Nullable
name|DruidJsonFilter
name|toDruidExpressionFilter
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|DruidQuery
name|query
parameter_list|)
block|{
specifier|final
name|String
name|expression
init|=
name|DruidExpressions
operator|.
name|toDruidExpression
argument_list|(
name|rexNode
argument_list|,
name|rowType
argument_list|,
name|query
argument_list|)
decl_stmt|;
return|return
name|expression
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|JsonExpressionFilter
argument_list|(
name|expression
argument_list|)
return|;
block|}
comment|/** Supported filter types. */
specifier|protected
enum|enum
name|Type
block|{
name|AND
block|,
name|OR
block|,
name|NOT
block|,
name|SELECTOR
block|,
name|IN
block|,
name|BOUND
block|,
name|EXPRESSION
block|;
specifier|public
name|String
name|lowercase
parameter_list|()
block|{
return|return
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|final
name|Type
name|type
decl_stmt|;
specifier|private
name|DruidJsonFilter
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
comment|/**    * Druid Expression filter.    */
specifier|public
specifier|static
class|class
name|JsonExpressionFilter
extends|extends
name|DruidJsonFilter
block|{
specifier|private
specifier|final
name|String
name|expression
decl_stmt|;
name|JsonExpressionFilter
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
name|super
argument_list|(
name|Type
operator|.
name|EXPRESSION
argument_list|)
expr_stmt|;
name|this
operator|.
name|expression
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|expression
argument_list|,
literal|"expression"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|JsonGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
name|generator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"type"
argument_list|,
name|type
operator|.
name|lowercase
argument_list|()
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"expression"
argument_list|,
name|expression
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
comment|/**      * We need to push to Druid an expression that always evaluates to true.      */
specifier|private
specifier|static
name|JsonExpressionFilter
name|alwaysTrue
parameter_list|()
block|{
return|return
operator|new
name|JsonExpressionFilter
argument_list|(
literal|"1 == 1"
argument_list|)
return|;
block|}
comment|/**      * We need to push to Druid an expression that always evaluates to false.      */
specifier|private
specifier|static
name|JsonExpressionFilter
name|alwaysFalse
parameter_list|()
block|{
return|return
operator|new
name|JsonExpressionFilter
argument_list|(
literal|"1 == 2"
argument_list|)
return|;
block|}
block|}
comment|/**    * Equality filter.    */
specifier|private
specifier|static
class|class
name|JsonSelector
extends|extends
name|DruidJsonFilter
block|{
specifier|private
specifier|final
name|String
name|dimension
decl_stmt|;
specifier|private
specifier|final
name|String
name|value
decl_stmt|;
specifier|private
specifier|final
name|ExtractionFunction
name|extractionFunction
decl_stmt|;
specifier|private
name|JsonSelector
parameter_list|(
name|String
name|dimension
parameter_list|,
name|String
name|value
parameter_list|,
name|ExtractionFunction
name|extractionFunction
parameter_list|)
block|{
name|super
argument_list|(
name|Type
operator|.
name|SELECTOR
argument_list|)
expr_stmt|;
name|this
operator|.
name|dimension
operator|=
name|dimension
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|extractionFunction
operator|=
name|extractionFunction
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|JsonGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
name|generator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"type"
argument_list|,
name|type
operator|.
name|lowercase
argument_list|()
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"dimension"
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"value"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|DruidQuery
operator|.
name|writeFieldIf
argument_list|(
name|generator
argument_list|,
literal|"extractionFn"
argument_list|,
name|extractionFunction
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Bound filter.    */
annotation|@
name|VisibleForTesting
specifier|protected
specifier|static
class|class
name|JsonBound
extends|extends
name|DruidJsonFilter
block|{
specifier|private
specifier|final
name|String
name|dimension
decl_stmt|;
specifier|private
specifier|final
name|String
name|lower
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|lowerStrict
decl_stmt|;
specifier|private
specifier|final
name|String
name|upper
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|upperStrict
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|alphaNumeric
decl_stmt|;
specifier|private
specifier|final
name|ExtractionFunction
name|extractionFunction
decl_stmt|;
specifier|protected
name|JsonBound
parameter_list|(
name|String
name|dimension
parameter_list|,
name|String
name|lower
parameter_list|,
name|boolean
name|lowerStrict
parameter_list|,
name|String
name|upper
parameter_list|,
name|boolean
name|upperStrict
parameter_list|,
name|boolean
name|alphaNumeric
parameter_list|,
name|ExtractionFunction
name|extractionFunction
parameter_list|)
block|{
name|super
argument_list|(
name|Type
operator|.
name|BOUND
argument_list|)
expr_stmt|;
name|this
operator|.
name|dimension
operator|=
name|dimension
expr_stmt|;
name|this
operator|.
name|lower
operator|=
name|lower
expr_stmt|;
name|this
operator|.
name|lowerStrict
operator|=
name|lowerStrict
expr_stmt|;
name|this
operator|.
name|upper
operator|=
name|upper
expr_stmt|;
name|this
operator|.
name|upperStrict
operator|=
name|upperStrict
expr_stmt|;
name|this
operator|.
name|alphaNumeric
operator|=
name|alphaNumeric
expr_stmt|;
name|this
operator|.
name|extractionFunction
operator|=
name|extractionFunction
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|JsonGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
name|generator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"type"
argument_list|,
name|type
operator|.
name|lowercase
argument_list|()
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"dimension"
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
if|if
condition|(
name|lower
operator|!=
literal|null
condition|)
block|{
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"lower"
argument_list|,
name|lower
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeBooleanField
argument_list|(
literal|"lowerStrict"
argument_list|,
name|lowerStrict
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upper
operator|!=
literal|null
condition|)
block|{
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"upper"
argument_list|,
name|upper
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeBooleanField
argument_list|(
literal|"upperStrict"
argument_list|,
name|upperStrict
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alphaNumeric
condition|)
block|{
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"ordering"
argument_list|,
literal|"numeric"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"ordering"
argument_list|,
literal|"lexicographic"
argument_list|)
expr_stmt|;
block|}
name|DruidQuery
operator|.
name|writeFieldIf
argument_list|(
name|generator
argument_list|,
literal|"extractionFn"
argument_list|,
name|extractionFunction
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Filter that combines other filters using a boolean operator.    */
specifier|private
specifier|static
class|class
name|JsonCompositeFilter
extends|extends
name|DruidJsonFilter
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|DruidJsonFilter
argument_list|>
name|fields
decl_stmt|;
specifier|private
name|JsonCompositeFilter
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|DruidJsonFilter
argument_list|>
name|fields
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|fields
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
specifier|private
name|JsonCompositeFilter
parameter_list|(
name|Type
name|type
parameter_list|,
name|DruidJsonFilter
modifier|...
name|fields
parameter_list|)
block|{
name|this
argument_list|(
name|type
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|JsonGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
name|generator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"type"
argument_list|,
name|type
operator|.
name|lowercase
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NOT
case|:
name|DruidQuery
operator|.
name|writeField
argument_list|(
name|generator
argument_list|,
literal|"field"
argument_list|,
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DruidQuery
operator|.
name|writeField
argument_list|(
name|generator
argument_list|,
literal|"fields"
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
name|generator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * IN filter.    */
specifier|protected
specifier|static
class|class
name|JsonInFilter
extends|extends
name|DruidJsonFilter
block|{
specifier|private
specifier|final
name|String
name|dimension
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|values
decl_stmt|;
specifier|private
specifier|final
name|ExtractionFunction
name|extractionFunction
decl_stmt|;
specifier|protected
name|JsonInFilter
parameter_list|(
name|String
name|dimension
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|values
parameter_list|,
name|ExtractionFunction
name|extractionFunction
parameter_list|)
block|{
name|super
argument_list|(
name|Type
operator|.
name|IN
argument_list|)
expr_stmt|;
name|this
operator|.
name|dimension
operator|=
name|dimension
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
name|this
operator|.
name|extractionFunction
operator|=
name|extractionFunction
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|JsonGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
name|generator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"type"
argument_list|,
name|type
operator|.
name|lowercase
argument_list|()
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"dimension"
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
name|DruidQuery
operator|.
name|writeField
argument_list|(
name|generator
argument_list|,
literal|"values"
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|DruidQuery
operator|.
name|writeFieldIf
argument_list|(
name|generator
argument_list|,
literal|"extractionFn"
argument_list|,
name|extractionFunction
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|DruidJsonFilter
name|getSelectorFilter
parameter_list|(
name|String
name|column
parameter_list|,
name|String
name|value
parameter_list|,
name|ExtractionFunction
name|extractionFunction
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|column
argument_list|,
literal|"column"
argument_list|)
expr_stmt|;
return|return
operator|new
name|JsonSelector
argument_list|(
name|column
argument_list|,
name|value
argument_list|,
name|extractionFunction
argument_list|)
return|;
block|}
comment|/** Druid Having Filter spec. */
specifier|protected
specifier|static
class|class
name|JsonDimHavingFilter
implements|implements
name|DruidJson
block|{
specifier|private
specifier|final
name|DruidJsonFilter
name|filter
decl_stmt|;
specifier|public
name|JsonDimHavingFilter
parameter_list|(
name|DruidJsonFilter
name|filter
parameter_list|)
block|{
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|JsonGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
name|generator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|generator
operator|.
name|writeStringField
argument_list|(
literal|"type"
argument_list|,
literal|"filter"
argument_list|)
expr_stmt|;
name|DruidQuery
operator|.
name|writeField
argument_list|(
name|generator
argument_list|,
literal|"filter"
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|generator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

