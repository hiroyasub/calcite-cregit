begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|druid
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateExtractProjectRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterAggregateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteTrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|ImmutableTriple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|immutables
operator|.
name|value
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|Interval
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Rules and relational operators for {@link DruidQuery}.  */
end_comment

begin_class
specifier|public
class|class
name|DruidRules
block|{
specifier|private
name|DruidRules
parameter_list|()
block|{
block|}
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|CalciteTrace
operator|.
name|getPlannerTracer
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidFilterRule
name|FILTER
init|=
name|DruidFilterRule
operator|.
name|DruidFilterRuleConfig
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidProjectRule
name|PROJECT
init|=
name|DruidProjectRule
operator|.
name|DruidProjectRuleConfig
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidAggregateRule
name|AGGREGATE
init|=
name|DruidAggregateRule
operator|.
name|DruidAggregateRuleConfig
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidAggregateProjectRule
name|AGGREGATE_PROJECT
init|=
name|DruidAggregateProjectRule
operator|.
name|DruidAggregateProjectRuleConfig
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidSortRule
name|SORT
init|=
name|DruidSortRule
operator|.
name|DruidSortRuleConfig
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule to push an {@link org.apache.calcite.rel.core.Sort} through a    * {@link org.apache.calcite.rel.core.Project}. Useful to transform    * to complex Druid queries. */
specifier|public
specifier|static
specifier|final
name|SortProjectTransposeRule
name|SORT_PROJECT_TRANSPOSE
init|=
operator|(
name|SortProjectTransposeRule
operator|)
name|SortProjectTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
name|Project
operator|.
name|class
argument_list|,
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|withDescription
argument_list|(
literal|"DruidSortProjectTransposeRule"
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule to push a {@link org.apache.calcite.rel.core.Project}    * past a {@link org.apache.calcite.rel.core.Filter}    * when {@code Filter} is on top of a {@link DruidQuery}. */
specifier|public
specifier|static
specifier|final
name|ProjectFilterTransposeRule
name|PROJECT_FILTER_TRANSPOSE
init|=
operator|(
name|ProjectFilterTransposeRule
operator|)
name|ProjectFilterTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|Filter
operator|.
name|class
argument_list|,
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|withDescription
argument_list|(
literal|"DruidProjectFilterTransposeRule"
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule to push a {@link org.apache.calcite.rel.core.Filter}    * past a {@link org.apache.calcite.rel.core.Project}    * when {@code Project} is on top of a {@link DruidQuery}. */
specifier|public
specifier|static
specifier|final
name|FilterProjectTransposeRule
name|FILTER_PROJECT_TRANSPOSE
init|=
operator|(
name|FilterProjectTransposeRule
operator|)
name|FilterProjectTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|Project
operator|.
name|class
argument_list|,
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|withCopyFilter
argument_list|(
literal|true
argument_list|)
operator|.
name|withCopyProject
argument_list|(
literal|true
argument_list|)
operator|.
name|withDescription
argument_list|(
literal|"DruidFilterProjectTransposeRule"
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule to push an {@link org.apache.calcite.rel.core.Aggregate}    * past a {@link org.apache.calcite.rel.core.Filter}    * when {@code Filter} is on top of a {@link DruidQuery}. */
specifier|public
specifier|static
specifier|final
name|AggregateFilterTransposeRule
name|AGGREGATE_FILTER_TRANSPOSE
init|=
operator|(
name|AggregateFilterTransposeRule
operator|)
name|AggregateFilterTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|Filter
operator|.
name|class
argument_list|,
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|withDescription
argument_list|(
literal|"DruidAggregateFilterTransposeRule"
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule to push an {@link org.apache.calcite.rel.core.Filter}    * past an {@link org.apache.calcite.rel.core.Aggregate}    * when {@code Aggregate} is on top of a {@link DruidQuery}. */
specifier|public
specifier|static
specifier|final
name|FilterAggregateTransposeRule
name|FILTER_AGGREGATE_TRANSPOSE
init|=
operator|(
name|FilterAggregateTransposeRule
operator|)
name|FilterAggregateTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|,
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|withDescription
argument_list|(
literal|"DruidFilterAggregateTransposeRule"
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidPostAggregationProjectRule
name|POST_AGGREGATION_PROJECT
init|=
name|DruidPostAggregationProjectRule
operator|.
name|DruidPostAggregationProjectRuleConfig
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule to extract a {@link org.apache.calcite.rel.core.Project} from    * {@link org.apache.calcite.rel.core.Aggregate} on top of    * {@link org.apache.calcite.adapter.druid.DruidQuery} based on the fields    * used in the aggregate. */
specifier|public
specifier|static
specifier|final
name|AggregateExtractProjectRule
name|PROJECT_EXTRACT_RULE
init|=
operator|(
name|AggregateExtractProjectRule
operator|)
name|AggregateExtractProjectRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|withDescription
argument_list|(
literal|"DruidAggregateExtractProjectRule"
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidHavingFilterRule
name|DRUID_HAVING_FILTER_RULE
init|=
name|DruidHavingFilterRule
operator|.
name|DruidHavingFilterRuleConfig
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|RULES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|FILTER
argument_list|,
name|PROJECT_FILTER_TRANSPOSE
argument_list|,
name|AGGREGATE_FILTER_TRANSPOSE
argument_list|,
name|AGGREGATE_PROJECT
argument_list|,
name|PROJECT_EXTRACT_RULE
argument_list|,
name|PROJECT
argument_list|,
name|POST_AGGREGATION_PROJECT
argument_list|,
name|AGGREGATE
argument_list|,
name|FILTER_AGGREGATE_TRANSPOSE
argument_list|,
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|SORT
argument_list|,
name|SORT_PROJECT_TRANSPOSE
argument_list|,
name|DRUID_HAVING_FILTER_RULE
argument_list|)
decl_stmt|;
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Filter} into a    * {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidFilterRule
extends|extends
name|RelRule
argument_list|<
name|DruidFilterRule
operator|.
name|DruidFilterRuleConfig
argument_list|>
block|{
comment|/** Creates a DruidFilterRule. */
specifier|protected
name|DruidFilterRule
parameter_list|(
name|DruidFilterRuleConfig
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|filter
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|call
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'f'
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|validPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonValidPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|Util
operator|.
name|first
argument_list|(
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|call
operator|.
name|getMetadataQuery
argument_list|()
operator|.
name|getPulledUpPredicates
argument_list|(
name|filter
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|predicates
argument_list|,
name|executor
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cond
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|cond
argument_list|)
control|)
block|{
name|DruidJsonFilter
name|druidJsonFilter
init|=
name|DruidJsonFilter
operator|.
name|toDruidFilters
argument_list|(
name|e
argument_list|,
name|filter
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|query
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
if|if
condition|(
name|druidJsonFilter
operator|!=
literal|null
condition|)
block|{
name|validPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonValidPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Timestamp
name|int
name|timestampFieldIdx
init|=
name|query
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|indexOf
argument_list|(
name|query
operator|.
name|druidTable
operator|.
name|timestampFieldName
argument_list|)
decl_stmt|;
name|RelNode
name|newDruidQuery
init|=
name|query
decl_stmt|;
specifier|final
name|Triple
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|triple
init|=
name|splitFilters
argument_list|(
name|validPreds
argument_list|,
name|nonValidPreds
argument_list|,
name|timestampFieldIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|triple
operator|.
name|getLeft
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|triple
operator|.
name|getMiddle
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// it sucks, nothing to push
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|residualPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|triple
operator|.
name|getRight
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Interval
argument_list|>
name|intervals
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|triple
operator|.
name|getLeft
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|String
name|timeZone
init|=
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|unwrap
argument_list|(
name|CalciteConnectionConfig
operator|.
name|class
argument_list|)
operator|.
name|timeZone
argument_list|()
decl_stmt|;
assert|assert
name|timeZone
operator|!=
literal|null
assert|;
name|intervals
operator|=
name|DruidDateTimeUtils
operator|.
name|createInterval
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|triple
operator|.
name|getLeft
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intervals
operator|==
literal|null
operator|||
name|intervals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Case we have a filter with extract that can not be written as interval push down
name|triple
operator|.
name|getMiddle
argument_list|()
operator|.
name|addAll
argument_list|(
name|triple
operator|.
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|triple
operator|.
name|getMiddle
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|RelNode
name|newFilter
init|=
name|filter
operator|.
name|copy
argument_list|(
name|filter
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|,
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|triple
operator|.
name|getMiddle
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|newDruidQuery
operator|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newFilter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intervals
operator|!=
literal|null
operator|&&
operator|!
name|intervals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newDruidQuery
operator|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
operator|(
name|DruidQuery
operator|)
name|newDruidQuery
argument_list|,
name|intervals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|residualPreds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newDruidQuery
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|newDruidQuery
argument_list|)
operator|.
name|filter
argument_list|(
name|residualPreds
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|newDruidQuery
argument_list|)
expr_stmt|;
block|}
comment|/**      * Given a list of conditions that contain Druid valid operations and      * a list that contains those that contain any non-supported operation,      * it outputs a triple with three different categories:      * 1-l) condition filters on the timestamp column,      * 2-m) condition filters that can be pushed to Druid,      * 3-r) condition filters that cannot be pushed to Druid.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"BetaApi"
argument_list|)
specifier|private
specifier|static
name|Triple
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|splitFilters
parameter_list|(
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|validPreds
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonValidPreds
parameter_list|,
specifier|final
name|int
name|timestampFieldIdx
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|timeRangeNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushableNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonPushableNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|nonValidPreds
argument_list|)
decl_stmt|;
comment|// Number of columns with the dimensions and timestamp
for|for
control|(
name|RexNode
name|conj
range|:
name|validPreds
control|)
block|{
specifier|final
name|RelOptUtil
operator|.
name|InputReferencedVisitor
name|visitor
init|=
operator|new
name|RelOptUtil
operator|.
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
name|conj
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
if|if
condition|(
name|visitor
operator|.
name|inputPosReferenced
operator|.
name|contains
argument_list|(
name|timestampFieldIdx
argument_list|)
operator|&&
name|visitor
operator|.
name|inputPosReferenced
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|timeRangeNodes
operator|.
name|add
argument_list|(
name|conj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pushableNodes
operator|.
name|add
argument_list|(
name|conj
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ImmutableTriple
operator|.
name|of
argument_list|(
name|timeRangeNodes
argument_list|,
name|pushableNodes
argument_list|,
name|nonPushableNodes
argument_list|)
return|;
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|DruidFilterRuleConfig
extends|extends
name|RelRule
operator|.
name|Config
block|{
name|DruidFilterRuleConfig
name|DEFAULT
init|=
name|ImmutableDruidFilterRuleConfig
operator|.
name|builder
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|noInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|default
name|DruidFilterRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|DruidFilterRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Rule to Push a Having {@link Filter} into a {@link DruidQuery}. */
specifier|public
specifier|static
class|class
name|DruidHavingFilterRule
extends|extends
name|RelRule
argument_list|<
name|DruidHavingFilterRule
operator|.
name|DruidHavingFilterRuleConfig
argument_list|>
block|{
comment|/** Creates a DruidHavingFilterRule. */
specifier|protected
name|DruidHavingFilterRule
parameter_list|(
name|DruidHavingFilterRuleConfig
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|filter
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'h'
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|RexNode
name|cond
init|=
name|filter
operator|.
name|getCondition
argument_list|()
decl_stmt|;
specifier|final
name|DruidJsonFilter
name|druidJsonFilter
init|=
name|DruidJsonFilter
operator|.
name|toDruidFilters
argument_list|(
name|cond
argument_list|,
name|query
operator|.
name|getTopNode
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|query
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
if|if
condition|(
name|druidJsonFilter
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelNode
name|newFilter
init|=
name|filter
operator|.
name|copy
argument_list|(
name|filter
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|newDruidQuery
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newFilter
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newDruidQuery
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|DruidHavingFilterRuleConfig
extends|extends
name|RelRule
operator|.
name|Config
block|{
name|DruidHavingFilterRuleConfig
name|DEFAULT
init|=
name|ImmutableDruidHavingFilterRuleConfig
operator|.
name|builder
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|noInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|default
name|DruidHavingFilterRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|DruidHavingFilterRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Project} into a    * {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidProjectRule
extends|extends
name|RelRule
argument_list|<
name|DruidProjectRule
operator|.
name|DruidProjectRuleConfig
argument_list|>
block|{
comment|/** Creates a DruidProjectRule. */
specifier|protected
name|DruidProjectRule
parameter_list|(
name|DruidProjectRuleConfig
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|project
operator|.
name|getVariablesSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|project
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'p'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|DruidQuery
operator|.
name|computeProjectAsScan
argument_list|(
name|project
argument_list|,
name|query
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|query
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// All expressions can be pushed to Druid in their entirety.
specifier|final
name|RelNode
name|newProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RelNode
name|newNode
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newProject
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|Pair
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|pair
init|=
name|splitProjects
argument_list|(
name|rexBuilder
argument_list|,
name|query
argument_list|,
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
comment|// We can't push anything useful to Druid.
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|above
init|=
name|pair
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|below
init|=
name|pair
operator|.
name|right
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|below
control|)
block|{
specifier|final
name|String
name|name
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|name
operator|=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
literal|null
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|e
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|newProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|input
argument_list|,
name|below
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|newQuery
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newProject
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newProject2
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newQuery
argument_list|,
name|above
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProject2
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|Pair
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|splitProjects
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RelNode
name|input
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RelOptUtil
operator|.
name|InputReferencedVisitor
name|visitor
init|=
operator|new
name|RelOptUtil
operator|.
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
name|visitor
operator|.
name|visitEach
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|visitor
operator|.
name|inputPosReferenced
operator|.
name|size
argument_list|()
operator|==
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// All inputs are referenced
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|belowNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|belowTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|positions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|visitor
operator|.
name|inputPosReferenced
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|positions
control|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|input
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|belowNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|belowTypes
operator|.
name|add
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|aboveNodes
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|positions
operator|.
name|indexOf
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|belowTypes
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|)
return|;
block|}
block|}
operator|.
name|visitList
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|aboveNodes
argument_list|,
name|belowNodes
argument_list|)
return|;
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|DruidProjectRuleConfig
extends|extends
name|RelRule
operator|.
name|Config
block|{
name|DruidProjectRuleConfig
name|DEFAULT
init|=
name|ImmutableDruidProjectRuleConfig
operator|.
name|builder
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|noInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|default
name|DruidProjectRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|DruidProjectRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Project} into a    * {@link DruidQuery} as a Post aggregator.    */
specifier|public
specifier|static
class|class
name|DruidPostAggregationProjectRule
extends|extends
name|RelRule
argument_list|<
name|DruidPostAggregationProjectRule
operator|.
name|DruidPostAggregationProjectRuleConfig
argument_list|>
block|{
comment|/** Creates a DruidPostAggregationProjectRule. */
specifier|protected
name|DruidPostAggregationProjectRule
parameter_list|(
name|DruidPostAggregationProjectRuleConfig
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'o'
argument_list|)
condition|)
block|{
return|return;
block|}
name|boolean
name|hasRexCalls
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RexNode
name|rexNode
range|:
name|project
operator|.
name|getProjects
argument_list|()
control|)
block|{
if|if
condition|(
name|rexNode
operator|instanceof
name|RexCall
condition|)
block|{
name|hasRexCalls
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// Only try to push down Project when there will be Post aggregators in result DruidQuery
if|if
condition|(
name|hasRexCalls
condition|)
block|{
specifier|final
name|RelNode
name|topNode
init|=
name|query
operator|.
name|getTopNode
argument_list|()
decl_stmt|;
specifier|final
name|Aggregate
name|topAgg
decl_stmt|;
if|if
condition|(
name|topNode
operator|instanceof
name|Aggregate
condition|)
block|{
name|topAgg
operator|=
operator|(
name|Aggregate
operator|)
name|topNode
expr_stmt|;
block|}
else|else
block|{
name|topAgg
operator|=
operator|(
name|Aggregate
operator|)
operator|(
operator|(
name|Filter
operator|)
name|topNode
operator|)
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|RexNode
name|rexNode
range|:
name|project
operator|.
name|getProjects
argument_list|()
control|)
block|{
if|if
condition|(
name|DruidExpressions
operator|.
name|toDruidExpression
argument_list|(
name|rexNode
argument_list|,
name|topAgg
operator|.
name|getRowType
argument_list|()
argument_list|,
name|query
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
specifier|final
name|RelNode
name|newProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|newQuery
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newProject
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newQuery
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|DruidPostAggregationProjectRuleConfig
extends|extends
name|RelRule
operator|.
name|Config
block|{
name|DruidPostAggregationProjectRuleConfig
name|DEFAULT
init|=
name|ImmutableDruidPostAggregationProjectRuleConfig
operator|.
name|builder
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|noInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|default
name|DruidPostAggregationProjectRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|DruidPostAggregationProjectRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Rule to push an {@link org.apache.calcite.rel.core.Aggregate}    * into a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidAggregateRule
extends|extends
name|RelRule
argument_list|<
name|DruidAggregateRule
operator|.
name|DruidAggregateRuleConfig
argument_list|>
block|{
comment|/** Creates a DruidAggregateRule. */
specifier|protected
name|DruidAggregateRule
parameter_list|(
name|DruidAggregateRuleConfig
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|topDruidNode
init|=
name|query
operator|.
name|getTopNode
argument_list|()
decl_stmt|;
specifier|final
name|Project
name|project
init|=
name|topDruidNode
operator|instanceof
name|Project
condition|?
operator|(
name|Project
operator|)
name|topDruidNode
else|:
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'a'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|aggregate
operator|.
name|getGroupSets
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|DruidQuery
operator|.
name|computeProjectGroupSet
argument_list|(
name|project
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|query
operator|.
name|table
operator|.
name|getRowType
argument_list|()
argument_list|,
name|query
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|aggNames
init|=
name|Util
operator|.
name|skip
argument_list|(
name|aggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|DruidQuery
operator|.
name|computeDruidJsonAgg
argument_list|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|,
name|aggNames
argument_list|,
name|project
argument_list|,
name|query
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|RelNode
name|newAggregate
init|=
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|query
operator|.
name|getTopNode
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newAggregate
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|DruidAggregateRuleConfig
extends|extends
name|RelRule
operator|.
name|Config
block|{
name|DruidAggregateRuleConfig
name|DEFAULT
init|=
name|ImmutableDruidAggregateRuleConfig
operator|.
name|builder
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|noInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|default
name|DruidAggregateRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|DruidAggregateRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Rule to push an {@link org.apache.calcite.rel.core.Aggregate} and    * {@link org.apache.calcite.rel.core.Project} into a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidAggregateProjectRule
extends|extends
name|RelRule
argument_list|<
name|DruidAggregateProjectRule
operator|.
name|DruidAggregateProjectRuleConfig
argument_list|>
block|{
comment|/** Creates a DruidAggregateProjectRule. */
specifier|protected
name|DruidAggregateProjectRule
parameter_list|(
name|DruidAggregateProjectRuleConfig
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'p'
operator|+
literal|'a'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|aggregate
operator|.
name|getGroupSets
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|DruidQuery
operator|.
name|computeProjectGroupSet
argument_list|(
name|project
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|query
operator|.
name|table
operator|.
name|getRowType
argument_list|()
argument_list|,
name|query
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|aggNames
init|=
name|Util
operator|.
name|skip
argument_list|(
name|aggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|DruidQuery
operator|.
name|computeDruidJsonAgg
argument_list|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|,
name|aggNames
argument_list|,
name|project
argument_list|,
name|query
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|RelNode
name|newProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newAggregate
init|=
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newProject
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|filterRefs
init|=
name|getFilterRefs
argument_list|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query2
decl_stmt|;
if|if
condition|(
name|filterRefs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|query2
operator|=
name|optimizeFilteredAggregations
argument_list|(
name|call
argument_list|,
name|query
argument_list|,
operator|(
name|Project
operator|)
name|newProject
argument_list|,
operator|(
name|Aggregate
operator|)
name|newAggregate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|DruidQuery
name|query1
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newProject
argument_list|)
decl_stmt|;
name|query2
operator|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query1
argument_list|,
name|newAggregate
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|query2
argument_list|)
expr_stmt|;
block|}
comment|/** Returns an array of unique filter references from the given list of      * {@link org.apache.calcite.rel.core.AggregateCall}s. */
specifier|private
specifier|static
name|Set
argument_list|<
name|Integer
argument_list|>
name|getUniqueFilterRefs
parameter_list|(
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|calls
parameter_list|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|refs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|call
range|:
name|calls
control|)
block|{
if|if
condition|(
name|call
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
name|refs
operator|.
name|add
argument_list|(
name|call
operator|.
name|filterArg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|refs
return|;
block|}
comment|/**      * Attempts to optimize any aggregations with filters in the DruidQuery.      * Uses the following steps:      *      *<ol>      *<li>Tries to abstract common filters out into the "filter" field;      *<li>Eliminates expressions that are always true or always false when      *     possible;      *<li>ANDs aggregate filters together with the outer filter to allow for      *     pruning of data.      *</ol>      *      *<p>Should be called before pushing both the aggregate and project into      * Druid. Assumes that at least one aggregate call has a filter attached to      * it. */
specifier|private
specifier|static
name|DruidQuery
name|optimizeFilteredAggregations
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|,
name|DruidQuery
name|query
parameter_list|,
name|Project
name|project
parameter_list|,
name|Aggregate
name|aggregate
parameter_list|)
block|{
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
specifier|final
name|RexBuilder
name|builder
init|=
name|query
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|Util
operator|.
name|first
argument_list|(
name|query
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|scan
init|=
name|query
operator|.
name|rels
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// first rel is the table scan
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|call
operator|.
name|getMetadataQuery
argument_list|()
operator|.
name|getPulledUpPredicates
argument_list|(
name|scan
argument_list|)
decl_stmt|;
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|builder
argument_list|,
name|predicates
argument_list|,
name|executor
argument_list|)
decl_stmt|;
comment|// if the druid query originally contained a filter
name|boolean
name|containsFilter
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RelNode
name|node
range|:
name|query
operator|.
name|rels
control|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|Filter
condition|)
block|{
name|filter
operator|=
operator|(
name|Filter
operator|)
name|node
expr_stmt|;
name|containsFilter
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// if every aggregate call has a filter arg reference
name|boolean
name|allHaveFilters
init|=
name|allAggregatesHaveFilters
argument_list|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|uniqueFilterRefs
init|=
name|getUniqueFilterRefs
argument_list|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
comment|// One of the pre-conditions for this method
assert|assert
name|uniqueFilterRefs
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// OR all the filters so that they can ANDed to the outer filter
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|i
range|:
name|uniqueFilterRefs
control|)
block|{
name|disjunctions
operator|.
name|add
argument_list|(
name|stripFilter
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|filterNode
init|=
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|builder
argument_list|,
name|disjunctions
argument_list|)
decl_stmt|;
comment|// Erase references to filters
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|uniqueFilterRefs
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|allHaveFilters
operator|)
comment|// filters get extracted
operator|||
name|aggCall
operator|.
name|hasFilter
argument_list|()
operator|&&
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|aggCall
operator|.
name|filterArg
argument_list|)
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|aggCall
operator|=
name|aggCall
operator|.
name|withFilter
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|newCalls
operator|.
name|add
argument_list|(
name|aggCall
argument_list|)
expr_stmt|;
block|}
name|aggregate
operator|=
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getGroupSets
argument_list|()
argument_list|,
name|newCalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsFilter
condition|)
block|{
comment|// AND the current filterNode with the filter node inside filter
name|filterNode
operator|=
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|filterNode
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Simplify the filter as much as possible
name|RexNode
name|tempFilterNode
init|=
name|filterNode
decl_stmt|;
name|filterNode
operator|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|filterNode
argument_list|)
expr_stmt|;
comment|// It's possible that after simplification that the expression is now always false.
comment|// Druid cannot handle such a filter.
comment|// This will happen when the below expression (f_n+1 may not exist):
comment|// f_n+1 AND (f_1 OR f_2 OR ... OR f_n) simplifies to be something always false.
comment|// f_n+1 cannot be false, since it came from a pushed filter rel node
comment|// and each f_i cannot be false, since DruidAggregateProjectRule would have caught that.
comment|// So, the only solution is to revert back to the un simplified version and let Druid
comment|// handle a filter that is ultimately unsatisfiable.
if|if
condition|(
name|filterNode
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
name|filterNode
operator|=
name|tempFilterNode
expr_stmt|;
block|}
name|filter
operator|=
name|LogicalFilter
operator|.
name|create
argument_list|(
name|scan
argument_list|,
name|filterNode
argument_list|)
expr_stmt|;
name|boolean
name|addNewFilter
init|=
operator|!
name|filter
operator|.
name|getCondition
argument_list|()
operator|.
name|isAlwaysTrue
argument_list|()
operator|&&
name|allHaveFilters
decl_stmt|;
comment|// Assumes that Filter nodes are always right after
comment|// TableScan nodes (which are always present)
name|int
name|startIndex
init|=
name|containsFilter
operator|&&
name|addNewFilter
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newNodes
init|=
name|constructNewNodes
argument_list|(
name|query
operator|.
name|rels
argument_list|,
name|addNewFilter
argument_list|,
name|startIndex
argument_list|,
name|filter
argument_list|,
name|project
argument_list|,
name|aggregate
argument_list|)
decl_stmt|;
return|return
name|DruidQuery
operator|.
name|create
argument_list|(
name|query
operator|.
name|getCluster
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|query
operator|.
name|getConvention
argument_list|()
argument_list|)
argument_list|,
name|query
operator|.
name|getTable
argument_list|()
argument_list|,
name|query
operator|.
name|druidTable
argument_list|,
name|newNodes
argument_list|)
return|;
block|}
comment|// Returns true if and only if every AggregateCall in calls has a filter argument.
specifier|private
specifier|static
name|boolean
name|allAggregatesHaveFilters
parameter_list|(
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|calls
parameter_list|)
block|{
for|for
control|(
name|AggregateCall
name|call
range|:
name|calls
control|)
block|{
if|if
condition|(
operator|!
name|call
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns a new List of RelNodes in the order of the given order of the oldNodes,      * the given {@link Filter}, and any extra nodes.      */
specifier|private
specifier|static
name|List
argument_list|<
name|RelNode
argument_list|>
name|constructNewNodes
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|oldNodes
parameter_list|,
name|boolean
name|addFilter
parameter_list|,
name|int
name|startIndex
parameter_list|,
name|RelNode
name|filter
parameter_list|,
name|RelNode
modifier|...
name|trailingNodes
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|newNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// The first item should always be the Table scan, so any filter would go after that
name|newNodes
operator|.
name|add
argument_list|(
name|oldNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addFilter
condition|)
block|{
name|newNodes
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
comment|// This is required so that each RelNode is linked to the one before it
if|if
condition|(
name|startIndex
operator|<
name|oldNodes
operator|.
name|size
argument_list|()
condition|)
block|{
name|RelNode
name|next
init|=
name|oldNodes
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
decl_stmt|;
name|newNodes
operator|.
name|add
argument_list|(
name|next
operator|.
name|copy
argument_list|(
name|next
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|filter
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|startIndex
operator|++
expr_stmt|;
block|}
block|}
comment|// Add the rest of the nodes from oldNodes
for|for
control|(
name|int
name|i
init|=
name|startIndex
init|;
name|i
operator|<
name|oldNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|newNodes
operator|.
name|add
argument_list|(
name|oldNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add the trailing nodes (need to link them)
for|for
control|(
name|RelNode
name|node
range|:
name|trailingNodes
control|)
block|{
name|newNodes
operator|.
name|add
argument_list|(
name|node
operator|.
name|copy
argument_list|(
name|node
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|newNodes
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newNodes
return|;
block|}
comment|// Removes the IS_TRUE in front of RexCalls, if they exist
specifier|private
specifier|static
name|RexNode
name|stripFilter
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_TRUE
condition|)
block|{
return|return
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|getFilterRefs
parameter_list|(
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|calls
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|refs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|call
range|:
name|calls
control|)
block|{
if|if
condition|(
name|call
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
name|refs
operator|.
name|add
argument_list|(
name|call
operator|.
name|filterArg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|refs
return|;
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|DruidAggregateProjectRuleConfig
extends|extends
name|RelRule
operator|.
name|Config
block|{
name|DruidAggregateProjectRuleConfig
name|DEFAULT
init|=
name|ImmutableDruidAggregateProjectRuleConfig
operator|.
name|builder
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b2
lambda|->
name|b2
operator|.
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|noInputs
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|default
name|DruidAggregateProjectRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|DruidAggregateProjectRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Sort}    * into a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidSortRule
extends|extends
name|RelRule
argument_list|<
name|DruidSortRule
operator|.
name|DruidSortRuleConfig
argument_list|>
block|{
comment|/** Creates a DruidSortRule. */
specifier|protected
name|DruidSortRule
parameter_list|(
name|DruidSortRuleConfig
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Sort
name|sort
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'l'
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Either it is:
comment|// - a pure limit above a query of type scan
comment|// - a sort and limit on a dimension/metric part of the druid group by query
if|if
condition|(
name|sort
operator|.
name|offset
operator|!=
literal|null
operator|&&
name|RexLiteral
operator|.
name|intValue
argument_list|(
name|sort
operator|.
name|offset
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// offset not supported by Druid
return|return;
block|}
if|if
condition|(
name|query
operator|.
name|getQueryType
argument_list|()
operator|==
name|QueryType
operator|.
name|SCAN
operator|&&
operator|!
name|RelOptUtil
operator|.
name|isPureLimit
argument_list|(
name|sort
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|RelNode
name|newSort
init|=
name|sort
operator|.
name|copy
argument_list|(
name|sort
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newSort
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|DruidSortRuleConfig
extends|extends
name|RelRule
operator|.
name|Config
block|{
name|DruidSortRuleConfig
name|DEFAULT
init|=
name|ImmutableDruidSortRuleConfig
operator|.
name|builder
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Sort
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|)
operator|.
name|noInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|default
name|DruidSortRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|DruidSortRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

