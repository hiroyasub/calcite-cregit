begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|druid
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterAggregateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectSortTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|PushProjector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|PredicateImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteTrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|ImmutableTriple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|Interval
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Rules and relational operators for {@link DruidQuery}.  */
end_comment

begin_class
specifier|public
class|class
name|DruidRules
block|{
specifier|private
name|DruidRules
parameter_list|()
block|{
block|}
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|CalciteTrace
operator|.
name|getPlannerTracer
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidFilterRule
name|FILTER
init|=
operator|new
name|DruidFilterRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidProjectRule
name|PROJECT
init|=
operator|new
name|DruidProjectRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidAggregateRule
name|AGGREGATE
init|=
operator|new
name|DruidAggregateRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidAggregateProjectRule
name|AGGREGATE_PROJECT
init|=
operator|new
name|DruidAggregateProjectRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidSortRule
name|SORT
init|=
operator|new
name|DruidSortRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidSortProjectTransposeRule
name|SORT_PROJECT_TRANSPOSE
init|=
operator|new
name|DruidSortProjectTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidProjectSortTransposeRule
name|PROJECT_SORT_TRANSPOSE
init|=
operator|new
name|DruidProjectSortTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidProjectFilterTransposeRule
name|PROJECT_FILTER_TRANSPOSE
init|=
operator|new
name|DruidProjectFilterTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidFilterProjectTransposeRule
name|FILTER_PROJECT_TRANSPOSE
init|=
operator|new
name|DruidFilterProjectTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidAggregateFilterTransposeRule
name|AGGREGATE_FILTER_TRANSPOSE
init|=
operator|new
name|DruidAggregateFilterTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidFilterAggregateTransposeRule
name|FILTER_AGGREGATE_TRANSPOSE
init|=
operator|new
name|DruidFilterAggregateTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DruidPostAggregationProjectRule
name|POST_AGGREGATION_PROJECT
init|=
operator|new
name|DruidPostAggregationProjectRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|RULES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|FILTER
argument_list|,
name|PROJECT_FILTER_TRANSPOSE
argument_list|,
comment|// Disabled, per
comment|//   [CALCITE-1706] DruidAggregateFilterTransposeRule
comment|//   causes very fine-grained aggregations to be pushed to Druid
comment|// AGGREGATE_FILTER_TRANSPOSE,
name|AGGREGATE_PROJECT
argument_list|,
name|PROJECT
argument_list|,
name|POST_AGGREGATION_PROJECT
argument_list|,
name|AGGREGATE
argument_list|,
name|FILTER_AGGREGATE_TRANSPOSE
argument_list|,
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|PROJECT_SORT_TRANSPOSE
argument_list|,
name|SORT
argument_list|,
name|SORT_PROJECT_TRANSPOSE
argument_list|)
decl_stmt|;
comment|/** Predicate that returns whether Druid can not handle an aggregate. */
specifier|private
specifier|static
specifier|final
name|Predicate
argument_list|<
name|Triple
argument_list|<
name|Aggregate
argument_list|,
name|RelNode
argument_list|,
name|DruidQuery
argument_list|>
argument_list|>
name|BAD_AGG
init|=
operator|new
name|PredicateImpl
argument_list|<
name|Triple
argument_list|<
name|Aggregate
argument_list|,
name|RelNode
argument_list|,
name|DruidQuery
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|test
parameter_list|(
name|Triple
argument_list|<
name|Aggregate
argument_list|,
name|RelNode
argument_list|,
name|DruidQuery
argument_list|>
name|triple
parameter_list|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
name|triple
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|node
init|=
name|triple
operator|.
name|getMiddle
argument_list|()
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|triple
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|CalciteConnectionConfig
name|config
init|=
name|query
operator|.
name|getConnectionConfig
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
switch|switch
condition|(
name|aggregateCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|COUNT
case|:
comment|// Druid count aggregator can handle 3 scenarios:
comment|// 1. count(distinct col) when approximate results
comment|//    are acceptable and col is not a metric.
comment|//    Note that exact count(distinct column) is handled
comment|//    by being rewritten into group by followed by count
comment|// 2. count(*)
comment|// 3. count(column)
if|if
condition|(
name|checkAggregateOnMetric
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|aggregateCall
operator|.
name|getArgList
argument_list|()
argument_list|)
argument_list|,
name|node
argument_list|,
name|query
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// case count(*)
if|if
condition|(
name|aggregateCall
operator|.
name|getArgList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// case count(column)
if|if
condition|(
name|aggregateCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// case count(distinct and is approximate)
if|if
condition|(
name|aggregateCall
operator|.
name|isDistinct
argument_list|()
operator|&&
operator|(
name|aggregateCall
operator|.
name|isApproximate
argument_list|()
operator|||
name|config
operator|.
name|approximateDistinctCount
argument_list|()
operator|)
condition|)
block|{
continue|continue;
block|}
return|return
literal|true
return|;
case|case
name|SUM
case|:
case|case
name|SUM0
case|:
case|case
name|MIN
case|:
case|case
name|MAX
case|:
specifier|final
name|RelDataType
name|type
init|=
name|aggregateCall
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|SqlTypeName
name|sqlTypeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|SqlTypeFamily
operator|.
name|APPROXIMATE_NUMERIC
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|sqlTypeName
argument_list|)
operator|||
name|SqlTypeFamily
operator|.
name|INTEGER
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|sqlTypeName
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|else if
condition|(
name|SqlTypeFamily
operator|.
name|EXACT_NUMERIC
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|sqlTypeName
argument_list|)
condition|)
block|{
comment|// Decimal
assert|assert
name|sqlTypeName
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
assert|;
if|if
condition|(
name|type
operator|.
name|getScale
argument_list|()
operator|==
literal|0
operator|||
name|config
operator|.
name|approximateDecimal
argument_list|()
condition|)
block|{
comment|// If scale is zero or we allow approximating decimal, we can proceed
continue|continue;
block|}
block|}
comment|// Cannot handle this aggregate function
return|return
literal|true
return|;
default|default:
comment|// Cannot handle this aggregate function
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Filter} into a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidFilterRule
extends|extends
name|RelOptRule
block|{
comment|/**      * Creates a DruidFilterRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidFilterRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|filter
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|call
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'f'
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|validPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonValidPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|Util
operator|.
name|first
argument_list|(
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|call
operator|.
name|getMetadataQuery
argument_list|()
operator|.
name|getPulledUpPredicates
argument_list|(
name|filter
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|predicates
argument_list|,
literal|true
argument_list|,
name|executor
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cond
init|=
name|simplify
operator|.
name|simplify
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|cond
argument_list|)
control|)
block|{
if|if
condition|(
name|query
operator|.
name|isValidFilter
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|validPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonValidPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Timestamp
name|int
name|timestampFieldIdx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|query
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|query
operator|.
name|druidTable
operator|.
name|timestampFieldName
operator|.
name|equals
argument_list|(
name|query
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|timestampFieldIdx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
specifier|final
name|Triple
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|triple
init|=
name|splitFilters
argument_list|(
name|rexBuilder
argument_list|,
name|query
argument_list|,
name|validPreds
argument_list|,
name|nonValidPreds
argument_list|,
name|timestampFieldIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|triple
operator|.
name|getLeft
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|triple
operator|.
name|getMiddle
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We can't push anything useful to Druid.
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|residualPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|triple
operator|.
name|getRight
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Interval
argument_list|>
name|intervals
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|triple
operator|.
name|getLeft
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|intervals
operator|=
name|DruidDateTimeUtils
operator|.
name|createInterval
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|triple
operator|.
name|getLeft
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|,
name|cluster
operator|.
name|getPlanner
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|unwrap
argument_list|(
name|CalciteConnectionConfig
operator|.
name|class
argument_list|)
operator|.
name|timeZone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|intervals
operator|==
literal|null
operator|||
name|intervals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Case we have an filter with extract that can not be written as interval push down
name|triple
operator|.
name|getMiddle
argument_list|()
operator|.
name|addAll
argument_list|(
name|triple
operator|.
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|RelNode
name|newDruidQuery
init|=
name|query
decl_stmt|;
if|if
condition|(
operator|!
name|triple
operator|.
name|getMiddle
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|RelNode
name|newFilter
init|=
name|filter
operator|.
name|copy
argument_list|(
name|filter
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|,
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|triple
operator|.
name|getMiddle
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|newDruidQuery
operator|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newFilter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intervals
operator|!=
literal|null
operator|&&
operator|!
name|intervals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newDruidQuery
operator|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
operator|(
name|DruidQuery
operator|)
name|newDruidQuery
argument_list|,
name|intervals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|residualPreds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newDruidQuery
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|newDruidQuery
argument_list|)
operator|.
name|filter
argument_list|(
name|residualPreds
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|newDruidQuery
argument_list|)
expr_stmt|;
block|}
comment|/**      * Given a list of conditions that contain Druid valid operations and      * a list that contains those that contain any non-supported operation,      * it outputs a triple with three different categories:      * 1-l) condition filters on the timestamp column,      * 2-m) condition filters that can be pushed to Druid,      * 3-r) condition filters that cannot be pushed to Druid.      */
specifier|private
specifier|static
name|Triple
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|splitFilters
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|DruidQuery
name|input
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|validPreds
parameter_list|,
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonValidPreds
parameter_list|,
specifier|final
name|int
name|timestampFieldIdx
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|timeRangeNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushableNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonPushableNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|nonValidPreds
argument_list|)
decl_stmt|;
comment|// Number of columns with the dimensions and timestamp
for|for
control|(
name|RexNode
name|conj
range|:
name|validPreds
control|)
block|{
specifier|final
name|RelOptUtil
operator|.
name|InputReferencedVisitor
name|visitor
init|=
operator|new
name|RelOptUtil
operator|.
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
name|conj
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
if|if
condition|(
name|visitor
operator|.
name|inputPosReferenced
operator|.
name|contains
argument_list|(
name|timestampFieldIdx
argument_list|)
condition|)
block|{
if|if
condition|(
name|visitor
operator|.
name|inputPosReferenced
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
comment|// Complex predicate, transformation currently not supported
name|nonPushableNodes
operator|.
name|add
argument_list|(
name|conj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timeRangeNodes
operator|.
name|add
argument_list|(
name|conj
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pushableNodes
operator|.
name|add
argument_list|(
name|conj
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ImmutableTriple
operator|.
name|of
argument_list|(
name|timeRangeNodes
argument_list|,
name|pushableNodes
argument_list|,
name|nonPushableNodes
argument_list|)
return|;
block|}
block|}
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Project} into a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidProjectRule
extends|extends
name|RelOptRule
block|{
comment|/**      * Creates a DruidProjectRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidProjectRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|project
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'p'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|canProjectAll
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
condition|)
block|{
comment|// All expressions can be pushed to Druid in their entirety.
specifier|final
name|RelNode
name|newProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RelNode
name|newNode
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newProject
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|Pair
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|pair
init|=
name|splitProjects
argument_list|(
name|rexBuilder
argument_list|,
name|query
argument_list|,
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
comment|// We can't push anything useful to Druid.
return|return;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|above
init|=
name|pair
operator|.
name|left
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|below
init|=
name|pair
operator|.
name|right
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|below
control|)
block|{
specifier|final
name|String
name|name
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|name
operator|=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
literal|null
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|e
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|newProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|input
argument_list|,
name|below
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|newQuery
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newProject
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newProject2
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newQuery
argument_list|,
name|above
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProject2
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|canProjectAll
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|e
range|:
name|nodes
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|Pair
argument_list|<
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|splitProjects
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RelNode
name|input
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|RelOptUtil
operator|.
name|InputReferencedVisitor
name|visitor
init|=
operator|new
name|RelOptUtil
operator|.
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visitor
operator|.
name|inputPosReferenced
operator|.
name|size
argument_list|()
operator|==
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// All inputs are referenced
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|belowNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|belowTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|positions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|visitor
operator|.
name|inputPosReferenced
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|positions
control|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|input
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|belowNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|belowTypes
operator|.
name|add
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|aboveNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|aboveNodes
operator|.
name|add
argument_list|(
name|node
operator|.
name|accept
argument_list|(
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|positions
operator|.
name|indexOf
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|belowTypes
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|aboveNodes
argument_list|,
name|belowNodes
argument_list|)
return|;
block|}
block|}
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Project} into a {@link DruidQuery} as a    * Post aggregator.    */
specifier|public
specifier|static
class|class
name|DruidPostAggregationProjectRule
extends|extends
name|RelOptRule
block|{
comment|/**      * Creates a DruidPostAggregationProjectRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidPostAggregationProjectRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|project
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'o'
argument_list|)
condition|)
block|{
return|return;
block|}
name|Pair
argument_list|<
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|Boolean
argument_list|>
name|scanned
init|=
name|scanProject
argument_list|(
name|query
argument_list|,
name|project
argument_list|)
decl_stmt|;
comment|// Only try to push down Project when there will be Post aggregators in result DruidQuery
if|if
condition|(
name|scanned
operator|.
name|right
condition|)
block|{
name|Pair
argument_list|<
name|Project
argument_list|,
name|Project
argument_list|>
name|splitProjectAggregate
init|=
name|splitProject
argument_list|(
name|rexBuilder
argument_list|,
name|query
argument_list|,
name|project
argument_list|,
name|scanned
operator|.
name|left
argument_list|,
name|cluster
argument_list|)
decl_stmt|;
name|Project
name|inner
init|=
name|splitProjectAggregate
operator|.
name|left
decl_stmt|;
name|Project
name|outer
init|=
name|splitProjectAggregate
operator|.
name|right
decl_stmt|;
name|DruidQuery
name|newQuery
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|inner
argument_list|)
decl_stmt|;
comment|// When all project get pushed into DruidQuery, the project can be replaced by DruidQuery.
if|if
condition|(
name|outer
operator|!=
literal|null
condition|)
block|{
name|Project
name|newProject
init|=
name|outer
operator|.
name|copy
argument_list|(
name|outer
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newQuery
argument_list|,
name|outer
operator|.
name|getProjects
argument_list|()
argument_list|,
name|outer
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|call
operator|.
name|transformTo
argument_list|(
name|newQuery
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Similar to split Project in DruidProjectRule. It used the name mapping from scanProject      * to render the correct field names of inner project so that the outer project can correctly      * refer to them. For RexNode that can be parsed into post aggregator, they will get pushed in      * before input reference, then outer project can simply refer to those pushed in RexNode to      * get result.      * @param rexBuilder builder from cluster      * @param query matched Druid Query      * @param project matched project takes in druid      * @param nameMap Result nameMapping from scanProject      * @param cluster cluster that provide builder for row type.      * @return Triple object contains inner project, outer project and required      *         Json Post Aggregation objects to be pushed down into Druid Query.      */
specifier|public
name|Pair
argument_list|<
name|Project
argument_list|,
name|Project
argument_list|>
name|splitProject
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
name|DruidQuery
name|query
parameter_list|,
name|Project
name|project
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|nameMap
parameter_list|,
specifier|final
name|RelOptCluster
name|cluster
parameter_list|)
block|{
comment|//Visit& Build Inner Project
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|innerRex
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|typeBuilder
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|RelOptUtil
operator|.
name|InputReferencedVisitor
name|visitor
init|=
operator|new
name|RelOptUtil
operator|.
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|positions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|innerTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Similar logic to splitProject in DruidProject Rule
comment|// However, post aggregation will also be output of DruidQuery and they will be
comment|// added before other input.
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|pair
range|:
name|project
operator|.
name|getNamedProjects
argument_list|()
control|)
block|{
name|RexNode
name|rex
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|String
name|name
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|String
name|fieldName
init|=
name|nameMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
block|{
name|rex
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|RexNode
name|node
init|=
name|rexBuilder
operator|.
name|copy
argument_list|(
name|rex
argument_list|)
decl_stmt|;
name|innerRex
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|positions
operator|.
name|add
argument_list|(
name|offset
operator|++
argument_list|)
expr_stmt|;
name|typeBuilder
operator|.
name|add
argument_list|(
name|nameMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|innerTypes
operator|.
name|add
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Other referred input will be added into the inner project rex list.
name|positions
operator|.
name|addAll
argument_list|(
name|visitor
operator|.
name|inputPosReferenced
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|visitor
operator|.
name|inputPosReferenced
control|)
block|{
specifier|final
name|RexNode
name|node
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|innerRex
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|typeBuilder
operator|.
name|add
argument_list|(
name|query
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|node
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|innerTypes
operator|.
name|add
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Project
name|innerProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|,
name|innerRex
argument_list|,
name|typeBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// If the whole project is pushed, we do not need to do anything else.
if|if
condition|(
name|project
operator|.
name|getNamedProjects
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|nameMap
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|innerProject
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// Build outer Project when some projects are left in outer project.
name|offset
operator|=
literal|0
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|outerRex
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|pair
range|:
name|project
operator|.
name|getNamedProjects
argument_list|()
control|)
block|{
name|RexNode
name|rex
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|String
name|name
init|=
name|pair
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|!
name|nameMap
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|outerRex
operator|.
name|add
argument_list|(
name|rex
operator|.
name|accept
argument_list|(
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
specifier|final
name|int
name|j
init|=
name|positions
operator|.
name|indexOf
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|innerTypes
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
name|j
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outerRex
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rex
operator|.
name|getType
argument_list|()
argument_list|,
name|positions
operator|.
name|indexOf
argument_list|(
name|offset
operator|++
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Project
name|outerProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|innerProject
argument_list|,
name|outerRex
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|innerProject
argument_list|,
name|outerProject
argument_list|)
return|;
block|}
comment|/**      * Scans the project.      *      *<p>Takes Druid Query as input to figure out which expression can be      * pushed down. Also returns a map to show the correct field name in Druid      * Query for columns get pushed in.      *      * @param query matched Druid Query      * @param project Matched project that takes in Druid Query      * @return Pair that shows how name map with each other.      */
specifier|public
name|Pair
argument_list|<
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|Boolean
argument_list|>
name|scanProject
parameter_list|(
name|DruidQuery
name|query
parameter_list|,
name|Project
name|project
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|aggNamesWithGroup
init|=
name|query
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapBuilder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|boolean
name|ret
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|namedProject
range|:
name|project
operator|.
name|getNamedProjects
argument_list|()
control|)
block|{
name|RexNode
name|rex
init|=
name|namedProject
operator|.
name|left
decl_stmt|;
name|String
name|name
init|=
name|namedProject
operator|.
name|right
decl_stmt|;
comment|// Find out the corresponding fieldName for DruidQuery to fetch result
comment|// in DruidConnectionImpl, give specific name for post aggregator
if|if
condition|(
name|rex
operator|instanceof
name|RexCall
condition|)
block|{
if|if
condition|(
name|checkPostAggregatorExist
argument_list|(
name|rex
argument_list|)
condition|)
block|{
name|String
name|postAggName
init|=
literal|"postagg#"
operator|+
name|j
operator|++
decl_stmt|;
name|mapBuilder
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|postAggName
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|rex
operator|instanceof
name|RexInputRef
condition|)
block|{
name|String
name|fieldName
init|=
name|aggNamesWithGroup
operator|.
name|get
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|mapBuilder
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|mapBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|ret
argument_list|)
return|;
block|}
comment|/**      * Recursively check whether the rexNode can be parsed into post aggregator in druid query      * Have to fulfill conditions below:      * 1. Arithmetic operation +, -, /, * or CAST in SQL      * 2. Simple input reference refer to the result of Aggregate or Grouping      * 3. A constant      * 4. All input referred should also be able to be parsed      * @param rexNode input RexNode to be recursively checked      * @return a boolean shows whether this rexNode can be parsed or not.      */
specifier|public
name|boolean
name|checkPostAggregatorExist
parameter_list|(
name|RexNode
name|rexNode
parameter_list|)
block|{
if|if
condition|(
name|rexNode
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|ele
range|:
operator|(
operator|(
name|RexCall
operator|)
name|rexNode
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|boolean
name|inputRex
init|=
name|checkPostAggregatorExist
argument_list|(
name|ele
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inputRex
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
switch|switch
condition|(
name|rexNode
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|DIVIDE
case|:
case|case
name|TIMES
case|:
comment|//case CAST:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
if|else if
condition|(
name|rexNode
operator|instanceof
name|RexInputRef
operator|||
name|rexNode
operator|instanceof
name|RexLiteral
condition|)
block|{
comment|// Do not have to check the source of input because the signature checking ensure
comment|// the input of project must be Aggregate.
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Rule to push an {@link org.apache.calcite.rel.core.Aggregate} into a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidAggregateRule
extends|extends
name|RelOptRule
block|{
comment|/**      * Creates a DruidAggregateRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidAggregateRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'a'
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|aggregate
operator|.
name|indicator
operator|||
name|aggregate
operator|.
name|getGroupSets
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|BAD_AGG
operator|.
name|apply
argument_list|(
name|ImmutableTriple
operator|.
name|of
argument_list|(
name|aggregate
argument_list|,
operator|(
name|RelNode
operator|)
name|aggregate
argument_list|,
name|query
argument_list|)
argument_list|)
operator|||
operator|!
name|validAggregate
argument_list|(
name|aggregate
argument_list|,
name|query
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|RelNode
name|newAggregate
init|=
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newAggregate
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check whether agg functions reference timestamp */
specifier|private
specifier|static
name|boolean
name|validAggregate
parameter_list|(
name|Aggregate
name|aggregate
parameter_list|,
name|DruidQuery
name|query
parameter_list|)
block|{
name|ImmutableBitSet
operator|.
name|Builder
name|builder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
name|builder
operator|.
name|addAll
argument_list|(
name|aggCall
operator|.
name|getArgList
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|checkTimestampRefOnQuery
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|,
name|query
operator|.
name|getTopNode
argument_list|()
argument_list|,
name|query
argument_list|)
return|;
block|}
block|}
comment|/**    * Rule to push an {@link org.apache.calcite.rel.core.Aggregate} and    * {@link org.apache.calcite.rel.core.Project} into a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidAggregateProjectRule
extends|extends
name|RelOptRule
block|{
comment|/**      * Creates a DruidAggregateProjectRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidAggregateProjectRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'p'
operator|+
literal|'a'
argument_list|)
condition|)
block|{
return|return;
block|}
name|int
name|timestampIdx
init|=
name|validProject
argument_list|(
name|project
argument_list|,
name|query
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|filterRefs
init|=
name|getFilterRefs
argument_list|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|timestampIdx
operator|==
operator|-
literal|1
operator|&&
name|filterRefs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|// Check that the filters that the Aggregate calls refer to are valid filters can be pushed
comment|// into Druid
for|for
control|(
name|Integer
name|i
range|:
name|filterRefs
control|)
block|{
name|RexNode
name|filterNode
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|query
operator|.
name|isValidFilter
argument_list|(
name|filterNode
argument_list|)
operator|||
name|filterNode
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|aggregate
operator|.
name|indicator
operator|||
name|aggregate
operator|.
name|getGroupSets
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|BAD_AGG
operator|.
name|apply
argument_list|(
name|ImmutableTriple
operator|.
name|of
argument_list|(
name|aggregate
argument_list|,
operator|(
name|RelNode
operator|)
name|project
argument_list|,
name|query
argument_list|)
argument_list|)
operator|||
operator|!
name|validAggregate
argument_list|(
name|aggregate
argument_list|,
name|timestampIdx
argument_list|,
name|filterRefs
operator|.
name|size
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|RelNode
name|newProject
init|=
name|project
operator|.
name|copy
argument_list|(
name|project
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newAggregate
init|=
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newProject
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query2
decl_stmt|;
if|if
condition|(
name|filterRefs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|query2
operator|=
name|optimizeFilteredAggregations
argument_list|(
name|call
argument_list|,
name|query
argument_list|,
operator|(
name|Project
operator|)
name|newProject
argument_list|,
operator|(
name|Aggregate
operator|)
name|newAggregate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|DruidQuery
name|query1
init|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newProject
argument_list|)
decl_stmt|;
name|query2
operator|=
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query1
argument_list|,
name|newAggregate
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|query2
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns an array of unique filter references from      * the given list of {@link org.apache.calcite.rel.core.AggregateCall}      * */
specifier|private
name|Set
argument_list|<
name|Integer
argument_list|>
name|getUniqueFilterRefs
parameter_list|(
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|calls
parameter_list|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|refs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|call
range|:
name|calls
control|)
block|{
if|if
condition|(
name|call
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
name|refs
operator|.
name|add
argument_list|(
name|call
operator|.
name|filterArg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|refs
return|;
block|}
comment|/**      * Attempts to optimize any aggregations with filters in the DruidQuery.      * Uses the following steps:      *      *<ol>      *<li>Tries to abstract common filters out into the "filter" field;      *<li>Eliminates expressions that are always true or always false when      *     possible;      *<li>ANDs aggregate filters together with the outer filter to allow for      *     pruning of data.      *</ol>      *      *<p>Should be called before pushing both the aggregate and project into      * Druid. Assumes that at least one aggregate call has a filter attached to      * it. */
specifier|private
name|DruidQuery
name|optimizeFilteredAggregations
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|,
name|DruidQuery
name|query
parameter_list|,
name|Project
name|project
parameter_list|,
name|Aggregate
name|aggregate
parameter_list|)
block|{
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
specifier|final
name|RexBuilder
name|builder
init|=
name|query
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|Util
operator|.
name|first
argument_list|(
name|query
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|scan
init|=
name|query
operator|.
name|rels
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// first rel is the table scan
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|call
operator|.
name|getMetadataQuery
argument_list|()
operator|.
name|getPulledUpPredicates
argument_list|(
name|scan
argument_list|)
decl_stmt|;
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|builder
argument_list|,
name|predicates
argument_list|,
literal|true
argument_list|,
name|executor
argument_list|)
decl_stmt|;
comment|// if the druid query originally contained a filter
name|boolean
name|containsFilter
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RelNode
name|node
range|:
name|query
operator|.
name|rels
control|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|Filter
condition|)
block|{
name|filter
operator|=
operator|(
name|Filter
operator|)
name|node
expr_stmt|;
name|containsFilter
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// if every aggregate call has a filter arg reference
name|boolean
name|allHaveFilters
init|=
name|allAggregatesHaveFilters
argument_list|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|uniqueFilterRefs
init|=
name|getUniqueFilterRefs
argument_list|(
name|aggregate
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
comment|// One of the pre-conditions for this method
assert|assert
name|uniqueFilterRefs
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// OR all the filters so that they can ANDed to the outer filter
name|List
argument_list|<
name|RexNode
argument_list|>
name|disjunctions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|i
range|:
name|uniqueFilterRefs
control|)
block|{
name|disjunctions
operator|.
name|add
argument_list|(
name|stripFilter
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|filterNode
init|=
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|builder
argument_list|,
name|disjunctions
argument_list|)
decl_stmt|;
comment|// Erase references to filters
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
name|int
name|newFilterArg
init|=
name|aggCall
operator|.
name|filterArg
decl_stmt|;
if|if
condition|(
operator|!
name|aggCall
operator|.
name|hasFilter
argument_list|()
operator|||
operator|(
name|uniqueFilterRefs
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|allHaveFilters
operator|)
comment|// filters get extracted
operator|||
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|newFilterArg
argument_list|)
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|newFilterArg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|newCalls
operator|.
name|add
argument_list|(
name|aggCall
operator|.
name|copy
argument_list|(
name|aggCall
operator|.
name|getArgList
argument_list|()
argument_list|,
name|newFilterArg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|aggregate
operator|=
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|aggregate
operator|.
name|indicator
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getGroupSets
argument_list|()
argument_list|,
name|newCalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|containsFilter
condition|)
block|{
comment|// AND the current filterNode with the filter node inside filter
name|filterNode
operator|=
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|filterNode
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Simplify the filter as much as possible
name|RexNode
name|tempFilterNode
init|=
name|filterNode
decl_stmt|;
name|filterNode
operator|=
name|simplify
operator|.
name|simplify
argument_list|(
name|filterNode
argument_list|)
expr_stmt|;
comment|// It's possible that after simplification that the expression is now always false.
comment|// Druid cannot handle such a filter.
comment|// This will happen when the below expression (f_n+1 may not exist):
comment|// f_n+1 AND (f_1 OR f_2 OR ... OR f_n) simplifies to be something always false.
comment|// f_n+1 cannot be false, since it came from a pushed filter rel node
comment|// and each f_i cannot be false, since DruidAggregateProjectRule would have caught that.
comment|// So, the only solution is to revert back to the un simplified version and let Druid
comment|// handle a filter that is ultimately unsatisfiable.
if|if
condition|(
name|filterNode
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
name|filterNode
operator|=
name|tempFilterNode
expr_stmt|;
block|}
name|filter
operator|=
name|LogicalFilter
operator|.
name|create
argument_list|(
name|scan
argument_list|,
name|filterNode
argument_list|)
expr_stmt|;
name|boolean
name|addNewFilter
init|=
operator|!
name|filter
operator|.
name|getCondition
argument_list|()
operator|.
name|isAlwaysTrue
argument_list|()
operator|&&
name|allHaveFilters
decl_stmt|;
comment|// Assumes that Filter nodes are always right after
comment|// TableScan nodes (which are always present)
name|int
name|startIndex
init|=
name|containsFilter
operator|&&
name|addNewFilter
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newNodes
init|=
name|constructNewNodes
argument_list|(
name|query
operator|.
name|rels
argument_list|,
name|addNewFilter
argument_list|,
name|startIndex
argument_list|,
name|filter
argument_list|,
name|project
argument_list|,
name|aggregate
argument_list|)
decl_stmt|;
return|return
name|DruidQuery
operator|.
name|create
argument_list|(
name|query
operator|.
name|getCluster
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|query
operator|.
name|getConvention
argument_list|()
argument_list|)
argument_list|,
name|query
operator|.
name|getTable
argument_list|()
argument_list|,
name|query
operator|.
name|druidTable
argument_list|,
name|newNodes
argument_list|)
return|;
block|}
comment|// Returns true if and only if every AggregateCall in calls has a filter argument.
specifier|private
specifier|static
name|boolean
name|allAggregatesHaveFilters
parameter_list|(
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|calls
parameter_list|)
block|{
for|for
control|(
name|AggregateCall
name|call
range|:
name|calls
control|)
block|{
if|if
condition|(
operator|!
name|call
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns a new List of RelNodes in the order of the given order of the oldNodes,      * the given {@link Filter}, and any extra nodes.      */
specifier|private
specifier|static
name|List
argument_list|<
name|RelNode
argument_list|>
name|constructNewNodes
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|oldNodes
parameter_list|,
name|boolean
name|addFilter
parameter_list|,
name|int
name|startIndex
parameter_list|,
name|RelNode
name|filter
parameter_list|,
name|RelNode
modifier|...
name|trailingNodes
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|newNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// The first item should always be the Table scan, so any filter would go after that
name|newNodes
operator|.
name|add
argument_list|(
name|oldNodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addFilter
condition|)
block|{
name|newNodes
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
comment|// This is required so that each RelNode is linked to the one before it
if|if
condition|(
name|startIndex
operator|<
name|oldNodes
operator|.
name|size
argument_list|()
condition|)
block|{
name|RelNode
name|next
init|=
name|oldNodes
operator|.
name|get
argument_list|(
name|startIndex
argument_list|)
decl_stmt|;
name|newNodes
operator|.
name|add
argument_list|(
name|next
operator|.
name|copy
argument_list|(
name|next
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|filter
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|startIndex
operator|++
expr_stmt|;
block|}
block|}
comment|// Add the rest of the nodes from oldNodes
for|for
control|(
name|int
name|i
init|=
name|startIndex
init|;
name|i
operator|<
name|oldNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|newNodes
operator|.
name|add
argument_list|(
name|oldNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add the trailing nodes (need to link them)
for|for
control|(
name|RelNode
name|node
range|:
name|trailingNodes
control|)
block|{
name|newNodes
operator|.
name|add
argument_list|(
name|node
operator|.
name|copy
argument_list|(
name|node
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|newNodes
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newNodes
return|;
block|}
comment|// Removes the IS_TRUE in front of RexCalls, if they exist
specifier|private
specifier|static
name|RexNode
name|stripFilter
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_TRUE
condition|)
block|{
return|return
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|getFilterRefs
parameter_list|(
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|calls
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|refs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|call
range|:
name|calls
control|)
block|{
if|if
condition|(
name|call
operator|.
name|hasFilter
argument_list|()
condition|)
block|{
name|refs
operator|.
name|add
argument_list|(
name|call
operator|.
name|filterArg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|refs
return|;
block|}
comment|/* To be a valid Project, we allow it to contain references, and a single call      * to a FLOOR function on the timestamp column OR valid time EXTRACT on the timestamp column.      * Returns the reference to the timestamp, if any. */
specifier|private
specifier|static
name|int
name|validProject
parameter_list|(
name|Project
name|project
parameter_list|,
name|DruidQuery
name|query
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|project
operator|.
name|getProjects
argument_list|()
decl_stmt|;
name|int
name|idxTimestamp
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|hasFloor
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|e
init|=
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RexCall
condition|)
block|{
comment|// It is a call, check that it is EXTRACT and follow-up conditions
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|DruidDateTimeUtils
operator|.
name|extractGranularity
argument_list|(
name|call
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|idxTimestamp
operator|!=
operator|-
literal|1
operator|&&
name|hasFloor
condition|)
block|{
comment|// Already one usage of timestamp column
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FLOOR
case|:
name|hasFloor
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|checkTimestampRefOnQuery
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|query
operator|.
name|getTopNode
argument_list|()
argument_list|,
name|query
argument_list|)
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|idxTimestamp
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|EXTRACT
case|:
name|idxTimestamp
operator|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|call
argument_list|)
operator|.
name|asList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
comment|// It needs to be a reference
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|checkTimestampRefOnQuery
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|query
operator|.
name|getTopNode
argument_list|()
argument_list|,
name|query
argument_list|)
condition|)
block|{
if|if
condition|(
name|idxTimestamp
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Already one usage of timestamp column
return|return
operator|-
literal|1
return|;
block|}
name|idxTimestamp
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|idxTimestamp
return|;
block|}
specifier|private
specifier|static
name|boolean
name|validAggregate
parameter_list|(
name|Aggregate
name|aggregate
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|numFilterRefs
parameter_list|)
block|{
if|if
condition|(
name|numFilterRefs
operator|>
literal|0
operator|&&
name|idx
operator|<
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
if|if
condition|(
name|aggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|contains
argument_list|(
name|idx
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Rule to push an {@link org.apache.calcite.rel.core.Sort} through a    * {@link org.apache.calcite.rel.core.Project}. Useful to transform    * to complex Druid queries.    */
specifier|public
specifier|static
class|class
name|DruidSortProjectTransposeRule
extends|extends
name|SortProjectTransposeRule
block|{
comment|/**      * Creates a DruidSortProjectTransposeRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidSortProjectTransposeRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rule to push back {@link org.apache.calcite.rel.core.Project} through a    * {@link org.apache.calcite.rel.core.Sort}. Useful if after pushing Sort,    * we could not push it inside DruidQuery.    */
specifier|public
specifier|static
class|class
name|DruidProjectSortTransposeRule
extends|extends
name|ProjectSortTransposeRule
block|{
comment|/**      * Creates a DruidProjectSortTransposeRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidProjectSortTransposeRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Sort}    * into a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidSortRule
extends|extends
name|RelOptRule
block|{
comment|/**      * Creates a DruidSortRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidSortRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Sort
name|sort
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DruidQuery
name|query
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DruidQuery
operator|.
name|isValidSignature
argument_list|(
name|query
operator|.
name|signature
argument_list|()
operator|+
literal|'l'
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Either it is:
comment|// - a sort and limit on a dimension/metric part of the druid group by query or
comment|// - a sort without limit on the time column on top of
comment|//     Agg operator (transformable to timeseries query), or
comment|// - a simple limit on top of other operator than Agg
if|if
condition|(
operator|!
name|validSortLimit
argument_list|(
name|sort
argument_list|,
name|query
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|RelNode
name|newSort
init|=
name|sort
operator|.
name|copy
argument_list|(
name|sort
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|query
operator|.
name|rels
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|DruidQuery
operator|.
name|extendQuery
argument_list|(
name|query
argument_list|,
name|newSort
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Checks whether sort is valid. */
specifier|private
specifier|static
name|boolean
name|validSortLimit
parameter_list|(
name|Sort
name|sort
parameter_list|,
name|DruidQuery
name|query
parameter_list|)
block|{
if|if
condition|(
name|sort
operator|.
name|offset
operator|!=
literal|null
operator|&&
name|RexLiteral
operator|.
name|intValue
argument_list|(
name|sort
operator|.
name|offset
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// offset not supported by Druid
return|return
literal|false
return|;
block|}
comment|// Use a different logic to push down Sort RelNode because the top node could be a Project now
name|RelNode
name|topNode
init|=
name|query
operator|.
name|getTopNode
argument_list|()
decl_stmt|;
name|Aggregate
name|topAgg
decl_stmt|;
if|if
condition|(
name|topNode
operator|instanceof
name|Project
operator|&&
operator|(
operator|(
name|Project
operator|)
name|topNode
operator|)
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Aggregate
condition|)
block|{
name|topAgg
operator|=
operator|(
name|Aggregate
operator|)
operator|(
operator|(
name|Project
operator|)
name|topNode
operator|)
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|topNode
operator|instanceof
name|Aggregate
condition|)
block|{
name|topAgg
operator|=
operator|(
name|Aggregate
operator|)
name|topNode
expr_stmt|;
block|}
else|else
block|{
comment|// If it is going to be a Druid select operator, we push the limit if
comment|// it does not contain a sort specification (required by Druid)
return|return
name|RelOptUtil
operator|.
name|isPureLimit
argument_list|(
name|sort
argument_list|)
return|;
block|}
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|positionsReferenced
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|col
range|:
name|sort
operator|.
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|int
name|idx
init|=
name|col
operator|.
name|getFieldIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|topAgg
operator|.
name|getGroupCount
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|//has the indexes of the columns used for sorts
name|positionsReferenced
operator|.
name|set
argument_list|(
name|topAgg
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Case it is a timeseries query
if|if
condition|(
name|checkIsFlooringTimestampRefOnQuery
argument_list|(
name|topAgg
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|topAgg
operator|.
name|getInput
argument_list|()
argument_list|,
name|query
argument_list|)
operator|&&
name|topAgg
operator|.
name|getGroupCount
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// do not push if it has a limit or more than one sort key or we have sort by
comment|// metric/dimension
return|return
operator|!
name|RelOptUtil
operator|.
name|isLimit
argument_list|(
name|sort
argument_list|)
operator|&&
name|sort
operator|.
name|collation
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|checkTimestampRefOnQuery
argument_list|(
name|positionsReferenced
operator|.
name|build
argument_list|()
argument_list|,
name|topAgg
operator|.
name|getInput
argument_list|()
argument_list|,
name|query
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/** Returns true if any of the grouping key is a floor operator over the timestamp column. */
specifier|private
specifier|static
name|boolean
name|checkIsFlooringTimestampRefOnQuery
parameter_list|(
name|ImmutableBitSet
name|set
parameter_list|,
name|RelNode
name|top
parameter_list|,
name|DruidQuery
name|query
parameter_list|)
block|{
if|if
condition|(
name|top
operator|instanceof
name|Project
condition|)
block|{
name|ImmutableBitSet
operator|.
name|Builder
name|newSet
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|top
decl_stmt|;
for|for
control|(
name|int
name|index
range|:
name|set
control|)
block|{
name|RexNode
name|node
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
assert|assert
name|DruidDateTimeUtils
operator|.
name|extractGranularity
argument_list|(
name|call
argument_list|)
operator|!=
literal|null
assert|;
if|if
condition|(
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FLOOR
condition|)
block|{
name|newSet
operator|.
name|addAll
argument_list|(
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|call
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|top
operator|=
name|project
operator|.
name|getInput
argument_list|()
expr_stmt|;
name|set
operator|=
name|newSet
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// Check if any references the timestamp column
for|for
control|(
name|int
name|index
range|:
name|set
control|)
block|{
if|if
condition|(
name|query
operator|.
name|druidTable
operator|.
name|timestampFieldName
operator|.
name|equals
argument_list|(
name|top
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Checks whether any of the references leads to the timestamp column. */
specifier|private
specifier|static
name|boolean
name|checkTimestampRefOnQuery
parameter_list|(
name|ImmutableBitSet
name|set
parameter_list|,
name|RelNode
name|top
parameter_list|,
name|DruidQuery
name|query
parameter_list|)
block|{
if|if
condition|(
name|top
operator|instanceof
name|Project
condition|)
block|{
name|ImmutableBitSet
operator|.
name|Builder
name|newSet
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|top
decl_stmt|;
for|for
control|(
name|int
name|index
range|:
name|set
control|)
block|{
name|RexNode
name|node
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|RexInputRef
condition|)
block|{
name|newSet
operator|.
name|set
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
assert|assert
name|DruidDateTimeUtils
operator|.
name|extractGranularity
argument_list|(
name|call
argument_list|)
operator|!=
literal|null
assert|;
comment|// when we have extract from time columnthe rexCall is in the form of /Reinterpret$0
name|newSet
operator|.
name|addAll
argument_list|(
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|call
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|top
operator|=
name|project
operator|.
name|getInput
argument_list|()
expr_stmt|;
name|set
operator|=
name|newSet
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// Check if any references the timestamp column
for|for
control|(
name|int
name|index
range|:
name|set
control|)
block|{
if|if
condition|(
name|query
operator|.
name|druidTable
operator|.
name|timestampFieldName
operator|.
name|equals
argument_list|(
name|top
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Checks whether any of the references leads to a metric column. */
specifier|private
specifier|static
name|boolean
name|checkAggregateOnMetric
parameter_list|(
name|ImmutableBitSet
name|set
parameter_list|,
name|RelNode
name|topProject
parameter_list|,
name|DruidQuery
name|query
parameter_list|)
block|{
if|if
condition|(
name|topProject
operator|instanceof
name|Project
condition|)
block|{
name|ImmutableBitSet
operator|.
name|Builder
name|newSet
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|topProject
decl_stmt|;
for|for
control|(
name|int
name|index
range|:
name|set
control|)
block|{
name|RexNode
name|node
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|setOfBits
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|newSet
operator|.
name|addAll
argument_list|(
name|setOfBits
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|newSet
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|index
range|:
name|set
control|)
block|{
if|if
condition|(
name|query
operator|.
name|druidTable
operator|.
name|isMetric
argument_list|(
name|query
operator|.
name|getTopNode
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Project}    * past a {@link org.apache.calcite.rel.core.Filter}    * when {@code Filter} is on top of a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidProjectFilterTransposeRule
extends|extends
name|ProjectFilterTransposeRule
block|{
comment|/**      * Creates a DruidProjectFilterTransposeRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidProjectFilterTransposeRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|PushProjector
operator|.
name|ExprCondition
operator|.
name|FALSE
argument_list|,
name|relBuilderFactory
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rule to push a {@link org.apache.calcite.rel.core.Filter}    * past a {@link org.apache.calcite.rel.core.Project}    * when {@code Project} is on top of a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidFilterProjectTransposeRule
extends|extends
name|FilterProjectTransposeRule
block|{
comment|/**      * Creates a DruidFilterProjectTransposeRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidFilterProjectTransposeRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|relBuilderFactory
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rule to push an {@link org.apache.calcite.rel.core.Aggregate}    * past a {@link org.apache.calcite.rel.core.Filter}    * when {@code Filter} is on top of a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidAggregateFilterTransposeRule
extends|extends
name|AggregateFilterTransposeRule
block|{
comment|/**      * Creates a DruidAggregateFilterTransposeRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidAggregateFilterTransposeRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rule to push an {@link org.apache.calcite.rel.core.Filter}    * past an {@link org.apache.calcite.rel.core.Aggregate}    * when {@code Aggregate} is on top of a {@link DruidQuery}.    */
specifier|public
specifier|static
class|class
name|DruidFilterAggregateTransposeRule
extends|extends
name|FilterAggregateTransposeRule
block|{
comment|/**      * Creates a DruidFilterAggregateTransposeRule.      *      * @param relBuilderFactory Builder for relational expressions      */
specifier|public
name|DruidFilterAggregateTransposeRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|DruidQuery
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End DruidRules.java
end_comment

end_unit

