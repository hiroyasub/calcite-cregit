begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Static utilities for JUnit tests.  *  * @author John V. Sichi  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|TestUtil
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|Pattern
name|LineBreakPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\r\n|\r|\n"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|TabPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\t"
argument_list|)
decl_stmt|;
comment|/**      * System-dependent newline character.      *      *<p/>Do not use '\n' in strings which are samples for test results. {@link      * java.io.PrintWriter#println()} produces '\n' on Unix and '\r\n' on      * Windows, but '\n' is always '\n', so your tests will fail on Windows.      */
specifier|public
specifier|static
specifier|final
name|String
name|NL
init|=
name|Util
operator|.
name|lineSeparator
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|lineBreak
init|=
literal|"\" + NL +"
operator|+
name|NL
operator|+
literal|"\""
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|lineBreak2
init|=
literal|"\\\\n\""
operator|+
name|NL
operator|+
literal|" + \""
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|lineBreak3
init|=
literal|"\\n\""
operator|+
name|NL
operator|+
literal|" + \""
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
specifier|public
specifier|static
name|void
name|assertEqualsVerbose
parameter_list|(
name|String
name|expected
parameter_list|,
name|String
name|actual
parameter_list|)
block|{
if|if
condition|(
name|actual
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|expected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
else|else
block|{
name|String
name|message
init|=
literal|"Expected:"
operator|+
name|NL
operator|+
name|expected
operator|+
name|NL
operator|+
literal|"Actual: null"
decl_stmt|;
throw|throw
operator|new
name|ComparisonFailure
argument_list|(
name|message
argument_list|,
name|expected
argument_list|,
name|actual
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|(
name|expected
operator|!=
literal|null
operator|)
operator|&&
name|expected
operator|.
name|equals
argument_list|(
name|actual
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|s
init|=
name|toJavaString
argument_list|(
name|actual
argument_list|)
decl_stmt|;
name|String
name|message
init|=
literal|"Expected:"
operator|+
name|NL
operator|+
name|expected
operator|+
name|NL
operator|+
literal|"Actual: "
operator|+
name|NL
operator|+
name|actual
operator|+
name|NL
operator|+
literal|"Actual java: "
operator|+
name|NL
operator|+
name|s
operator|+
name|NL
decl_stmt|;
throw|throw
operator|new
name|ComparisonFailure
argument_list|(
name|message
argument_list|,
name|expected
argument_list|,
name|actual
argument_list|)
throw|;
block|}
comment|/**      * Converts a string (which may contain quotes and newlines) into a java      * literal.      *      *<p>For example,<code>      *<pre>string with "quotes" split      * across lines</pre>      *</code> becomes<code>      *<pre>"string with \"quotes\" split" + NL +      *  "across lines"</pre>      *</code>      */
specifier|public
specifier|static
name|String
name|quoteForJava
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|s
operator|=
name|Util
operator|.
name|replace
argument_list|(
name|s
argument_list|,
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
name|s
operator|=
name|Util
operator|.
name|replace
argument_list|(
name|s
argument_list|,
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
name|s
operator|=
name|LineBreakPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|replaceAll
argument_list|(
name|lineBreak
argument_list|)
expr_stmt|;
name|s
operator|=
name|TabPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\\\t"
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"\""
operator|+
name|s
operator|+
literal|"\""
expr_stmt|;
specifier|final
name|String
name|spurious
init|=
literal|" + "
operator|+
name|NL
operator|+
literal|"\"\""
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|endsWith
argument_list|(
name|spurious
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
name|spurious
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Converts a string (which may contain quotes and newlines) into a java      * literal.      *      *<p>For example,<code>      *<pre>string with "quotes" split      * across lines</pre>      *</code> becomes<code>      *<pre>TestUtil.fold(      *  "string with \"quotes\" split\n",      *  + "across lines")</pre>      *</code>      */
specifier|public
specifier|static
name|String
name|toJavaString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
comment|// Convert [string with "quotes" split
comment|// across lines]
comment|// into [fold(
comment|// "string with \"quotes\" split\n"
comment|// + "across lines")]
comment|//
name|s
operator|=
name|Util
operator|.
name|replace
argument_list|(
name|s
argument_list|,
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
name|s
operator|=
name|LineBreakPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|replaceAll
argument_list|(
name|lineBreak2
argument_list|)
expr_stmt|;
name|s
operator|=
name|TabPattern
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\\\t"
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"\""
operator|+
name|s
operator|+
literal|"\""
expr_stmt|;
name|String
name|spurious
init|=
name|NL
operator|+
literal|" \\+ \"\""
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|endsWith
argument_list|(
name|spurious
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
name|spurious
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|indexOf
argument_list|(
name|lineBreak3
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|s
operator|=
literal|"TestUtil.fold("
operator|+
name|NL
operator|+
name|s
operator|+
literal|")"
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Combines an array of strings, each representing a line, into a single      * string containing line separators.      */
specifier|public
specifier|static
name|String
name|fold
parameter_list|(
name|String
index|[]
name|strings
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|NL
argument_list|)
expr_stmt|;
block|}
name|String
name|string
init|=
name|strings
index|[
name|i
index|]
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Converts a string containing newlines (\n) into a string containing      * os-dependent line endings.      */
specifier|public
specifier|static
name|String
name|fold
parameter_list|(
name|String
name|string
parameter_list|)
block|{
if|if
condition|(
operator|!
literal|"\n"
operator|.
name|equals
argument_list|(
name|NL
argument_list|)
condition|)
block|{
name|string
operator|=
name|string
operator|.
name|replaceAll
argument_list|(
literal|"\n"
argument_list|,
name|NL
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
comment|/**      * Quotes a pattern.      */
specifier|public
specifier|static
name|String
name|quotePattern
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|replaceAll
argument_list|(
literal|"\\\\"
argument_list|,
literal|"\\\\"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\."
argument_list|,
literal|"\\\\."
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\+"
argument_list|,
literal|"\\\\+"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\{"
argument_list|,
literal|"\\\\{"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\}"
argument_list|,
literal|"\\\\}"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\|"
argument_list|,
literal|"\\\\||"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"[$]"
argument_list|,
literal|"\\\\\\$"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\?"
argument_list|,
literal|"\\\\?"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\*"
argument_list|,
literal|"\\\\*"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\("
argument_list|,
literal|"\\\\("
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\)"
argument_list|,
literal|"\\\\)"
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\["
argument_list|,
literal|"\\\\["
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\]"
argument_list|,
literal|"\\\\]"
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|// End TestUtil.java
end_comment

end_unit

