begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|test
operator|.
name|concurrent
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|SqlTimeoutException
import|;
end_import

begin_comment
comment|/**  * ConcurrentTestCommandGenerator creates instances of {@link  * ConcurrentTestCommand} that perform specific actions in a specific  * order and within the context of a test thread ({@link  * ConcurrentTestCommandExecutor}).  *  *<p>Typical actions include preparing a SQL statement for execution, executing  * the statement and verifying its result set, and closing the statement.  *  *<p>A single ConcurrentTestCommandGenerator creates commands for  * multiple threads. Each thread is represented by an integer "thread ID".  * Thread IDs may take on any positive integer value and may be a sparse set  * (e.g. 1, 2, 5).  *  *<p>When each command is created, it is associated with a thread and given an  * execution order. Execution order values are positive integers, must be unique  * within a thread, and may be a sparse set.  *  *<p>There are no restrictions on the order of command creation.  */
end_comment

begin_class
specifier|public
class|class
name|ConcurrentTestCommandGenerator
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|char
name|APOS
init|=
literal|'\''
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|COMMA
init|=
literal|','
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|LEFT_BRACKET
init|=
literal|'{'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|RIGHT_BRACKET
init|=
literal|'}'
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
name|boolean
name|debug
init|=
literal|false
decl_stmt|;
specifier|protected
name|PrintStream
name|debugStream
init|=
name|System
operator|.
name|out
decl_stmt|;
specifier|protected
name|String
name|jdbcURL
decl_stmt|;
specifier|protected
name|Properties
name|jdbcProps
decl_stmt|;
comment|/**      * Maps Integer thread IDs to a TreeMap. The TreeMap vaules map an Integer      * execution order to a {@link ConcurrentTestCommand}.      */
specifier|private
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
name|threadMap
decl_stmt|;
comment|/**      * Maps Integer thread IDs to thread names.      */
specifier|private
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|threadNameMap
decl_stmt|;
comment|/** Describes a thread that failed */
specifier|public
specifier|static
class|class
name|FailedThread
block|{
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
specifier|public
specifier|final
name|String
name|location
decl_stmt|;
specifier|public
specifier|final
name|Throwable
name|failure
decl_stmt|;
specifier|public
name|FailedThread
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|location
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|location
operator|=
name|location
expr_stmt|;
name|this
operator|.
name|failure
operator|=
name|failure
expr_stmt|;
block|}
block|}
comment|/** Collects threads that failed. Cleared when execution starts, valid whe/n      * execution has ended. Only failed threads appear in the list, so after a      * successful test the list is empty.      */
specifier|private
name|List
argument_list|<
name|FailedThread
argument_list|>
name|failedThreads
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**      * Constructs a new ConcurrentTestCommandGenerator.      */
specifier|public
name|ConcurrentTestCommandGenerator
parameter_list|()
block|{
name|threadMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|threadNameMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|failedThreads
operator|=
operator|new
name|ArrayList
argument_list|<
name|FailedThread
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * Adds a synchronization commands. When a thread reaches a synchronization      * command it stops and waits for all other threads to reach their      * synchronization commands. When all threads have reached their      * synchronization commands, they are all released simultaneously (or as      * close as one can get with {@link Object#notifyAll()}). Each thread must      * have exactly the same number of synchronization commands.      *      * @param threadId the thread that should execute this command      * @param order the execution order      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addSynchronizationCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|)
block|{
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
operator|new
name|SynchronizationCommand
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Causes the given thread to sleep for the indicated number of      * milliseconds.  Thread executes {@link java.lang.Thread#sleep(long)}.      *      * @param threadId the thread that should execute this command      * @param order the execution order      * @param millis the length of time to sleep in milliseconds (must not be      * negative)      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addSleepCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|,
name|long
name|millis
parameter_list|)
block|{
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
operator|new
name|SleepCommand
argument_list|(
name|millis
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Adds an "explain plan" command.      *      * @param threadId the thread that should execute this command      * @param order the execution order      * @param sql the explain plan SQL (e.g.<code>"explain plan for select *      * from t"</code>)      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addExplainCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
assert|assert
operator|(
name|sql
operator|!=
literal|null
operator|)
assert|;
name|ConcurrentTestCommand
name|command
init|=
operator|new
name|ExplainCommand
argument_list|(
name|sql
argument_list|)
decl_stmt|;
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
name|command
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link PreparedStatement} for the given SQL. This command does      * not execute the SQL, it merely creates a PreparedStatement and stores it      * in the ConcurrentTestCommandExecutor.      *      * @param threadId the thread that should execute this command      * @param order the execution order      * @param sql the SQL to prepare (e.g.<code>"select * from t"</code>)      *      * @return the newly-added command      *      * @see #addFetchAndCompareCommand(int, int, int, String)      */
specifier|public
name|ConcurrentTestCommand
name|addPrepareCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
assert|assert
operator|(
name|sql
operator|!=
literal|null
operator|)
assert|;
name|ConcurrentTestCommand
name|command
init|=
operator|new
name|PrepareCommand
argument_list|(
name|sql
argument_list|)
decl_stmt|;
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
name|command
argument_list|)
return|;
block|}
comment|/**      * Executes a previously {@link #addPrepareCommand(int, int, String)      * prepared} SQL statement and compares its {@link ResultSet} to the given      * data.      *      *<p><b>Expected data format:</b><code>{ 'row1, col1 value', 'row1, col2      * value', ... }, { 'row2, col1 value', 'row2, col2 value', ... },      * ...</code>      *      *<ul>      *<li>For string data: enclose value in apostrophes, use doubled apostrophe      * to include an spostrophe in the value.</li>      *<li>For integer or real data: simply use the stringified value (e.g. 123,      * 12.3, 0.65). No scientific notation is allowed.</li>      *<li>For null values, use the word<code>null</code> without quotes.</li>      *</ul>      *<b>Example:</b><code>{ 'foo', 10, 3.14, null }</code>      *      *<p><b>Note on timeout:</b> If the previously prepared statement's {@link      * Statement#setQueryTimeout(int)} method throws an<code>      * UnsupportedOperationException</code> it is ignored and no timeout is set.      *      * @param threadId the thread that should execute this command      * @param order the execution order      * @param timeout the query timeout, in seconds (see above)      * @param expected the expected results (see above)      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addFetchAndCompareCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|,
name|int
name|timeout
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|ConcurrentTestCommand
name|command
init|=
operator|new
name|FetchAndCompareCommand
argument_list|(
name|timeout
argument_list|,
name|expected
argument_list|)
decl_stmt|;
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
name|command
argument_list|)
return|;
block|}
comment|/**      * Closes a previously {@link #addPrepareCommand(int, int, String) prepared}      * SQL statement.      *      * @param threadId the thread that should execute this command      * @param order the execution order      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addCloseCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|)
block|{
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
operator|new
name|CloseCommand
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Executes the given SQL via {@link Statement#executeUpdate(String)}. May      * be used for update as well as insert statements.      *      *<p><b>Note on timeout:</b> If the previously prepared statement's {@link      * Statement#setQueryTimeout(int)} method throws an<code>      * UnsupportedOperationException</code> it is ignored and no timeout is set.      *      * @param threadId the thread that should execute this command      * @param order the execution order      * @param timeout the query timeout, in seconds (see above)      * @param sql the insert/update/delete SQL      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addInsertCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|,
name|int
name|timeout
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|ConcurrentTestCommand
name|command
init|=
operator|new
name|InsertCommand
argument_list|(
name|timeout
argument_list|,
name|sql
argument_list|)
decl_stmt|;
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
name|command
argument_list|)
return|;
block|}
comment|/**      * Commits pending transaction on the thread's connection.      *      * @param threadId the thread that should execute this command      * @param order the execution order      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addCommitCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|)
block|{
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
operator|new
name|CommitCommand
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Rolls back pending transaction on the thread's connection.      *      * @param threadId the thread that should execute this command      * @param order the execution order      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addRollbackCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|)
block|{
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
operator|new
name|RollbackCommand
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Executes a DDL statement immediately. Assumes the statement returns no      * information.      *      * @return the newly-added command      */
specifier|public
name|ConcurrentTestCommand
name|addDdlCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|,
name|String
name|ddl
parameter_list|)
block|{
return|return
name|addCommand
argument_list|(
name|threadId
argument_list|,
name|order
argument_list|,
operator|new
name|DdlCommand
argument_list|(
name|ddl
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Handles adding a command to {@link #threadMap}.      *      * @return the newly-added command      */
specifier|protected
name|ConcurrentTestCommand
name|addCommand
parameter_list|(
name|int
name|threadId
parameter_list|,
name|int
name|order
parameter_list|,
name|ConcurrentTestCommand
name|command
parameter_list|)
block|{
assert|assert
operator|(
name|threadId
operator|>
literal|0
operator|)
assert|;
assert|assert
operator|(
name|order
operator|>
literal|0
operator|)
assert|;
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
name|commandMap
init|=
name|threadMap
operator|.
name|get
argument_list|(
name|threadId
argument_list|)
decl_stmt|;
if|if
condition|(
name|commandMap
operator|==
literal|null
condition|)
block|{
name|commandMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|()
expr_stmt|;
name|threadMap
operator|.
name|put
argument_list|(
name|threadId
argument_list|,
name|commandMap
argument_list|)
expr_stmt|;
block|}
comment|// check for duplicate order numbers
assert|assert
operator|(
operator|!
name|commandMap
operator|.
name|containsKey
argument_list|(
name|order
argument_list|)
operator|)
assert|;
name|commandMap
operator|.
name|put
argument_list|(
name|order
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return
name|command
return|;
block|}
comment|/**      * Configures a human-readable name for a given thread identifier. Does not      * imply that the thread will be created -- that only happens if there are      * commands added to the thread.      */
specifier|public
name|void
name|setThreadName
parameter_list|(
name|int
name|threadId
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|threadNameMap
operator|.
name|put
argument_list|(
operator|new
name|Integer
argument_list|(
name|threadId
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|setDebug
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|debug
operator|=
name|enabled
expr_stmt|;
block|}
specifier|protected
name|void
name|setDebug
parameter_list|(
name|boolean
name|enabled
parameter_list|,
name|PrintStream
name|alternatePrintStream
parameter_list|)
block|{
name|debug
operator|=
name|enabled
expr_stmt|;
name|debugStream
operator|=
name|alternatePrintStream
expr_stmt|;
block|}
comment|/**      * Sets the jdbc data source for executing the command threads.      */
specifier|public
name|void
name|setDataSource
parameter_list|(
name|String
name|jdbcURL
parameter_list|,
name|Properties
name|jdbcProps
parameter_list|)
block|{
name|this
operator|.
name|jdbcURL
operator|=
name|jdbcURL
expr_stmt|;
name|this
operator|.
name|jdbcProps
operator|=
name|jdbcProps
expr_stmt|;
block|}
comment|/**      * Creates a {@link ConcurrentTestCommandExecutor} object for each define thread,      * and then runs them all.      *      * @throws Exception if no connection found or if a thread operation is      * interrupted      */
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|Exception
block|{
name|ConcurrentTestCommandExecutor
index|[]
name|threads
init|=
name|innerExecute
argument_list|()
decl_stmt|;
name|postExecute
argument_list|(
name|threads
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|ConcurrentTestCommandExecutor
index|[]
name|innerExecute
parameter_list|()
throws|throws
name|Exception
block|{
name|failedThreads
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Set
name|threadIds
init|=
name|getThreadIds
argument_list|()
decl_stmt|;
name|ConcurrentTestCommandExecutor
operator|.
name|Sync
name|sync
init|=
operator|new
name|ConcurrentTestCommandExecutor
operator|.
name|Sync
argument_list|(
name|threadIds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// initialize command executors
name|ConcurrentTestCommandExecutor
index|[]
name|threads
init|=
operator|new
name|ConcurrentTestCommandExecutor
index|[
name|threadIds
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|threadIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|threadIds
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Integer
name|threadId
init|=
operator|(
name|Integer
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Iterator
name|commands
init|=
name|getCommandIterator
argument_list|(
name|threadId
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|debugStream
operator|.
name|println
argument_list|(
literal|"Thread ID: "
operator|+
name|threadId
operator|+
literal|" ("
operator|+
name|getThreadName
argument_list|(
name|threadId
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|printCommands
argument_list|(
name|debugStream
argument_list|,
name|threadId
argument_list|)
expr_stmt|;
block|}
name|threads
index|[
name|threadIndex
operator|++
index|]
operator|=
operator|new
name|ConcurrentTestCommandExecutor
argument_list|(
name|threadId
operator|.
name|intValue
argument_list|()
argument_list|,
name|getThreadName
argument_list|(
name|threadId
argument_list|)
argument_list|,
name|this
operator|.
name|jdbcURL
argument_list|,
name|this
operator|.
name|jdbcProps
argument_list|,
name|commands
argument_list|,
name|sync
argument_list|,
name|this
operator|.
name|debug
condition|?
name|this
operator|.
name|debugStream
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// start all the threads
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|threads
operator|.
name|length
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|threads
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// wait for all threads to finish
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|threads
operator|.
name|length
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|threads
index|[
name|i
index|]
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
return|return
name|threads
return|;
block|}
specifier|protected
name|void
name|postExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
index|[]
name|threads
parameter_list|)
throws|throws
name|Exception
block|{
comment|// check for failures
if|if
condition|(
name|requiresCustomErrorHandling
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|threads
operator|.
name|length
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ConcurrentTestCommandExecutor
name|executor
init|=
name|threads
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|executor
operator|.
name|getFailureCause
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|customErrorHandler
argument_list|(
name|executor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|threads
operator|.
name|length
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|Throwable
name|cause
init|=
name|threads
index|[
name|i
index|]
operator|.
name|getFailureCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|failedThreads
operator|.
name|add
argument_list|(
operator|new
name|FailedThread
argument_list|(
name|threads
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|,
name|threads
index|[
name|i
index|]
operator|.
name|getFailureLocation
argument_list|()
argument_list|,
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Returns whether any test thread failed. Valid after {@link #execute} has      * returned.      */
specifier|public
name|boolean
name|failed
parameter_list|()
block|{
return|return
operator|!
name|failedThreads
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/** @return the list of failed threads (unmodifiable) */
specifier|public
name|List
argument_list|<
name|FailedThread
argument_list|>
name|getFailedThreads
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|failedThreads
argument_list|)
return|;
block|}
comment|/**      * Insures that the number of commands is the same for each thread, fills      * missing order value with null commands, and interleaves a synchronization      * command before each actual command. These steps are required for      * synchronized execution in FarragoConcurrencyTestCase.      */
specifier|public
name|void
name|synchronizeCommandSets
parameter_list|()
block|{
name|int
name|maxCommands
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
name|i
init|=
name|threadMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
name|commands
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Fill in missing slots with null (no-op) commands.
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
operator|(
name|commands
operator|.
name|lastKey
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|Integer
name|key
init|=
operator|new
name|Integer
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commands
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|commands
operator|.
name|put
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
name|maxCommands
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxCommands
argument_list|,
name|commands
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Make sure all threads have the same number of commands.
for|for
control|(
name|Iterator
argument_list|<
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
name|i
init|=
name|threadMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
name|commands
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|commands
operator|.
name|size
argument_list|()
operator|<
name|maxCommands
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|commands
operator|.
name|size
argument_list|()
operator|+
literal|1
init|;
name|j
operator|<=
name|maxCommands
condition|;
name|j
operator|++
control|)
block|{
name|commands
operator|.
name|put
argument_list|(
operator|new
name|Integer
argument_list|(
name|j
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Interleave synchronization commands before each command.
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
argument_list|>
name|i
init|=
name|threadMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
name|threadCommandsEntry
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
name|commands
init|=
name|threadCommandsEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
name|synchronizedCommands
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
name|j
init|=
name|commands
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
name|commandEntry
init|=
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|orderKey
init|=
operator|(
name|commandEntry
operator|.
name|getKey
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|ConcurrentTestCommand
name|command
init|=
name|commandEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|synchronizedCommands
operator|.
name|put
argument_list|(
operator|new
name|Integer
argument_list|(
operator|(
name|orderKey
operator|*
literal|2
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
operator|new
name|AutoSynchronizationCommand
argument_list|()
argument_list|)
expr_stmt|;
name|synchronizedCommands
operator|.
name|put
argument_list|(
operator|new
name|Integer
argument_list|(
name|orderKey
operator|*
literal|2
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
name|threadCommandsEntry
operator|.
name|setValue
argument_list|(
name|synchronizedCommands
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Validates that all threads have the same number of      * SynchronizationCommands (otherwise a deadlock is guaranteed).      * @return true when valid, false when invalid.      */
specifier|public
name|boolean
name|hasValidSynchronization
parameter_list|()
block|{
name|int
name|numSyncs
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
argument_list|>
name|i
init|=
name|threadMap
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
argument_list|>
name|threadCommandsEntry
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
name|commands
init|=
operator|(
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|ConcurrentTestCommand
argument_list|>
operator|)
name|threadCommandsEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|numSyncsThisThread
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ConcurrentTestCommand
argument_list|>
name|j
init|=
name|commands
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|j
operator|.
name|next
argument_list|()
operator|instanceof
name|SynchronizationCommand
condition|)
block|{
name|numSyncsThisThread
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numSyncs
operator|<
literal|0
condition|)
block|{
name|numSyncs
operator|=
name|numSyncsThisThread
expr_stmt|;
block|}
if|if
condition|(
name|numSyncs
operator|!=
name|numSyncsThisThread
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns a set of thread IDs.      */
specifier|protected
name|Set
argument_list|<
name|Integer
argument_list|>
name|getThreadIds
parameter_list|()
block|{
return|return
name|threadMap
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/**      * Retrieves the name of a given thread. If no thread names were configured,      * returns the concatenation of "#" and the thread's numeric identifier.      *      * @return human-readable thread name      */
specifier|protected
name|String
name|getThreadName
parameter_list|(
name|Integer
name|threadId
parameter_list|)
block|{
if|if
condition|(
name|threadNameMap
operator|.
name|containsKey
argument_list|(
name|threadId
argument_list|)
condition|)
block|{
return|return
name|threadNameMap
operator|.
name|get
argument_list|(
name|threadId
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|"#"
operator|+
name|threadId
return|;
block|}
block|}
comment|/**      * Indicates whether commands generated by this generator require special      * handling. Default implement returns false.      */
name|boolean
name|requiresCustomErrorHandling
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * Custom error handling occurs here if {@link      * #requiresCustomErrorHandling()} returns true. Default implementation does      * nothing.      */
name|void
name|customErrorHandler
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
block|{
block|}
comment|/**      * Returns a {@link Collection} of {@link ConcurrentTestCommand}      * objects for the given thread ID.      */
name|Collection
name|getCommands
parameter_list|(
name|Integer
name|threadId
parameter_list|)
block|{
assert|assert
operator|(
name|threadMap
operator|.
name|containsKey
argument_list|(
name|threadId
argument_list|)
operator|)
assert|;
return|return
operator|(
operator|(
name|TreeMap
operator|)
name|threadMap
operator|.
name|get
argument_list|(
name|threadId
argument_list|)
operator|)
operator|.
name|values
argument_list|()
return|;
block|}
comment|/**      * Returns an {@link Iterator} of {@link ConcurrentTestCommand}      * objects for the given thread ID.      */
name|Iterator
name|getCommandIterator
parameter_list|(
name|Integer
name|threadId
parameter_list|)
block|{
return|return
name|getCommands
argument_list|(
name|threadId
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**      * Prints a description of the commands to be executed for a given thread.      */
name|void
name|printCommands
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|Integer
name|threadId
parameter_list|)
block|{
name|int
name|stepNumber
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|getCommandIterator
argument_list|(
name|threadId
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"\tStep "
operator|+
name|stepNumber
operator|++
operator|+
literal|": "
operator|+
name|i
operator|.
name|next
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**      * abstract base to handle SQLExceptions      */
specifier|protected
specifier|static
specifier|abstract
class|class
name|AbstractCommand
implements|implements
name|ConcurrentTestCommand
block|{
specifier|private
name|boolean
name|shouldFail
init|=
literal|false
decl_stmt|;
specifier|private
name|String
name|failComment
init|=
literal|null
decl_stmt|;
comment|// describes an expected error
specifier|private
name|Pattern
name|failPattern
init|=
literal|null
decl_stmt|;
comment|// an expected error message
specifier|private
name|boolean
name|failureExpected
init|=
literal|false
decl_stmt|;
comment|// failure expected, no pattern
comment|// implement ConcurrentTestCommand
specifier|public
name|ConcurrentTestCommand
name|markToFail
parameter_list|(
name|String
name|comment
parameter_list|,
name|String
name|pattern
parameter_list|)
block|{
name|shouldFail
operator|=
literal|true
expr_stmt|;
name|failComment
operator|=
name|comment
expr_stmt|;
name|failPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|boolean
name|isFailureExpected
parameter_list|()
block|{
return|return
name|failureExpected
return|;
block|}
specifier|public
name|ConcurrentTestCommand
name|markToFail
parameter_list|()
block|{
name|this
operator|.
name|failureExpected
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|// subclasses define this to execute themselves
specifier|protected
specifier|abstract
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|exec
parameter_list|)
throws|throws
name|Exception
function_decl|;
comment|// implement ConcurrentTestCommand
specifier|public
name|void
name|execute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|exec
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|doExecute
argument_list|(
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldFail
condition|)
block|{
throw|throw
operator|new
name|ConcurrentTestCommand
operator|.
name|ShouldHaveFailedException
argument_list|(
name|failComment
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|err
parameter_list|)
block|{
if|if
condition|(
operator|!
name|shouldFail
condition|)
block|{
throw|throw
name|err
throw|;
block|}
name|boolean
name|matches
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|failPattern
operator|==
literal|null
condition|)
block|{
name|matches
operator|=
literal|true
expr_stmt|;
comment|// by default
block|}
else|else
block|{
for|for
control|(
name|SQLException
name|err2
init|=
name|err
init|;
name|err2
operator|!=
literal|null
condition|;
name|err2
operator|=
name|err2
operator|.
name|getNextException
argument_list|()
control|)
block|{
name|String
name|msg
init|=
name|err2
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
block|{
name|matches
operator|=
name|failPattern
operator|.
name|matcher
argument_list|(
name|msg
argument_list|)
operator|.
name|find
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|matches
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|matches
condition|)
block|{
comment|// an unexpected error
throw|throw
name|err
throw|;
block|}
else|else
block|{
comment|// else swallow it
name|Util
operator|.
name|swallow
argument_list|(
name|err
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * SynchronizationCommand causes the execution thread to wait for all other      * threads in the test before continuing.      */
specifier|static
class|class
name|SynchronizationCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
name|SynchronizationCommand
parameter_list|()
block|{
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|Exception
block|{
name|executor
operator|.
name|getSynchronizer
argument_list|()
operator|.
name|waitForOthers
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * AutoSynchronizationCommand is idential to SynchronizationCommand, except      * that it is generated automatically by the test harness and is not counted      * when displaying the step number in which an error occurred.      */
specifier|static
class|class
name|AutoSynchronizationCommand
extends|extends
name|SynchronizationCommand
block|{
specifier|private
name|AutoSynchronizationCommand
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * SleepCommand causes the execution thread to wait for all other threads in      * the test before continuing.      */
specifier|private
specifier|static
class|class
name|SleepCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
name|long
name|millis
decl_stmt|;
specifier|private
name|SleepCommand
parameter_list|(
name|long
name|millis
parameter_list|)
block|{
name|this
operator|.
name|millis
operator|=
name|millis
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|Exception
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|millis
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * ExplainCommand executes explain plan commands. Automatically closes the      * {@link Statement} before returning from {@link      * #execute(ConcurrentTestCommandExecutor)}.      */
specifier|private
specifier|static
class|class
name|ExplainCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
name|String
name|sql
decl_stmt|;
specifier|private
name|ExplainCommand
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|stmt
init|=
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|createStatement
argument_list|()
decl_stmt|;
try|try
block|{
name|ResultSet
name|rset
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|rowCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rset
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// REVIEW: SZ 6/17/2004: Should we attempt to
comment|// validate the results of the explain plan?
name|rowCount
operator|++
expr_stmt|;
block|}
assert|assert
operator|(
name|rowCount
operator|>
literal|0
operator|)
assert|;
block|}
finally|finally
block|{
name|rset
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * PrepareCommand creates a {@link PreparedStatement}. Stores the prepared      * statement in the ConcurrentTestCommandExecutor.      */
specifier|private
specifier|static
class|class
name|PrepareCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
name|String
name|sql
decl_stmt|;
specifier|private
name|PrepareCommand
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
init|=
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|executor
operator|.
name|setStatement
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * CloseCommand closes a previously prepared statement. If no statement is      * stored in the ConcurrentTestCommandExecutor, it does nothing.      */
specifier|private
specifier|static
class|class
name|CloseCommand
extends|extends
name|AbstractCommand
block|{
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|stmt
init|=
name|executor
operator|.
name|getStatement
argument_list|()
decl_stmt|;
if|if
condition|(
name|stmt
operator|!=
literal|null
condition|)
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|executor
operator|.
name|clearStatement
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|abstract
class|class
name|CommandWithTimeout
extends|extends
name|AbstractCommand
block|{
specifier|private
name|int
name|timeout
decl_stmt|;
specifier|private
name|CommandWithTimeout
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
specifier|protected
name|boolean
name|setTimeout
parameter_list|(
name|Statement
name|stmt
parameter_list|)
throws|throws
name|SQLException
block|{
assert|assert
operator|(
name|timeout
operator|>=
literal|0
operator|)
assert|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|stmt
operator|.
name|setQueryTimeout
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**      * FetchAndCompareCommand executes a previously prepared statement stored in      * the ConcurrentTestCommandExecutor and then validates the returned      * rows against expected data.      */
specifier|private
specifier|static
class|class
name|FetchAndCompareCommand
extends|extends
name|CommandWithTimeout
block|{
specifier|private
name|List
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|expected
decl_stmt|;
specifier|private
name|List
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|result
decl_stmt|;
specifier|private
name|FetchAndCompareCommand
parameter_list|(
name|int
name|timeout
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|super
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|parseExpected
argument_list|(
name|expected
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
init|=
operator|(
name|PreparedStatement
operator|)
name|executor
operator|.
name|getStatement
argument_list|()
decl_stmt|;
name|boolean
name|timeoutSet
init|=
name|setTimeout
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|ResultSet
name|rset
init|=
name|stmt
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|rows
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|rsetColumnCount
init|=
name|rset
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumnCount
argument_list|()
decl_stmt|;
while|while
condition|(
name|rset
operator|.
name|next
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|row
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|rsetColumnCount
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|value
init|=
name|rset
operator|.
name|getObject
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|rset
operator|.
name|wasNull
argument_list|()
condition|)
block|{
name|value
operator|=
literal|null
expr_stmt|;
block|}
name|row
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|rows
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SqlTimeoutException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|timeoutSet
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|rset
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|rows
expr_stmt|;
name|testValues
argument_list|()
expr_stmt|;
block|}
comment|/**          * Parses expected values. See {@link          * ConcurrentTestCommandGenerator#addFetchAndCompareCommand(int,          * int, int, String)} for details on format of<code>expected</code>.          *          * @throws IllegalStateException if there are formatting errors in          *<code>expected</code>          */
specifier|private
name|void
name|parseExpected
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
specifier|final
name|int
name|STATE_ROW_START
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|STATE_VALUE_START
init|=
literal|1
decl_stmt|;
specifier|final
name|int
name|STATE_STRING_VALUE
init|=
literal|2
decl_stmt|;
specifier|final
name|int
name|STATE_OTHER_VALUE
init|=
literal|3
decl_stmt|;
specifier|final
name|int
name|STATE_VALUE_END
init|=
literal|4
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|rows
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|state
init|=
name|STATE_ROW_START
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|row
init|=
literal|null
decl_stmt|;
name|StringBuilder
name|value
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expected
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|expected
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|nextCh
init|=
operator|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|expected
operator|.
name|length
argument_list|()
operator|)
condition|?
name|expected
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|STATE_ROW_START
case|:
comment|// find start of row
if|if
condition|(
name|ch
operator|==
name|LEFT_BRACKET
condition|)
block|{
name|row
operator|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|state
operator|=
name|STATE_VALUE_START
expr_stmt|;
block|}
break|break;
case|case
name|STATE_VALUE_START
case|:
comment|// start value
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|value
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|APOS
condition|)
block|{
comment|// a string value
name|state
operator|=
name|STATE_STRING_VALUE
expr_stmt|;
block|}
else|else
block|{
comment|// some other kind of value
name|value
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
name|STATE_OTHER_VALUE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|STATE_STRING_VALUE
case|:
comment|// handle string values
if|if
condition|(
name|ch
operator|==
name|APOS
condition|)
block|{
if|if
condition|(
name|nextCh
operator|==
name|APOS
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
name|APOS
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|row
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
name|STATE_VALUE_END
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATE_OTHER_VALUE
case|:
comment|// handle other values (numeric, null)
if|if
condition|(
operator|(
name|ch
operator|!=
name|COMMA
operator|)
operator|&&
operator|(
name|ch
operator|!=
name|RIGHT_BRACKET
operator|)
condition|)
block|{
name|value
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
name|String
name|stringValue
init|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|stringValue
operator|.
name|matches
argument_list|(
literal|"^-?[0-9]+$"
argument_list|)
condition|)
block|{
name|row
operator|.
name|add
argument_list|(
operator|new
name|BigInteger
argument_list|(
name|stringValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|stringValue
operator|.
name|matches
argument_list|(
literal|"^-?[0-9]*\\.[0-9]+$"
argument_list|)
condition|)
block|{
name|row
operator|.
name|add
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|stringValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|stringValue
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|row
operator|.
name|add
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|stringValue
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|row
operator|.
name|add
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|stringValue
operator|.
name|equals
argument_list|(
literal|"null"
argument_list|)
condition|)
block|{
name|row
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unknown value type '"
operator|+
name|stringValue
operator|+
literal|"' for FetchAndCompare command"
argument_list|)
throw|;
block|}
name|state
operator|=
name|STATE_VALUE_END
expr_stmt|;
comment|// FALL THROUGH
case|case
name|STATE_VALUE_END
case|:
comment|// find comma or end of row
if|if
condition|(
name|ch
operator|==
name|COMMA
condition|)
block|{
name|state
operator|=
name|STATE_VALUE_START
expr_stmt|;
block|}
if|else if
condition|(
name|ch
operator|==
name|RIGHT_BRACKET
condition|)
block|{
comment|// end of row
name|rows
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|state
operator|=
name|STATE_ROW_START
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unexpected character '"
operator|+
name|ch
operator|+
literal|"' at position "
operator|+
name|i
operator|+
literal|" of expected values"
argument_list|)
throw|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|state
operator|!=
name|STATE_ROW_START
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unterminated data in expected values"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rows
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Iterator
name|rowIter
init|=
name|rows
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|expectedNumColumns
init|=
operator|(
operator|(
name|ArrayList
operator|)
name|rowIter
operator|.
name|next
argument_list|()
operator|)
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|rowIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|numColumns
init|=
operator|(
operator|(
name|ArrayList
operator|)
name|rowIter
operator|.
name|next
argument_list|()
operator|)
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numColumns
operator|!=
name|expectedNumColumns
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"all rows in expected values must have the same number of columns"
argument_list|)
throw|;
block|}
block|}
block|}
name|this
operator|.
name|expected
operator|=
name|rows
expr_stmt|;
block|}
comment|/**          * Validates expected data against retrieved data.          */
specifier|private
name|void
name|testValues
parameter_list|()
block|{
if|if
condition|(
name|expected
operator|.
name|size
argument_list|()
operator|!=
name|result
operator|.
name|size
argument_list|()
condition|)
block|{
name|dumpData
argument_list|(
literal|"Expected "
operator|+
name|expected
operator|.
name|size
argument_list|()
operator|+
literal|" rows, got "
operator|+
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|expectedIter
init|=
name|expected
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|resultIter
init|=
name|result
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|rowNum
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|expectedIter
operator|.
name|hasNext
argument_list|()
operator|&&
name|resultIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|expectedRow
init|=
name|expectedIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|resultRow
init|=
name|resultIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|testValues
argument_list|(
name|expectedRow
argument_list|,
name|resultRow
argument_list|,
name|rowNum
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Validates {@link ResultSet} against expected data.          */
specifier|private
name|void
name|testValues
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|expectedRow
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|resultRow
parameter_list|,
name|int
name|rowNum
parameter_list|)
block|{
if|if
condition|(
name|expectedRow
operator|.
name|size
argument_list|()
operator|!=
name|resultRow
operator|.
name|size
argument_list|()
condition|)
block|{
name|dumpData
argument_list|(
literal|"Row "
operator|+
name|rowNum
operator|+
literal|" Expected "
operator|+
name|expected
operator|.
name|size
argument_list|()
operator|+
literal|" columns, got "
operator|+
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Iterator
name|expectedIter
init|=
name|expectedRow
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
name|resultIter
init|=
name|resultRow
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|colNum
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|expectedIter
operator|.
name|hasNext
argument_list|()
operator|&&
name|resultIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|expectedValue
init|=
name|expectedIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|resultValue
init|=
name|resultIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|expectedValue
operator|==
literal|null
operator|)
operator|||
operator|(
name|expectedValue
operator|instanceof
name|String
operator|)
operator|||
operator|(
name|expectedValue
operator|instanceof
name|Boolean
operator|)
condition|)
block|{
name|test
argument_list|(
name|expectedValue
argument_list|,
name|resultValue
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|expectedValue
operator|instanceof
name|BigInteger
condition|)
block|{
name|BigInteger
name|expectedInt
init|=
operator|(
name|BigInteger
operator|)
name|expectedValue
decl_stmt|;
if|if
condition|(
name|expectedInt
operator|.
name|bitLength
argument_list|()
operator|<=
literal|31
condition|)
block|{
name|test
argument_list|(
name|expectedInt
operator|.
name|intValue
argument_list|()
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|resultValue
operator|)
operator|.
name|intValue
argument_list|()
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|expectedInt
operator|.
name|bitLength
argument_list|()
operator|<=
literal|63
condition|)
block|{
name|test
argument_list|(
name|expectedInt
operator|.
name|longValue
argument_list|()
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|resultValue
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// REVIEW: how do we return very
comment|// large integer values?
name|test
argument_list|(
name|expectedInt
argument_list|,
name|resultValue
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|expectedValue
operator|instanceof
name|BigDecimal
condition|)
block|{
name|BigDecimal
name|expectedReal
init|=
operator|(
name|BigDecimal
operator|)
name|expectedValue
decl_stmt|;
name|float
name|asFloat
init|=
name|expectedReal
operator|.
name|floatValue
argument_list|()
decl_stmt|;
name|double
name|asDouble
init|=
name|expectedReal
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|asFloat
operator|!=
name|Float
operator|.
name|POSITIVE_INFINITY
operator|)
operator|&&
operator|(
name|asFloat
operator|!=
name|Float
operator|.
name|NEGATIVE_INFINITY
operator|)
condition|)
block|{
name|test
argument_list|(
name|asFloat
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|resultValue
operator|)
operator|.
name|floatValue
argument_list|()
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|asDouble
operator|!=
name|Double
operator|.
name|POSITIVE_INFINITY
operator|)
operator|&&
operator|(
name|asDouble
operator|!=
name|Double
operator|.
name|NEGATIVE_INFINITY
operator|)
condition|)
block|{
name|test
argument_list|(
name|asDouble
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|resultValue
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// REVIEW: how do we return very large decimal
comment|// values?
name|test
argument_list|(
name|expectedReal
argument_list|,
name|resultValue
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unknown type of expected value: "
operator|+
name|expectedValue
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|colNum
operator|++
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|test
parameter_list|(
name|Object
name|expected
parameter_list|,
name|Object
name|got
parameter_list|,
name|int
name|rowNum
parameter_list|,
name|int
name|colNum
parameter_list|)
block|{
if|if
condition|(
operator|(
name|expected
operator|==
literal|null
operator|)
operator|&&
operator|(
name|got
operator|==
literal|null
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|expected
operator|==
literal|null
operator|)
operator|||
operator|!
name|expected
operator|.
name|equals
argument_list|(
name|got
argument_list|)
condition|)
block|{
name|reportError
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|expected
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|got
argument_list|)
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|test
parameter_list|(
name|int
name|expected
parameter_list|,
name|int
name|got
parameter_list|,
name|int
name|rowNum
parameter_list|,
name|int
name|colNum
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|!=
name|got
condition|)
block|{
name|reportError
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|expected
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|got
argument_list|)
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|test
parameter_list|(
name|long
name|expected
parameter_list|,
name|long
name|got
parameter_list|,
name|int
name|rowNum
parameter_list|,
name|int
name|colNum
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|!=
name|got
condition|)
block|{
name|reportError
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|expected
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|got
argument_list|)
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|test
parameter_list|(
name|float
name|expected
parameter_list|,
name|float
name|got
parameter_list|,
name|int
name|rowNum
parameter_list|,
name|int
name|colNum
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|!=
name|got
condition|)
block|{
name|reportError
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|expected
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|got
argument_list|)
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|test
parameter_list|(
name|double
name|expected
parameter_list|,
name|double
name|got
parameter_list|,
name|int
name|rowNum
parameter_list|,
name|int
name|colNum
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|!=
name|got
condition|)
block|{
name|reportError
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|expected
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|got
argument_list|)
argument_list|,
name|rowNum
argument_list|,
name|colNum
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|reportError
parameter_list|(
name|String
name|expected
parameter_list|,
name|String
name|got
parameter_list|,
name|int
name|rowNum
parameter_list|,
name|int
name|colNum
parameter_list|)
block|{
name|dumpData
argument_list|(
literal|"Row "
operator|+
name|rowNum
operator|+
literal|", column "
operator|+
name|colNum
operator|+
literal|": expected<"
operator|+
name|expected
operator|+
literal|">, got<"
operator|+
name|got
operator|+
literal|">"
argument_list|)
expr_stmt|;
block|}
comment|/**          * Outputs expected and result data in tabular format.          */
specifier|private
name|void
name|dumpData
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|Iterator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|expectedIter
init|=
name|expected
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|resultIter
init|=
name|result
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|StringBuilder
name|fullMessage
init|=
operator|new
name|StringBuilder
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|int
name|rowNum
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|expectedIter
operator|.
name|hasNext
argument_list|()
operator|||
name|resultIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|StringBuilder
name|expectedOut
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|expectedOut
operator|.
name|append
argument_list|(
literal|"Row "
argument_list|)
operator|.
name|append
argument_list|(
name|rowNum
argument_list|)
operator|.
name|append
argument_list|(
literal|" exp:"
argument_list|)
expr_stmt|;
name|StringBuilder
name|resultOut
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|resultOut
operator|.
name|append
argument_list|(
literal|"Row "
argument_list|)
operator|.
name|append
argument_list|(
name|rowNum
argument_list|)
operator|.
name|append
argument_list|(
literal|" got:"
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Object
argument_list|>
name|expectedRowIter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|expectedIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|expectedRow
init|=
name|expectedIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|expectedRowIter
operator|=
name|expectedRow
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Object
argument_list|>
name|resultRowIter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|resultIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|resultRow
init|=
name|resultIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|resultRowIter
operator|=
name|resultRow
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
name|expectedRowIter
operator|!=
literal|null
operator|)
operator|&&
name|expectedRowIter
operator|.
name|hasNext
argument_list|()
operator|)
operator|||
operator|(
operator|(
name|resultRowIter
operator|!=
literal|null
operator|)
operator|&&
name|resultRowIter
operator|.
name|hasNext
argument_list|()
operator|)
condition|)
block|{
name|Object
name|expectedObject
init|=
operator|(
operator|(
name|expectedRowIter
operator|!=
literal|null
operator|)
condition|?
name|expectedRowIter
operator|.
name|next
argument_list|()
else|:
literal|""
operator|)
decl_stmt|;
name|Object
name|resultObject
init|=
operator|(
operator|(
name|resultRowIter
operator|!=
literal|null
operator|)
condition|?
name|resultRowIter
operator|.
name|next
argument_list|()
else|:
literal|""
operator|)
decl_stmt|;
name|String
name|expectedValue
decl_stmt|;
if|if
condition|(
name|expectedObject
operator|==
literal|null
condition|)
block|{
name|expectedValue
operator|=
literal|"<null>"
expr_stmt|;
block|}
else|else
block|{
name|expectedValue
operator|=
name|expectedObject
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|String
name|resultValue
decl_stmt|;
if|if
condition|(
name|resultObject
operator|==
literal|null
condition|)
block|{
name|resultValue
operator|=
literal|"<null>"
expr_stmt|;
block|}
else|else
block|{
name|resultValue
operator|=
name|resultObject
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|int
name|width
init|=
name|Math
operator|.
name|max
argument_list|(
name|expectedValue
operator|.
name|length
argument_list|()
argument_list|,
name|resultValue
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedOut
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
operator|.
name|append
argument_list|(
name|expectedValue
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|width
operator|-
name|expectedValue
operator|.
name|length
argument_list|()
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|expectedOut
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|resultOut
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
operator|.
name|append
argument_list|(
name|resultValue
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|width
operator|-
name|resultValue
operator|.
name|length
argument_list|()
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|resultOut
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|expectedRowIter
operator|==
literal|null
operator|)
operator|&&
operator|(
name|resultRowIter
operator|==
literal|null
operator|)
condition|)
block|{
name|expectedOut
operator|.
name|append
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|resultOut
operator|.
name|append
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
block|}
name|expectedOut
operator|.
name|append
argument_list|(
literal|" |"
argument_list|)
expr_stmt|;
name|resultOut
operator|.
name|append
argument_list|(
literal|" |"
argument_list|)
expr_stmt|;
name|fullMessage
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
operator|.
name|append
argument_list|(
name|expectedOut
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
operator|.
name|append
argument_list|(
name|resultOut
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|rowNum
operator|++
expr_stmt|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|fullMessage
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * InsertCommand exeutes an insert, update or delete SQL statement. Uses      * {@link Statement#executeUpdate(String)}.      */
specifier|private
specifier|static
class|class
name|InsertCommand
extends|extends
name|CommandWithTimeout
block|{
specifier|private
name|String
name|sql
decl_stmt|;
specifier|private
name|InsertCommand
parameter_list|(
name|int
name|timeout
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|super
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|stmt
init|=
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|setTimeout
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * CommitCommand commits pending transactions via {@link      * Connection#commit()}.      */
specifier|private
specifier|static
class|class
name|CommitCommand
extends|extends
name|AbstractCommand
block|{
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * RollbackCommand rolls back pending transactions via {@link      * Connection#rollback()}.      */
specifier|private
specifier|static
class|class
name|RollbackCommand
extends|extends
name|AbstractCommand
block|{
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * DdlCommand executes DDL commands. Automatically closes the {@link      * Statement} before returning from {@link      * #doExecute(ConcurrentTestCommandExecutor)}.      */
specifier|private
specifier|static
class|class
name|DdlCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
name|String
name|sql
decl_stmt|;
specifier|private
name|DdlCommand
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|stmt
init|=
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|createStatement
argument_list|()
decl_stmt|;
try|try
block|{
name|stmt
operator|.
name|execute
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End ConcurrentTestCommandGenerator.java
end_comment

end_unit

