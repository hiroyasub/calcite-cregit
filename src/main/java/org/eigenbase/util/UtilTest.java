begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to DynamoBI Corporation (DynamoBI) under one // or more contributor license agreements.  See the NOTICE file // distributed with this work for additional information // regarding copyright ownership.  DynamoBI licenses this file // to you under the Apache License, Version 2.0 (the // "License"); you may not use this file except in compliance // with the License.  You may obtain a copy of the License at  //   http://www.apache.org/licenses/LICENSE-2.0  // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied.  See the License for the // specific language governing permissions and limitations // under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|MessageFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|*
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|textui
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|test
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Unit test for {@link Util} and other classes in this package.  *  * @author jhyde  * @version $Id$  * @since Jul 12, 2004  */
end_comment

begin_class
specifier|public
class|class
name|UtilTest
extends|extends
name|TestCase
block|{
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|UtilTest
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
specifier|static
name|Test
name|suite
parameter_list|()
throws|throws
name|Exception
block|{
name|TestSuite
name|suite
init|=
operator|new
name|TestSuite
argument_list|()
decl_stmt|;
name|suite
operator|.
name|addTestSuite
argument_list|(
name|UtilTest
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|suite
return|;
block|}
specifier|public
name|void
name|testPrintEquals
parameter_list|()
block|{
name|assertPrintEquals
argument_list|(
literal|"\"x\""
argument_list|,
literal|"x"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testPrintEquals2
parameter_list|()
block|{
name|assertPrintEquals
argument_list|(
literal|"\"x\""
argument_list|,
literal|"x"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testPrintEquals3
parameter_list|()
block|{
name|assertPrintEquals
argument_list|(
literal|"null"
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testPrintEquals4
parameter_list|()
block|{
name|assertPrintEquals
argument_list|(
literal|""
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testPrintEquals5
parameter_list|()
block|{
name|assertPrintEquals
argument_list|(
literal|"\"\\\\\\\"\\r\\n\""
argument_list|,
literal|"\\\"\r\n"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testScientificNotation
parameter_list|()
block|{
name|BigDecimal
name|bd
decl_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"0.001234"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"1.234E-3"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"0.001"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"1E-3"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"-0.001"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"-1E-3"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"1E0"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"-1"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"-1E0"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"1.0"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"1.0E0"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"12345"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"1.2345E4"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"12345.00"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"1.234500E4"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"12345.001"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"1.2345001E4"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
comment|//test truncate
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"1.23456789012345678901"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"1.2345678901234567890E0"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
name|bd
operator|=
operator|new
name|BigDecimal
argument_list|(
literal|"-1.23456789012345678901"
argument_list|)
expr_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"-1.2345678901234567890E0"
argument_list|,
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testToJavaId
parameter_list|()
throws|throws
name|UnsupportedEncodingException
block|{
name|assertEquals
argument_list|(
literal|"ID$0$foo"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
literal|"foo"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"ID$0$foo_20_bar"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
literal|"foo bar"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"ID$0$foo__bar"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
literal|"foo_bar"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"ID$100$_30_bar"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
literal|"0bar"
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"ID$0$foo0bar"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
literal|"foo0bar"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"ID$0$it_27_s_20_a_20_bird_2c__20_it_27_s_20_a_20_plane_21_"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
literal|"it's a bird, it's a plane!"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Try some funny non-ASCII charsets
name|assertEquals
argument_list|(
literal|"ID$0$_f6__cb__c4__ca__ae__c1__f9__cb_"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
literal|"\u00f6\u00cb\u00c4\u00ca\u00ae\u00c1\u00f9\u00cb"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"ID$0$_f6cb__c4ca__aec1__f9cb_"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
literal|"\uf6cb\uc4ca\uaec1\uf9cb"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes1
init|=
block|{
literal|3
block|,
literal|12
block|,
literal|54
block|,
literal|23
block|,
literal|33
block|,
literal|23
block|,
literal|45
block|,
literal|21
block|,
literal|127
block|,
operator|-
literal|34
block|,
operator|-
literal|92
block|,
operator|-
literal|113
block|}
decl_stmt|;
name|assertEquals
argument_list|(
literal|"ID$0$_3__c_6_17__21__17__2d__15__7f__6cd9__fffd_"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
operator|new
name|String
argument_list|(
name|bytes1
argument_list|,
literal|"EUC-JP"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes2
init|=
block|{
literal|64
block|,
literal|32
block|,
literal|43
block|,
operator|-
literal|45
block|,
operator|-
literal|23
block|,
literal|0
block|,
literal|43
block|,
literal|54
block|,
literal|119
block|,
operator|-
literal|32
block|,
operator|-
literal|56
block|,
operator|-
literal|34
block|}
decl_stmt|;
name|assertEquals
argument_list|(
literal|"ID$0$_30c__3617__2117__2d15__7fde__a48f_"
argument_list|,
name|Util
operator|.
name|toJavaId
argument_list|(
operator|new
name|String
argument_list|(
name|bytes1
argument_list|,
literal|"UTF-16"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assertPrintEquals
parameter_list|(
name|String
name|expect
parameter_list|,
name|String
name|in
parameter_list|,
name|boolean
name|nullMeansNull
parameter_list|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|Util
operator|.
name|printJavaString
argument_list|(
name|pw
argument_list|,
name|in
argument_list|,
name|nullMeansNull
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
name|String
name|out
init|=
name|sw
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|expect
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests whether {@link EnumeratedValues} serialize correctly.      */
specifier|public
name|void
name|testSerializeEnumeratedValues
parameter_list|()
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|UnserializableEnum
name|unser
init|=
operator|(
name|UnserializableEnum
operator|)
name|serializeAndDeserialize
argument_list|(
name|UnserializableEnum
operator|.
name|Foo
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|unser
operator|==
name|UnserializableEnum
operator|.
name|Foo
argument_list|)
expr_stmt|;
name|SerializableEnum
name|ser
init|=
operator|(
name|SerializableEnum
operator|)
name|serializeAndDeserialize
argument_list|(
name|SerializableEnum
operator|.
name|Foo
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|ser
operator|==
name|SerializableEnum
operator|.
name|Foo
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|Object
name|serializeAndDeserialize
parameter_list|(
name|Object
name|e1
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|ByteArrayOutputStream
name|bout
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|ObjectOutputStream
name|out
init|=
operator|new
name|ObjectOutputStream
argument_list|(
name|bout
argument_list|)
decl_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|ByteArrayInputStream
name|bin
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|bout
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|ObjectInputStream
name|in
init|=
operator|new
name|ObjectInputStream
argument_list|(
name|bin
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|in
operator|.
name|readObject
argument_list|()
decl_stmt|;
return|return
name|o
return|;
block|}
comment|/**      * Unit-test for {@link BitString}.      */
specifier|public
name|void
name|testBitString
parameter_list|()
block|{
comment|// Powers of two, minimal length.
specifier|final
name|BitString
name|b0
init|=
operator|new
name|BitString
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b1
init|=
operator|new
name|BitString
argument_list|(
literal|"1"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b2
init|=
operator|new
name|BitString
argument_list|(
literal|"10"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b4
init|=
operator|new
name|BitString
argument_list|(
literal|"100"
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b8
init|=
operator|new
name|BitString
argument_list|(
literal|"1000"
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b16
init|=
operator|new
name|BitString
argument_list|(
literal|"10000"
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b32
init|=
operator|new
name|BitString
argument_list|(
literal|"100000"
argument_list|,
literal|6
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b64
init|=
operator|new
name|BitString
argument_list|(
literal|"1000000"
argument_list|,
literal|7
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b128
init|=
operator|new
name|BitString
argument_list|(
literal|"10000000"
argument_list|,
literal|8
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b256
init|=
operator|new
name|BitString
argument_list|(
literal|"100000000"
argument_list|,
literal|9
argument_list|)
decl_stmt|;
comment|// other strings
specifier|final
name|BitString
name|b0_1
init|=
operator|new
name|BitString
argument_list|(
literal|""
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|BitString
name|b0_12
init|=
operator|new
name|BitString
argument_list|(
literal|""
argument_list|,
literal|12
argument_list|)
decl_stmt|;
comment|// conversion to hex strings
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|b0
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1"
argument_list|,
name|b1
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2"
argument_list|,
name|b2
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"4"
argument_list|,
name|b4
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"8"
argument_list|,
name|b8
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"10"
argument_list|,
name|b16
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"20"
argument_list|,
name|b32
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"40"
argument_list|,
name|b64
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"80"
argument_list|,
name|b128
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"100"
argument_list|,
name|b256
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0"
argument_list|,
name|b0_1
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"000"
argument_list|,
name|b0_12
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
comment|// to byte array
name|assertByteArray
argument_list|(
literal|"01"
argument_list|,
literal|"1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertByteArray
argument_list|(
literal|"01"
argument_list|,
literal|"1"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assertByteArray
argument_list|(
literal|"01"
argument_list|,
literal|"1"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|assertByteArray
argument_list|(
literal|"00, 01"
argument_list|,
literal|"1"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|assertByteArray
argument_list|(
literal|""
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertByteArray
argument_list|(
literal|"00"
argument_list|,
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assertByteArray
argument_list|(
literal|"00"
argument_list|,
literal|"0000"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// bit count less than string
name|assertByteArray
argument_list|(
literal|"00"
argument_list|,
literal|"000"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|// bit count larger than string
name|assertByteArray
argument_list|(
literal|"00"
argument_list|,
literal|"0"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|// precisely 1 byte
name|assertByteArray
argument_list|(
literal|"00, 00"
argument_list|,
literal|"00"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|// just over 1 byte
comment|// from hex string
name|assertReversible
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"10"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"100"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"1000"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"10000"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"100000"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"1000000"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"10000000"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"100000000"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"01"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"001010"
argument_list|)
expr_stmt|;
name|assertReversible
argument_list|(
literal|"000000000100"
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|assertReversible
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|s
argument_list|,
name|BitString
operator|.
name|createFromBitString
argument_list|(
name|s
argument_list|)
operator|.
name|toBitString
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|s
argument_list|,
name|BitString
operator|.
name|createFromHexString
argument_list|(
name|s
argument_list|)
operator|.
name|toHexString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assertByteArray
parameter_list|(
name|String
name|expected
parameter_list|,
name|String
name|bits
parameter_list|,
name|int
name|bitCount
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|BitString
operator|.
name|toByteArrayFromBitString
argument_list|(
name|bits
argument_list|,
name|bitCount
argument_list|)
decl_stmt|;
specifier|final
name|String
name|s
init|=
name|toString
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**      * Converts a byte array to a hex string like "AB, CD".      */
specifier|private
name|String
name|toString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|b
init|=
name|bytes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|String
name|s
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|b
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
operator|(
name|b
operator|<
literal|16
operator|)
condition|?
operator|(
literal|"0"
operator|+
name|s
operator|)
else|:
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Tests {@link CastingList} and {@link Util#cast}.      */
specifier|public
name|void
name|testCastingList
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|Number
argument_list|>
name|numberList
init|=
operator|new
name|ArrayList
argument_list|<
name|Number
argument_list|>
argument_list|()
decl_stmt|;
name|numberList
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|numberList
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|numberList
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|integerList
init|=
name|Util
operator|.
name|cast
argument_list|(
name|numberList
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|integerList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|Integer
argument_list|(
literal|2
argument_list|)
argument_list|,
name|integerList
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Nulls are OK.
name|assertNull
argument_list|(
name|integerList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Can update the underlying list.
name|integerList
operator|.
name|set
argument_list|(
literal|1
argument_list|,
literal|345
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|Integer
argument_list|(
literal|345
argument_list|)
argument_list|,
name|integerList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|integerList
operator|.
name|set
argument_list|(
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|integerList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Can add a member of the wrong type to the underlying list.
name|numberList
operator|.
name|add
argument_list|(
operator|new
name|Double
argument_list|(
literal|3.1415
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|integerList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Access a member which is of the wrong type.
try|try
block|{
name|integerList
operator|.
name|get
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
comment|// ok
block|}
block|}
specifier|public
name|void
name|testIterableProperties
parameter_list|()
block|{
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"foo"
argument_list|,
literal|"george"
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"bar"
argument_list|,
literal|"ringo"
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|Util
operator|.
name|toMap
argument_list|(
name|properties
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"bar=ringo;foo=george;"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|Util
operator|.
name|toMap
argument_list|(
name|properties
argument_list|)
operator|.
name|entrySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
literal|"nonString"
argument_list|,
literal|34
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|Util
operator|.
name|toMap
argument_list|(
name|properties
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|s
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|fail
argument_list|(
literal|"expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
comment|// ok
block|}
block|}
comment|/**      * Tests the difference engine, {@link DiffTestCase#diff}.      */
specifier|public
name|void
name|testDiffLines
parameter_list|()
block|{
name|String
index|[]
name|before
init|=
block|{
literal|"Get a dose of her in jackboots and kilt"
block|,
literal|"She's killer-diller when she's dressed to the hilt"
block|,
literal|"She's the kind of a girl that makes The News of The World"
block|,
literal|"Yes you could say she was attractively built."
block|,
literal|"Yeah yeah yeah."
block|}
decl_stmt|;
name|String
index|[]
name|after
init|=
block|{
literal|"Get a dose of her in jackboots and kilt"
block|,
literal|"(they call her \"Polythene Pam\")"
block|,
literal|"She's killer-diller when she's dressed to the hilt"
block|,
literal|"She's the kind of a girl that makes The Sunday Times"
block|,
literal|"seem more interesting."
block|,
literal|"Yes you could say she was attractively built."
block|}
decl_stmt|;
name|String
name|diff
init|=
name|DiffTestCase
operator|.
name|diffLines
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|before
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|after
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|diff
argument_list|,
name|TestUtil
operator|.
name|fold
argument_list|(
literal|"1a2\n"
operator|+
literal|"> (they call her \"Polythene Pam\")\n"
operator|+
literal|"3c4,5\n"
operator|+
literal|"< She's the kind of a girl that makes The News of The World\n"
operator|+
literal|"---\n"
operator|+
literal|"> She's the kind of a girl that makes The Sunday Times\n"
operator|+
literal|"> seem more interesting.\n"
operator|+
literal|"5d6\n"
operator|+
literal|"< Yeah yeah yeah.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the {@link Util#toPosix(TimeZone, boolean)} method.      */
specifier|public
name|void
name|testPosixTimeZone
parameter_list|()
block|{
comment|// NOTE jvs 31-July-2007:  First two tests are disabled since
comment|// not everyone may have patched their system yet for recent
comment|// DST change.
comment|// Pacific Standard Time. Effective 2007, the local time changes from
comment|// PST to PDT at 02:00 LST to 03:00 LDT on the second Sunday in March
comment|// and returns at 02:00 LDT to 01:00 LST on the first Sunday in
comment|// November.
if|if
condition|(
literal|false
condition|)
block|{
name|assertEquals
argument_list|(
literal|"PST-8PDT,M3.2.0,M11.1.0"
argument_list|,
name|Util
operator|.
name|toPosix
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"PST"
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"PST-8PDT1,M3.2.0/2,M11.1.0/2"
argument_list|,
name|Util
operator|.
name|toPosix
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"PST"
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Tokyo has +ve offset, no DST
name|assertEquals
argument_list|(
literal|"JST9"
argument_list|,
name|Util
operator|.
name|toPosix
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"Asia/Tokyo"
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Sydney, Australia lies ten hours east of GMT and makes a one hour
comment|// shift forward during daylight savings. Being located in the southern
comment|// hemisphere, daylight savings begins on the last Sunday in October at
comment|// 2am and ends on the last Sunday in March at 3am.
comment|// (Uses STANDARD_TIME time-transition mode.)
comment|// Because australia changed their daylight savings rules, some JVMs
comment|// have a different (older and incorrect) timezone settings for
comment|// Australia.  So we test for the older one first then do the
comment|// correct assert based upon what the toPosix method returns
name|String
name|posixTime
init|=
name|Util
operator|.
name|toPosix
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"Australia/Sydney"
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|posixTime
operator|.
name|equals
argument_list|(
literal|"EST10EST1,M10.5.0/2,M3.5.0/3"
argument_list|)
condition|)
block|{
comment|// older JVMs without the fix
name|assertEquals
argument_list|(
literal|"EST10EST1,M10.5.0/2,M3.5.0/3"
argument_list|,
name|posixTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// newer JVMs with the fix
name|assertEquals
argument_list|(
literal|"EST10EST1,M10.1.0/2,M4.1.0/3"
argument_list|,
name|posixTime
argument_list|)
expr_stmt|;
block|}
comment|// Paris, France. (Uses UTC_TIME time-transition mode.)
name|assertEquals
argument_list|(
literal|"CET1CEST1,M3.5.0/2,M10.5.0/3"
argument_list|,
name|Util
operator|.
name|toPosix
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"Europe/Paris"
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"UTC0"
argument_list|,
name|Util
operator|.
name|toPosix
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the methods {@link Util#enumConstants(Class)} and {@link      * Util#enumVal(Class, String)}.      */
specifier|public
name|void
name|testEnumConstants
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MemoryType
argument_list|>
name|memoryTypeMap
init|=
name|Util
operator|.
name|enumConstants
argument_list|(
name|MemoryType
operator|.
name|class
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|memoryTypeMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|MemoryType
operator|.
name|HEAP
argument_list|,
name|memoryTypeMap
operator|.
name|get
argument_list|(
literal|"HEAP"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|MemoryType
operator|.
name|NON_HEAP
argument_list|,
name|memoryTypeMap
operator|.
name|get
argument_list|(
literal|"NON_HEAP"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|memoryTypeMap
operator|.
name|put
argument_list|(
literal|"FOO"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// expected: map is immutable
block|}
name|assertEquals
argument_list|(
literal|"HEAP"
argument_list|,
name|Util
operator|.
name|enumVal
argument_list|(
name|MemoryType
operator|.
name|class
argument_list|,
literal|"HEAP"
argument_list|)
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|Util
operator|.
name|enumVal
argument_list|(
name|MemoryType
operator|.
name|class
argument_list|,
literal|"heap"
argument_list|)
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
name|Util
operator|.
name|enumVal
argument_list|(
name|MemoryType
operator|.
name|class
argument_list|,
literal|"nonexistent"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the method {@link Util#toIter(java.util.BitSet)}.      */
specifier|public
name|void
name|testToIterBitSet
parameter_list|()
block|{
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|assertToIterBitSet
argument_list|(
literal|""
argument_list|,
name|bitSet
argument_list|)
expr_stmt|;
name|bitSet
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertToIterBitSet
argument_list|(
literal|"0"
argument_list|,
name|bitSet
argument_list|)
expr_stmt|;
name|bitSet
operator|.
name|set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertToIterBitSet
argument_list|(
literal|"0, 1"
argument_list|,
name|bitSet
argument_list|)
expr_stmt|;
name|bitSet
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bitSet
operator|.
name|set
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|assertToIterBitSet
argument_list|(
literal|"10"
argument_list|,
name|bitSet
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests that iterating over a BitSet yields the expected string.      *      * @param expected Expected string      * @param bitSet Bit set      */
specifier|private
name|void
name|assertToIterBitSet
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|,
name|BitSet
name|bitSet
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|Util
operator|.
name|toIter
argument_list|(
name|bitSet
argument_list|)
control|)
block|{
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the method {@link Util#toList(java.util.BitSet)}.      */
specifier|public
name|void
name|testToListBitSet
parameter_list|()
block|{
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toList
argument_list|(
name|bitSet
argument_list|)
argument_list|,
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
name|bitSet
operator|.
name|set
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toList
argument_list|(
name|bitSet
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|bitSet
operator|.
name|set
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toList
argument_list|(
name|bitSet
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the method {@link Util#bitSetOf(int...)}.      */
specifier|public
name|void
name|testBitSetOf
parameter_list|()
block|{
name|assertEquals
argument_list|(
name|Util
operator|.
name|toList
argument_list|(
name|Util
operator|.
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toList
argument_list|(
name|Util
operator|.
name|bitSetOf
argument_list|()
argument_list|)
argument_list|,
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the method {@link Util#bitSetBetween(int, int)}.      */
specifier|public
name|void
name|testBitSetBetween
parameter_list|()
block|{
name|assertEquals
argument_list|(
name|Util
operator|.
name|toList
argument_list|(
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toList
argument_list|(
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Util
operator|.
name|toList
argument_list|(
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|Collections
operator|.
expr|<
name|Integer
operator|>
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests SQL builders.      */
specifier|public
name|void
name|testSqlBuilder
parameter_list|()
block|{
specifier|final
name|SqlBuilder
name|buf
init|=
operator|new
name|SqlBuilder
argument_list|(
name|SqlDialect
operator|.
name|EIGENBASE
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"select "
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"select "
argument_list|,
name|buf
operator|.
name|getSql
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|identifier
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"select \"x\""
argument_list|,
name|buf
operator|.
name|getSql
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|identifier
argument_list|(
literal|"y"
argument_list|,
literal|"a b"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"select \"x\", \"y\".\"a b\""
argument_list|,
name|buf
operator|.
name|getSql
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SqlString
name|sqlString
init|=
name|buf
operator|.
name|toSqlString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|SqlDialect
operator|.
name|EIGENBASE
argument_list|,
name|sqlString
operator|.
name|getDialect
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|buf
operator|.
name|getSql
argument_list|()
argument_list|,
name|sqlString
operator|.
name|getSql
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|buf
operator|.
name|getSql
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|buf
operator|.
name|getSqlAndClear
argument_list|()
argument_list|,
name|sqlString
operator|.
name|getSql
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|literal
argument_list|(
literal|"can't get no satisfaction"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"'can''t get no satisfaction'"
argument_list|,
name|buf
operator|.
name|getSqlAndClear
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|literal
argument_list|(
operator|new
name|Timestamp
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"TIMESTAMP '1970-01-01 00:00:00'"
argument_list|,
name|buf
operator|.
name|getSqlAndClear
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|clear
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"hello world"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|buf
operator|.
name|indexOf
argument_list|(
literal|"l"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|1
argument_list|,
name|buf
operator|.
name|indexOf
argument_list|(
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|buf
operator|.
name|indexOf
argument_list|(
literal|"l"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unit test for {@link org.eigenbase.util.CompositeList}.      */
specifier|public
name|void
name|testCompositeList
parameter_list|()
block|{
comment|// Made up of zero lists
name|CompositeList
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|CompositeList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|list
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|String
name|s
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertFalse
argument_list|(
name|list
operator|.
name|listIterator
argument_list|()
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|listEmpty
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|listAbc
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|listEmpty2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Made up of two lists, two of which are empty
name|list
operator|=
operator|new
name|CompositeList
argument_list|<
name|String
argument_list|>
argument_list|(
name|listEmpty
argument_list|,
name|listAbc
argument_list|,
name|listEmpty2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|list
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"c"
argument_list|,
name|list
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|String
name|s
init|=
name|list
operator|.
name|get
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// ok
block|}
try|try
block|{
specifier|final
name|String
name|s
init|=
name|list
operator|.
name|set
argument_list|(
literal|0
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// ok
block|}
comment|// Iterator
specifier|final
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterator
init|=
name|list
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|iterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"a"
argument_list|,
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"b"
argument_list|,
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|iterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"expected error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertEquals
argument_list|(
literal|"c"
argument_list|,
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|iterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|// Extend one of the backing lists, and list grows.
name|listEmpty2
operator|.
name|add
argument_list|(
literal|"zz"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"zz"
argument_list|,
name|list
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|// Syntactic sugar 'of' method
name|String
name|ss
init|=
literal|""
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|CompositeList
operator|.
name|of
argument_list|(
name|list
argument_list|,
name|list
argument_list|)
control|)
block|{
name|ss
operator|+=
name|s
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"abczzabczz"
argument_list|,
name|ss
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unit test for {@link Template}.      */
specifier|public
name|void
name|testTemplate
parameter_list|()
block|{
comment|// Regular java message format.
name|assertEquals
argument_list|(
literal|"Hello, world, what a nice day."
argument_list|,
name|MessageFormat
operator|.
name|format
argument_list|(
literal|"Hello, {0}, what a nice {1}."
argument_list|,
literal|"world"
argument_list|,
literal|"day"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Our extended message format. First, just strings.
specifier|final
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"person"
argument_list|,
literal|"world"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"time"
argument_list|,
literal|"day"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Hello, world, what a nice day."
argument_list|,
name|Template
operator|.
name|formatByName
argument_list|(
literal|"Hello, {person}, what a nice {time}."
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
comment|// String and an integer.
specifier|final
name|Template
name|template
init|=
operator|new
name|Template
argument_list|(
literal|"Happy {age,number,#.00}th birthday, {person}!"
argument_list|)
decl_stmt|;
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"person"
argument_list|,
literal|"Ringo"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"age"
argument_list|,
literal|64.5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Happy 64.50th birthday, Ringo!"
argument_list|,
name|template
operator|.
name|format
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
comment|// Missing parameters evaluate to null.
name|map
operator|.
name|remove
argument_list|(
literal|"person"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Happy 64.50th birthday, null!"
argument_list|,
name|template
operator|.
name|format
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
comment|// Specify parameter by Integer ordinal.
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|1
argument_list|,
literal|"Ringo"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"0"
argument_list|,
literal|64.5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Happy 64.50th birthday, Ringo!"
argument_list|,
name|template
operator|.
name|format
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
comment|// Too many parameters supplied.
name|map
operator|.
name|put
argument_list|(
literal|"lastName"
argument_list|,
literal|"Starr"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"homeTown"
argument_list|,
literal|"Liverpool"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Happy 64.50th birthday, Ringo!"
argument_list|,
name|template
operator|.
name|format
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
comment|// Get parameter names. In order of appearance.
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"age"
argument_list|,
literal|"person"
argument_list|)
argument_list|,
name|template
operator|.
name|getParameterNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// No parameters; doubled single quotes; quoted braces.
specifier|final
name|Template
name|template2
init|=
operator|new
name|Template
argument_list|(
literal|"Don''t expand 'this {brace}'."
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptyList
argument_list|()
argument_list|,
name|template2
operator|.
name|getParameterNames
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Don't expand this {brace}."
argument_list|,
name|template2
operator|.
name|format
argument_list|(
name|Collections
operator|.
expr|<
name|Object
argument_list|,
name|Object
operator|>
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Empty template.
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|Template
operator|.
name|formatByName
argument_list|(
literal|""
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unit test for {@link Util#parseLocale(String)} method.      */
specifier|public
name|void
name|testParseLocale
parameter_list|()
block|{
name|Locale
index|[]
name|locales
init|=
block|{
name|Locale
operator|.
name|CANADA
block|,
name|Locale
operator|.
name|CANADA_FRENCH
block|,
name|Locale
operator|.
name|getDefault
argument_list|()
block|,
name|Locale
operator|.
name|US
block|,
name|Locale
operator|.
name|TRADITIONAL_CHINESE
block|,         }
decl_stmt|;
for|for
control|(
name|Locale
name|locale
range|:
name|locales
control|)
block|{
name|assertEquals
argument_list|(
name|locale
argument_list|,
name|Util
operator|.
name|parseLocale
argument_list|(
name|locale
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Example locale names in Locale.toString() javadoc.
name|String
index|[]
name|localeNames
init|=
block|{
literal|"en"
block|,
literal|"de_DE"
block|,
literal|"_GB"
block|,
literal|"en_US_WIN"
block|,
literal|"de__POSIX"
block|,
literal|"fr__MAC"
block|}
decl_stmt|;
for|for
control|(
name|String
name|localeName
range|:
name|localeNames
control|)
block|{
name|assertEquals
argument_list|(
name|localeName
argument_list|,
name|Util
operator|.
name|parseLocale
argument_list|(
name|localeName
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|testStringChunker
parameter_list|()
block|{
name|String
name|source
init|=
literal|"0123456789AB"
decl_stmt|;
name|String
index|[]
name|chunks
decl_stmt|;
name|String
index|[]
name|ref
init|=
operator|new
name|String
index|[]
block|{
literal|"0123456789AB"
block|}
decl_stmt|;
name|int
name|chunkSize
init|=
literal|0
decl_stmt|;
name|int
name|chunkCount
decl_stmt|;
comment|// Invalid chunk size
try|try
block|{
name|chunkCount
operator|=
name|StringChunker
operator|.
name|countChunks
argument_list|(
name|source
operator|.
name|length
argument_list|()
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected division by zero error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ae
parameter_list|)
block|{
comment|// OK
block|}
comment|// Unchunked; buffer size>> string length
name|chunkSize
operator|=
literal|32767
expr_stmt|;
name|chunkCount
operator|=
name|StringChunker
operator|.
name|countChunks
argument_list|(
name|source
operator|.
name|length
argument_list|()
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|chunkCount
argument_list|)
expr_stmt|;
name|chunks
operator|=
name|StringChunker
operator|.
name|slice
argument_list|(
name|source
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|ref
argument_list|,
name|chunks
argument_list|)
argument_list|)
expr_stmt|;
comment|// Unchunked; exact buffer size match
name|chunkSize
operator|=
literal|12
expr_stmt|;
name|chunkCount
operator|=
name|StringChunker
operator|.
name|countChunks
argument_list|(
name|source
operator|.
name|length
argument_list|()
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|chunkCount
argument_list|)
expr_stmt|;
name|chunks
operator|=
name|StringChunker
operator|.
name|slice
argument_list|(
name|source
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|ref
argument_list|,
name|chunks
argument_list|)
argument_list|)
expr_stmt|;
comment|// Simple split, evenly divisible
name|chunkSize
operator|=
literal|6
expr_stmt|;
name|chunkCount
operator|=
name|StringChunker
operator|.
name|countChunks
argument_list|(
name|source
operator|.
name|length
argument_list|()
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|chunkCount
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|new
name|String
index|[]
block|{
literal|"012345"
block|,
literal|"6789AB"
block|}
expr_stmt|;
name|chunks
operator|=
name|StringChunker
operator|.
name|slice
argument_list|(
name|source
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|ref
argument_list|,
name|chunks
argument_list|)
argument_list|)
expr_stmt|;
comment|// Simple split, not evenly divisible
name|chunkSize
operator|=
literal|5
expr_stmt|;
name|chunkCount
operator|=
name|StringChunker
operator|.
name|countChunks
argument_list|(
name|source
operator|.
name|length
argument_list|()
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|chunkCount
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|new
name|String
index|[]
block|{
literal|"01234"
block|,
literal|"56789"
block|,
literal|"AB"
block|}
expr_stmt|;
name|chunks
operator|=
name|StringChunker
operator|.
name|slice
argument_list|(
name|source
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|ref
argument_list|,
name|chunks
argument_list|)
argument_list|)
expr_stmt|;
comment|// Worst case, individual characters
name|chunkSize
operator|=
literal|1
expr_stmt|;
name|chunkCount
operator|=
name|StringChunker
operator|.
name|countChunks
argument_list|(
name|source
operator|.
name|length
argument_list|()
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
name|chunkCount
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|new
name|String
index|[]
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"A"
block|,
literal|"B"
block|}
expr_stmt|;
name|chunks
operator|=
name|StringChunker
operator|.
name|slice
argument_list|(
name|source
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|ref
argument_list|,
name|chunks
argument_list|)
argument_list|)
expr_stmt|;
comment|// Empty input string
name|source
operator|=
literal|""
expr_stmt|;
name|chunkCount
operator|=
name|StringChunker
operator|.
name|countChunks
argument_list|(
name|source
operator|.
name|length
argument_list|()
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|chunkCount
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|new
name|String
index|[]
block|{
literal|""
block|}
expr_stmt|;
name|chunks
operator|=
name|StringChunker
operator|.
name|slice
argument_list|(
name|source
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Arrays
operator|.
name|equals
argument_list|(
name|ref
argument_list|,
name|chunks
argument_list|)
argument_list|)
expr_stmt|;
comment|// Null input string
name|source
operator|=
literal|null
expr_stmt|;
try|try
block|{
name|chunks
operator|=
name|StringChunker
operator|.
name|slice
argument_list|(
name|source
argument_list|,
name|chunkSize
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected null pointer"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|npe
parameter_list|)
block|{
comment|// OK
block|}
block|}
comment|/**      * Runs the test suite.      */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|TestRunner
operator|.
name|run
argument_list|(
name|suite
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**      * Enumeration which extends BasicValue does NOT serialize correctly.      */
specifier|private
specifier|static
class|class
name|UnserializableEnum
extends|extends
name|EnumeratedValues
operator|.
name|BasicValue
block|{
specifier|public
specifier|static
specifier|final
name|UnserializableEnum
name|Foo
init|=
operator|new
name|UnserializableEnum
argument_list|(
literal|"foo"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|UnserializableEnum
name|Bar
init|=
operator|new
name|UnserializableEnum
argument_list|(
literal|"bar"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|public
name|UnserializableEnum
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|ordinal
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Enumeration which serializes correctly.      */
specifier|private
specifier|static
class|class
name|SerializableEnum
extends|extends
name|EnumeratedValues
operator|.
name|SerializableValue
block|{
specifier|public
specifier|static
specifier|final
name|SerializableEnum
name|Foo
init|=
operator|new
name|SerializableEnum
argument_list|(
literal|"foo"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SerializableEnum
name|Bar
init|=
operator|new
name|SerializableEnum
argument_list|(
literal|"bar"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|public
name|SerializableEnum
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|ordinal
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Object
name|readResolve
parameter_list|()
throws|throws
name|ObjectStreamException
block|{
switch|switch
condition|(
name|_ordinal
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Foo
return|;
case|case
literal|2
case|:
return|return
name|Bar
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End UtilTest.java
end_comment

end_unit

