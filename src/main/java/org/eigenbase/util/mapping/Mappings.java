begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Utility functions related to mappings.  *  * @author jhyde  * @version $Id$  * @see MappingType  * @see Mapping  * @see Permutation  * @since Mar 24, 2006  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Mappings
block|{
comment|//~ Constructors -----------------------------------------------------------
specifier|private
name|Mappings
parameter_list|()
block|{
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * Creates a mapping with required properties.      */
specifier|public
specifier|static
name|Mapping
name|create
parameter_list|(
name|MappingType
name|mappingType
parameter_list|,
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|)
block|{
switch|switch
condition|(
name|mappingType
condition|)
block|{
case|case
name|Bijection
case|:
assert|assert
name|sourceCount
operator|==
name|targetCount
assert|;
return|return
operator|new
name|Permutation
argument_list|(
name|sourceCount
argument_list|)
return|;
case|case
name|InverseSurjection
case|:
case|case
name|PartialSurjection
case|:
return|return
operator|new
name|Mappings
operator|.
name|PartialMapping
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|mappingType
argument_list|)
return|;
case|case
name|PartialFunction
case|:
case|case
name|Function
case|:
return|return
operator|new
name|PartialFunctionImpl
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|mappingType
argument_list|)
return|;
case|case
name|InverseFunction
case|:
case|case
name|InversePartialFunction
case|:
return|return
operator|new
name|InverseMapping
argument_list|(
name|create
argument_list|(
name|mappingType
operator|.
name|inverse
argument_list|()
argument_list|,
name|targetCount
argument_list|,
name|sourceCount
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"no known implementation for mapping type "
operator|+
name|mappingType
argument_list|)
throw|;
block|}
block|}
comment|//~ Inner Interfaces -------------------------------------------------------
comment|/**      * Mapping where every source has a target. But:      *      *<ul>      *<li>A target may not have a source.      *<li>May not be finite.      *</ul>      */
specifier|public
specifier|static
interface|interface
name|FunctionMapping
block|{
comment|/**          * Returns the target that a source maps to, or -1 if it is not mapped.          */
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
function_decl|;
comment|/**          * Returns the target that a source maps to.          *          * @param source source          *          * @return target          *          * @throws IndexOutOfBoundsException if source is not mapped          */
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
function_decl|;
name|MappingType
name|getMappingType
parameter_list|()
function_decl|;
name|int
name|getSourceCount
parameter_list|()
function_decl|;
block|}
comment|/**      * Mapping suitable for sourcing columns.      *      *<p>Properties:      *      *<ul>      *<li>It has a finite number of sources and targets      *<li>Each target has exactly one source      *<li>Each source has at most one target      *</ul>      *      *<p>TODO: figure out which interfaces this should extend      */
specifier|public
specifier|static
interface|interface
name|SourceMapping
block|{
name|int
name|getSourceCount
parameter_list|()
function_decl|;
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
function_decl|;
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
function_decl|;
name|int
name|getTargetCount
parameter_list|()
function_decl|;
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
function_decl|;
name|MappingType
name|getMappingType
parameter_list|()
function_decl|;
name|boolean
name|isIdentity
parameter_list|()
function_decl|;
name|Mapping
name|inverse
parameter_list|()
function_decl|;
block|}
comment|/**      * Mapping suitable for mapping columns to a target.      *      *<p>Properties:      *      *<ul>      *<li>It has a finite number of sources and targets      *<li>Each target has at most one source      *<li>Each source has exactly one target      *</ul>      *      *<p>TODO: figure out which interfaces this should extend      */
specifier|public
specifier|static
interface|interface
name|TargetMapping
block|{
name|int
name|getSourceCount
parameter_list|()
function_decl|;
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
function_decl|;
name|int
name|getTargetCount
parameter_list|()
function_decl|;
name|int
name|getTarget
parameter_list|(
name|int
name|target
parameter_list|)
function_decl|;
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
function_decl|;
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
function_decl|;
name|MappingType
name|getMappingType
parameter_list|()
function_decl|;
name|Mapping
name|inverse
parameter_list|()
function_decl|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|public
specifier|static
specifier|abstract
class|class
name|AbstractMapping
implements|implements
name|Mapping
block|{
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
name|int
name|target
init|=
name|getTargetOpt
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"source #"
operator|+
name|source
operator|+
literal|" has no target in mapping "
operator|+
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|target
return|;
block|}
specifier|public
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
name|int
name|source
init|=
name|getSourceOpt
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"target #"
operator|+
name|source
operator|+
literal|" has no source in mapping "
operator|+
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|source
return|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
name|int
name|sourceCount
init|=
name|getSourceCount
argument_list|()
decl_stmt|;
name|int
name|targetCount
init|=
name|getTargetCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceCount
operator|!=
name|targetCount
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|getSource
argument_list|(
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
specifier|abstract
class|class
name|FiniteAbstractMapping
extends|extends
name|AbstractMapping
block|{
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|FunctionMappingIter
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**          * Returns a string representation of this mapping.          *          *<p>For example, the mapping          *          *<table border="1">          *<tr>          *<th>source</th>          *<td>0</td>          *<td>1</td>          *<td>2</td>          *</tr>          *<tr>          *<th>target</th>          *<td>-1</td>          *<td>3</td>          *<td>2</td>          *</tr>          *</table>          *          *<table border="1">          *<tr>          *<th>target</th>          *<td>0</td>          *<td>1</td>          *<td>2</td>          *<td>3</td>          *</tr>          *<tr>          *<th>source</th>          *<td>-1</td>          *<td>-1</td>          *<td>2</td>          *<td>1</td>          *</tr>          *</table>          *          * is represented by the string "[1:3, 2:2]".          *          *<p>This method relies upon the optional method {@link #iterator()}.          */
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iter
init|=
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|IntPair
name|pair
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|pair
operator|.
name|source
argument_list|)
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
operator|.
name|append
argument_list|(
name|pair
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// not very efficient
return|return
name|toString
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
comment|// not very efficient
return|return
operator|(
name|obj
operator|instanceof
name|Permutation
operator|)
operator|&&
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|obj
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|FunctionMappingIter
implements|implements
name|Iterator
argument_list|<
name|IntPair
argument_list|>
block|{
specifier|private
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|FunctionMapping
name|mapping
decl_stmt|;
name|FunctionMappingIter
parameter_list|(
name|FunctionMapping
name|mapping
parameter_list|)
block|{
name|this
operator|.
name|mapping
operator|=
name|mapping
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|(
name|i
operator|<
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|)
operator|||
operator|(
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|==
operator|-
literal|1
operator|)
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
name|int
name|x
init|=
name|i
operator|++
decl_stmt|;
return|return
operator|new
name|IntPair
argument_list|(
name|x
argument_list|,
name|mapping
operator|.
name|getTarget
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|/**      * Thrown when a mapping is expected to return one element but returns      * several.      */
specifier|public
specifier|static
class|class
name|TooManyElementsException
extends|extends
name|RuntimeException
block|{     }
comment|/**      * Thrown when a mapping is expected to return one element but returns none.      */
specifier|public
specifier|static
class|class
name|NoElementException
extends|extends
name|RuntimeException
block|{     }
comment|/**      * A mapping where a source at most one target, and every target has at most      * one source.      */
specifier|public
specifier|static
class|class
name|PartialMapping
extends|extends
name|FiniteAbstractMapping
implements|implements
name|Mapping
implements|,
name|FunctionMapping
implements|,
name|TargetMapping
block|{
specifier|protected
specifier|final
name|int
index|[]
name|sources
decl_stmt|;
specifier|protected
specifier|final
name|int
index|[]
name|targets
decl_stmt|;
specifier|private
specifier|final
name|MappingType
name|mappingType
decl_stmt|;
comment|/**          * Creates a partial mapping.          *          *<p>Initially, no element is mapped to any other:          *          *<table border="1">          *<tr>          *<th>source</th>          *<td>0</td>          *<td>1</td>          *<td>2</td>          *</tr>          *<tr>          *<th>target</th>          *<td>-1</td>          *<td>-1</td>          *<td>-1</td>          *</tr>          *</table>          *          *<table border="1">          *<tr>          *<th>target</th>          *<td>0</td>          *<td>1</td>          *<td>2</td>          *<td>3</td>          *</tr>          *<tr>          *<th>source</th>          *<td>-1</td>          *<td>-1</td>          *<td>-1</td>          *<td>-1</td>          *</tr>          *</table>          *          * @param sourceCount Number of source elements          * @param targetCount Number of target elements          * @param mappingType Mapping type; must not allow multiple sources per          * target or multiple targets per source          */
specifier|public
name|PartialMapping
parameter_list|(
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|,
name|MappingType
name|mappingType
parameter_list|)
block|{
name|this
operator|.
name|mappingType
operator|=
name|mappingType
expr_stmt|;
assert|assert
name|mappingType
operator|.
name|isSingleSource
argument_list|()
operator|:
name|mappingType
assert|;
assert|assert
name|mappingType
operator|.
name|isSingleTarget
argument_list|()
operator|:
name|mappingType
assert|;
name|this
operator|.
name|sources
operator|=
operator|new
name|int
index|[
name|targetCount
index|]
expr_stmt|;
name|this
operator|.
name|targets
operator|=
operator|new
name|int
index|[
name|sourceCount
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|sources
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|targets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**          * Creates a partial mapping from a list. For example,<code>          * PartialMapping({1, 2, 4}, 6)</code> creates the mapping          *          *<table border="1">          *<tr>          *<th>source</th>          *<td>0</td>          *<td>1</td>          *<td>2</td>          *<td>3</td>          *<td>4</td>          *<td>5</td>          *</tr>          *<tr>          *<th>target</th>          *<td>-1</td>          *<td>0</td>          *<td>1</td>          *<td>-1</td>          *<td>2</td>          *<td>-1</td>          *</tr>          *</table>          *          * @param sourceList List whose i'th element is the source of target #i          * @param sourceCount Number of elements in the source domain          * @param mappingType Mapping type, must be {@link          * org.eigenbase.util.mapping.MappingType#PartialSurjection} or          * stronger.          */
specifier|public
name|PartialMapping
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|sourceList
parameter_list|,
name|int
name|sourceCount
parameter_list|,
name|MappingType
name|mappingType
parameter_list|)
block|{
name|this
operator|.
name|mappingType
operator|=
name|mappingType
expr_stmt|;
assert|assert
name|mappingType
operator|.
name|isSingleSource
argument_list|()
assert|;
assert|assert
name|mappingType
operator|.
name|isSingleTarget
argument_list|()
assert|;
name|int
name|targetCount
init|=
name|sourceList
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|.
name|targets
operator|=
operator|new
name|int
index|[
name|sourceCount
index|]
expr_stmt|;
name|this
operator|.
name|sources
operator|=
operator|new
name|int
index|[
name|targetCount
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|sources
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|source
init|=
name|sourceList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sources
index|[
name|i
index|]
operator|=
name|source
expr_stmt|;
if|if
condition|(
name|source
operator|>=
literal|0
condition|)
block|{
name|targets
index|[
name|source
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|!
name|this
operator|.
name|mappingType
operator|.
name|isMandatorySource
argument_list|()
assert|;
block|}
block|}
block|}
specifier|private
name|PartialMapping
parameter_list|(
name|int
index|[]
name|sources
parameter_list|,
name|int
index|[]
name|targets
parameter_list|,
name|MappingType
name|mappingType
parameter_list|)
block|{
name|this
operator|.
name|sources
operator|=
name|sources
expr_stmt|;
name|this
operator|.
name|targets
operator|=
name|targets
expr_stmt|;
name|this
operator|.
name|mappingType
operator|=
name|mappingType
expr_stmt|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
return|return
name|mappingType
return|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
return|return
name|targets
operator|.
name|length
return|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
return|return
name|sources
operator|.
name|length
return|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
operator|new
name|PartialMapping
argument_list|(
name|targets
operator|.
name|clone
argument_list|()
argument_list|,
name|sources
operator|.
name|clone
argument_list|()
argument_list|,
name|mappingType
operator|.
name|inverse
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|MappingItr
argument_list|()
return|;
block|}
specifier|protected
name|boolean
name|isValid
parameter_list|()
block|{
name|assertPartialValid
argument_list|(
name|this
operator|.
name|sources
argument_list|,
name|this
operator|.
name|targets
argument_list|)
expr_stmt|;
name|assertPartialValid
argument_list|(
name|this
operator|.
name|targets
argument_list|,
name|this
operator|.
name|sources
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|void
name|assertPartialValid
parameter_list|(
name|int
index|[]
name|sources
parameter_list|,
name|int
index|[]
name|targets
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sources
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|source
init|=
name|sources
index|[
name|i
index|]
decl_stmt|;
assert|assert
name|source
operator|>=
operator|-
literal|1
assert|;
assert|assert
name|source
operator|<
name|targets
operator|.
name|length
assert|;
assert|assert
operator|(
name|source
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|targets
index|[
name|source
index|]
operator|==
name|i
operator|)
assert|;
block|}
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
assert|assert
name|isValid
argument_list|()
assert|;
specifier|final
name|int
name|prevTarget
init|=
name|targets
index|[
name|source
index|]
decl_stmt|;
name|targets
index|[
name|source
index|]
operator|=
name|target
expr_stmt|;
specifier|final
name|int
name|prevSource
init|=
name|sources
index|[
name|target
index|]
decl_stmt|;
name|sources
index|[
name|target
index|]
operator|=
name|source
expr_stmt|;
if|if
condition|(
name|prevTarget
operator|!=
operator|-
literal|1
condition|)
block|{
name|sources
index|[
name|prevTarget
index|]
operator|=
name|prevSource
expr_stmt|;
block|}
if|if
condition|(
name|prevSource
operator|!=
operator|-
literal|1
condition|)
block|{
name|targets
index|[
name|prevSource
index|]
operator|=
name|prevTarget
expr_stmt|;
block|}
assert|assert
name|isValid
argument_list|()
assert|;
block|}
specifier|public
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|sources
index|[
name|target
index|]
return|;
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|targets
index|[
name|source
index|]
return|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
name|int
name|target
init|=
name|getTargetOpt
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"source #"
operator|+
name|source
operator|+
literal|" has no target in mapping "
operator|+
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|target
return|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
if|if
condition|(
name|sources
operator|.
name|length
operator|!=
name|targets
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sources
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|source
init|=
name|sources
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|source
operator|!=
name|i
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
class|class
name|MappingItr
implements|implements
name|Iterator
argument_list|<
name|IntPair
argument_list|>
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|targets
operator|.
name|length
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
name|int
name|x
init|=
name|i
operator|++
decl_stmt|;
return|return
operator|new
name|IntPair
argument_list|(
name|x
argument_list|,
name|targets
index|[
name|x
index|]
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
block|}
comment|/**      * A surjection with inverse has precisely one source for each target.      * (Whereas a general surjection has at least one source for each target.)      * Every source has at most one target.      *      *<p>If you call {@link #set} on a target, the target's previous source      * will be lost.      */
specifier|static
class|class
name|SurjectionWithInverse
extends|extends
name|PartialMapping
block|{
name|SurjectionWithInverse
parameter_list|(
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|)
block|{
name|super
argument_list|(
name|sourceCount
argument_list|,
name|targetCount
argument_list|,
name|MappingType
operator|.
name|InverseSurjection
argument_list|)
expr_stmt|;
block|}
comment|/**          * Creates a mapping between a source and a target.          *          *<p>It is an error to map a target to a source which already has a          * target.          *          *<p>If you map a source to a target which already has a source, the          * old source becomes an orphan.          *          * @param source source          * @param target target          */
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
assert|assert
name|isValid
argument_list|()
assert|;
specifier|final
name|int
name|prevTarget
init|=
name|targets
index|[
name|source
index|]
decl_stmt|;
if|if
condition|(
name|prevTarget
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"source #"
operator|+
name|source
operator|+
literal|" is already mapped to target #"
operator|+
name|target
argument_list|)
throw|;
block|}
name|targets
index|[
name|source
index|]
operator|=
name|target
expr_stmt|;
specifier|final
name|int
name|prevSource
init|=
name|sources
index|[
name|target
index|]
decl_stmt|;
name|sources
index|[
name|target
index|]
operator|=
name|source
expr_stmt|;
name|sources
index|[
name|prevTarget
index|]
operator|=
name|prevSource
expr_stmt|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|sources
index|[
name|target
index|]
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|IdentityMapping
extends|extends
name|AbstractMapping
implements|implements
name|FunctionMapping
implements|,
name|TargetMapping
implements|,
name|SourceMapping
block|{
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
comment|/**          * Creates an identity mapping.          *          * @param size Size, or -1 if infinite.          */
specifier|public
name|IdentityMapping
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
name|this
return|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
return|return
name|MappingType
operator|.
name|Bijection
return|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
return|return
name|size
return|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
return|return
name|size
return|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|source
return|;
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|source
return|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|target
return|;
block|}
specifier|public
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|target
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|IntPair
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|(
name|size
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|<
name|size
operator|)
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
name|int
name|x
init|=
name|i
operator|++
decl_stmt|;
return|return
operator|new
name|IntPair
argument_list|(
name|x
argument_list|,
name|x
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|OverridingSourceMapping
extends|extends
name|AbstractMapping
implements|implements
name|SourceMapping
block|{
specifier|private
specifier|final
name|SourceMapping
name|parent
decl_stmt|;
specifier|private
specifier|final
name|int
name|source
decl_stmt|;
specifier|private
specifier|final
name|int
name|target
decl_stmt|;
specifier|public
name|OverridingSourceMapping
parameter_list|(
name|SourceMapping
name|parent
parameter_list|,
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
operator|new
name|OverridingTargetMapping
argument_list|(
operator|(
name|TargetMapping
operator|)
name|parent
operator|.
name|inverse
argument_list|()
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
return|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
comment|// FIXME: Mapping type might be weaker than parent.
return|return
name|parent
operator|.
name|getMappingType
argument_list|()
return|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|==
name|this
operator|.
name|target
condition|)
block|{
return|return
name|this
operator|.
name|source
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getSource
argument_list|(
name|target
argument_list|)
return|;
block|}
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
comment|// FIXME: It's possible that parent was not the identity but that
comment|// this overriding fixed it.
return|return
operator|(
name|source
operator|==
name|target
operator|)
operator|&&
name|parent
operator|.
name|isIdentity
argument_list|()
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
class|class
name|OverridingTargetMapping
extends|extends
name|AbstractMapping
implements|implements
name|TargetMapping
block|{
specifier|private
specifier|final
name|TargetMapping
name|parent
decl_stmt|;
specifier|private
specifier|final
name|int
name|target
decl_stmt|;
specifier|private
specifier|final
name|int
name|source
decl_stmt|;
specifier|public
name|OverridingTargetMapping
parameter_list|(
name|TargetMapping
name|parent
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|source
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|parent
operator|.
name|set
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
operator|new
name|OverridingSourceMapping
argument_list|(
name|parent
operator|.
name|inverse
argument_list|()
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
return|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
comment|// FIXME: Mapping type might be weaker than parent.
return|return
name|parent
operator|.
name|getMappingType
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
comment|// FIXME: Possible that parent is not identity but this overriding
comment|// fixes it.
return|return
operator|(
name|source
operator|==
name|target
operator|)
operator|&&
operator|(
operator|(
name|Mapping
operator|)
name|parent
operator|)
operator|.
name|isIdentity
argument_list|()
return|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|==
name|this
operator|.
name|source
condition|)
block|{
return|return
name|this
operator|.
name|target
return|;
block|}
else|else
block|{
return|return
name|parent
operator|.
name|getTarget
argument_list|(
name|source
argument_list|)
return|;
block|}
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
comment|/**      * Implementation of {@link Mapping} where a source can have at most one      * target, and a target can have any number of sources. The source count      * must be finite, but the target count may be infinite.      *      *<p>The implementation uses an array for the forward-mapping, but does not      * store the backward mapping.      */
specifier|private
specifier|static
class|class
name|PartialFunctionImpl
extends|extends
name|AbstractMapping
implements|implements
name|TargetMapping
block|{
specifier|private
specifier|final
name|int
name|sourceCount
decl_stmt|;
specifier|private
specifier|final
name|int
name|targetCount
decl_stmt|;
specifier|private
specifier|final
name|MappingType
name|mappingType
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|targets
decl_stmt|;
specifier|public
name|PartialFunctionImpl
parameter_list|(
name|int
name|sourceCount
parameter_list|,
name|int
name|targetCount
parameter_list|,
name|MappingType
name|mappingType
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|sourceCount
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Sources must be finite"
argument_list|)
throw|;
block|}
name|this
operator|.
name|sourceCount
operator|=
name|sourceCount
expr_stmt|;
name|this
operator|.
name|targetCount
operator|=
name|targetCount
expr_stmt|;
name|this
operator|.
name|mappingType
operator|=
name|mappingType
expr_stmt|;
if|if
condition|(
operator|!
name|mappingType
operator|.
name|isSingleTarget
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must have at most one target"
argument_list|)
throw|;
block|}
name|this
operator|.
name|targets
operator|=
operator|new
name|int
index|[
name|sourceCount
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|targets
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
return|return
name|sourceCount
return|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
return|return
name|targetCount
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|IntPair
argument_list|>
argument_list|()
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
block|{
name|advance
parameter_list|()
constructor_decl|;
block|}
specifier|private
name|void
name|advance
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|sourceCount
condition|)
block|{
break|break;
comment|// end
block|}
if|if
condition|(
name|targets
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
break|break;
comment|// found one
block|}
block|}
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|sourceCount
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
specifier|final
name|IntPair
name|pair
init|=
operator|new
name|IntPair
argument_list|(
name|i
argument_list|,
name|targets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|pair
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
return|return
name|mappingType
return|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
comment|// todo: implement
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
operator|(
name|target
operator|<
literal|0
operator|)
operator|&&
name|mappingType
operator|.
name|isMandatorySource
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Target is required"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|target
operator|>=
name|targetCount
operator|)
operator|&&
operator|(
name|targetCount
operator|>=
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Target must be less than "
operator|+
name|targetCount
argument_list|)
throw|;
block|}
name|targets
index|[
name|source
index|]
operator|=
name|target
expr_stmt|;
block|}
specifier|public
name|void
name|setAll
parameter_list|(
name|Mapping
name|mapping
parameter_list|)
block|{
for|for
control|(
name|IntPair
name|pair
range|:
name|mapping
control|)
block|{
name|set
argument_list|(
name|pair
operator|.
name|source
argument_list|,
name|pair
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|targets
index|[
name|source
index|]
return|;
block|}
block|}
comment|/**      * Decorator which converts any {@link Mapping} into the inverse of itself.      *      *<p>If the mapping does not have an inverse -- for example, if a given      * source can have more than one target -- then the corresponding method      * call of the underlying mapping will raise a runtime exception.      */
specifier|private
specifier|static
class|class
name|InverseMapping
implements|implements
name|Mapping
block|{
specifier|private
specifier|final
name|Mapping
name|parent
decl_stmt|;
name|InverseMapping
parameter_list|(
name|Mapping
name|parent
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
specifier|public
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|IntPair
argument_list|>
name|parentIter
init|=
name|parent
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|IntPair
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|parentIter
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|IntPair
name|next
parameter_list|()
block|{
name|IntPair
name|parentPair
init|=
name|parentIter
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|IntPair
argument_list|(
name|parentPair
operator|.
name|target
argument_list|,
name|parentPair
operator|.
name|source
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|parentIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
specifier|public
name|int
name|getSourceCount
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getTargetCount
argument_list|()
return|;
block|}
specifier|public
name|int
name|getTargetCount
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getSourceCount
argument_list|()
return|;
block|}
specifier|public
name|MappingType
name|getMappingType
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getMappingType
argument_list|()
operator|.
name|inverse
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isIdentity
parameter_list|()
block|{
return|return
name|parent
operator|.
name|isIdentity
argument_list|()
return|;
block|}
specifier|public
name|int
name|getTargetOpt
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|parent
operator|.
name|getSourceOpt
argument_list|(
name|source
argument_list|)
return|;
block|}
specifier|public
name|int
name|getTarget
parameter_list|(
name|int
name|source
parameter_list|)
block|{
return|return
name|parent
operator|.
name|getSource
argument_list|(
name|source
argument_list|)
return|;
block|}
specifier|public
name|int
name|getSource
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|parent
operator|.
name|getTarget
argument_list|(
name|target
argument_list|)
return|;
block|}
specifier|public
name|int
name|getSourceOpt
parameter_list|(
name|int
name|target
parameter_list|)
block|{
return|return
name|parent
operator|.
name|getTargetOpt
argument_list|(
name|target
argument_list|)
return|;
block|}
specifier|public
name|Mapping
name|inverse
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|int
name|source
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|parent
operator|.
name|set
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Mappings.java
end_comment

end_unit

