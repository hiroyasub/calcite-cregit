begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * PushAggregateThroughUnionRule implements the rule for pushing an  * {@link AggregateRel} past a non-distinct {@link UnionRel}.  */
end_comment

begin_class
specifier|public
class|class
name|PushAggregateThroughUnionRule
extends|extends
name|RelOptRule
block|{
specifier|public
specifier|static
specifier|final
name|PushAggregateThroughUnionRule
name|instance
init|=
operator|new
name|PushAggregateThroughUnionRule
argument_list|()
decl_stmt|;
comment|/**      * Private constructor.      */
specifier|private
name|PushAggregateThroughUnionRule
parameter_list|()
block|{
name|super
argument_list|(
name|some
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|UnionRel
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|AggregateRel
name|aggRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|UnionRel
name|unionRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|unionRel
operator|.
name|all
condition|)
block|{
comment|// This transformation is only valid for UNION ALL.
comment|// Consider t1(i) with rows (5), (5) and t2(i) with
comment|// rows (5), (10), and the query
comment|// select sum(i) from (select i from t1) union (select i from t2).
comment|// The correct answer is 15.  If we apply the transformation,
comment|// we get
comment|// select sum(i) from
comment|// (select sum(i) as i from t1) union (select sum(i) as i from t2)
comment|// which yields 25 (incorrect).
return|return;
block|}
name|RelOptCluster
name|cluster
init|=
name|unionRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
name|BitSet
name|groupByKeyMask
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggRel
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|groupByKeyMask
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|transformedAggCalls
init|=
name|transformAggCalls
argument_list|(
name|aggRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|aggRel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
argument_list|,
name|aggRel
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|transformedAggCalls
operator|==
literal|null
condition|)
block|{
comment|// we've detected the presence of something like AVG,
comment|// which we can't handle
return|return;
block|}
name|boolean
name|anyTransformed
init|=
literal|false
decl_stmt|;
comment|// create corresponding aggs on top of each union child
name|List
argument_list|<
name|RelNode
argument_list|>
name|newUnionInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|unionRel
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|boolean
name|alreadyUnique
init|=
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUnique
argument_list|(
name|input
argument_list|,
name|aggRel
operator|.
name|getGroupSet
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|alreadyUnique
condition|)
block|{
name|newUnionInputs
operator|.
name|add
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|anyTransformed
operator|=
literal|true
expr_stmt|;
name|newUnionInputs
operator|.
name|add
argument_list|(
operator|new
name|AggregateRel
argument_list|(
name|cluster
argument_list|,
name|input
argument_list|,
name|aggRel
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|aggRel
operator|.
name|getAggCallList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|anyTransformed
condition|)
block|{
comment|// none of the children could benefit from the pushdown,
comment|// so bail out (preventing the infinite loop to which most
comment|// planners would succumb)
return|return;
block|}
comment|// create a new union whose children are the aggs created above
name|UnionRel
name|newUnionRel
init|=
operator|new
name|UnionRel
argument_list|(
name|cluster
argument_list|,
name|newUnionInputs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|AggregateRel
name|newTopAggRel
init|=
operator|new
name|AggregateRel
argument_list|(
name|cluster
argument_list|,
name|newUnionRel
argument_list|,
name|aggRel
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|transformedAggCalls
argument_list|)
decl_stmt|;
comment|// In case we transformed any COUNT (which is always NOT NULL)
comment|// to SUM (which is always NULLABLE), cast back to keep the
comment|// planner happy.
name|RelNode
name|castRel
init|=
name|RelOptUtil
operator|.
name|createCastRel
argument_list|(
name|newTopAggRel
argument_list|,
name|aggRel
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|castRel
argument_list|)
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|transformAggCalls
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|int
name|nGroupCols
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|origCalls
parameter_list|)
block|{
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newCalls
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregateCall
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|iInput
init|=
name|nGroupCols
decl_stmt|;
for|for
control|(
name|AggregateCall
name|origCall
range|:
name|origCalls
control|)
block|{
if|if
condition|(
name|origCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|origCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"AVG"
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// TODO jvs 13-May-2009: don't assume we know how to handle
comment|// everything else.
name|Aggregation
name|aggFun
decl_stmt|;
name|RelDataType
name|aggType
decl_stmt|;
if|if
condition|(
name|origCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"COUNT"
argument_list|)
condition|)
block|{
name|aggType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|origCall
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|aggFun
operator|=
operator|new
name|SqlSumAggFunction
argument_list|(
name|aggType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aggFun
operator|=
name|origCall
operator|.
name|getAggregation
argument_list|()
expr_stmt|;
name|aggType
operator|=
name|origCall
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
name|AggregateCall
name|newCall
init|=
operator|new
name|AggregateCall
argument_list|(
name|aggFun
argument_list|,
name|origCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|iInput
argument_list|)
argument_list|,
name|aggType
argument_list|,
name|origCall
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|newCalls
operator|.
name|add
argument_list|(
name|newCall
argument_list|)
expr_stmt|;
operator|++
name|iInput
expr_stmt|;
block|}
return|return
name|newCalls
return|;
block|}
block|}
end_class

begin_comment
comment|// End PushAggregateThroughUnionRule.java
end_comment

end_unit

