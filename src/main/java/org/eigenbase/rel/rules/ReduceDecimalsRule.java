begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|resource
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * ReduceDecimalsRule is a rule which reduces decimal operations (such as casts  * or arithmetic) into operations involving more primitive types (such as longs  * and doubles). The rule allows eigenbase implementations to deal with decimals  * in a consistent manner, while saving the effort of implementing them.  *  *<p>The rule can be applied to a {@link CalcRel} with a program for which  * {@link RexUtil#requiresDecimalExpansion} returns true. The rule relies on a  * {@link RexShuttle} to walk over relational expressions and replace them.  *  *<p>While decimals are generally not implemented by the eigenbase runtime, the  * rule is optionally applied, in order to support the situation in which we  * would like to push down decimal operations to an external database.  */
end_comment

begin_class
specifier|public
class|class
name|ReduceDecimalsRule
extends|extends
name|RelOptRule
block|{
specifier|public
specifier|static
specifier|final
name|ReduceDecimalsRule
name|instance
init|=
operator|new
name|ReduceDecimalsRule
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**      * Creates a ReduceDecimalsRule.      */
specifier|private
name|ReduceDecimalsRule
parameter_list|()
block|{
name|super
argument_list|(
name|any
argument_list|(
name|CalcRel
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|// implement RelOptRule
specifier|public
name|Convention
name|getOutConvention
parameter_list|()
block|{
return|return
name|Convention
operator|.
name|NONE
return|;
block|}
comment|// implement RelOptRule
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|CalcRel
name|calcRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Expand decimals in every expression in this program. If no
comment|// expression changes, don't apply the rule.
specifier|final
name|RexProgram
name|program
init|=
name|calcRel
operator|.
name|getProgram
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|requiresDecimalExpansion
argument_list|(
name|program
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|calcRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexShuttle
name|shuttle
init|=
operator|new
name|DecimalShuttle
argument_list|(
name|rexBuilder
argument_list|)
decl_stmt|;
name|RexProgramBuilder
name|programBuilder
init|=
name|RexProgramBuilder
operator|.
name|create
argument_list|(
name|rexBuilder
argument_list|,
name|calcRel
operator|.
name|getChild
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|program
operator|.
name|getExprList
argument_list|()
argument_list|,
name|program
operator|.
name|getProjectList
argument_list|()
argument_list|,
name|program
operator|.
name|getCondition
argument_list|()
argument_list|,
name|program
operator|.
name|getOutputRowType
argument_list|()
argument_list|,
name|shuttle
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RexProgram
name|newProgram
init|=
name|programBuilder
operator|.
name|getProgram
argument_list|()
decl_stmt|;
name|CalcRel
name|newCalcRel
init|=
operator|new
name|CalcRel
argument_list|(
name|calcRel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|calcRel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|calcRel
operator|.
name|getChild
argument_list|()
argument_list|,
name|newProgram
operator|.
name|getOutputRowType
argument_list|()
argument_list|,
name|newProgram
argument_list|,
name|Collections
operator|.
expr|<
name|RelCollation
operator|>
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newCalcRel
argument_list|)
expr_stmt|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**      * A shuttle which converts decimal expressions to expressions based on      * longs.      */
specifier|public
class|class
name|DecimalShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|irreducible
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|results
decl_stmt|;
specifier|private
specifier|final
name|ExpanderMap
name|expanderMap
decl_stmt|;
specifier|public
name|DecimalShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|irreducible
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
argument_list|()
expr_stmt|;
name|results
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
argument_list|()
expr_stmt|;
name|expanderMap
operator|=
operator|new
name|ExpanderMap
argument_list|(
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
comment|/**          * Rewrites a call in place, from bottom up, as follows:          *          *<ol>          *<li>visit operands          *<li>visit call node          *          *<ol>          *<li>rewrite call          *<li>visit the rewritten call          *</ol>          *</ol>          */
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|RexNode
name|savedResult
init|=
name|lookup
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|savedResult
operator|!=
literal|null
condition|)
block|{
return|return
name|savedResult
return|;
block|}
comment|// permanently updates a call in place
name|apply
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
expr_stmt|;
name|RexNode
name|newCall
init|=
name|call
decl_stmt|;
name|RexNode
name|rewrite
init|=
name|rewriteCall
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrite
operator|!=
name|call
condition|)
block|{
name|newCall
operator|=
name|rewrite
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|register
argument_list|(
name|call
argument_list|,
name|newCall
argument_list|)
expr_stmt|;
return|return
name|newCall
return|;
block|}
comment|/**          * Registers node so it will not be computed again          */
specifier|private
name|void
name|register
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|RexNode
name|reducedNode
parameter_list|)
block|{
name|String
name|key
init|=
name|RexUtil
operator|.
name|makeKey
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|reducedNode
condition|)
block|{
name|irreducible
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|reducedNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|results
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|reducedNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Lookup registered node          */
specifier|private
name|RexNode
name|lookup
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
name|String
name|key
init|=
name|RexUtil
operator|.
name|makeKey
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|irreducible
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|results
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**          * Rewrites a call, if required, or returns the original call          */
specifier|private
name|RexNode
name|rewriteCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|operator
operator|.
name|requiresDecimalExpansion
argument_list|()
condition|)
block|{
return|return
name|call
return|;
block|}
name|RexExpander
name|expander
init|=
name|getExpander
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|expander
operator|.
name|canExpand
argument_list|(
name|call
argument_list|)
condition|)
block|{
return|return
name|expander
operator|.
name|expand
argument_list|(
name|call
argument_list|)
return|;
block|}
return|return
name|call
return|;
block|}
comment|/**          * Returns a {@link RexExpander} for a call          */
specifier|private
name|RexExpander
name|getExpander
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
return|return
name|expanderMap
operator|.
name|getExpander
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/**      * Maps a RexCall to a RexExpander      */
specifier|private
class|class
name|ExpanderMap
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlOperator
argument_list|,
name|RexExpander
argument_list|>
name|map
decl_stmt|;
specifier|private
name|RexExpander
name|defaultExpander
decl_stmt|;
specifier|private
name|ExpanderMap
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|SqlOperator
argument_list|,
name|RexExpander
argument_list|>
argument_list|()
expr_stmt|;
name|registerExpanders
argument_list|(
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|registerExpanders
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|RexExpander
name|cast
init|=
operator|new
name|CastExpander
argument_list|(
name|rexBuilder
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|castFunc
argument_list|,
name|cast
argument_list|)
expr_stmt|;
name|RexExpander
name|passThrough
init|=
operator|new
name|PassThroughExpander
argument_list|(
name|rexBuilder
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|prefixMinusOperator
argument_list|,
name|passThrough
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|absFunc
argument_list|,
name|passThrough
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNullOperator
argument_list|,
name|passThrough
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNotNullOperator
argument_list|,
name|passThrough
argument_list|)
expr_stmt|;
name|RexExpander
name|arithmetic
init|=
operator|new
name|BinaryArithmeticExpander
argument_list|(
name|rexBuilder
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|divideOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|multiplyOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|plusOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|minusOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|modFunc
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|equalsOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|lessThanOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|lessThanOrEqualOperator
argument_list|,
name|arithmetic
argument_list|)
expr_stmt|;
name|RexExpander
name|floor
init|=
operator|new
name|FloorExpander
argument_list|(
name|rexBuilder
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|floorFunc
argument_list|,
name|floor
argument_list|)
expr_stmt|;
name|RexExpander
name|ceil
init|=
operator|new
name|CeilExpander
argument_list|(
name|rexBuilder
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ceilFunc
argument_list|,
name|ceil
argument_list|)
expr_stmt|;
name|RexExpander
name|reinterpret
init|=
operator|new
name|ReinterpretExpander
argument_list|(
name|rexBuilder
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|reinterpretOperator
argument_list|,
name|reinterpret
argument_list|)
expr_stmt|;
name|RexExpander
name|caseExpander
init|=
operator|new
name|CaseExpander
argument_list|(
name|rexBuilder
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|caseExpander
argument_list|)
expr_stmt|;
name|defaultExpander
operator|=
operator|new
name|CastArgAsDoubleExpander
argument_list|(
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexExpander
name|getExpander
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|RexExpander
name|expander
init|=
name|map
operator|.
name|get
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|expander
operator|!=
literal|null
operator|)
condition|?
name|expander
else|:
name|defaultExpander
return|;
block|}
block|}
comment|/**      * Rewrites a decimal expression for a specific set of SqlOperator's. In      * general, most expressions are rewritten in such a way that SqlOperator's      * do not have to deal with decimals. Decimals are represented by their      * unscaled integer representations, similar to {@link      * BigDecimal#unscaledValue()} (i.e. 10^scale). Once decimals are decoded,      * SqlOperators can then operate on the integer representations. The value      * can later be recoded as a decimal.      *      *<p>For example, suppose one casts 2.0 as a decima(10,4). The value is      * decoded (20), multiplied by a scale factor (1000), for a result of      * (20000) which is encoded as a decimal(10,4), in this case 2.0000      *      *<p>To avoid the lengthy coding of RexNode expressions, this base class      * provides succinct methods for building expressions used in rewrites.      */
specifier|public
specifier|abstract
class|class
name|RexExpander
block|{
comment|/**          * Factory for constructing new relational expressions          */
name|RexBuilder
name|builder
decl_stmt|;
comment|/**          * Type for the internal representation of decimals. This type is a          * non-nullable type and requires extra work to make it nullable.          */
name|RelDataType
name|int8
decl_stmt|;
comment|/**          * Type for doubles. This type is a non-nullable type and requires extra          * work to make it nullable.          */
name|RelDataType
name|real8
decl_stmt|;
comment|/**          * Constructs a RexExpander          */
specifier|public
name|RexExpander
parameter_list|(
name|RexBuilder
name|builder
parameter_list|)
block|{
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
name|int8
operator|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
name|real8
operator|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
expr_stmt|;
block|}
comment|/**          * This defaults to the utility method, {@link          * RexUtil#requiresDecimalExpansion(RexNode, boolean)} which checks          * general guidelines on whether a rewrite should be considered at all.          * In general, it is helpful to update the utility method since that          * method is often used to filter the somewhat expensive rewrite          * process.          *          *<p>However, this method provides another place for implementations of          * RexExpander to make a more detailed analysis before deciding on          * whether to perform a rewrite.          */
specifier|public
name|boolean
name|canExpand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
return|return
name|RexUtil
operator|.
name|requiresDecimalExpansion
argument_list|(
name|call
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**          * Rewrites an expression containing decimals. Normally, this method          * always performs a rewrite, but implementations may choose to return          * the original expression if no change was required.          */
specifier|public
specifier|abstract
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
function_decl|;
comment|/**          * Makes an exact numeric literal to be used for scaling          *          * @param scale a scale from one to max precision - 1          *          * @return 10^scale as an exact numeric value          */
specifier|protected
name|RexNode
name|makeScaleFactor
parameter_list|(
name|int
name|scale
parameter_list|)
block|{
assert|assert
operator|(
name|scale
operator|>
literal|0
operator|)
operator|&&
operator|(
name|scale
operator|<
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
operator|)
assert|;
return|return
name|makeExactLiteral
argument_list|(
name|powerOfTen
argument_list|(
name|scale
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Makes an approximate literal to be used for scaling          *          * @param scale a scale from -99 to 99          *          * @return 10^scale as an approximate value          */
specifier|protected
name|RexNode
name|makeApproxScaleFactor
parameter_list|(
name|int
name|scale
parameter_list|)
block|{
assert|assert
operator|(
operator|(
operator|-
literal|100
operator|<
name|scale
operator|)
operator|&&
operator|(
name|scale
operator|<
literal|100
operator|)
operator|)
operator|:
literal|"could not make approximate scale factor"
assert|;
if|if
condition|(
name|scale
operator|>=
literal|0
condition|)
block|{
return|return
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scale
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|BigDecimal
name|tenth
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|makeApproxLiteral
argument_list|(
name|tenth
operator|.
name|pow
argument_list|(
operator|-
name|scale
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**          * Makes an exact numeric value to be used for rounding.          *          * @param scale a scale from 1 to max precision - 1          *          * @return 10^scale / 2 as an exact numeric value          */
specifier|protected
name|RexNode
name|makeRoundFactor
parameter_list|(
name|int
name|scale
parameter_list|)
block|{
assert|assert
operator|(
name|scale
operator|>
literal|0
operator|)
operator|&&
operator|(
name|scale
operator|<
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
operator|)
assert|;
return|return
name|makeExactLiteral
argument_list|(
name|powerOfTen
argument_list|(
name|scale
argument_list|)
operator|/
literal|2
argument_list|)
return|;
block|}
comment|/**          * Calculates a power of ten, as a long value          */
specifier|protected
name|long
name|powerOfTen
parameter_list|(
name|int
name|scale
parameter_list|)
block|{
assert|assert
operator|(
name|scale
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|scale
operator|<
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
operator|)
assert|;
return|return
name|BigInteger
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scale
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**          * Makes an exact, non-nullable literal of Bigint type          */
specifier|protected
name|RexNode
name|makeExactLiteral
parameter_list|(
name|long
name|l
parameter_list|)
block|{
name|BigDecimal
name|bd
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|l
argument_list|)
decl_stmt|;
return|return
name|builder
operator|.
name|makeExactLiteral
argument_list|(
name|bd
argument_list|,
name|int8
argument_list|)
return|;
block|}
comment|/**          * Makes an approximate literal of double precision          */
specifier|protected
name|RexNode
name|makeApproxLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeApproxLiteral
argument_list|(
name|bd
argument_list|)
return|;
block|}
comment|/**          * Scales up a decimal value and returns the scaled value as an exact          * number.          *          * @param value the integer representation of a decimal          * @param scale a value from zero to max precision - 1          *          * @return value * 10^scale as an exact numeric value          */
specifier|protected
name|RexNode
name|scaleUp
parameter_list|(
name|RexNode
name|value
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
assert|assert
operator|(
name|scale
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|scale
operator|<
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
operator|)
assert|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
return|return
name|value
return|;
block|}
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|multiplyOperator
argument_list|,
name|value
argument_list|,
name|makeScaleFactor
argument_list|(
name|scale
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Scales down a decimal value, and returns the scaled value as an exact          * numeric. with the rounding convention {@link BigDecimal#ROUND_HALF_UP          * BigDecimal.ROUND_HALF_UP}. (Values midway between two points are          * rounded away from zero.)          *          * @param value the integer representation of a decimal          * @param scale a value from zero to max precision          *          * @return value/10^scale, rounded away from zero and returned as an          * exact numeric value          */
specifier|protected
name|RexNode
name|scaleDown
parameter_list|(
name|RexNode
name|value
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|int
name|maxPrecision
init|=
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
decl_stmt|;
assert|assert
operator|(
name|scale
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|scale
operator|<=
name|maxPrecision
operator|)
assert|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
return|return
name|value
return|;
block|}
if|if
condition|(
name|scale
operator|==
name|maxPrecision
condition|)
block|{
name|long
name|half
init|=
name|BigInteger
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scale
operator|-
literal|1
argument_list|)
operator|.
name|longValue
argument_list|()
operator|*
literal|5
decl_stmt|;
return|return
name|makeCase
argument_list|(
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
argument_list|,
name|value
argument_list|,
name|makeExactLiteral
argument_list|(
name|half
argument_list|)
argument_list|)
argument_list|,
name|makeExactLiteral
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|lessThanOrEqualOperator
argument_list|,
name|value
argument_list|,
name|makeExactLiteral
argument_list|(
operator|-
name|half
argument_list|)
argument_list|)
argument_list|,
name|makeExactLiteral
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|makeExactLiteral
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
name|RexNode
name|roundFactor
init|=
name|makeRoundFactor
argument_list|(
name|scale
argument_list|)
decl_stmt|;
name|RexNode
name|roundValue
init|=
name|makeCase
argument_list|(
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOperator
argument_list|,
name|value
argument_list|,
name|makeExactLiteral
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|makePlus
argument_list|(
name|value
argument_list|,
name|roundFactor
argument_list|)
argument_list|,
name|makeMinus
argument_list|(
name|value
argument_list|,
name|roundFactor
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|makeDivide
argument_list|(
name|roundValue
argument_list|,
name|makeScaleFactor
argument_list|(
name|scale
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Scales down a decimal value and returns the scaled value as a an          * double precision approximate value. Scaling is implemented with          * double precision arithmetic.          *          * @param value the integer representation of a decimal          * @param scale a value from zero to {@link          * SqlTypeName#MAX_NUMERIC_PRECISION MAX_NUMERIC_PRECISION}          *          * @return value/10^scale as a double precision value          */
specifier|protected
name|RexNode
name|scaleDownDouble
parameter_list|(
name|RexNode
name|value
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
assert|assert
operator|(
name|scale
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|scale
operator|<=
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
operator|)
assert|;
name|RexNode
name|cast
init|=
name|ensureType
argument_list|(
name|real8
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
return|return
name|cast
return|;
block|}
return|return
name|makeDivide
argument_list|(
name|cast
argument_list|,
name|makeApproxScaleFactor
argument_list|(
name|scale
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Ensures a value is of a required scale. If it is not, then the value          * is multiplied by a scale factor. Scaling up an exact value is limited          * to max precision - 1, because we cannot represent the result of          * larger scales internally. Scaling up a floating point value is more          * flexible since the value may be very small despite having a scale of          * zero and the scaling may still produce a reasonable result          *          * @param value integer representation of decimal, or a floating point          * number          * @param scale current scale, 0 for floating point numbers          * @param required required scale, must be at least the current scale;          * the scale difference may not be greater than max precision - 1 for          * exact numerics          *          * @return value * 10^scale, returned as an exact or approximate value          * corresponding to the input value          */
specifier|protected
name|RexNode
name|ensureScale
parameter_list|(
name|RexNode
name|value
parameter_list|,
name|int
name|scale
parameter_list|,
name|int
name|required
parameter_list|)
block|{
name|int
name|maxPrecision
init|=
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
decl_stmt|;
assert|assert
operator|(
name|scale
operator|<=
name|maxPrecision
operator|)
operator|&&
operator|(
name|required
operator|<=
name|maxPrecision
operator|)
assert|;
assert|assert
name|required
operator|>=
name|scale
assert|;
if|if
condition|(
name|scale
operator|==
name|required
condition|)
block|{
return|return
name|value
return|;
block|}
name|int
name|scaleDiff
init|=
name|required
operator|-
name|scale
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|makeMultiply
argument_list|(
name|value
argument_list|,
name|makeApproxScaleFactor
argument_list|(
name|scaleDiff
argument_list|)
argument_list|)
return|;
block|}
comment|// TODO: make a validator exception for this
if|if
condition|(
name|scaleDiff
operator|>=
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"Source type with scale "
operator|+
name|scale
operator|+
literal|" cannot be converted to target type with scale "
operator|+
name|required
operator|+
literal|" because the smallest value of the "
operator|+
literal|"source type is too large to be encoded by the "
operator|+
literal|"target type"
argument_list|)
throw|;
block|}
return|return
name|scaleUp
argument_list|(
name|value
argument_list|,
name|scaleDiff
argument_list|)
return|;
block|}
comment|/**          * Retrieves a decimal node's integer representation          *          * @param decimalNode the decimal value as an opaque type          *          * @return an integer representation of the decimal value          */
specifier|protected
name|RexNode
name|decodeValue
parameter_list|(
name|RexNode
name|decimalNode
parameter_list|)
block|{
assert|assert
operator|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|decimalNode
operator|.
name|getType
argument_list|()
argument_list|)
operator|)
assert|;
return|return
name|builder
operator|.
name|decodeIntervalOrDecimal
argument_list|(
name|decimalNode
argument_list|)
return|;
block|}
comment|/**          * Retrieves the primitive value of a numeric node. If the node is a          * decimal, then it must first be decoded. Otherwise the original node          * may be returned.          *          * @param node a numeric node, possibly a decimal          *          * @return the primitive value of the numeric node          */
specifier|protected
name|RexNode
name|accessValue
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
assert|assert
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
assert|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|decodeValue
argument_list|(
name|node
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
comment|/**          * Casts a decimal's integer representation to a decimal node. If the          * expression is not the expected integer type, then it is casted first.          *          *<p>This method does not request an overflow check.          *          * @param value integer representation of decimal          * @param decimalType type integer will be reinterpreted as          *          * @return the integer representation reinterpreted as a decimal type          */
specifier|protected
name|RexNode
name|encodeValue
parameter_list|(
name|RexNode
name|value
parameter_list|,
name|RelDataType
name|decimalType
parameter_list|)
block|{
return|return
name|encodeValue
argument_list|(
name|value
argument_list|,
name|decimalType
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**          * Casts a decimal's integer representation to a decimal node. If the          * expression is not the expected integer type, then it is casted first.          *          *<p>An overflow check may be requested to ensure the internal value          * does not exceed the maximum value of the decimal type.          *          * @param value integer representation of decimal          * @param decimalType type integer will be reinterpreted as          * @param checkOverflow indicates whether an overflow check is required          * when reinterpreting this particular value as the decimal type. A          * check usually not required for arithmetic, but is often required for          * rounding and explicit casts.          *          * @return the integer reinterpreted as an opaque decimal type          */
specifier|protected
name|RexNode
name|encodeValue
parameter_list|(
name|RexNode
name|value
parameter_list|,
name|RelDataType
name|decimalType
parameter_list|,
name|boolean
name|checkOverflow
parameter_list|)
block|{
return|return
name|builder
operator|.
name|encodeIntervalOrDecimal
argument_list|(
name|value
argument_list|,
name|decimalType
argument_list|,
name|checkOverflow
argument_list|)
return|;
block|}
comment|/**          * Ensures expression is interpreted as a specified type. The returned          * expression may be wrapped with a cast.          *          *<p>This method corrects the nullability of the specified type to          * match the nullability of the expression.          *          * @param type desired type          * @param node expression          *          * @return a casted expression or the original expression          */
specifier|protected
name|RexNode
name|ensureType
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|ensureType
argument_list|(
name|type
argument_list|,
name|node
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**          * Ensures expression is interpreted as a specified type. The returned          * expression may be wrapped with a cast.          *          * @param type desired type          * @param node expression          * @param matchNullability whether to correct nullability of specified          * type to match the expression; this usually should be true, except for          * explicit casts which can override default nullability          *          * @return a casted expression or the original expression          */
specifier|protected
name|RexNode
name|ensureType
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|node
parameter_list|,
name|boolean
name|matchNullability
parameter_list|)
block|{
return|return
name|builder
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|node
argument_list|,
name|matchNullability
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|makeCase
parameter_list|(
name|RexNode
name|condition
parameter_list|,
name|RexNode
name|thenClause
parameter_list|,
name|RexNode
name|elseClause
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|condition
argument_list|,
name|thenClause
argument_list|,
name|elseClause
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|makeCase
parameter_list|(
name|RexNode
name|whenA
parameter_list|,
name|RexNode
name|thenA
parameter_list|,
name|RexNode
name|whenB
parameter_list|,
name|RexNode
name|thenB
parameter_list|,
name|RexNode
name|elseClause
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|whenA
argument_list|,
name|thenA
argument_list|,
name|whenB
argument_list|,
name|thenB
argument_list|,
name|elseClause
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|makePlus
parameter_list|(
name|RexNode
name|a
parameter_list|,
name|RexNode
name|b
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|plusOperator
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|makeMinus
parameter_list|(
name|RexNode
name|a
parameter_list|,
name|RexNode
name|b
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|minusOperator
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|makeDivide
parameter_list|(
name|RexNode
name|a
parameter_list|,
name|RexNode
name|b
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|divideIntegerOperator
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|makeMultiply
parameter_list|(
name|RexNode
name|a
parameter_list|,
name|RexNode
name|b
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|multiplyOperator
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|makeIsPositive
parameter_list|(
name|RexNode
name|a
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOperator
argument_list|,
name|a
argument_list|,
name|makeExactLiteral
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|makeIsNegative
parameter_list|(
name|RexNode
name|a
parameter_list|)
block|{
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|lessThanOperator
argument_list|,
name|a
argument_list|,
name|makeExactLiteral
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Expands a decimal cast expression      */
specifier|private
class|class
name|CastExpander
extends|extends
name|RexExpander
block|{
specifier|private
name|CastExpander
parameter_list|(
name|RexBuilder
name|builder
parameter_list|)
block|{
name|super
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
comment|// implement RexExpander
specifier|public
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|operands
decl_stmt|;
assert|assert
name|call
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Cast
argument_list|)
assert|;
assert|assert
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
assert|assert
operator|!
name|RexLiteral
operator|.
name|isNullLiteral
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
assert|;
name|RexNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|clone
argument_list|()
decl_stmt|;
name|RelDataType
name|fromType
init|=
name|operand
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|toType
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|fromType
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|toType
argument_list|)
operator|)
assert|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isIntType
argument_list|(
name|toType
argument_list|)
condition|)
block|{
comment|// decimal to int
return|return
name|ensureType
argument_list|(
name|toType
argument_list|,
name|scaleDown
argument_list|(
name|decodeValue
argument_list|(
name|operand
argument_list|)
argument_list|,
name|fromType
operator|.
name|getScale
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|toType
argument_list|)
condition|)
block|{
comment|// decimal to floating point
return|return
name|ensureType
argument_list|(
name|toType
argument_list|,
name|scaleDownDouble
argument_list|(
name|decodeValue
argument_list|(
name|operand
argument_list|)
argument_list|,
name|fromType
operator|.
name|getScale
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|fromType
argument_list|)
condition|)
block|{
comment|// real to decimal
return|return
name|encodeValue
argument_list|(
name|ensureScale
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|,
name|toType
operator|.
name|getScale
argument_list|()
argument_list|)
argument_list|,
name|toType
argument_list|,
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|fromType
argument_list|)
operator|||
operator|!
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|toType
argument_list|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"Cast from '"
operator|+
name|fromType
operator|.
name|toString
argument_list|()
operator|+
literal|"' to '"
operator|+
name|toType
operator|.
name|toString
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|int
name|fromScale
init|=
name|fromType
operator|.
name|getScale
argument_list|()
decl_stmt|;
name|int
name|toScale
init|=
name|toType
operator|.
name|getScale
argument_list|()
decl_stmt|;
name|int
name|fromDigits
init|=
name|fromType
operator|.
name|getPrecision
argument_list|()
operator|-
name|fromScale
decl_stmt|;
name|int
name|toDigits
init|=
name|toType
operator|.
name|getPrecision
argument_list|()
operator|-
name|toScale
decl_stmt|;
comment|// NOTE: precision 19 overflows when its underlying
comment|// bigint representation overflows
name|boolean
name|checkOverflow
init|=
operator|(
name|toType
operator|.
name|getPrecision
argument_list|()
operator|<
literal|19
operator|)
operator|&&
operator|(
name|toDigits
operator|<
name|fromDigits
operator|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isIntType
argument_list|(
name|fromType
argument_list|)
condition|)
block|{
comment|// int to decimal
return|return
name|encodeValue
argument_list|(
name|ensureScale
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|,
name|toType
operator|.
name|getScale
argument_list|()
argument_list|)
argument_list|,
name|toType
argument_list|,
name|checkOverflow
argument_list|)
return|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|fromType
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|toType
argument_list|)
condition|)
block|{
comment|// decimal to decimal
name|RexNode
name|value
init|=
name|decodeValue
argument_list|(
name|operand
argument_list|)
decl_stmt|;
name|RexNode
name|scaled
decl_stmt|;
if|if
condition|(
name|fromScale
operator|<=
name|toScale
condition|)
block|{
name|scaled
operator|=
name|ensureScale
argument_list|(
name|value
argument_list|,
name|fromScale
argument_list|,
name|toScale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|toDigits
operator|==
name|fromDigits
operator|)
operator|&&
operator|(
name|toScale
operator|<
name|fromScale
operator|)
condition|)
block|{
comment|// rounding away from zero may cause an overflow
comment|// for example: cast(9.99 as decimal(2,1))
name|checkOverflow
operator|=
literal|true
expr_stmt|;
block|}
name|scaled
operator|=
name|scaleDown
argument_list|(
name|value
argument_list|,
name|fromScale
operator|-
name|toScale
argument_list|)
expr_stmt|;
block|}
return|return
name|encodeValue
argument_list|(
name|scaled
argument_list|,
name|toType
argument_list|,
name|checkOverflow
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"Reduce decimal cast from "
operator|+
name|fromType
operator|+
literal|" to "
operator|+
name|toType
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Expands a decimal arithmetic expression      */
specifier|private
class|class
name|BinaryArithmeticExpander
extends|extends
name|RexExpander
block|{
name|RelDataType
name|typeA
decl_stmt|,
name|typeB
decl_stmt|;
name|int
name|scaleA
decl_stmt|,
name|scaleB
decl_stmt|;
specifier|private
name|BinaryArithmeticExpander
parameter_list|(
name|RexBuilder
name|builder
parameter_list|)
block|{
name|super
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
comment|// implement RexExpander
specifier|public
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|operands
decl_stmt|;
assert|assert
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
name|RelDataType
name|typeA
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|typeB
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|typeA
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|typeB
argument_list|)
operator|)
assert|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|typeA
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|typeB
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|newOperands
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isApproximateNumeric
argument_list|(
name|typeA
argument_list|)
condition|)
block|{
name|newOperands
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ensureType
argument_list|(
name|real8
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newOperands
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|ensureType
argument_list|(
name|real8
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|newOperands
argument_list|)
return|;
block|}
name|analyzeOperands
argument_list|(
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Plus
argument_list|)
condition|)
block|{
return|return
name|expandPlusMinus
argument_list|(
name|call
argument_list|,
name|operands
argument_list|)
return|;
block|}
if|else if
condition|(
name|call
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Minus
argument_list|)
condition|)
block|{
return|return
name|expandPlusMinus
argument_list|(
name|call
argument_list|,
name|operands
argument_list|)
return|;
block|}
if|else if
condition|(
name|call
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Divide
argument_list|)
condition|)
block|{
return|return
name|expandDivide
argument_list|(
name|call
argument_list|,
name|operands
argument_list|)
return|;
block|}
if|else if
condition|(
name|call
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Times
argument_list|)
condition|)
block|{
return|return
name|expandTimes
argument_list|(
name|call
argument_list|,
name|operands
argument_list|)
return|;
block|}
if|else if
condition|(
name|call
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Comparison
argument_list|)
condition|)
block|{
return|return
name|expandComparison
argument_list|(
name|call
argument_list|,
name|operands
argument_list|)
return|;
block|}
if|else if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|modFunc
condition|)
block|{
return|return
name|expandMod
argument_list|(
name|call
argument_list|,
name|operands
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"ReduceDecimalsRule could not expand "
operator|+
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**          * Convenience method for reading characteristics of operands (such as          * scale, precision, whole digits) into an ArithmeticExpander. The          * operands are restricted by the following contraints:          *          *<ul>          *<li>there are exactly two operands          *<li>both are exact numeric types          *</ul>          */
specifier|private
name|void
name|analyzeOperands
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
assert|assert
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
name|typeA
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
name|typeB
operator|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|typeA
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|typeB
argument_list|)
operator|)
assert|;
name|scaleA
operator|=
name|typeA
operator|.
name|getScale
argument_list|()
expr_stmt|;
name|scaleB
operator|=
name|typeB
operator|.
name|getScale
argument_list|()
expr_stmt|;
block|}
specifier|private
name|RexNode
name|expandPlusMinus
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
name|RelDataType
name|outType
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
name|int
name|outScale
init|=
name|outType
operator|.
name|getScale
argument_list|()
decl_stmt|;
return|return
name|encodeValue
argument_list|(
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|ensureScale
argument_list|(
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|scaleA
argument_list|,
name|outScale
argument_list|)
argument_list|,
name|ensureScale
argument_list|(
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|scaleB
argument_list|,
name|outScale
argument_list|)
argument_list|)
argument_list|,
name|outType
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|expandDivide
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
name|RelDataType
name|outType
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexNode
name|dividend
init|=
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|ensureType
argument_list|(
name|real8
argument_list|,
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ensureType
argument_list|(
name|real8
argument_list|,
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|scaleDifference
init|=
name|outType
operator|.
name|getScale
argument_list|()
operator|-
name|scaleA
operator|+
name|scaleB
decl_stmt|;
name|RexNode
name|rescale
init|=
name|builder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|multiplyOperator
argument_list|,
name|dividend
argument_list|,
name|makeApproxScaleFactor
argument_list|(
name|scaleDifference
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|encodeValue
argument_list|(
name|rescale
argument_list|,
name|outType
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|expandTimes
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
comment|// Multiplying the internal values of the two arguments leads to
comment|// a number with scale = scaleA + scaleB. If the result type has
comment|// a lower scale, then the number should be scaled down.
name|int
name|divisor
init|=
name|scaleA
operator|+
name|scaleB
operator|-
name|call
operator|.
name|getType
argument_list|()
operator|.
name|getScale
argument_list|()
decl_stmt|;
if|if
condition|(
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|useDoubleMultiplication
argument_list|(
name|typeA
argument_list|,
name|typeB
argument_list|)
condition|)
block|{
comment|// Approximate implementation:
comment|// cast (a as double) * cast (b as double)
comment|//     / 10^divisor
name|RexNode
name|division
init|=
name|makeDivide
argument_list|(
name|makeMultiply
argument_list|(
name|ensureType
argument_list|(
name|real8
argument_list|,
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ensureType
argument_list|(
name|real8
argument_list|,
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|divisor
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|encodeValue
argument_list|(
name|division
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
comment|// Exact implementation: scaleDown(a * b)
return|return
name|encodeValue
argument_list|(
name|scaleDown
argument_list|(
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|RexNode
name|expandComparison
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
name|int
name|commonScale
init|=
name|Math
operator|.
name|max
argument_list|(
name|scaleA
argument_list|,
name|scaleB
argument_list|)
decl_stmt|;
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|ensureScale
argument_list|(
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|scaleA
argument_list|,
name|commonScale
argument_list|)
argument_list|,
name|ensureScale
argument_list|(
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|scaleB
argument_list|,
name|commonScale
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|expandMod
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
assert|assert
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|typeA
argument_list|)
assert|;
assert|assert
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|typeB
argument_list|)
assert|;
if|if
condition|(
operator|(
name|scaleA
operator|!=
literal|0
operator|)
operator|||
operator|(
name|scaleB
operator|!=
literal|0
operator|)
condition|)
block|{
throw|throw
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|ArgumentMustHaveScaleZero
operator|.
name|ex
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|RexNode
name|result
init|=
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|accessValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RelDataType
name|retType
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|retType
argument_list|)
condition|)
block|{
return|return
name|encodeValue
argument_list|(
name|result
argument_list|,
name|retType
argument_list|)
return|;
block|}
return|return
name|ensureType
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
comment|/**      * Expander that rewrites floor(decimal) expressions:      *      *<pre>      * if (value< 0)      *     (value-0.99...)/(10^scale)      * else      *     value/(10^scale)      *</pre>      */
specifier|private
class|class
name|FloorExpander
extends|extends
name|RexExpander
block|{
specifier|private
name|FloorExpander
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|super
argument_list|(
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|floorFunc
assert|;
name|RexNode
name|decValue
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|scale
init|=
name|decValue
operator|.
name|getType
argument_list|()
operator|.
name|getScale
argument_list|()
decl_stmt|;
name|RexNode
name|value
init|=
name|decodeValue
argument_list|(
name|decValue
argument_list|)
decl_stmt|;
name|RexNode
name|rewrite
decl_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
name|rewrite
operator|=
name|decValue
expr_stmt|;
block|}
if|else if
condition|(
name|scale
operator|==
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
condition|)
block|{
name|rewrite
operator|=
name|makeCase
argument_list|(
name|makeIsNegative
argument_list|(
name|value
argument_list|)
argument_list|,
name|makeExactLiteral
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|makeExactLiteral
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RexNode
name|round
init|=
name|makeExactLiteral
argument_list|(
literal|1
operator|-
name|powerOfTen
argument_list|(
name|scale
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|scaleFactor
init|=
name|makeScaleFactor
argument_list|(
name|scale
argument_list|)
decl_stmt|;
name|rewrite
operator|=
name|makeCase
argument_list|(
name|makeIsNegative
argument_list|(
name|value
argument_list|)
argument_list|,
name|makeDivide
argument_list|(
name|makePlus
argument_list|(
name|value
argument_list|,
name|round
argument_list|)
argument_list|,
name|scaleFactor
argument_list|)
argument_list|,
name|makeDivide
argument_list|(
name|value
argument_list|,
name|scaleFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|encodeValue
argument_list|(
name|rewrite
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      * Expander that rewrites ceiling(decimal) expressions:      *      *<pre>      * if (value> 0)      *     (value+0.99...)/(10^scale)      * else      *     value/(10^scale)      *</pre>      */
specifier|private
class|class
name|CeilExpander
extends|extends
name|RexExpander
block|{
specifier|private
name|CeilExpander
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|super
argument_list|(
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|ceilFunc
assert|;
name|RexNode
name|decValue
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|scale
init|=
name|decValue
operator|.
name|getType
argument_list|()
operator|.
name|getScale
argument_list|()
decl_stmt|;
name|RexNode
name|value
init|=
name|decodeValue
argument_list|(
name|decValue
argument_list|)
decl_stmt|;
name|RexNode
name|rewrite
decl_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
name|rewrite
operator|=
name|decValue
expr_stmt|;
block|}
if|else if
condition|(
name|scale
operator|==
name|SqlTypeName
operator|.
name|MAX_NUMERIC_PRECISION
condition|)
block|{
name|rewrite
operator|=
name|makeCase
argument_list|(
name|makeIsPositive
argument_list|(
name|value
argument_list|)
argument_list|,
name|makeExactLiteral
argument_list|(
literal|1
argument_list|)
argument_list|,
name|makeExactLiteral
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RexNode
name|round
init|=
name|makeExactLiteral
argument_list|(
name|powerOfTen
argument_list|(
name|scale
argument_list|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|RexNode
name|scaleFactor
init|=
name|makeScaleFactor
argument_list|(
name|scale
argument_list|)
decl_stmt|;
name|rewrite
operator|=
name|makeCase
argument_list|(
name|makeIsPositive
argument_list|(
name|value
argument_list|)
argument_list|,
name|makeDivide
argument_list|(
name|makePlus
argument_list|(
name|value
argument_list|,
name|round
argument_list|)
argument_list|,
name|scaleFactor
argument_list|)
argument_list|,
name|makeDivide
argument_list|(
name|value
argument_list|,
name|scaleFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|encodeValue
argument_list|(
name|rewrite
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      * Expander that rewrites case expressions, in place. Starting from:      *      *<pre>(when $cond then $val)+ else $default</pre>      *      * this expander casts all values to the return type. If the target type is      * a decimal, then the values are then decoded. The result of expansion is      * that the case operator no longer deals with decimals args. (The return      * value is encoded if necessary.)      *      *<p>Note: a decimal type is returned iff arguments have decimals      */
specifier|private
class|class
name|CaseExpander
extends|extends
name|RexExpander
block|{
specifier|private
name|CaseExpander
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|super
argument_list|(
name|rexBuilder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|RelDataType
name|retType
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
name|int
name|argCount
init|=
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|opBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argCount
condition|;
name|i
operator|++
control|)
block|{
comment|// skip case conditions
if|if
condition|(
operator|(
operator|(
name|i
operator|%
literal|2
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|!=
operator|(
name|argCount
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|opBuilder
operator|.
name|add
argument_list|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RexNode
name|expr
init|=
name|ensureType
argument_list|(
name|retType
argument_list|,
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|retType
argument_list|)
condition|)
block|{
name|expr
operator|=
name|decodeValue
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|opBuilder
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|newCall
init|=
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|opBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|retType
argument_list|)
condition|)
block|{
name|newCall
operator|=
name|encodeValue
argument_list|(
name|newCall
argument_list|,
name|retType
argument_list|)
expr_stmt|;
block|}
return|return
name|newCall
return|;
block|}
block|}
comment|/**      * An expander that substitutes decimals with their integer representations.      * If the output is decimal, the output is reinterpreted from the integer      * representation into a decimal.      */
specifier|private
class|class
name|PassThroughExpander
extends|extends
name|RexExpander
block|{
specifier|private
name|PassThroughExpander
parameter_list|(
name|RexBuilder
name|builder
parameter_list|)
block|{
name|super
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|canExpand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
return|return
name|RexUtil
operator|.
name|requiresDecimalExpansion
argument_list|(
name|call
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|operands
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|opBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|operands
control|)
block|{
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isNumeric
argument_list|(
name|operand
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|opBuilder
operator|.
name|add
argument_list|(
name|accessValue
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opBuilder
operator|.
name|add
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
name|RexNode
name|newCall
init|=
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|opBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|encodeValue
argument_list|(
name|newCall
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|newCall
return|;
block|}
block|}
block|}
comment|/**      * An expander which casts decimal arguments as doubles      */
specifier|private
class|class
name|CastArgAsDoubleExpander
extends|extends
name|CastArgAsTypeExpander
block|{
specifier|private
name|CastArgAsDoubleExpander
parameter_list|(
name|RexBuilder
name|builder
parameter_list|)
block|{
name|super
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelDataType
name|getArgType
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|real8
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|type
operator|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
block|}
comment|/**      * An expander which casts decimal arguments as another type      */
specifier|private
specifier|abstract
class|class
name|CastArgAsTypeExpander
extends|extends
name|RexExpander
block|{
specifier|private
name|CastArgAsTypeExpander
parameter_list|(
name|RexBuilder
name|builder
parameter_list|)
block|{
name|super
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|RelDataType
name|getArgType
parameter_list|(
name|RexCall
name|call
parameter_list|,
name|int
name|ordinal
parameter_list|)
function_decl|;
specifier|public
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|operands
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|opBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|operand
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|operands
argument_list|)
control|)
block|{
name|RelDataType
name|targetType
init|=
name|getArgType
argument_list|(
name|call
argument_list|,
name|operand
operator|.
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|operand
operator|.
name|e
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|opBuilder
operator|.
name|add
argument_list|(
name|ensureType
argument_list|(
name|targetType
argument_list|,
name|operand
operator|.
name|e
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opBuilder
operator|.
name|add
argument_list|(
name|operand
operator|.
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|RexNode
name|ret
init|=
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|opBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|=
name|ensureType
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|ret
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
comment|/**      * This expander simplifies reinterpret calls. Consider (1.0+1)*1. The inner      * operation encodes a decimal (Reinterpret(...)) which the outer operation      * immediately decodes: (Reinterpret(Reinterpret(...))). Arithmetic overflow      * is handled by underlying integer operations, so we don't have to consider      * it. Simply remove the nested Reinterpret.      */
specifier|private
class|class
name|ReinterpretExpander
extends|extends
name|RexExpander
block|{
specifier|private
name|ReinterpretExpander
parameter_list|(
name|RexBuilder
name|builder
parameter_list|)
block|{
name|super
argument_list|(
name|builder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|canExpand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
return|return
name|call
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Reinterpret
argument_list|)
operator|&&
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|Reinterpret
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|expand
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|operands
decl_stmt|;
name|RexCall
name|subCall
init|=
operator|(
name|RexCall
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|innerValue
init|=
name|subCall
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|canSimplify
argument_list|(
name|call
argument_list|,
name|subCall
argument_list|,
name|innerValue
argument_list|)
condition|)
block|{
return|return
name|innerValue
operator|.
name|clone
argument_list|()
return|;
block|}
return|return
name|call
return|;
block|}
comment|/**          * Detect, in a generic, but strict way, whether it is possible to          * simplify a reinterpret cast. The rules are as follows:          *          *<ol>          *<li>If value is not the same basic type as outer, then we cannot          * simplify          *<li>If the value is nullable but the inner or outer are not, then we          * cannot simplify.          *<li>If inner is nullable but outer is not, we cannot simplify.          *<li>If an overflow check is required from either inner or outer, we          * cannot simplify.          *<li>Otherwise, given the same type, and sufficient nullability          * constraints, we can simplify.          *</ol>          *          * @param outer outer call to reinterpret          * @param inner inner call to reinterpret          * @param value inner value          *          * @return whether the two reinterpret casts can be removed          */
specifier|private
name|boolean
name|canSimplify
parameter_list|(
name|RexCall
name|outer
parameter_list|,
name|RexCall
name|inner
parameter_list|,
name|RexNode
name|value
parameter_list|)
block|{
name|RelDataType
name|outerType
init|=
name|outer
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|innerType
init|=
name|inner
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|valueType
init|=
name|value
operator|.
name|getType
argument_list|()
decl_stmt|;
name|boolean
name|outerCheck
init|=
name|RexUtil
operator|.
name|canReinterpretOverflow
argument_list|(
name|outer
argument_list|)
decl_stmt|;
name|boolean
name|innerCheck
init|=
name|RexUtil
operator|.
name|canReinterpretOverflow
argument_list|(
name|inner
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|outerType
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|valueType
operator|.
name|getSqlTypeName
argument_list|()
operator|)
operator|||
operator|(
name|outerType
operator|.
name|getPrecision
argument_list|()
operator|!=
name|valueType
operator|.
name|getPrecision
argument_list|()
operator|)
operator|||
operator|(
name|outerType
operator|.
name|getScale
argument_list|()
operator|!=
name|valueType
operator|.
name|getScale
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|valueType
operator|.
name|isNullable
argument_list|()
operator|&&
operator|(
operator|!
name|innerType
operator|.
name|isNullable
argument_list|()
operator|||
operator|!
name|outerType
operator|.
name|isNullable
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|innerType
operator|.
name|isNullable
argument_list|()
operator|&&
operator|!
name|outerType
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// One would think that we could go from Nullable -> Not Nullable
comment|// since we are substituting a general type with a more specific
comment|// type. However the optimizer doesn't like it.
if|if
condition|(
name|valueType
operator|.
name|isNullable
argument_list|()
operator|!=
name|outerType
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|innerCheck
operator|||
name|outerCheck
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End ReduceDecimalsRule.java
end_comment

end_unit

