begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_comment
comment|/**  *<code>ProjectRelBase</code> is an abstract base class for implementations of  * {@link ProjectRel}.  *  * @version $Id$  * @author jhyde  * @since March, 2004  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|ProjectRelBase
extends|extends
name|SingleRel
block|{
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
name|RexNode
index|[]
name|exps
decl_stmt|;
comment|/**      * Values defined in {@link Flags}.      */
specifier|protected
name|int
name|flags
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RelCollation
argument_list|>
name|collationList
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**      * Creates a Project.      *      * @param cluster Cluster this relational expression belongs to      * @param traits traits of this rel      * @param child input relational expression      * @param exps set of expressions for the input columns      * @param rowType output row type      * @param flags values as in {@link Flags}      * @param collationList List of sort keys      */
specifier|protected
name|ProjectRelBase
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|,
name|RelNode
name|child
parameter_list|,
name|RexNode
index|[]
name|exps
parameter_list|,
name|RelDataType
name|rowType
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|final
name|List
argument_list|<
name|RelCollation
argument_list|>
name|collationList
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|traits
argument_list|,
name|child
argument_list|)
expr_stmt|;
assert|assert
name|rowType
operator|!=
literal|null
assert|;
assert|assert
name|collationList
operator|!=
literal|null
assert|;
name|this
operator|.
name|exps
operator|=
name|exps
expr_stmt|;
name|this
operator|.
name|rowType
operator|=
name|rowType
expr_stmt|;
name|this
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|this
operator|.
name|collationList
operator|=
name|collationList
operator|.
name|isEmpty
argument_list|()
condition|?
name|Collections
operator|.
expr|<
name|RelCollation
operator|>
name|emptyList
argument_list|()
else|:
name|collationList
expr_stmt|;
assert|assert
name|isValid
argument_list|(
literal|true
argument_list|)
assert|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|List
argument_list|<
name|RelCollation
argument_list|>
name|getCollationList
parameter_list|()
block|{
return|return
name|collationList
return|;
block|}
specifier|public
name|boolean
name|isBoxed
parameter_list|()
block|{
return|return
operator|(
name|flags
operator|&
name|Flags
operator|.
name|Boxed
operator|)
operator|==
name|Flags
operator|.
name|Boxed
return|;
block|}
comment|// override AbstractRelNode
specifier|public
name|RexNode
index|[]
name|getChildExps
parameter_list|()
block|{
return|return
name|getProjectExps
argument_list|()
return|;
block|}
comment|/**      * Returns the project expressions.      */
specifier|public
name|RexNode
index|[]
name|getProjectExps
parameter_list|()
block|{
return|return
name|exps
return|;
block|}
specifier|public
name|int
name|getFlags
parameter_list|()
block|{
return|return
name|flags
return|;
block|}
specifier|public
name|boolean
name|isValid
parameter_list|(
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
operator|!
name|super
operator|.
name|isValid
argument_list|(
name|fail
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|compatibleTypes
argument_list|(
name|exps
argument_list|,
name|getRowType
argument_list|()
argument_list|,
literal|true
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
name|RexChecker
name|checker
init|=
operator|new
name|RexChecker
argument_list|(
name|getChild
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|fail
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|exp
range|:
name|exps
control|)
block|{
name|exp
operator|.
name|accept
argument_list|(
name|checker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checker
operator|.
name|getFailureCount
argument_list|()
operator|>
literal|0
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|isBoxed
argument_list|()
condition|)
block|{
if|if
condition|(
name|exps
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|collationList
operator|==
literal|null
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|RelOptCost
name|computeSelfCost
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|double
name|dRows
init|=
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|getChild
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|dCpu
init|=
name|dRows
operator|*
name|exps
operator|.
name|length
decl_stmt|;
name|double
name|dIo
init|=
literal|0
decl_stmt|;
return|return
name|planner
operator|.
name|makeCost
argument_list|(
name|dRows
argument_list|,
name|dCpu
argument_list|,
name|dIo
argument_list|)
return|;
block|}
specifier|public
name|RelOptPlanWriter
name|explainTerms
parameter_list|(
name|RelOptPlanWriter
name|pw
parameter_list|)
block|{
name|super
operator|.
name|explainTerms
argument_list|(
name|pw
argument_list|)
expr_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RelDataTypeField
argument_list|>
name|field
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|rowType
operator|.
name|getFields
argument_list|()
argument_list|)
control|)
block|{
name|String
name|fieldName
init|=
name|field
operator|.
name|e
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
block|{
name|fieldName
operator|=
literal|"field#"
operator|+
name|field
operator|.
name|i
expr_stmt|;
block|}
name|pw
operator|.
name|item
argument_list|(
name|fieldName
argument_list|,
name|exps
index|[
name|field
operator|.
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// If we're generating a digest, include the rowtype. If two projects
comment|// differ in return type, we don't want to regard them as equivalent,
comment|// otherwise we will try to put rels of different types into the same
comment|// planner equivalence set.
if|if
condition|(
operator|(
name|pw
operator|.
name|getDetailLevel
argument_list|()
operator|==
name|SqlExplainLevel
operator|.
name|DIGEST_ATTRIBUTES
operator|)
operator|&&
literal|false
condition|)
block|{
name|pw
operator|.
name|item
argument_list|(
literal|"type"
argument_list|,
name|rowType
argument_list|)
expr_stmt|;
block|}
return|return
name|pw
return|;
block|}
comment|/**      * Burrows into a synthetic record and returns the underlying relation which      * provides the field called<code>fieldName</code>.      */
specifier|public
name|JavaRel
name|implementFieldAccess
parameter_list|(
name|JavaRelImplementor
name|implementor
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isBoxed
argument_list|()
condition|)
block|{
return|return
name|implementor
operator|.
name|implementFieldAccess
argument_list|(
operator|(
name|JavaRel
operator|)
name|getChild
argument_list|()
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
name|RelDataType
name|type
init|=
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|field
init|=
name|type
operator|.
name|getFieldOrdinal
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|implementor
operator|.
name|findRel
argument_list|(
operator|(
name|JavaRel
operator|)
name|this
argument_list|,
name|exps
index|[
name|field
index|]
argument_list|)
return|;
block|}
comment|//~ Inner Interfaces -------------------------------------------------------
specifier|public
interface|interface
name|Flags
block|{
name|int
name|AnonFields
init|=
literal|2
decl_stmt|;
comment|/**          * Whether the resulting row is to be a synthetic class whose fields are          * the aliases of the fields.<code>boxed</code> must be true unless          * there is only one field:<code>select {dept.deptno} from dept</code>          * is boxed,<code>select dept.deptno from dept</code> is not.          */
name|int
name|Boxed
init|=
literal|1
decl_stmt|;
name|int
name|None
init|=
literal|0
decl_stmt|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**      * Visitor which walks over a program and checks validity.      */
specifier|private
specifier|static
class|class
name|Checker
extends|extends
name|RexVisitorImpl
argument_list|<
name|Boolean
argument_list|>
block|{
specifier|private
specifier|final
name|boolean
name|fail
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|inputRowType
decl_stmt|;
name|int
name|failCount
init|=
literal|0
decl_stmt|;
comment|/**          * Creates a Checker.          *          * @param inputRowType Input row type to expressions          * @param fail Whether to throw if checker finds an error          */
specifier|private
name|Checker
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|fail
operator|=
name|fail
expr_stmt|;
name|this
operator|.
name|inputRowType
operator|=
name|inputRowType
expr_stmt|;
block|}
specifier|public
name|Boolean
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
index|[]
name|fields
init|=
name|inputRowType
operator|.
name|getFields
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|fields
operator|.
name|length
operator|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
operator|++
name|failCount
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"inputRef"
argument_list|,
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|,
literal|"underlying field"
argument_list|,
name|fields
index|[
name|index
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|fail
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
operator|++
name|failCount
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|Boolean
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"localRef invalid in project"
assert|;
operator|++
name|failCount
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|public
name|Boolean
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
name|super
operator|.
name|visitFieldAccess
argument_list|(
name|fieldAccess
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|refType
init|=
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
assert|assert
name|refType
operator|.
name|isStruct
argument_list|()
assert|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|fieldAccess
operator|.
name|getField
argument_list|()
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|field
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>
name|refType
operator|.
name|getFields
argument_list|()
operator|.
name|length
operator|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
operator|++
name|failCount
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|final
name|RelDataTypeField
name|typeField
init|=
name|refType
operator|.
name|getFields
argument_list|()
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|eq
argument_list|(
literal|"type1"
argument_list|,
name|typeField
operator|.
name|getType
argument_list|()
argument_list|,
literal|"type2"
argument_list|,
name|fieldAccess
operator|.
name|getType
argument_list|()
argument_list|,
name|fail
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
operator|++
name|failCount
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End ProjectRelBase.java
end_comment

end_unit

