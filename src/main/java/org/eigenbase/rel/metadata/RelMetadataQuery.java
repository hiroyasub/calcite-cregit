begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|stat
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * RelMetadataQuery provides a strongly-typed facade on top of {@link  * RelMetadataProvider} for the set of relational expression metadata queries  * defined as standard within Eigenbase. The Javadoc on these methods serves as  * their primary specification.  *  *<p>To add a new standard query<code>Xyz</code> to this interface, follow  * these steps:  *  *<ol>  *<li>Add a static method<code>getXyz</code> specification to this class.  *<li>Add unit tests to {@link org.eigenbase.test.RelMetadataTest}.  *<li>Write a new provider class<code>RelMdXyz</code> in this package. Follow  * the pattern from an existing class such as {@link RelMdColumnOrigins},  * overloading on all of the logical relational expressions to which the query  * applies. If your new metadata query takes parameters, be sure to register  * them in the constructor via a call to {@link  * ReflectiveRelMetadataProvider#mapParameterTypes}.  *<li>Register your provider class in {@link DefaultRelMetadataProvider}.  *<li>Get unit tests working.  *</ol>  *  *<p>Because relational expression metadata is extensible, extension projects  * can define similar facades in order to specify access to custom metadata.  * Please do not add queries here (nor on {@link RelNode}) which lack meaning  * outside of your extension.  *  *<p>Besides adding new metadata queries, extension projects may need to add  * custom providers for the standard queries in order to handle additional  * relational expressions (either logical or physical). In either case, the  * process is the same: write a reflective provider and chain it on to an  * instance of {@link DefaultRelMetadataProvider}, prepending it to the default  * providers. Then supply that instance to the planner via the appropriate  * plugin mechanism.  *  * @author John V. Sichi  * @version $Id$  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|RelMetadataQuery
block|{
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * Returns statistics for a relational expression. These statistics include      * features such as row counts, or column distributions. Stats are typically      * collected by sampling a table. They might also be inferred from a rel's      * history. Certain rels, such as filters, might generate stats from their      * inputs.      *      * @param rel the relational expression.      *      * @return a statistics object, if statistics are available, or null      * otherwise      */
specifier|public
specifier|static
name|RelStatSource
name|getStatistics
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|RelStatSource
name|result
init|=
operator|(
name|RelStatSource
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getStatistics"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Estimates the number of rows which will be returned by a relational      * expression. The default implementation for this query asks the rel itself      * via {@link RelNode#getRows}, but metadata providers can override this      * with their own cost models.      *      *      * @param rel the relational expression      *      * @return estimated row count, or null if no reliable estimate can be      * determined      */
specifier|public
specifier|static
name|Double
name|getRowCount
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|Double
name|result
init|=
operator|(
name|Double
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getRowCount"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|validateResult
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Estimates the cost of executing a relational expression, including the      * cost of its inputs. The default implementation for this query adds {@link      * #getNonCumulativeCost} to the cumulative cost of each input, but metadata      * providers can override this with their own cost models, e.g. to take into      * account interactions between expressions.      *      * @param rel the relational expression      *      * @return estimated cost, or null if no reliable estimate can be determined      */
specifier|public
specifier|static
name|RelOptCost
name|getCumulativeCost
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|RelOptCost
name|result
init|=
operator|(
name|RelOptCost
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getCumulativeCost"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Estimates the cost of executing a relational expression, not counting the      * cost of its inputs. (However, the non-cumulative cost is still usually      * dependent on the row counts of the inputs.) The default implementation      * for this query asks the rel itself via {@link RelNode#computeSelfCost},      * but metadata providers can override this with their own cost models.      *      * @param rel the relational expression      *      * @return estimated cost, or null if no reliable estimate can be determined      */
specifier|public
specifier|static
name|RelOptCost
name|getNonCumulativeCost
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|RelOptCost
name|result
init|=
operator|(
name|RelOptCost
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getNonCumulativeCost"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Estimates the percentage of the number of rows actually produced by an      * expression out of the number of rows it would produce if all single-table      * filter conditions were removed.      *      * @param rel the relational expression      *      * @return estimated percentage (between 0.0 and 1.0), or null if no      * reliable estimate can be determined      */
specifier|public
specifier|static
name|Double
name|getPercentageOriginalRows
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|Double
name|result
init|=
operator|(
name|Double
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getPercentageOriginalRows"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|assertPercentage
argument_list|(
name|result
argument_list|)
operator|)
assert|;
return|return
name|result
return|;
block|}
comment|/**      * For a given output column of an expression, determines all columns of      * underlying tables which contribute to result values. An output column may      * have more than one origin due to expressions such as UnionRel and      * ProjectRel. The optimizer may use this information for catalog access      * (e.g. index availability).      *      * @param rel the relational expression      * @param iOutputColumn 0-based ordinal for output column of interest      *      * @return set of origin columns, or null if this information cannot be      * determined (whereas empty set indicates definitely no origin columns at      * all)      */
specifier|public
specifier|static
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|getColumnOrigins
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|iOutputColumn
parameter_list|)
block|{
return|return
operator|(
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getColumnOrigins"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|iOutputColumn
block|}
argument_list|)
return|;
block|}
comment|/**      * Estimates the percentage of an expression's output rows which satisfy a      * given predicate. Returns null to indicate that no reliable estimate can      * be produced.      *      * @param rel the relational expression      * @param predicate predicate whose selectivity is to be estimated against      * rel's output      *      * @return estimated selectivity (between 0.0 and 1.0), or null if no      * reliable estimate can be determined      */
specifier|public
specifier|static
name|Double
name|getSelectivity
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
block|{
name|Double
name|result
init|=
operator|(
name|Double
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getSelectivity"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|predicate
block|}
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|assertPercentage
argument_list|(
name|result
argument_list|)
operator|)
assert|;
return|return
name|result
return|;
block|}
comment|/**      * Determines the set of unique minimal keys for this expression. A key is      * represented as a BitSet, where each bit position represents a 0-based      * output column ordinal. (Note that RelNode.isDistinct should return true      * if and only if at least one key is known.)      *      * @param rel the relational expression      *      * @return set of keys, or null if this information cannot be determined      * (whereas empty set indicates definitely no keys at all)      */
specifier|public
specifier|static
name|Set
argument_list|<
name|BitSet
argument_list|>
name|getUniqueKeys
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|(
name|Set
argument_list|<
name|BitSet
argument_list|>
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getUniqueKeys"
argument_list|,
operator|new
name|Object
index|[]
block|{
literal|false
block|}
argument_list|)
return|;
block|}
comment|/**      * Determines the set of unique minimal keys for this expression,      * optionally ignoring nulls in the columns in the expression.  A key is      * represented as a BitSet, where each bit position represents a 0-based      * output column ordinal. (Note that RelNode.isDistinct should return true      * if and only if at least one key is known.)      *      *<p>Nulls can be ignored if the relational expression has filtered out      * null values.      *      * @param rel the relational expression      * @param ignoreNulls if true, ignore null values when determining      * whether the keys are unique      *      * @return set of keys, or null if this information cannot be determined      * (whereas empty set indicates definitely no keys at all)      */
specifier|public
specifier|static
name|Set
argument_list|<
name|BitSet
argument_list|>
name|getUniqueKeys
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|)
block|{
return|return
operator|(
name|Set
argument_list|<
name|BitSet
argument_list|>
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getUniqueKeys"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|ignoreNulls
block|}
argument_list|)
return|;
block|}
comment|/**      * Determines if a specified set of columns from a specified relational      * expression are unique.      *      * @param rel the relational expression      * @param columns column mask representing the subset of columns for which      * uniqueness will be determined      *      * @return true or false depending on whether the columns are unique, or      * null if not enough information is available to make that determination      */
specifier|public
specifier|static
name|Boolean
name|areColumnsUnique
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|BitSet
name|columns
parameter_list|)
block|{
return|return
operator|(
name|Boolean
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"areColumnsUnique"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|columns
block|,
literal|false
block|}
argument_list|)
return|;
block|}
comment|/**      * Determines if a specified set of columns from a specified relational      * expression are unique, optionally ignoring null values in the columns.      * Nulls can be ignored if the relational expression has filtered out      * null values.      *      * @param rel the relational expression      * @param columns column mask representing the subset of columns for which      * uniqueness will be determined      * @param ignoreNulls if true, ignore null values when determining column      * uniqueness      *      * @return true or false depending on whether the columns are unique, or      * null if not enough information is available to make that determination      */
specifier|public
specifier|static
name|Boolean
name|areColumnsUnique
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|BitSet
name|columns
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|)
block|{
return|return
operator|(
name|Boolean
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"areColumnsUnique"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|columns
block|,
name|ignoreNulls
block|}
argument_list|)
return|;
block|}
comment|/**      * Estimates the distinct row count in the original source for the given      * groupKey, ignoring any filtering being applied by the expression.      * Typically, "original source" means base table, but for derived columns,      * the estimate may come from a non-leaf rel such as a ProjectRel.      *      * @param rel the relational expression      * @param groupKey column mask representing the subset of columns for which      * the row count will be determined      *      * @return distinct row count for the given groupKey, or null if no reliable      * estimate can be determined      */
specifier|public
specifier|static
name|Double
name|getPopulationSize
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|BitSet
name|groupKey
parameter_list|)
block|{
name|Double
name|result
init|=
operator|(
name|Double
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getPopulationSize"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|groupKey
block|}
argument_list|)
decl_stmt|;
return|return
name|validateResult
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Estimates the number of rows which would be produced by a GROUP BY on the      * set of columns indicated by groupKey, where the input to the GROUP BY has      * been pre-filtered by predicate. This quantity (leaving out predicate) is      * often referred to as cardinality (as in gender being a "low-cardinality      * column").      *      * @param rel the relational expression      * @param groupKey column mask representing group by columns      * @param predicate pre-filtered predicates      *      * @return distinct row count for groupKey, filtered by predicate, or null      * if no reliable estimate can be determined      */
specifier|public
specifier|static
name|Double
name|getDistinctRowCount
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|BitSet
name|groupKey
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
block|{
name|Double
name|result
init|=
operator|(
name|Double
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"getDistinctRowCount"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|groupKey
block|,
name|predicate
block|}
argument_list|)
decl_stmt|;
return|return
name|validateResult
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Determines whether a relational expression should be visible in EXPLAIN      * PLAN output at a particular level of detail.      *      * @param rel the relational expression      * @param explainLevel level of detail      *      * @return true for visible, false for invisible      */
specifier|public
specifier|static
name|boolean
name|isVisibleInExplain
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|SqlExplainLevel
name|explainLevel
parameter_list|)
block|{
name|Boolean
name|b
init|=
operator|(
name|Boolean
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
operator|.
name|getRelMetadata
argument_list|(
name|rel
argument_list|,
literal|"isVisibleInExplain"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|explainLevel
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
name|b
return|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|assertPercentage
parameter_list|(
name|Double
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|double
name|d
init|=
name|result
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|d
operator|>=
literal|0.0
operator|)
assert|;
assert|assert
operator|(
name|d
operator|<=
literal|1.0
operator|)
assert|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|boolean
name|assertNonNegative
parameter_list|(
name|Double
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|double
name|d
init|=
name|result
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|d
operator|>=
literal|0.0
operator|)
assert|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|Double
name|validateResult
parameter_list|(
name|Double
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Never let the result go below 1, as it will result in incorrect
comment|// calculations if the rowcount is used as the denominator in a
comment|// division expression.  Also, cap the value at the max double value
comment|// to avoid calculations using infinity.
if|if
condition|(
name|result
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
name|result
operator|=
name|Double
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
assert|assert
operator|(
name|assertNonNegative
argument_list|(
name|result
argument_list|)
operator|)
assert|;
if|if
condition|(
name|result
operator|<
literal|1.0
condition|)
block|{
name|result
operator|=
literal|1.0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

begin_comment
comment|// End RelMetadataQuery.java
end_comment

end_unit

