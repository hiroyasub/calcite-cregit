begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql2rel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|hep
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|trace
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_comment
comment|/**  * RelDecorrelator replaces all correlated expressions(corExp) in a relational  * expression (RelNode) tree with non-correlated expressions that are produced  * from joining the RelNode that produces the corExp with the RelNode that  * references it.  */
end_comment

begin_class
specifier|public
class|class
name|RelDecorrelator
implements|implements
name|ReflectiveVisitor
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|Logger
name|sqlToRelTracer
init|=
name|EigenbaseTrace
operator|.
name|getSqlToRelTracer
argument_list|()
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|// maps built during translation
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|SortedSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|>
name|mapRefRelToCorVar
decl_stmt|;
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|CorrelatorRel
argument_list|>
name|mapCorVarToCorRel
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RexFieldAccess
argument_list|,
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|mapFieldAccessToCorVar
decl_stmt|;
specifier|private
specifier|final
name|DecorrelateRelVisitor
name|decorrelateVisitor
decl_stmt|;
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
comment|// The rel which is being visited
specifier|private
name|RelNode
name|currentRel
decl_stmt|;
comment|// maps built during decorrelation
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|mapOldToNewRel
decl_stmt|;
comment|// map rel to all the newly created correlated variables in its output
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|mapNewRelToMapCorVarToOutputPos
decl_stmt|;
comment|// another map to map old input positions to new input positions
comment|// this is from the view point of the parent rel of a new rel.
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|mapNewRelToMapOldToNewOutputPos
decl_stmt|;
specifier|private
specifier|final
name|HashSet
argument_list|<
name|CorrelatorRel
argument_list|>
name|generatedCorRels
init|=
operator|new
name|HashSet
argument_list|<
name|CorrelatorRel
argument_list|>
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|RelDecorrelator
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Map
argument_list|<
name|RelNode
argument_list|,
name|SortedSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|>
name|mapRefRelToCorVar
parameter_list|,
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|CorrelatorRel
argument_list|>
name|mapCorVarToCorRel
parameter_list|,
name|Map
argument_list|<
name|RexFieldAccess
argument_list|,
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|mapFieldAccessToCorVar
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|mapRefRelToCorVar
operator|=
name|mapRefRelToCorVar
expr_stmt|;
name|this
operator|.
name|mapCorVarToCorRel
operator|=
name|mapCorVarToCorRel
expr_stmt|;
name|this
operator|.
name|mapFieldAccessToCorVar
operator|=
name|mapFieldAccessToCorVar
expr_stmt|;
name|decorrelateVisitor
operator|=
operator|new
name|DecorrelateRelVisitor
argument_list|()
expr_stmt|;
name|mapOldToNewRel
operator|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
argument_list|()
expr_stmt|;
name|mapNewRelToMapCorVarToOutputPos
operator|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|mapNewRelToMapOldToNewOutputPos
operator|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|RelNode
name|decorrelate
parameter_list|(
name|RelNode
name|root
parameter_list|)
block|{
comment|// first adjust count() expression if any
name|HepProgramBuilder
name|programBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AdjustProjectForCountAggregateRule
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AdjustProjectForCountAggregateRule
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|programBuilder
operator|.
name|createProgram
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|=
name|planner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
comment|// Perform decorrelation.
name|mapOldToNewRel
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|clear
argument_list|()
expr_stmt|;
name|decorrelateVisitor
operator|.
name|visit
argument_list|(
name|root
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapOldToNewRel
operator|.
name|containsKey
argument_list|(
name|root
argument_list|)
condition|)
block|{
comment|// has been rewritten
return|return
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|root
argument_list|)
return|;
block|}
else|else
block|{
comment|// not rewritten
return|return
name|root
return|;
block|}
block|}
specifier|public
name|RelNode
name|removeCorrelationViaRule
parameter_list|(
name|RelNode
name|root
parameter_list|)
block|{
name|HepProgramBuilder
name|programBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|RemoveSingleAggregateRule
argument_list|()
argument_list|)
expr_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|RemoveCorrelationForScalarProjectRule
argument_list|()
argument_list|)
expr_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|RemoveCorrelationForScalarAggregateRule
argument_list|()
argument_list|)
expr_stmt|;
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|programBuilder
operator|.
name|createProgram
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|RelNode
name|newRootRel
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
return|return
name|newRootRel
return|;
block|}
specifier|protected
name|RexNode
name|decorrelateExpr
parameter_list|(
name|RexNode
name|exp
parameter_list|)
block|{
name|DecorrelateRexShuttle
name|shuttle
init|=
operator|new
name|DecorrelateRexShuttle
argument_list|()
decl_stmt|;
return|return
name|exp
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|removeCorrelationExpr
parameter_list|(
name|RexNode
name|exp
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|)
block|{
name|RemoveCorrelationRexShuttle
name|shuttle
init|=
operator|new
name|RemoveCorrelationRexShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|)
decl_stmt|;
return|return
name|exp
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|removeCorrelationExpr
parameter_list|(
name|RexNode
name|exp
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|,
name|RexInputRef
name|nullIndicator
parameter_list|)
block|{
name|RemoveCorrelationRexShuttle
name|shuttle
init|=
operator|new
name|RemoveCorrelationRexShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
name|nullIndicator
argument_list|)
decl_stmt|;
return|return
name|exp
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|removeCorrelationExpr
parameter_list|(
name|RexNode
name|exp
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
parameter_list|)
block|{
name|RemoveCorrelationRexShuttle
name|shuttle
init|=
operator|new
name|RemoveCorrelationRexShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
name|isCount
argument_list|)
decl_stmt|;
return|return
name|exp
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|public
name|void
name|decorrelateRelGeneric
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|RelNode
name|newRel
init|=
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|oldInputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldInputs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|RelNode
name|newInputRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldInputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|newInputRel
operator|==
literal|null
operator|)
operator|||
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newInputRel
argument_list|)
condition|)
block|{
comment|// if child is not rewritten, or if it produces correlated
comment|// variables, terminate rewrite
return|return;
block|}
else|else
block|{
name|newInputs
operator|.
name|add
argument_list|(
name|newInputRel
argument_list|)
expr_stmt|;
name|newRel
operator|.
name|replaceInput
argument_list|(
name|i
argument_list|,
name|newInputRel
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|Util
operator|.
name|equalShallow
argument_list|(
name|oldInputs
argument_list|,
name|newInputs
argument_list|)
condition|)
block|{
name|newRel
operator|=
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// the output position should not change since there're no corVars
comment|// coming from below.
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputPos
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|mapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|newRel
argument_list|)
expr_stmt|;
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newRel
argument_list|,
name|mapOldToNewOutputPos
argument_list|)
expr_stmt|;
block|}
comment|/**      * Rewrite SortRel.      *      * @param rel SortRel to be rewritten      */
specifier|public
name|void
name|decorrelateRel
parameter_list|(
name|SortRel
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. change the collations field to reference the new input.
comment|//
comment|// SortRel itself should not reference cor vars.
assert|assert
operator|(
operator|!
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
operator|)
assert|;
comment|// SortRel only references field positions in collations field.
comment|// The collations field in the newRel now need to refer to the
comment|// new output positions in its input.
comment|// Its output does not change the input ordering, so there's no
comment|// need to call propagateExpr.
name|RelNode
name|oldChildRel
init|=
name|rel
operator|.
name|getChild
argument_list|()
decl_stmt|;
name|RelNode
name|newChildRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldChildRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|newChildRel
operator|==
literal|null
condition|)
block|{
comment|// If child has not been rewritten, do not rewrite this rel.
return|return;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|childMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
assert|assert
name|childMapOldToNewOutputPos
operator|!=
literal|null
assert|;
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|Mappings
operator|.
name|target
argument_list|(
name|childMapOldToNewOutputPos
argument_list|,
name|oldChildRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|newChildRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|RelCollation
name|oldCollation
init|=
name|rel
operator|.
name|getCollation
argument_list|()
decl_stmt|;
name|RelCollation
name|newCollation
init|=
name|RexUtil
operator|.
name|apply
argument_list|(
name|mapping
argument_list|,
name|oldCollation
argument_list|)
decl_stmt|;
name|SortRel
name|newRel
init|=
operator|new
name|SortRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSetOf
argument_list|(
name|Convention
operator|.
name|NONE
argument_list|)
argument_list|,
name|newChildRel
argument_list|,
name|newCollation
argument_list|)
decl_stmt|;
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|newRel
argument_list|)
expr_stmt|;
comment|// SortRel does not change input ordering
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newRel
argument_list|,
name|childMapOldToNewOutputPos
argument_list|)
expr_stmt|;
block|}
comment|/**      * Rewrite AggregateRel.      *      * @param rel the project rel to rewrite      */
specifier|public
name|void
name|decorrelateRel
parameter_list|(
name|AggregateRel
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. Permute the group by keys to the front.
comment|// 2. If the child of an AggregateRel produces correlated variables,
comment|//    add them to the group list.
comment|// 3. Change aggCalls to reference the new ProjectRel.
comment|//
comment|// AggregaterRel itself should not reference cor vars.
assert|assert
operator|(
operator|!
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
operator|)
assert|;
name|RelNode
name|oldChildRel
init|=
name|rel
operator|.
name|getChild
argument_list|()
decl_stmt|;
name|RelNode
name|newChildRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldChildRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|newChildRel
operator|==
literal|null
condition|)
block|{
comment|// If child has not been rewritten, do not rewrite this rel.
return|return;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|childMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|childMapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
comment|// map from newChildRel
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapNewChildToProjOutputPos
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|oldGroupKeyCount
init|=
name|rel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
decl_stmt|;
comment|// ProjectRel projects the original expressions,
comment|// plus any correlated variables the child wants to pass along.
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|exprNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|newChildOutput
init|=
name|newChildRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|RelDataType
name|fieldType
decl_stmt|;
name|RexInputRef
name|newInput
decl_stmt|;
name|int
name|newChildPos
decl_stmt|;
name|int
name|newPos
decl_stmt|;
comment|// oldChildRel has the original group by keys in the front.
for|for
control|(
name|newPos
operator|=
literal|0
init|;
name|newPos
operator|<
name|oldGroupKeyCount
condition|;
name|newPos
operator|++
control|)
block|{
name|newChildPos
operator|=
name|childMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
name|fieldType
operator|=
name|newChildOutput
index|[
name|newChildPos
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
name|newInput
operator|=
operator|new
name|RexInputRef
argument_list|(
name|newChildPos
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|newInput
argument_list|)
expr_stmt|;
name|exprNames
operator|.
name|add
argument_list|(
name|newChildOutput
index|[
name|newChildPos
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|mapNewChildToProjOutputPos
operator|.
name|put
argument_list|(
name|newChildPos
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
block|}
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|mapCorVarToOutputPos
init|=
operator|new
name|TreeMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|produceCorVar
init|=
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|produceCorVar
condition|)
block|{
comment|// If child produces correlated variables, move them to the front,
comment|// right after any existing groupby fields.
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|childMapCorVarToOutputPos
init|=
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
comment|// Now add the corVars from the child, starting from
comment|// position oldGroupKeyCount.
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|childMapCorVarToOutputPos
operator|.
name|keySet
argument_list|()
control|)
block|{
name|newChildPos
operator|=
name|childMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
expr_stmt|;
name|fieldType
operator|=
name|newChildOutput
index|[
name|newChildPos
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
name|newInput
operator|=
operator|new
name|RexInputRef
argument_list|(
name|newChildPos
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|newInput
argument_list|)
expr_stmt|;
name|exprNames
operator|.
name|add
argument_list|(
name|newChildOutput
index|[
name|newChildPos
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|mapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|corVar
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|mapNewChildToProjOutputPos
operator|.
name|put
argument_list|(
name|newChildPos
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
block|}
comment|// add the remaining fields
specifier|final
name|int
name|newGroupKeyCount
init|=
name|newPos
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newChildOutput
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mapNewChildToProjOutputPos
operator|.
name|containsKey
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|fieldType
operator|=
name|newChildOutput
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
name|newInput
operator|=
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|newInput
argument_list|)
expr_stmt|;
name|exprNames
operator|.
name|add
argument_list|(
name|newChildOutput
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|mapNewChildToProjOutputPos
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
block|}
assert|assert
operator|(
name|newPos
operator|==
name|newChildOutput
operator|.
name|length
operator|)
assert|;
comment|// This ProjectRel will be what the old child maps to,
comment|// replacing any previous mapping from old child).
name|RelNode
name|newProjectRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|newChildRel
argument_list|,
name|exprs
argument_list|,
name|exprNames
argument_list|)
decl_stmt|;
comment|// update mappings:
comment|// oldChildRel ----> newChildRel
comment|//
comment|//                   newProjectRel
comment|//                        |
comment|// oldChildRel ---->  newChildRel
comment|//
comment|// is transformed to
comment|//
comment|// oldChildRel ----> newProjectRel
comment|//                        |
comment|//                   newChildRel
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|combinedMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|oldChildPos
range|:
name|childMapOldToNewOutputPos
operator|.
name|keySet
argument_list|()
control|)
block|{
name|combinedMap
operator|.
name|put
argument_list|(
name|oldChildPos
argument_list|,
name|mapNewChildToProjOutputPos
operator|.
name|get
argument_list|(
name|childMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|oldChildPos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|oldChildRel
argument_list|,
name|newProjectRel
argument_list|)
expr_stmt|;
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newProjectRel
argument_list|,
name|combinedMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|produceCorVar
condition|)
block|{
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|newProjectRel
argument_list|,
name|mapCorVarToOutputPos
argument_list|)
expr_stmt|;
block|}
comment|// now it's time to rewrite AggregateRel
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newAggCalls
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregateCall
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|oldAggCalls
init|=
name|rel
operator|.
name|getAggCallList
argument_list|()
decl_stmt|;
comment|// AggregateRel.Call oldAggCall;
name|int
name|oldChildOutputFieldCount
init|=
name|oldChildRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|newChildOutputFieldCount
init|=
name|newProjectRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AggregateCall
name|oldAggCall
range|:
name|oldAggCalls
control|)
block|{
operator|++
name|i
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|oldAggArgs
init|=
name|oldAggCall
operator|.
name|getArgList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|aggArgs
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Adjust the aggregator argument positions.
comment|// Note aggregator does not change input ordering, so the child
comment|// output position mapping can be used to derive the new positions
comment|// for the argument.
for|for
control|(
name|int
name|oldPos
range|:
name|oldAggArgs
control|)
block|{
name|aggArgs
operator|.
name|add
argument_list|(
name|combinedMap
operator|.
name|get
argument_list|(
name|oldPos
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newAggCalls
operator|.
name|add
argument_list|(
operator|new
name|AggregateCall
argument_list|(
name|oldAggCall
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|oldAggCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|aggArgs
argument_list|,
name|oldAggCall
operator|.
name|getType
argument_list|()
argument_list|,
name|oldAggCall
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// The old to new output position mapping will be the same as that
comment|// of newProjectRel, plus any aggregates that the oldAgg produces.
name|combinedMap
operator|.
name|put
argument_list|(
name|oldChildOutputFieldCount
operator|+
name|i
argument_list|,
name|newChildOutputFieldCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|AggregateRel
name|newAggregateRel
init|=
operator|new
name|AggregateRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|newProjectRel
argument_list|,
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|0
argument_list|,
name|newGroupKeyCount
argument_list|)
argument_list|,
name|newAggCalls
argument_list|)
decl_stmt|;
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|newAggregateRel
argument_list|)
expr_stmt|;
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newAggregateRel
argument_list|,
name|combinedMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|produceCorVar
condition|)
block|{
comment|// AggregaterRel does not change input ordering so corVars will be
comment|// located at the same position as the input newProjectRel.
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|newAggregateRel
argument_list|,
name|mapCorVarToOutputPos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Rewrite ProjectRel.      *      * @param rel the project rel to rewrite      */
specifier|public
name|void
name|decorrelateRel
parameter_list|(
name|ProjectRel
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. Pass along any correlated variables coming from the child.
comment|//
name|RelNode
name|oldChildRel
init|=
name|rel
operator|.
name|getChild
argument_list|()
decl_stmt|;
name|RelNode
name|newChildRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldChildRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|newChildRel
operator|==
literal|null
condition|)
block|{
comment|// If child has not been rewritten, do not rewrite this rel.
return|return;
block|}
name|RexNode
index|[]
name|oldProj
init|=
name|rel
operator|.
name|getProjectExps
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|relOutput
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|childMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|childMapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputPos
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|produceCorVar
init|=
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
comment|// ProjectRel projects the original expressions,
comment|// plus any correlated variables the child wants to pass along.
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|exprNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// If this ProjectRel has correlated reference, create value generator
comment|// and produce the correlated variables in the new output.
if|if
condition|(
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|decorrelateInputWithValueGenerator
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// The old child should be mapped to the JoinRel created by
comment|// rewriteInputWithValueGenerator().
name|newChildRel
operator|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldChildRel
argument_list|)
expr_stmt|;
name|produceCorVar
operator|=
literal|true
expr_stmt|;
block|}
comment|// ProjectRel projects the original expressions
name|int
name|newPos
decl_stmt|;
for|for
control|(
name|newPos
operator|=
literal|0
init|;
name|newPos
operator|<
name|oldProj
operator|.
name|length
condition|;
name|newPos
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|newPos
argument_list|,
name|decorrelateExpr
argument_list|(
name|oldProj
index|[
name|newPos
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|exprNames
operator|.
name|add
argument_list|(
name|newPos
argument_list|,
name|relOutput
index|[
name|newPos
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|mapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newPos
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
block|}
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|mapCorVarToOutputPos
init|=
operator|new
name|TreeMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Project any correlated variables the child wants to pass along.
if|if
condition|(
name|produceCorVar
condition|)
block|{
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|childMapCorVarToOutputPos
init|=
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
comment|// propagate cor vars from the new child
name|int
name|corVarPos
decl_stmt|;
name|RelDataType
name|fieldType
decl_stmt|;
name|RexInputRef
name|newInput
decl_stmt|;
name|RelDataTypeField
index|[]
name|newChildOutput
init|=
name|newChildRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|childMapCorVarToOutputPos
operator|.
name|keySet
argument_list|()
control|)
block|{
name|corVarPos
operator|=
name|childMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
expr_stmt|;
name|fieldType
operator|=
name|newChildOutput
index|[
name|corVarPos
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
name|newInput
operator|=
operator|new
name|RexInputRef
argument_list|(
name|corVarPos
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|newInput
argument_list|)
expr_stmt|;
name|exprNames
operator|.
name|add
argument_list|(
name|newChildOutput
index|[
name|corVarPos
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|mapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|corVar
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
name|newPos
operator|++
expr_stmt|;
block|}
block|}
name|RelNode
name|newProjectRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|newChildRel
argument_list|,
name|exprs
argument_list|,
name|exprNames
argument_list|)
decl_stmt|;
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|newProjectRel
argument_list|)
expr_stmt|;
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newProjectRel
argument_list|,
name|mapOldToNewOutputPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|produceCorVar
condition|)
block|{
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|newProjectRel
argument_list|,
name|mapCorVarToOutputPos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Create RelNode tree that produces a list of correlated variables.      *      * @param correlations correlated variables to generate      * @param valueGenFieldOffset offset in the output that generated columns      * will start      * @param mapCorVarToOutputPos output positions for the correlated variables      * generated      *      * @return RelNode the root of the resultant RelNode tree      */
specifier|private
name|RelNode
name|createValueGenerator
parameter_list|(
name|SortedSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|correlations
parameter_list|,
name|int
name|valueGenFieldOffset
parameter_list|,
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|mapCorVarToOutputPos
parameter_list|)
block|{
name|RelNode
name|resultRel
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|mapNewInputRelToOutputPos
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|mapNewInputRelToNewOffset
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|RelNode
name|oldInputRel
decl_stmt|;
name|RelNode
name|newInputRel
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|newLocalOutputPosList
decl_stmt|;
comment|// inputRel provides the definition of a correlated variable.
comment|// Add to map all the referenced positions(relative to each input rel)
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|correlations
control|)
block|{
name|int
name|oldCorVarOffset
init|=
name|corVar
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|oldInputRel
operator|=
name|mapCorVarToCorRel
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|oldInputRel
operator|!=
literal|null
operator|)
assert|;
name|newInputRel
operator|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldInputRel
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|newInputRel
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
operator|!
name|mapNewInputRelToOutputPos
operator|.
name|containsKey
argument_list|(
name|newInputRel
argument_list|)
condition|)
block|{
name|newLocalOutputPosList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newLocalOutputPosList
operator|=
name|mapNewInputRelToOutputPos
operator|.
name|get
argument_list|(
name|newInputRel
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newInputRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|mapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|int
name|newCorVarOffset
init|=
name|mapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|oldCorVarOffset
argument_list|)
decl_stmt|;
comment|// Add all unique positions referenced.
if|if
condition|(
operator|!
name|newLocalOutputPosList
operator|.
name|contains
argument_list|(
name|newCorVarOffset
argument_list|)
condition|)
block|{
name|newLocalOutputPosList
operator|.
name|add
argument_list|(
name|newCorVarOffset
argument_list|)
expr_stmt|;
block|}
name|mapNewInputRelToOutputPos
operator|.
name|put
argument_list|(
name|newInputRel
argument_list|,
name|newLocalOutputPosList
argument_list|)
expr_stmt|;
block|}
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// Project only the correlated fields out of each inputRel
comment|// and join the projectRel together.
comment|// To make sure the plan does not change in terms of join order,
comment|// join these rels based on their occurance in cor var list which
comment|// is sorted.
name|Set
argument_list|<
name|RelNode
argument_list|>
name|joinedInputRelSet
init|=
operator|new
name|HashSet
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|correlations
control|)
block|{
name|oldInputRel
operator|=
name|mapCorVarToCorRel
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|oldInputRel
operator|!=
literal|null
operator|)
assert|;
name|newInputRel
operator|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldInputRel
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|newInputRel
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
operator|!
name|joinedInputRelSet
operator|.
name|contains
argument_list|(
name|newInputRel
argument_list|)
condition|)
block|{
name|RelNode
name|projectRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|newInputRel
argument_list|,
name|mapNewInputRelToOutputPos
operator|.
name|get
argument_list|(
name|newInputRel
argument_list|)
argument_list|)
decl_stmt|;
name|RelNode
name|distinctRel
init|=
name|RelOptUtil
operator|.
name|createDistinctRel
argument_list|(
name|projectRel
argument_list|)
decl_stmt|;
name|RelOptCluster
name|cluster
init|=
name|distinctRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
name|joinedInputRelSet
operator|.
name|add
argument_list|(
name|newInputRel
argument_list|)
expr_stmt|;
name|mapNewInputRelToNewOffset
operator|.
name|put
argument_list|(
name|newInputRel
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|distinctRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|resultRel
operator|==
literal|null
condition|)
block|{
name|resultRel
operator|=
name|distinctRel
expr_stmt|;
block|}
else|else
block|{
name|resultRel
operator|=
operator|new
name|JoinRel
argument_list|(
name|cluster
argument_list|,
name|resultRel
argument_list|,
name|distinctRel
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|Collections
operator|.
expr|<
name|String
operator|>
name|emptySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Translate the positions of correlated variables to be relative to
comment|// the join output, leaving room for valueGenFieldOffset because
comment|// valueGenerators are joined with the original left input of the rel
comment|// referencing correlated variables.
name|int
name|newOutputPos
decl_stmt|,
name|newLocalOutputPos
decl_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|correlations
control|)
block|{
comment|// The first child of a correlatorRel is always the rel defining
comment|// the correlated variables.
name|newInputRel
operator|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|mapCorVarToCorRel
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|newLocalOutputPosList
operator|=
name|mapNewInputRelToOutputPos
operator|.
name|get
argument_list|(
name|newInputRel
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newInputRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|mapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|newLocalOutputPos
operator|=
name|mapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|corVar
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
comment|// newOutputPos is the index of the cor var in the referenced
comment|// position list plus the offset of referenced postition list of
comment|// each newInputRel.
name|newOutputPos
operator|=
name|newLocalOutputPosList
operator|.
name|indexOf
argument_list|(
name|newLocalOutputPos
argument_list|)
operator|+
name|mapNewInputRelToNewOffset
operator|.
name|get
argument_list|(
name|newInputRel
argument_list|)
operator|+
name|valueGenFieldOffset
expr_stmt|;
if|if
condition|(
name|mapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|corVar
argument_list|)
condition|)
block|{
assert|assert
operator|(
name|mapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|==
name|newOutputPos
operator|)
assert|;
block|}
name|mapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|corVar
argument_list|,
name|newOutputPos
argument_list|)
expr_stmt|;
block|}
return|return
name|resultRel
return|;
block|}
specifier|private
name|void
name|decorrelateInputWithValueGenerator
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
comment|// currently only handles one child input
assert|assert
operator|(
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
name|RelNode
name|oldChildRel
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|newChildRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldChildRel
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|childMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|childMapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|mapCorVarToOutputPos
init|=
operator|new
name|TreeMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newChildRel
argument_list|)
condition|)
block|{
name|mapCorVarToOutputPos
operator|.
name|putAll
argument_list|(
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SortedSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|corVarList
init|=
name|mapRefRelToCorVar
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|RelNode
name|newLeftChildRel
init|=
name|newChildRel
decl_stmt|;
name|int
name|leftChildOutputCount
init|=
name|newLeftChildRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// can directly add positions into mapCorVarToOutputPos since join
comment|// does not change the output ordering from the children.
name|RelNode
name|valueGenRel
init|=
name|createValueGenerator
argument_list|(
name|corVarList
argument_list|,
name|leftChildOutputCount
argument_list|,
name|mapCorVarToOutputPos
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variablesStopped
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|RelNode
name|joinRel
init|=
operator|new
name|JoinRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|newLeftChildRel
argument_list|,
name|valueGenRel
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|variablesStopped
argument_list|)
decl_stmt|;
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|oldChildRel
argument_list|,
name|joinRel
argument_list|)
expr_stmt|;
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|joinRel
argument_list|,
name|mapCorVarToOutputPos
argument_list|)
expr_stmt|;
comment|// JoinRel or FilterRel does not change the old input ordering. All
comment|// input fields from newLeftInput(i.e. the original input to the old
comment|// FilterRel) are in the output and in the same position.
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|joinRel
argument_list|,
name|childMapOldToNewOutputPos
argument_list|)
expr_stmt|;
block|}
comment|/**      * Rewrite FilterRel.      *      * @param rel the filter rel to rewrite      */
specifier|public
name|void
name|decorrelateRel
parameter_list|(
name|FilterRel
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. If a FilterRel references a correlated field in its filter
comment|// condition, rewrite the FilterRel to be
comment|//   FilterRel
comment|//     JoinRel(cross product)
comment|//       OriginalFilterInput
comment|//       ValueGenerator(produces distinct sets of correlated variables)
comment|// and rewrite the correlated fieldAccess in the filter condition to
comment|// reference the JoinRel output.
comment|//
comment|// 2. If FilterRel does not reference correlated variables, simply
comment|// rewrite the filter condition using new input.
comment|//
name|RelNode
name|oldChildRel
init|=
name|rel
operator|.
name|getChild
argument_list|()
decl_stmt|;
name|RelNode
name|newChildRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldChildRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|newChildRel
operator|==
literal|null
condition|)
block|{
comment|// If child has not been rewritten, do not rewrite this rel.
return|return;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|childMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|childMapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|boolean
name|produceCorVar
init|=
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newChildRel
argument_list|)
decl_stmt|;
comment|// If this FilterRel has correlated reference, create value generator
comment|// and produce the correlated variables in the new output.
if|if
condition|(
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|rel
argument_list|)
condition|)
block|{
name|decorrelateInputWithValueGenerator
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// The old child should be mapped to the newly created JoinRel by
comment|// rewriteInputWithValueGenerator().
name|newChildRel
operator|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldChildRel
argument_list|)
expr_stmt|;
name|produceCorVar
operator|=
literal|true
expr_stmt|;
block|}
comment|// Replace the filter expression to reference output of the join
comment|// Map filter to the new filter over join
name|RelNode
name|newFilterRel
init|=
name|CalcRel
operator|.
name|createFilter
argument_list|(
name|newChildRel
argument_list|,
name|decorrelateExpr
argument_list|(
name|rel
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|newFilterRel
argument_list|)
expr_stmt|;
comment|// Filter does not change the input ordering.
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newFilterRel
argument_list|,
name|childMapOldToNewOutputPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|produceCorVar
condition|)
block|{
comment|// filter rel does not permute the input all corvars produced by
comment|// filter will have the same output positions in the child rel.
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|newFilterRel
argument_list|,
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newChildRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Rewrite CorrelatorRel into a left outer join.      *      * @param rel CorrelatorRel      */
specifier|public
name|void
name|decorrelateRel
parameter_list|(
name|CorrelatorRel
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// The original left input will be joined with the new right input that
comment|// has generated correlated variables propagated up. For any generated
comment|// cor vars that are not used in the join key, pass them along to be
comment|// joined later with the CorrelatorRels that produce them.
comment|//
comment|// the right input to CorrelatorRel should produce correlated variables
name|RelNode
name|oldLeftRel
init|=
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|oldRightRel
init|=
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RelNode
name|newLeftRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldLeftRel
argument_list|)
decl_stmt|;
name|RelNode
name|newRightRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldRightRel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|newLeftRel
operator|==
literal|null
operator|)
operator|||
operator|(
name|newRightRel
operator|==
literal|null
operator|)
condition|)
block|{
comment|// If any child has not been rewritten, do not rewrite this rel.
return|return;
block|}
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|rightChildMapCorVarToOutputPos
init|=
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newRightRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightChildMapCorVarToOutputPos
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|leftChildMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newLeftRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|leftChildMapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|rightChildMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newRightRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|rightChildMapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|mapCorVarToOutputPos
init|=
name|rightChildMapCorVarToOutputPos
decl_stmt|;
assert|assert
operator|(
name|rel
operator|.
name|getCorrelations
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
name|rightChildMapCorVarToOutputPos
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
operator|)
assert|;
comment|// Change correlator rel into a join.
comment|// Join all the correlated variables produced by this correlator rel
comment|// with the values generated and propagated from the right input
name|RexNode
name|condition
init|=
name|rel
operator|.
name|getCondition
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
index|[]
name|newLeftOutput
init|=
name|newLeftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|int
name|newLeftFieldCount
init|=
name|newLeftOutput
operator|.
name|length
decl_stmt|;
specifier|final
name|RelDataTypeField
index|[]
name|newRightOutput
init|=
name|newRightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|int
name|newLeftPos
decl_stmt|,
name|newRightPos
decl_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|rel
operator|.
name|getCorrelations
argument_list|()
control|)
block|{
name|newLeftPos
operator|=
name|leftChildMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|corVar
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
name|newRightPos
operator|=
name|rightChildMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
expr_stmt|;
name|RexNode
name|equi
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|equalsOperator
argument_list|,
operator|new
name|RexInputRef
argument_list|(
name|newLeftPos
argument_list|,
name|newLeftOutput
index|[
name|newLeftPos
index|]
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
operator|new
name|RexInputRef
argument_list|(
name|newLeftFieldCount
operator|+
name|newRightPos
argument_list|,
name|newRightOutput
index|[
name|newRightPos
index|]
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
condition|)
block|{
name|condition
operator|=
name|equi
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|andOperator
argument_list|,
name|condition
argument_list|,
name|equi
argument_list|)
expr_stmt|;
block|}
comment|// remove this cor var from output position mapping
name|mapCorVarToOutputPos
operator|.
name|remove
argument_list|(
name|corVar
argument_list|)
expr_stmt|;
block|}
comment|// Update the output position for the cor vars: only pass on the cor
comment|// vars that are not used in the join key.
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|mapCorVarToOutputPos
operator|.
name|keySet
argument_list|()
control|)
block|{
name|int
name|newPos
init|=
name|mapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|+
name|newLeftFieldCount
decl_stmt|;
name|mapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|corVar
argument_list|,
name|newPos
argument_list|)
expr_stmt|;
block|}
comment|// then add any cor var from the left input. Do not need to change
comment|// output positions.
if|if
condition|(
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newLeftRel
argument_list|)
condition|)
block|{
name|mapCorVarToOutputPos
operator|.
name|putAll
argument_list|(
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newLeftRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create the mapping between the output of the old correlation rel
comment|// and the new join rel
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputPos
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|oldLeftFieldCount
init|=
name|oldLeftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|oldRightFieldCount
init|=
name|oldRightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|==
operator|(
name|oldLeftFieldCount
operator|+
name|oldRightFieldCount
operator|)
operator|)
assert|;
comment|// Left input positions are not changed.
name|mapOldToNewOutputPos
operator|.
name|putAll
argument_list|(
name|leftChildMapOldToNewOutputPos
argument_list|)
expr_stmt|;
comment|// Right input positions are shifted by newLeftFieldCount.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldRightFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|mapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|i
operator|+
name|oldLeftFieldCount
argument_list|,
name|rightChildMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|newLeftFieldCount
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variablesStopped
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|RelNode
name|newRel
init|=
operator|new
name|JoinRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|newLeftRel
argument_list|,
name|newRightRel
argument_list|,
name|condition
argument_list|,
name|rel
operator|.
name|getJoinType
argument_list|()
argument_list|,
name|variablesStopped
argument_list|)
decl_stmt|;
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|newRel
argument_list|)
expr_stmt|;
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newRel
argument_list|,
name|mapOldToNewOutputPos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mapCorVarToOutputPos
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|newRel
argument_list|,
name|mapCorVarToOutputPos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Rewrite JoinRel.      *      * @param rel JoinRel      */
specifier|public
name|void
name|decorrelateRel
parameter_list|(
name|JoinRel
name|rel
parameter_list|)
block|{
comment|//
comment|// Rewrite logic:
comment|//
comment|// 1. rewrite join condition.
comment|// 2. map output positions and produce cor vars if any.
comment|//
name|RelNode
name|oldLeftRel
init|=
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|oldRightRel
init|=
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RelNode
name|newLeftRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldLeftRel
argument_list|)
decl_stmt|;
name|RelNode
name|newRightRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldRightRel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|newLeftRel
operator|==
literal|null
operator|)
operator|||
operator|(
name|newRightRel
operator|==
literal|null
operator|)
condition|)
block|{
comment|// If any child has not been rewritten, do not rewrite this rel.
return|return;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|leftChildMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newLeftRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|leftChildMapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|rightChildMapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newRightRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|rightChildMapOldToNewOutputPos
operator|!=
literal|null
operator|)
assert|;
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|mapCorVarToOutputPos
init|=
operator|new
name|TreeMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variablesStopped
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|RelNode
name|newRel
init|=
operator|new
name|JoinRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|newLeftRel
argument_list|,
name|newRightRel
argument_list|,
name|decorrelateExpr
argument_list|(
name|rel
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|,
name|rel
operator|.
name|getJoinType
argument_list|()
argument_list|,
name|variablesStopped
argument_list|)
decl_stmt|;
comment|// Create the mapping between the output of the old correlation rel
comment|// and the new join rel
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputPos
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|oldLeftFieldCount
init|=
name|oldLeftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|newLeftFieldCount
init|=
name|newLeftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|oldRightFieldCount
init|=
name|oldRightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|==
operator|(
name|oldLeftFieldCount
operator|+
name|oldRightFieldCount
operator|)
operator|)
assert|;
comment|// Left input positions are not changed.
name|mapOldToNewOutputPos
operator|.
name|putAll
argument_list|(
name|leftChildMapOldToNewOutputPos
argument_list|)
expr_stmt|;
comment|// Right input positions are shifted by newLeftFieldCount.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldRightFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|mapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|i
operator|+
name|oldLeftFieldCount
argument_list|,
name|rightChildMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|newLeftFieldCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newLeftRel
argument_list|)
condition|)
block|{
name|mapCorVarToOutputPos
operator|.
name|putAll
argument_list|(
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newLeftRel
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Right input positions are shifted by newLeftFieldCount.
name|int
name|oldRightPos
decl_stmt|;
if|if
condition|(
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newRightRel
argument_list|)
condition|)
block|{
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|rightChildMapCorVarToOutputPos
init|=
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newRightRel
argument_list|)
decl_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|rightChildMapCorVarToOutputPos
operator|.
name|keySet
argument_list|()
control|)
block|{
name|oldRightPos
operator|=
name|rightChildMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
expr_stmt|;
name|mapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|corVar
argument_list|,
name|oldRightPos
operator|+
name|newLeftFieldCount
argument_list|)
expr_stmt|;
block|}
block|}
name|mapOldToNewRel
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|newRel
argument_list|)
expr_stmt|;
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|put
argument_list|(
name|newRel
argument_list|,
name|mapOldToNewOutputPos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mapCorVarToOutputPos
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|put
argument_list|(
name|newRel
argument_list|,
name|mapCorVarToOutputPos
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|RexInputRef
name|getNewForOldInputRef
parameter_list|(
name|RexInputRef
name|oldInputRef
parameter_list|)
block|{
assert|assert
operator|(
name|currentRel
operator|!=
literal|null
operator|)
assert|;
name|int
name|oldOrdinal
init|=
name|oldInputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|newOrdinal
init|=
literal|0
decl_stmt|;
comment|// determine which input rel oldOrdinal references, and adjust
comment|// oldOrdinal to be relative to that input rel
name|List
argument_list|<
name|RelNode
argument_list|>
name|oldInputRels
init|=
name|currentRel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|RelNode
name|oldInputRel
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RelNode
name|oldInputRel0
range|:
name|oldInputRels
control|)
block|{
name|RelDataType
name|oldInputType
init|=
name|oldInputRel0
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|oldInputType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldOrdinal
operator|<
name|n
condition|)
block|{
name|oldInputRel
operator|=
name|oldInputRel0
expr_stmt|;
break|break;
block|}
name|RelNode
name|newInput
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldInputRel0
argument_list|)
decl_stmt|;
name|newOrdinal
operator|+=
name|newInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
name|oldOrdinal
operator|-=
name|n
expr_stmt|;
block|}
assert|assert
operator|(
name|oldInputRel
operator|!=
literal|null
operator|)
assert|;
name|RelNode
name|newInputRel
init|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldInputRel
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|newInputRel
operator|!=
literal|null
operator|)
assert|;
comment|// now oldOrdinal is relative to oldInputRel
name|int
name|oldLocalOrdinal
init|=
name|oldOrdinal
decl_stmt|;
comment|// figure out the newLocalOrdinal, relative to the newInputRel.
name|int
name|newLocalOrdinal
init|=
name|oldLocalOrdinal
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapOldToNewOutputPos
init|=
name|mapNewRelToMapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|newInputRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapOldToNewOutputPos
operator|!=
literal|null
condition|)
block|{
name|newLocalOrdinal
operator|=
name|mapOldToNewOutputPos
operator|.
name|get
argument_list|(
name|oldLocalOrdinal
argument_list|)
expr_stmt|;
block|}
name|newOrdinal
operator|+=
name|newLocalOrdinal
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|newOrdinal
argument_list|,
name|newInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|newLocalOrdinal
index|]
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Pull projRel above the joinRel from its RHS input. Enforce nullability      * for join output.      *      * @param joinRel Join      * @param projRel the orginal projRel as the RHS input of the join.      * @param nullIndicatorPos Position of null indicator      *      * @return the subtree with the new ProjectRel at the root      */
specifier|private
name|RelNode
name|projectJoinOutputWithNullability
parameter_list|(
name|JoinRel
name|joinRel
parameter_list|,
name|ProjectRel
name|projRel
parameter_list|,
name|int
name|nullIndicatorPos
parameter_list|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelNode
name|leftInputRel
init|=
name|joinRel
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|JoinRelType
name|joinType
init|=
name|joinRel
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|RexInputRef
name|nullIndicator
init|=
operator|new
name|RexInputRef
argument_list|(
name|nullIndicatorPos
argument_list|,
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
operator|(
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|nullIndicatorPos
index|]
operator|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|// now create the new project
name|List
argument_list|<
name|String
argument_list|>
name|newFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newProjExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
comment|// project everything from the LHS and then those from the original
comment|// projRel
name|RelDataTypeField
index|[]
name|leftInputFields
init|=
name|leftInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftInputFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RelDataType
name|newType
init|=
name|leftInputFields
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
decl_stmt|;
name|newProjExprs
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|newType
argument_list|)
argument_list|)
expr_stmt|;
name|newFieldNames
operator|.
name|add
argument_list|(
name|leftInputFields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Marked where the projected expr is coming from so that the types will
comment|// become nullable for the original projections which are now coming out
comment|// of the nullable side of the OJ.
name|boolean
name|projectPulledAboveLeftCorrelator
init|=
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
decl_stmt|;
name|RexNode
index|[]
name|projExprs
init|=
name|projRel
operator|.
name|getProjectExps
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projExprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|projExpr
init|=
name|projExprs
index|[
name|i
index|]
decl_stmt|;
name|RexNode
name|newProjExpr
init|=
name|removeCorrelationExpr
argument_list|(
name|projExpr
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
name|nullIndicator
argument_list|)
decl_stmt|;
name|newProjExprs
operator|.
name|add
argument_list|(
name|newProjExpr
argument_list|)
expr_stmt|;
name|newFieldNames
operator|.
name|add
argument_list|(
operator|(
name|projRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|newProjRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|joinRel
argument_list|,
name|newProjExprs
argument_list|,
name|newFieldNames
argument_list|)
decl_stmt|;
return|return
name|newProjRel
return|;
block|}
comment|/**      * Pulls projRel above the joinRel from its RHS input. Enforces nullability      * for join output.      *      * @param corRel Correlator      * @param projRel the orginal ProjectRel as the RHS input of the join      * @param isCount Positions which are calls to the<code>COUNT</code>      * aggregation function      *      * @return the subtree with the new ProjectRel at the root      */
specifier|private
name|RelNode
name|aggregateCorrelatorOutput
parameter_list|(
name|CorrelatorRel
name|corRel
parameter_list|,
name|ProjectRel
name|projRel
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
parameter_list|)
block|{
name|RelNode
name|leftInputRel
init|=
name|corRel
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|JoinRelType
name|joinType
init|=
name|corRel
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
comment|// now create the new project
name|List
argument_list|<
name|String
argument_list|>
name|newFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newProjExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
comment|// project everything from the LHS and then those from the original
comment|// projRel
name|RelDataTypeField
index|[]
name|leftInputFields
init|=
name|leftInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftInputFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RelDataType
name|newType
init|=
name|leftInputFields
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
decl_stmt|;
name|newProjExprs
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|newType
argument_list|)
argument_list|)
expr_stmt|;
name|newFieldNames
operator|.
name|add
argument_list|(
name|leftInputFields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Marked where the projected expr is coming from so that the types will
comment|// become nullable for the original projections which are now coming out
comment|// of the nullable side of the OJ.
name|boolean
name|projectPulledAboveLeftCorrelator
init|=
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
decl_stmt|;
name|RexNode
index|[]
name|projExprs
init|=
name|projRel
operator|.
name|getProjectExps
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projExprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|projExpr
init|=
name|projExprs
index|[
name|i
index|]
decl_stmt|;
name|RexNode
name|newProjExpr
init|=
name|removeCorrelationExpr
argument_list|(
name|projExpr
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
name|isCount
argument_list|)
decl_stmt|;
name|newProjExprs
operator|.
name|add
argument_list|(
name|newProjExpr
argument_list|)
expr_stmt|;
name|newFieldNames
operator|.
name|add
argument_list|(
operator|(
name|projRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|newProjRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|corRel
argument_list|,
name|newProjExprs
argument_list|,
name|newFieldNames
argument_list|)
decl_stmt|;
return|return
name|newProjRel
return|;
block|}
comment|/**      * Checks whether the correlations in projRel and filterRel are related to      * the correlated variables provided by corRel.      *      * @param corRel Correlator      * @param projRel the orginal ProjectRel as the RHS input of the join      * @param filterRel Filter      * @param correlatedJoinKeys Correlated join keys      *      * @return true if filter and proj only references corVar provided by corRel      */
specifier|private
name|boolean
name|checkCorVars
parameter_list|(
name|CorrelatorRel
name|corRel
parameter_list|,
name|ProjectRel
name|projRel
parameter_list|,
name|FilterRel
name|filterRel
parameter_list|,
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|correlatedJoinKeys
parameter_list|)
block|{
if|if
condition|(
name|filterRel
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|(
name|correlatedJoinKeys
operator|!=
literal|null
operator|)
assert|;
comment|// check that all correlated refs in the filter condition are
comment|// used in the join(as field access).
name|HashSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|corVarInFilter
init|=
operator|new
name|HashSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|()
decl_stmt|;
name|corVarInFilter
operator|.
name|addAll
argument_list|(
name|mapRefRelToCorVar
operator|.
name|get
argument_list|(
name|filterRel
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RexFieldAccess
name|correlatedJoinKey
range|:
name|correlatedJoinKeys
control|)
block|{
name|corVarInFilter
operator|.
name|remove
argument_list|(
name|mapFieldAccessToCorVar
operator|.
name|get
argument_list|(
name|correlatedJoinKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|corVarInFilter
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check that the correlated variables referenced in these
comment|// comparisons do come from the correlatorRel.
name|corVarInFilter
operator|.
name|addAll
argument_list|(
name|mapRefRelToCorVar
operator|.
name|get
argument_list|(
name|filterRel
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|corVarInFilter
control|)
block|{
if|if
condition|(
name|mapCorVarToCorRel
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|!=
name|corRel
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// if projRel has any correlated reference, make sure they are also
comment|// provided by the current corRel. They will be projected out of the LHS
comment|// of the corRel.
if|if
condition|(
operator|(
name|projRel
operator|!=
literal|null
operator|)
operator|&&
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|projRel
argument_list|)
condition|)
block|{
name|SortedSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|corVarInProj
init|=
name|mapRefRelToCorVar
operator|.
name|get
argument_list|(
name|projRel
argument_list|)
decl_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|corVarInProj
control|)
block|{
if|if
condition|(
name|mapCorVarToCorRel
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|!=
name|corRel
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Remove correlated variables from the tree at root corRel      *      * @param corRel Correlator      */
specifier|private
name|void
name|removeCorVarFromTree
parameter_list|(
name|CorrelatorRel
name|corRel
parameter_list|)
block|{
name|HashSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|corVarSet
init|=
operator|new
name|HashSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|()
decl_stmt|;
name|corVarSet
operator|.
name|addAll
argument_list|(
name|mapCorVarToCorRel
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|corVarSet
control|)
block|{
if|if
condition|(
name|mapCorVarToCorRel
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|==
name|corRel
condition|)
block|{
name|mapCorVarToCorRel
operator|.
name|remove
argument_list|(
name|corVar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Project all childRel output fields plus the additional expressions.      *      * @param childRel Child relational expression      * @param additionalExprs Additional expressions      * @param additionalExprNames Names of additional expressions      *      * @return the new ProjectRel      */
specifier|private
name|RelNode
name|createProjectWithAdditionalExprs
parameter_list|(
name|RelNode
name|childRel
parameter_list|,
name|RexNode
index|[]
name|additionalExprs
parameter_list|,
name|String
index|[]
name|additionalExprNames
parameter_list|)
block|{
name|boolean
name|useNewNames
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|additionalExprNames
operator|!=
literal|null
condition|)
block|{
name|useNewNames
operator|=
literal|true
expr_stmt|;
block|}
name|RelDataType
name|childFieldType
init|=
name|childRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|childFieldCount
init|=
name|childFieldType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RexNode
index|[]
name|exprs
init|=
operator|new
name|RexNode
index|[
name|childFieldCount
operator|+
name|additionalExprs
operator|.
name|length
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|childFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|exprs
index|[
name|i
index|]
operator|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|childFieldType
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|exprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|exprs
index|[
name|i
index|]
operator|=
name|additionalExprs
index|[
name|i
operator|-
name|childFieldCount
index|]
expr_stmt|;
block|}
name|String
index|[]
name|exprNames
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|useNewNames
condition|)
block|{
name|exprNames
operator|=
operator|new
name|String
index|[
name|childFieldCount
operator|+
name|additionalExprs
operator|.
name|length
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|childFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|exprNames
index|[
name|i
index|]
operator|=
name|childFieldType
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|exprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|exprNames
index|[
name|i
index|]
operator|=
name|additionalExprNames
index|[
name|i
operator|-
name|childFieldCount
index|]
expr_stmt|;
block|}
block|}
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|childRel
argument_list|,
name|exprs
argument_list|,
name|exprNames
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|private
class|class
name|DecorrelateRelVisitor
extends|extends
name|RelVisitor
block|{
specifier|private
specifier|final
name|ReflectiveVisitDispatcher
argument_list|<
name|RelDecorrelator
argument_list|,
name|RelNode
argument_list|>
name|dispatcher
init|=
name|ReflectUtil
operator|.
name|createDispatcher
argument_list|(
name|RelDecorrelator
operator|.
name|class
argument_list|,
name|RelNode
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// implement RelVisitor
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
comment|// rewrite children first  (from left to right)
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|currentRel
operator|=
name|p
expr_stmt|;
specifier|final
name|String
name|visitMethodName
init|=
literal|"decorrelateRel"
decl_stmt|;
name|boolean
name|found
init|=
name|dispatcher
operator|.
name|invokeVisitor
argument_list|(
name|RelDecorrelator
operator|.
name|this
argument_list|,
name|currentRel
argument_list|,
name|visitMethodName
argument_list|)
decl_stmt|;
name|currentRel
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|decorrelateRelGeneric
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|// else no rewrite will occur. This will terminate the bottom-up
comment|// rewrite. If root node of a RelNode tree is not rewritten, the
comment|// original tree will be returned. See decorrelate() method.
block|}
block|}
specifier|private
class|class
name|DecorrelateRexShuttle
extends|extends
name|RexShuttle
block|{
comment|// override RexShuttle
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
name|int
name|newInputRelOutputOffset
init|=
literal|0
decl_stmt|;
name|RelNode
name|oldInputRel
decl_stmt|;
name|RelNode
name|newInputRel
decl_stmt|;
name|Integer
name|newInputPos
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|currentRel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|oldInputRel
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|newInputRel
operator|=
name|mapOldToNewRel
operator|.
name|get
argument_list|(
name|oldInputRel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newInputRel
operator|!=
literal|null
operator|)
operator|&&
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|containsKey
argument_list|(
name|newInputRel
argument_list|)
condition|)
block|{
name|SortedMap
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|,
name|Integer
argument_list|>
name|childMapCorVarToOutputPos
init|=
name|mapNewRelToMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|newInputRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|childMapCorVarToOutputPos
operator|!=
literal|null
condition|)
block|{
comment|// try to find in this input rel the position of cor var
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
init|=
name|mapFieldAccessToCorVar
operator|.
name|get
argument_list|(
name|fieldAccess
argument_list|)
decl_stmt|;
if|if
condition|(
name|corVar
operator|!=
literal|null
condition|)
block|{
name|newInputPos
operator|=
name|childMapCorVarToOutputPos
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
expr_stmt|;
if|if
condition|(
name|newInputPos
operator|!=
literal|null
condition|)
block|{
comment|// this input rel does produce the cor var
comment|// referenced
name|newInputPos
operator|+=
name|newInputRelOutputOffset
expr_stmt|;
comment|// fieldAccess is assumed to have the correct
comment|// type info.
name|RexInputRef
name|newInput
init|=
operator|new
name|RexInputRef
argument_list|(
name|newInputPos
argument_list|,
name|fieldAccess
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|newInput
return|;
block|}
block|}
block|}
comment|// this input rel does not produce the cor var needed
name|newInputRelOutputOffset
operator|+=
name|newInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// this input rel is not rewritten
name|newInputRelOutputOffset
operator|+=
name|oldInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|fieldAccess
return|;
block|}
comment|// override RexShuttle
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|RexInputRef
name|newInputRef
init|=
name|getNewForOldInputRef
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
return|return
name|newInputRef
return|;
block|}
block|}
specifier|private
class|class
name|RemoveCorrelationRexShuttle
extends|extends
name|RexShuttle
block|{
name|RexBuilder
name|rexBuilder
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
name|boolean
name|projectPulledAboveLeftCorrelator
decl_stmt|;
name|RexInputRef
name|nullIndicator
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
decl_stmt|;
specifier|public
name|RemoveCorrelationRexShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RemoveCorrelationRexShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|,
name|RexInputRef
name|nullIndicator
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
name|nullIndicator
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RemoveCorrelationRexShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|projectPulledAboveLeftCorrelator
argument_list|,
literal|null
argument_list|,
name|isCount
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RemoveCorrelationRexShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|boolean
name|projectPulledAboveLeftCorrelator
parameter_list|,
name|RexInputRef
name|nullIndicator
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
parameter_list|)
block|{
name|this
operator|.
name|projectPulledAboveLeftCorrelator
operator|=
name|projectPulledAboveLeftCorrelator
expr_stmt|;
name|this
operator|.
name|nullIndicator
operator|=
name|nullIndicator
expr_stmt|;
name|this
operator|.
name|isCount
operator|=
name|isCount
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
expr_stmt|;
block|}
specifier|private
name|RexNode
name|createCaseExpression
parameter_list|(
name|RexInputRef
name|nullInputRef
parameter_list|,
name|RexLiteral
name|lit
parameter_list|,
name|RexNode
name|rexNode
parameter_list|)
block|{
name|RexNode
index|[]
name|caseOperands
init|=
operator|new
name|RexNode
index|[
literal|3
index|]
decl_stmt|;
comment|// Construct a CASE expression to handle the null indicator.
comment|//
comment|// This also covers the case where a left correlated subquery
comment|// projects fields from outer relation. Since LOJ cannot produce
comment|// nulls on the LHS, the projection now need to make a nullable LHS
comment|// reference using a nullability indicator. If this this indicator
comment|// is null, it means the subquery does not produce any value. As a
comment|// result, any RHS ref by this usbquery needs to produce null value.
comment|// WHEN indicator IS NULL
name|caseOperands
index|[
literal|0
index|]
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNullOperator
argument_list|,
operator|new
name|RexInputRef
argument_list|(
name|nullInputRef
operator|.
name|getIndex
argument_list|()
argument_list|,
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|nullInputRef
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// THEN CAST(NULL AS newInputTypeNullable)
name|caseOperands
index|[
literal|1
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rexNode
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|lit
argument_list|)
expr_stmt|;
comment|// ELSE cast (newInput AS newInputTypeNullable) END
name|caseOperands
index|[
literal|2
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|rexNode
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|rexNode
argument_list|)
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|caseOperands
argument_list|)
return|;
block|}
comment|// override RexShuttle
specifier|public
name|RexNode
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
if|if
condition|(
name|mapFieldAccessToCorVar
operator|.
name|containsKey
argument_list|(
name|fieldAccess
argument_list|)
condition|)
block|{
comment|// if it is a corVar, change it to be input ref.
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
init|=
name|mapFieldAccessToCorVar
operator|.
name|get
argument_list|(
name|fieldAccess
argument_list|)
decl_stmt|;
comment|// corVar offset shuold point to the leftInput of currentRel,
comment|// which is the CorrelatorRel.
name|RexNode
name|newRexNode
init|=
operator|new
name|RexInputRef
argument_list|(
name|corVar
operator|.
name|getOffset
argument_list|()
argument_list|,
name|fieldAccess
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|projectPulledAboveLeftCorrelator
operator|&&
operator|(
name|nullIndicator
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// need to enforce nullability by applying an additional
comment|// cast operator over the transformed expression.
name|newRexNode
operator|=
name|createCaseExpression
argument_list|(
name|nullIndicator
argument_list|,
name|rexBuilder
operator|.
name|constantNull
argument_list|()
argument_list|,
name|newRexNode
argument_list|)
expr_stmt|;
block|}
return|return
name|newRexNode
return|;
block|}
return|return
name|fieldAccess
return|;
block|}
comment|// override RexShuttle
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
operator|(
name|currentRel
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|currentRel
operator|instanceof
name|CorrelatorRel
operator|)
condition|)
block|{
comment|// if this rel references corVar
comment|// and now it needs to be rewritten
comment|// it must have been pulled above the CorrelatorRel
comment|// replace the input ref to account for the LHS of the
comment|// CorrelatorRel
name|int
name|leftInputFieldCount
init|=
operator|(
operator|(
name|CorrelatorRel
operator|)
name|currentRel
operator|)
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RelDataType
name|newType
init|=
name|inputRef
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|projectPulledAboveLeftCorrelator
condition|)
block|{
name|newType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|newType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|int
name|pos
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|RexInputRef
name|newInputRef
init|=
operator|new
name|RexInputRef
argument_list|(
name|leftInputFieldCount
operator|+
name|pos
argument_list|,
name|newType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|isCount
operator|!=
literal|null
operator|)
operator|&&
name|isCount
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
block|{
return|return
name|createCaseExpression
argument_list|(
name|newInputRef
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
argument_list|,
name|newInputRef
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|newInputRef
return|;
block|}
block|}
return|return
name|inputRef
return|;
block|}
comment|// override RexLiteral
specifier|public
name|RexNode
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
comment|// Use nullIndicator to decide whether to project null.
comment|// Do nothing if the literal is null.
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|isNull
argument_list|(
name|literal
argument_list|)
operator|&&
name|projectPulledAboveLeftCorrelator
operator|&&
operator|(
name|nullIndicator
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
name|createCaseExpression
argument_list|(
name|nullIndicator
argument_list|,
name|rexBuilder
operator|.
name|constantNull
argument_list|()
argument_list|,
name|literal
argument_list|)
return|;
block|}
return|return
name|literal
return|;
block|}
specifier|public
name|RexNode
name|visitCall
parameter_list|(
specifier|final
name|RexCall
name|call
parameter_list|)
block|{
name|RexNode
name|newCall
decl_stmt|;
name|boolean
index|[]
name|update
init|=
block|{
literal|false
block|}
decl_stmt|;
name|RexNode
index|[]
name|clonedOperands
init|=
name|visitArray
argument_list|(
name|call
operator|.
name|operands
argument_list|,
name|update
argument_list|)
decl_stmt|;
if|if
condition|(
name|update
index|[
literal|0
index|]
condition|)
block|{
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
name|boolean
name|isSpecialCast
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|operator
operator|instanceof
name|SqlFunction
condition|)
block|{
name|SqlFunction
name|function
init|=
operator|(
name|SqlFunction
operator|)
name|operator
decl_stmt|;
if|if
condition|(
name|function
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|operands
operator|.
name|length
operator|<
literal|2
condition|)
block|{
name|isSpecialCast
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isSpecialCast
condition|)
block|{
comment|// TODO: ideally this only needs to be called if the result
comment|// type will also change. However, since that requires
comment|// suport from type inference rules to tell whether a rule
comment|// decides return type based on input types, for now all
comment|// operators will be recreated with new type if any operand
comment|// changed, unless the operator has "built-in" type.
name|newCall
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|operator
argument_list|,
name|clonedOperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use the current return type when creating a new call, for
comment|// operators with return type built into the operator
comment|// definition, and with no type inference rules, such as
comment|// cast function with less than 2 operands.
comment|// TODO: Comments in RexShuttle.visitCall() mention other
comment|// types in this catagory. Need to resolve those together
comment|// and preferrably in the base class RexShuttle.
name|newCall
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|operator
argument_list|,
name|clonedOperands
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|newCall
operator|=
name|call
expr_stmt|;
block|}
if|if
condition|(
name|projectPulledAboveLeftCorrelator
operator|&&
operator|(
name|nullIndicator
operator|!=
literal|null
operator|)
condition|)
block|{
return|return
name|createCaseExpression
argument_list|(
name|nullIndicator
argument_list|,
name|rexBuilder
operator|.
name|constantNull
argument_list|()
argument_list|,
name|newCall
argument_list|)
return|;
block|}
return|return
name|newCall
return|;
block|}
block|}
comment|/**      * Rule to remove single_value rel. For cases like      *      *<blockquote>AggRel single_value proj/filter/agg/ join on unique LHS key      * AggRel single group</blockquote>      */
specifier|private
specifier|final
class|class
name|RemoveSingleAggregateRule
extends|extends
name|RelOptRule
block|{
specifier|public
name|RemoveSingleAggregateRule
parameter_list|()
block|{
name|super
argument_list|(
name|some
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|,
name|some
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|AggregateRel
name|singleAggRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ProjectRel
name|projRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|AggregateRel
name|aggRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// check singleAggRel is single_value agg
if|if
condition|(
operator|(
operator|!
name|singleAggRel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|singleAggRel
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
operator|||
operator|!
operator|(
name|singleAggRel
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlSingleValueAggFunction
operator|)
condition|)
block|{
return|return;
block|}
comment|// check projRel only projects one expression
comment|// check this project only projects one expression, i.e. scalar
comment|// subqueries.
name|RexNode
index|[]
name|projExprs
init|=
name|projRel
operator|.
name|getProjectExps
argument_list|()
decl_stmt|;
if|if
condition|(
name|projExprs
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
comment|// check the input to projRel is an aggregate on the entire input
if|if
condition|(
operator|!
name|aggRel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// singleAggRel produces a nullable type, so create the new
comment|// projection that casts proj expr to a nullable type.
name|RexNode
index|[]
name|newProjExprs
init|=
operator|new
name|RexNode
index|[
literal|1
index|]
decl_stmt|;
name|newProjExprs
index|[
literal|0
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|projRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|projExprs
index|[
literal|0
index|]
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|projExprs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|RelNode
name|newProjRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|aggRel
argument_list|,
name|newProjExprs
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProjRel
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
class|class
name|RemoveCorrelationForScalarProjectRule
extends|extends
name|RelOptRule
block|{
specifier|public
name|RemoveCorrelationForScalarProjectRule
parameter_list|()
block|{
name|super
argument_list|(
name|some
argument_list|(
name|CorrelatorRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|RelNode
operator|.
name|class
argument_list|)
argument_list|,
name|some
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|,
name|some
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|RelNode
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|CorrelatorRel
name|corRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|leftInputRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|AggregateRel
name|aggRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|ProjectRel
name|projRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|RelNode
name|rightInputRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|RelOptCluster
name|cluster
init|=
name|corRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
name|currentRel
operator|=
name|corRel
expr_stmt|;
comment|// Check for this pattern.
comment|// The pattern matching could be simplified if rules can be applied
comment|// during decorrelation.
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   AggregateRel (groupby (0) single_value())
comment|//     ProjectRel-A (may reference coVar)
comment|//       RightInputRel
name|JoinRelType
name|joinType
init|=
name|corRel
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|RexNode
name|joinCond
init|=
name|corRel
operator|.
name|getCondition
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|||
operator|(
name|joinCond
operator|!=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
comment|// check that the agg is of the following type:
comment|// doing a single_value() on the entire input
if|if
condition|(
operator|(
operator|!
name|aggRel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|aggRel
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
operator|||
operator|!
operator|(
name|aggRel
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlSingleValueAggFunction
operator|)
condition|)
block|{
return|return;
block|}
comment|// check this project only projects one expression, i.e. scalar
comment|// subqueries.
if|if
condition|(
name|projRel
operator|.
name|getProjectExps
argument_list|()
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
name|int
name|nullIndicatorPos
decl_stmt|;
if|if
condition|(
operator|(
name|rightInputRel
operator|instanceof
name|FilterRel
operator|)
operator|&&
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|rightInputRel
argument_list|)
condition|)
block|{
comment|// rightInputRel has this shape:
comment|//
comment|//       FilterRel (references corvar)
comment|//         FilterInputRel
comment|// If rightInputRel is a filter and contains correlated
comment|// reference, make sure the correlated keys in the filter
comment|// condition forms a unique key of the RHS.
name|FilterRel
name|filterRel
init|=
operator|(
name|FilterRel
operator|)
name|rightInputRel
decl_stmt|;
name|rightInputRel
operator|=
name|filterRel
operator|.
name|getChild
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|rightInputRel
operator|instanceof
name|HepRelVertex
operator|)
assert|;
name|rightInputRel
operator|=
operator|(
operator|(
name|HepRelVertex
operator|)
name|rightInputRel
operator|)
operator|.
name|getCurrentRel
argument_list|()
expr_stmt|;
comment|// check filter input contains no correlation
if|if
condition|(
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rightInputRel
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
comment|// extract the correlation out of the filterRel
comment|// First breaking up the filter conditions into equality
comment|// comparisons between rightJoinKeys(from the original
comment|// filterInputRel) and correlatedJoinKeys. correlatedJoinKeys
comment|// can be expressions, while rightJoinKeys need to be input
comment|// refs. These comparisons are AND'ed together.
name|List
argument_list|<
name|RexNode
argument_list|>
name|tmpRightJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|tmpRightJoinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// check that the columns referenced in these comparisons form
comment|// an unique key of the filterInputRel
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|rightJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexInputRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tmpRightJoinKeys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
assert|assert
operator|(
name|tmpRightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
assert|;
name|rightJoinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|tmpRightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check that the columns referenced in rightJoinKeys form an
comment|// unique key of the filterInputRel
if|if
condition|(
name|rightJoinKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// The join filters out the nulls.  So, it's ok if there are
comment|// nulls in the join keys.
if|if
condition|(
operator|!
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUniqueWhenNullsFiltered
argument_list|(
name|rightInputRel
argument_list|,
name|rightJoinKeys
argument_list|)
condition|)
block|{
name|sqlToRelTracer
operator|.
name|fine
argument_list|(
name|rightJoinKeys
operator|.
name|toString
argument_list|()
operator|+
literal|"are not unique keys for "
operator|+
name|rightInputRel
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|RexUtil
operator|.
name|FieldAccessFinder
name|visitor
init|=
operator|new
name|RexUtil
operator|.
name|FieldAccessFinder
argument_list|()
decl_stmt|;
name|RexUtil
operator|.
name|apply
argument_list|(
name|visitor
argument_list|,
name|correlatedJoinKeys
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|correlatedKeyList
init|=
name|visitor
operator|.
name|getFieldAccessList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|checkCorVars
argument_list|(
name|corRel
argument_list|,
name|projRel
argument_list|,
name|filterRel
argument_list|,
name|correlatedKeyList
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Change the plan to this structure.
comment|// Note that the aggregateRel is removed.
comment|//
comment|// ProjectRel-A' (replace corvar to input ref from the JoinRel)
comment|//   JoinRel (replace corvar to input ref from LeftInputRel)
comment|//     LeftInputRel
comment|//     RightInputRel(oreviously FilterInputRel)
comment|// Change the filter condition into a join condition
name|joinCond
operator|=
name|removeCorrelationExpr
argument_list|(
name|filterRel
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|nullIndicatorPos
operator|=
name|leftInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|rightJoinKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getIndex
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|projRel
argument_list|)
condition|)
block|{
comment|// check filter input contains no correlation
if|if
condition|(
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rightInputRel
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|checkCorVars
argument_list|(
name|corRel
argument_list|,
name|projRel
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Change the plan to this structure.
comment|//
comment|// ProjectRel-A' (replace corvar to input ref from JoinRel)
comment|//   JoinRel (left, condition = true)
comment|//     LeftInputRel
comment|//     AggregateRel(groupby(0), single_value(0), s_v(1)....)
comment|//       ProjectRel-B (everything from input plus literal true)
comment|//         ProjInputRel
comment|// make the new projRel to provide a null indicator
name|rightInputRel
operator|=
name|createProjectWithAdditionalExprs
argument_list|(
name|rightInputRel
argument_list|,
operator|new
name|RexNode
index|[]
block|{
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"nullIndicator"
block|}
argument_list|)
expr_stmt|;
comment|// make the new aggRel
name|rightInputRel
operator|=
name|RelOptUtil
operator|.
name|createSingleValueAggRel
argument_list|(
name|cluster
argument_list|,
name|rightInputRel
argument_list|)
expr_stmt|;
comment|// The last field:
comment|//     single_value(true)
comment|// is the nullIndicator
name|nullIndicatorPos
operator|=
name|leftInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|rightInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
comment|// make the new join rel
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variablesStopped
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|JoinRel
name|joinRel
init|=
operator|new
name|JoinRel
argument_list|(
name|corRel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|leftInputRel
argument_list|,
name|rightInputRel
argument_list|,
name|joinCond
argument_list|,
name|joinType
argument_list|,
name|variablesStopped
argument_list|)
decl_stmt|;
name|RelNode
name|newProjRel
init|=
name|projectJoinOutputWithNullability
argument_list|(
name|joinRel
argument_list|,
name|projRel
argument_list|,
name|nullIndicatorPos
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProjRel
argument_list|)
expr_stmt|;
name|removeCorVarFromTree
argument_list|(
name|corRel
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
class|class
name|RemoveCorrelationForScalarAggregateRule
extends|extends
name|RelOptRule
block|{
specifier|public
name|RemoveCorrelationForScalarAggregateRule
parameter_list|()
block|{
name|super
argument_list|(
name|some
argument_list|(
name|CorrelatorRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|RelNode
operator|.
name|class
argument_list|)
argument_list|,
name|some
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|some
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|,
name|some
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|RelNode
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|CorrelatorRel
name|corRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|leftInputRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ProjectRel
name|aggOutputProjRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|AggregateRel
name|aggRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|ProjectRel
name|aggInputProjRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|RelNode
name|rightInputRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|RelOptCluster
name|cluster
init|=
name|corRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
name|currentRel
operator|=
name|corRel
expr_stmt|;
comment|// check for this pattern
comment|// The pattern matching could be simplified if rules can be applied
comment|// during decorrelation,
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   ProjectRel-A (a RexNode)
comment|//     AggregateRel (groupby (0), agg0(), agg1()...)
comment|//       ProjectRel-B (references coVar)
comment|//         rightInputRel
comment|// check aggOutputProj projects only one expression
name|RexNode
index|[]
name|aggOutputProjExprs
init|=
name|aggOutputProjRel
operator|.
name|getProjectExps
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggOutputProjExprs
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
name|JoinRelType
name|joinType
init|=
name|corRel
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|RexNode
name|joinCond
init|=
name|corRel
operator|.
name|getCondition
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|||
operator|(
name|joinCond
operator|!=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
comment|// check that the agg is on the entire input
if|if
condition|(
operator|!
name|aggRel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|RexNode
index|[]
name|aggInputProjExprs
init|=
name|aggInputProjRel
operator|.
name|getProjectExps
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
name|aggRel
operator|.
name|getAggCallList
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCountStar
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// mark if agg produces count(*) which needs to reference the
comment|// nullIndicator after the transformation.
name|int
name|k
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
operator|++
name|k
expr_stmt|;
if|if
condition|(
operator|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlCountAggFunction
operator|)
operator|&&
operator|(
name|aggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|isCountStar
operator|.
name|add
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rightInputRel
operator|instanceof
name|FilterRel
operator|)
operator|&&
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|rightInputRel
argument_list|)
condition|)
block|{
comment|// rightInputRel has this shape:
comment|//
comment|//       FilterRel (references corvar)
comment|//         FilterInputRel
name|FilterRel
name|filterRel
init|=
operator|(
name|FilterRel
operator|)
name|rightInputRel
decl_stmt|;
name|rightInputRel
operator|=
name|filterRel
operator|.
name|getChild
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|rightInputRel
operator|instanceof
name|HepRelVertex
operator|)
assert|;
name|rightInputRel
operator|=
operator|(
operator|(
name|HepRelVertex
operator|)
name|rightInputRel
operator|)
operator|.
name|getCurrentRel
argument_list|()
expr_stmt|;
comment|// check filter input contains no correlation
if|if
condition|(
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rightInputRel
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
comment|// check filter condition type First extract the correlation out
comment|// of the filterRel
comment|// First breaking up the filter conditions into equality
comment|// comparisons between rightJoinKeys(from the original
comment|// filterInputRel) and correlatedJoinKeys. correlatedJoinKeys
comment|// can only be RexFieldAccess, while rightJoinKeys can be
comment|// expressions. These comparisons are AND'ed together.
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|tmpCorrelatedJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|rightJoinKeys
argument_list|,
name|tmpCorrelatedJoinKeys
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// make sure the correlated reference forms a unique key check
comment|// that the columns referenced in these comparisons form an
comment|// unique key of the leftInputRel
name|List
argument_list|<
name|RexFieldAccess
argument_list|>
name|correlatedJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexFieldAccess
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|correlatedInputRefJoinKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|RexInputRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|joinKey
range|:
name|tmpCorrelatedJoinKeys
control|)
block|{
assert|assert
name|joinKey
operator|instanceof
name|RexFieldAccess
assert|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexFieldAccess
operator|)
name|joinKey
argument_list|)
expr_stmt|;
name|RexNode
name|correlatedInputRef
init|=
name|removeCorrelationExpr
argument_list|(
name|joinKey
argument_list|,
literal|false
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|correlatedInputRef
operator|instanceof
name|RexInputRef
operator|)
assert|;
name|correlatedInputRefJoinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|correlatedInputRef
argument_list|)
expr_stmt|;
block|}
comment|// check that the columns referenced in rightJoinKeys form an
comment|// unique key of the filterInputRel
if|if
condition|(
name|correlatedInputRefJoinKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// The join filters out the nulls.  So, it's ok if there are
comment|// nulls in the join keys.
if|if
condition|(
operator|!
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUniqueWhenNullsFiltered
argument_list|(
name|leftInputRel
argument_list|,
name|correlatedInputRefJoinKeys
argument_list|)
condition|)
block|{
name|sqlToRelTracer
operator|.
name|fine
argument_list|(
name|correlatedJoinKeys
operator|.
name|toString
argument_list|()
operator|+
literal|"are not unique keys for "
operator|+
name|leftInputRel
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// check cor var references are valid
if|if
condition|(
operator|!
name|checkCorVars
argument_list|(
name|corRel
argument_list|,
name|aggInputProjRel
argument_list|,
name|filterRel
argument_list|,
name|correlatedJoinKeys
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Rewrite the above plan:
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   ProjectRel-A (a RexNode)
comment|//     AggregateRel (groupby(0), agg0(),agg1()...)
comment|//       ProjectRel-B (may reference coVar)
comment|//         FilterRel (references corVar)
comment|//           RightInputRel (no correlated reference)
comment|//
comment|// to this plan:
comment|//
comment|// ProjectRel-A' (all gby keys + rewritten nullable ProjExpr)
comment|//   AggregateRel (groupby(all left input refs)
comment|//                 agg0(rewritten expression),
comment|//                 agg1()...)
comment|//     ProjectRel-B' (rewriten original projected exprs)
comment|//       JoinRel(replace corvar w/ input ref from LeftInputRel)
comment|//         LeftInputRel
comment|//         RightInputRel
comment|//
comment|// In the case where agg is count(*) or count($corVar), it is
comment|// changed to count(nullIndicator).
comment|// Note:  any non-nullable field from the RHS can be used as
comment|// the indicator however a "true" field is added to the
comment|// projection list from the RHS for simplicity to avoid
comment|// searching for non-null fields.
comment|//
comment|// ProjectRel-A' (all gby keys + rewritten nullable ProjExpr)
comment|//   AggregateRel (groupby(all left input refs),
comment|//                 count(nullIndicator), other aggs...)
comment|//     ProjectRel-B' (all left input refs plus
comment|//                    the rewritten original projected exprs)
comment|//       JoinRel(replace corvar to input ref from LeftInputRel)
comment|//         LeftInputRel
comment|//         ProjectRel (everything from RightInputRel plus
comment|//                     the nullIndicator "true")
comment|//           RightInputRel
comment|//
comment|// first change the filter condition into a join condition
name|joinCond
operator|=
name|removeCorrelationExpr
argument_list|(
name|filterRel
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|mapRefRelToCorVar
operator|.
name|containsKey
argument_list|(
name|aggInputProjRel
argument_list|)
condition|)
block|{
comment|// check rightInputRel contains no correlation
if|if
condition|(
name|RelOptUtil
operator|.
name|getVariablesUsed
argument_list|(
name|rightInputRel
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
comment|// check cor var references are valid
if|if
condition|(
operator|!
name|checkCorVars
argument_list|(
name|corRel
argument_list|,
name|aggInputProjRel
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
condition|)
block|{
return|return;
block|}
name|int
name|nFields
init|=
name|leftInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|BitSet
name|allCols
init|=
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|0
argument_list|,
name|nFields
argument_list|)
decl_stmt|;
comment|// leftInputRel contains unique keys
comment|// i.e. each row is distinct and can group by on all the left
comment|// fields
if|if
condition|(
operator|!
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUnique
argument_list|(
name|leftInputRel
argument_list|,
name|allCols
argument_list|)
condition|)
block|{
name|sqlToRelTracer
operator|.
name|fine
argument_list|(
literal|"There are no unique keys for "
operator|+
name|leftInputRel
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//
comment|// Rewrite the above plan:
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   ProjectRel-A (a RexNode)
comment|//     AggregateRel (groupby(0), agg0(), agg1()...)
comment|//       ProjectRel-B (references coVar)
comment|//         RightInputRel (no correlated reference)
comment|//
comment|// to this plan:
comment|//
comment|// ProjectRel-A' (all gby keys + rewritten nullable ProjExpr)
comment|//   AggregateRel (groupby(all left input refs)
comment|//                 agg0(rewritten expression),
comment|//                 agg1()...)
comment|//     ProjectRel-B' (rewriten original projected exprs)
comment|//       JoinRel (LOJ cond = true)
comment|//         LeftInputRel
comment|//         RightInputRel
comment|//
comment|// In the case where agg is count($corVar), it is changed to
comment|// count(nullIndicator).
comment|// Note:  any non-nullable field from the RHS can be used as
comment|// the indicator however a "true" field is added to the
comment|// projection list from the RHS for simplicity to avoid
comment|// searching for non-null fields.
comment|//
comment|// ProjectRel-A' (all gby keys + rewritten nullable ProjExpr)
comment|//   AggregateRel (groupby(all left input refs),
comment|//                 count(nullIndicator), other aggs...)
comment|//     ProjectRel-B' (all left input refs plus
comment|//                    the rewritten original projected exprs)
comment|//       JoinRel(replace corvar to input ref from LeftInputRel)
comment|//         LeftInputRel
comment|//         ProjectRel (everything from RightInputRel plus
comment|//                     the nullIndicator "true")
comment|//           RightInputRel
block|}
else|else
block|{
return|return;
block|}
name|RelDataType
name|leftInputFieldType
init|=
name|leftInputRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|leftInputFieldCount
init|=
name|leftInputFieldType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|joinOutputProjExprCount
init|=
name|leftInputFieldCount
operator|+
name|aggInputProjExprs
operator|.
name|length
operator|+
literal|1
decl_stmt|;
name|rightInputRel
operator|=
name|createProjectWithAdditionalExprs
argument_list|(
name|rightInputRel
argument_list|,
operator|new
name|RexNode
index|[]
block|{
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"nullIndicator"
block|}
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variablesStopped
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|JoinRel
name|joinRel
init|=
operator|new
name|JoinRel
argument_list|(
name|cluster
argument_list|,
name|leftInputRel
argument_list|,
name|rightInputRel
argument_list|,
name|joinCond
argument_list|,
name|joinType
argument_list|,
name|variablesStopped
argument_list|)
decl_stmt|;
comment|// To the consumer of joinOutputProjRel, nullIndicator is located
comment|// at the end
name|int
name|nullIndicatorPos
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
decl_stmt|;
name|RexInputRef
name|nullIndicator
init|=
operator|new
name|RexInputRef
argument_list|(
name|nullIndicatorPos
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
operator|(
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|nullIndicatorPos
index|]
operator|)
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|// first project all the groupby keys plus the transformed agg input
name|RexNode
index|[]
name|joinOutputProjExprs
init|=
operator|new
name|RexNode
index|[
name|joinOutputProjExprCount
index|]
decl_stmt|;
comment|// LOJ Join preserves LHS types
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftInputFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|joinOutputProjExprs
index|[
name|i
index|]
operator|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|leftInputFieldType
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggInputProjExprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|joinOutputProjExprs
index|[
name|i
operator|+
name|leftInputFieldCount
index|]
operator|=
name|removeCorrelationExpr
argument_list|(
name|aggInputProjExprs
index|[
name|i
index|]
argument_list|,
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
argument_list|,
name|nullIndicator
argument_list|)
expr_stmt|;
block|}
name|joinOutputProjExprs
index|[
name|joinOutputProjExprCount
operator|-
literal|1
index|]
operator|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|nullIndicatorPos
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|nullIndicatorPos
argument_list|)
expr_stmt|;
name|RelNode
name|joinOutputProjRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|joinRel
argument_list|,
name|joinOutputProjExprs
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// nullIndicator is now at a different location in the output of
comment|// the join
name|nullIndicatorPos
operator|=
name|joinOutputProjExprCount
operator|-
literal|1
expr_stmt|;
specifier|final
name|int
name|groupCount
init|=
name|leftInputFieldCount
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newAggCalls
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregateCall
argument_list|>
argument_list|()
decl_stmt|;
name|k
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
operator|++
name|k
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|aggArgs
init|=
name|aggCall
operator|.
name|getArgList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|newAggArgs
decl_stmt|;
if|if
condition|(
name|isCountStar
operator|.
name|contains
argument_list|(
name|k
argument_list|)
condition|)
block|{
comment|// this is a count(*), transform it to count(nullIndicator)
comment|// the null indicator is located at the end
name|newAggArgs
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|nullIndicatorPos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newAggArgs
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Integer
name|aggArg
range|:
name|aggArgs
control|)
block|{
name|newAggArgs
operator|.
name|add
argument_list|(
name|aggArg
operator|+
name|groupCount
argument_list|)
expr_stmt|;
block|}
block|}
name|newAggCalls
operator|.
name|add
argument_list|(
operator|new
name|AggregateCall
argument_list|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|aggCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|newAggArgs
argument_list|,
name|aggCall
operator|.
name|getType
argument_list|()
argument_list|,
name|aggCall
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BitSet
name|groupSet
init|=
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|0
argument_list|,
name|groupCount
argument_list|)
decl_stmt|;
name|AggregateRel
name|newAggRel
init|=
operator|new
name|AggregateRel
argument_list|(
name|cluster
argument_list|,
name|joinOutputProjRel
argument_list|,
name|groupSet
argument_list|,
name|newAggCalls
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newAggOutputProjExprList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|Util
operator|.
name|toIter
argument_list|(
name|groupSet
argument_list|)
control|)
block|{
name|newAggOutputProjExprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newAggRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|newAggOutputProjExpr
init|=
name|removeCorrelationExpr
argument_list|(
name|aggOutputProjExprs
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|newAggOutputProjExprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|newAggOutputProjExpr
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|newAggOutputProjExpr
argument_list|)
argument_list|)
expr_stmt|;
name|RelNode
name|newAggOutputProjRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|newAggRel
argument_list|,
name|newAggOutputProjExprList
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newAggOutputProjRel
argument_list|)
expr_stmt|;
name|removeCorVarFromTree
argument_list|(
name|corRel
argument_list|)
expr_stmt|;
block|}
block|}
comment|// REVIEW jhyde 29-Oct-2007: This rule is non-static, depends on the state
comment|// of members in RelDecorrelator, and has side-effects in the decorrelator.
comment|// This breaks the contract of a planner rule, and the rule will not be
comment|// reusable in other planners.
comment|// REVIEW jvs 29-Oct-2007:  Shouldn't it also be incorporating
comment|// the flavor attribute into the description?
specifier|private
specifier|final
class|class
name|AdjustProjectForCountAggregateRule
extends|extends
name|RelOptRule
block|{
specifier|final
name|boolean
name|flavor
decl_stmt|;
specifier|public
name|AdjustProjectForCountAggregateRule
parameter_list|(
name|boolean
name|flavor
parameter_list|)
block|{
name|super
argument_list|(
name|flavor
condition|?
name|some
argument_list|(
name|CorrelatorRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|RelNode
operator|.
name|class
argument_list|)
argument_list|,
name|some
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
else|:
name|some
argument_list|(
name|CorrelatorRel
operator|.
name|class
argument_list|,
name|any
argument_list|(
name|RelNode
operator|.
name|class
argument_list|)
argument_list|,
name|any
argument_list|(
name|AggregateRel
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|flavor
operator|=
name|flavor
expr_stmt|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|CorrelatorRel
name|corRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|leftInputRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ProjectRel
name|aggOutputProjRel
decl_stmt|;
name|AggregateRel
name|aggRel
decl_stmt|;
if|if
condition|(
name|flavor
condition|)
block|{
name|aggOutputProjRel
operator|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|aggRel
operator|=
name|call
operator|.
name|rel
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aggRel
operator|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// Create identity projection
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|aggRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|exprList
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|exprList
operator|.
name|size
argument_list|()
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNameList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|aggOutputProjRel
operator|=
operator|new
name|ProjectRel
argument_list|(
name|corRel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|aggRel
argument_list|,
name|exprList
argument_list|,
name|fieldNameList
argument_list|,
name|ProjectRel
operator|.
name|Flags
operator|.
name|Boxed
argument_list|)
expr_stmt|;
block|}
name|onMatch2
argument_list|(
name|call
argument_list|,
name|corRel
argument_list|,
name|leftInputRel
argument_list|,
name|aggOutputProjRel
argument_list|,
name|aggRel
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|onMatch2
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|,
name|CorrelatorRel
name|corRel
parameter_list|,
name|RelNode
name|leftInputRel
parameter_list|,
name|ProjectRel
name|aggOutputProjRel
parameter_list|,
name|AggregateRel
name|aggRel
parameter_list|)
block|{
name|RelOptCluster
name|cluster
init|=
name|corRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
if|if
condition|(
name|generatedCorRels
operator|.
name|contains
argument_list|(
name|corRel
argument_list|)
condition|)
block|{
comment|// This correlator was generated by a previous invocation of
comment|// this rule. No further work to do.
return|return;
block|}
name|currentRel
operator|=
name|corRel
expr_stmt|;
comment|// check for this pattern
comment|// The pattern matching could be simplified if rules can be applied
comment|// during decorrelation,
comment|//
comment|// CorrelateRel(left correlation, condition = true)
comment|//   LeftInputRel
comment|//   ProjectRel-A (a RexNode)
comment|//     AggregateRel (groupby (0), agg0(), agg1()...)
comment|// check aggOutputProj projects only one expression
name|RexNode
index|[]
name|aggOutputProjExprs
init|=
name|aggOutputProjRel
operator|.
name|getProjectExps
argument_list|()
decl_stmt|;
if|if
condition|(
name|aggOutputProjExprs
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
name|JoinRelType
name|joinType
init|=
name|corRel
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|RexNode
name|joinCond
init|=
name|corRel
operator|.
name|getCondition
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|||
operator|(
name|joinCond
operator|!=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
comment|// check that the agg is on the entire input
if|if
condition|(
operator|!
name|aggRel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
name|aggRel
operator|.
name|getAggCallList
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|isCount
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// remember the count() positions
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlCountAggFunction
condition|)
block|{
name|isCount
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now rewrite the plan to
comment|//
comment|// Project-A' (all LHS plus transformed original projections,
comment|//             replacing references to count() with case statement)
comment|//   CorrelatorRel(left correlation, condition = true)
comment|//     LeftInputRel
comment|//     AggregateRel (groupby (0), agg0(), agg1()...)
comment|//
name|CorrelatorRel
name|newCorRel
init|=
operator|new
name|CorrelatorRel
argument_list|(
name|cluster
argument_list|,
name|leftInputRel
argument_list|,
name|aggRel
argument_list|,
name|corRel
operator|.
name|getCorrelations
argument_list|()
argument_list|,
name|corRel
operator|.
name|getJoinType
argument_list|()
argument_list|)
decl_stmt|;
comment|// remember this rel so we don't fire rule on it again
comment|// REVIEW jhyde 29-Oct-2007: rules should not save state; rule
comment|// should recognize patterns where it does or does not need to do
comment|// work
name|generatedCorRels
operator|.
name|add
argument_list|(
name|newCorRel
argument_list|)
expr_stmt|;
comment|// need to update the mapCorVarToCorRel Update the output position
comment|// for the cor vars: only pass on the cor vars that are not used in
comment|// the join key.
name|Set
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
name|corVars
init|=
operator|new
name|HashSet
argument_list|<
name|CorrelatorRel
operator|.
name|Correlation
argument_list|>
argument_list|()
decl_stmt|;
name|corVars
operator|.
name|addAll
argument_list|(
name|mapCorVarToCorRel
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|CorrelatorRel
operator|.
name|Correlation
name|corVar
range|:
name|corVars
control|)
block|{
if|if
condition|(
name|mapCorVarToCorRel
operator|.
name|get
argument_list|(
name|corVar
argument_list|)
operator|==
name|corRel
condition|)
block|{
name|mapCorVarToCorRel
operator|.
name|put
argument_list|(
name|corVar
argument_list|,
name|newCorRel
argument_list|)
expr_stmt|;
block|}
block|}
name|RelNode
name|newOutputRel
init|=
name|aggregateCorrelatorOutput
argument_list|(
name|newCorRel
argument_list|,
name|aggOutputProjRel
argument_list|,
name|isCount
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newOutputRel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelDecorrelator.java
end_comment

end_unit

