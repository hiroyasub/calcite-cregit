begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql2rel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Standard implementation of {@link SqlRexConvertletTable}.  */
end_comment

begin_class
specifier|public
class|class
name|StandardConvertletTable
extends|extends
name|ReflectiveConvertletTable
block|{
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|StandardConvertletTable
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
comment|// Register aliases (operators which have a different name but
comment|// identical behavior to other operators).
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|characterLengthFunc
argument_list|,
name|SqlStdOperatorTable
operator|.
name|charLengthFunc
argument_list|)
expr_stmt|;
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isUnknownOperator
argument_list|,
name|SqlStdOperatorTable
operator|.
name|isNullOperator
argument_list|)
expr_stmt|;
name|addAlias
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNotUnknownOperator
argument_list|,
name|SqlStdOperatorTable
operator|.
name|isNotNullOperator
argument_list|)
expr_stmt|;
comment|// Register convertlets for specific objects.
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|castFunc
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCast
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isDistinctFromOperator
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertIsDistinctFrom
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNotDistinctFromOperator
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertIsDistinctFrom
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Expand "x NOT LIKE y" into "NOT (x LIKE y)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|notLikeOperator
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlCall
name|expanded
init|=
name|SqlStdOperatorTable
operator|.
name|notOperator
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|SqlStdOperatorTable
operator|.
name|likeOperator
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Expand "x NOT SIMILAR y" into "NOT (x SIMILAR y)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|notSimilarOperator
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlCall
name|expanded
init|=
name|SqlStdOperatorTable
operator|.
name|notOperator
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|SqlStdOperatorTable
operator|.
name|similarOperator
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Unary "+" has no effect, so expand "+ x" into "x".
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|prefixPlusOperator
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlNode
name|expanded
init|=
name|call
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// "AS" has no effect, so expand "x AS id" into "x".
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|asOperator
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlNode
name|expanded
init|=
name|call
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// "SQRT(x)" is equivalent to "POWER(x, .5)"
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|sqrtFunc
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlNode
name|expanded
init|=
name|SqlStdOperatorTable
operator|.
name|powerFunc
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0.5"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|expanded
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// REVIEW jvs 24-Apr-2006: This only seems to be working from within a
comment|// windowed agg.  I have added an optimizer rule
comment|// org.eigenbase.rel.rules.ReduceAggregatesRule which handles other
comment|// cases post-translation.  The reason I did that was to defer the
comment|// implementation decision; e.g. we may want to push it down to a
comment|// foreign server directly rather than decomposed; decomposition is
comment|// easier than recognition.
comment|// Convert "avg(<expr>)" to "cast(sum(<expr>) / count(<expr>) as
comment|//<type>)". We don't need to handle the empty set specially, because
comment|// the SUM is already supposed to come out as NULL in cases where the
comment|// COUNT is zero, so the null check should take place first and prevent
comment|// division by zero. We need the cast because SUM and COUNT may use
comment|// different types, say BIGINT.
comment|//
comment|// Similarly STDDEV_POP and STDDEV_SAMP, VAR_POP and VAR_SAMP.
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|avgOperator
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlAvgAggFunction
operator|.
name|Subtype
operator|.
name|AVG
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|stddevPopOperator
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlAvgAggFunction
operator|.
name|Subtype
operator|.
name|STDDEV_POP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|stddevSampOperator
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlAvgAggFunction
operator|.
name|Subtype
operator|.
name|STDDEV_SAMP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|varPopOperator
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlAvgAggFunction
operator|.
name|Subtype
operator|.
name|VAR_POP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|varSampOperator
argument_list|,
operator|new
name|AvgVarianceConvertlet
argument_list|(
name|SqlAvgAggFunction
operator|.
name|Subtype
operator|.
name|VAR_SAMP
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|floorFunc
argument_list|,
operator|new
name|FloorCeilConvertlet
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ceilFunc
argument_list|,
operator|new
name|FloorCeilConvertlet
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Convert "element(<expr>)" to "$element_slice(<expr>)", if the
comment|// expression is a multiset of scalars.
if|if
condition|(
literal|false
condition|)
block|{
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|elementFunc
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|Util
operator|.
name|permAssert
argument_list|(
name|operands
operator|.
name|length
operator|==
literal|1
argument_list|,
literal|"operands.length == 1"
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|operand
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|elementSlicefunc
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operand
argument_list|)
argument_list|)
return|;
block|}
comment|// fallback on default behavior
return|return
name|StandardConvertletTable
operator|.
name|this
operator|.
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// Convert "$element_slice(<expr>)" to "element(<expr>).field#0"
if|if
condition|(
literal|false
condition|)
block|{
name|registerOp
argument_list|(
name|SqlStdOperatorTable
operator|.
name|elementSlicefunc
argument_list|,
operator|new
name|SqlRexConvertlet
argument_list|()
block|{
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|Util
operator|.
name|permAssert
argument_list|(
name|operands
operator|.
name|length
operator|==
literal|1
argument_list|,
literal|"operands.length == 1"
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|operand
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|RexNode
name|expr
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|SqlStdOperatorTable
operator|.
name|elementFunc
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operand
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * Converts a CASE expression.      */
specifier|public
name|RexNode
name|convertCase
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCase
name|call
parameter_list|)
block|{
name|SqlNodeList
name|whenList
init|=
name|call
operator|.
name|getWhenOperands
argument_list|()
decl_stmt|;
name|SqlNodeList
name|thenList
init|=
name|call
operator|.
name|getThenOperands
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|whenList
operator|.
name|size
argument_list|()
operator|==
name|thenList
operator|.
name|size
argument_list|()
operator|)
assert|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|whenList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|whenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|thenList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exprList
operator|.
name|add
argument_list|(
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|getElseOperand
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|RexNode
index|[]
name|exprs
init|=
name|exprList
operator|.
name|toArray
argument_list|(
operator|new
name|RexNode
index|[
name|exprList
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|cx
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|elseArgs
argument_list|(
name|exprs
operator|.
name|length
argument_list|)
control|)
block|{
name|exprList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|exprList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|exprList
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMultiset
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMultisetValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RelDataType
name|originalType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexRangeRef
name|rr
init|=
name|cx
operator|.
name|getSubqueryExpr
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|rr
operator|!=
literal|null
assert|;
name|RelDataType
name|msType
init|=
name|rr
operator|.
name|getType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
literal|0
index|]
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexNode
name|expr
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|msType
argument_list|,
name|rr
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|msType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
assert|;
if|if
condition|(
operator|!
name|originalType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// If the type is not a struct, the multiset operator will have
comment|// wrapped the type as a record. Add a call to the $SLICE operator
comment|// to compensate. For example,
comment|// if '<ms>' has type 'RECORD (INTEGER x) MULTISET',
comment|// then '$SLICE(<ms>) has type 'INTEGER MULTISET'.
comment|// This will be removed as the expression is translated.
name|expr
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|sliceOp
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|RexNode
name|convertArray
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlArrayValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMap
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMapValueConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertMultisetQuery
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlMultisetQueryConstructor
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RelDataType
name|originalType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexRangeRef
name|rr
init|=
name|cx
operator|.
name|getSubqueryExpr
argument_list|(
name|call
argument_list|)
decl_stmt|;
assert|assert
name|rr
operator|!=
literal|null
assert|;
name|RelDataType
name|msType
init|=
name|rr
operator|.
name|getType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
literal|0
index|]
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexNode
name|expr
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|msType
argument_list|,
name|rr
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|msType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
assert|;
if|if
condition|(
operator|!
name|originalType
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// If the type is not a struct, the multiset operator will have
comment|// wrapped the type as a record. Add a call to the $SLICE operator
comment|// to compensate. For example,
comment|// if '<ms>' has type 'RECORD (INTEGER x) MULTISET',
comment|// then '$SLICE(<ms>) has type 'INTEGER MULTISET'.
comment|// This will be removed as the expression is translated.
name|expr
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|sliceOp
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|RexNode
name|convertJdbc
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlJdbcFunctionCall
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Yuck!! The function definition contains arguments!
comment|// TODO: adopt a more conventional definition/instance structure
specifier|final
name|SqlCall
name|convertedCall
init|=
name|op
operator|.
name|getLookupCall
argument_list|()
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|convertedCall
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|convertCast
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
assert|assert
name|call
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
assert|;
if|if
condition|(
name|call
operator|.
name|operands
index|[
literal|1
index|]
operator|instanceof
name|SqlIntervalQualifier
condition|)
block|{
name|SqlNode
name|node
init|=
name|call
operator|.
name|operands
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
name|RexLiteral
name|sourceInterval
init|=
operator|(
name|RexLiteral
operator|)
name|cx
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|long
name|sourceValue
init|=
operator|(
operator|(
name|BigDecimal
operator|)
name|sourceInterval
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|SqlIntervalQualifier
name|intervalQualifier
init|=
operator|(
name|SqlIntervalQualifier
operator|)
name|call
operator|.
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|RexLiteral
name|castedInterval
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeIntervalLiteral
argument_list|(
name|sourceValue
argument_list|,
name|intervalQualifier
argument_list|)
decl_stmt|;
return|return
name|castToValidatedType
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|castedInterval
argument_list|)
return|;
block|}
return|return
name|castToValidatedType
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|cx
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
name|SqlDataTypeSpec
name|dataType
init|=
operator|(
name|SqlDataTypeSpec
operator|)
name|call
operator|.
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|call
operator|.
name|operands
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
return|;
block|}
name|RexNode
name|arg
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|RelDataType
name|type
init|=
name|dataType
operator|.
name|deriveType
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|dataType
operator|.
name|getCollectionsTypeName
argument_list|()
condition|)
block|{
specifier|final
name|RelDataType
name|argComponentType
init|=
name|arg
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|componentType
init|=
name|type
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|argComponentType
operator|.
name|isStruct
argument_list|()
operator|&&
operator|!
name|componentType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|RelDataType
name|tt
init|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataType
index|[]
block|{
name|componentType
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
name|argComponentType
operator|.
name|getFields
argument_list|()
index|[
literal|0
index|]
operator|.
name|getName
argument_list|()
block|}
argument_list|)
decl_stmt|;
name|tt
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|tt
argument_list|,
name|componentType
operator|.
name|isNullable
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isn
init|=
name|type
operator|.
name|isNullable
argument_list|()
decl_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|tt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|isn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|convertFloorCeil
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|boolean
name|floor
parameter_list|)
block|{
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
comment|// Rewrite floor, ceil of interval
if|if
condition|(
operator|(
name|operands
operator|.
name|length
operator|==
literal|1
operator|)
operator|&&
operator|(
name|operands
index|[
literal|0
index|]
operator|instanceof
name|SqlIntervalLiteral
operator|)
condition|)
block|{
name|SqlIntervalLiteral
operator|.
name|IntervalValue
name|interval
init|=
operator|(
name|SqlIntervalLiteral
operator|.
name|IntervalValue
operator|)
operator|(
operator|(
name|SqlIntervalLiteral
operator|)
name|operands
index|[
literal|0
index|]
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|val
init|=
name|interval
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
operator|.
name|multiplier
decl_stmt|;
name|RexNode
name|rexInterval
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|RexNode
name|res
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|zero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|cond
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
argument_list|,
name|rexInterval
argument_list|,
name|zero
argument_list|)
decl_stmt|;
name|RexNode
name|pad
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|val
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|cast
init|=
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|rexInterval
operator|.
name|getType
argument_list|()
argument_list|,
name|pad
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|SqlOperator
name|op
init|=
name|floor
condition|?
name|SqlStdOperatorTable
operator|.
name|minusOperator
else|:
name|SqlStdOperatorTable
operator|.
name|plusOperator
decl_stmt|;
name|RexNode
name|sum
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|rexInterval
argument_list|,
name|cast
argument_list|)
decl_stmt|;
name|RexNode
name|kase
init|=
name|floor
condition|?
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|cond
argument_list|,
name|rexInterval
argument_list|,
name|sum
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|cond
argument_list|,
name|sum
argument_list|,
name|rexInterval
argument_list|)
decl_stmt|;
name|RexNode
name|factor
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|div
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|divideIntegerOperator
argument_list|,
name|kase
argument_list|,
name|factor
argument_list|)
decl_stmt|;
name|RexNode
name|mult
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|multiplyOperator
argument_list|,
name|div
argument_list|,
name|factor
argument_list|)
decl_stmt|;
name|res
operator|=
name|mult
expr_stmt|;
return|return
name|res
return|;
block|}
comment|// normal floor, ceil function
return|return
name|convertFunction
argument_list|(
name|cx
argument_list|,
operator|(
name|SqlFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertExtract
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlExtractFunction
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|)
decl_stmt|;
comment|// TODO: Will need to use decimal type for seconds with precision
name|RelDataType
name|resType
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
name|resType
operator|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|resType
argument_list|,
name|exprs
index|[
literal|1
index|]
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
expr_stmt|;
name|RexNode
name|cast
init|=
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|resType
argument_list|,
name|exprs
index|[
literal|1
index|]
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|SqlIntervalQualifier
operator|.
name|TimeUnit
name|unit
init|=
operator|(
operator|(
name|SqlIntervalQualifier
operator|)
name|operands
index|[
literal|0
index|]
operator|)
operator|.
name|getStartUnit
argument_list|()
decl_stmt|;
name|long
name|val
init|=
name|unit
operator|.
name|multiplier
decl_stmt|;
name|RexNode
name|factor
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|DAY
case|:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HOUR
case|:
name|val
operator|=
name|SqlIntervalQualifier
operator|.
name|TimeUnit
operator|.
name|DAY
operator|.
name|multiplier
expr_stmt|;
break|break;
case|case
name|MINUTE
case|:
name|val
operator|=
name|SqlIntervalQualifier
operator|.
name|TimeUnit
operator|.
name|HOUR
operator|.
name|multiplier
expr_stmt|;
break|break;
case|case
name|SECOND
case|:
name|val
operator|=
name|SqlIntervalQualifier
operator|.
name|TimeUnit
operator|.
name|MINUTE
operator|.
name|multiplier
expr_stmt|;
break|break;
case|case
name|YEAR
case|:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MONTH
case|:
name|val
operator|=
name|SqlIntervalQualifier
operator|.
name|TimeUnit
operator|.
name|YEAR
operator|.
name|multiplier
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|unit
argument_list|)
throw|;
block|}
name|RexNode
name|res
init|=
name|cast
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|RexNode
name|modVal
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
argument_list|,
name|resType
argument_list|)
decl_stmt|;
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|modFunc
argument_list|,
name|res
argument_list|,
name|modVal
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|divideIntegerOperator
argument_list|,
name|res
argument_list|,
name|factor
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
specifier|public
name|RexNode
name|convertDatetimeMinus
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlDatetimeSubtractionOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Rewrite datetime minus
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|)
decl_stmt|;
comment|// TODO: Handle year month interval (represented in months)
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
if|if
condition|(
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
operator|==
name|expr
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"Datetime subtraction of year month interval"
argument_list|)
expr_stmt|;
block|}
block|}
name|RelDataType
name|int8Type
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|casts
init|=
operator|new
name|RexNode
index|[
literal|2
index|]
decl_stmt|;
name|casts
index|[
literal|0
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|int8Type
argument_list|,
name|exprs
index|[
literal|0
index|]
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|,
name|exprs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|casts
index|[
literal|1
index|]
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|int8Type
argument_list|,
name|exprs
index|[
literal|1
index|]
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|,
name|exprs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|minus
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|minusOperator
argument_list|,
name|casts
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|resType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|res
init|=
name|rexBuilder
operator|.
name|makeReinterpretCast
argument_list|(
name|resType
argument_list|,
name|minus
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
specifier|public
name|RexNode
name|convertFunction
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlFunction
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|)
decl_stmt|;
if|if
condition|(
name|fun
operator|.
name|getFunctionType
argument_list|()
operator|==
name|SqlFunctionCategory
operator|.
name|UserDefinedConstructor
condition|)
block|{
return|return
name|makeConstructorCall
argument_list|(
name|cx
argument_list|,
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|convertAggregateFunction
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlAggFunction
name|fun
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|exprs
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|isCountStar
argument_list|()
condition|)
block|{
name|exprs
operator|=
name|RexNode
operator|.
name|EMPTY_ARRAY
expr_stmt|;
block|}
else|else
block|{
name|exprs
operator|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|fun
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|makeConstructorCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlFunction
name|constructor
parameter_list|,
name|RexNode
index|[]
name|exprs
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|deriveReturnType
argument_list|(
name|constructor
argument_list|,
name|typeFactory
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|type
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RexNode
index|[]
name|initializationExprs
init|=
operator|new
name|RexNode
index|[
name|n
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|initializationExprs
index|[
name|i
index|]
operator|=
name|cx
operator|.
name|getDefaultValueFactory
argument_list|()
operator|.
name|newAttributeInitializer
argument_list|(
name|type
argument_list|,
name|constructor
argument_list|,
name|i
argument_list|,
name|exprs
argument_list|)
expr_stmt|;
block|}
name|RexNode
index|[]
name|defaultCasts
init|=
name|RexUtil
operator|.
name|generateCastExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|type
argument_list|,
name|initializationExprs
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeNewInvocation
argument_list|(
name|type
argument_list|,
name|defaultCasts
argument_list|)
return|;
block|}
comment|/**      * Converts a call to an operator into a {@link RexCall} to the same      * operator.      *      *<p>Called automatically via reflection.      *      * @param cx Context      * @param call Call      *      * @return Rex call      */
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|exprs
init|=
name|convertExpressionList
argument_list|(
name|cx
argument_list|,
name|operands
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
operator|==
name|SqlTypeStrategies
operator|.
name|otcComparableUnorderedX2
condition|)
block|{
name|ensureSameType
argument_list|(
name|cx
argument_list|,
name|exprs
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|exprs
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|elseArgs
parameter_list|(
name|int
name|count
parameter_list|)
block|{
comment|// If list is odd, e.g. [0, 1, 2, 3, 4] we get [1, 3, 4]
comment|// If list is even, e.g. [0, 1, 2, 3, 4, 5] we get [2, 4, 5]
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|count
operator|%
literal|2
init|;
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
name|void
name|ensureSameType
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
specifier|final
name|RexNode
index|[]
name|exprs
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|leastRestrictive
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|exprs
index|[
name|index
index|]
operator|.
name|getType
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|exprs
operator|.
name|length
return|;
block|}
block|}
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|exprs
index|[
name|i
index|]
operator|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|exprs
index|[
name|i
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|RexNode
index|[]
name|convertExpressionList
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlNode
index|[]
name|nodes
parameter_list|)
block|{
specifier|final
name|RexNode
index|[]
name|exprs
init|=
operator|new
name|RexNode
index|[
name|nodes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|node
init|=
name|nodes
index|[
name|i
index|]
decl_stmt|;
name|exprs
index|[
name|i
index|]
operator|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|exprs
return|;
block|}
specifier|private
name|RexNode
name|convertIsDistinctFrom
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|RexNode
name|op0
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|RexNode
name|op1
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|call
operator|.
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
return|return
name|RelOptUtil
operator|.
name|isDistinctFrom
argument_list|(
name|cx
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|neg
argument_list|)
return|;
block|}
comment|/**      * Converts a BETWEEN expression.      *      *<p>Called automatically via reflection.      */
specifier|public
name|RexNode
name|convertBetween
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlBetweenOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlNode
name|value
init|=
name|call
operator|.
name|operands
index|[
name|SqlBetweenOperator
operator|.
name|VALUE_OPERAND
index|]
decl_stmt|;
name|RexNode
name|x
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|final
name|SqlBetweenOperator
operator|.
name|Flag
name|symmetric
init|=
name|op
operator|.
name|flag
decl_stmt|;
specifier|final
name|SqlNode
name|lower
init|=
name|call
operator|.
name|operands
index|[
name|SqlBetweenOperator
operator|.
name|LOWER_OPERAND
index|]
decl_stmt|;
name|RexNode
name|y
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|lower
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|upper
init|=
name|call
operator|.
name|operands
index|[
name|SqlBetweenOperator
operator|.
name|UPPER_OPERAND
index|]
decl_stmt|;
name|RexNode
name|z
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|upper
argument_list|)
decl_stmt|;
name|RexNode
name|res
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|ge1
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|RexNode
name|le1
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|lessThanOrEqualOperator
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
decl_stmt|;
name|RexNode
name|and1
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|andOperator
argument_list|,
name|ge1
argument_list|,
name|le1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|symmetric
condition|)
block|{
case|case
name|ASYMMETRIC
case|:
name|res
operator|=
name|and1
expr_stmt|;
break|break;
case|case
name|SYMMETRIC
case|:
name|RexNode
name|ge2
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
decl_stmt|;
name|RexNode
name|le2
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|lessThanOrEqualOperator
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|RexNode
name|and2
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|andOperator
argument_list|,
name|ge2
argument_list|,
name|le2
argument_list|)
decl_stmt|;
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|orOperator
argument_list|,
name|and1
argument_list|,
name|and2
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|symmetric
argument_list|)
throw|;
block|}
specifier|final
name|SqlBetweenOperator
name|betweenOp
init|=
operator|(
name|SqlBetweenOperator
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|betweenOp
operator|.
name|isNegated
argument_list|()
condition|)
block|{
name|res
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|notOperator
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
comment|/**      * Converts a LiteralChain expression: that is, concatenates the operands      * immediately, to produce a single literal string.      *      *<p>Called automatically via reflection.      */
specifier|public
name|RexNode
name|convertLiteralChain
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlLiteralChainOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|Util
operator|.
name|discard
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|SqlLiteral
name|sum
init|=
name|SqlLiteralChainOperator
operator|.
name|concatenateOperands
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertLiteral
argument_list|(
name|sum
argument_list|)
return|;
block|}
comment|/**      * Converts a ROW.      *      *<p>Called automatically via reflection.      */
specifier|public
name|RexNode
name|convertRow
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlRowOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|COLUMN_LIST
condition|)
block|{
return|return
name|convertCall
argument_list|(
name|cx
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cx
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
operator|(
name|SqlIdentifier
operator|)
name|operand
operator|)
operator|.
name|getSimple
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|columnListConstructor
argument_list|,
name|columns
argument_list|)
return|;
block|}
comment|/**      * Converts a call to OVERLAPS.      *      *<p>Called automatically via reflection.      */
specifier|public
name|RexNode
name|convertOverlaps
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlOverlapsOperator
name|op
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// for intervals [t0, t1] overlaps [t2, t3], we can find if the
comment|// intervals overlaps by: ~(t1< t2 or t3< t0)
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
assert|assert
name|operands
operator|.
name|length
operator|==
literal|4
assert|;
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
comment|// make t1 = t0 + t1 when t1 is an interval.
name|SqlOperator
name|op1
init|=
name|SqlStdOperatorTable
operator|.
name|plusOperator
decl_stmt|;
name|SqlNode
index|[]
name|second
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|second
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|second
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|op1
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|second
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operands
index|[
literal|3
index|]
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
comment|// make t3 = t2 + t3 when t3 is an interval.
name|SqlOperator
name|op1
init|=
name|SqlStdOperatorTable
operator|.
name|plusOperator
decl_stmt|;
name|SqlNode
index|[]
name|four
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|four
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|four
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|op1
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|four
argument_list|)
expr_stmt|;
block|}
comment|// This captures t1>= t2
name|SqlOperator
name|op1
init|=
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
decl_stmt|;
name|SqlNode
index|[]
name|left
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|left
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|left
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|SqlCall
name|call1
init|=
name|op1
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|left
argument_list|)
decl_stmt|;
comment|// This captures t3>= t0
name|SqlOperator
name|op2
init|=
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
decl_stmt|;
name|SqlNode
index|[]
name|right
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|right
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|right
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|SqlCall
name|call2
init|=
name|op2
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|right
argument_list|)
decl_stmt|;
comment|// This captures t1>= t2 and t3>= t0
name|SqlOperator
name|and
init|=
name|SqlStdOperatorTable
operator|.
name|andOperator
decl_stmt|;
name|SqlNode
index|[]
name|overlaps
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|overlaps
index|[
literal|0
index|]
operator|=
name|call1
expr_stmt|;
name|overlaps
index|[
literal|1
index|]
operator|=
name|call2
expr_stmt|;
name|SqlCall
name|call3
init|=
name|and
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|overlaps
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|convertExpression
argument_list|(
name|call3
argument_list|)
return|;
block|}
comment|/**      * Casts a RexNode value to the validated type of a SqlCall. If the value      * was already of the validated type, then the value is returned without an      * additional cast.      */
specifier|public
name|RexNode
name|castToValidatedType
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|RexNode
name|value
parameter_list|)
block|{
specifier|final
name|RelDataType
name|resType
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|resType
condition|)
block|{
return|return
name|value
return|;
block|}
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|resType
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|AvgVarianceConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|private
specifier|final
name|SqlAvgAggFunction
operator|.
name|Subtype
name|subtype
decl_stmt|;
specifier|public
name|AvgVarianceConvertlet
parameter_list|(
name|SqlAvgAggFunction
operator|.
name|Subtype
name|subtype
parameter_list|)
block|{
name|this
operator|.
name|subtype
operator|=
name|subtype
expr_stmt|;
block|}
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|Util
operator|.
name|permAssert
argument_list|(
name|operands
operator|.
name|length
operator|==
literal|1
argument_list|,
literal|"operands.length == 1"
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|arg
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|SqlNode
name|expr
decl_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|AVG
case|:
name|expr
operator|=
name|expandAvg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|STDDEV_POP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|STDDEV_SAMP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_POP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_SAMP
case|:
name|expr
operator|=
name|expandVariance
argument_list|(
name|arg
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|subtype
argument_list|)
throw|;
block|}
name|RelDataType
name|type
init|=
name|cx
operator|.
name|getValidator
argument_list|()
operator|.
name|getValidatedNodeType
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|RexNode
name|rex
init|=
name|cx
operator|.
name|convertExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|cx
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|type
argument_list|,
name|rex
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|expandAvg
parameter_list|(
specifier|final
name|SqlNode
name|arg
parameter_list|)
block|{
specifier|final
name|SqlParserPos
name|pos
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlNode
name|sum
init|=
name|SqlStdOperatorTable
operator|.
name|sumOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|count
init|=
name|SqlStdOperatorTable
operator|.
name|countOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|divideOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sum
argument_list|,
name|count
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|expandVariance
parameter_list|(
specifier|final
name|SqlNode
name|arg
parameter_list|,
name|boolean
name|biased
parameter_list|,
name|boolean
name|sqrt
parameter_list|)
block|{
comment|// stddev_pop(x) ==>
comment|//   power(
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / count(x),
comment|//     .5)
comment|//
comment|// stddev_samp(x) ==>
comment|//   power(
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / (count(x) - 1),
comment|//     .5)
comment|//
comment|// var_pop(x) ==>
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / count(x)
comment|//
comment|// var_samp(x) ==>
comment|//     (sum(x * x) - sum(x) * sum(x) / count(x))
comment|//     / (count(x) - 1)
specifier|final
name|SqlParserPos
name|pos
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlNode
name|argSquared
init|=
name|SqlStdOperatorTable
operator|.
name|multiplyOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumArgSquared
init|=
name|SqlStdOperatorTable
operator|.
name|sumOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|argSquared
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sum
init|=
name|SqlStdOperatorTable
operator|.
name|sumOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sumSquared
init|=
name|SqlStdOperatorTable
operator|.
name|multiplyOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sum
argument_list|,
name|sum
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|count
init|=
name|SqlStdOperatorTable
operator|.
name|countOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|arg
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|avgSumSquared
init|=
name|SqlStdOperatorTable
operator|.
name|divideOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumSquared
argument_list|,
name|count
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|diff
init|=
name|SqlStdOperatorTable
operator|.
name|minusOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|sumArgSquared
argument_list|,
name|avgSumSquared
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|denominator
decl_stmt|;
if|if
condition|(
name|biased
condition|)
block|{
name|denominator
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SqlNumericLiteral
name|one
init|=
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|denominator
operator|=
name|SqlStdOperatorTable
operator|.
name|minusOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|count
argument_list|,
name|one
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNode
name|div
init|=
name|SqlStdOperatorTable
operator|.
name|divideOperator
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|diff
argument_list|,
name|denominator
argument_list|)
decl_stmt|;
name|SqlNode
name|result
init|=
name|div
decl_stmt|;
if|if
condition|(
name|sqrt
condition|)
block|{
specifier|final
name|SqlNumericLiteral
name|half
init|=
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0.5"
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|result
operator|=
name|SqlStdOperatorTable
operator|.
name|powerFunc
operator|.
name|createCall
argument_list|(
name|pos
argument_list|,
name|div
argument_list|,
name|half
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
specifier|private
class|class
name|FloorCeilConvertlet
implements|implements
name|SqlRexConvertlet
block|{
specifier|private
specifier|final
name|boolean
name|floor
decl_stmt|;
specifier|public
name|FloorCeilConvertlet
parameter_list|(
name|boolean
name|floor
parameter_list|)
block|{
name|this
operator|.
name|floor
operator|=
name|floor
expr_stmt|;
block|}
specifier|public
name|RexNode
name|convertCall
parameter_list|(
name|SqlRexContext
name|cx
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|convertFloorCeil
argument_list|(
name|cx
argument_list|,
name|call
argument_list|,
name|floor
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End StandardConvertletTable.java
end_comment

end_unit

