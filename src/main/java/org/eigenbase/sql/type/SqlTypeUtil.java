begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
package|;
end_package

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|resource
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util14
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Contains utility methods used during SQL validation or type derivation.  *  * @author Wael Chatila  * @version $Id$  * @since Sep 3, 2004  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlTypeUtil
block|{
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * Checks whether two types or more are char comparable.      *      * @return Returns true if all operands are of char type and if they are      * comparable, i.e. of the same charset and collation of same charset      *      * @pre argTypes != null      * @pre argTypes.length>= 2      */
specifier|public
specifier|static
name|boolean
name|isCharTypeComparable
parameter_list|(
name|RelDataType
index|[]
name|argTypes
parameter_list|)
block|{
assert|assert
literal|null
operator|!=
name|argTypes
operator|:
literal|"precondition failed"
assert|;
assert|assert
literal|2
operator|<=
name|argTypes
operator|.
name|length
operator|:
literal|"precondition failed"
assert|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
operator|(
name|argTypes
operator|.
name|length
operator|-
literal|1
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|RelDataType
name|t0
init|=
name|argTypes
index|[
name|j
index|]
decl_stmt|;
name|RelDataType
name|t1
init|=
name|argTypes
index|[
name|j
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|inCharFamily
argument_list|(
name|t0
argument_list|)
operator|||
operator|!
name|inCharFamily
argument_list|(
name|t1
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
literal|null
operator|==
name|t0
operator|.
name|getCharset
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"RelDataType object should have been assigned a "
operator|+
literal|"(default) charset when calling deriveType"
argument_list|)
throw|;
block|}
if|else if
condition|(
operator|!
name|t0
operator|.
name|getCharset
argument_list|()
operator|.
name|equals
argument_list|(
name|t1
operator|.
name|getCharset
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
literal|null
operator|==
name|t0
operator|.
name|getCollation
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"RelDataType object should have been assigned a "
operator|+
literal|"(default) collation when calling deriveType"
argument_list|)
throw|;
block|}
if|else if
condition|(
operator|!
name|t0
operator|.
name|getCollation
argument_list|()
operator|.
name|getCharset
argument_list|()
operator|.
name|equals
argument_list|(
name|t1
operator|.
name|getCollation
argument_list|()
operator|.
name|getCharset
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * @param start zero based index      * @param stop zero based index      */
specifier|public
specifier|static
name|boolean
name|isCharTypeComparable
parameter_list|(
name|RelDataType
index|[]
name|argTypes
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|stop
parameter_list|)
block|{
name|int
name|n
init|=
name|stop
operator|-
name|start
operator|+
literal|1
decl_stmt|;
name|RelDataType
index|[]
name|subset
init|=
operator|new
name|RelDataType
index|[
name|n
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|argTypes
argument_list|,
name|start
argument_list|,
name|subset
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|isCharTypeComparable
argument_list|(
name|subset
argument_list|)
return|;
block|}
comment|/**      * Returns whether the operands to a call are char type-comparable.      *      * @param binding Binding of call to operands      * @param operands Operands to check for compatibility; usually the operands      * of the bound call, but not always      * @param throwOnFailure Whether to throw an exception on failure      *      * @return whether operands are valid      *      * @pre null != operands      * @pre 2<= operands.length      */
specifier|public
specifier|static
name|boolean
name|isCharTypeComparable
parameter_list|(
name|SqlCallBinding
name|binding
parameter_list|,
name|SqlNode
index|[]
name|operands
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
specifier|final
name|SqlValidator
name|validator
init|=
name|binding
operator|.
name|getValidator
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|binding
operator|.
name|getScope
argument_list|()
decl_stmt|;
assert|assert
literal|null
operator|!=
name|operands
operator|:
literal|"precondition failed"
assert|;
assert|assert
literal|2
operator|<=
name|operands
operator|.
name|length
operator|:
literal|"precondition failed"
assert|;
if|if
condition|(
operator|!
name|isCharTypeComparable
argument_list|(
name|deriveAndCollectTypes
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|operands
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|throwOnFailure
condition|)
block|{
name|String
name|msg
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|msg
operator|+=
literal|", "
expr_stmt|;
block|}
name|msg
operator|+=
name|operands
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
throw|throw
name|binding
operator|.
name|newError
argument_list|(
name|EigenbaseResource
operator|.
name|instance
argument_list|()
operator|.
name|OperandNotComparable
operator|.
name|ex
argument_list|(
name|msg
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Iterates over all operands, derives their types, and collects them into      * an array.      */
specifier|public
specifier|static
name|RelDataType
index|[]
name|deriveAndCollectTypes
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
index|[]
name|operands
parameter_list|)
block|{
name|RelDataType
index|[]
name|types
init|=
operator|new
name|RelDataType
index|[
name|operands
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|types
return|;
block|}
comment|/**      * Collects the row types of an array of relational expressions.      *      * @param rels array of relational expressions      *      * @return array of row types      */
specifier|public
specifier|static
name|RelDataType
index|[]
name|collectTypes
parameter_list|(
name|RelNode
index|[]
name|rels
parameter_list|)
block|{
name|RelDataType
index|[]
name|types
init|=
operator|new
name|RelDataType
index|[
name|rels
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|types
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|rels
index|[
name|i
index|]
operator|.
name|getRowType
argument_list|()
expr_stmt|;
block|}
return|return
name|types
return|;
block|}
comment|/**      * Promotes a type to a row type (does nothing if it already is one).      *      * @param type type to be promoted      * @param fieldName name to give field in row type; null for default of      * "ROW_VALUE"      *      * @return row type      */
specifier|public
specifier|static
name|RelDataType
name|promoteToRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
block|{
name|fieldName
operator|=
literal|"ROW_VALUE"
expr_stmt|;
block|}
name|type
operator|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataType
index|[]
block|{
name|type
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
name|fieldName
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/**      * Recreates a given RelDataType with nullablility iff any of a calls      * operand types are nullable.      */
specifier|public
specifier|static
name|RelDataType
name|makeNullableIfOperandsAre
parameter_list|(
specifier|final
name|SqlValidator
name|validator
parameter_list|,
specifier|final
name|SqlValidatorScope
name|scope
parameter_list|,
specifier|final
name|SqlCall
name|call
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
name|RelDataType
name|operandType
init|=
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|containsNullable
argument_list|(
name|operandType
argument_list|)
condition|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|validator
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|type
return|;
block|}
comment|/**      * Recreates a given RelDataType with nullability iff any of the param      * argTypes are nullable.      */
specifier|public
specifier|static
name|RelDataType
name|makeNullableIfOperandsAre
parameter_list|(
specifier|final
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|RelDataType
index|[]
name|argTypes
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|containsNullable
argument_list|(
name|argTypes
argument_list|)
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/**      * Returns whether one or more of an array of types is nullable.      */
specifier|public
specifier|static
name|boolean
name|containsNullable
parameter_list|(
name|RelDataType
index|[]
name|types
parameter_list|)
block|{
for|for
control|(
name|RelDataType
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
name|containsNullable
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Determines whether a type or any of its fields (if a structured type) are      * nullable.      */
specifier|public
specifier|static
name|boolean
name|containsNullable
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|type
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
name|containsNullable
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns typeName.equals(type.getSqlTypeName()). If      * typeName.equals(SqlTypeName.Any) true is always returned.      */
specifier|public
specifier|static
name|boolean
name|isOfSameTypeName
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|SqlTypeName
operator|.
name|ANY
operator|.
name|equals
argument_list|(
name|typeName
argument_list|)
operator|||
name|typeName
operator|.
name|equals
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns true if any element in<code>typeNames</code> matches      * type.getSqlTypeName().      *      * @see #isOfSameTypeName(SqlTypeName, RelDataType)      */
specifier|public
specifier|static
name|boolean
name|isOfSameTypeName
parameter_list|(
name|SqlTypeName
index|[]
name|typeNames
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
for|for
control|(
name|SqlTypeName
name|typeName
range|:
name|typeNames
control|)
block|{
if|if
condition|(
name|isOfSameTypeName
argument_list|(
name|typeName
argument_list|,
name|type
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * @return true if type is DATE, TIME, or TIMESTAMP      */
specifier|public
specifier|static
name|boolean
name|isDatetime
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|isOfSameTypeName
argument_list|(
name|SqlTypeName
operator|.
name|datetimeTypes
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**      * @return true if type is some kind of INTERVAL      */
specifier|public
specifier|static
name|boolean
name|isInterval
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|isOfSameTypeName
argument_list|(
name|SqlTypeName
operator|.
name|timeIntervalTypes
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**      * @return true if type is in SqlTypeFamily.Character      */
specifier|public
specifier|static
name|boolean
name|inCharFamily
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
return|;
block|}
comment|/**      * @return true if type is in SqlTypeFamily.Character      */
specifier|public
specifier|static
name|boolean
name|inCharFamily
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
return|return
name|SqlTypeFamily
operator|.
name|getFamilyForSqlType
argument_list|(
name|typeName
argument_list|)
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
return|;
block|}
comment|/**      * @return true if type is in SqlTypeFamily.Boolean      */
specifier|public
specifier|static
name|boolean
name|inBooleanFamily
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|BOOLEAN
return|;
block|}
comment|/**      * @return true if two types are in same type family      */
specifier|public
specifier|static
name|boolean
name|inSameFamily
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
return|return
name|t1
operator|.
name|getFamily
argument_list|()
operator|==
name|t2
operator|.
name|getFamily
argument_list|()
return|;
block|}
comment|/**      * @return true if two types are in same type family, or one or the other is      * of type SqlTypeName.Null      */
specifier|public
specifier|static
name|boolean
name|inSameFamilyOrNull
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
return|return
operator|(
name|t1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|)
operator|||
operator|(
name|t2
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
operator|)
operator|||
operator|(
name|t1
operator|.
name|getFamily
argument_list|()
operator|==
name|t2
operator|.
name|getFamily
argument_list|()
operator|)
return|;
block|}
comment|/**      * @return true if type family is either character or binary      */
specifier|public
specifier|static
name|boolean
name|inCharOrBinaryFamilies
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
operator|)
operator|||
operator|(
name|type
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|BINARY
operator|)
return|;
block|}
comment|/**      * @return true if type is a LOB of some kind      */
specifier|public
specifier|static
name|boolean
name|isLob
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
comment|// TODO jvs 9-Dec-2004:  once we support LOB types
return|return
literal|false
return|;
block|}
comment|/**      * @return true if type is variable width with bounded precision      */
specifier|public
specifier|static
name|boolean
name|isBoundedVariableWidth
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|VARCHAR
case|:
case|case
name|VARBINARY
case|:
comment|// TODO angel 8-June-2005: Multiset should be LOB
case|case
name|MULTISET
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**      * @return true if type is one of the integer types      */
specifier|public
specifier|static
name|boolean
name|isIntType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**      * @return true if type is decimal      */
specifier|public
specifier|static
name|boolean
name|isDecimal
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|typeName
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
return|;
block|}
comment|/**      * @return true if type is bigint      */
specifier|public
specifier|static
name|boolean
name|isBigint
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|typeName
operator|==
name|SqlTypeName
operator|.
name|BIGINT
return|;
block|}
comment|/**      * @return true if type is numeric with exact precision      */
specifier|public
specifier|static
name|boolean
name|isExactNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Returns the maximum value of an integral type, as a long value      */
specifier|public
specifier|static
name|long
name|maxValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
assert|assert
operator|(
name|SqlTypeUtil
operator|.
name|isIntType
argument_list|(
name|type
argument_list|)
operator|)
assert|;
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MAX_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MAX_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
case|case
name|BIGINT
case|:
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * @return true if type is numeric with approximate precision      */
specifier|public
specifier|static
name|boolean
name|isApproximateNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**      * @return true if type is numeric      */
specifier|public
specifier|static
name|boolean
name|isNumeric
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|isExactNumeric
argument_list|(
name|type
argument_list|)
operator|||
name|isApproximateNumeric
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**      * Tests whether two types have the same name and structure, possibly with      * differing modifiers. For example, VARCHAR(1) and VARCHAR(10) are      * considered the same, while VARCHAR(1) and CHAR(1) are considered      * different. Likewise, VARCHAR(1) MULTISET and VARCHAR(10) MULTISET are      * considered the same.      *      * @return true if types have same name and structure      */
specifier|public
specifier|static
name|boolean
name|sameNamedType
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|.
name|isStruct
argument_list|()
operator|||
name|t2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|t1
operator|.
name|isStruct
argument_list|()
operator|||
operator|!
name|t2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t1
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|t2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RelDataTypeField
index|[]
name|fields1
init|=
name|t1
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|fields2
init|=
name|t2
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields1
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|sameNamedType
argument_list|(
name|fields1
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|fields2
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
name|RelDataType
name|comp1
init|=
name|t1
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|RelDataType
name|comp2
init|=
name|t2
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|comp1
operator|!=
literal|null
operator|)
operator|||
operator|(
name|comp2
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|comp1
operator|==
literal|null
operator|)
operator|||
operator|(
name|comp2
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|sameNamedType
argument_list|(
name|comp1
argument_list|,
name|comp2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|t1
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|t2
operator|.
name|getSqlTypeName
argument_list|()
return|;
block|}
comment|/**      * Computes the maximum number of bytes required to represent a value of a      * type having user-defined precision. This computation assumes no overhead      * such as length indicators and NUL-terminators. Complex types for which      * multiple representations are possible (e.g. DECIMAL or TIMESTAMP) return      * 0.      *      * @param type type for which to compute storage      *      * @return maximum bytes, or 0 for a fixed-width type or type with unknown      * maximum      */
specifier|public
specifier|static
name|int
name|getMaxByteSize
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
operator|(
name|double
operator|)
name|type
operator|.
name|getPrecision
argument_list|()
operator|)
operator|*
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|newEncoder
argument_list|()
operator|.
name|maxBytesPerChar
argument_list|()
argument_list|)
return|;
case|case
name|BINARY
case|:
case|case
name|VARBINARY
case|:
return|return
name|type
operator|.
name|getPrecision
argument_list|()
return|;
case|case
name|MULTISET
case|:
comment|// TODO Wael Jan-24-2005: Need a better way to tell fennel this
comment|// number. This a very generic place and implementation details like
comment|// this doesnt belong here. Waiting to change this once we have blob
comment|// support
return|return
literal|4096
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
comment|/**      * Determines the minimum unscaled value of a numeric type      *      * @param type a numeric type      */
specifier|public
specifier|static
name|long
name|getMinValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MIN_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MIN_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MIN_VALUE
return|;
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|NumberUtil
operator|.
name|getMinUnscaled
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"getMinValue("
operator|+
name|typeName
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Determines the maximum unscaled value of a numeric type      *      * @param type a numeric type      */
specifier|public
specifier|static
name|long
name|getMaxValue
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
name|Byte
operator|.
name|MAX_VALUE
return|;
case|case
name|SMALLINT
case|:
return|return
name|Short
operator|.
name|MAX_VALUE
return|;
case|case
name|INTEGER
case|:
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|NumberUtil
operator|.
name|getMaxUnscaled
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"getMaxValue("
operator|+
name|typeName
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
comment|/**      * @return true if type has a representation as a Java primitive (ignoring      * nullability)      */
specifier|public
specifier|static
name|boolean
name|isJavaPrimitive
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
case|case
name|SYMBOL
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/**      * @return class name of the wrapper for the primitive data type.      */
specifier|public
specifier|static
name|String
name|getPrimitiveWrapperJavaClassName
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
literal|"Boolean"
return|;
default|default:
return|return
name|getNumericJavaClassName
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
comment|/**      * @return class name of the numeric data type.      */
specifier|public
specifier|static
name|String
name|getNumericJavaClassName
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|TINYINT
case|:
return|return
literal|"Byte"
return|;
case|case
name|SMALLINT
case|:
return|return
literal|"Short"
return|;
case|case
name|INTEGER
case|:
return|return
literal|"Integer"
return|;
case|case
name|BIGINT
case|:
return|return
literal|"Long"
return|;
case|case
name|REAL
case|:
return|return
literal|"Float"
return|;
case|case
name|DECIMAL
case|:
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
return|return
literal|"Double"
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Tests assignability of a value to a site.      *      * @param toType type of the target site      * @param fromType type of the source value      *      * @return true iff assignable      */
specifier|public
specifier|static
name|boolean
name|canAssignFrom
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RelDataType
name|fromType
parameter_list|)
block|{
comment|// TODO jvs 2-Jan-2005:  handle all the other cases like
comment|// rows, collections, UDT's
if|if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
comment|// REVIEW jvs 4-Dec-2008: We allow assignment from NULL to any
comment|// type, including NOT NULL types, since in the case where no
comment|// rows are actually processed, the assignment is legal
comment|// (FRG-365).  However, it would be better if the validator's
comment|// NULL type inference guaranteed that we had already
comment|// assigned a real (nullable) type to every NULL literal.
return|return
literal|true
return|;
block|}
if|if
condition|(
name|areCharacterSetsMismatched
argument_list|(
name|toType
argument_list|,
name|fromType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|toType
operator|.
name|getFamily
argument_list|()
operator|==
name|fromType
operator|.
name|getFamily
argument_list|()
return|;
block|}
comment|/**      * Determines whether two types both have different character sets. If one      * or the other type has no character set (e.g. in cast from INT to      * VARCHAR), that is not a mismatch.      *      * @param t1 first type      * @param t2 second type      *      * @return true iff mismatched      */
specifier|public
specifier|static
name|boolean
name|areCharacterSetsMismatched
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
name|Charset
name|cs1
init|=
name|t1
operator|.
name|getCharset
argument_list|()
decl_stmt|;
name|Charset
name|cs2
init|=
name|t2
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|cs1
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|cs2
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|cs1
operator|.
name|equals
argument_list|(
name|cs2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Compares two types and returns true if fromType can be cast to toType.      *      *<p>REVIEW jvs 17-Dec-2004: the coerce param below shouldn't really be      * necessary. We're using it as a hack because {@link      * SqlTypeFactoryImpl#leastRestrictiveSqlType} isn't complete enough yet.      * Once it is, this param (and the non-coerce rules of {@link      * SqlTypeAssignmentRules}) should go away.      *      * @param toType target of assignment      * @param fromType source of assignment      * @param coerce if true, the SQL rules for CAST are used; if false, the      * rules are similar to Java; e.g. you can't assign short x = (int) y, and      * you can't assign int x = (String) z.      *      * @return true iff cast is legal      */
specifier|public
specifier|static
name|boolean
name|canCastFrom
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RelDataType
name|fromType
parameter_list|,
name|boolean
name|coerce
parameter_list|)
block|{
if|if
condition|(
name|toType
operator|==
name|fromType
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|toType
operator|.
name|isStruct
argument_list|()
operator|||
name|fromType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
if|if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
comment|// can't cast between different distinct types
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|toType
operator|.
name|getFields
argument_list|()
index|[
literal|0
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|fromType
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DISTINCT
condition|)
block|{
return|return
name|canCastFrom
argument_list|(
name|toType
argument_list|,
name|fromType
operator|.
name|getFields
argument_list|()
index|[
literal|0
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ROW
condition|)
block|{
if|if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|ROW
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|n
init|=
name|toType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|fromType
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|RelDataTypeField
name|toField
init|=
name|toType
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|RelDataTypeField
name|fromField
init|=
name|fromType
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|canCastFrom
argument_list|(
name|toField
operator|.
name|getType
argument_list|()
argument_list|,
name|fromField
operator|.
name|getType
argument_list|()
argument_list|,
name|coerce
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
if|if
condition|(
operator|!
name|fromType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|toType
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|fromType
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|else if
condition|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|MULTISET
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|toType
operator|.
name|getFamily
argument_list|()
operator|==
name|fromType
operator|.
name|getFamily
argument_list|()
return|;
block|}
block|}
name|RelDataType
name|c1
init|=
name|toType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|null
condition|)
block|{
name|RelDataType
name|c2
init|=
name|fromType
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|c2
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|canCastFrom
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|coerce
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|isInterval
argument_list|(
name|fromType
argument_list|)
operator|&&
name|isExactNumeric
argument_list|(
name|toType
argument_list|)
operator|)
operator|||
operator|(
name|isInterval
argument_list|(
name|toType
argument_list|)
operator|&&
name|isExactNumeric
argument_list|(
name|fromType
argument_list|)
operator|)
condition|)
block|{
name|IntervalSqlType
name|intervalType
init|=
operator|(
name|IntervalSqlType
operator|)
operator|(
name|isInterval
argument_list|(
name|fromType
argument_list|)
condition|?
name|fromType
else|:
name|toType
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|isSingleDatetimeField
argument_list|()
condition|)
block|{
comment|// Casts between intervals and exact numerics must involve
comment|// intervals with a single datetime field.
return|return
literal|false
return|;
block|}
block|}
name|SqlTypeName
name|tn1
init|=
name|toType
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
name|SqlTypeName
name|tn2
init|=
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|tn1
operator|==
literal|null
operator|)
operator|||
operator|(
name|tn2
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// REVIEW jvs 9-Feb-2009: we don't impose SQL rules for character sets
comment|// here; instead, we do that in SqlCastFunction.  The reason is that
comment|// this method is called from at least one place (MedJdbcNameDirectory)
comment|// where internally a cast across character repertoires is OK.  Should
comment|// probably clean that up.
name|SqlTypeAssignmentRules
name|rules
init|=
name|SqlTypeAssignmentRules
operator|.
name|instance
argument_list|()
decl_stmt|;
return|return
name|rules
operator|.
name|canCastFrom
argument_list|(
name|tn1
argument_list|,
name|tn2
argument_list|,
name|coerce
argument_list|)
return|;
block|}
comment|/**      * @return the field names of a struct type      */
specifier|public
specifier|static
name|String
index|[]
name|getFieldNames
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|RelDataTypeField
index|[]
name|fields
init|=
name|type
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|String
index|[]
name|ret
init|=
operator|new
name|String
index|[
name|fields
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
index|[
name|i
index|]
operator|=
name|fields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * @return the field types of a struct type      */
specifier|public
specifier|static
name|RelDataType
index|[]
name|getFieldTypes
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|RelDataTypeField
index|[]
name|fields
init|=
name|type
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|RelDataType
index|[]
name|ret
init|=
operator|new
name|RelDataType
index|[
name|fields
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
index|[
name|i
index|]
operator|=
name|fields
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Flattens a record type by recursively expanding any fields which are      * themselves record types. For each record type, a representative null      * value field is also prepended (with state NULL for a null value and FALSE      * for non-null), and all component types are asserted to be nullable, since      * SQL doesn't allow NOT NULL to be specified on attributes.      *      * @param typeFactory factory which should produced flattened type      * @param recordType type with possible nesting      * @param flatteningMap if non-null, receives map from unflattened ordinal      * to flattened ordinal (must have length at least      * recordType.getFieldList().size())      *      * @return flattened equivalent      */
specifier|public
specifier|static
name|RelDataType
name|flattenRecordType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|recordType
parameter_list|,
name|int
index|[]
name|flatteningMap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|recordType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
name|recordType
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|nested
init|=
name|flattenFields
argument_list|(
name|typeFactory
argument_list|,
name|recordType
argument_list|,
name|fieldList
argument_list|,
name|flatteningMap
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nested
condition|)
block|{
return|return
name|recordType
return|;
block|}
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|fieldList
control|)
block|{
operator|++
name|i
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
operator|+
literal|"_"
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|,
name|fieldNames
argument_list|)
return|;
block|}
comment|/**      * Creates a record type with anonymous field names.      */
specifier|public
specifier|static
name|RelDataType
name|createStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|RelDataType
index|[]
name|types
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataTypeFactory
operator|.
name|FieldInfo
argument_list|()
block|{
specifier|public
name|int
name|getFieldCount
parameter_list|()
block|{
return|return
name|types
operator|.
name|length
return|;
block|}
specifier|public
name|String
name|getFieldName
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
literal|"$"
operator|+
name|index
return|;
block|}
specifier|public
name|RelDataType
name|getFieldType
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|types
index|[
name|index
index|]
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|needsNullIndicator
parameter_list|(
name|RelDataType
name|recordType
parameter_list|)
block|{
comment|// NOTE jvs 9-Mar-2005: It would be more storage-efficient to say that
comment|// no null indicator is required for structured type columns declared
comment|// as NOT NULL.  However, the uniformity of always having a null
comment|// indicator makes things cleaner in many places.
return|return
operator|(
name|recordType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|STRUCTURED
operator|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|flattenFields
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|list
parameter_list|,
name|int
index|[]
name|flatteningMap
parameter_list|)
block|{
name|boolean
name|nested
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|needsNullIndicator
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// NOTE jvs 9-Mar-2005:  other code
comment|// (e.g. RelStructuredTypeFlattener) relies on the
comment|// null indicator field coming first.
name|RelDataType
name|indicatorType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|indicatorType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|indicatorType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|RelDataTypeField
name|nullIndicatorField
init|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
literal|"NULL_VALUE"
argument_list|,
literal|0
argument_list|,
name|indicatorType
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|nullIndicatorField
argument_list|)
expr_stmt|;
name|nested
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|RelDataTypeField
name|field1
range|:
name|type
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|RelDataTypeField
name|field
init|=
operator|(
name|RelDataTypeField
operator|)
name|field1
decl_stmt|;
if|if
condition|(
name|flatteningMap
operator|!=
literal|null
condition|)
block|{
name|flatteningMap
index|[
name|field
operator|.
name|getIndex
argument_list|()
index|]
operator|=
name|list
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|nested
operator|=
literal|true
expr_stmt|;
name|flattenFields
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|list
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|nested
operator|=
literal|true
expr_stmt|;
comment|// TODO jvs 14-Feb-2005:  generalize to any kind of
comment|// collection type
name|RelDataType
name|flattenedCollectionType
init|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|flattenRecordType
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|field
operator|=
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|flattenedCollectionType
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nested
return|;
block|}
comment|/**      * Converts an instance of RelDataType to an instance of SqlDataTypeSpec.      *      * @param type type descriptor      *      * @return corresponding parse representation      */
specifier|public
specifier|static
name|SqlDataTypeSpec
name|convertTypeToSpec
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
comment|// TODO jvs 28-Dec-2004:  support row types, user-defined types,
comment|// interval types, multiset types, etc
assert|assert
operator|(
name|typeName
operator|!=
literal|null
operator|)
assert|;
name|SqlIdentifier
name|typeIdentifier
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|typeName
operator|.
name|name
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|String
name|charSetName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|inCharFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|charSetName
operator|=
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
expr_stmt|;
comment|// TODO jvs 28-Dec-2004:  collation
block|}
comment|// REVIEW jvs 28-Dec-2004:  discriminate between precision/scale
comment|// zero and unspecified?
comment|// REVIEW angel 11-Jan-2006:
comment|// Use neg numbers to indicate unspecified precision/scale
if|if
condition|(
name|typeName
operator|.
name|allowsScale
argument_list|()
condition|)
block|{
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
name|typeIdentifier
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|type
operator|.
name|getScale
argument_list|()
argument_list|,
name|charSetName
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
if|else if
condition|(
name|typeName
operator|.
name|allowsPrec
argument_list|()
condition|)
block|{
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
name|typeIdentifier
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|charSetName
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
name|typeIdentifier
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|charSetName
argument_list|,
literal|null
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|RelDataType
name|createMultisetType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|ret
init|=
name|typeFactory
operator|.
name|createMultisetType
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
name|nullable
argument_list|)
return|;
block|}
comment|/**      * Adds collation and charset to a character type, returns other types      * unchanged.      *      * @param type Type      * @param typeFactory Type factory      *      * @return Type with added charset and collation, or unchanged type if it is      * not a char type.      */
specifier|public
specifier|static
name|RelDataType
name|addCharsetAndCollation
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inCharFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|type
return|;
block|}
name|Charset
name|charset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
name|charset
operator|==
literal|null
condition|)
block|{
name|charset
operator|=
name|typeFactory
operator|.
name|getDefaultCharset
argument_list|()
expr_stmt|;
block|}
name|SqlCollation
name|collation
init|=
name|type
operator|.
name|getCollation
argument_list|()
decl_stmt|;
if|if
condition|(
name|collation
operator|==
literal|null
condition|)
block|{
name|collation
operator|=
operator|new
name|SqlCollation
argument_list|(
name|SqlCollation
operator|.
name|Coercibility
operator|.
name|Implicit
argument_list|)
expr_stmt|;
block|}
comment|// todo: should get the implicit collation from repository
comment|//   instead of null
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|charset
argument_list|,
name|collation
argument_list|)
expr_stmt|;
name|SqlValidatorUtil
operator|.
name|checkCharsetAndCollateConsistentIfCharType
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/**      * Returns whether two types are equal, ignoring nullability.      *      *<p>They need not come from the same factory.      *      * @param factory Type factory      * @param type1 First type      * @param type2 Second type      *      * @return whether types are equal, ignoring nullability      */
specifier|public
specifier|static
name|boolean
name|equalSansNullability
parameter_list|(
name|RelDataTypeFactory
name|factory
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|.
name|equals
argument_list|(
name|type2
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|type1
operator|.
name|isNullable
argument_list|()
operator|==
name|type2
operator|.
name|isNullable
argument_list|()
condition|)
block|{
comment|// If types have the same nullability and they weren't equal above,
comment|// they must be different.
return|return
literal|false
return|;
block|}
return|return
name|type1
operator|.
name|equals
argument_list|(
name|factory
operator|.
name|createTypeWithNullability
argument_list|(
name|type2
argument_list|,
name|type1
operator|.
name|isNullable
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Adds a field to a record type at a specified position.      *      *<p>For example, if type is<code>(A integer, B boolean)</code>, and      * fieldType is<code>varchar(10)</code>, then<code>prepend(typeFactory,      * type, 0, "Z", fieldType)</code> will return<code>(Z varchar(10), A      * integer, B boolean)</code>.      *      * @param typeFactory Type factory      * @param type Record type      * @param at Ordinal to add field      * @param fieldName Name of new field      * @param fieldType Type of new field      *      * @return Extended record type      */
specifier|public
specifier|static
name|RelDataType
name|addField
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|RelDataType
name|type
parameter_list|,
specifier|final
name|int
name|at
parameter_list|,
specifier|final
name|String
name|fieldName
parameter_list|,
specifier|final
name|RelDataType
name|fieldType
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataTypeFactory
operator|.
name|FieldInfo
argument_list|()
block|{
specifier|public
name|int
name|getFieldCount
parameter_list|()
block|{
return|return
name|type
operator|.
name|getFieldCount
argument_list|()
operator|+
literal|1
return|;
block|}
specifier|public
name|String
name|getFieldName
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|==
name|at
condition|)
block|{
return|return
name|fieldName
return|;
block|}
if|if
condition|(
name|index
operator|>
name|at
condition|)
block|{
operator|--
name|index
expr_stmt|;
block|}
return|return
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getName
argument_list|()
return|;
block|}
specifier|public
name|RelDataType
name|getFieldType
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|==
name|at
condition|)
block|{
return|return
name|fieldType
return|;
block|}
if|if
condition|(
name|index
operator|>
name|at
condition|)
block|{
operator|--
name|index
expr_stmt|;
block|}
return|return
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Returns the ordinal of a given field in a record type, or -1 if the field      * is not found.      *      * @param type Record type      * @param fieldName Name of field      *      * @return Ordinal of field      */
specifier|public
specifier|static
name|int
name|findField
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|type
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Records a struct type with no fields.      *      * @param typeFactory Type factory      *      * @return Struct type with no fields      */
specifier|public
specifier|static
name|RelDataType
name|createEmptyStructType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataType
index|[
literal|0
index|]
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/**      * Returns whether two types are comparable. They need to be scalar types of      * the same family, or struct types whose fields are pairwise comparable.      *      * @param type1 First type      * @param type2 Second type      *      * @return Whether types are comparable      */
specifier|public
specifier|static
name|boolean
name|isComparable
parameter_list|(
name|RelDataType
name|type1
parameter_list|,
name|RelDataType
name|type2
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
operator|!=
name|type2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|type1
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|int
name|n
init|=
name|type1
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|type2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|RelDataTypeField
name|field1
init|=
operator|(
name|RelDataTypeField
operator|)
name|type1
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelDataTypeField
name|field2
init|=
operator|(
name|RelDataTypeField
operator|)
name|type2
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isComparable
argument_list|(
name|field1
operator|.
name|getType
argument_list|()
argument_list|,
name|field2
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
name|RelDataTypeFamily
name|family1
init|=
literal|null
decl_stmt|;
name|RelDataTypeFamily
name|family2
init|=
literal|null
decl_stmt|;
comment|// REVIEW jvs 2-June-2005:  This is needed to keep
comment|// the Saffron type system happy.
if|if
condition|(
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|family1
operator|=
name|type1
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|family2
operator|=
name|type2
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|family1
operator|==
literal|null
condition|)
block|{
name|family1
operator|=
name|type1
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|family2
operator|==
literal|null
condition|)
block|{
name|family2
operator|=
name|type2
operator|.
name|getFamily
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|family1
operator|==
name|family2
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Checks whether a type represents Unicode character data.      *      * @param type type to test      *      * @return whether type represents Unicode character data      */
specifier|public
specifier|static
name|boolean
name|isUnicode
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|Charset
name|charset
init|=
name|type
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
name|charset
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|charset
operator|.
name|name
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"UTF"
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**      * Convenience class for building a struct type with several fields.      *      *<p>TypeBuilder is more convenient because it supports chained calls to      * add one field at a time. The chained syntax means that you can use a      * TypeBuilder in contexts where only an expression is allowed, for example      * in a field initializer. There are several overloadings of the<code>      * add</code> method for types which take different parameters, and you can      * explicitly state whether you want a field to be nullable.      *      *<p>For example, to create the type      *      *<blockquote>      *<pre>      * (A BOOLEAN NOT NULL, B VARCHAR(10), C DECIMAL(6,2))      *</pre>      *</blockquote>      *      * the code is      *      *<blockquote>      *<pre>      * RelDataTypeFactory typeFactory;      * return new TypeBuilder(typeFactory)      *     .add("A", SqlTypeName.BOOLEAN, false)      *     .add("B", SqlTypeName.VARCHAR(10), true)      *     .add("C", SqlTypeName.DECIMAL, 6, 2, false)      *     .type();      *</pre>      *</blockquote>      *      *<p>The equivalent conventional code is:      *      *<blockquote>      *<pre>      * RelDataTypeFactory typeFactory;      * String[] names = {"A", "B", "C"};      * RelDataType[] types = {      *     typeFactory.createSqlType(SqlTypeName.BOOLEAN),      *     typeFactory.createTypeWithNullability(      *         typeFactory.createSqlType(SqlTypeName.VARCHAR, 10),      *         true),      *    typeFactory.createSqlType(SqlTypeName.DECIMAL, 6, 2)      * };      * return typeFactory.createStructType(names, types);      *</pre>      *</blockquote>      */
specifier|public
specifier|static
class|class
name|TypeBuilder
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RelDataTypeFieldImpl
argument_list|>
name|fieldList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataTypeFieldImpl
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|public
name|TypeBuilder
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
name|this
operator|.
name|typeFactory
operator|=
name|typeFactory
expr_stmt|;
block|}
specifier|public
name|TypeBuilder
name|add
parameter_list|(
name|String
name|name
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullable
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|nullable
argument_list|)
expr_stmt|;
block|}
name|fieldList
operator|.
name|add
argument_list|(
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|TypeBuilder
name|add
parameter_list|(
name|String
name|name
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullable
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|nullable
argument_list|)
expr_stmt|;
block|}
name|fieldList
operator|.
name|add
argument_list|(
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|TypeBuilder
name|add
parameter_list|(
name|String
name|name
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
name|scale
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|,
name|scale
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullable
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|nullable
argument_list|)
expr_stmt|;
block|}
name|fieldList
operator|.
name|add
argument_list|(
operator|new
name|RelDataTypeFieldImpl
argument_list|(
name|name
argument_list|,
operator|-
literal|1
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|RelDataType
name|type
parameter_list|()
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataTypeFactory
operator|.
name|FieldInfo
argument_list|()
block|{
specifier|public
name|int
name|getFieldCount
parameter_list|()
block|{
return|return
name|fieldList
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|String
name|getFieldName
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|fieldList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getName
argument_list|()
return|;
block|}
specifier|public
name|RelDataType
name|getFieldType
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|fieldList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End SqlTypeUtil.java
end_comment

end_unit

