begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|rel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|openjava
operator|.
name|mop
operator|.
name|*
import|;
end_import

begin_import
import|import
name|openjava
operator|.
name|ptree
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|runtime
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|trace
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *<code>IterCalcRel</code> is an iterator implementation of a combination of  * {@link ProjectRel} above an optional {@link FilterRel}. It takes a {@link  * TupleIter iterator} as input, and for each row applies the filter condition  * if defined. Rows passing the filter expression are transformed via projection  * and returned. Note that the same object is always returned (with different  * values), so parents must not buffer the result.  *  *<p>Rules:  *  *<ul>  *<li>{@link org.eigenbase.oj.rel.IterRules.IterCalcRule} creates an  * IterCalcRel from a {@link org.eigenbase.rel.CalcRel}</li>  *</ul>  */
end_comment

begin_class
specifier|public
class|class
name|IterCalcRel
extends|extends
name|SingleRel
implements|implements
name|JavaRel
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
name|boolean
name|abortOnError
init|=
literal|true
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|errorBuffering
init|=
literal|false
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|RexProgram
name|program
decl_stmt|;
comment|/**      * Values defined in {@link org.eigenbase.rel.ProjectRelBase.Flags}.      */
specifier|protected
name|int
name|flags
decl_stmt|;
specifier|private
name|String
name|tag
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|IterCalcRel
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|child
parameter_list|,
name|RexProgram
name|program
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|this
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|getEmptyTraitSet
argument_list|()
argument_list|,
name|child
argument_list|,
name|program
argument_list|,
name|flags
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IterCalcRel
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelTraitSet
name|traitSet
parameter_list|,
name|RelNode
name|child
parameter_list|,
name|RexProgram
name|program
parameter_list|,
name|int
name|flags
parameter_list|,
name|String
name|tag
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|traitSet
operator|.
name|plus
argument_list|(
name|CallingConvention
operator|.
name|ITERATOR
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|this
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|this
operator|.
name|program
operator|=
name|program
expr_stmt|;
name|this
operator|.
name|rowType
operator|=
name|program
operator|.
name|getOutputRowType
argument_list|()
expr_stmt|;
name|this
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|// TODO jvs 10-May-2004: need a computeSelfCost which takes condition into
comment|// account; maybe inherit from CalcRelBase?
specifier|public
name|RelOptPlanWriter
name|explainTerms
parameter_list|(
name|RelOptPlanWriter
name|pw
parameter_list|)
block|{
return|return
name|program
operator|.
name|explainCalc
argument_list|(
name|super
operator|.
name|explainTerms
argument_list|(
name|pw
argument_list|)
argument_list|)
return|;
block|}
specifier|protected
name|String
name|computeDigest
parameter_list|()
block|{
name|String
name|tempDigest
init|=
name|super
operator|.
name|computeDigest
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|null
condition|)
block|{
comment|// append logger type to digest
name|int
name|lastParen
init|=
name|tempDigest
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
decl_stmt|;
name|tempDigest
operator|=
name|tempDigest
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|lastParen
argument_list|)
operator|+
literal|",type="
operator|+
name|tag
operator|+
name|tempDigest
operator|.
name|substring
argument_list|(
name|lastParen
argument_list|)
expr_stmt|;
block|}
return|return
name|tempDigest
return|;
block|}
specifier|public
name|double
name|getRows
parameter_list|()
block|{
return|return
name|FilterRel
operator|.
name|estimateFilteredRows
argument_list|(
name|getChild
argument_list|()
argument_list|,
name|program
argument_list|)
return|;
block|}
specifier|public
name|RelOptCost
name|computeSelfCost
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|double
name|dRows
init|=
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|double
name|dCpu
init|=
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|getChild
argument_list|()
argument_list|)
operator|*
name|program
operator|.
name|getExprCount
argument_list|()
decl_stmt|;
name|double
name|dIo
init|=
literal|0
decl_stmt|;
return|return
name|planner
operator|.
name|makeCost
argument_list|(
name|dRows
argument_list|,
name|dCpu
argument_list|,
name|dIo
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|copy
parameter_list|(
name|RelTraitSet
name|traitSet
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|)
block|{
return|return
operator|new
name|IterCalcRel
argument_list|(
name|getCluster
argument_list|()
argument_list|,
name|traitSet
argument_list|,
name|sole
argument_list|(
name|inputs
argument_list|)
argument_list|,
name|program
operator|.
name|copy
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|tag
argument_list|)
return|;
block|}
specifier|public
name|int
name|getFlags
parameter_list|()
block|{
return|return
name|flags
return|;
block|}
specifier|public
name|boolean
name|isBoxed
parameter_list|()
block|{
return|return
operator|(
name|flags
operator|&
name|ProjectRelBase
operator|.
name|Flags
operator|.
name|Boxed
operator|)
operator|==
name|ProjectRelBase
operator|.
name|Flags
operator|.
name|Boxed
return|;
block|}
comment|/**      * Burrows into a synthetic record and returns the underlying relation which      * provides the field called<code>fieldName</code>.      */
specifier|public
name|JavaRel
name|implementFieldAccess
parameter_list|(
name|JavaRelImplementor
name|implementor
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isBoxed
argument_list|()
condition|)
block|{
return|return
name|implementor
operator|.
name|implementFieldAccess
argument_list|(
operator|(
name|JavaRel
operator|)
name|getChild
argument_list|()
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
name|RelDataType
name|type
init|=
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|field
init|=
name|type
operator|.
name|getFieldOrdinal
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
name|RexLocalRef
name|ref
init|=
name|program
operator|.
name|getProjectList
argument_list|()
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|ref
operator|.
name|getIndex
argument_list|()
decl_stmt|;
return|return
name|implementor
operator|.
name|findRel
argument_list|(
operator|(
name|JavaRel
operator|)
name|this
argument_list|,
name|program
operator|.
name|getExprList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Disables throwing of exceptions on error. Do not set this false without a      * very good reason! Doing so will prevent type cast, overflow/underflow,      * etc. errors in Farrago.      */
specifier|public
specifier|static
name|void
name|setAbortOnError
parameter_list|(
name|boolean
name|abortOnError
parameter_list|)
block|{
name|IterCalcRel
operator|.
name|abortOnError
operator|=
name|abortOnError
expr_stmt|;
block|}
comment|/**      * Allows errors to be buffered, in the event that they overflow the error      * handler.      *      * @param errorBuffering whether to buffer errors      */
specifier|public
specifier|static
name|void
name|setErrorBuffering
parameter_list|(
name|boolean
name|errorBuffering
parameter_list|)
block|{
name|IterCalcRel
operator|.
name|errorBuffering
operator|=
name|errorBuffering
expr_stmt|;
block|}
specifier|public
specifier|static
name|Expression
name|implementAbstract
parameter_list|(
name|JavaRelImplementor
name|implementor
parameter_list|,
name|JavaRel
name|rel
parameter_list|,
name|Expression
name|childExp
parameter_list|,
name|Variable
name|varInputRow
parameter_list|,
specifier|final
name|RelDataType
name|inputRowType
parameter_list|,
specifier|final
name|RelDataType
name|outputRowType
parameter_list|,
name|RexProgram
name|program
parameter_list|,
name|String
name|tag
parameter_list|)
block|{
return|return
name|implementAbstractTupleIter
argument_list|(
name|implementor
argument_list|,
name|rel
argument_list|,
name|childExp
argument_list|,
name|varInputRow
argument_list|,
name|inputRowType
argument_list|,
name|outputRowType
argument_list|,
name|program
argument_list|,
name|tag
argument_list|)
return|;
block|}
comment|/**      * Generates code for a Java expression satisfying the {@link      * org.eigenbase.runtime.TupleIter} interface. The generated code allocates      * a {@link org.eigenbase.runtime.CalcTupleIter} with a dynamic {@link      * org.eigenbase.runtime.TupleIter#fetchNext()} method. If the "abort on      * error" flag is false, or an error handling tag is specified, then      * fetchNext is written to handle row errors.      *      *<p>Row errors are handled by wrapping expressions that can fail with a      * try/catch block. A caught RuntimeException is then published to an      * "connection variable." In the event that errors can overflow, an "error      * buffering" flag allows them to be posted again on the next iteration of      * fetchNext.      *      * @param implementor an object that implements relations as Java code      * @param rel the relation to be implemented      * @param childExp the implemented child of the relation      * @param varInputRow the Java variable to use for the input row      * @param inputRowType the rel data type of the input row      * @param outputRowType the rel data type of the output row      * @param program the rex program to implemented by the relation      * @param tag an error handling tag      *      * @return a Java expression satisfying the TupleIter interface      */
specifier|public
specifier|static
name|Expression
name|implementAbstractTupleIter
parameter_list|(
name|JavaRelImplementor
name|implementor
parameter_list|,
name|JavaRel
name|rel
parameter_list|,
name|Expression
name|childExp
parameter_list|,
name|Variable
name|varInputRow
parameter_list|,
specifier|final
name|RelDataType
name|inputRowType
parameter_list|,
specifier|final
name|RelDataType
name|outputRowType
parameter_list|,
name|RexProgram
name|program
parameter_list|,
name|String
name|tag
parameter_list|)
block|{
name|MemberDeclarationList
name|memberList
init|=
operator|new
name|MemberDeclarationList
argument_list|()
decl_stmt|;
comment|// Perform error recovery if continuing on errors or if
comment|// an error handling tag has been specified
name|boolean
name|errorRecovery
init|=
operator|!
name|abortOnError
operator|||
operator|(
name|tag
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// Error buffering should not be enabled unless error recovery is
assert|assert
operator|!
name|errorBuffering
operator|||
name|errorRecovery
assert|;
comment|// Allow backwards compatibility until all Farrago extensions are
comment|// satisfied with the new error handling semantics. The new semantics
comment|// include:
comment|//   (1) cast input object to input row object outside of try block,
comment|//         should be fine, at least for base Farrago
comment|//   (2) maintain a columnIndex counter to better locate of error,
comment|//         at the cost of a few cycles
comment|//   (3) publish errors to the runtime context. FarragoRuntimeContext
comment|//         now supports this API
name|boolean
name|backwardsCompatible
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|null
condition|)
block|{
name|backwardsCompatible
operator|=
literal|false
expr_stmt|;
block|}
name|RelDataTypeFactory
name|typeFactory
init|=
name|implementor
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|OJClass
name|outputRowClass
init|=
name|OJUtil
operator|.
name|typeToOJClass
argument_list|(
name|outputRowType
argument_list|,
name|typeFactory
argument_list|)
decl_stmt|;
name|OJClass
name|inputRowClass
init|=
name|OJUtil
operator|.
name|typeToOJClass
argument_list|(
name|inputRowType
argument_list|,
name|typeFactory
argument_list|)
decl_stmt|;
name|Variable
name|varOutputRow
init|=
name|implementor
operator|.
name|newVariable
argument_list|()
decl_stmt|;
name|FieldDeclaration
name|inputRowVarDecl
init|=
operator|new
name|FieldDeclaration
argument_list|(
operator|new
name|ModifierList
argument_list|(
name|ModifierList
operator|.
name|PRIVATE
argument_list|)
argument_list|,
name|TypeName
operator|.
name|forOJClass
argument_list|(
name|inputRowClass
argument_list|)
argument_list|,
name|varInputRow
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|FieldDeclaration
name|outputRowVarDecl
init|=
operator|new
name|FieldDeclaration
argument_list|(
operator|new
name|ModifierList
argument_list|(
name|ModifierList
operator|.
name|PRIVATE
argument_list|)
argument_list|,
name|TypeName
operator|.
name|forOJClass
argument_list|(
name|outputRowClass
argument_list|)
argument_list|,
name|varOutputRow
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|AllocationExpression
argument_list|(
name|outputRowClass
argument_list|,
operator|new
name|ExpressionList
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// The method body for fetchNext, a main target of code generation
name|StatementList
name|nextMethodBody
init|=
operator|new
name|StatementList
argument_list|()
decl_stmt|;
comment|// First, post an error if it overflowed the previous time
comment|//     if (pendingError) {
comment|//         rc = handleRowError(...);
comment|//         if (rc instanceof NoDataReason) {
comment|//             return rc;
comment|//         }
comment|//         pendingError = false;
comment|//     }
if|if
condition|(
name|errorBuffering
condition|)
block|{
comment|// add to next method body...
block|}
comment|// Most of fetchNext falls within a while() block. The while block
comment|// allows us to try multiple input rows against a filter condition
comment|// before returning a single row.
comment|//     while (true) {
comment|//         Object varInputObj = inputIterator.fetchNext();
comment|//         if (varInputObj instanceof TupleIter.NoDataReason) {
comment|//             return varInputObj;
comment|//         }
comment|//         varInputRow = (InputRowClass) varInputObj;
comment|//         int columnIndex = 0;
comment|//         [calculation statements]
comment|//     }
name|StatementList
name|whileBody
init|=
operator|new
name|StatementList
argument_list|()
decl_stmt|;
name|Variable
name|varInputObj
init|=
name|implementor
operator|.
name|newVariable
argument_list|()
decl_stmt|;
name|whileBody
operator|.
name|add
argument_list|(
operator|new
name|VariableDeclaration
argument_list|(
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|Object
operator|.
name|class
argument_list|)
argument_list|,
name|varInputObj
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|MethodCall
argument_list|(
operator|new
name|FieldAccess
argument_list|(
literal|"inputIterator"
argument_list|)
argument_list|,
literal|"fetchNext"
argument_list|,
operator|new
name|ExpressionList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|StatementList
name|ifNoDataReasonBody
init|=
operator|new
name|StatementList
argument_list|()
decl_stmt|;
name|whileBody
operator|.
name|add
argument_list|(
operator|new
name|IfStatement
argument_list|(
operator|new
name|InstanceofExpression
argument_list|(
name|varInputObj
argument_list|,
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|TupleIter
operator|.
name|NoDataReason
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
name|ifNoDataReasonBody
argument_list|)
argument_list|)
expr_stmt|;
name|ifNoDataReasonBody
operator|.
name|add
argument_list|(
operator|new
name|ReturnStatement
argument_list|(
name|varInputObj
argument_list|)
argument_list|)
expr_stmt|;
comment|// Push up the row declaration for new error handling so that the
comment|// input row is available to the error handler
if|if
condition|(
operator|!
name|backwardsCompatible
condition|)
block|{
name|whileBody
operator|.
name|add
argument_list|(
name|assignInputRow
argument_list|(
name|inputRowClass
argument_list|,
name|varInputRow
argument_list|,
name|varInputObj
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Variable
name|varColumnIndex
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|errorRecovery
operator|&&
operator|!
name|backwardsCompatible
condition|)
block|{
comment|// NOTE jvs 7-Oct-2006:  Declare varColumnIndex as a member
comment|// (rather than a local) in case in the future we want
comment|// to decompose complex expressions into helper methods.
name|varColumnIndex
operator|=
name|implementor
operator|.
name|newVariable
argument_list|()
expr_stmt|;
name|FieldDeclaration
name|varColumnIndexDecl
init|=
operator|new
name|FieldDeclaration
argument_list|(
operator|new
name|ModifierList
argument_list|(
name|ModifierList
operator|.
name|PRIVATE
argument_list|)
argument_list|,
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|int
operator|.
name|class
argument_list|)
argument_list|,
name|varColumnIndex
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|memberList
operator|.
name|add
argument_list|(
name|varColumnIndexDecl
argument_list|)
expr_stmt|;
name|whileBody
operator|.
name|add
argument_list|(
operator|new
name|ExpressionStatement
argument_list|(
operator|new
name|AssignmentExpression
argument_list|(
name|varColumnIndex
argument_list|,
name|AssignmentExpression
operator|.
name|EQUALS
argument_list|,
name|Literal
operator|.
name|makeLiteral
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Calculator (projection, filtering) statements are later appended
comment|// to calcStmts. Typically, this target will be the while list itself.
name|StatementList
name|calcStmts
decl_stmt|;
if|if
condition|(
operator|!
name|errorRecovery
condition|)
block|{
name|calcStmts
operator|=
name|whileBody
expr_stmt|;
block|}
else|else
block|{
comment|// For error recovery, we wrap the calc statements
comment|// (e.g., everything but the code that reads rows from the
comment|// inputIterator) in a try/catch that publishes exceptions.
name|calcStmts
operator|=
operator|new
name|StatementList
argument_list|()
expr_stmt|;
comment|// try { /* calcStmts */ }
comment|// catch(RuntimeException ex) {
comment|//     Object rc = connection.handleRowError(...);
comment|//     [buffer error if necessary]
comment|// }
name|StatementList
name|catchStmts
init|=
operator|new
name|StatementList
argument_list|()
decl_stmt|;
if|if
condition|(
name|backwardsCompatible
condition|)
block|{
name|catchStmts
operator|.
name|add
argument_list|(
operator|new
name|ExpressionStatement
argument_list|(
operator|new
name|MethodCall
argument_list|(
operator|new
name|MethodCall
argument_list|(
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|EigenbaseTrace
operator|.
name|class
argument_list|)
argument_list|,
literal|"getStatementTracer"
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|"log"
argument_list|,
operator|new
name|ExpressionList
argument_list|(
operator|new
name|FieldAccess
argument_list|(
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|Level
operator|.
name|class
argument_list|)
argument_list|,
literal|"WARNING"
argument_list|)
argument_list|,
name|Literal
operator|.
name|makeLiteral
argument_list|(
literal|"java calc exception"
argument_list|)
argument_list|,
operator|new
name|FieldAccess
argument_list|(
literal|"ex"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Variable
name|varRc
init|=
name|implementor
operator|.
name|newVariable
argument_list|()
decl_stmt|;
name|ExpressionList
name|handleRowErrorArgs
init|=
operator|new
name|ExpressionList
argument_list|(
name|varInputRow
argument_list|,
operator|new
name|FieldAccess
argument_list|(
literal|"ex"
argument_list|)
argument_list|,
name|varColumnIndex
argument_list|)
decl_stmt|;
name|handleRowErrorArgs
operator|.
name|add
argument_list|(
name|Literal
operator|.
name|makeLiteral
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|catchStmts
operator|.
name|add
argument_list|(
operator|new
name|VariableDeclaration
argument_list|(
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|Object
operator|.
name|class
argument_list|)
argument_list|,
name|varRc
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|MethodCall
argument_list|(
name|implementor
operator|.
name|getConnectionVariable
argument_list|()
argument_list|,
literal|"handleRowError"
argument_list|,
name|handleRowErrorArgs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Buffer an error if it overflowed
comment|//     if (rc instanceof NoDataReason) {
comment|//         pendingError = true;
comment|//         [save error state]
comment|//         return rc;
comment|//     }
if|if
condition|(
name|errorBuffering
condition|)
block|{
comment|// add to catch statements...
block|}
block|}
name|CatchList
name|catchList
init|=
operator|new
name|CatchList
argument_list|(
operator|new
name|CatchBlock
argument_list|(
operator|new
name|Parameter
argument_list|(
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|RuntimeException
operator|.
name|class
argument_list|)
argument_list|,
literal|"ex"
argument_list|)
argument_list|,
name|catchStmts
argument_list|)
argument_list|)
decl_stmt|;
name|TryStatement
name|tryStmt
init|=
operator|new
name|TryStatement
argument_list|(
name|calcStmts
argument_list|,
name|catchList
argument_list|)
decl_stmt|;
name|whileBody
operator|.
name|add
argument_list|(
name|tryStmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backwardsCompatible
condition|)
block|{
name|calcStmts
operator|.
name|add
argument_list|(
name|assignInputRow
argument_list|(
name|inputRowClass
argument_list|,
name|varInputRow
argument_list|,
name|varInputObj
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StatementList
name|condBody
decl_stmt|;
name|RexToOJTranslator
name|translator
init|=
name|implementor
operator|.
name|newStmtTranslator
argument_list|(
name|rel
argument_list|,
name|calcStmts
argument_list|,
name|memberList
argument_list|)
decl_stmt|;
try|try
block|{
name|translator
operator|.
name|pushProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
name|program
operator|.
name|getCondition
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// TODO jvs 8-Oct-2006:  move condition to its own
comment|// method if big, as below for project exprs.
name|condBody
operator|=
operator|new
name|StatementList
argument_list|()
expr_stmt|;
name|RexNode
name|rexIsTrue
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isTrueOperator
argument_list|,
name|program
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
name|Expression
name|conditionExp
init|=
name|translator
operator|.
name|translateRexNode
argument_list|(
name|rexIsTrue
argument_list|)
decl_stmt|;
name|calcStmts
operator|.
name|add
argument_list|(
operator|new
name|IfStatement
argument_list|(
name|conditionExp
argument_list|,
name|condBody
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|condBody
operator|=
name|calcStmts
expr_stmt|;
block|}
name|RelDataTypeField
index|[]
name|fields
init|=
name|outputRowType
operator|.
name|getFields
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
init|=
name|program
operator|.
name|getProjectList
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|rhs
range|:
name|projectRefList
control|)
block|{
comment|// NOTE jvs 14-Sept-2006:  Put complicated project expressions
comment|// into their own method, otherwise a big select list can easily
comment|// blow the 64K Java limit on method bytecode size.  Make
comment|// methods private final in the hopes that they will get inlined
comment|// JIT.  For now we decide "complicated" based on the size of
comment|// the generated Java parse tree. A big enough select list of
comment|// simple expressions could still blow the limit, so we may need
comment|// to group them together, sub-divide, etc.
name|StatementList
name|projMethodBody
init|=
operator|new
name|StatementList
argument_list|()
decl_stmt|;
if|if
condition|(
name|errorRecovery
operator|&&
operator|!
name|backwardsCompatible
condition|)
block|{
name|projMethodBody
operator|.
name|add
argument_list|(
operator|new
name|ExpressionStatement
argument_list|(
operator|new
name|UnaryExpression
argument_list|(
name|varColumnIndex
argument_list|,
name|UnaryExpression
operator|.
name|POST_INCREMENT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
name|RexToOJTranslator
name|projTranslator
init|=
name|translator
operator|.
name|push
argument_list|(
name|projMethodBody
argument_list|)
decl_stmt|;
name|String
name|javaFieldName
init|=
name|Util
operator|.
name|toJavaId
argument_list|(
name|fields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Expression
name|lhs
init|=
operator|new
name|FieldAccess
argument_list|(
name|varOutputRow
argument_list|,
name|javaFieldName
argument_list|)
decl_stmt|;
name|projTranslator
operator|.
name|translateAssignment
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|int
name|complexity
init|=
name|OJUtil
operator|.
name|countParseTreeNodes
argument_list|(
name|projMethodBody
argument_list|)
decl_stmt|;
comment|// REVIEW: HCP 5/18/2011
comment|// The projMethod should be checked
comment|// for causing possible compiler errors caused by the use of
comment|// variables declared in other projMethods.  Also the
comment|// local declaration of variabled used by other proj methods
comment|// should also be checked.
comment|// Fixing for backswing integration 14270
comment|// TODO: check if abstracting this method body will cause
comment|// a compiler error
if|if
condition|(
literal|true
condition|)
block|{
comment|// No method needed; just append.
name|condBody
operator|.
name|addAll
argument_list|(
name|projMethodBody
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Need a separate method.
name|String
name|projMethodName
init|=
literal|"calc_"
operator|+
name|varOutputRow
operator|.
name|toString
argument_list|()
operator|+
literal|"_f_"
operator|+
name|i
decl_stmt|;
name|MemberDeclaration
name|projMethodDecl
init|=
operator|new
name|MethodDeclaration
argument_list|(
operator|new
name|ModifierList
argument_list|(
name|ModifierList
operator|.
name|PRIVATE
operator||
name|ModifierList
operator|.
name|FINAL
argument_list|)
argument_list|,
name|TypeName
operator|.
name|forOJClass
argument_list|(
name|OJSystem
operator|.
name|VOID
argument_list|)
argument_list|,
name|projMethodName
argument_list|,
operator|new
name|ParameterList
argument_list|()
argument_list|,
literal|null
argument_list|,
name|projMethodBody
argument_list|)
decl_stmt|;
name|memberList
operator|.
name|add
argument_list|(
name|projMethodDecl
argument_list|)
expr_stmt|;
name|condBody
operator|.
name|add
argument_list|(
operator|new
name|ExpressionStatement
argument_list|(
operator|new
name|MethodCall
argument_list|(
name|projMethodName
argument_list|,
operator|new
name|ExpressionList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|translator
operator|.
name|popProgram
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
name|condBody
operator|.
name|add
argument_list|(
operator|new
name|ReturnStatement
argument_list|(
name|varOutputRow
argument_list|)
argument_list|)
expr_stmt|;
name|WhileStatement
name|whileStmt
init|=
operator|new
name|WhileStatement
argument_list|(
name|Literal
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|whileBody
argument_list|)
decl_stmt|;
name|nextMethodBody
operator|.
name|add
argument_list|(
name|whileStmt
argument_list|)
expr_stmt|;
name|MemberDeclaration
name|fetchNextMethodDecl
init|=
operator|new
name|MethodDeclaration
argument_list|(
operator|new
name|ModifierList
argument_list|(
name|ModifierList
operator|.
name|PUBLIC
argument_list|)
argument_list|,
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|Object
operator|.
name|class
argument_list|)
argument_list|,
literal|"fetchNext"
argument_list|,
operator|new
name|ParameterList
argument_list|()
argument_list|,
literal|null
argument_list|,
name|nextMethodBody
argument_list|)
decl_stmt|;
comment|// The restart() method should reset variables used to buffer errors
comment|//     pendingError = false
if|if
condition|(
name|errorBuffering
condition|)
block|{
comment|// declare refinement of restart() and add to member list...
block|}
name|memberList
operator|.
name|add
argument_list|(
name|inputRowVarDecl
argument_list|)
expr_stmt|;
name|memberList
operator|.
name|add
argument_list|(
name|outputRowVarDecl
argument_list|)
expr_stmt|;
name|memberList
operator|.
name|add
argument_list|(
name|fetchNextMethodDecl
argument_list|)
expr_stmt|;
name|Expression
name|newTupleIterExp
init|=
operator|new
name|AllocationExpression
argument_list|(
name|OJUtil
operator|.
name|typeNameForClass
argument_list|(
name|CalcTupleIter
operator|.
name|class
argument_list|)
argument_list|,
operator|new
name|ExpressionList
argument_list|(
name|childExp
argument_list|)
argument_list|,
name|memberList
argument_list|)
decl_stmt|;
return|return
name|newTupleIterExp
return|;
block|}
specifier|public
name|ParseTree
name|implement
parameter_list|(
name|JavaRelImplementor
name|implementor
parameter_list|)
block|{
name|Expression
name|childExp
init|=
name|implementor
operator|.
name|visitJavaChild
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
operator|(
name|JavaRel
operator|)
name|getChild
argument_list|()
argument_list|)
decl_stmt|;
name|RelDataType
name|outputRowType
init|=
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataType
name|inputRowType
init|=
name|getChild
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|Variable
name|varInputRow
init|=
name|implementor
operator|.
name|newVariable
argument_list|()
decl_stmt|;
name|implementor
operator|.
name|bind
argument_list|(
name|getChild
argument_list|()
argument_list|,
name|varInputRow
argument_list|)
expr_stmt|;
return|return
name|implementAbstract
argument_list|(
name|implementor
argument_list|,
name|this
argument_list|,
name|childExp
argument_list|,
name|varInputRow
argument_list|,
name|inputRowType
argument_list|,
name|outputRowType
argument_list|,
name|program
argument_list|,
name|tag
argument_list|)
return|;
block|}
specifier|public
name|RexProgram
name|getProgram
parameter_list|()
block|{
return|return
name|program
return|;
block|}
specifier|public
name|String
name|getTag
parameter_list|()
block|{
return|return
name|tag
return|;
block|}
specifier|private
specifier|static
name|Statement
name|assignInputRow
parameter_list|(
name|OJClass
name|inputRowClass
parameter_list|,
name|Variable
name|varInputRow
parameter_list|,
name|Variable
name|varInputObj
parameter_list|)
block|{
return|return
operator|new
name|ExpressionStatement
argument_list|(
operator|new
name|AssignmentExpression
argument_list|(
name|varInputRow
argument_list|,
name|AssignmentExpression
operator|.
name|EQUALS
argument_list|,
operator|new
name|CastExpression
argument_list|(
name|TypeName
operator|.
name|forOJClass
argument_list|(
name|inputRowClass
argument_list|)
argument_list|,
name|varInputObj
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|// End IterCalcRel.java
end_comment

end_unit

