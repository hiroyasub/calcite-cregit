begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to DynamoBI Corporation (DynamoBI) under one // or more contributor license agreements.  See the NOTICE file // distributed with this work for additional information // regarding copyright ownership.  DynamoBI licenses this file // to you under the Apache License, Version 2.0 (the // "License"); you may not use this file except in compliance // with the License.  You may obtain a copy of the License at  //   http://www.apache.org/licenses/LICENSE-2.0  // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied.  See the License for the // specific language governing permissions and limitations // under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|rel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|openjava
operator|.
name|ptree
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|trace
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *<code>JavaRelImplementor</code> deals with the nastiness of converting a tree  * of relational expressions into an implementation, generally an {@link  * ParseTree openjava parse tree}.  *  *<p>The {@link #bind} method allows relational expressions to register which  * Java variable holds their row. They can bind 'lazily', so that the variable  * is only declared and initialized if it is actually used in another  * expression.</p>  *  *<p>TODO jvs 14-June-2004: some of JavaRelImplementor is specific to the JAVA  * calling convention; those portions should probably be factored out into a  * subclass.</p>  */
end_comment

begin_class
specifier|public
class|class
name|JavaRelImplementor
implements|implements
name|RelImplementor
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|Logger
name|tracer
init|=
name|EigenbaseTrace
operator|.
name|getRelImplementorTracer
argument_list|()
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/**      * Maps a {@link String} to the {@link Frame} whose {@link      * Frame#rel}.correlVariable == correlName.      */
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Frame
argument_list|>
name|mapCorrel2Frame
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Frame
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|Variable
argument_list|>
name|mapCorrelNameToVariable
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Variable
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Maps a {@link RelNode} to the unique frame whose {@link Frame#rel} is      * that relational expression.      */
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Frame
argument_list|>
name|mapRel2Frame
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|Frame
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Stack of {@link StatementList} objects.      */
specifier|final
name|Stack
argument_list|<
name|StatementList
argument_list|>
name|stmtListStack
init|=
operator|new
name|Stack
argument_list|<
name|StatementList
argument_list|>
argument_list|()
decl_stmt|;
name|Statement
name|exitStatement
decl_stmt|;
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
name|int
name|nextVariableId
decl_stmt|;
specifier|protected
specifier|final
name|OJRexImplementorTable
name|implementorTable
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**      * Creates a JavaRelImplementor      *      * @param rexBuilder Builder for {@link RexNode}s      * @param implementorTable Table of implementations of operators. Must not      * be null      */
specifier|public
name|JavaRelImplementor
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|OJRexImplementorTable
name|implementorTable
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|rexBuilder
operator|!=
literal|null
argument_list|,
literal|"rexBuilder != null"
argument_list|)
expr_stmt|;
name|Util
operator|.
name|pre
argument_list|(
name|implementorTable
operator|!=
literal|null
argument_list|,
literal|"implementorTable != null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|implementorTable
operator|=
name|implementorTable
expr_stmt|;
name|nextVariableId
operator|=
literal|0
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|void
name|setExitStatement
parameter_list|(
name|openjava
operator|.
name|ptree
operator|.
name|Statement
name|stmt
parameter_list|)
block|{
name|this
operator|.
name|exitStatement
operator|=
name|stmt
expr_stmt|;
block|}
specifier|public
name|Statement
name|getExitStatement
parameter_list|()
block|{
return|return
name|exitStatement
return|;
block|}
specifier|public
name|StatementList
name|getStatementList
parameter_list|()
block|{
return|return
name|stmtListStack
operator|.
name|peek
argument_list|()
return|;
block|}
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|rexBuilder
return|;
block|}
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
return|;
block|}
comment|/**      * Records the fact that instances of<code>rel</code> are available in      *<code>variable</code>.      */
specifier|public
name|void
name|bind
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Variable
name|variable
parameter_list|)
block|{
name|bind
argument_list|(
name|rel
argument_list|,
operator|new
name|EagerBind
argument_list|(
name|variable
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Declares a variable, and binds it lazily, so it only gets initialized if      * it is actually used.      *      * @return the Variable so declared      */
specifier|public
name|Variable
name|bind
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|StatementList
name|statementList
parameter_list|,
specifier|final
name|VariableInitializer
name|initializer
parameter_list|)
block|{
name|VariableInitializerThunk
name|thunk
init|=
operator|new
name|VariableInitializerThunk
argument_list|()
block|{
specifier|public
name|VariableInitializer
name|getInitializer
parameter_list|()
block|{
return|return
name|initializer
return|;
block|}
block|}
decl_stmt|;
name|Variable
name|variable
init|=
name|newVariable
argument_list|()
decl_stmt|;
name|LazyBind
name|bind
init|=
operator|new
name|LazyBind
argument_list|(
name|variable
argument_list|,
name|statementList
argument_list|,
name|getTypeFactory
argument_list|()
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|thunk
argument_list|)
decl_stmt|;
name|bind
argument_list|(
name|rel
argument_list|,
name|bind
argument_list|)
expr_stmt|;
return|return
name|bind
operator|.
name|getVariable
argument_list|()
return|;
block|}
comment|/**      * Shares a variable between relations.<code>previous</code> already has a      * variable, and calling this method indicates that<code>rel</code>'s      * output will appear in this variable too.      */
specifier|public
name|void
name|bind
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|previous
parameter_list|)
block|{
name|bind
argument_list|(
name|rel
argument_list|,
operator|new
name|RelBind
argument_list|(
name|previous
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binds a correlating variable. References to correlating variables such as      *<code>$cor2</code> will be replaced with java variables such as<code>      * $Oj14</code>.      */
specifier|public
name|void
name|bindCorrel
parameter_list|(
name|String
name|correlName
parameter_list|,
name|Variable
name|variable
parameter_list|)
block|{
name|mapCorrelNameToVariable
operator|.
name|put
argument_list|(
name|correlName
argument_list|,
name|variable
argument_list|)
expr_stmt|;
block|}
specifier|public
name|JavaRel
name|findRel
parameter_list|(
name|JavaRel
name|rel
parameter_list|,
name|RexNode
name|expression
parameter_list|)
block|{
if|if
condition|(
name|expression
operator|instanceof
name|RexInputRef
condition|)
block|{
name|RexInputRef
name|variable
init|=
operator|(
name|RexInputRef
operator|)
name|expression
decl_stmt|;
comment|// REVIEW jvs 30-May-2005:  What's up with this?  The "&& false"
comment|// should have at least a comment!
if|if
condition|(
operator|(
name|rel
operator|instanceof
name|JoinRelBase
operator|)
operator|&&
literal|false
condition|)
block|{
return|return
operator|(
name|JavaRel
operator|)
name|findInputRel
argument_list|(
name|rel
argument_list|,
name|variable
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|JavaRel
operator|)
name|rel
operator|.
name|getInput
argument_list|(
name|variable
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|expression
operator|instanceof
name|RexFieldAccess
condition|)
block|{
name|RexFieldAccess
name|fieldAccess
init|=
operator|(
name|RexFieldAccess
operator|)
name|expression
decl_stmt|;
name|String
name|fieldName
init|=
name|fieldAccess
operator|.
name|getName
argument_list|()
decl_stmt|;
name|RexNode
name|refExp
init|=
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
decl_stmt|;
name|JavaRel
name|rel2
init|=
name|findRel
argument_list|(
name|rel
argument_list|,
name|refExp
argument_list|)
decl_stmt|;
comment|// recursive
if|if
condition|(
name|rel2
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|implementFieldAccess
argument_list|(
name|rel2
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Burrows into a synthetic record and returns the underlying relation which      * provides the field called<code>fieldName</code>.      */
specifier|public
name|JavaRel
name|implementFieldAccess
parameter_list|(
name|JavaRel
name|rel
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|ProjectRelBase
condition|)
block|{
return|return
operator|(
operator|(
name|ProjectRelBase
operator|)
name|rel
operator|)
operator|.
name|implementFieldAccess
argument_list|(
name|this
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
if|else if
condition|(
name|rel
operator|instanceof
name|IterCalcRel
condition|)
block|{
return|return
operator|(
operator|(
name|IterCalcRel
operator|)
name|rel
operator|)
operator|.
name|implementFieldAccess
argument_list|(
name|this
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Implements the body of the current expression's parent. If<code>      * variable</code> is not null, bind the current expression to<code>      * variable</code>. For example, a nested loops join would generate      *      *<blockquote>      *<pre>      * for (int i = 0; i< emps.length; i++) {      *   Emp emp = emps[i];      *   for (int j = 0; j< depts.length; j++) {      *     Dept dept = depts[j];      *     if (emp.deptno == dept.deptno) {      *<<parent body>>      *     }      *   }      * }      *</pre>      *</blockquote>      *      * which corresponds to      *      *<blockquote>      *<pre>      * [emp:iter      *   [dept:iter      *     [join:body(emp,dept)      *       [parent:body]      *     ]      *   ]      * ]      *</pre>      *</blockquote>      *      * @param rel child relation      * @param stmtList block that child was generating its code into      */
specifier|public
name|void
name|generateParentBody
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|StatementList
name|stmtList
parameter_list|)
block|{
if|if
condition|(
name|stmtList
operator|!=
literal|null
condition|)
block|{
name|pushStatementList
argument_list|(
name|stmtList
argument_list|)
expr_stmt|;
block|}
name|Frame
name|frame
init|=
name|mapRel2Frame
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|bindDeferred
argument_list|(
name|frame
argument_list|,
name|rel
argument_list|)
expr_stmt|;
operator|(
operator|(
name|JavaLoopRel
operator|)
name|frame
operator|.
name|parent
operator|)
operator|.
name|implementJavaParent
argument_list|(
name|this
argument_list|,
name|frame
operator|.
name|ordinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmtList
operator|!=
literal|null
condition|)
block|{
name|popStatementList
argument_list|(
name|stmtList
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|bindDeferred
parameter_list|(
name|Frame
name|frame
parameter_list|,
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|StatementList
name|statementList
init|=
name|getStatementList
argument_list|()
decl_stmt|;
if|if
condition|(
name|frame
operator|.
name|bind
operator|==
literal|null
condition|)
block|{
comment|// this relational expression has not bound itself, so we presume
comment|// that we can call its implementSelf() method
if|if
condition|(
operator|!
operator|(
name|rel
operator|instanceof
name|JavaSelfRel
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"In order to bind-deferred, a "
operator|+
literal|"relational expression must implement JavaSelfRel: "
operator|+
name|rel
argument_list|)
throw|;
block|}
specifier|final
name|JavaSelfRel
name|selfRel
init|=
operator|(
name|JavaSelfRel
operator|)
name|rel
decl_stmt|;
name|LazyBind
name|lazyBind
init|=
operator|new
name|LazyBind
argument_list|(
name|newVariable
argument_list|()
argument_list|,
name|statementList
argument_list|,
name|getTypeFactory
argument_list|()
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
operator|new
name|VariableInitializerThunk
argument_list|()
block|{
specifier|public
name|VariableInitializer
name|getInitializer
parameter_list|()
block|{
return|return
name|selfRel
operator|.
name|implementSelf
argument_list|(
name|JavaRelImplementor
operator|.
name|this
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|bind
argument_list|(
name|rel
argument_list|,
name|lazyBind
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|frame
operator|.
name|bind
operator|instanceof
name|LazyBind
operator|)
operator|&&
operator|(
operator|(
operator|(
name|LazyBind
operator|)
name|frame
operator|.
name|bind
operator|)
operator|.
name|statementList
operator|!=
name|statementList
operator|)
condition|)
block|{
comment|// Frame is already bound, but to a variable declared in a different
comment|// scope. Re-bind it.
specifier|final
name|LazyBind
name|lazyBind
init|=
operator|(
name|LazyBind
operator|)
name|frame
operator|.
name|bind
decl_stmt|;
name|lazyBind
operator|.
name|statementList
operator|=
name|statementList
expr_stmt|;
name|lazyBind
operator|.
name|bound
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**      * Convenience wrapper around {@link RelImplementor#visitChild} for the      * common case where {@link JavaRel} has a child which is a {@link JavaRel}.      */
specifier|public
specifier|final
name|Expression
name|visitJavaChild
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|JavaRel
name|child
parameter_list|)
block|{
return|return
operator|(
name|Expression
operator|)
name|visitChild
argument_list|(
name|parent
argument_list|,
name|ordinal
argument_list|,
name|child
argument_list|)
return|;
block|}
specifier|public
specifier|final
name|Object
name|visitChild
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|child
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
assert|assert
name|child
operator|==
name|parent
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
assert|;
block|}
name|createFrame
argument_list|(
name|parent
argument_list|,
name|ordinal
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
name|visitChildInternal
argument_list|(
name|child
argument_list|,
name|ordinal
argument_list|)
return|;
block|}
specifier|protected
name|void
name|createFrame
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|child
parameter_list|)
block|{
name|Frame
name|frame
init|=
operator|new
name|Frame
argument_list|()
decl_stmt|;
name|frame
operator|.
name|rel
operator|=
name|child
expr_stmt|;
name|frame
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|frame
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|mapRel2Frame
operator|.
name|put
argument_list|(
name|child
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|String
name|correl
init|=
name|child
operator|.
name|getCorrelVariable
argument_list|()
decl_stmt|;
if|if
condition|(
name|correl
operator|!=
literal|null
condition|)
block|{
comment|// Record that this frame is responsible for setting this
comment|// variable. But if another frame is already doing the job --
comment|// this frame's parent, which belongs to the same set -- don't
comment|// override it.
if|if
condition|(
name|mapCorrel2Frame
operator|.
name|get
argument_list|(
name|correl
argument_list|)
operator|==
literal|null
condition|)
block|{
name|mapCorrel2Frame
operator|.
name|put
argument_list|(
name|correl
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|Object
name|visitChildInternal
parameter_list|(
name|RelNode
name|child
parameter_list|)
block|{
return|return
name|visitChildInternal
argument_list|(
name|child
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|public
name|Object
name|visitChildInternal
parameter_list|(
name|RelNode
name|child
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|CallingConvention
name|convention
init|=
name|child
operator|.
name|getConvention
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|JavaRel
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Relational expression '"
operator|+
name|child
operator|+
literal|"' has '"
operator|+
name|convention
operator|+
literal|"' calling convention, so must implement interface "
operator|+
name|JavaRel
operator|.
name|class
argument_list|)
throw|;
block|}
name|JavaRel
name|javaRel
init|=
operator|(
name|JavaRel
operator|)
name|child
decl_stmt|;
specifier|final
name|ParseTree
name|p
init|=
name|javaRel
operator|.
name|implement
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|convention
operator|==
name|CallingConvention
operator|.
name|JAVA
operator|)
operator|&&
operator|(
name|p
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Relational expression '"
operator|+
name|child
operator|+
literal|"' returned '"
operator|+
name|p
operator|+
literal|" on implement, but should have "
operator|+
literal|"returned null, because it has JAVA calling-convention. "
operator|+
literal|"(Note that similar calling-conventions, such as "
operator|+
literal|"Iterator, must return a value.)"
argument_list|)
throw|;
block|}
return|return
name|p
return|;
block|}
comment|/**      * Starts an iteration, by calling {@link      * org.eigenbase.oj.rel.JavaRel#implement} on the root element.      */
specifier|public
name|Expression
name|implementRoot
parameter_list|(
name|JavaRel
name|rel
parameter_list|)
block|{
return|return
name|visitJavaChild
argument_list|(
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|rel
argument_list|)
return|;
block|}
comment|/**      * Creates an expression which references correlating variable<code>      * correlName</code> from the context of<code>rel</code>. For example, if      *<code>correlName</code> is set by the 1st child of<code>rel</code>'s 2nd      * child, then this method returns<code>$input2.$input1</code>.      */
specifier|public
name|Expression
name|makeReference
parameter_list|(
name|String
name|correlName
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|Frame
name|frame
init|=
operator|(
name|Frame
operator|)
name|mapCorrel2Frame
operator|.
name|get
argument_list|(
name|correlName
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|frame
operator|!=
literal|null
operator|)
assert|;
assert|assert
operator|(
name|Util
operator|.
name|equal
argument_list|(
name|frame
operator|.
name|rel
operator|.
name|getCorrelVariable
argument_list|()
argument_list|,
name|correlName
argument_list|)
operator|)
assert|;
assert|assert
operator|(
name|frame
operator|.
name|hasVariable
argument_list|()
operator|)
assert|;
return|return
name|frame
operator|.
name|getVariable
argument_list|()
return|;
block|}
comment|/**      * Generates a variable with a unique name.      */
specifier|public
name|Variable
name|newVariable
parameter_list|()
block|{
return|return
name|newVariable
argument_list|(
literal|"oj_var"
argument_list|)
return|;
block|}
comment|/**      * Generates a variable with a unique name and a stem which indicates its      * purpose. For example,<code>newVariable("binding")</code> might generate      * a variable called<code>"binding_12"</code>.      */
specifier|public
name|Variable
name|newVariable
parameter_list|(
name|String
name|base
parameter_list|)
block|{
assert|assert
name|base
operator|!=
literal|null
assert|;
return|return
operator|new
name|Variable
argument_list|(
name|base
operator|+
name|generateVariableId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @return unique generated variable ID      */
specifier|public
name|int
name|generateVariableId
parameter_list|()
block|{
return|return
name|nextVariableId
operator|++
return|;
block|}
specifier|public
name|Variable
name|getConnectionVariable
parameter_list|()
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"getConnectionVariable"
argument_list|)
throw|;
block|}
specifier|public
name|void
name|popStatementList
parameter_list|(
name|StatementList
name|stmtList
parameter_list|)
block|{
assert|assert
operator|(
name|stmtList
operator|==
name|getStatementList
argument_list|()
operator|)
assert|;
name|stmtListStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|pushStatementList
parameter_list|(
name|StatementList
name|stmtList
parameter_list|)
block|{
name|stmtListStack
operator|.
name|push
argument_list|(
name|stmtList
argument_list|)
expr_stmt|;
block|}
comment|/**      * Converts an expression in internal form (the input relation is referenced      * using the variable<code>$input0</code>) to generated form (the input      * relation is referenced using the bindings in this<code>      * JavaRelImplementor</code>). Compare this method with      * net.sf.saffron.oj.xlat.QueryInfo.convertExpToInternal(), which converts      * from source form to internal form.      *      * @param exp the expression to translate (it is cloned, not modified)      * @param rel the relational expression which is the context for<code>      * exp</code>      */
specifier|public
name|Expression
name|translate
parameter_list|(
name|JavaRel
name|rel
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
name|RexToOJTranslator
name|translator
init|=
name|newTranslator
argument_list|(
name|rel
argument_list|)
decl_stmt|;
return|return
name|translator
operator|.
name|translateRexNode
argument_list|(
name|exp
argument_list|)
return|;
block|}
comment|/**      * Determines whether it is possible to implement a set of expressions in      * Java.      *      * @param program Program to translate      *      * @return whether all expressions in the program can be implemented      */
specifier|public
name|boolean
name|canTranslate
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RexProgram
name|program
parameter_list|)
block|{
name|RexToOJTranslator
name|translator
init|=
name|newTranslator
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|TranslationTester
name|tester
init|=
operator|new
name|TranslationTester
argument_list|(
name|translator
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
name|program
operator|.
name|getExprList
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprList
control|)
block|{
if|if
condition|(
operator|!
name|tester
operator|.
name|canTranslate
argument_list|(
name|expr
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Determines whether it is possible to implement an expression in Java.      *      * @param rel Relational expression      * @param expression Expression      * @param deep if true, operands of the given expression are tested for      * translatability as well; if false only the top level expression is tested      *      * @return whether the expression can be implemented      */
specifier|public
name|boolean
name|canTranslate
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RexNode
name|expression
parameter_list|,
name|boolean
name|deep
parameter_list|)
block|{
name|RexToOJTranslator
name|translator
init|=
name|newTranslator
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|TranslationTester
name|tester
init|=
operator|new
name|TranslationTester
argument_list|(
name|translator
argument_list|,
name|deep
argument_list|)
decl_stmt|;
return|return
name|tester
operator|.
name|canTranslate
argument_list|(
name|expression
argument_list|)
return|;
block|}
comment|/**      * Generates code for an expression, possibly using multiple statements,      * scratch variables, and helper functions.      *      *<p>If you want to avoid generating common expressions, it is better to      * create a translator using {@link #newStmtTranslator(JavaRel,      * StatementList, MemberDeclarationList)} and use it to translate multiple      * expressions.      *      * @param rel the relational expression which is the context for exp      * @param exp the row expression to be translated      * @param stmtList optional code can be appended here      * @param memberList optional member declarations can be appended here (if      * needed for reusable scratch space or helper functions; local variables      * can also be allocated in stmtList)      */
specifier|public
name|Expression
name|translateViaStatements
parameter_list|(
name|JavaRel
name|rel
parameter_list|,
name|RexNode
name|exp
parameter_list|,
name|StatementList
name|stmtList
parameter_list|,
name|MemberDeclarationList
name|memberList
parameter_list|)
block|{
name|RexToOJTranslator
name|translator
init|=
name|newStmtTranslator
argument_list|(
name|rel
argument_list|,
name|stmtList
argument_list|,
name|memberList
argument_list|)
decl_stmt|;
return|return
name|translator
operator|.
name|translateRexNode
argument_list|(
name|exp
argument_list|)
return|;
block|}
comment|/**      * Converts an array of expressions in internal into a list of expressions      * in generated form.      *      * @see #translate(JavaRel,RexNode)      */
specifier|public
name|ExpressionList
name|translateList
parameter_list|(
name|JavaRel
name|rel
parameter_list|,
name|RexNode
index|[]
name|exps
parameter_list|)
block|{
specifier|final
name|ExpressionList
name|list
init|=
operator|new
name|ExpressionList
argument_list|()
decl_stmt|;
name|RexToOJTranslator
name|translator
init|=
name|newTranslator
argument_list|(
name|rel
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exps
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|translator
operator|.
name|translateRexNode
argument_list|(
name|exps
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**      * Creates a {@link RexToOJTranslator} with which to translate the {@link      * RexNode row-expressions} within a relational expression into OpenJava      * expressions.      */
specifier|protected
name|RexToOJTranslator
name|newTranslator
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|new
name|RexToOJTranslator
argument_list|(
name|this
argument_list|,
name|rel
argument_list|,
name|implementorTable
argument_list|)
return|;
block|}
comment|/**      * Creates a translator which can translate a succession of expressions,      * possibly using multiple statements, scratch variables, and helper      * functions.      *      *<p>Typical usage:      *      *<blockquote>      *<pre>      * Translator translator = newStmtTranslator(rel, stmtList, memberList);      * translator.translateRexNode(exp1);      * translator.translateRexNode(exp2);      *</pre>      *</blockquote>      *      * @param rel the relational expression which is the context for exp      * @param stmtList optional code can be appended here      * @param memberList optional member declarations can be appended here (if      * needed for reusable scratch space or helper functions; local variables      */
specifier|public
name|RexToOJTranslator
name|newStmtTranslator
parameter_list|(
specifier|final
name|JavaRel
name|rel
parameter_list|,
name|StatementList
name|stmtList
parameter_list|,
name|MemberDeclarationList
name|memberList
parameter_list|)
block|{
return|return
name|newTranslator
argument_list|(
name|rel
argument_list|)
return|;
block|}
comment|/**      * Creates an expression which references the<i>ordinal</i><sup>th</sup>      * input.      */
specifier|public
name|Expression
name|translateInput
parameter_list|(
name|JavaRel
name|rel
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|fieldOffset
init|=
name|computeFieldOffset
argument_list|(
name|rel
argument_list|,
name|ordinal
argument_list|)
decl_stmt|;
return|return
name|translate
argument_list|(
name|rel
argument_list|,
name|rexBuilder
operator|.
name|makeRangeReference
argument_list|(
name|rowType
argument_list|,
name|fieldOffset
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns the index of the first field in<code>rel</code> which comes from      * its<code>ordinal</code>th input.      *      *<p>For example, if rel joins T0(A,B,C) to T1(D,E), then      * countFields(0,rel) yields 0, and countFields(1,rel) yields 3.</p>      */
specifier|private
name|int
name|computeFieldOffset
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
if|if
condition|(
name|ordinal
operator|==
literal|0
condition|)
block|{
comment|// short-circuit for the common case
return|return
literal|0
return|;
block|}
name|int
name|fieldOffset
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ordinal
condition|;
name|i
operator|++
control|)
block|{
name|RelNode
name|input
init|=
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fieldOffset
operator|+=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|fieldOffset
return|;
block|}
comment|/**      * Creates an expression which references the<i>      * fieldOrdinal</i><sup>th</sup> field of the<i>ordinal</i><sup>th</sup>      * input.      *      *<p>(We can potentially optimize the generation process, so we can access      * field values without actually instantiating the row.)</p>      */
specifier|public
name|Expression
name|translateInputField
parameter_list|(
name|JavaRel
name|rel
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|)
block|{
assert|assert
name|ordinal
operator|>=
literal|0
assert|;
assert|assert
name|ordinal
operator|<
name|rel
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
assert|;
assert|assert
name|fieldOrdinal
operator|>=
literal|0
assert|;
assert|assert
name|fieldOrdinal
operator|<
name|rel
operator|.
name|getInput
argument_list|(
name|ordinal
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
assert|;
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
index|[]
name|fields
init|=
name|rowType
operator|.
name|getFields
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldIndex
init|=
name|computeFieldOffset
argument_list|(
name|rel
argument_list|,
name|ordinal
argument_list|)
operator|+
name|fieldOrdinal
decl_stmt|;
assert|assert
name|fieldIndex
operator|>=
literal|0
assert|;
assert|assert
name|fieldIndex
operator|<
name|fields
operator|.
name|length
assert|;
specifier|final
name|RexNode
name|expr
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|fields
index|[
name|fieldIndex
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|fieldIndex
argument_list|)
decl_stmt|;
return|return
name|translate
argument_list|(
name|rel
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/**      * Records the fact that instances of<code>rel</code> are available via      *<code>bind</code> (which may be eager or lazy).      */
specifier|private
name|void
name|bind
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Bind
name|bind
parameter_list|)
block|{
name|tracer
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Bind "
operator|+
name|rel
operator|.
name|toString
argument_list|()
operator|+
literal|" to "
operator|+
name|bind
argument_list|)
expr_stmt|;
name|Frame
name|frame
init|=
name|mapRel2Frame
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|frame
operator|.
name|bind
operator|=
name|bind
expr_stmt|;
name|boolean
name|stupid
init|=
name|SaffronProperties
operator|.
name|instance
argument_list|()
operator|.
name|stupid
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|stupid
condition|)
block|{
comment|// trigger the declaration of the variable, even though it
comment|// may not be used
name|Util
operator|.
name|discard
argument_list|(
name|bind
operator|.
name|getVariable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|RelNode
name|findInputRel
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
name|findInputRel
argument_list|(
name|rel
argument_list|,
name|offset
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|}
argument_list|)
return|;
block|}
specifier|private
name|RelNode
name|findInputRel
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
index|[]
name|offsets
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|JoinRel
condition|)
block|{
comment|// no variable here -- go deeper
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RelNode
name|result
init|=
name|findInputRel
argument_list|(
name|inputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|offset
argument_list|,
name|offsets
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
if|else if
condition|(
name|offset
operator|==
name|offsets
index|[
literal|0
index|]
condition|)
block|{
return|return
name|rel
return|;
block|}
else|else
block|{
name|offsets
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
return|return
literal|null
return|;
comment|// not found
block|}
comment|/**      * Returns the variable which, in the generated program, will hold the      * current row of a given relational expression. This method is only      * applicable if the relational expression is the current one or an input;      * if it is an ancestor, there is no current value, and this method returns      * null.      */
specifier|public
name|Variable
name|findInputVariable
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|Frame
name|frame
init|=
name|mapRel2Frame
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|frame
operator|!=
literal|null
operator|)
operator|&&
name|frame
operator|.
name|hasVariable
argument_list|()
condition|)
block|{
return|return
name|frame
operator|.
name|getVariable
argument_list|()
return|;
block|}
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|rel
operator|.
name|getInputs
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|rel
operator|=
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
specifier|public
name|Expression
name|implementStart
parameter_list|(
name|AggregateCall
name|call
parameter_list|,
name|JavaRel
name|rel
parameter_list|)
block|{
name|OJAggImplementor
name|aggImplementor
init|=
name|implementorTable
operator|.
name|get
argument_list|(
name|call
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|aggImplementor
operator|.
name|implementStart
argument_list|(
name|this
argument_list|,
name|rel
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|Expression
name|implementStartAndNext
parameter_list|(
name|AggregateCall
name|call
parameter_list|,
name|JavaRel
name|rel
parameter_list|)
block|{
name|OJAggImplementor
name|aggImplementor
init|=
name|implementorTable
operator|.
name|get
argument_list|(
name|call
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|aggImplementor
operator|.
name|implementStartAndNext
argument_list|(
name|this
argument_list|,
name|rel
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|void
name|implementNext
parameter_list|(
name|AggregateCall
name|call
parameter_list|,
name|JavaRel
name|rel
parameter_list|,
name|Expression
name|accumulator
parameter_list|)
block|{
name|OJAggImplementor
name|aggImplementor
init|=
name|implementorTable
operator|.
name|get
argument_list|(
name|call
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
name|aggImplementor
operator|.
name|implementNext
argument_list|(
name|this
argument_list|,
name|rel
argument_list|,
name|accumulator
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
comment|/**      * Generates the expression to retrieve the result of this aggregation.      */
specifier|public
name|Expression
name|implementResult
parameter_list|(
name|AggregateCall
name|call
parameter_list|,
name|Expression
name|accumulator
parameter_list|)
block|{
name|OJAggImplementor
name|aggImplementor
init|=
name|implementorTable
operator|.
name|get
argument_list|(
name|call
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|aggImplementor
operator|.
name|implementResult
argument_list|(
name|this
argument_list|,
name|accumulator
argument_list|,
name|call
argument_list|)
return|;
block|}
comment|/**      * Returns a list of the relational expressions which are ancestors of the      * current one.      *      * @pre // rel must be on the implementation stack      */
specifier|public
name|List
argument_list|<
name|RelNode
argument_list|>
name|getAncestorRels
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|ancestorList
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
name|Frame
name|frame
init|=
name|mapRel2Frame
operator|.
name|get
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|Util
operator|.
name|pre
argument_list|(
name|frame
operator|!=
literal|null
argument_list|,
literal|"rel must be on the current implementation stack"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|ancestorList
operator|.
name|add
argument_list|(
name|frame
operator|.
name|rel
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|parentRel
init|=
name|frame
operator|.
name|parent
decl_stmt|;
if|if
condition|(
name|parentRel
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|frame
operator|=
name|mapRel2Frame
operator|.
name|get
argument_list|(
name|parentRel
argument_list|)
expr_stmt|;
name|Util
operator|.
name|permAssert
argument_list|(
name|frame
operator|!=
literal|null
argument_list|,
literal|"ancestor rel must have frame"
argument_list|)
expr_stmt|;
block|}
return|return
name|ancestorList
return|;
block|}
comment|//~ Inner Interfaces -------------------------------------------------------
comment|/**      * A<code>VariableInitializerThunk</code> yields a {@link      * VariableInitializer}.      */
specifier|public
interface|interface
name|VariableInitializerThunk
block|{
name|VariableInitializer
name|getInitializer
parameter_list|()
function_decl|;
block|}
specifier|private
interface|interface
name|Bind
block|{
name|Variable
name|getVariable
parameter_list|()
function_decl|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|private
specifier|static
class|class
name|EagerBind
implements|implements
name|Bind
block|{
name|Variable
name|variable
decl_stmt|;
name|EagerBind
parameter_list|(
name|Variable
name|variable
parameter_list|)
block|{
name|this
operator|.
name|variable
operator|=
name|variable
expr_stmt|;
block|}
specifier|public
name|Variable
name|getVariable
parameter_list|()
block|{
return|return
name|variable
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"(variable="
operator|+
name|variable
operator|.
name|toString
argument_list|()
operator|+
literal|")"
return|;
block|}
block|}
comment|/**      * Binds a relational expression to whatever another relational expression      * is currently bound to.      *      *<p>Note that if relational expressions are shared, then this binding can      * change over time. Consider, for instance "select * from emps where deptno      * = 10 union select * from emps where deptno = 20". There will be a reader      * of "emps" which is used by the two filter expressions "deptno = 10" and      * "deptno = 20". The "emp" reader will assign its current row to "var4" in      * the first binding, and to "var8" in the second.</p>      */
specifier|private
class|class
name|RelBind
implements|implements
name|Bind
block|{
specifier|private
specifier|final
name|RelNode
name|rel
decl_stmt|;
name|RelBind
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
block|}
specifier|public
name|Variable
name|getVariable
parameter_list|()
block|{
specifier|final
name|Frame
name|frame
init|=
name|findFrame
argument_list|()
decl_stmt|;
return|return
name|frame
operator|.
name|getVariable
argument_list|()
return|;
block|}
specifier|private
name|Frame
name|findFrame
parameter_list|()
block|{
name|RelNode
name|previous
init|=
name|rel
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Frame
name|frame
init|=
name|mapRel2Frame
operator|.
name|get
argument_list|(
name|previous
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|.
name|bind
operator|!=
literal|null
condition|)
block|{
name|tracer
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINE
argument_list|,
literal|"Bind "
operator|+
name|rel
operator|.
name|toString
argument_list|()
operator|+
literal|" to "
operator|+
name|previous
operator|.
name|toString
argument_list|()
operator|+
literal|"("
operator|+
name|frame
operator|.
name|bind
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
name|frame
return|;
block|}
comment|// go deeper
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|previous
operator|.
name|getInputs
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|inputs
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|:
literal|"input is not bound"
assert|;
name|previous
operator|=
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|Frame
block|{
comment|/**          *<code>rel</code>'s parent          */
name|RelNode
name|parent
decl_stmt|;
comment|/**          * relation which is being implemented in this frame          */
name|RelNode
name|rel
decl_stmt|;
comment|/**          * ordinal of<code>rel</code> within<code>parent</code>          */
name|int
name|ordinal
decl_stmt|;
comment|/**          * Holds variable which hasn't been declared yet.          */
specifier|private
name|Bind
name|bind
decl_stmt|;
comment|/**          * Retrieves the variable, executing the lazy bind if necessary.          */
name|Variable
name|getVariable
parameter_list|()
block|{
assert|assert
operator|(
name|hasVariable
argument_list|()
operator|)
assert|;
return|return
name|bind
operator|.
name|getVariable
argument_list|()
return|;
block|}
comment|/**          * Returns whether the frame has, or potentially has, a variable.          */
name|boolean
name|hasVariable
parameter_list|()
block|{
return|return
name|bind
operator|!=
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|LazyBind
implements|implements
name|Bind
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|final
name|RelDataType
name|type
decl_stmt|;
specifier|final
name|Statement
name|after
decl_stmt|;
name|StatementList
name|statementList
decl_stmt|;
specifier|final
name|Variable
name|variable
decl_stmt|;
specifier|final
name|VariableInitializerThunk
name|thunk
decl_stmt|;
name|boolean
name|bound
decl_stmt|;
name|LazyBind
parameter_list|(
name|Variable
name|variable
parameter_list|,
name|StatementList
name|statementList
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|VariableInitializerThunk
name|thunk
parameter_list|)
block|{
name|this
operator|.
name|variable
operator|=
name|variable
expr_stmt|;
name|this
operator|.
name|statementList
operator|=
name|statementList
expr_stmt|;
name|this
operator|.
name|after
operator|=
operator|(
name|statementList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|null
else|:
name|statementList
operator|.
name|get
argument_list|(
name|statementList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|typeFactory
expr_stmt|;
name|this
operator|.
name|thunk
operator|=
name|thunk
expr_stmt|;
block|}
specifier|public
name|Variable
name|getVariable
parameter_list|()
block|{
if|if
condition|(
operator|!
name|bound
condition|)
block|{
name|bound
operator|=
literal|true
expr_stmt|;
name|int
name|position
init|=
name|find
argument_list|(
name|statementList
argument_list|,
name|after
argument_list|)
decl_stmt|;
name|VariableDeclaration
name|varDecl
init|=
operator|new
name|VariableDeclaration
argument_list|(
name|OJUtil
operator|.
name|toTypeName
argument_list|(
name|type
argument_list|,
name|typeFactory
argument_list|)
argument_list|,
name|variable
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|statementList
operator|.
name|insertElementAt
argument_list|(
name|varDecl
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|varDecl
operator|.
name|setInitializer
argument_list|(
name|thunk
operator|.
name|getInitializer
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|variable
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"(variable="
operator|+
name|variable
operator|.
name|toString
argument_list|()
operator|+
literal|", thunk="
operator|+
name|thunk
operator|.
name|toString
argument_list|()
operator|+
literal|")"
return|;
block|}
specifier|private
specifier|static
name|int
name|find
parameter_list|(
name|StatementList
name|list
parameter_list|,
name|Statement
name|statement
parameter_list|)
block|{
if|if
condition|(
name|statement
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|list
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
name|statement
condition|)
block|{
return|return
name|i
operator|+
literal|1
return|;
block|}
block|}
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"could not find statement "
operator|+
name|statement
operator|+
literal|" in list "
operator|+
name|list
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Similar to {@link RexToOJTranslator}, but instead of translating, merely      * tests whether an expression can be translated.      */
specifier|public
specifier|static
class|class
name|TranslationTester
block|{
specifier|private
specifier|final
name|RexToOJTranslator
name|translator
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|deep
decl_stmt|;
specifier|public
name|TranslationTester
parameter_list|(
name|RexToOJTranslator
name|translator
parameter_list|,
name|boolean
name|deep
parameter_list|)
block|{
name|this
operator|.
name|translator
operator|=
name|translator
expr_stmt|;
name|this
operator|.
name|deep
operator|=
name|deep
expr_stmt|;
block|}
comment|/**          * Returns whether an expression can be translated.          */
specifier|public
name|boolean
name|canTranslate
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
try|try
block|{
name|go
argument_list|(
name|rex
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|CannotTranslate
name|cannotTranslate
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**          * Walks over an expression, and throws<code>CannotTranslate</code>          * if expression cannot be translated.          *          * @param rex Expression          *          * @throws org.eigenbase.oj.rel.JavaRelImplementor.TranslationTester.CannotTranslate          * if expression or a sub-expression cannot be translated          */
specifier|protected
name|void
name|go
parameter_list|(
name|RexNode
name|rex
parameter_list|)
throws|throws
name|CannotTranslate
block|{
if|if
condition|(
name|rex
operator|instanceof
name|RexCall
condition|)
block|{
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
if|if
condition|(
operator|!
name|translator
operator|.
name|canConvertCall
argument_list|(
name|call
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CannotTranslate
argument_list|()
throw|;
block|}
if|if
condition|(
operator|!
name|deep
condition|)
block|{
return|return;
block|}
name|RexNode
index|[]
name|operands
init|=
name|call
operator|.
name|operands
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|go
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|rex
operator|instanceof
name|RexFieldAccess
condition|)
block|{
if|if
condition|(
operator|!
name|deep
condition|)
block|{
return|return;
block|}
name|go
argument_list|(
operator|(
operator|(
name|RexFieldAccess
operator|)
name|rex
operator|)
operator|.
name|getReferenceExpr
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Thrown when we encounter an expression which cannot be translated. It          * is always handled by {@link TranslationTester#canTranslate(RexNode)},          * and is not really an error.          */
specifier|private
specifier|static
class|class
name|CannotTranslate
extends|extends
name|Exception
block|{
specifier|public
name|CannotTranslate
parameter_list|()
block|{
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End JavaRelImplementor.java
end_comment

end_unit

