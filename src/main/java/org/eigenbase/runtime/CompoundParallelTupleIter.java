begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|runtime
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|test
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *<code>CompoundParallelTupleIter</code> creates one TupleIter out of several.  * Unlike its serial counterpart {@link CompoundTupleIter}, it runs all its  * inputs in parallel, in separate threads that it spawns. It outputs the next  * element available from any of its inputs. Note that the order of output rows  * is indeterminate, since it is unpredictable which input will arrive next.  *  *<p>The compound TupleIter is finished when all of its inputs are finished.  * The set of input iterators is fixed at construction.  *  *<p>This variant is needed when an input is infinite, since CompoundTupleIter  * would hang. Extending this class to preserve order is problematic, given its  * low level:  *  *<ul>  *<li>items Are now synthetic {@link Object}s.</li>  *<li>Items would have to become things that expose a {@link Comparable}<i>  * key</i> value.</li>  *<li>Even if one input lags behind the other provding a {@link  * Iterator#next()} value, that missing value might sort before its available  * counterparts from the other inputs. There is no basis to decide to wait for  * it or not.</li>  *</ul>  *  * @author Marc Berkowitz  * @version $Id$  */
end_comment

begin_class
specifier|public
class|class
name|CompoundParallelTupleIter
extends|extends
name|AbstractTupleIter
block|{
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|TupleIter
index|[]
name|in
decl_stmt|;
specifier|private
specifier|final
name|boolean
index|[]
name|endOfData
decl_stmt|;
specifier|private
name|int
name|i
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|CompoundParallelTupleIter
parameter_list|(
name|TupleIter
index|[]
name|tupleIters
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|tupleIters
expr_stmt|;
name|this
operator|.
name|endOfData
operator|=
operator|new
name|boolean
index|[
name|tupleIters
operator|.
name|length
index|]
expr_stmt|;
name|this
operator|.
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|Object
name|fetchNext
parameter_list|()
block|{
name|int
name|endOfDataCount
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|N
init|=
name|in
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|offset
init|=
literal|0
init|;
name|offset
operator|<
name|N
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|N
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|endOfData
index|[
name|i
index|]
condition|)
block|{
name|endOfDataCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|Object
name|o
init|=
name|in
index|[
name|i
index|]
operator|.
name|fetchNext
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NoDataReason
operator|.
name|END_OF_DATA
condition|)
block|{
name|endOfData
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
name|endOfDataCount
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|o
operator|==
name|NoDataReason
operator|.
name|UNDERFLOW
condition|)
block|{
comment|// Ignore this.
block|}
else|else
block|{
return|return
name|o
return|;
block|}
block|}
block|}
if|if
condition|(
name|endOfDataCount
operator|==
name|N
condition|)
block|{
return|return
name|NoDataReason
operator|.
name|END_OF_DATA
return|;
block|}
return|return
name|NoDataReason
operator|.
name|UNDERFLOW
return|;
block|}
specifier|public
name|void
name|restart
parameter_list|()
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|in
operator|.
name|length
condition|;
name|index
operator|++
control|)
block|{
name|in
index|[
name|index
index|]
operator|.
name|restart
argument_list|()
expr_stmt|;
name|endOfData
index|[
name|index
index|]
operator|=
literal|false
expr_stmt|;
block|}
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|closeAllocation
parameter_list|()
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|in
operator|.
name|length
condition|;
name|index
operator|++
control|)
block|{
name|in
index|[
name|index
index|]
operator|.
name|closeAllocation
argument_list|()
expr_stmt|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|public
specifier|static
class|class
name|Test
extends|extends
name|EigenbaseTestCase
block|{
specifier|public
name|Test
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|Exception
block|{
name|super
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|// The CompoundParallelTupleIter preserves the order of 2 elements
comment|// from the same source, but may transpose 2 elements from different
comment|// soureces. Being sloppy, just test that the actual results match the
comment|// expected results when resorted.
specifier|protected
name|void
name|assertEquals
parameter_list|(
name|TupleIter
name|tupleIter
parameter_list|,
name|Object
index|[]
name|expected
parameter_list|)
comment|// expected vals -- sorted in place
block|{
name|Object
index|[]
name|actual
init|=
name|toList
argument_list|(
name|tupleIter
argument_list|)
operator|.
name|toArray
argument_list|()
decl_stmt|;
comment|// get results
name|Arrays
operator|.
name|sort
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testCompoundParallelTupleIter2
parameter_list|()
block|{
name|TupleIter
name|tupleIter
init|=
operator|new
name|CompoundParallelTupleIter
argument_list|(
operator|new
name|TupleIter
index|[]
block|{
name|makeTupleIter
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|)
block|,
name|makeTupleIter
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"c"
block|}
argument_list|)
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|tupleIter
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testCompoundParallelTupleIter1
parameter_list|()
block|{
name|TupleIter
name|tupleIter
init|=
operator|new
name|CompoundParallelTupleIter
argument_list|(
operator|new
name|TupleIter
index|[]
block|{
name|makeTupleIter
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|}
argument_list|)
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|tupleIter
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testCompoundParallelTupleIter3
parameter_list|()
block|{
name|TupleIter
name|tupleIter
init|=
operator|new
name|CompoundParallelTupleIter
argument_list|(
operator|new
name|TupleIter
index|[]
block|{
name|makeTupleIter
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|}
argument_list|)
block|,
name|makeTupleIter
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"d"
block|,
literal|"e"
block|}
argument_list|)
block|,
name|makeTupleIter
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"f"
block|}
argument_list|)
block|,                     }
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|tupleIter
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testCompoundParallelIterEmpty1
parameter_list|()
block|{
name|TupleIter
name|tupleIter
init|=
operator|new
name|CompoundParallelTupleIter
argument_list|(
operator|new
name|TupleIter
index|[]
block|{}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|tupleIter
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|testCompoundParallelIterEmpty2
parameter_list|()
block|{
name|TupleIter
name|tupleIter
init|=
operator|new
name|CompoundParallelTupleIter
argument_list|(
operator|new
name|TupleIter
index|[]
block|{
name|makeTupleIter
argument_list|(
operator|new
name|String
index|[]
block|{}
argument_list|)
block|,
name|makeTupleIter
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|)
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|tupleIter
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End CompoundParallelTupleIter.java
end_comment

end_unit

