begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|runtime
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|trace
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Adapter that exposes a 'push' producer as an {@link Iterator}. Supports one  * or more producers feeding into a single consumer. The consumer and the  * producers must each run in its own thread. When there are several producers  * the data is merged as it arrives: no sorting.  *  *<p>By default, the queue contains at most one object (implemented via {@link  * SynchronousQueue}), but this can be customized by supplying an alternate  * implementation (e.g. {@link ArrayBlockingQueue}) to the constructor. If you  * call {@link #next}, your thread will wait until a producer thread calls  * {@link #put} or {@link #done}. Nulls are allowed. If a producer has an error,  * it can pass it to the consumer via {@link #done}.</p>  *  * @author jhyde  * @version $Id$  * @since Oct 20, 2003  */
end_comment

begin_class
specifier|public
class|class
name|QueueIterator
implements|implements
name|Iterator
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|WrappedNull
name|WRAPPED_NULL
init|=
operator|new
name|WrappedNull
argument_list|()
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|// NOTE: numProducers is the only state variable requiring synchronization.
comment|// All others are accessed only from the consumer end, which does not
comment|// support consumption from multiple threads.  (The queue itself provides
comment|// its own synchronization.)
specifier|private
name|int
name|numProducers
decl_stmt|;
comment|// a wrapping class can provide its tracer, which is used here to trace
comment|// synchronization events
specifier|private
specifier|final
name|EigenbaseLogger
name|tracer
decl_stmt|;
comment|/**      * next Iterator value (nulls are represented via #WRAPPED_NULL)      */
specifier|protected
name|Object
name|next
decl_stmt|;
comment|/**      * false when Iterator is finished      */
specifier|protected
name|boolean
name|hasNext
decl_stmt|;
specifier|protected
name|Throwable
name|throwable
decl_stmt|;
specifier|protected
name|BlockingQueue
name|queue
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**      * default constructor (one producer, no tracer, SynchronousQueue)      */
specifier|public
name|QueueIterator
parameter_list|()
block|{
name|this
argument_list|(
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param n number of producers      * @param tracer trace to this Logger, or null.      */
specifier|public
name|QueueIterator
parameter_list|(
name|int
name|n
parameter_list|,
name|Logger
name|tracer
parameter_list|)
block|{
name|this
argument_list|(
name|n
argument_list|,
name|tracer
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param n number of producers      * @param tracer trace to this Logger, or null.      * @param queue {@link BlockingQueue}  implementation, or null for default      */
specifier|public
name|QueueIterator
parameter_list|(
name|int
name|n
parameter_list|,
name|Logger
name|tracer
parameter_list|,
name|BlockingQueue
name|queue
parameter_list|)
block|{
name|numProducers
operator|=
name|n
expr_stmt|;
name|this
operator|.
name|tracer
operator|=
operator|(
name|tracer
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
operator|new
name|EigenbaseLogger
argument_list|(
name|tracer
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|queue
operator|=
operator|new
name|SynchronousQueue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|hasNext
operator|=
literal|false
expr_stmt|;
comment|// done now
return|return;
block|}
name|hasNext
operator|=
literal|true
expr_stmt|;
block|}
comment|//~ Methods ---------------------------------------------------------------
specifier|public
name|StringBuilder
name|printStatus
parameter_list|(
name|StringBuilder
name|b
parameter_list|)
block|{
name|b
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|throwable
operator|!=
literal|null
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|" error: "
argument_list|)
operator|.
name|append
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasNext
condition|)
block|{
if|if
condition|(
name|queue
operator|instanceof
name|ArrayBlockingQueue
condition|)
block|{
comment|// Kludge - expect an ArrayBlockingQueue
name|ArrayBlockingQueue
name|abq
init|=
operator|(
name|ArrayBlockingQueue
operator|)
name|queue
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|" size: "
argument_list|)
operator|.
name|append
argument_list|(
name|abq
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"size ?"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|" done"
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
specifier|protected
name|void
name|reset
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|hasNext
operator|=
literal|true
expr_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
name|throwable
operator|=
literal|null
expr_stmt|;
name|numProducers
operator|=
name|n
expr_stmt|;
block|}
comment|/**      * Producer calls<code>done</code> to say that there are no more objects,      * setting<code>throwable</code> if there was an error.      */
specifier|public
name|void
name|done
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|EndOfQueue
name|eoq
init|=
literal|null
decl_stmt|;
comment|// NOTE:  synchronized can't be around queue.put or we'll deadlock
synchronized|synchronized
init|(
name|this
init|)
block|{
name|numProducers
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|numProducers
operator|==
literal|0
operator|)
operator|||
operator|(
name|throwable
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// shut down the iterator
name|eoq
operator|=
operator|new
name|EndOfQueue
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eoq
operator|!=
literal|null
condition|)
block|{
comment|// put a dummy null to wake up the consumer, who will check
comment|// for
try|try
block|{
name|queue
operator|.
name|put
argument_list|(
name|eoq
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
comment|// implement Iterator
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|next
operator|=
name|queue
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
name|checkTermination
argument_list|()
expr_stmt|;
return|return
name|hasNext
return|;
block|}
comment|/**      * As {@link #hasNext}, but throws {@link TimeoutException} if no row is      * available within the timeout.      *      * @param timeoutMillis Milliseconds to wait; less than or equal to zero      * means don't wait      */
specifier|public
name|boolean
name|hasNext
parameter_list|(
name|long
name|timeoutMillis
parameter_list|)
throws|throws
name|TimeoutException
block|{
if|if
condition|(
operator|!
name|hasNext
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|timeoutMillis
operator|<=
literal|0
condition|)
block|{
name|next
operator|=
name|queue
operator|.
name|poll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|queue
operator|.
name|poll
argument_list|(
name|timeoutMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
block|}
name|checkTermination
argument_list|()
expr_stmt|;
return|return
name|hasNext
return|;
block|}
comment|// implement Iterator
specifier|public
name|Object
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
comment|// It is illegal to call next when there are no more objects.
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|Object
name|o
init|=
name|next
decl_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|WRAPPED_NULL
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|o
return|;
block|}
block|}
comment|/**      * As {@link #next}, but throws {@link TimeoutException} if no row is      * available within the timeout.      *      * @param timeoutMillis Milliseconds to wait; less than or equal to zero      * means don't wait      */
specifier|public
name|Object
name|next
parameter_list|(
name|long
name|timeoutMillis
parameter_list|)
throws|throws
name|TimeoutException
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|(
name|timeoutMillis
argument_list|)
condition|)
block|{
comment|// It is illegal to call next when there are no more objects.
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|next
argument_list|()
return|;
block|}
comment|/**      * Producer calls<code>put</code> to add another object (which may be      * null).      *      * @param o object to put      *      * @throws IllegalStateException if this method is called after {@link      * #done}      */
specifier|public
name|void
name|put
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasNext
condition|)
block|{
comment|// It is illegal to add a new object after done() has been called.
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|o
operator|=
name|WRAPPED_NULL
expr_stmt|;
block|}
try|try
block|{
name|queue
operator|.
name|put
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**      * Producer calls<code>offer</code> to attempt to add another object (which      * may be null) with a timeout.      *      * @param o object to offer      * @param timeoutMillis Milliseconds to wait; less than or equal to zero      * means don't wait      *      * @return true if offer accepted      *      * @throws IllegalStateException if this method is called after {@link      * #done}      */
specifier|public
name|boolean
name|offer
parameter_list|(
name|Object
name|o
parameter_list|,
name|long
name|timeoutMillis
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasNext
condition|)
block|{
comment|// It is illegal to add a new object after done() has been called.
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|o
operator|=
name|WRAPPED_NULL
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|timeoutMillis
operator|<=
literal|0
condition|)
block|{
return|return
name|queue
operator|.
name|offer
argument_list|(
name|o
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|queue
operator|.
name|offer
argument_list|(
name|o
argument_list|,
name|timeoutMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
comment|// implement Iterator
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**      * Checks for end-of-queue, and throws an error if one has been set via      * {@link #done(Throwable)}.      */
specifier|protected
name|void
name|checkTermination
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|next
operator|instanceof
name|EndOfQueue
operator|)
condition|)
block|{
return|return;
block|}
name|EndOfQueue
name|eoq
init|=
operator|(
name|EndOfQueue
operator|)
name|next
decl_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
name|hasNext
operator|=
literal|false
expr_stmt|;
name|throwable
operator|=
name|eoq
operator|.
name|throwable
expr_stmt|;
name|onEndOfQueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|throwable
operator|==
literal|null
condition|)
block|{
empty_stmt|;
block|}
if|else if
condition|(
name|throwable
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|throwable
throw|;
block|}
if|else if
condition|(
name|throwable
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|throwable
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|Error
argument_list|(
literal|"error: "
operator|+
name|throwable
argument_list|)
throw|;
block|}
block|}
comment|/**      * Called (from the consumer thread context) just before the iterator      * returns false for hasNext(). Default implementation does nothing, but      * subclasses can use this for cleanup actions.      */
specifier|protected
name|void
name|onEndOfQueue
parameter_list|()
block|{
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**      * Thrown by {@link QueueIterator#hasNext(long)} and {@link      * QueueIterator#next(long)} to indicate that operation timed out before      * rows were available.      */
specifier|public
specifier|static
class|class
name|TimeoutException
extends|extends
name|Exception
block|{     }
comment|/**      * Sentinel object.      */
specifier|private
specifier|static
class|class
name|EndOfQueue
block|{
name|Throwable
name|throwable
decl_stmt|;
name|EndOfQueue
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|this
operator|.
name|throwable
operator|=
name|throwable
expr_stmt|;
block|}
block|}
comment|/**      * A null masquerading as a real object.      */
specifier|private
specifier|static
class|class
name|WrappedNull
block|{     }
block|}
end_class

begin_comment
comment|// End QueueIterator.java
end_comment

end_unit

