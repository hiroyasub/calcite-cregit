begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|rex
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util14
operator|.
name|DateTimeUtil
import|;
end_import

begin_comment
comment|/**  * Factory for row expressions.  *  *<p>Some common literal values (NULL, TRUE, FALSE, 0, 1, '') are cached.</p>  *  * @author jhyde  * @version $Id$  * @since Nov 23, 2003  */
end_comment

begin_class
specifier|public
class|class
name|RexBuilder
block|{
comment|/** Special operator that accesses an unadvertised field of an input record.      * This operator cannot be used in SQL queries; it is introduced temporarily      * during sql-to-rel translation, then replaced during the process that      * trims unwanted fields. */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|GET_OPERATOR
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"_get"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|)
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|private
specifier|final
name|RexLiteral
name|booleanTrue
decl_stmt|;
specifier|private
specifier|final
name|RexLiteral
name|booleanFalse
decl_stmt|;
specifier|private
specifier|final
name|RexLiteral
name|charEmpty
decl_stmt|;
specifier|private
specifier|final
name|RexLiteral
name|constantNull
decl_stmt|;
specifier|private
specifier|final
name|SqlStdOperatorTable
name|opTab
init|=
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**      * Creates a RexBuilder.      *      * @param typeFactory Type factory      */
specifier|public
name|RexBuilder
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
name|this
operator|.
name|typeFactory
operator|=
name|typeFactory
expr_stmt|;
name|this
operator|.
name|booleanTrue
operator|=
name|makeLiteral
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
name|this
operator|.
name|booleanFalse
operator|=
name|makeLiteral
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
name|this
operator|.
name|charEmpty
operator|=
name|makeLiteral
argument_list|(
operator|new
name|NlsString
argument_list|(
literal|""
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
expr_stmt|;
name|this
operator|.
name|constantNull
operator|=
name|makeLiteral
argument_list|(
literal|null
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * Returns this RexBuilder's type factory      *      * @return type factory      */
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|typeFactory
return|;
block|}
comment|/**      * Returns this RexBuilder's operator table      *      * @return operator table      */
specifier|public
name|SqlStdOperatorTable
name|getOpTab
parameter_list|()
block|{
return|return
name|opTab
return|;
block|}
comment|/**      * Creates an expression accessing a given named field from a record.      *      * @param expr Expression yielding a record      * @param fieldName Name of field in record      *      * @return Expression accessing a given named field      */
specifier|public
name|RexNode
name|makeFieldAccess
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|type
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Type '"
operator|+
name|type
operator|+
literal|"' has no field '"
operator|+
name|fieldName
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|makeFieldAccessInternal
argument_list|(
name|expr
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/**      * Creates an expression accessing a field with a given ordinal from a      * record.      *      * @param expr Expression yielding a record      * @param i Ordinal of field      *      * @return Expression accessing given field      */
specifier|public
name|RexNode
name|makeFieldAccess
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
index|[]
name|fields
init|=
name|type
operator|.
name|getFields
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|>=
name|fields
operator|.
name|length
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Field ordinal "
operator|+
name|i
operator|+
literal|" is invalid for "
operator|+
literal|" type '"
operator|+
name|type
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|makeFieldAccessInternal
argument_list|(
name|expr
argument_list|,
name|fields
index|[
name|i
index|]
argument_list|)
return|;
block|}
comment|/**      * Creates an expression accessing a given field from a record.      *      * @param expr Expression yielding a record      * @param field Field      *      * @return Expression accessing given field      */
specifier|private
name|RexNode
name|makeFieldAccessInternal
parameter_list|(
name|RexNode
name|expr
parameter_list|,
specifier|final
name|RelDataTypeField
name|field
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexRangeRef
condition|)
block|{
name|RexRangeRef
name|range
init|=
operator|(
name|RexRangeRef
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getIndex
argument_list|()
operator|<
literal|0
condition|)
block|{
return|return
name|makeCall
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|GET_OPERATOR
argument_list|,
name|expr
argument_list|,
name|makeLiteral
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|RexInputRef
argument_list|(
name|range
operator|.
name|getOffset
argument_list|()
operator|+
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|new
name|RexFieldAccess
argument_list|(
name|expr
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/**      * Creates a call with an array of arguments and a predetermined type.      */
specifier|public
name|RexNode
name|makeCall
parameter_list|(
name|RelDataType
name|returnType
parameter_list|,
name|SqlOperator
name|op
parameter_list|,
name|RexNode
modifier|...
name|exprs
parameter_list|)
block|{
return|return
operator|new
name|RexCall
argument_list|(
name|returnType
argument_list|,
name|op
argument_list|,
name|exprs
argument_list|)
return|;
block|}
comment|/**      * Creates a call with an array of arguments.      *      *<p>This is the fundamental method called by all of the other<code>      * makeCall</code> methods. If you derive a class from {@link RexBuilder},      * this is the only method you need to override.</p>      */
specifier|public
name|RexNode
name|makeCall
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|RexNode
modifier|...
name|exprs
parameter_list|)
block|{
comment|// TODO jvs 12-Jun-2010:  Find a better place for this;
comment|// it surely does not belong here.
if|if
condition|(
name|op
operator|==
name|SqlStdOperatorTable
operator|.
name|andOperator
operator|&&
name|exprs
operator|.
name|length
operator|==
literal|2
operator|&&
name|exprs
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|exprs
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|// Avoid generating 'AND(x, x)'; this can cause plan explosions if a
comment|// relnode is its own child and is merged with itself.
return|return
name|exprs
index|[
literal|0
index|]
return|;
block|}
specifier|final
name|RelDataType
name|type
init|=
name|deriveReturnType
argument_list|(
name|op
argument_list|,
name|typeFactory
argument_list|,
name|exprs
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexCall
argument_list|(
name|type
argument_list|,
name|op
argument_list|,
name|exprs
argument_list|)
return|;
block|}
comment|/**      * Creates a call with a list of arguments.      *      *<p>Equivalent to<code>makeCall(op, exprList.toArray(new      * RexNode[exprList.size()]))</code>.      */
specifier|public
specifier|final
name|RexNode
name|makeCall
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprList
parameter_list|)
block|{
return|return
name|makeCall
argument_list|(
name|op
argument_list|,
name|exprList
operator|.
name|toArray
argument_list|(
operator|new
name|RexNode
index|[
name|exprList
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Derives the return type of a call to an operator.      *      * @param op the operator being called      * @param typeFactory factory for return type      * @param exprs actual operands      *      * @return derived type      */
specifier|public
name|RelDataType
name|deriveReturnType
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RexNode
index|[]
name|exprs
parameter_list|)
block|{
return|return
name|op
operator|.
name|inferReturnType
argument_list|(
operator|new
name|RexCallBinding
argument_list|(
name|typeFactory
argument_list|,
name|op
argument_list|,
name|exprs
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates a reference to an aggregate call, checking for repeated calls.      */
specifier|public
name|RexNode
name|addAggCall
parameter_list|(
name|AggregateCall
name|aggCall
parameter_list|,
name|int
name|groupCount
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
parameter_list|,
name|Map
argument_list|<
name|AggregateCall
argument_list|,
name|RexNode
argument_list|>
name|aggCallMapping
parameter_list|)
block|{
name|RexNode
name|rex
init|=
name|aggCallMapping
operator|.
name|get
argument_list|(
name|aggCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|rex
operator|==
literal|null
condition|)
block|{
name|int
name|index
init|=
name|aggCalls
operator|.
name|size
argument_list|()
operator|+
name|groupCount
decl_stmt|;
name|aggCalls
operator|.
name|add
argument_list|(
name|aggCall
argument_list|)
expr_stmt|;
name|rex
operator|=
name|makeInputRef
argument_list|(
name|aggCall
operator|.
name|getType
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|aggCallMapping
operator|.
name|put
argument_list|(
name|aggCall
argument_list|,
name|rex
argument_list|)
expr_stmt|;
block|}
return|return
name|rex
return|;
block|}
comment|/**      * Creates a call to a windowed agg.      */
specifier|public
name|RexNode
name|makeOver
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|SqlAggFunction
name|operator
parameter_list|,
name|RexNode
index|[]
name|exprs
parameter_list|,
name|RexNode
index|[]
name|partitionKeys
parameter_list|,
name|RexNode
index|[]
name|orderKeys
parameter_list|,
name|SqlNode
name|lowerBound
parameter_list|,
name|SqlNode
name|upperBound
parameter_list|,
name|boolean
name|physical
parameter_list|,
name|boolean
name|allowPartial
parameter_list|,
name|boolean
name|nullWhenCountZero
parameter_list|)
block|{
assert|assert
name|operator
operator|!=
literal|null
assert|;
assert|assert
name|exprs
operator|!=
literal|null
assert|;
assert|assert
name|partitionKeys
operator|!=
literal|null
assert|;
assert|assert
name|orderKeys
operator|!=
literal|null
assert|;
specifier|final
name|RexWindow
name|window
init|=
name|makeWindow
argument_list|(
name|partitionKeys
argument_list|,
name|orderKeys
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|physical
argument_list|)
decl_stmt|;
specifier|final
name|RexOver
name|over
init|=
operator|new
name|RexOver
argument_list|(
name|type
argument_list|,
name|operator
argument_list|,
name|exprs
argument_list|,
name|window
argument_list|)
decl_stmt|;
name|RexNode
name|result
init|=
name|over
decl_stmt|;
comment|// This should be correct but need time to go over test results.
comment|// Also want to look at combing with section below.
if|if
condition|(
name|nullWhenCountZero
condition|)
block|{
specifier|final
name|RelDataType
name|bigintType
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
name|result
operator|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOperator
argument_list|,
operator|new
name|RexOver
argument_list|(
name|bigintType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|countOperator
argument_list|,
name|exprs
argument_list|,
name|window
argument_list|)
argument_list|,
name|makeLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bigintType
argument_list|,
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
argument_list|)
argument_list|,
name|over
argument_list|,
name|makeCast
argument_list|(
name|over
operator|.
name|getType
argument_list|()
argument_list|,
name|constantNull
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allowPartial
condition|)
block|{
name|Util
operator|.
name|permAssert
argument_list|(
name|physical
argument_list|,
literal|"DISALLOW PARTIAL over RANGE"
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|bigintType
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
comment|// todo: read bound
name|result
operator|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
argument_list|,
operator|new
name|RexOver
argument_list|(
name|bigintType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|countOperator
argument_list|,
name|RexNode
operator|.
name|EMPTY_ARRAY
argument_list|,
name|window
argument_list|)
argument_list|,
name|makeLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|2
argument_list|)
argument_list|,
name|bigintType
argument_list|,
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|,
name|constantNull
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Creates a window specification.      *      * @param partitionKeys Partition keys      * @param orderKeys Order keys      * @param lowerBound Lower bound      * @param upperBound Upper bound      * @param physical Whether physical. True if row-based, false if range-based      * @return window specification      */
specifier|public
name|RexWindow
name|makeWindow
parameter_list|(
name|RexNode
index|[]
name|partitionKeys
parameter_list|,
name|RexNode
index|[]
name|orderKeys
parameter_list|,
name|SqlNode
name|lowerBound
parameter_list|,
name|SqlNode
name|upperBound
parameter_list|,
name|boolean
name|physical
parameter_list|)
block|{
return|return
operator|new
name|RexWindow
argument_list|(
name|partitionKeys
argument_list|,
name|orderKeys
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|physical
argument_list|)
return|;
block|}
comment|/**      * Creates a constant for the SQL<code>NULL</code> value.      */
specifier|public
name|RexLiteral
name|constantNull
parameter_list|()
block|{
return|return
name|constantNull
return|;
block|}
comment|/**      * Creates an expression referencing a correlation variable.      *      * @param type Type of variable      * @param name Name of variable      *      * @return Correlation variable      */
specifier|public
name|RexNode
name|makeCorrel
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
operator|new
name|RexCorrelVariable
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**      * Creates an invocation of the NEW operator.      *      * @param type Type to be instantiated      * @param exprs Arguments to NEW operator      *      * @return Expression invoking NEW operator      */
specifier|public
name|RexNode
name|makeNewInvocation
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
index|[]
name|exprs
parameter_list|)
block|{
return|return
operator|new
name|RexCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|newOperator
argument_list|,
name|exprs
argument_list|)
return|;
block|}
comment|/**      * Creates a call to the CAST operator, expanding if possible.      *      * @param type Type to cast to      * @param exp Expression being cast      *      * @return Call to CAST operator      */
specifier|public
name|RexNode
name|makeCast
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
specifier|final
name|SqlTypeName
name|sqlType
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|exp
operator|instanceof
name|RexLiteral
condition|)
block|{
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|exp
decl_stmt|;
specifier|final
name|Comparable
name|value
init|=
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|RexLiteral
operator|.
name|valueMatchesType
argument_list|(
name|value
argument_list|,
name|sqlType
argument_list|,
literal|false
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|value
operator|instanceof
name|NlsString
operator|)
operator|||
operator|(
name|type
operator|instanceof
name|BasicSqlType
operator|&&
name|type
operator|.
name|getPrecision
argument_list|()
operator|>=
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
operator|)
operator|)
condition|)
block|{
return|return
name|makeLiteral
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isInterval
argument_list|(
name|type
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|exp
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|makeCastExactToInterval
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|else if
condition|(
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type
argument_list|)
operator|&&
name|SqlTypeUtil
operator|.
name|isInterval
argument_list|(
name|exp
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|makeCastIntervalToExact
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|else if
condition|(
name|sqlType
operator|==
name|SqlTypeName
operator|.
name|BOOLEAN
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|exp
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|makeCastExactToBoolean
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|else if
condition|(
name|exp
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BOOLEAN
operator|&&
name|SqlTypeUtil
operator|.
name|isExactNumeric
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|makeCastBooleanToExact
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
return|return
name|makeAbstractCast
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|makeCastExactToBoolean
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
return|return
name|makeCall
argument_list|(
name|toType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|notEqualsOperator
argument_list|,
name|exp
argument_list|,
name|makeZeroLiteral
argument_list|(
name|exp
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|makeCastBooleanToExact
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
specifier|final
name|RexNode
name|casted
init|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|exp
argument_list|,
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|toType
argument_list|)
argument_list|,
name|makeZeroLiteral
argument_list|(
name|toType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exp
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|casted
return|;
block|}
return|return
name|makeCall
argument_list|(
name|toType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNotNullOperator
argument_list|,
name|exp
argument_list|)
argument_list|,
name|casted
argument_list|,
name|makeNullLiteral
argument_list|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|makeCastIntervalToExact
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
name|IntervalSqlType
name|intervalType
init|=
operator|(
name|IntervalSqlType
operator|)
name|exp
operator|.
name|getType
argument_list|()
decl_stmt|;
name|TimeUnit
name|endUnit
init|=
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getEndUnit
argument_list|()
decl_stmt|;
if|if
condition|(
name|endUnit
operator|==
literal|null
condition|)
block|{
name|endUnit
operator|=
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
expr_stmt|;
block|}
name|int
name|scale
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|endUnit
operator|==
name|TimeUnit
operator|.
name|SECOND
condition|)
block|{
name|scale
operator|=
name|Math
operator|.
name|min
argument_list|(
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getFractionalSecondPrecision
argument_list|()
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|BigDecimal
name|multiplier
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|endUnit
operator|.
name|multiplier
argument_list|)
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scale
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|value
init|=
name|decodeIntervalOrDecimal
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiplier
operator|.
name|longValue
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|value
operator|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|divideIntegerOperator
argument_list|,
name|value
argument_list|,
name|makeBigintLiteral
argument_list|(
name|multiplier
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
name|RelDataType
name|decimalType
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|scale
operator|+
name|intervalType
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|value
operator|=
name|encodeIntervalOrDecimal
argument_list|(
name|value
argument_list|,
name|decimalType
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|ensureType
argument_list|(
name|toType
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|makeCastExactToInterval
parameter_list|(
name|RelDataType
name|toType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
name|IntervalSqlType
name|intervalType
init|=
operator|(
name|IntervalSqlType
operator|)
name|toType
decl_stmt|;
name|TimeUnit
name|endUnit
init|=
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getEndUnit
argument_list|()
decl_stmt|;
if|if
condition|(
name|endUnit
operator|==
literal|null
condition|)
block|{
name|endUnit
operator|=
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
expr_stmt|;
block|}
name|int
name|scale
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|endUnit
operator|==
name|TimeUnit
operator|.
name|SECOND
condition|)
block|{
name|scale
operator|=
name|Math
operator|.
name|min
argument_list|(
name|intervalType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getFractionalSecondPrecision
argument_list|()
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|BigDecimal
name|multiplier
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|endUnit
operator|.
name|multiplier
argument_list|)
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scale
argument_list|)
argument_list|)
decl_stmt|;
name|RelDataType
name|decimalType
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|scale
operator|+
name|intervalType
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|RexNode
name|value
init|=
name|decodeIntervalOrDecimal
argument_list|(
name|ensureType
argument_list|(
name|decimalType
argument_list|,
name|exp
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiplier
operator|.
name|longValue
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|value
operator|=
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|multiplyOperator
argument_list|,
name|value
argument_list|,
name|makeExactLiteral
argument_list|(
name|multiplier
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|encodeIntervalOrDecimal
argument_list|(
name|value
argument_list|,
name|toType
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Casts a decimal's integer representation to a decimal node. If the      * expression is not the expected integer type, then it is casted first.      *      *<p>An overflow check may be requested to ensure the internal value      * does not exceed the maximum value of the decimal type.      *      * @param value integer representation of decimal      * @param type type integer will be reinterpreted as      * @param checkOverflow indicates whether an overflow check is required      * when reinterpreting this particular value as the decimal type. A      * check usually not required for arithmetic, but is often required for      * rounding and explicit casts.      *      * @return the integer reinterpreted as an opaque decimal type      */
specifier|public
name|RexNode
name|encodeIntervalOrDecimal
parameter_list|(
name|RexNode
name|value
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|boolean
name|checkOverflow
parameter_list|)
block|{
name|RelDataType
name|bigintType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
name|RexNode
name|cast
init|=
name|ensureType
argument_list|(
name|bigintType
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|makeReinterpretCast
argument_list|(
name|type
argument_list|,
name|cast
argument_list|,
name|makeLiteral
argument_list|(
name|checkOverflow
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Retrieves an interval or decimal node's integer representation      *      * @param node the interval or decimal value as an opaque type      *      * @return an integer representation of the decimal value      */
specifier|public
name|RexNode
name|decodeIntervalOrDecimal
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
assert|assert
operator|(
name|SqlTypeUtil
operator|.
name|isDecimal
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
operator|||
name|SqlTypeUtil
operator|.
name|isInterval
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
operator|)
assert|;
name|RelDataType
name|bigintType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
return|return
name|makeReinterpretCast
argument_list|(
name|matchNullability
argument_list|(
name|bigintType
argument_list|,
name|node
argument_list|)
argument_list|,
name|node
argument_list|,
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates a call to the CAST operator.      *      * @param type Type to cast to      * @param exp Expression being cast      *      * @return Call to CAST operator      */
specifier|public
name|RexNode
name|makeAbstractCast
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
return|return
operator|new
name|RexCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|castFunc
argument_list|,
operator|new
name|RexNode
index|[]
block|{
name|exp
block|}
argument_list|)
return|;
block|}
comment|/**      * Makes a reinterpret cast.      *      * @param type type returned by the cast      * @param exp expression to be casted      * @param checkOverflow whether an overflow check is required      *      * @return a RexCall with two operands and a special return type      */
specifier|public
name|RexNode
name|makeReinterpretCast
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|exp
parameter_list|,
name|RexNode
name|checkOverflow
parameter_list|)
block|{
name|RexNode
index|[]
name|args
decl_stmt|;
if|if
condition|(
operator|(
name|checkOverflow
operator|!=
literal|null
operator|)
operator|&&
name|checkOverflow
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|args
operator|=
operator|new
name|RexNode
index|[]
block|{
name|exp
block|,
name|checkOverflow
block|}
expr_stmt|;
block|}
else|else
block|{
name|args
operator|=
operator|new
name|RexNode
index|[]
block|{
name|exp
block|}
expr_stmt|;
block|}
return|return
operator|new
name|RexCall
argument_list|(
name|type
argument_list|,
name|SqlStdOperatorTable
operator|.
name|reinterpretOperator
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**      * Makes an expression which converts a value of type T to a value of type T      * NOT NULL, or throws if the value is NULL. If the expression is already      * NOT NULL, does nothing.      */
specifier|public
name|RexNode
name|makeNotNullCast
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|expr
return|;
block|}
name|RelDataType
name|typeNotNull
init|=
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|RexCall
argument_list|(
name|typeNotNull
argument_list|,
name|SqlStdOperatorTable
operator|.
name|castFunc
argument_list|,
operator|new
name|RexNode
index|[]
block|{
name|expr
block|}
argument_list|)
return|;
block|}
comment|/**      * Creates a reference to all the fields in the row. That is, the whole row      * as a single record object.      *      * @param rowType Type of the input row.      */
specifier|public
name|RexNode
name|makeRangeReference
parameter_list|(
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
operator|new
name|RexRangeRef
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * Creates a reference to all the fields in the row.      *      *<p>For example, if the input row has type<code>T{f0,f1,f2,f3,f4}</code>      * then<code>makeRangeReference(T{f0,f1,f2,f3,f4}, S{f3,f4}, 3)</code> is      * an expression which yields the last 2 fields.      *      * @param type Type of the resulting range record.      * @param offset Index of first field.      * @param nullable Whether the record is nullable.      */
specifier|public
name|RexNode
name|makeRangeReference
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|nullable
parameter_list|)
block|{
if|if
condition|(
name|nullable
operator|&&
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|nullable
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexRangeRef
argument_list|(
name|type
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/**      * Creates a reference to a given field of the input record.      *      * @param type Type of field      * @param i Ordinal of field      *      * @return Reference to field      */
specifier|public
name|RexInputRef
name|makeInputRef
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|type
operator|=
name|SqlTypeUtil
operator|.
name|addCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|typeFactory
argument_list|)
expr_stmt|;
return|return
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**      * Creates a literal representing a flag.      *      * @param flag Flag value; must be either a {@link      * org.eigenbase.util14.Enum14.Value} or a {@link Enum}, and hence a {@link      * Comparable}.      */
specifier|public
name|RexLiteral
name|makeFlag
parameter_list|(
name|Object
name|flag
parameter_list|)
block|{
assert|assert
name|flag
operator|!=
literal|null
assert|;
assert|assert
operator|(
name|flag
operator|instanceof
name|EnumeratedValues
operator|.
name|Value
operator|)
operator|||
operator|(
name|flag
operator|instanceof
name|Enum
operator|)
assert|;
assert|assert
name|flag
operator|instanceof
name|Comparable
assert|;
return|return
name|makeLiteral
argument_list|(
operator|(
name|Comparable
operator|)
name|flag
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SYMBOL
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|SYMBOL
argument_list|)
return|;
block|}
comment|/**      * Internal method to create a call to a literal. Code outside this package      * should call one of the type-specific methods such as {@link      * #makeDateLiteral(Calendar)}, {@link #makeLiteral(boolean)}, {@link      * #makeLiteral(String)}.      *      * @param o Value of literal, must be appropriate for the type      * @param type Type of literal      * @param typeName SQL type of literal      *      * @return Literal      */
specifier|protected
name|RexLiteral
name|makeLiteral
parameter_list|(
name|Comparable
name|o
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|)
block|{
comment|// All literals except NULL have NOT NULL types.
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|o
operator|==
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeName
operator|==
name|SqlTypeName
operator|.
name|CHAR
condition|)
block|{
comment|// Character literals must have a charset and collation. Populate
comment|// from the type if necessary.
assert|assert
name|o
operator|instanceof
name|NlsString
assert|;
name|NlsString
name|nlsString
init|=
operator|(
name|NlsString
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|(
name|nlsString
operator|.
name|getCollation
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|nlsString
operator|.
name|getCharset
argument_list|()
operator|==
literal|null
operator|)
condition|)
block|{
assert|assert
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
assert|;
assert|assert
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
operator|!=
literal|null
assert|;
assert|assert
name|type
operator|.
name|getCollation
argument_list|()
operator|!=
literal|null
assert|;
name|o
operator|=
operator|new
name|NlsString
argument_list|(
name|nlsString
operator|.
name|getValue
argument_list|()
argument_list|,
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|type
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|RexLiteral
argument_list|(
name|o
argument_list|,
name|type
argument_list|,
name|typeName
argument_list|)
return|;
block|}
comment|/**      * Creates a boolean literal.      */
specifier|public
name|RexLiteral
name|makeLiteral
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
return|return
name|b
condition|?
name|booleanTrue
else|:
name|booleanFalse
return|;
block|}
comment|/**      * Creates a numeric literal.      */
specifier|public
name|RexLiteral
name|makeExactLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
name|RelDataType
name|relType
decl_stmt|;
name|int
name|scale
init|=
name|bd
operator|.
name|scale
argument_list|()
decl_stmt|;
name|long
name|l
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
operator|.
name|longValue
argument_list|()
decl_stmt|;
assert|assert
operator|(
operator|(
name|scale
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|scale
operator|<=
name|SqlTypeName
operator|.
name|MAX_NUMERIC_SCALE
operator|)
operator|)
assert|;
assert|assert
operator|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|l
argument_list|,
name|scale
argument_list|)
operator|.
name|equals
argument_list|(
name|bd
argument_list|)
operator|)
assert|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|>=
name|Integer
operator|.
name|MIN_VALUE
operator|)
operator|&&
operator|(
name|l
operator|<=
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|)
block|{
name|relType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|precision
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|relType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|scale
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
return|return
name|makeExactLiteral
argument_list|(
name|bd
argument_list|,
name|relType
argument_list|)
return|;
block|}
comment|/**      * Creates a BIGINT literal.      */
specifier|public
name|RexLiteral
name|makeBigintLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
name|RelDataType
name|bigintType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
return|return
name|makeLiteral
argument_list|(
name|bd
argument_list|,
name|bigintType
argument_list|,
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
return|;
block|}
comment|/**      * Creates a numeric literal.      */
specifier|public
name|RexLiteral
name|makeExactLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|makeLiteral
argument_list|(
name|bd
argument_list|,
name|type
argument_list|,
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
return|;
block|}
comment|/**      * Creates a byte array literal.      */
specifier|public
name|RexLiteral
name|makeBinaryLiteral
parameter_list|(
name|byte
index|[]
name|byteArray
parameter_list|)
block|{
return|return
name|makeLiteral
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|byteArray
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BINARY
argument_list|,
name|byteArray
operator|.
name|length
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|BINARY
argument_list|)
return|;
block|}
comment|/**      * Creates a double-precision literal.      */
specifier|public
name|RexLiteral
name|makeApproxLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|)
block|{
comment|// Validator should catch if underflow is allowed
comment|// If underflow is allowed, let underflow become zero
if|if
condition|(
name|bd
operator|.
name|doubleValue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|bd
operator|=
name|BigDecimal
operator|.
name|ZERO
expr_stmt|;
block|}
return|return
name|makeApproxLiteral
argument_list|(
name|bd
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates an approximate numeric literal (double or float).      *      * @param bd literal value      * @param type approximate numeric type      *      * @return new literal      */
specifier|public
name|RexLiteral
name|makeApproxLiteral
parameter_list|(
name|BigDecimal
name|bd
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
assert|assert
operator|(
name|SqlTypeFamily
operator|.
name|APPROXIMATE_NUMERIC
operator|.
name|getTypeNames
argument_list|()
operator|.
name|contains
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
operator|)
assert|;
return|return
name|makeLiteral
argument_list|(
name|bd
argument_list|,
name|type
argument_list|,
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
return|;
block|}
comment|/**      * Creates a character string literal.      *      * @pre s != null      */
specifier|public
name|RexLiteral
name|makeLiteral
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|makePreciseStringLiteral
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|/**      * Creates a character string literal with type CHAR and default charset and      * collation.      *      * @param s String value      *      * @return Character string literal      */
specifier|protected
name|RexLiteral
name|makePreciseStringLiteral
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|s
operator|!=
literal|null
argument_list|,
literal|"s != null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
return|return
name|charEmpty
return|;
block|}
else|else
block|{
return|return
name|makeLiteral
argument_list|(
operator|new
name|NlsString
argument_list|(
name|s
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
return|;
block|}
block|}
comment|/**      * Ensures expression is interpreted as a specified type. The returned      * expression may be wrapped with a cast.      *      * @param type desired type      * @param node expression      * @param matchNullability whether to correct nullability of specified      * type to match the expression; this usually should be true, except for      * explicit casts which can override default nullability      *      * @return a casted expression or the original expression      */
specifier|public
name|RexNode
name|ensureType
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|node
parameter_list|,
name|boolean
name|matchNullability
parameter_list|)
block|{
name|RelDataType
name|targetType
init|=
name|type
decl_stmt|;
if|if
condition|(
name|matchNullability
condition|)
block|{
name|targetType
operator|=
name|matchNullability
argument_list|(
name|type
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|targetType
argument_list|)
condition|)
block|{
return|return
name|makeCast
argument_list|(
name|targetType
argument_list|,
name|node
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
comment|/**      * Ensures that a type's nullability matches a value's nullability.      */
specifier|public
name|RelDataType
name|matchNullability
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|RexNode
name|value
parameter_list|)
block|{
name|boolean
name|typeNullability
init|=
name|type
operator|.
name|isNullable
argument_list|()
decl_stmt|;
name|boolean
name|valueNullability
init|=
name|value
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeNullability
operator|!=
name|valueNullability
condition|)
block|{
return|return
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
name|valueNullability
argument_list|)
return|;
block|}
return|return
name|type
return|;
block|}
comment|/**      * Creates a character string literal from an {@link NlsString}.      *      *<p>If the string's charset and collation are not set, uses the system      * defaults.      *      * @pre str != null      */
specifier|public
name|RexLiteral
name|makeCharLiteral
parameter_list|(
name|NlsString
name|str
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|str
operator|!=
literal|null
argument_list|,
literal|"str != null"
argument_list|)
expr_stmt|;
name|RelDataType
name|type
init|=
name|SqlUtil
operator|.
name|createNlsStringType
argument_list|(
name|typeFactory
argument_list|,
name|str
argument_list|)
decl_stmt|;
return|return
name|makeLiteral
argument_list|(
name|str
argument_list|,
name|type
argument_list|,
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
return|;
block|}
comment|/**      * Creates a Date literal.      *      * @pre date != null      */
specifier|public
name|RexLiteral
name|makeDateLiteral
parameter_list|(
name|Calendar
name|date
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|date
operator|!=
literal|null
argument_list|,
literal|"date != null"
argument_list|)
expr_stmt|;
return|return
name|makeLiteral
argument_list|(
name|date
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|DATE
argument_list|)
return|;
block|}
comment|/**      * Creates a Time literal.      *      * @pre time != null      */
specifier|public
name|RexLiteral
name|makeTimeLiteral
parameter_list|(
name|Calendar
name|time
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|time
operator|!=
literal|null
argument_list|,
literal|"time != null"
argument_list|)
expr_stmt|;
return|return
name|makeLiteral
argument_list|(
name|time
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|,
name|precision
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|TIME
argument_list|)
return|;
block|}
comment|/**      * Creates a Timestamp literal.      *      * @pre timestamp != null      */
specifier|public
name|RexLiteral
name|makeTimestampLiteral
parameter_list|(
name|Calendar
name|timestamp
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|timestamp
operator|!=
literal|null
argument_list|,
literal|"timestamp != null"
argument_list|)
expr_stmt|;
return|return
name|makeLiteral
argument_list|(
name|timestamp
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|,
name|precision
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
return|;
block|}
comment|/**      * Creates an interval literal.      */
specifier|public
name|RexLiteral
name|makeIntervalLiteral
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|intervalQualifier
operator|!=
literal|null
argument_list|,
literal|"intervalQualifier != null"
argument_list|)
expr_stmt|;
return|return
name|makeLiteral
argument_list|(
literal|null
argument_list|,
name|typeFactory
operator|.
name|createSqlIntervalType
argument_list|(
name|intervalQualifier
argument_list|)
argument_list|,
name|intervalQualifier
operator|.
name|isYearMonth
argument_list|()
condition|?
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
else|:
name|SqlTypeName
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
return|;
block|}
comment|/**      * Creates an interval literal.      */
specifier|public
name|RexLiteral
name|makeIntervalLiteral
parameter_list|(
name|long
name|l
parameter_list|,
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|makeLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|l
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlIntervalType
argument_list|(
name|intervalQualifier
argument_list|)
argument_list|,
name|intervalQualifier
operator|.
name|isYearMonth
argument_list|()
condition|?
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
else|:
name|SqlTypeName
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
return|;
block|}
comment|/**      * Creates a reference to a dynamic parameter      *      * @param type Type of dynamic parameter      * @param index Index of dynamic parameter      *      * @return Expression referencing dynamic parameter      */
specifier|public
name|RexDynamicParam
name|makeDynamicParam
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|RexDynamicParam
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**      * Creates an expression corresponding to a null literal, cast to a specific      * type and precision      *      * @param typeName name of the type that the null will be cast to      * @param precision precision of the type      *      * @return created expression      */
specifier|public
name|RexNode
name|makeNullLiteral
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|constantNull
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates a literal whose value is NULL, with a particular type.      *      *<p>The typing is necessary because RexNodes are strictly typed. For      * example, in the Rex world the<code>NULL</code> parameter to<code>      * SUBSTRING(NULL FROM 2 FOR 4)</code> must have a valid VARCHAR type so      * that the result type can be determined.      *      * @param typeName Type to cast NULL to      *      * @return NULL literal of given type      */
specifier|public
name|RexNode
name|makeNullLiteral
parameter_list|(
name|SqlTypeName
name|typeName
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|constantNull
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates a copy of an expression, which may have been created using a      * different RexBuilder and/or {@link RelDataTypeFactory}, using this      * RexBuilder.      *      * @param expr Expression      *      * @return Copy of expression      *      * @see RelDataTypeFactory#copyType(RelDataType)      */
specifier|public
name|RexNode
name|copy
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|expr
operator|.
name|accept
argument_list|(
operator|new
name|RexCopier
argument_list|(
name|this
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates a literal of the default value for the given type.      *      * @see #makeZeroLiteral(org.eigenbase.reltype.RelDataType, boolean)      *      * @param type Type      * @return Simple literal      */
specifier|public
name|RexLiteral
name|makeZeroLiteral
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|(
name|RexLiteral
operator|)
name|makeZeroLiteral
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates an expression of the default value for the given type, casting if      * necessary to ensure that the expression is the exact type.      *      *<p>This value is:</p>      *      *<ul>      *<li>0 for numeric types;      *<li>FALSE for BOOLEAN;      *<li>The epoch for TIMESTAMP and DATE;      *<li>Midnight for TIME;      *<li>The empty string for string types (CHAR, BINARY, VARCHAR, VARBINARY).      *</ul>      *      * @param type Type      * @param allowCast Whether to allow a cast. If false, value is always a      *    {@link RexLiteral} but may not be the exact type      * @return Simple literal, or cast simple literal      */
specifier|public
name|RexNode
name|makeZeroLiteral
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|boolean
name|allowCast
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|RexLiteral
name|literal
decl_stmt|;
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|CHAR
case|:
return|return
name|makeCharLiteral
argument_list|(
operator|new
name|NlsString
argument_list|(
name|Util
operator|.
name|spaces
argument_list|(
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
case|case
name|VARCHAR
case|:
name|literal
operator|=
name|makeCharLiteral
argument_list|(
operator|new
name|NlsString
argument_list|(
literal|""
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowCast
condition|)
block|{
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|literal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|literal
return|;
block|}
case|case
name|BINARY
case|:
return|return
name|makeBinaryLiteral
argument_list|(
operator|new
name|byte
index|[
name|type
operator|.
name|getPrecision
argument_list|()
index|]
argument_list|)
return|;
case|case
name|VARBINARY
case|:
name|literal
operator|=
name|makeBinaryLiteral
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowCast
condition|)
block|{
return|return
name|makeCast
argument_list|(
name|type
argument_list|,
name|literal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|literal
return|;
block|}
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|type
argument_list|)
return|;
case|case
name|FLOAT
case|:
case|case
name|REAL
case|:
case|case
name|DOUBLE
case|:
return|return
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|type
argument_list|)
return|;
case|case
name|BOOLEAN
case|:
return|return
name|booleanFalse
return|;
case|case
name|TIME
case|:
return|return
name|makeTimeLiteral
argument_list|(
name|DateTimeUtil
operator|.
name|zeroCalendar
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
return|;
case|case
name|DATE
case|:
return|return
name|makeDateLiteral
argument_list|(
name|DateTimeUtil
operator|.
name|zeroCalendar
argument_list|)
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|makeTimestampLiteral
argument_list|(
name|DateTimeUtil
operator|.
name|zeroCalendar
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RexBuilder.java
end_comment

end_unit

