begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|relopt
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|RemoveTrivialProjectRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * Substitutes part of a tree of relational expressions with another tree.  *  *<p>The call {@code new SubstitutionVisitor(find, query).go(replacement))  * will return {@code query} with every occurrence of {@code find} replaced  * by {@code replacement}.</p>  *  *<p>The following example shows how {@code SubstitutionVisitor} can be used  * for materialized view recognition.</p>  *  *<ul>  *<li>query = SELECT a, c FROM t WHERE x = 5 AND b = 4</li>  *<li>find = SELECT a, b, c FROM t WHERE x = 5</li>  *<li>replacement = SELECT * FROM mv</li>  *<li>result = SELECT a, c FROM mv WHERE b = 4</li>  *</ul>  *  *<p>Note that {@code result} uses the materialized view table {@code mv} and a  * simplified condition {@code b = 4}.</p>  *  *<p>Uses a bottom-up matching algorithm. Nodes do not need to be identical.  * At each level, returns the residue.</p>  *  *<p>The inputs must only include the core relational operators:  * {@link org.eigenbase.rel.TableAccessRel},  * {@link org.eigenbase.rel.FilterRel},  * {@link org.eigenbase.rel.ProjectRel},  * {@link org.eigenbase.rel.JoinRel},  * {@link org.eigenbase.rel.UnionRel},  * {@link org.eigenbase.rel.AggregateRel}.</p>  */
end_comment

begin_class
specifier|public
class|class
name|SubstitutionVisitor
block|{
specifier|private
specifier|final
name|RelNode
name|query
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|find
decl_stmt|;
comment|/** Map from each node in the query and the materialization query      * to its parent. */
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|parentMap
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|RelNode
argument_list|,
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Nodes in {@link #find} that have no children. */
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|findLeaves
decl_stmt|;
comment|/** Nodes in {@link #query} that have no children. */
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|queryLeaves
decl_stmt|;
comment|/** Map from leaves in {@link #find} to leaves in {@link #query}. */
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|leafMap
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|replacementMap
init|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|SubstitutionVisitor
parameter_list|(
name|RelNode
name|find
parameter_list|,
name|RelNode
name|query
parameter_list|)
block|{
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|this
operator|.
name|find
operator|=
name|find
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelNode
argument_list|>
name|parents
init|=
operator|new
name|HashSet
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|allNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RelVisitor
name|visitor
init|=
operator|new
name|RelVisitor
argument_list|()
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|parentMap
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
name|parent
argument_list|,
name|ordinal
argument_list|)
argument_list|)
expr_stmt|;
name|parents
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|find
argument_list|)
expr_stmt|;
comment|// Populate the list of leaves in the tree under "find".
comment|// Leaves are all nodes that are not parents.
comment|// For determinism, it is important that the list is in scan order.
name|allNodes
operator|.
name|removeAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|findLeaves
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|allNodes
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|allNodes
operator|.
name|removeAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|queryLeaves
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|allNodes
argument_list|)
expr_stmt|;
block|}
comment|// TODO: move to RelOptUtil
specifier|private
specifier|static
name|boolean
name|contains
parameter_list|(
name|RelNode
name|ancestor
parameter_list|,
specifier|final
name|RelNode
name|target
parameter_list|)
block|{
if|if
condition|(
name|ancestor
operator|==
name|target
condition|)
block|{
comment|// Short-cut common case.
return|return
literal|true
return|;
block|}
try|try
block|{
operator|new
name|RelVisitor
argument_list|()
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|target
condition|)
block|{
throw|throw
name|FoundRel
operator|.
name|INSTANCE
throw|;
block|}
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
operator|.
name|go
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|FoundRel
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
specifier|private
specifier|static
name|RelNode
name|replace
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|find
parameter_list|,
name|RelNode
name|replace
parameter_list|)
block|{
if|if
condition|(
name|find
operator|==
name|replace
condition|)
block|{
comment|// Short-cut common case.
return|return
name|query
return|;
block|}
assert|assert
name|equalType
argument_list|(
literal|"find"
argument_list|,
name|find
argument_list|,
literal|"replace"
argument_list|,
name|replace
argument_list|)
assert|;
if|if
condition|(
name|query
operator|==
name|find
condition|)
block|{
comment|// Short-cut another common case.
return|return
name|replace
return|;
block|}
return|return
name|replaceRecurse
argument_list|(
name|query
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|RelNode
name|replaceRecurse
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|find
parameter_list|,
name|RelNode
name|replace
parameter_list|)
block|{
if|if
condition|(
name|query
operator|==
name|find
condition|)
block|{
return|return
name|replace
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
name|query
operator|.
name|getInputs
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|inputs
control|)
block|{
name|newInputs
operator|.
name|add
argument_list|(
name|replaceRecurse
argument_list|(
name|input
argument_list|,
name|find
argument_list|,
name|replace
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newInputs
operator|.
name|equals
argument_list|(
name|inputs
argument_list|)
condition|)
block|{
return|return
name|query
operator|.
name|copy
argument_list|(
name|query
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
return|;
block|}
block|}
return|return
name|query
return|;
block|}
specifier|public
name|RelNode
name|go
parameter_list|(
name|RelNode
name|replacement
parameter_list|)
block|{
assert|assert
name|equalType
argument_list|(
literal|"find"
argument_list|,
name|find
argument_list|,
literal|"replacement"
argument_list|,
name|replacement
argument_list|)
assert|;
name|replacementMap
operator|.
name|put
argument_list|(
name|find
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
specifier|final
name|UnifyResult
name|unifyResult
init|=
name|matchRecurse
argument_list|(
name|find
argument_list|)
decl_stmt|;
if|if
condition|(
name|unifyResult
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelNode
name|node
init|=
name|replace
argument_list|(
name|query
argument_list|,
name|unifyResult
operator|.
name|query
argument_list|,
name|unifyResult
operator|.
name|result
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Convert: query="
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|query
argument_list|)
operator|+
literal|"\nnode="
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|UnifyResult
name|matchRecurse
parameter_list|(
name|RelNode
name|find
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|findInputs
init|=
name|find
operator|.
name|getInputs
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|queryInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
name|RelNode
name|queryParent
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RelNode
name|findInput
range|:
name|findInputs
control|)
block|{
name|UnifyResult
name|unifyResult
init|=
name|matchRecurse
argument_list|(
name|findInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|unifyResult
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|queryInputs
operator|.
name|add
argument_list|(
name|unifyResult
operator|.
name|result
argument_list|)
expr_stmt|;
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
name|parentMap
operator|.
name|get
argument_list|(
name|unifyResult
operator|.
name|query
argument_list|)
decl_stmt|;
name|queryParent
operator|=
name|pair
operator|.
name|left
expr_stmt|;
block|}
for|for
control|(
name|UnifyRule
name|rule
range|:
name|RULES
control|)
block|{
if|if
condition|(
name|findInputs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RelNode
name|queryLeaf
range|:
name|queryLeaves
control|)
block|{
specifier|final
name|UnifyResult
name|x
init|=
name|apply
argument_list|(
name|rule
argument_list|,
name|queryLeaf
argument_list|,
name|find
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
return|return
name|x
return|;
block|}
block|}
block|}
else|else
block|{
specifier|final
name|UnifyResult
name|x
init|=
name|apply
argument_list|(
name|rule
argument_list|,
name|queryParent
argument_list|,
name|find
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
return|return
name|x
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
parameter_list|<
name|Q
extends|extends
name|RelNode
parameter_list|,
name|T
extends|extends
name|RelNode
parameter_list|>
name|UnifyResult
name|apply
parameter_list|(
name|UnifyRule
argument_list|<
name|Q
argument_list|,
name|T
argument_list|>
name|rule
parameter_list|,
name|Q
name|query
parameter_list|,
name|T
name|find
parameter_list|)
block|{
specifier|final
name|Class
argument_list|<
name|Q
argument_list|>
name|queryClass
init|=
name|rule
operator|.
name|getQueryClass
argument_list|()
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|targetClass
init|=
name|rule
operator|.
name|getTargetClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryClass
operator|.
name|isInstance
argument_list|(
name|query
argument_list|)
operator|&&
name|targetClass
operator|.
name|isInstance
argument_list|(
name|find
argument_list|)
condition|)
block|{
return|return
name|rule
operator|.
name|apply
argument_list|(
operator|new
name|UnifyIn
argument_list|<
name|Q
argument_list|,
name|T
argument_list|>
argument_list|(
name|queryClass
operator|.
name|cast
argument_list|(
name|query
argument_list|)
argument_list|,
name|targetClass
operator|.
name|cast
argument_list|(
name|find
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|// First, burrow to the bottom of the replacement.
specifier|private
name|DownResult
name|match
parameter_list|(
name|RelNode
name|find
parameter_list|)
block|{
switch|switch
condition|(
name|Match
operator|.
name|of
argument_list|(
name|find
argument_list|)
condition|)
block|{
case|case
name|FILTER
case|:
return|return
name|matchFilter
argument_list|(
operator|(
operator|(
name|FilterRel
operator|)
name|find
operator|)
argument_list|)
return|;
case|case
name|PROJECT
case|:
return|return
name|matchProject
argument_list|(
operator|(
operator|(
name|ProjectRel
operator|)
name|find
operator|)
argument_list|)
return|;
case|case
name|SCAN
case|:
return|return
name|matchScan
argument_list|(
operator|(
name|TableAccessRelBase
operator|)
name|find
argument_list|)
return|;
case|case
name|UNION
case|:
return|return
name|matchUnion
argument_list|(
operator|(
name|UnionRel
operator|)
name|find
argument_list|)
return|;
case|case
name|JOIN
case|:
return|return
name|matchJoin
argument_list|(
operator|(
name|JoinRel
operator|)
name|find
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|find
argument_list|)
throw|;
block|}
block|}
name|DownResult
name|matchScan
parameter_list|(
name|TableAccessRelBase
name|find
parameter_list|)
block|{
comment|// We've reached a leaf of the "find" tree. Find the corresponding
comment|// leaf of the "query" tree.
specifier|final
name|RelNode
name|query
init|=
name|leafMap
operator|.
name|get
argument_list|(
name|find
argument_list|)
decl_stmt|;
assert|assert
name|query
operator|instanceof
name|TableAccessRelBase
assert|;
return|return
name|DownResult
operator|.
name|of
argument_list|(
name|query
argument_list|)
return|;
block|}
name|DownResult
name|matchProject
parameter_list|(
name|ProjectRel
name|find
parameter_list|)
block|{
name|DownResult
name|in
init|=
name|match
argument_list|(
name|find
operator|.
name|getChild
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|Match
operator|.
name|of
argument_list|(
name|in
operator|.
name|rel
argument_list|)
condition|)
block|{
case|case
name|PROJECT
case|:
comment|// Decompose the project. For example, if
comment|//   query = Project(2, 7 from T)
comment|//   find = Project(2, 3, 7 from T)
comment|// then
comment|//   in.
comment|//   out.result = Project(0, 1, 2 from MV)
comment|//   out.residue = lambda R => Project(0, 2 from R)
block|}
comment|// TODO:
return|return
name|DownResult
operator|.
name|of
argument_list|(
literal|null
argument_list|)
return|;
block|}
name|DownResult
name|matchFilter
parameter_list|(
name|FilterRel
name|find
parameter_list|)
block|{
return|return
name|match
argument_list|(
name|find
operator|.
name|getChild
argument_list|()
argument_list|)
return|;
block|}
name|DownResult
name|matchUnion
parameter_list|(
name|UnionRel
name|find
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
comment|// TODO:
block|}
name|DownResult
name|matchJoin
parameter_list|(
name|JoinRel
name|find
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|private
interface|interface
name|Handler
parameter_list|<
name|R
parameter_list|>
block|{
name|R
name|apply
parameter_list|(
name|TableAccessRelBase
name|rel
parameter_list|)
function_decl|;
name|R
name|apply
parameter_list|(
name|ProjectRel
name|rel
parameter_list|)
function_decl|;
name|R
name|apply
parameter_list|(
name|FilterRel
name|rel
parameter_list|)
function_decl|;
name|R
name|apply
parameter_list|(
name|UnionRel
name|rel
parameter_list|)
function_decl|;
name|R
name|apply
parameter_list|(
name|JoinRel
name|rel
parameter_list|)
function_decl|;
block|}
specifier|private
enum|enum
name|Match
block|{
name|SCAN
block|{
specifier|public
parameter_list|<
name|R
parameter_list|>
name|Dispatcher
argument_list|<
name|R
argument_list|>
name|dispatcher
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
specifier|final
name|Handler
argument_list|<
name|R
argument_list|>
name|handler
parameter_list|)
block|{
return|return
operator|new
name|Dispatcher
argument_list|<
name|R
argument_list|>
argument_list|()
block|{
specifier|public
name|R
name|apply
parameter_list|()
block|{
return|return
name|handler
operator|.
name|apply
argument_list|(
operator|(
name|TableAccessRelBase
operator|)
name|rel
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
block|,
name|PROJECT
block|{
specifier|public
parameter_list|<
name|R
parameter_list|>
name|Dispatcher
argument_list|<
name|R
argument_list|>
name|dispatcher
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
specifier|final
name|Handler
argument_list|<
name|R
argument_list|>
name|handler
parameter_list|)
block|{
return|return
operator|new
name|Dispatcher
argument_list|<
name|R
argument_list|>
argument_list|()
block|{
specifier|public
name|R
name|apply
parameter_list|()
block|{
return|return
name|handler
operator|.
name|apply
argument_list|(
operator|(
name|ProjectRel
operator|)
name|rel
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
block|,
name|FILTER
block|{
specifier|public
parameter_list|<
name|R
parameter_list|>
name|Dispatcher
argument_list|<
name|R
argument_list|>
name|dispatcher
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
specifier|final
name|Handler
argument_list|<
name|R
argument_list|>
name|handler
parameter_list|)
block|{
return|return
operator|new
name|Dispatcher
argument_list|<
name|R
argument_list|>
argument_list|()
block|{
specifier|public
name|R
name|apply
parameter_list|()
block|{
return|return
name|handler
operator|.
name|apply
argument_list|(
operator|(
name|FilterRel
operator|)
name|rel
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
block|,
name|UNION
block|{
specifier|public
parameter_list|<
name|R
parameter_list|>
name|Dispatcher
argument_list|<
name|R
argument_list|>
name|dispatcher
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
specifier|final
name|Handler
argument_list|<
name|R
argument_list|>
name|handler
parameter_list|)
block|{
return|return
operator|new
name|Dispatcher
argument_list|<
name|R
argument_list|>
argument_list|()
block|{
specifier|public
name|R
name|apply
parameter_list|()
block|{
return|return
name|handler
operator|.
name|apply
argument_list|(
operator|(
name|UnionRel
operator|)
name|rel
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
block|,
name|JOIN
block|{
specifier|public
parameter_list|<
name|R
parameter_list|>
name|Dispatcher
argument_list|<
name|R
argument_list|>
name|dispatcher
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
specifier|final
name|Handler
argument_list|<
name|R
argument_list|>
name|handler
parameter_list|)
block|{
return|return
operator|new
name|Dispatcher
argument_list|<
name|R
argument_list|>
argument_list|()
block|{
specifier|public
name|R
name|apply
parameter_list|()
block|{
return|return
name|handler
operator|.
name|apply
argument_list|(
operator|(
name|JoinRel
operator|)
name|rel
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
block|;
specifier|static
name|Match
name|of
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|TableAccessRelBase
condition|)
block|{
return|return
name|SCAN
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|ProjectRel
condition|)
block|{
return|return
name|PROJECT
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|FilterRel
condition|)
block|{
return|return
name|FILTER
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|JoinRel
condition|)
block|{
return|return
name|JOIN
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|UnionRel
condition|)
block|{
return|return
name|UNION
return|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected "
operator|+
name|rel
argument_list|)
throw|;
block|}
specifier|public
specifier|abstract
argument_list|<
name|R
argument_list|>
name|Dispatcher
argument_list|<
name|R
argument_list|>
name|dispatcher
argument_list|(
name|RelNode
name|rel
argument_list|,
name|Handler
argument_list|<
name|R
argument_list|>
name|handler
argument_list|)
decl_stmt|;
block|}
specifier|private
specifier|static
specifier|abstract
class|class
name|Dispatcher
parameter_list|<
name|R
parameter_list|>
block|{
specifier|public
specifier|static
parameter_list|<
name|R
parameter_list|>
name|Dispatcher
argument_list|<
name|R
argument_list|>
name|of
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Handler
argument_list|<
name|R
argument_list|>
name|handler
parameter_list|)
block|{
return|return
name|Match
operator|.
name|of
argument_list|(
name|rel
argument_list|)
operator|.
name|dispatcher
argument_list|(
name|rel
argument_list|,
name|handler
argument_list|)
return|;
block|}
specifier|public
specifier|abstract
name|R
name|apply
parameter_list|()
function_decl|;
block|}
specifier|private
specifier|static
class|class
name|DownResult
block|{
specifier|public
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|private
name|DownResult
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
block|}
specifier|static
name|DownResult
name|of
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|new
name|DownResult
argument_list|(
name|rel
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|MatchFailed
extends|extends
name|RuntimeException
block|{
specifier|public
specifier|static
specifier|final
name|MatchFailed
name|INSTANCE
init|=
operator|new
name|MatchFailed
argument_list|()
decl_stmt|;
block|}
specifier|private
specifier|static
class|class
name|FoundRel
extends|extends
name|RuntimeException
block|{
specifier|public
specifier|static
specifier|final
name|FoundRel
name|INSTANCE
init|=
operator|new
name|FoundRel
argument_list|()
decl_stmt|;
block|}
specifier|private
interface|interface
name|UnifyRule
parameter_list|<
name|Q
extends|extends
name|RelNode
parameter_list|,
name|T
extends|extends
name|RelNode
parameter_list|>
block|{
name|Class
argument_list|<
name|Q
argument_list|>
name|getQueryClass
parameter_list|()
function_decl|;
name|Class
argument_list|<
name|T
argument_list|>
name|getTargetClass
parameter_list|()
function_decl|;
comment|/**<p>Applies this rule to a particular node in a query. The goal is          * to convert {@code query} into {@code target}. Before the rule is          * invoked, Optiq has made sure that query's children are equivalent          * to target's children.          *          *<p>There are 3 possible outcomes:</p>          *          *<ul>          *          *<li>{@code query} already exactly matches {@code target}; returns          * {@code target}</li>          *          *<li>{@code query} is sufficiently close to a match for          * {@code target}; returns {@code target}</li>          *          *<li>{@code query} cannot be made to match {@code target}; returns          * null</li>          *          *</ul>          *          *<p>REVIEW: Is possible that we match query PLUS one or more of its          * ancestors?</p>          *          * @param in Input parameters          */
name|UnifyResult
name|apply
parameter_list|(
name|UnifyIn
argument_list|<
name|Q
argument_list|,
name|T
argument_list|>
name|in
parameter_list|)
function_decl|;
block|}
comment|/** Arguments to an application of a {@link UnifyRule}. */
specifier|private
class|class
name|UnifyIn
parameter_list|<
name|Q
extends|extends
name|RelNode
parameter_list|,
name|T
extends|extends
name|RelNode
parameter_list|>
block|{
specifier|final
name|Q
name|query
decl_stmt|;
specifier|final
name|T
name|target
decl_stmt|;
specifier|public
name|UnifyIn
parameter_list|(
name|Q
name|query
parameter_list|,
name|T
name|target
parameter_list|)
block|{
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
specifier|public
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Integer
argument_list|>
name|parent
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
return|return
name|parentMap
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
name|UnifyResult
name|result
parameter_list|(
name|RelNode
name|result
parameter_list|)
block|{
assert|assert
name|contains
argument_list|(
name|result
argument_list|,
name|target
argument_list|)
assert|;
assert|assert
name|equalType
argument_list|(
literal|"result"
argument_list|,
name|result
argument_list|,
literal|"query"
argument_list|,
name|query
argument_list|)
assert|;
name|RelNode
name|replace
init|=
name|replacementMap
operator|.
name|get
argument_list|(
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|replace
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|replace
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|replace
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|UnifyResult
argument_list|(
name|query
argument_list|,
name|target
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|equalType
parameter_list|(
name|String
name|desc0
parameter_list|,
name|RelNode
name|rel0
parameter_list|,
name|String
name|desc1
parameter_list|,
name|RelNode
name|rel1
parameter_list|)
block|{
return|return
name|RelOptUtil
operator|.
name|equal
argument_list|(
name|desc0
argument_list|,
name|rel0
operator|.
name|getRowType
argument_list|()
argument_list|,
name|desc1
argument_list|,
name|rel1
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Result of an application of a {@link UnifyRule} indicating that the      * rule successfully matched {@code query} against {@code target} and      * generated a {@code result} that is equivalent to {@code query} and      * contains {@code target}. */
specifier|private
specifier|static
class|class
name|UnifyResult
block|{
specifier|private
specifier|final
name|RelNode
name|query
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|target
decl_stmt|;
comment|// equivalent to "query", contains "result"
specifier|private
specifier|final
name|RelNode
name|result
decl_stmt|;
name|UnifyResult
parameter_list|(
name|RelNode
name|query
parameter_list|,
name|RelNode
name|target
parameter_list|,
name|RelNode
name|result
parameter_list|)
block|{
name|this
operator|.
name|query
operator|=
name|query
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|abstract
class|class
name|AbstractUnifyRule
parameter_list|<
name|Q
extends|extends
name|RelNode
parameter_list|,
name|T
extends|extends
name|RelNode
parameter_list|>
implements|implements
name|UnifyRule
argument_list|<
name|Q
argument_list|,
name|T
argument_list|>
block|{
specifier|private
specifier|final
name|Class
argument_list|<
name|Q
argument_list|>
name|queryClass
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|targetClass
decl_stmt|;
specifier|public
name|AbstractUnifyRule
parameter_list|(
name|Class
argument_list|<
name|Q
argument_list|>
name|queryClass
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|targetClass
parameter_list|)
block|{
name|this
operator|.
name|queryClass
operator|=
name|queryClass
expr_stmt|;
name|this
operator|.
name|targetClass
operator|=
name|targetClass
expr_stmt|;
block|}
specifier|public
name|Class
argument_list|<
name|Q
argument_list|>
name|getQueryClass
parameter_list|()
block|{
return|return
name|queryClass
return|;
block|}
specifier|public
name|Class
argument_list|<
name|T
argument_list|>
name|getTargetClass
parameter_list|()
block|{
return|return
name|targetClass
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|ScanUnifyRule
extends|extends
name|AbstractUnifyRule
argument_list|<
name|TableAccessRelBase
argument_list|,
name|TableAccessRelBase
argument_list|>
block|{
specifier|public
name|ScanUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|TableAccessRelBase
operator|.
name|class
argument_list|,
name|TableAccessRelBase
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyIn
argument_list|<
name|TableAccessRelBase
argument_list|,
name|TableAccessRelBase
argument_list|>
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|.
name|query
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|in
operator|.
name|target
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|in
operator|.
name|result
argument_list|(
name|in
operator|.
name|target
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|ProjectUnifyRule
extends|extends
name|AbstractUnifyRule
argument_list|<
name|ProjectRel
argument_list|,
name|ProjectRel
argument_list|>
block|{
specifier|public
name|ProjectUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|ProjectRel
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyIn
argument_list|<
name|ProjectRel
argument_list|,
name|ProjectRel
argument_list|>
name|in
parameter_list|)
block|{
specifier|final
name|RexShuttle
name|shuttle
init|=
name|getRexShuttle
argument_list|(
name|in
operator|.
name|target
argument_list|)
decl_stmt|;
specifier|final
name|ProjectRel
name|newProject
init|=
operator|new
name|ProjectRel
argument_list|(
name|in
operator|.
name|target
operator|.
name|getCluster
argument_list|()
argument_list|,
name|in
operator|.
name|target
argument_list|,
name|shuttle
operator|.
name|apply
argument_list|(
name|in
operator|.
name|query
operator|.
name|getProjects
argument_list|()
argument_list|)
argument_list|,
name|in
operator|.
name|query
operator|.
name|getRowType
argument_list|()
argument_list|,
name|in
operator|.
name|query
operator|.
name|getFlags
argument_list|()
argument_list|,
name|in
operator|.
name|query
operator|.
name|getCollationList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newProject2
init|=
name|RemoveTrivialProjectRule
operator|.
name|strip
argument_list|(
name|newProject
argument_list|)
decl_stmt|;
return|return
name|in
operator|.
name|result
argument_list|(
name|newProject2
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|FilterToProjectUnifyRule
extends|extends
name|AbstractUnifyRule
argument_list|<
name|FilterRel
argument_list|,
name|ProjectRel
argument_list|>
block|{
specifier|public
name|FilterToProjectUnifyRule
parameter_list|()
block|{
name|super
argument_list|(
name|FilterRel
operator|.
name|class
argument_list|,
name|ProjectRel
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|UnifyResult
name|apply
parameter_list|(
name|UnifyIn
argument_list|<
name|FilterRel
argument_list|,
name|ProjectRel
argument_list|>
name|in
parameter_list|)
block|{
comment|// Child of projectTarget is equivalent to child of filterQuery.
try|try
block|{
comment|// TODO: shuttle that recognizes more complex
comment|// expressions e,g
comment|//   materialized view as select x + y from t
comment|//
comment|// TODO: make sure that constants are ok
specifier|final
name|RexShuttle
name|shuttle
init|=
name|getRexShuttle
argument_list|(
name|in
operator|.
name|target
argument_list|)
decl_stmt|;
specifier|final
name|FilterRel
name|newFilter
init|=
operator|new
name|FilterRel
argument_list|(
name|in
operator|.
name|query
operator|.
name|getCluster
argument_list|()
argument_list|,
name|in
operator|.
name|target
argument_list|,
name|in
operator|.
name|query
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|in
operator|.
name|result
argument_list|(
name|newFilter
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MatchFailed
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
specifier|private
specifier|static
name|RexShuttle
name|getRexShuttle
parameter_list|(
name|ProjectRel
name|target
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|target
operator|.
name|getProjects
argument_list|()
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|ref
parameter_list|)
block|{
specifier|final
name|Integer
name|integer
init|=
name|map
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|integer
argument_list|,
name|ref
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
throw|throw
name|MatchFailed
operator|.
name|INSTANCE
throw|;
block|}
block|}
return|;
block|}
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|UnifyRule
argument_list|>
name|RULES
init|=
name|Arrays
operator|.
expr|<
name|UnifyRule
operator|>
name|asList
argument_list|(
operator|new
name|ScanUnifyRule
argument_list|()
argument_list|,
operator|new
name|ProjectUnifyRule
argument_list|()
argument_list|,
operator|new
name|FilterToProjectUnifyRule
argument_list|()
argument_list|)
decl_stmt|;
block|}
end_class

begin_comment
comment|// End SubstitutionVisitor.java
end_comment

end_unit

