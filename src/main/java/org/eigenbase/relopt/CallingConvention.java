begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|relopt
package|;
end_package

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|rules
operator|.
name|java
operator|.
name|EnumerableRel
import|;
end_import

begin_comment
comment|/**  *<code>CallingConvention</code> enumerates the calling conventions built in to  * the Saffron project. This set can be extended by applications by defining new  * instances of CallingConvention and registering them with a planner, along  * with the desired conversion rules. Extended ordinals must be greater than  * CallingConvention.enumeration.getMax().  */
end_comment

begin_class
specifier|public
class|class
name|CallingConvention
implements|implements
name|RelTrait
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
name|int
name|maxOrdinal
decl_stmt|;
comment|/**      * The<code>NONE</code> calling convention means that expression does not      * support any calling convention -- in other words, it is not      * implementable, and has to be transformed to something else in order to be      * implemented.      */
specifier|public
specifier|static
specifier|final
name|int
name|NONE_ORDINAL
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|NONE
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"NONE"
argument_list|,
name|NONE_ORDINAL
argument_list|,
name|RelNode
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>JAVA</code> calling convention means that the expression is      * converted into an Openjava parse tree, which can then be un-parsed,      * compiled, and executed as java code.      *      *<p>The {@link org.eigenbase.oj.rel.JavaRel#implement} method generates a      * piece of code which will call the piece of code corresponding to the      * parent once for each row:      *      *<ul>      *<li>The<dfn>parent code</dfn> is generated by calling {@link      * JavaRelImplementor#generateParentBody}, which in turn calls {@link      * org.eigenbase.oj.rel.JavaLoopRel#implementJavaParent} on the parent.</li>      *<li>The code is generated into the<dfn>current block</dfn> (gleaned from      * {@link org.eigenbase.oj.rel.JavaRelImplementor#getStatementList}).</li>      *</ul>      *</p>      */
specifier|public
specifier|static
specifier|final
name|int
name|JAVA_ORDINAL
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|JAVA
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"JAVA"
argument_list|,
name|JAVA_ORDINAL
argument_list|,
name|JavaLoopRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>ITERATOR</code> calling convention means that the expression is      * converted to an openjava expression ({@link openjava.ptree.Expression})      * which evalutes to an {@link org.eigenbase.runtime.TupleIter}. See {@link      * org.eigenbase.rel.convert.ConverterRel}.      */
specifier|public
specifier|static
specifier|final
name|int
name|ITERATOR_ORDINAL
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ITERATOR
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ITERATOR"
argument_list|,
name|ITERATOR_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>ARRAY</code> calling convention results in a Java expression      * which evaluates to an array containing the rows returned. Compare with      * {@link #JAVA_ORDINAL}, where a loop<em>does something</em> for each row      * returned).      */
specifier|public
specifier|static
specifier|final
name|int
name|ARRAY_ORDINAL
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ARRAY
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ARRAY"
argument_list|,
name|ARRAY_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>COLLECTION</code> calling convention results in a Java      * expression which evaluates to a {@link java.util.Collection}, typically a      * {@link java.util.ArrayList}.      */
specifier|public
specifier|static
specifier|final
name|int
name|COLLECTION_ORDINAL
init|=
literal|3
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|COLLECTION
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"COLLECTION"
argument_list|,
name|COLLECTION_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|VECTOR_ORDINAL
init|=
literal|4
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|VECTOR
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"VECTOR"
argument_list|,
name|VECTOR_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|ENUMERATION_ORDINAL
init|=
literal|5
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ENUMERATION
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ENUMERATION"
argument_list|,
name|ENUMERATION_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MAP_ORDINAL
init|=
literal|6
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|MAP
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"MAP"
argument_list|,
name|MAP_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|HASHTABLE_ORDINAL
init|=
literal|7
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|HASHTABLE
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"HASHTABLE"
argument_list|,
name|HASHTABLE_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>ITERABLE</code> calling convention means that the expression is      * converted to an openjava expression ({@link openjava.ptree.Expression})      * which evalutes to an object which implements {@link      * org.eigenbase.runtime.Iterable}.      */
specifier|public
specifier|static
specifier|final
name|int
name|ITERABLE_ORDINAL
init|=
literal|8
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ITERABLE
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ITERABLE"
argument_list|,
name|ITERABLE_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>EXISTS</code> calling convention is only allowed for a      * terminator.      */
specifier|public
specifier|static
specifier|final
name|int
name|EXISTS_ORDINAL
init|=
literal|9
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|EXISTS
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"EXISTS"
argument_list|,
name|EXISTS_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>RESULT_SET</code> calling convention means that the expression      * is a {@link java.sql.ResultSet JDBC result set} or {@link      * org.eigenbase.runtime.ResultSetProvider}. When a result set is      * converted to another convention such as array or iterator, the default      * object type is {@link org.eigenbase.runtime.Row}.      */
specifier|public
specifier|static
specifier|final
name|int
name|RESULT_SET_ORDINAL
init|=
literal|10
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|RESULT_SET
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"RESULT_SET"
argument_list|,
name|RESULT_SET_ORDINAL
argument_list|,
name|ResultSetRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>ENUMERABLE</code> calling convention means that the expression      * is a {@link net.hydromatic.linq4j.Enumerable}.      */
specifier|public
specifier|static
specifier|final
name|int
name|ENUMERABLE_ORDINAL
init|=
literal|11
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ENUMERABLE
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ENUMERABLE"
argument_list|,
name|ENUMERABLE_ORDINAL
argument_list|,
name|EnumerableRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
index|[]
name|values
init|=
operator|new
name|CallingConvention
index|[]
block|{
name|NONE
block|,
name|JAVA
block|,
name|ITERATOR
block|,
name|ARRAY
block|,
name|COLLECTION
block|,
name|VECTOR
block|,
name|ENUMERATION
block|,
name|MAP
block|,
name|HASHTABLE
block|,
name|ITERABLE
block|,
name|EXISTS
block|,
name|RESULT_SET
block|,
name|ENUMERABLE
block|,         }
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/**      * Enumerated value's name.      */
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
comment|/**      * Enumerated value's ordinal.      */
specifier|private
specifier|final
name|int
name|ordinal
decl_stmt|;
comment|/**      * Interface that a relational expression of this calling convention must      * implement. Must be a sub-interface of {@link RelNode}.      */
specifier|private
specifier|final
name|Class
name|interfaze
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|CallingConvention
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|Class
name|interfaze
parameter_list|)
block|{
name|Util
operator|.
name|pre
argument_list|(
name|name
operator|!=
literal|null
argument_list|,
literal|"name != null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|interfaze
operator|=
name|interfaze
expr_stmt|;
name|Util
operator|.
name|pre
argument_list|(
name|RelNode
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|interfaze
argument_list|)
argument_list|,
literal|"RelNode.class.isAssignableFrom(interfaze)"
argument_list|)
expr_stmt|;
name|maxOrdinal
operator|=
name|Math
operator|.
name|max
argument_list|(
name|ordinal
argument_list|,
name|maxOrdinal
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|Class
name|getInterface
parameter_list|()
block|{
return|return
name|interfaze
return|;
block|}
specifier|public
specifier|static
name|int
name|generateOrdinal
parameter_list|()
block|{
return|return
name|maxOrdinal
operator|+
literal|1
return|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
specifier|public
name|int
name|getOrdinal
parameter_list|()
block|{
return|return
name|ordinal
return|;
block|}
comment|// Implement RelTrait
specifier|public
name|RelTraitDef
name|getTraitDef
parameter_list|()
block|{
return|return
name|CallingConventionTraitDef
operator|.
name|instance
return|;
block|}
comment|/**      * Returns the ordinal as the CallingConvention's hash code.      *      * @return ordinal      */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|ordinal
return|;
block|}
comment|/**      * Compares this CallingConvention to another for equality by ordinal.      *      * @param o the other CallingConvention      *      * @return true if they are equal, false otherwise      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|ordinal
operator|==
operator|(
operator|(
name|CallingConvention
operator|)
name|o
operator|)
operator|.
name|ordinal
return|;
block|}
comment|/**      * Returns the value's name.      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
end_class

begin_comment
comment|// End CallingConvention.java
end_comment

end_unit

