begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|relopt
package|;
end_package

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Obsolete set of {@link Convention}s. The code that uses these conventions  * will be removed from Optiq shortly.  */
end_comment

begin_class
specifier|public
class|class
name|CallingConvention
implements|implements
name|Convention
block|{
comment|//~ Static fields/initializers ---------------------------------------------
comment|/**      * The<code>JAVA</code> calling convention means that the expression is      * converted into an Openjava parse tree, which can then be un-parsed,      * compiled, and executed as java code.      *      *<p>The {@link org.eigenbase.oj.rel.JavaRel#implement} method generates a      * piece of code which will call the piece of code corresponding to the      * parent once for each row:      *      *<ul>      *<li>The<dfn>parent code</dfn> is generated by calling {@code      * JavaRelImplementor#generateParentBody}, which in turn calls {@link      * org.eigenbase.oj.rel.JavaLoopRel#implementJavaParent} on the parent.</li>      *<li>The code is generated into the<dfn>current block</dfn> (gleaned from      * {@code org.eigenbase.oj.rel.JavaRelImplementor#getStatementList}).</li>      *</ul>      *</p>      */
specifier|private
specifier|static
specifier|final
name|int
name|JAVA_ORDINAL
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|JAVA
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"JAVA"
argument_list|,
name|JAVA_ORDINAL
argument_list|,
name|JavaLoopRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>ITERATOR</code> calling convention means that the expression is      * converted to an OpenJava expression      * which evaluates to an {@link org.eigenbase.runtime.TupleIter}. See {@link      * org.eigenbase.rel.convert.ConverterRel}.      */
specifier|private
specifier|static
specifier|final
name|int
name|ITERATOR_ORDINAL
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ITERATOR
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ITERATOR"
argument_list|,
name|ITERATOR_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>ARRAY</code> calling convention results in a Java expression      * which evaluates to an array containing the rows returned. Compare with      * {@link #JAVA_ORDINAL}, where a loop<em>does something</em> for each row      * returned).      */
specifier|private
specifier|static
specifier|final
name|int
name|ARRAY_ORDINAL
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ARRAY
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ARRAY"
argument_list|,
name|ARRAY_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>COLLECTION</code> calling convention results in a Java      * expression which evaluates to a {@link java.util.Collection}, typically a      * {@link java.util.ArrayList}.      */
specifier|private
specifier|static
specifier|final
name|int
name|COLLECTION_ORDINAL
init|=
literal|3
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|COLLECTION
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"COLLECTION"
argument_list|,
name|COLLECTION_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|VECTOR_ORDINAL
init|=
literal|4
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|VECTOR
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"VECTOR"
argument_list|,
name|VECTOR_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ENUMERATION_ORDINAL
init|=
literal|5
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ENUMERATION
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ENUMERATION"
argument_list|,
name|ENUMERATION_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAP_ORDINAL
init|=
literal|6
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|MAP
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"MAP"
argument_list|,
name|MAP_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|HASHTABLE_ORDINAL
init|=
literal|7
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|HASHTABLE
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"HASHTABLE"
argument_list|,
name|HASHTABLE_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>ITERABLE</code> calling convention means that the expression is      * converted to an OpenJava expression      * which evaluates to an object which implements {@link Iterable}.      */
specifier|private
specifier|static
specifier|final
name|int
name|ITERABLE_ORDINAL
init|=
literal|8
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|ITERABLE
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"ITERABLE"
argument_list|,
name|ITERABLE_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>EXISTS</code> calling convention is only allowed for a      * terminator.      */
specifier|private
specifier|static
specifier|final
name|int
name|EXISTS_ORDINAL
init|=
literal|9
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|EXISTS
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"EXISTS"
argument_list|,
name|EXISTS_ORDINAL
argument_list|,
name|JavaRel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The<code>RESULT_SET</code> calling convention means that the expression      * is a {@link java.sql.ResultSet JDBC result set} or {@link      * org.eigenbase.runtime.ResultSetProvider}. When a result set is      * converted to another convention such as array or iterator, the default      * object type is {@link org.eigenbase.runtime.Row}.      */
specifier|private
specifier|static
specifier|final
name|int
name|RESULT_SET_ORDINAL
init|=
literal|10
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
name|RESULT_SET
init|=
operator|new
name|CallingConvention
argument_list|(
literal|"RESULT_SET"
argument_list|,
name|RESULT_SET_ORDINAL
argument_list|,
name|ResultSetRel
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|CallingConvention
index|[]
name|values
init|=
operator|new
name|CallingConvention
index|[]
block|{
name|JAVA
block|,
name|ITERATOR
block|,
name|ARRAY
block|,
name|COLLECTION
block|,
name|VECTOR
block|,
name|ENUMERATION
block|,
name|MAP
block|,
name|HASHTABLE
block|,
name|ITERABLE
block|,
name|EXISTS
block|,
name|RESULT_SET
block|,         }
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/**      * Enumerated value's name.      */
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
comment|/**      * Enumerated value's ordinal.      */
specifier|private
specifier|final
name|int
name|ordinal
decl_stmt|;
comment|/**      * Interface that a relational expression of this calling convention must      * implement. Must be a sub-interface of {@link RelNode}.      */
specifier|private
specifier|final
name|Class
name|interface_
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|private
name|CallingConvention
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|Class
name|interface_
parameter_list|)
block|{
assert|assert
name|name
operator|!=
literal|null
assert|;
assert|assert
name|RelNode
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|interface_
argument_list|)
assert|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|interface_
operator|=
name|interface_
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|Class
name|getInterface
parameter_list|()
block|{
return|return
name|interface_
return|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|// Implement RelTrait
specifier|public
name|RelTraitDef
name|getTraitDef
parameter_list|()
block|{
return|return
name|ConventionTraitDef
operator|.
name|instance
return|;
block|}
comment|/**      * Returns the ordinal as the CallingConvention's hash code.      *      * @return ordinal      */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|ordinal
return|;
block|}
comment|/**      * Compares this CallingConvention to another for equality by ordinal.      *      * @param o the other CallingConvention      *      * @return true if they are equal, false otherwise      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|this
operator|==
name|o
operator|||
name|o
operator|instanceof
name|CallingConvention
operator|&&
name|ordinal
operator|==
operator|(
operator|(
name|CallingConvention
operator|)
name|o
operator|)
operator|.
name|ordinal
return|;
block|}
comment|/**      * Returns the value's name.      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
end_class

begin_comment
comment|// End CallingConvention.java
end_comment

end_unit

