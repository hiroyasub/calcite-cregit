begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|relopt
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|openjava
operator|.
name|ptree
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|openjava
operator|.
name|ptree
operator|.
name|FieldAccess
import|;
end_import

begin_import
import|import
name|openjava
operator|.
name|ptree
operator|.
name|Variable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|oj
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  *<code>RelOptUtil</code> defines static utility methods for use in optimizing  * {@link RelNode}s.  *  * @author jhyde  * @since 26 September, 2003  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|RelOptUtil
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|Variable
name|var0
init|=
operator|new
name|Variable
argument_list|(
name|makeName
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Variable
name|var1
init|=
operator|new
name|Variable
argument_list|(
name|makeName
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|NL
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|double
name|EPSILON
init|=
literal|1.0e-5
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**      * Returns the ordinal of the input represented by the variable<code>      * name</code>, or -1 if it does not represent an input.      */
specifier|public
specifier|static
name|int
name|getInputOrdinal
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"$input"
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"$input0"
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|else if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"$input1"
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"unknown input variable: "
operator|+
name|name
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**      * Returns a list of variables set by a relational expression or its      * descendants.      */
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getVariablesSet
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|VariableSetVisitor
name|visitor
init|=
operator|new
name|VariableSetVisitor
argument_list|()
decl_stmt|;
name|go
argument_list|(
name|visitor
argument_list|,
name|rel
argument_list|)
expr_stmt|;
return|return
name|visitor
operator|.
name|variables
return|;
block|}
comment|/**      * Returns a set of distinct variables set by<code>rel0</code> and used by      *<code>rel1</code>.      */
specifier|public
specifier|static
name|String
index|[]
name|getVariablesSetAndUsed
parameter_list|(
name|RelNode
name|rel0
parameter_list|,
name|RelNode
name|rel1
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
name|getVariablesSet
argument_list|(
name|rel0
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|Util
operator|.
name|emptyStringArray
return|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|used
init|=
name|getVariablesUsed
argument_list|(
name|rel1
argument_list|)
decl_stmt|;
if|if
condition|(
name|used
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|Util
operator|.
name|emptyStringArray
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|set
control|)
block|{
if|if
condition|(
name|used
operator|.
name|contains
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|result
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|Util
operator|.
name|emptyStringArray
return|;
block|}
return|return
name|result
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|result
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Returns a set of variables used by a relational expression or its      * descendants. The set may contain duplicates. The item type is the same as      * {@link org.eigenbase.rex.RexVariable#getName}      */
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|getVariablesUsed
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|VariableUsedVisitor
name|vuv
init|=
operator|new
name|VariableUsedVisitor
argument_list|()
decl_stmt|;
specifier|final
name|VisitorRelVisitor
name|visitor
init|=
operator|new
name|VisitorRelVisitor
argument_list|(
name|vuv
argument_list|)
block|{
comment|// implement RelVisitor
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|p
operator|.
name|collectVariablesUsed
argument_list|(
name|vuv
operator|.
name|variables
argument_list|)
expr_stmt|;
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|// Important! Remove stopped variables AFTER we visit
comment|// children. (which what super.visit() does)
name|vuv
operator|.
name|variables
operator|.
name|removeAll
argument_list|(
name|p
operator|.
name|getVariablesStopped
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|visitor
operator|.
name|go
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
name|vuv
operator|.
name|variables
return|;
block|}
comment|/**      * Sets a {@link RelVisitor} going on a given relational expression, and      * returns the result.      */
specifier|public
specifier|static
name|void
name|go
parameter_list|(
name|RelVisitor
name|visitor
parameter_list|,
name|RelNode
name|p
parameter_list|)
block|{
try|try
block|{
name|visitor
operator|.
name|go
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|e
argument_list|,
literal|"while visiting tree"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Constructs a reference to the<code>field</code><sup>th</sup> field of      * the<code>ordinal</code><sup>th</sup> input.      */
specifier|public
specifier|static
name|FieldAccess
name|makeFieldAccess
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|int
name|field
parameter_list|)
block|{
return|return
operator|new
name|FieldAccess
argument_list|(
operator|new
name|Variable
argument_list|(
name|makeName
argument_list|(
name|ordinal
argument_list|)
argument_list|)
argument_list|,
name|OJSyntheticClass
operator|.
name|makeField
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Constructs a reference to the<code>field</code><sup>th</sup> field of an      * expression.      */
specifier|public
specifier|static
name|FieldAccess
name|makeFieldAccess
parameter_list|(
name|Expression
name|expr
parameter_list|,
name|int
name|field
parameter_list|)
block|{
return|return
operator|new
name|FieldAccess
argument_list|(
name|expr
argument_list|,
name|OJSyntheticClass
operator|.
name|makeField
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Constructs the name for the<code>ordinal</code>th input. For example,      *<code>makeName(0)</code> returns "$input0".      */
specifier|public
specifier|static
name|String
name|makeName
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
comment|// avoid a memory allocation for the common cases
switch|switch
condition|(
name|ordinal
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"$input0"
return|;
case|case
literal|1
case|:
return|return
literal|"$input1"
return|;
default|default:
return|return
literal|"$input"
operator|+
name|ordinal
return|;
block|}
block|}
specifier|public
specifier|static
name|Variable
name|makeReference
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
comment|// save ourselves a memory allocation for the common cases
switch|switch
condition|(
name|ordinal
condition|)
block|{
case|case
literal|0
case|:
return|return
name|var0
return|;
case|case
literal|1
case|:
return|return
name|var1
return|;
default|default:
return|return
operator|new
name|Variable
argument_list|(
name|makeName
argument_list|(
name|ordinal
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|RelNode
index|[]
name|a
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|a
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns a list of the names of the fields in a given struct type. The      * list is immutable.      *      * @param type Struct type      *      * @return List of field names      *      * @see #getFieldTypeList(RelDataType)      * @see #getFieldNames(RelDataType)      */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getFieldNameList
parameter_list|(
specifier|final
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|String
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getName
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|type
operator|.
name|getFieldCount
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**      * Returns an array of the names of the fields in a given struct type.      *      * @param type Struct type      *      * @return Array of field names      *      * @see #getFieldNameList(RelDataType)      */
specifier|public
specifier|static
name|String
index|[]
name|getFieldNames
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|RelDataTypeField
index|[]
name|fields
init|=
name|type
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|String
index|[]
name|names
init|=
operator|new
name|String
index|[
name|fields
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|names
index|[
name|i
index|]
operator|=
name|fields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
return|return
name|names
return|;
block|}
comment|/**      * Returns a list of the types of the fields in a given struct type. The      * list is immutable.      *      * @param type Struct type      *      * @return List of field types      *      * @see #getFieldNameList(RelDataType)      * @see #getFieldTypes(RelDataType)      */
specifier|public
specifier|static
name|List
argument_list|<
name|RelDataType
argument_list|>
name|getFieldTypeList
parameter_list|(
specifier|final
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|type
operator|.
name|getFieldCount
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**      * Returns an array of the types of the fields in a given struct type.      *      * @param type Struct type      *      * @return Array of field types      *      * @see #getFieldTypeList(RelDataType)      */
specifier|public
specifier|static
name|RelDataType
index|[]
name|getFieldTypes
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
name|RelDataTypeField
index|[]
name|fields
init|=
name|type
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|RelDataType
index|[]
name|types
init|=
operator|new
name|RelDataType
index|[
name|fields
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|fields
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
return|return
name|types
return|;
block|}
comment|/**      * Collects the names and types of the fields in a given struct type.      */
specifier|public
specifier|static
name|void
name|collectFields
parameter_list|(
name|RelDataType
name|type
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNameList
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
parameter_list|)
block|{
specifier|final
name|RelDataTypeField
index|[]
name|fields
init|=
name|type
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|fields
index|[
name|i
index|]
decl_stmt|;
name|typeList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|fieldNameList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|RelDataType
name|createTypeFromProjection
parameter_list|(
specifier|final
name|RelDataType
name|type
parameter_list|,
specifier|final
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|columnNameList
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataTypeFactory
operator|.
name|FieldInfo
argument_list|()
block|{
specifier|public
name|int
name|getFieldCount
parameter_list|()
block|{
return|return
name|columnNameList
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|String
name|getFieldName
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|columnNameList
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|getFieldType
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|iField
init|=
name|type
operator|.
name|getFieldOrdinal
argument_list|(
name|getFieldName
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|type
operator|.
name|getFields
argument_list|()
index|[
name|iField
index|]
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|areRowTypesEqual
parameter_list|(
name|RelDataType
name|rowType1
parameter_list|,
name|RelDataType
name|rowType2
parameter_list|,
name|boolean
name|compareNames
parameter_list|)
block|{
if|if
condition|(
name|rowType1
operator|==
name|rowType2
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|compareNames
condition|)
block|{
comment|// if types are not identity-equal, then either the names or
comment|// the types must be different
return|return
literal|false
return|;
block|}
name|int
name|n
init|=
name|rowType1
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowType2
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RelDataTypeField
index|[]
name|f1
init|=
name|rowType1
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|f2
init|=
name|rowType2
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|f1
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|f2
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Verifies that a row type being added to an equivalence class matches the      * existing type, raising an assertion if this is not the case.      *      * @param originalRel canonical rel for equivalence class      * @param newRel rel being added to equivalence class      * @param equivalenceClass object representing equivalence class      */
specifier|public
specifier|static
name|void
name|verifyTypeEquivalence
parameter_list|(
name|RelNode
name|originalRel
parameter_list|,
name|RelNode
name|newRel
parameter_list|,
name|Object
name|equivalenceClass
parameter_list|)
block|{
name|RelDataType
name|expectedRowType
init|=
name|originalRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataType
name|actualRowType
init|=
name|newRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
comment|// Row types must be the same, except for field names.
if|if
condition|(
name|areRowTypesEqual
argument_list|(
name|expectedRowType
argument_list|,
name|actualRowType
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|s
init|=
literal|"Cannot add expression of different type to set: "
operator|+
name|Util
operator|.
name|lineSeparator
operator|+
literal|"set type is "
operator|+
name|expectedRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
name|Util
operator|.
name|lineSeparator
operator|+
literal|"expression type is "
operator|+
name|actualRowType
operator|.
name|getFullTypeString
argument_list|()
operator|+
name|Util
operator|.
name|lineSeparator
operator|+
literal|"set is "
operator|+
name|equivalenceClass
operator|.
name|toString
argument_list|()
operator|+
name|Util
operator|.
name|lineSeparator
operator|+
literal|"expression is "
operator|+
name|newRel
operator|.
name|toString
argument_list|()
decl_stmt|;
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|s
argument_list|)
throw|;
block|}
comment|/**      * Creates a plan suitable for use in<code>EXISTS</code> or<code>IN</code>      * statements. See {@link      * org.eigenbase.sql2rel.SqlToRelConverter#convertExists} Note: this      * implementation of createExistsPlan is only called from      * net.sf.farrago.fennel.rel. The last two arguments do not apply to      * those invocations and can be removed from the method.      *      *<p>      *      * @param cluster      * @param seekRel A query rel, for example the resulting rel from 'select *      * from emp' or 'values (1,2,3)' or '('Foo', 34)'.      * @param conditions May be null      * @param extraExpr Column expression to add. "TRUE" for EXISTS and IN      * @param extraName Name of expression to add.      *      * @return relational expression which outer joins a boolean condition      * column      *      * @pre extraExpr == null || extraName != null      */
specifier|public
specifier|static
name|RelNode
name|createExistsPlan
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|seekRel
parameter_list|,
name|RexNode
index|[]
name|conditions
parameter_list|,
name|RexLiteral
name|extraExpr
parameter_list|,
name|String
name|extraName
parameter_list|)
block|{
name|RelNode
name|ret
init|=
name|seekRel
decl_stmt|;
if|if
condition|(
operator|(
name|conditions
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|conditions
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
block|{
name|RexNode
name|conditionExp
init|=
name|RexUtil
operator|.
name|andRexNodeList
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|conditions
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|=
name|CalcRel
operator|.
name|createFilter
argument_list|(
name|ret
argument_list|,
name|conditionExp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extraExpr
operator|!=
literal|null
condition|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|extraExpr
operator|==
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
operator|)
assert|;
comment|// this should only be called for the exists case
comment|// first stick an Agg on top of the subquery
comment|// agg does not like no agg functions so just pretend it is
comment|// doing a min(TRUE)
name|RexNode
index|[]
name|exprs
init|=
operator|new
name|RexNode
index|[
literal|1
index|]
decl_stmt|;
name|exprs
index|[
literal|0
index|]
operator|=
name|extraExpr
expr_stmt|;
name|ret
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|ret
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|RelDataType
index|[]
name|argTypes
init|=
operator|new
name|RelDataType
index|[
literal|1
index|]
decl_stmt|;
name|argTypes
index|[
literal|0
index|]
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
name|SqlAggFunction
name|minFunction
init|=
operator|new
name|SqlMinMaxAggFunction
argument_list|(
name|argTypes
argument_list|,
literal|true
argument_list|,
name|SqlMinMaxAggFunction
operator|.
name|MINMAX_COMPARABLE
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|minFunction
operator|.
name|inferReturnType
argument_list|(
name|typeFactory
argument_list|,
name|argTypes
argument_list|)
decl_stmt|;
specifier|final
name|AggregateCall
name|aggCall
init|=
operator|new
name|AggregateCall
argument_list|(
name|minFunction
argument_list|,
literal|false
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
literal|0
argument_list|)
argument_list|,
name|returnType
argument_list|,
name|extraName
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|new
name|AggregateRel
argument_list|(
name|ret
operator|.
name|getCluster
argument_list|()
argument_list|,
name|ret
argument_list|,
name|Util
operator|.
name|bitSetOf
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|aggCall
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|public
specifier|static
name|RelNode
name|createExistsPlan
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|seekRel
parameter_list|,
name|boolean
name|isIn
parameter_list|,
name|boolean
name|isExists
parameter_list|,
name|boolean
name|needsOuterJoin
parameter_list|)
block|{
name|RelNode
name|ret
init|=
name|seekRel
decl_stmt|;
if|if
condition|(
name|isIn
operator|||
name|isExists
condition|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|RelDataType
name|inputFieldType
init|=
name|ret
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|outputFieldCount
decl_stmt|;
if|if
condition|(
name|isIn
condition|)
block|{
if|if
condition|(
name|needsOuterJoin
condition|)
block|{
name|outputFieldCount
operator|=
name|inputFieldType
operator|.
name|getFieldCount
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|outputFieldCount
operator|=
name|inputFieldType
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// EXISTS only projects TRUE in the subquery
name|outputFieldCount
operator|=
literal|1
expr_stmt|;
block|}
name|RexNode
index|[]
name|exprs
init|=
operator|new
name|RexNode
index|[
name|outputFieldCount
index|]
decl_stmt|;
comment|// for IN/NOT IN , it needs to output the fields
if|if
condition|(
name|isIn
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputFieldType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprs
index|[
name|i
index|]
operator|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputFieldType
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needsOuterJoin
condition|)
block|{
comment|// First insert an Agg on top of the subquery
comment|// agg does not like no agg functions so just pretend it is
comment|// doing a min(TRUE)
name|RexNode
name|trueExp
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|exprs
index|[
name|outputFieldCount
operator|-
literal|1
index|]
operator|=
name|trueExp
expr_stmt|;
name|ret
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|ret
argument_list|,
name|exprs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|RelDataType
index|[]
name|argTypes
init|=
operator|new
name|RelDataType
index|[
literal|1
index|]
decl_stmt|;
name|argTypes
index|[
literal|0
index|]
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
name|SqlAggFunction
name|minFunction
init|=
operator|new
name|SqlMinMaxAggFunction
argument_list|(
name|argTypes
argument_list|,
literal|true
argument_list|,
name|SqlMinMaxAggFunction
operator|.
name|MINMAX_COMPARABLE
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|minFunction
operator|.
name|inferReturnType
argument_list|(
name|typeFactory
argument_list|,
name|argTypes
argument_list|)
decl_stmt|;
name|int
name|newProjFieldCount
init|=
name|ret
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|AggregateCall
name|aggCall
init|=
operator|new
name|AggregateCall
argument_list|(
name|minFunction
argument_list|,
literal|false
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|newProjFieldCount
operator|-
literal|1
argument_list|)
argument_list|,
name|returnType
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|new
name|AggregateRel
argument_list|(
name|ret
operator|.
name|getCluster
argument_list|()
argument_list|,
name|ret
argument_list|,
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|0
argument_list|,
name|newProjFieldCount
operator|-
literal|1
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|aggCall
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|ret
operator|=
operator|new
name|AggregateRel
argument_list|(
name|ret
operator|.
name|getCluster
argument_list|()
argument_list|,
name|ret
argument_list|,
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|0
argument_list|,
name|ret
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
name|aggCalls
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Creates a ProjectRel which accomplishes a rename.      *      * @param outputType a row type descriptor whose field names the generated      * ProjectRel must match      * @param rel the rel whose output is to be renamed; rel.getRowType() must      * be the same as outputType except for field names      *      * @return generated relational expression      */
specifier|public
specifier|static
name|RelNode
name|createRenameRel
parameter_list|(
name|RelDataType
name|outputType
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|RelDataType
name|inputType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|inputFields
init|=
name|inputType
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|inputFields
operator|.
name|length
decl_stmt|;
name|RelDataTypeField
index|[]
name|outputFields
init|=
name|outputType
operator|.
name|getFields
argument_list|()
decl_stmt|;
assert|assert
name|outputFields
operator|.
name|length
operator|==
name|n
operator|:
literal|"rename: field count mismatch: in="
operator|+
name|inputType
operator|+
literal|", out"
operator|+
name|outputType
assert|;
name|RexNode
index|[]
name|renameExps
init|=
operator|new
name|RexNode
index|[
name|n
index|]
decl_stmt|;
name|String
index|[]
name|renameNames
init|=
operator|new
name|String
index|[
name|n
index|]
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
assert|assert
operator|(
name|inputFields
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|outputFields
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|)
operator|)
assert|;
name|renameNames
index|[
name|i
index|]
operator|=
name|outputFields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
name|renameExps
index|[
name|i
index|]
operator|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputFields
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|inputFields
index|[
name|i
index|]
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|renameExps
argument_list|,
name|renameNames
argument_list|)
return|;
block|}
comment|/**      * Creates a filter which will remove rows containing NULL values.      *      * @param rel the rel to be filtered      * @param fieldOrdinals array of 0-based field ordinals to filter, or null      * for all fields      *      * @return filtered rel      */
specifier|public
specifier|static
name|RelNode
name|createNullFilter
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Integer
index|[]
name|fieldOrdinals
parameter_list|)
block|{
name|RexNode
name|condition
init|=
literal|null
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fieldOrdinals
operator|!=
literal|null
condition|)
block|{
name|n
operator|=
name|fieldOrdinals
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
name|RelDataTypeField
index|[]
name|fields
init|=
name|rowType
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|int
name|iField
decl_stmt|;
if|if
condition|(
name|fieldOrdinals
operator|!=
literal|null
condition|)
block|{
name|iField
operator|=
name|fieldOrdinals
index|[
name|i
index|]
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|iField
operator|=
name|i
expr_stmt|;
block|}
name|RelDataType
name|type
init|=
name|fields
index|[
name|iField
index|]
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|RexNode
name|newCondition
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNotNullOperator
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|iField
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
name|condition
operator|=
name|newCondition
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|andOperator
argument_list|,
name|condition
argument_list|,
name|newCondition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
comment|// no filtering required
return|return
name|rel
return|;
block|}
return|return
name|CalcRel
operator|.
name|createFilter
argument_list|(
name|rel
argument_list|,
name|condition
argument_list|)
return|;
block|}
comment|/**      * Creates a projection which casts a rel's output to a desired row type.      *      * @param rel producer of rows to be converted      * @param castRowType row type after cast      * @param rename if true, use field names from castRowType; if false,      * preserve field names from rel      *      * @return conversion rel      */
specifier|public
specifier|static
name|RelNode
name|createCastRel
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|)
block|{
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|areRowTypesEqual
argument_list|(
name|rowType
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|)
condition|)
block|{
comment|// nothing to do
return|return
name|rel
return|;
block|}
name|RexNode
index|[]
name|castExps
init|=
name|RexUtil
operator|.
name|generateCastExpressions
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|castRowType
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
if|if
condition|(
name|rename
condition|)
block|{
comment|// Use names and types from castRowType.
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|castExps
argument_list|,
name|getFieldNames
argument_list|(
name|castRowType
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// Use names from rowType, types from castRowType.
return|return
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rel
argument_list|,
name|castExps
argument_list|,
name|getFieldNames
argument_list|(
name|rowType
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Creates an AggregateRel which removes all duplicates from the result of      * an underlying rel.      *      * @param rel underlying rel      *      * @return rel implementing SingleValueAgg      */
specifier|public
specifier|static
name|RelNode
name|createSingleValueAggRel
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
comment|// assert (rel.getRowType().getFieldCount() == 1);
name|int
name|aggCallCnt
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregateCall
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggCallCnt
condition|;
name|i
operator|++
control|)
block|{
name|RelDataType
name|returnType
init|=
name|SqlStdOperatorTable
operator|.
name|singleValueOperator
operator|.
name|inferReturnType
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
operator|new
name|RelDataType
index|[]
block|{
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
block|}
argument_list|)
decl_stmt|;
name|aggCalls
operator|.
name|add
argument_list|(
operator|new
name|AggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|singleValueOperator
argument_list|,
literal|false
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|i
argument_list|)
argument_list|,
name|returnType
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|AggregateRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
argument_list|,
name|Util
operator|.
name|bitSetOf
argument_list|()
argument_list|,
name|aggCalls
argument_list|)
return|;
block|}
comment|/**      * Creates an AggregateRel which removes all duplicates from the result of      * an underlying rel.      *      * @param rel underlying rel      *      * @return rel implementing DISTINCT      */
specifier|public
specifier|static
name|RelNode
name|createDistinctRel
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCalls
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
return|return
operator|new
name|AggregateRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
argument_list|,
name|Util
operator|.
name|bitSetBetween
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
name|aggCalls
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|analyzeSimpleEquiJoin
parameter_list|(
name|JoinRel
name|joinRel
parameter_list|,
name|int
index|[]
name|joinFieldOrdinals
parameter_list|)
block|{
name|RexNode
name|joinExp
init|=
name|joinRel
operator|.
name|getCondition
argument_list|()
decl_stmt|;
if|if
condition|(
name|joinExp
operator|.
name|getKind
argument_list|()
operator|!=
name|RexKind
operator|.
name|Equals
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexCall
name|binaryExpression
init|=
operator|(
name|RexCall
operator|)
name|joinExp
decl_stmt|;
name|RexNode
name|leftComparand
init|=
name|binaryExpression
operator|.
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|RexNode
name|rightComparand
init|=
name|binaryExpression
operator|.
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|leftComparand
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rightComparand
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|leftFieldCount
init|=
name|joinRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RexInputRef
name|leftFieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|leftComparand
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|leftFieldAccess
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
condition|)
block|{
comment|// left field must access left side of join
return|return
literal|false
return|;
block|}
name|RexInputRef
name|rightFieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|rightComparand
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rightFieldAccess
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// right field must access right side of join
return|return
literal|false
return|;
block|}
name|joinFieldOrdinals
index|[
literal|0
index|]
operator|=
name|leftFieldAccess
operator|.
name|getIndex
argument_list|()
expr_stmt|;
name|joinFieldOrdinals
index|[
literal|1
index|]
operator|=
name|rightFieldAccess
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Splits out the equi-join components of a join condition, and returns      * what's left. For example, given the condition      *      *<blockquote><code>L.A = R.X AND L.B = L.C AND (L.D = 5 OR L.E =      * R.Y)</code></blockquote>      *      * returns      *      *<ul>      *<li>leftKeys = {A}      *<li>rightKeys = {X}      *<li>rest = L.B = L.C AND (L.D = 5 OR L.E = R.Y)</li>      *</ul>      *      * @param left left input to join      * @param right right input to join      * @param condition join condition      * @param leftKeys The ordinals of the fields from the left input which are      * equi-join keys      * @param rightKeys The ordinals of the fields from the right input which      * are equi-join keys      *      * @return remaining join filters that are not equijoins; may return a      * {@link RexLiteral} true, but never null      */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|residualList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|residualList
operator|.
name|addAll
argument_list|(
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
switch|switch
condition|(
name|residualList
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|residualList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|RexUtil
operator|.
name|andRexNodeList
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|residualList
argument_list|)
return|;
block|}
block|}
comment|/**      * Splits out the equi-join (and optionally, a single non-equi) components      * of a join condition, and returns what's left. Projection might be      * required by the caller to provide join keys that are not direct field      * references.      *      * @param sysFieldList list of system fields      * @param leftRel left join input      * @param rightRel right join input      * @param condition join condition      * @param leftJoinKeys The join keys from the left input which are equi-join      * keys      * @param rightJoinKeys The join keys from the right input which are      * equi-join keys      * @param filterNulls The join key positions for which null values will not      * match. null values only match for the "is not distinct from" condition.      * @param rangeOp if null, only locate equi-joins; otherwise, locate a      * single non-equi join predicate and return its operator in this list;      * join keys associated with the non-equi join predicate are at the end      * of the key lists returned      *      * @return What's left      */
specifier|public
specifier|static
name|RexNode
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|condition
argument_list|,
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
switch|switch
condition|(
name|nonEquiList
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|null
return|;
case|case
literal|1
case|:
return|return
name|nonEquiList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|RexUtil
operator|.
name|andRexNodeList
argument_list|(
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|FilterRel
name|filterRel
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|filterRel
operator|.
name|getCondition
argument_list|()
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
switch|switch
condition|(
name|nonEquiList
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|null
return|;
case|case
literal|1
case|:
return|return
name|nonEquiList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|RexUtil
operator|.
name|andRexNodeList
argument_list|(
name|filterRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|RexNode
name|splitCorrelatedFilterCondition
parameter_list|(
name|FilterRel
name|filterRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|filterRel
operator|.
name|getCondition
argument_list|()
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
comment|// Convert the remainders into a list that are AND'ed together.
switch|switch
condition|(
name|nonEquiList
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|null
return|;
case|case
literal|1
case|:
return|return
name|nonEquiList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|RexUtil
operator|.
name|andRexNodeList
argument_list|(
name|filterRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|nonEquiList
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sysFieldList
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
parameter_list|,
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|rangeOp
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
specifier|final
name|int
name|sysFieldCount
init|=
name|sysFieldList
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftFieldCount
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|rightFieldCount
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|firstLeftField
init|=
name|sysFieldCount
decl_stmt|;
specifier|final
name|int
name|firstRightField
init|=
name|sysFieldCount
operator|+
name|leftFieldCount
decl_stmt|;
specifier|final
name|int
name|totalFieldCount
init|=
name|firstRightField
operator|+
name|rightFieldCount
decl_stmt|;
specifier|final
name|RelDataTypeField
index|[]
name|leftFields
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
index|[]
name|rightFields
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
comment|// adjustment array
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|totalFieldCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|firstLeftField
init|;
name|i
operator|<
name|firstRightField
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
operator|-
name|firstLeftField
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|firstRightField
init|;
name|i
operator|<
name|totalFieldCount
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
operator|-
name|firstRightField
expr_stmt|;
block|}
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|andOperator
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitJoinCondition
argument_list|(
name|sysFieldList
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|operand
argument_list|,
name|leftJoinKeys
argument_list|,
name|rightJoinKeys
argument_list|,
name|filterNulls
argument_list|,
name|rangeOp
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|RexNode
name|leftKey
init|=
literal|null
decl_stmt|;
name|RexNode
name|rightKey
init|=
literal|null
decl_stmt|;
name|boolean
name|reverse
init|=
literal|false
decl_stmt|;
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
comment|// Only consider range operators if we haven't already seen one
if|if
condition|(
operator|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|equalsOperator
operator|)
operator|||
operator|(
operator|(
name|filterNulls
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|isNotDistinctFromOperator
operator|)
operator|)
operator|||
operator|(
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
name|rangeOp
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|greaterThanOperator
operator|)
operator|||
operator|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
operator|)
operator|||
operator|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|lessThanOperator
operator|)
operator|||
operator|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|lessThanOrEqualOperator
operator|)
operator|)
operator|)
condition|)
block|{
specifier|final
name|RexNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|BitSet
name|projRefs0
init|=
operator|new
name|BitSet
argument_list|(
name|totalFieldCount
argument_list|)
decl_stmt|;
name|BitSet
name|projRefs1
init|=
operator|new
name|BitSet
argument_list|(
name|totalFieldCount
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder0
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|projRefs0
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder1
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|projRefs1
argument_list|)
decl_stmt|;
name|op0
operator|.
name|accept
argument_list|(
name|inputFinder0
argument_list|)
expr_stmt|;
name|op1
operator|.
name|accept
argument_list|(
name|inputFinder1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|projRefs0
operator|.
name|nextSetBit
argument_list|(
name|firstRightField
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|projRefs1
operator|.
name|nextSetBit
argument_list|(
name|firstLeftField
argument_list|)
operator|>=
name|firstRightField
operator|)
condition|)
block|{
name|leftKey
operator|=
name|op0
expr_stmt|;
name|rightKey
operator|=
name|op1
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|projRefs1
operator|.
name|nextSetBit
argument_list|(
name|firstRightField
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|projRefs0
operator|.
name|nextSetBit
argument_list|(
name|firstLeftField
argument_list|)
operator|>=
name|firstRightField
operator|)
condition|)
block|{
name|leftKey
operator|=
name|op1
expr_stmt|;
name|rightKey
operator|=
name|op0
expr_stmt|;
name|reverse
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|leftKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightKey
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// replace right Key input ref
name|rightKey
operator|=
name|rightKey
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|rightFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
comment|// left key only needs to be adjusted if there are system
comment|// fields, but do it for uniformity
name|leftKey
operator|=
name|leftKey
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|leftFields
argument_list|,
name|leftFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|RelDataType
name|leftKeyType
init|=
name|leftKey
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|rightKeyType
init|=
name|rightKey
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftKeyType
operator|!=
name|rightKeyType
condition|)
block|{
comment|// perform casting
name|RelDataType
name|targetKeyType
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
operator|new
name|RelDataType
index|[]
block|{
name|leftKeyType
block|,
name|rightKeyType
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetKeyType
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Cannot find common type for join keys "
operator|+
name|leftKey
operator|+
literal|" (type "
operator|+
name|leftKeyType
operator|+
literal|") and "
operator|+
name|rightKey
operator|+
literal|" (type "
operator|+
name|rightKeyType
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|leftKeyType
operator|!=
name|targetKeyType
condition|)
block|{
name|leftKey
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|targetKeyType
argument_list|,
name|leftKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightKeyType
operator|!=
name|targetKeyType
condition|)
block|{
name|rightKey
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|targetKeyType
argument_list|,
name|rightKey
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|rangeOp
operator|==
literal|null
operator|)
operator|&&
operator|(
operator|(
name|leftKey
operator|==
literal|null
operator|)
operator|||
operator|(
name|rightKey
operator|==
literal|null
operator|)
operator|)
condition|)
block|{
comment|// no equality join keys found yet:
comment|// try tranforming the condition to
comment|// equality "join" conditions, e.g.
comment|//     f(LHS)> 0 ===> ( f(LHS)> 0 ) = TRUE,
comment|// and make the RHS produce TRUE, but only if we're strictly
comment|// looking for equi-joins
name|BitSet
name|projRefs
init|=
operator|new
name|BitSet
argument_list|(
name|totalFieldCount
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|projRefs
argument_list|)
decl_stmt|;
name|condition
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
name|leftKey
operator|=
literal|null
expr_stmt|;
name|rightKey
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|projRefs
operator|.
name|nextSetBit
argument_list|(
name|firstRightField
argument_list|)
operator|<
literal|0
condition|)
block|{
name|leftKey
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|leftFields
argument_list|,
name|leftFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|rightKey
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// effectively performing an equality comparison
name|operator
operator|=
name|SqlStdOperatorTable
operator|.
name|equalsOperator
expr_stmt|;
block|}
if|else if
condition|(
name|projRefs
operator|.
name|nextSetBit
argument_list|(
name|firstLeftField
argument_list|)
operator|>=
name|firstRightField
condition|)
block|{
name|leftKey
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// replace right Key input ref
name|rightKey
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|rightFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
comment|// effectively performing an equality comparison
name|operator
operator|=
name|SqlStdOperatorTable
operator|.
name|equalsOperator
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|leftKey
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightKey
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// found suitable join keys
comment|// add them to key list, ensuring that if there is a
comment|// non-equi join predicate, it appears at the end of the
comment|// key list; also mark the null filtering property
name|addJoinKey
argument_list|(
name|leftJoinKeys
argument_list|,
name|leftKey
argument_list|,
operator|(
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|rangeOp
operator|.
name|isEmpty
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|addJoinKey
argument_list|(
name|rightJoinKeys
argument_list|,
name|rightKey
argument_list|,
operator|(
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|rangeOp
operator|.
name|isEmpty
argument_list|()
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filterNulls
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|equalsOperator
operator|)
condition|)
block|{
comment|// nulls are considered not matching for equality comparison
comment|// add the position of the most recently inserted key
name|filterNulls
operator|.
name|add
argument_list|(
name|leftJoinKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rangeOp
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|operator
operator|!=
name|SqlStdOperatorTable
operator|.
name|equalsOperator
operator|)
operator|&&
operator|(
name|operator
operator|!=
name|SqlStdOperatorTable
operator|.
name|isDistinctFromOperator
operator|)
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
block|{
if|if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|greaterThanOperator
condition|)
block|{
name|operator
operator|=
name|SqlStdOperatorTable
operator|.
name|lessThanOperator
expr_stmt|;
block|}
if|else if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
condition|)
block|{
name|operator
operator|=
name|SqlStdOperatorTable
operator|.
name|lessThanOrEqualOperator
expr_stmt|;
block|}
if|else if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|lessThanOperator
condition|)
block|{
name|operator
operator|=
name|SqlStdOperatorTable
operator|.
name|greaterThanOperator
expr_stmt|;
block|}
if|else if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|lessThanOrEqualOperator
condition|)
block|{
name|operator
operator|=
name|SqlStdOperatorTable
operator|.
name|greaterThanOrEqualOperator
expr_stmt|;
block|}
block|}
name|rangeOp
operator|.
name|add
argument_list|(
name|operator
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// else fall through and add this condition as nonEqui condition
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|addJoinKey
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyList
parameter_list|,
name|RexNode
name|key
parameter_list|,
name|boolean
name|preserveLastElementInList
parameter_list|)
block|{
if|if
condition|(
operator|!
name|joinKeyList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|preserveLastElementInList
condition|)
block|{
name|joinKeyList
operator|.
name|add
argument_list|(
name|joinKeyList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|joinKeyList
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|FilterRel
name|filterRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexInputRef
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|andOperator
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|equalsOperator
condition|)
block|{
specifier|final
name|RexNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op0
argument_list|)
operator|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
operator|(
name|RexInputRef
operator|)
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|splitCorrelatedFilterCondition
parameter_list|(
name|FilterRel
name|filterRel
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|correlatedJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|,
name|boolean
name|extractCorrelatedFieldAccess
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|andOperator
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitCorrelatedFilterCondition
argument_list|(
name|filterRel
argument_list|,
name|operand
argument_list|,
name|joinKeys
argument_list|,
name|correlatedJoinKeys
argument_list|,
name|nonEquiList
argument_list|,
name|extractCorrelatedFieldAccess
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|equalsOperator
condition|)
block|{
specifier|final
name|RexNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|RexNode
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|extractCorrelatedFieldAccess
condition|)
block|{
if|if
condition|(
operator|!
name|RexUtil
operator|.
name|containsFieldAccess
argument_list|(
name|op0
argument_list|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexFieldAccess
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexFieldAccess
operator|)
operator|&&
operator|!
name|RexUtil
operator|.
name|containsFieldAccess
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op0
argument_list|)
operator|)
operator|&&
operator|(
name|op1
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|joinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
if|else if
condition|(
operator|(
name|op0
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|!
operator|(
name|RexUtil
operator|.
name|containsInputRef
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|add
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|correlatedJoinKeys
operator|.
name|add
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|// The operator is not of RexCall type
comment|// So we fail. Fall through.
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|splitJoinCondition
parameter_list|(
specifier|final
name|int
name|leftFieldCount
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nonEquiList
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|andOperator
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|splitJoinCondition
argument_list|(
name|leftFieldCount
argument_list|,
name|operand
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|nonEquiList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|equalsOperator
condition|)
block|{
specifier|final
name|RexNode
index|[]
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|operands
index|[
literal|0
index|]
operator|instanceof
name|RexInputRef
operator|)
operator|&&
operator|(
name|operands
index|[
literal|1
index|]
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|RexInputRef
name|op0
init|=
operator|(
name|RexInputRef
operator|)
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|RexInputRef
name|op1
init|=
operator|(
name|RexInputRef
operator|)
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|RexInputRef
name|leftField
decl_stmt|,
name|rightField
decl_stmt|;
if|if
condition|(
operator|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
operator|&&
operator|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// Arguments were of form 'op0 = op1'
name|leftField
operator|=
name|op0
expr_stmt|;
name|rightField
operator|=
name|op1
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|)
operator|&&
operator|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
operator|)
condition|)
block|{
comment|// Arguments were of form 'op1 = op0'
name|leftField
operator|=
name|op1
expr_stmt|;
name|rightField
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
return|return;
block|}
name|leftKeys
operator|.
name|add
argument_list|(
name|leftField
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|rightField
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Arguments were not field references, one from each side, so
comment|// we fail. Fall through.
block|}
block|}
comment|// Add this condition to the list of non-equi-join conditions.
name|nonEquiList
operator|.
name|add
argument_list|(
name|condition
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adding projection to the inputs of a join to produce the required join      * keys.      *      * @param inputRels inputs to a join      * @param leftJoinKeys expressions for LHS of join key      * @param rightJoinKeys expressions for RHS of join key      * @param systemColCount number of system columns, usually zero. These      * columns are projected at the leading edge of the output row.      * @param leftKeys on return this contains the join key positions from the      * new project rel on the LHS.      * @param rightKeys on return this contains the join key positions from the      * new project rel on the RHS.      * @param outputProj on return this contains the positions of the original      * join output in the (to be formed by caller) LhxJoinRel. Caller needs to      * be responsible for adding projection on the new join output.      */
specifier|public
specifier|static
name|void
name|projectJoinInputs
parameter_list|(
name|RelNode
index|[]
name|inputRels
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|int
name|systemColCount
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|outputProj
parameter_list|)
block|{
name|RelNode
name|leftRel
init|=
name|inputRels
index|[
literal|0
index|]
decl_stmt|;
name|RelNode
name|rightRel
init|=
name|inputRels
index|[
literal|1
index|]
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|int
name|origLeftInputSize
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|origRightInputSize
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newLeftFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newRightFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newRightFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|leftKeyCount
init|=
name|leftJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|rightKeyCount
init|=
name|rightJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|systemColCount
condition|;
name|i
operator|++
control|)
block|{
name|outputProj
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origLeftInputSize
condition|;
name|i
operator|++
control|)
block|{
name|newLeftFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outputProj
operator|.
name|add
argument_list|(
name|systemColCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|newLeftKeyCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leftKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|leftKey
init|=
name|leftJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftKey
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// already added to the projected left fields
comment|// only need to remember the index in the join key list
name|leftKeys
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|leftKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newLeftFields
operator|.
name|add
argument_list|(
name|leftKey
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
name|leftKey
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|leftKeys
operator|.
name|add
argument_list|(
name|origLeftInputSize
operator|+
name|newLeftKeyCount
argument_list|)
expr_stmt|;
name|newLeftKeyCount
operator|++
expr_stmt|;
block|}
block|}
name|int
name|leftFieldCount
init|=
name|origLeftInputSize
operator|+
name|newLeftKeyCount
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origRightInputSize
condition|;
name|i
operator|++
control|)
block|{
name|newRightFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outputProj
operator|.
name|add
argument_list|(
name|systemColCount
operator|+
name|leftFieldCount
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|newRightKeyCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rightKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|rightKey
init|=
name|rightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightKey
operator|instanceof
name|RexInputRef
condition|)
block|{
comment|// already added to the projected left fields
comment|// only need to remember the index in the join key list
name|rightKeys
operator|.
name|add
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rightKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newRightFields
operator|.
name|add
argument_list|(
name|rightKey
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
name|rightKey
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|origRightInputSize
operator|+
name|newRightKeyCount
argument_list|)
expr_stmt|;
name|newRightKeyCount
operator|++
expr_stmt|;
block|}
block|}
comment|// added project if need to produce new keys than the original input
comment|// fields
if|if
condition|(
name|newLeftKeyCount
operator|>
literal|0
condition|)
block|{
name|leftRel
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|leftRel
argument_list|,
name|newLeftFields
argument_list|,
name|newLeftFieldNames
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newRightKeyCount
operator|>
literal|0
condition|)
block|{
name|rightRel
operator|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|rightRel
argument_list|,
name|newRightFields
argument_list|,
name|newRightFieldNames
argument_list|)
expr_stmt|;
block|}
name|inputRels
index|[
literal|0
index|]
operator|=
name|leftRel
expr_stmt|;
name|inputRels
index|[
literal|1
index|]
operator|=
name|rightRel
expr_stmt|;
block|}
comment|/**      * Creates a projection on top of a join, if the desired projection is a      * subset of the join columns      *      * @param outputProj desired projection; if null, return original join node      * @param joinRel the join node      *      * @return projected join node or the original join if projection is      * unnecessary      */
specifier|public
specifier|static
name|RelNode
name|createProjectJoinRel
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|outputProj
parameter_list|,
name|RelNode
name|joinRel
parameter_list|)
block|{
name|int
name|newProjectOutputSize
init|=
name|outputProj
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|joinOutputFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
comment|// If no projection was passed in, or the number of desired projection
comment|// columns is the same as the number of columns returned from the
comment|// join, then no need to create a projection
if|if
condition|(
operator|(
name|newProjectOutputSize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|newProjectOutputSize
operator|<
name|joinOutputFields
operator|.
name|length
operator|)
condition|)
block|{
name|RexNode
index|[]
name|newProjectOutputFields
init|=
operator|new
name|RexNode
index|[
name|newProjectOutputSize
index|]
decl_stmt|;
name|String
index|[]
name|newProjectOutputNames
init|=
operator|new
name|String
index|[
name|newProjectOutputSize
index|]
decl_stmt|;
comment|// Create the individual projection expressions
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newProjectOutputSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|fieldIndex
init|=
name|outputProj
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newProjectOutputFields
index|[
name|i
index|]
operator|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|joinOutputFields
index|[
name|fieldIndex
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|fieldIndex
argument_list|)
expr_stmt|;
name|newProjectOutputNames
index|[
name|i
index|]
operator|=
name|joinOutputFields
index|[
name|fieldIndex
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
comment|// Create a project rel on the output of the join.
name|RelNode
name|projectOutputRel
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|joinRel
argument_list|,
name|newProjectOutputFields
argument_list|,
name|newProjectOutputNames
argument_list|)
decl_stmt|;
return|return
name|projectOutputRel
return|;
block|}
return|return
name|joinRel
return|;
block|}
specifier|public
specifier|static
name|void
name|registerAbstractRels
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|PullConstantsThroughAggregatesRule
operator|.
name|instance
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|FilterToCalcRule
operator|.
name|instance
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|ProjectToCalcRule
operator|.
name|instance
argument_list|)
expr_stmt|;
comment|// REVIEW jvs 9-Apr-2006: Do we still need these two?  Doesn't the
comment|// combination of MergeCalcRule, FilterToCalcRule, and
comment|// ProjectToCalcRule have the same effect?
name|planner
operator|.
name|addRule
argument_list|(
name|MergeFilterOntoCalcRule
operator|.
name|instance
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|MergeProjectOntoCalcRule
operator|.
name|instance
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|MergeCalcRule
operator|.
name|instance
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRule
operator|.
name|unionInstance
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRule
operator|.
name|projectInstance
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|RemoveEmptyRule
operator|.
name|filterInstance
argument_list|)
expr_stmt|;
block|}
comment|/**      * Dumps a plan as a string.      *      * @param header Header to print before the plan. Ignored if the format is      * XML.      * @param rel Relational expression to explain.      * @param asXml Whether to format as XML.      * @param detailLevel Detail level.      *      * @return Plan      */
specifier|public
specifier|static
name|String
name|dumpPlan
parameter_list|(
name|String
name|header
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|boolean
name|asXml
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|header
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
name|RelOptPlanWriter
name|planWriter
decl_stmt|;
if|if
condition|(
name|asXml
condition|)
block|{
name|planWriter
operator|=
operator|new
name|RelOptXmlPlanWriter
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|planWriter
operator|=
operator|new
name|RelOptPlanWriter
argument_list|(
name|pw
argument_list|,
name|detailLevel
argument_list|)
expr_stmt|;
block|}
name|planWriter
operator|.
name|setIdPrefix
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Creates the row type descriptor for the result of a DML operation, which      * is a single column named ROWCOUNT of type BIGINT.      *      * @param typeFactory factory to use for creating type descriptor      *      * @return created type      */
specifier|public
specifier|static
name|RelDataType
name|createDmlRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
operator|new
name|RelDataType
index|[]
block|{
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
block|}
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"ROWCOUNT"
block|}
argument_list|)
return|;
block|}
comment|/**      * Creates a reference to an output field of a relational expression.      *      * @param rel Relational expression      * @param i Field ordinal; if negative, counts from end, so -1 means the      * last field      */
specifier|public
specifier|static
name|RexNode
name|createInputRef
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|i
parameter_list|)
block|{
specifier|final
name|RelDataTypeField
index|[]
name|fields
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|fields
operator|.
name|length
operator|+
name|i
expr_stmt|;
block|}
return|return
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|fields
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**      * Returns whether two types are equal using '='.      *      * @param desc1      * @param type1 First type      * @param desc2      * @param type2 Second type      * @param fail Whether to assert if they are not equal      *      * @return Whether the types are equal      */
specifier|public
specifier|static
name|boolean
name|eq
parameter_list|(
specifier|final
name|String
name|desc1
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
specifier|final
name|String
name|desc2
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"type mismatch:"
operator|+
name|NL
operator|+
name|desc1
operator|+
literal|":"
operator|+
name|NL
operator|+
name|type1
operator|.
name|getFullTypeString
argument_list|()
operator|+
name|NL
operator|+
name|desc2
operator|+
literal|":"
operator|+
name|NL
operator|+
name|type2
operator|.
name|getFullTypeString
argument_list|()
assert|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns whether two types are equal using {@link      * #areRowTypesEqual(RelDataType, RelDataType, boolean)}. Both types must      * not be null.      *      * @param desc1 Description of role of first type      * @param type1 First type      * @param desc2 Description of role of second type      * @param type2 Second type      * @param fail Whether to assert if they are not equal      *      * @return Whether the types are equal      */
specifier|public
specifier|static
name|boolean
name|equal
parameter_list|(
specifier|final
name|String
name|desc1
parameter_list|,
name|RelDataType
name|type1
parameter_list|,
specifier|final
name|String
name|desc2
parameter_list|,
name|RelDataType
name|type2
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
operator|!
name|areRowTypesEqual
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|,
literal|false
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
literal|"Type mismatch:"
operator|+
name|NL
operator|+
name|desc1
operator|+
literal|":"
operator|+
name|NL
operator|+
name|type1
operator|.
name|getFullTypeString
argument_list|()
operator|+
name|NL
operator|+
name|desc2
operator|+
literal|":"
operator|+
name|NL
operator|+
name|type2
operator|.
name|getFullTypeString
argument_list|()
assert|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns a translation of the<code>IS DISTINCT FROM</code> (or<code>IS      * NOT DISTINCT FROM</code>) sql operator.      *      * @param neg if false, returns a translation of IS NOT DISTINCT FROM      */
specifier|public
specifier|static
name|RexNode
name|isDistinctFrom
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|x
parameter_list|,
name|RexNode
name|y
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|RexNode
name|ret
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
assert|assert
operator|(
name|y
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
operator|)
assert|;
name|RelDataTypeField
index|[]
name|xFields
init|=
name|x
operator|.
name|getType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|yFields
init|=
name|x
operator|.
name|getType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|xFields
operator|.
name|length
operator|==
name|yFields
operator|.
name|length
operator|)
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xFields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|xField
init|=
name|xFields
index|[
name|i
index|]
decl_stmt|;
name|RelDataTypeField
name|yField
init|=
name|yFields
index|[
name|i
index|]
decl_stmt|;
name|RexNode
name|newX
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|x
argument_list|,
name|xField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|newY
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|y
argument_list|,
name|yField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|newCall
init|=
name|isDistinctFromInternal
argument_list|(
name|rexBuilder
argument_list|,
name|newX
argument_list|,
name|newY
argument_list|,
name|neg
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
assert|assert
operator|(
literal|null
operator|!=
name|ret
operator|)
assert|;
name|ret
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|andOperator
argument_list|,
name|ret
argument_list|,
name|newCall
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
literal|null
operator|==
name|ret
operator|)
assert|;
name|ret
operator|=
name|newCall
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ret
operator|=
name|isDistinctFromInternal
argument_list|(
name|rexBuilder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|neg
argument_list|)
expr_stmt|;
block|}
comment|// The result of IS DISTINCT FROM is NOT NULL because it can
comment|// only return TRUE or FALSE.
name|ret
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
specifier|static
name|RexNode
name|isDistinctFromInternal
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|x
parameter_list|,
name|RexNode
name|y
parameter_list|,
name|boolean
name|neg
parameter_list|)
block|{
name|SqlOperator
name|nullOp
decl_stmt|;
name|SqlOperator
name|eqOp
decl_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|nullOp
operator|=
name|SqlStdOperatorTable
operator|.
name|isNullOperator
expr_stmt|;
name|eqOp
operator|=
name|SqlStdOperatorTable
operator|.
name|equalsOperator
expr_stmt|;
block|}
else|else
block|{
name|nullOp
operator|=
name|SqlStdOperatorTable
operator|.
name|isNotNullOperator
expr_stmt|;
name|eqOp
operator|=
name|SqlStdOperatorTable
operator|.
name|notEqualsOperator
expr_stmt|;
block|}
name|RexNode
index|[]
name|whenThenElse
init|=
block|{
comment|// when x is null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNullOperator
argument_list|,
name|x
argument_list|)
block|,
comment|// then return y is [not] null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|nullOp
argument_list|,
name|y
argument_list|)
block|,
comment|// when y is null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|isNullOperator
argument_list|,
name|y
argument_list|)
block|,
comment|// then return x is [not] null
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|nullOp
argument_list|,
name|x
argument_list|)
block|,
comment|// else return x compared to y
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|eqOp
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
block|}
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|caseOperator
argument_list|,
name|whenThenElse
argument_list|)
return|;
block|}
comment|/**      * Converts a relational expression to a string.      */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPlanWriter
name|planWriter
init|=
operator|new
name|RelOptPlanWriter
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
argument_list|)
decl_stmt|;
name|planWriter
operator|.
name|setIdPrefix
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|rel
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
name|planWriter
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Renames a relational expression to make its field names the same as      * another row type. If the row type is already identical, or if the row      * type is too different (the fields are different in number or type) does      * nothing.      *      * @param rel Relational expression      * @param desiredRowType Desired row type (including desired field names)      *      * @return Renamed relational expression, or the original expression if      * there is nothing to do or nothing we<em>can</em> do.      */
specifier|public
specifier|static
name|RelNode
name|renameIfNecessary
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelDataType
name|desiredRowType
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowType
operator|==
name|desiredRowType
condition|)
block|{
comment|// Nothing to do.
return|return
name|rel
return|;
block|}
assert|assert
operator|!
name|rowType
operator|.
name|equals
argument_list|(
name|desiredRowType
argument_list|)
assert|;
if|if
condition|(
operator|!
name|areRowTypesEqual
argument_list|(
name|rowType
argument_list|,
name|desiredRowType
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// The row types are different ignoring names. Nothing we can do.
return|return
name|rel
return|;
block|}
name|rel
operator|=
name|CalcRel
operator|.
name|createRename
argument_list|(
name|rel
argument_list|,
name|getFieldNames
argument_list|(
name|desiredRowType
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rel
return|;
block|}
specifier|public
specifier|static
name|String
name|dumpType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
specifier|final
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
specifier|final
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
specifier|final
name|TypeDumper
name|typeDumper
init|=
operator|new
name|TypeDumper
argument_list|(
name|pw
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|typeDumper
operator|.
name|acceptFields
argument_list|(
name|type
operator|.
name|getFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typeDumper
operator|.
name|accept
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|sw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Decompose a rex predicate into list of RexNodes that are AND'ed together      *      * @param rexPredicate predicate to be analyzed      * @param rexList list of decomposed RexNodes      */
specifier|public
specifier|static
name|void
name|decomposeConjunction
parameter_list|(
name|RexNode
name|rexPredicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList
parameter_list|)
block|{
if|if
condition|(
name|rexPredicate
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rexPredicate
operator|.
name|isA
argument_list|(
name|RexKind
operator|.
name|And
argument_list|)
condition|)
block|{
specifier|final
name|RexNode
index|[]
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rexPredicate
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|operand
init|=
name|operands
index|[
name|i
index|]
decl_stmt|;
name|decomposeConjunction
argument_list|(
name|operand
argument_list|,
name|rexList
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rexList
operator|.
name|add
argument_list|(
name|rexPredicate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Ands two sets of join filters together, either of which can be null.      *      * @param rexBuilder rexBuilder to create AND expression      * @param left filter on the left that the right will be AND'd to      * @param right filter on the right      *      * @return AND'd filter      */
specifier|public
specifier|static
name|RexNode
name|andJoinFilters
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|left
parameter_list|,
name|RexNode
name|right
parameter_list|)
block|{
comment|// don't bother AND'ing in expressions that always evaluate to
comment|// true
if|if
condition|(
operator|(
name|left
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|left
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|right
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|right
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|left
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|andOperator
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|left
operator|=
name|right
expr_stmt|;
block|}
comment|// Joins must have some filter
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
name|left
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|left
return|;
block|}
comment|/**      * Adjusts key values in a list by some fixed amount.      *      * @param keys list of key values      * @param adjustment the amount to adjust the key values by      *      * @return modified list      */
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|adjustKeys
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|keys
parameter_list|,
name|int
name|adjustment
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|newKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|newKeys
operator|.
name|add
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|adjustment
argument_list|)
expr_stmt|;
block|}
return|return
name|newKeys
return|;
block|}
comment|/**      * Sets a bit in a bitmap for each RexInputRef in a RelNode      *      * @param bitmap bitmap to be set      * @param start starting bit to set, corresponding to first field in the      * RelNode      * @param end the bit one beyond the last to be set      */
specifier|public
specifier|static
name|void
name|setRexInputBitmap
parameter_list|(
name|BitSet
name|bitmap
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|bitmap
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns true if all bits set in the second parameter are also set in the      * first      *      * @param x containing bitmap      * @param y bitmap to be checked      *      * @return true if all bits in the second parameter are set in the first      */
specifier|public
specifier|static
name|boolean
name|contains
parameter_list|(
name|BitSet
name|x
parameter_list|,
name|BitSet
name|y
parameter_list|)
block|{
name|BitSet
name|tmp
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|or
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|andNot
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|tmp
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**      * Classifies filters according to where they should be processed. They      * either stay where they are, are pushed to the join (if they originated      * from above the join), or are pushed to one of the children. Filters that      * are pushed are added to list passed in as input parameters.      *      * @param joinRel join node      * @param filters filters to be classified      * @param pushJoin true if filters originated from above the join node and      * the join is an inner join      * @param pushLeft true if filters can be pushed to the left      * @param pushRight true if filters can be pushed to the right      * @param joinFilters list of filters to push to the join      * @param leftFilters list of filters to push to the left child      * @param rightFilters list of filters to push to the right child      *      * @return true if at least one filter was pushed      */
specifier|public
specifier|static
name|boolean
name|classifyFilters
parameter_list|(
name|RelNode
name|joinRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|boolean
name|pushJoin
parameter_list|,
name|boolean
name|pushLeft
parameter_list|,
name|boolean
name|pushRight
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
parameter_list|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|boolean
name|filterPushed
init|=
literal|false
decl_stmt|;
name|RelDataTypeField
index|[]
name|joinFields
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|int
name|nTotalFields
init|=
name|joinFields
operator|.
name|length
decl_stmt|;
name|int
name|nFieldsLeft
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|BitSet
name|leftBitmap
init|=
operator|new
name|BitSet
argument_list|(
name|nFieldsLeft
argument_list|)
decl_stmt|;
name|BitSet
name|rightBitmap
init|=
operator|new
name|BitSet
argument_list|(
name|nTotalFields
operator|-
name|nFieldsLeft
argument_list|)
decl_stmt|;
comment|// set the reference bitmaps for the left and right children
name|RelOptUtil
operator|.
name|setRexInputBitmap
argument_list|(
name|leftBitmap
argument_list|,
literal|0
argument_list|,
name|nFieldsLeft
argument_list|)
expr_stmt|;
name|RelOptUtil
operator|.
name|setRexInputBitmap
argument_list|(
name|rightBitmap
argument_list|,
name|nFieldsLeft
argument_list|,
name|nTotalFields
argument_list|)
expr_stmt|;
name|ListIterator
argument_list|<
name|RexNode
argument_list|>
name|filterIter
init|=
name|filters
operator|.
name|listIterator
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|rightFields
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
while|while
condition|(
name|filterIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|filter
init|=
name|filterIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|BitSet
name|filterBitmap
init|=
operator|new
name|BitSet
argument_list|(
name|nTotalFields
argument_list|)
decl_stmt|;
name|filter
operator|.
name|accept
argument_list|(
operator|new
name|InputFinder
argument_list|(
name|filterBitmap
argument_list|)
argument_list|)
expr_stmt|;
comment|// REVIEW - are there any expressions that need special handling
comment|// and therefore cannot be pushed?
comment|// filters can be pushed to the left child if the left child
comment|// does not generate NULLs and the only columns referenced in
comment|// the filter originate from the left child
if|if
condition|(
name|pushLeft
operator|&&
name|RelOptUtil
operator|.
name|contains
argument_list|(
name|leftBitmap
argument_list|,
name|filterBitmap
argument_list|)
condition|)
block|{
name|filterPushed
operator|=
literal|true
expr_stmt|;
comment|// ignore filters that always evaluate to true
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|leftFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
name|filterIter
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// filters can be pushed to the right child if the right child
comment|// does not generate NULLs and the only columns referenced in
comment|// the filter originate from the right child
block|}
if|else if
condition|(
name|pushRight
operator|&&
name|RelOptUtil
operator|.
name|contains
argument_list|(
name|rightBitmap
argument_list|,
name|filterBitmap
argument_list|)
condition|)
block|{
name|filterPushed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|filter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the field references in the filter to reflect
comment|// that fields in the right now shift over to the left;
comment|// since we never push filters to a NULL generating
comment|// child, the types of the source should match the dest
comment|// so we don't need to explicitly pass the destination
comment|// fields to RexInputConverter
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|nTotalFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nFieldsLeft
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|nFieldsLeft
init|;
name|i
operator|<
name|nTotalFields
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
operator|-
name|nFieldsLeft
expr_stmt|;
block|}
name|rightFilters
operator|.
name|add
argument_list|(
name|filter
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|joinFields
argument_list|,
name|rightFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|filterIter
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// if the filter can't be pushed to either child and the join
comment|// is an inner join, push them to the join if they originated
comment|// from above the join
block|}
if|else if
condition|(
name|pushJoin
condition|)
block|{
name|filterPushed
operator|=
literal|true
expr_stmt|;
name|joinFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|filterIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|// else, leave the filter where it is
block|}
return|return
name|filterPushed
return|;
block|}
comment|/**      * Splits a filter into two lists, depending on whether or not the filter      * only references its child input      *      * @param nChildFields number of fields in the child      * @param predicate filters that will be split      * @param pushable returns the list of filters that can be pushed to the      * child input      * @param notPushable returns the list of filters that cannot be pushed to      * the child input      */
specifier|public
specifier|static
name|void
name|splitFilters
parameter_list|(
name|int
name|nChildFields
parameter_list|,
name|RexNode
name|predicate
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|pushable
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|notPushable
parameter_list|)
block|{
comment|// convert the filter to a list
name|List
argument_list|<
name|RexNode
argument_list|>
name|filterList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|predicate
argument_list|,
name|filterList
argument_list|)
expr_stmt|;
comment|// for each filter, if the filter only references the child inputs,
comment|// then it can be pushed
name|BitSet
name|childBitmap
init|=
operator|new
name|BitSet
argument_list|(
name|nChildFields
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|setRexInputBitmap
argument_list|(
name|childBitmap
argument_list|,
literal|0
argument_list|,
name|nChildFields
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|filterList
control|)
block|{
name|BitSet
name|filterRefs
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
name|filter
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|filterRefs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RelOptUtil
operator|.
name|contains
argument_list|(
name|childBitmap
argument_list|,
name|filterRefs
argument_list|)
condition|)
block|{
name|pushable
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notPushable
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Splits a join condition.      *      * @param left Left input to the join      * @param right Right input to the join      * @param condition Join condition      *      * @return Array holding the output; neither element is null. Element 0 is      * the equi-join condition (or TRUE if empty); Element 1 is rest of the      * condition (or TRUE if empty).      */
specifier|public
specifier|static
name|RexNode
index|[]
name|splitJoinCondition
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|RelNode
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|nonEquiCondition
init|=
name|splitJoinCondition
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|condition
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|)
decl_stmt|;
assert|assert
name|nonEquiCondition
operator|!=
literal|null
assert|;
name|RexNode
name|equiCondition
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
assert|assert
name|leftKeys
operator|.
name|size
argument_list|()
operator|==
name|rightKeys
operator|.
name|size
argument_list|()
assert|;
specifier|final
name|int
name|keyCount
init|=
name|leftKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|leftKey
init|=
name|leftKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|rightKey
init|=
name|rightKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|equi
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|equalsOperator
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|leftKey
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|leftKey
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|right
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
index|[
name|rightKey
index|]
operator|.
name|getType
argument_list|()
argument_list|,
name|rightKey
operator|+
name|offset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|equiCondition
operator|=
name|equi
expr_stmt|;
block|}
else|else
block|{
name|equiCondition
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|andOperator
argument_list|,
name|equiCondition
argument_list|,
name|equi
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|RexNode
index|[]
block|{
name|equiCondition
block|,
name|nonEquiCondition
block|}
return|;
block|}
comment|/**      * Determines if a projection and its input reference identical input      * references.      *      * @param project projection being examined      * @param checkNames if true, also compare that the names of the project      * fields and its child fields      *      * @return if checkNames is false, true is returned if the project and its      * child reference the same input references, regardless of the names of the      * project and child fields; if checkNames is true, then true is returned if      * the input references are the same but the field names are different      */
specifier|public
specifier|static
name|boolean
name|checkProjAndChildInputs
parameter_list|(
name|ProjectRel
name|project
parameter_list|,
name|boolean
name|checkNames
parameter_list|)
block|{
if|if
condition|(
operator|!
name|project
operator|.
name|isBoxed
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|n
init|=
name|project
operator|.
name|getProjectExps
argument_list|()
operator|.
name|length
decl_stmt|;
name|RelDataType
name|inputType
init|=
name|project
operator|.
name|getChild
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputType
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|n
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RelDataTypeField
index|[]
name|projFields
init|=
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|RelDataTypeField
index|[]
name|inputFields
init|=
name|inputType
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|boolean
name|namesDifferent
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|RexNode
name|exp
init|=
name|project
operator|.
name|getProjectExps
argument_list|()
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|exp
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|RexInputRef
name|fieldAccess
init|=
operator|(
name|RexInputRef
operator|)
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|fieldAccess
operator|.
name|getIndex
argument_list|()
condition|)
block|{
comment|// can't support reorder yet
return|return
literal|false
return|;
block|}
if|if
condition|(
name|checkNames
condition|)
block|{
name|String
name|inputFieldName
init|=
name|inputFields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|projFieldName
init|=
name|projFields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|projFieldName
operator|.
name|equals
argument_list|(
name|inputFieldName
argument_list|)
condition|)
block|{
name|namesDifferent
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// inputs are the same; return value depends on the checkNames
comment|// parameter
return|return
operator|(
operator|!
name|checkNames
operator|||
name|namesDifferent
operator|)
return|;
block|}
comment|/**      * Creates projection expressions reflecting the swapping of a join's input.      *      * @param newJoin the RelNode corresponding to the join with its inputs      * swapped      * @param origJoin original JoinRel      * @param origOrder if true, create the projection expressions to reflect      * the original (pre-swapped) join projection; otherwise, create the      * projection to reflect the order of the swapped projection      *      * @return array of expression representing the swapped join inputs      */
specifier|public
specifier|static
name|RexNode
index|[]
name|createSwappedJoinExprs
parameter_list|(
name|RelNode
name|newJoin
parameter_list|,
name|JoinRel
name|origJoin
parameter_list|,
name|boolean
name|origOrder
parameter_list|)
block|{
specifier|final
name|RelDataTypeField
index|[]
name|newJoinFields
init|=
name|newJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFields
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|newJoin
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|exps
init|=
operator|new
name|RexNode
index|[
name|newJoinFields
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|int
name|nFields
init|=
name|origOrder
condition|?
name|origJoin
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
else|:
name|origJoin
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exps
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|source
init|=
operator|(
name|i
operator|+
name|nFields
operator|)
operator|%
name|exps
operator|.
name|length
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|origOrder
condition|?
name|newJoinFields
index|[
name|source
index|]
else|:
name|newJoinFields
index|[
name|i
index|]
decl_stmt|;
name|exps
index|[
name|i
index|]
operator|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
return|return
name|exps
return|;
block|}
comment|/**      * Creates a new SetOpRel corresponding to an original SetOpRel with a new      * set of input children      *      * @param setOpRel the original SetOpRel      * @param newSetOpInputs the input children      *      * @return new SetOpRel      */
specifier|public
specifier|static
name|SetOpRel
name|createNewSetOpRel
parameter_list|(
name|SetOpRel
name|setOpRel
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|newSetOpInputs
parameter_list|)
block|{
name|SetOpRel
name|newSetOpRel
init|=
literal|null
decl_stmt|;
name|RelOptCluster
name|cluster
init|=
name|setOpRel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
if|if
condition|(
name|setOpRel
operator|instanceof
name|UnionRel
condition|)
block|{
name|newSetOpRel
operator|=
operator|new
name|UnionRel
argument_list|(
name|cluster
argument_list|,
name|newSetOpInputs
argument_list|,
operator|!
name|setOpRel
operator|.
name|isDistinct
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|setOpRel
operator|instanceof
name|IterConcatenateRel
condition|)
block|{
name|newSetOpRel
operator|=
operator|new
name|IterConcatenateRel
argument_list|(
name|cluster
argument_list|,
name|newSetOpInputs
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|setOpRel
operator|instanceof
name|IntersectRel
condition|)
block|{
name|newSetOpRel
operator|=
operator|new
name|IntersectRel
argument_list|(
name|cluster
argument_list|,
name|newSetOpInputs
argument_list|,
operator|!
name|setOpRel
operator|.
name|isDistinct
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|setOpRel
operator|instanceof
name|MinusRel
condition|)
block|{
name|newSetOpRel
operator|=
operator|new
name|MinusRel
argument_list|(
name|cluster
argument_list|,
name|newSetOpInputs
argument_list|,
operator|!
name|setOpRel
operator|.
name|isDistinct
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|newSetOpRel
return|;
block|}
comment|/**      * Converts a filter to the new filter that would result if the filter is      * pushed past a ProjectRel that it currently is referencing.      *      * @param filter the filter to be converted      * @param projRel project rel underneath the filter      *      * @return converted filter      */
specifier|public
specifier|static
name|RexNode
name|pushFilterPastProject
parameter_list|(
name|RexNode
name|filter
parameter_list|,
name|ProjectRelBase
name|projRel
parameter_list|)
block|{
comment|// use RexPrograms to merge the filter and ProjectRel into a
comment|// single program so we can convert the FilterRel condition to
comment|// directly reference the ProjectRel's child
name|RexBuilder
name|rexBuilder
init|=
name|projRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexProgram
name|bottomProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|projRel
operator|.
name|getChild
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|projRel
operator|.
name|getProjectExps
argument_list|()
argument_list|,
literal|null
argument_list|,
name|projRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|RexProgramBuilder
name|topProgramBuilder
init|=
operator|new
name|RexProgramBuilder
argument_list|(
name|projRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|topProgramBuilder
operator|.
name|addIdentity
argument_list|()
expr_stmt|;
name|topProgramBuilder
operator|.
name|addCondition
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|RexProgram
name|topProgram
init|=
name|topProgramBuilder
operator|.
name|getProgram
argument_list|()
decl_stmt|;
name|RexProgram
name|mergedProgram
init|=
name|RexProgramBuilder
operator|.
name|mergePrograms
argument_list|(
name|topProgram
argument_list|,
name|bottomProgram
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
return|return
name|mergedProgram
operator|.
name|expandLocalRef
argument_list|(
name|mergedProgram
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates a new {@link MultiJoinRel} to reflect projection references from      * a {@link ProjectRel} that is on top of the {@link MultiJoinRel}.      *      * @param multiJoin the original MultiJoinRel      * @param project the ProjectRel on top of the MultiJoinRel      *      * @return the new MultiJoinRel      */
specifier|public
specifier|static
name|MultiJoinRel
name|projectMultiJoin
parameter_list|(
name|MultiJoinRel
name|multiJoin
parameter_list|,
name|ProjectRel
name|project
parameter_list|)
block|{
comment|// Locate all input references in the projection expressions as well
comment|// the post-join filter.  Since the filter effectively sits in
comment|// between the ProjectRel and the MultiJoinRel, the projection needs
comment|// to include those filter references.
name|BitSet
name|inputRefs
init|=
operator|new
name|BitSet
argument_list|(
name|multiJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|inputRefs
argument_list|)
operator|.
name|apply
argument_list|(
name|project
operator|.
name|getProjectExps
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getPostJoinFilter
argument_list|()
argument_list|)
expr_stmt|;
comment|// create new copies of the bitmaps
name|List
argument_list|<
name|RelNode
argument_list|>
name|multiJoinInputs
init|=
name|multiJoin
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|int
name|nInputs
init|=
name|multiJoinInputs
operator|.
name|size
argument_list|()
decl_stmt|;
name|BitSet
index|[]
name|newProjFields
init|=
operator|new
name|BitSet
index|[
name|nInputs
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nInputs
condition|;
name|i
operator|++
control|)
block|{
name|newProjFields
index|[
name|i
index|]
operator|=
operator|new
name|BitSet
argument_list|(
name|multiJoinInputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// set the bits found in the expressions
name|int
name|currInput
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|startField
init|=
literal|0
decl_stmt|;
name|int
name|nFields
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|bit
init|=
name|inputRefs
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
init|;
name|bit
operator|>=
literal|0
condition|;
name|bit
operator|=
name|inputRefs
operator|.
name|nextSetBit
argument_list|(
name|bit
operator|+
literal|1
argument_list|)
control|)
block|{
while|while
condition|(
name|bit
operator|>=
operator|(
name|startField
operator|+
name|nFields
operator|)
condition|)
block|{
name|startField
operator|+=
name|nFields
expr_stmt|;
name|currInput
operator|++
expr_stmt|;
assert|assert
operator|(
name|currInput
operator|<
name|nInputs
operator|)
assert|;
name|nFields
operator|=
name|multiJoinInputs
operator|.
name|get
argument_list|(
name|currInput
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
name|newProjFields
index|[
name|currInput
index|]
operator|.
name|set
argument_list|(
name|bit
operator|-
name|startField
argument_list|)
expr_stmt|;
block|}
comment|// create a new MultiJoinRel containing the new field bitmaps
comment|// for each input
return|return
operator|new
name|MultiJoinRel
argument_list|(
name|multiJoin
operator|.
name|getCluster
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getInputs
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getJoinFilter
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getRowType
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|isFullOuterJoin
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getJoinTypes
argument_list|()
argument_list|,
name|newProjFields
argument_list|,
name|multiJoin
operator|.
name|getJoinFieldRefCountsMap
argument_list|()
argument_list|,
name|multiJoin
operator|.
name|getPostJoinFilter
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|RelNode
parameter_list|>
name|T
name|addTrait
parameter_list|(
name|T
name|rel
parameter_list|,
name|RelTrait
name|trait
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|T
operator|)
name|rel
operator|.
name|copy
argument_list|(
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|plus
argument_list|(
name|trait
argument_list|)
argument_list|,
operator|(
name|List
operator|)
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|private
specifier|static
class|class
name|VariableSetVisitor
extends|extends
name|RelVisitor
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variables
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// implement RelVisitor
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|p
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|super
operator|.
name|visit
argument_list|(
name|p
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|p
operator|.
name|collectVariablesUsed
argument_list|(
name|variables
argument_list|)
expr_stmt|;
comment|// Important! Remove stopped variables AFTER we visit children
comment|// (which what super.visit() does)
name|variables
operator|.
name|removeAll
argument_list|(
name|p
operator|.
name|getVariablesStopped
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
class|class
name|VariableUsedVisitor
extends|extends
name|RexShuttle
block|{
specifier|public
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|variables
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|RexNode
name|visitCorrelVariable
parameter_list|(
name|RexCorrelVariable
name|p
parameter_list|)
block|{
name|variables
operator|.
name|add
argument_list|(
name|p
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|InputReferencedVisitor
extends|extends
name|RexShuttle
block|{
specifier|public
specifier|final
name|SortedSet
argument_list|<
name|Integer
argument_list|>
name|inputPosReferenced
init|=
operator|new
name|TreeSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|inputPosReferenced
operator|.
name|add
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|inputRef
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|TypeDumper
block|{
specifier|private
specifier|final
name|String
name|extraIndent
init|=
literal|"  "
decl_stmt|;
specifier|private
name|String
name|indent
decl_stmt|;
specifier|private
specifier|final
name|PrintWriter
name|pw
decl_stmt|;
name|TypeDumper
parameter_list|(
name|PrintWriter
name|pw
parameter_list|)
block|{
name|this
operator|.
name|pw
operator|=
name|pw
expr_stmt|;
name|this
operator|.
name|indent
operator|=
literal|""
expr_stmt|;
block|}
name|void
name|accept
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
specifier|final
name|RelDataTypeField
index|[]
name|fields
init|=
name|type
operator|.
name|getFields
argument_list|()
decl_stmt|;
comment|// RECORD (
comment|//   I INTEGER NOT NULL,
comment|//   J VARCHAR(240))
name|pw
operator|.
name|println
argument_list|(
literal|"RECORD ("
argument_list|)
expr_stmt|;
name|String
name|prevIndent
init|=
name|indent
decl_stmt|;
name|this
operator|.
name|indent
operator|=
name|indent
operator|+
name|extraIndent
expr_stmt|;
name|acceptFields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|this
operator|.
name|indent
operator|=
name|prevIndent
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|" NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|type
operator|instanceof
name|MultisetSqlType
condition|)
block|{
comment|// E.g. "INTEGER NOT NULL MULTISET NOT NULL"
name|accept
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" MULTISET"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|pw
operator|.
name|print
argument_list|(
literal|" NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// E.g. "INTEGER" E.g. "VARCHAR(240) CHARACTER SET "ISO-8859-1"
comment|// COLLATE "ISO-8859-1$en_US$primary" NOT NULL"
name|pw
operator|.
name|print
argument_list|(
name|type
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|acceptFields
parameter_list|(
specifier|final
name|RelDataTypeField
index|[]
name|fields
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pw
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|pw
operator|.
name|print
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pw
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|accept
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Visitor which builds a bitmap of the inputs used by an expression.      */
specifier|public
specifier|static
class|class
name|InputFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|BitSet
name|rexRefSet
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
decl_stmt|;
specifier|public
name|InputFinder
parameter_list|(
name|BitSet
name|rexRefSet
parameter_list|)
block|{
name|this
argument_list|(
name|rexRefSet
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|InputFinder
parameter_list|(
name|BitSet
name|rexRefSet
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|rexRefSet
operator|=
name|rexRefSet
expr_stmt|;
name|this
operator|.
name|extraFields
operator|=
name|extraFields
expr_stmt|;
block|}
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|rexRefSet
operator|.
name|set
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**          * Applies this visitor to an array of expressions and an optional          * single expression.          */
specifier|public
name|void
name|apply
parameter_list|(
name|RexNode
index|[]
name|exprs
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
name|RexProgram
operator|.
name|apply
argument_list|(
name|this
argument_list|,
name|exprs
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|RexBuilder
operator|.
name|GET_OPERATOR
condition|)
block|{
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
index|[
literal|1
index|]
decl_stmt|;
name|extraFields
operator|.
name|add
argument_list|(
operator|new
name|RelDataTypeFieldImpl
argument_list|(
operator|(
name|String
operator|)
name|literal
operator|.
name|getValue2
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/**      * Walks an expression tree, converting the index of RexInputRefs based on      * some adjustment factor.      */
specifier|public
specifier|static
class|class
name|RexInputConverter
extends|extends
name|RexShuttle
block|{
specifier|protected
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
specifier|final
name|RelDataTypeField
index|[]
name|srcFields
decl_stmt|;
specifier|protected
specifier|final
name|RelDataTypeField
index|[]
name|destFields
decl_stmt|;
specifier|private
specifier|final
name|RelDataTypeField
index|[]
name|leftDestFields
decl_stmt|;
specifier|private
specifier|final
name|RelDataTypeField
index|[]
name|rightDestFields
decl_stmt|;
specifier|private
specifier|final
name|int
name|nLeftDestFields
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|adjustments
decl_stmt|;
comment|/**          * @param rexBuilder builder for creating new RexInputRefs          * @param srcFields fields where the RexInputRefs originally originated          * from; if null, a new RexInputRef is always created, referencing the          * input from destFields corresponding to its current index value          * @param destFields fields that the new RexInputRefs will be          * referencing; if null, use the type information from the source field          * when creating the new RexInputRef          * @param leftDestFields in the case where the destination is a join,          * these are the fields from the left join input          * @param rightDestFields in the case where the destination is a join,          * these are the fields from the right join input          * @param adjustments the amount to adjust each field by          */
specifier|private
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataTypeField
index|[]
name|srcFields
parameter_list|,
name|RelDataTypeField
index|[]
name|destFields
parameter_list|,
name|RelDataTypeField
index|[]
name|leftDestFields
parameter_list|,
name|RelDataTypeField
index|[]
name|rightDestFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
name|this
operator|.
name|srcFields
operator|=
name|srcFields
expr_stmt|;
name|this
operator|.
name|destFields
operator|=
name|destFields
expr_stmt|;
name|this
operator|.
name|adjustments
operator|=
name|adjustments
expr_stmt|;
name|this
operator|.
name|leftDestFields
operator|=
name|leftDestFields
expr_stmt|;
name|this
operator|.
name|rightDestFields
operator|=
name|rightDestFields
expr_stmt|;
if|if
condition|(
name|leftDestFields
operator|==
literal|null
condition|)
block|{
name|nLeftDestFields
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|destFields
operator|==
literal|null
operator|)
assert|;
name|nLeftDestFields
operator|=
name|leftDestFields
operator|.
name|length
expr_stmt|;
block|}
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataTypeField
index|[]
name|srcFields
parameter_list|,
name|RelDataTypeField
index|[]
name|leftDestFields
parameter_list|,
name|RelDataTypeField
index|[]
name|rightDestFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
literal|null
argument_list|,
name|leftDestFields
argument_list|,
name|rightDestFields
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataTypeField
index|[]
name|srcFields
parameter_list|,
name|RelDataTypeField
index|[]
name|destFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
name|destFields
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexInputConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelDataTypeField
index|[]
name|srcFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
name|this
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|var
parameter_list|)
block|{
name|int
name|srcIndex
init|=
name|var
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|destIndex
init|=
name|srcIndex
operator|+
name|adjustments
index|[
name|srcIndex
index|]
decl_stmt|;
name|RelDataType
name|type
decl_stmt|;
if|if
condition|(
name|destFields
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|destFields
index|[
name|destIndex
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|leftDestFields
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|destIndex
operator|<
name|nLeftDestFields
condition|)
block|{
name|type
operator|=
name|leftDestFields
index|[
name|destIndex
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|rightDestFields
index|[
name|destIndex
operator|-
name|nLeftDestFields
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|srcFields
index|[
name|srcIndex
index|]
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|adjustments
index|[
name|srcIndex
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|srcFields
operator|==
literal|null
operator|)
operator|||
operator|(
name|type
operator|!=
name|srcFields
index|[
name|srcIndex
index|]
operator|.
name|getType
argument_list|()
operator|)
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|type
argument_list|,
name|destIndex
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|var
return|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelOptUtil.java
end_comment

end_unit

