begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|mongodb
package|;
end_package

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|trace
operator|.
name|EigenbaseTrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/**  * Rules and relational operators for  * {@link MongoRel#CONVENTION MONGO}  * calling convention.  */
end_comment

begin_class
specifier|public
class|class
name|MongoRules
block|{
specifier|protected
specifier|static
specifier|final
name|Logger
name|tracer
init|=
name|EigenbaseTrace
operator|.
name|getPlannerTracer
argument_list|()
decl_stmt|;
specifier|public
specifier|static
name|RelOptRule
index|[]
name|RULES
init|=
block|{
operator|new
name|PushProjectOntoMongoRule
argument_list|()
block|,   }
decl_stmt|;
specifier|private
specifier|static
class|class
name|PushProjectOntoMongoRule
extends|extends
name|RelOptRule
block|{
specifier|private
name|PushProjectOntoMongoRule
parameter_list|()
block|{
name|super
argument_list|(
name|some
argument_list|(
name|ProjectRel
operator|.
name|class
argument_list|,
name|leaf
argument_list|(
name|MongoTableScan
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|ProjectRel
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|MongoTableScan
name|table
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|table
operator|.
name|ops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|RelOptCluster
name|cluster
init|=
name|table
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|ItemFinder
name|itemFinder
init|=
operator|new
name|ItemFinder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newProjects
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|project
operator|.
name|getProjectExps
argument_list|()
control|)
block|{
specifier|final
name|RexNode
name|rex2
init|=
name|rex
operator|.
name|accept
argument_list|(
name|itemFinder
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|rex3
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|ensureType
argument_list|(
name|rex
operator|.
name|getType
argument_list|()
argument_list|,
name|rex2
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|rex3
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"map="
operator|+
name|itemFinder
operator|.
name|map
operator|+
literal|"\n projects="
operator|+
name|newProjects
operator|+
literal|"\n items="
operator|+
name|itemFinder
operator|.
name|items
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|ops
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|(
name|table
operator|.
name|ops
argument_list|)
decl_stmt|;
specifier|final
name|String
name|findString
init|=
name|Util
operator|.
name|toString
argument_list|(
name|itemFinder
operator|.
name|items
argument_list|,
literal|"{"
argument_list|,
literal|", "
argument_list|,
literal|"}"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|aggregateString
init|=
literal|"{$project ...}"
decl_stmt|;
name|ops
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|findString
argument_list|,
name|aggregateString
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|itemFinder
operator|.
name|builder
argument_list|)
decl_stmt|;
specifier|final
name|MongoTableScan
name|newTable
init|=
operator|new
name|MongoTableScan
argument_list|(
name|cluster
argument_list|,
name|table
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|table
operator|.
name|getTable
argument_list|()
argument_list|,
name|table
operator|.
name|mongoTable
argument_list|,
name|rowType
argument_list|,
name|ops
argument_list|)
decl_stmt|;
specifier|final
name|ProjectRel
name|newProject
init|=
operator|new
name|ProjectRel
argument_list|(
name|cluster
argument_list|,
name|newTable
argument_list|,
name|newProjects
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
argument_list|,
name|ProjectRel
operator|.
name|Flags
operator|.
name|Boxed
argument_list|,
name|Collections
operator|.
expr|<
name|RelCollation
operator|>
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProject
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|String
name|parseFieldAccess
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
name|rex
operator|instanceof
name|RexCall
condition|)
block|{
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|itemOp
operator|&&
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|&&
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|&&
operator|(
operator|(
name|RexInputRef
operator|)
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
operator|==
literal|0
operator|&&
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexLiteral
condition|)
block|{
name|RexLiteral
name|arg
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
condition|)
block|{
return|return
operator|(
name|String
operator|)
name|arg
operator|.
name|getValue2
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|RelDataType
name|parseCast
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
name|rex
operator|instanceof
name|RexCall
condition|)
block|{
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|castFunc
condition|)
block|{
assert|assert
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|call
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// Not currently used. Keep it around for a while. It may evolve into
comment|// something that can handle complex expressions.
specifier|private
specifier|static
class|class
name|ItemFinder
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RexInputRef
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|RexInputRef
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|RelDataTypeFactory
operator|.
name|FieldInfoBuilder
name|builder
init|=
operator|new
name|RelDataTypeFactory
operator|.
name|FieldInfoBuilder
argument_list|()
decl_stmt|;
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|items
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|String
name|fieldName
init|=
name|parseFieldAccess
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldName
operator|!=
literal|null
condition|)
block|{
return|return
name|registerField
argument_list|(
name|fieldName
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|RelDataType
name|type
init|=
name|parseCast
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RexNode
name|operand
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fieldName
operator|=
name|parseFieldAccess
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldName
operator|!=
literal|null
condition|)
block|{
return|return
name|registerField
argument_list|(
name|fieldName
argument_list|,
name|call
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|// just ignore the cast
return|return
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|registerField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
name|RexInputRef
name|x
init|=
name|map
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|null
condition|)
block|{
name|x
operator|=
operator|new
name|RexInputRef
argument_list|(
name|map
operator|.
name|size
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|fieldName
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|items
operator|.
name|add
argument_list|(
name|fieldName
operator|+
literal|": 1"
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
block|}
comment|/*   static abstract class MongoConverterRule extends ConverterRule {     protected final MongoConvention out;      public MongoConverterRule(         Class<? extends RelNode> clazz,         RelTrait in,         MongoConvention out,         String description) {       super(clazz, in, out, description);       this.out = out;     }   }    private static class MongoJoinRule extends MongoConverterRule {     private MongoJoinRule(MongoConvention out) {       super(           JoinRel.class,           Convention.NONE,           out,           "MongoJoinRule");     }      @Override     public RelNode convert(RelNode rel) {       JoinRel join = (JoinRel) rel;       List<RelNode> newInputs = new ArrayList<RelNode>();       for (RelNode input : join.getInputs()) {         if (!(input.getConvention() == getOutTrait())) {           input =               convert(                   input,                   input.getTraitSet()                       .replace(out));         }         newInputs.add(input);       }       try {         return new MongoJoinRel(             join.getCluster(),             join.getTraitSet().replace(out),             newInputs.get(0),             newInputs.get(1),             join.getCondition(),             join.getJoinType(),             join.getVariablesStopped());       } catch (InvalidRelException e) {         tracer.warning(e.toString());         return null;       }     }   }    public static class MongoJoinRel       extends JoinRelBase       implements MongoRel {     final ImmutableIntList leftKeys;     final ImmutableIntList rightKeys;      protected MongoJoinRel(         RelOptCluster cluster,         RelTraitSet traits,         RelNode left,         RelNode right,         RexNode condition,         JoinRelType joinType,         Set<String> variablesStopped)         throws InvalidRelException {       super(           cluster, traits, left, right, condition, joinType,           variablesStopped);       final List<Integer> leftKeys = new ArrayList<Integer>();       final List<Integer> rightKeys = new ArrayList<Integer>();       RexNode remaining =           RelOptUtil.splitJoinCondition(               left, right, condition, leftKeys, rightKeys);       if (!remaining.isAlwaysTrue()) {         throw new InvalidRelException(             "MongoJoinRel only supports equi-join");       }       this.leftKeys = ImmutableIntList.of(leftKeys);       this.rightKeys = ImmutableIntList.of(rightKeys);     }      @Override     public MongoJoinRel copy(         RelTraitSet traitSet,         RexNode conditionExpr,         RelNode left,         RelNode right) {       try {         return new MongoJoinRel(             getCluster(),             traitSet,             left,             right,             conditionExpr,             joinType,             variablesStopped);       } catch (InvalidRelException e) {         // Semantic error not possible. Must be a bug. Convert to         // internal error.         throw new AssertionError(e);       }     }      @Override     public RelOptCost computeSelfCost(RelOptPlanner planner) {       // We always "build" the       double rowCount = RelMetadataQuery.getRowCount(this);        return planner.makeCost(rowCount, 0, 0);     }      @Override     public double getRows() {       final boolean leftKey = left.isKey(Util.bitSetOf(leftKeys));       final boolean rightKey = right.isKey(Util.bitSetOf(rightKeys));       final double leftRowCount = left.getRows();       final double rightRowCount = right.getRows();       if (leftKey&& rightKey) {         return Math.min(leftRowCount, rightRowCount);       }       if (leftKey) {         return rightRowCount;       }       if (rightKey) {         return leftRowCount;       }       return leftRowCount * rightRowCount;     }      public SqlString implement(MongoImplementor implementor) {       final SqlBuilder buf = new SqlBuilder(implementor.dialect);       buf.append("SELECT ");       int i = 0;       List<String> fields = getRowType().getFieldNames();       for (Ord<RelNode> input : Ord.zip(getInputs())) {         String t = "t" + input.i;         final List<String> inFields =             input.e.getRowType().getFieldNames();         for (String inField : inFields) {           buf.append(i> 0 ? ", " : "");           buf.identifier(t, inField);           alias(buf, inField, fields.get(i));           i++;         }       }       buf.append(" FROM ");       for (Ord<RelNode> input : Ord.zip(getInputs())) {         if (input.i> 0) {           implementor.newline(buf)               .append("JOIN ");         }         implementor.subquery(buf, input.i, input.e, "t" + input.i);       }       final List<String> leftFields =           getInput(0).getRowType().getFieldNames();       final List<String> rightFields =           getInput(1).getRowType().getFieldNames();       for (Ord<Pair<Integer, Integer>> pair           : Ord.zip(Pair.zip(leftKeys, rightKeys))) {         implementor.newline(buf)             .append(pair.i == 0 ? "ON " : "AND ")             .identifier("t0", leftFields.get(pair.e.left))             .append(" = ")             .identifier("t1", rightFields.get(pair.e.right));       }       return buf.toSqlString();     }   }    /**    * Rule to convert a {@link CalcRel} to an    * {@link MongoCalcRel}.    o/   private static class MongoCalcRule       extends MongoConverterRule {     private MongoCalcRule(MongoConvention out) {       super(           CalcRel.class,           Convention.NONE,           out,           "MongoCalcRule");     }      public RelNode convert(RelNode rel) {       final CalcRel calc = (CalcRel) rel;        // If there's a multiset, let FarragoMultisetSplitter work on it       // first.       if (RexMultisetUtil.containsMultiset(calc.getProgram())) {         return null;       }        return new MongoCalcRel(           rel.getCluster(),           rel.getTraitSet().replace(out),           convert(               calc.getChild(),               calc.getTraitSet().replace(out)),           calc.getProgram(),           ProjectRelBase.Flags.Boxed);     }   }    public static class MongoCalcRel extends SingleRel implements MongoRel {     private final RexProgram program;      /**      * Values defined in {@link org.eigenbase.rel.ProjectRelBase.Flags}.      o/     protected int flags;      public MongoCalcRel(         RelOptCluster cluster,         RelTraitSet traitSet,         RelNode child,         RexProgram program,         int flags) {       super(cluster, traitSet, child);       assert getConvention() instanceof MongoConvention;       this.flags = flags;       this.program = program;       this.rowType = program.getOutputRowType();     }      public RelOptPlanWriter explainTerms(RelOptPlanWriter pw) {       return program.explainCalc(super.explainTerms(pw));     }      public double getRows() {       return FilterRel.estimateFilteredRows(           getChild(), program);     }      public RelOptCost computeSelfCost(RelOptPlanner planner) {       double dRows = RelMetadataQuery.getRowCount(this);       double dCpu =           RelMetadataQuery.getRowCount(getChild())               * program.getExprCount();       double dIo = 0;       return planner.makeCost(dRows, dCpu, dIo);     }      public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {       return new MongoCalcRel(           getCluster(),           traitSet,           sole(inputs),           program.copy(),           getFlags());     }      public int getFlags() {       return flags;     }      public RexProgram getProgram() {       return program;     }      public SqlString implement(MongoImplementor implementor) {       final SqlBuilder buf = new SqlBuilder(implementor.dialect);       buf.append("SELECT ");       if (isStar(program)) {         buf.append("*");       } else {         for (Ord<RexLocalRef> ref : Ord.zip(program.getProjectList())) {           buf.append(ref.i == 0 ? "" : ", ");           expr(buf, program, ref.e);           alias(buf, null, getRowType().getFieldNames().get(ref.i));         }       }       implementor.newline(buf)           .append("FROM ");       implementor.subquery(buf, 0, getChild(), "t");       if (program.getCondition() != null) {         implementor.newline(buf);         buf.append("WHERE ");         expr(buf, program, program.getCondition());       }       return buf.toSqlString();     }      private static boolean isStar(RexProgram program) {       int i = 0;       for (RexLocalRef ref : program.getProjectList()) {         if (ref.getIndex() != i++) {           return false;         }       }       return i == program.getInputRowType().getFieldCount();     }      private static void expr(         SqlBuilder buf, RexProgram program, RexNode rex) {       if (rex instanceof RexLocalRef) {         final int index = ((RexLocalRef) rex).getIndex();         expr(buf, program, program.getExprList().get(index));       } else if (rex instanceof RexInputRef) {         buf.identifier(             program.getInputRowType().getFieldNames().get(                 ((RexInputRef) rex).getIndex()));       } else if (rex instanceof RexLiteral) {         toSql(buf, (RexLiteral) rex);       } else if (rex instanceof RexCall) {         final RexCall call = (RexCall) rex;         switch (call.getOperator().getSyntax()) {         case Binary:           expr(buf, program, call.getOperandList().get(0));           buf.append(' ')               .append(call.getOperator().toString())               .append(' ');           expr(buf, program, call.getOperandList().get(1));           break;         default:           throw new AssertionError(call.getOperator());         }       } else {         throw new AssertionError(rex);       }     }   }    private static SqlBuilder toSql(SqlBuilder buf, RexLiteral rex) {     switch (rex.getTypeName()) {     case CHAR:     case VARCHAR:       return buf.append(           new NlsString(rex.getValue2().toString(), null, null)               .asSql(false, false));     default:       return buf.append(rex.getValue2().toString());     }   }    /**    * Rule to convert an {@link org.eigenbase.rel.AggregateRel} to an    * {@link MongoAggregateRel}.    o/   private static class MongoAggregateRule extends MongoConverterRule {     private MongoAggregateRule(MongoConvention out) {       super(           AggregateRel.class,           Convention.NONE,           out,           "MongoAggregateRule");     }      public RelNode convert(RelNode rel) {       final AggregateRel agg = (AggregateRel) rel;       final RelTraitSet traitSet =           agg.getTraitSet().replace(out);       try {         return new MongoAggregateRel(             rel.getCluster(),             traitSet,             convert(agg.getChild(), traitSet),             agg.getGroupSet(),             agg.getAggCallList());       } catch (InvalidRelException e) {         tracer.warning(e.toString());         return null;       }     }   }    public static class MongoAggregateRel       extends AggregateRelBase       implements MongoRel {     public MongoAggregateRel(         RelOptCluster cluster,         RelTraitSet traitSet,         RelNode child,         BitSet groupSet,         List<AggregateCall> aggCalls)         throws InvalidRelException {       super(cluster, traitSet, child, groupSet, aggCalls);       assert getConvention() instanceof MongoConvention;        for (AggregateCall aggCall : aggCalls) {         if (aggCall.isDistinct()) {           throw new InvalidRelException(               "distinct aggregation not supported");         }       }     }      @Override     public MongoAggregateRel copy(         RelTraitSet traitSet, List<RelNode> inputs) {       try {         return new MongoAggregateRel(             getCluster(),             traitSet,             sole(inputs),             groupSet,             aggCalls);       } catch (InvalidRelException e) {         // Semantic error not possible. Must be a bug. Convert to         // internal error.         throw new AssertionError(e);       }     }      public SqlString implement(MongoImplementor implementor) {       // "select a, b, sum(x) from ( ... ) group by a, b"       final SqlBuilder buf = new SqlBuilder(implementor.dialect);       final List<String> inFields =           getChild().getRowType().getFieldNames();       final List<String> fields = getRowType().getFieldNames();       buf.append("SELECT ");       int i = 0;       for (int group : Util.toIter(groupSet)) {         buf.append(i> 0 ? ", " : "");         final String inField = inFields.get(group);         buf.identifier(inField);         alias(buf, inField, fields.get(i));         i++;       }       for (AggregateCall aggCall : aggCalls) {         buf.append(i> 0 ? ", " : "");         buf.append(aggCall.getAggregation().getName());         buf.append("(");         if (aggCall.getArgList().isEmpty()) {           buf.append("*");         } else {           for (Ord<Integer> call : Ord.zip(aggCall.getArgList())) {             buf.append(call.i> 0 ? ", " : "");             buf.append(inFields.get(call.e));           }         }         buf.append(")");         alias(buf, null, fields.get(i));         i++;       }       implementor.newline(buf)           .append(" FROM ");       implementor.subquery(buf, 0, getChild(), "t");       if (!groupSet.isEmpty()) {         implementor.newline(buf)             .append("GROUP BY ");         i = 0;         for (int group : Util.toIter(groupSet)) {           buf.append(i> 0 ? ", " : "");           final String inField = inFields.get(group);           buf.identifier(inField);           i++;         }       }       return buf.toSqlString();     }   }    /**    * Rule to convert an {@link org.eigenbase.rel.SortRel} to an    * {@link MongoSortRel}.    o/   private static class MongoSortRule       extends MongoConverterRule {     private MongoSortRule(MongoConvention out) {       super(           SortRel.class,           Convention.NONE,           out,           "MongoSortRule");     }      public RelNode convert(RelNode rel) {       final SortRel sort = (SortRel) rel;       final RelTraitSet traitSet =           sort.getTraitSet().replace(out);       return new MongoSortRel(           rel.getCluster(),           traitSet,           convert(sort.getChild(), traitSet),           sort.getCollations());     }   }    public static class MongoSortRel       extends SortRel       implements MongoRel {     public MongoSortRel(         RelOptCluster cluster,         RelTraitSet traitSet,         RelNode child,         List<RelFieldCollation> collations) {       super(cluster, traitSet, child, collations);       assert getConvention() instanceof MongoConvention;       assert getConvention() == child.getConvention();     }      @Override     public MongoSortRel copy(         RelTraitSet traitSet,         RelNode newInput,         List<RelFieldCollation> newCollations) {       return new MongoSortRel(           getCluster(),           traitSet,           newInput,           newCollations);     }      public SqlString implement(MongoImplementor implementor) {       throw new AssertionError(); // TODO:     }   }    /**    * Rule to convert an {@link org.eigenbase.rel.UnionRel} to a    * {@link MongoUnionRel}.    o/   private static class MongoUnionRule       extends MongoConverterRule {     private MongoUnionRule(MongoConvention out) {       super(           UnionRel.class,           Convention.NONE,           out,           "MongoUnionRule");     }      public RelNode convert(RelNode rel) {       final UnionRel union = (UnionRel) rel;       final RelTraitSet traitSet =           union.getTraitSet().replace(out);       return new MongoUnionRel(           rel.getCluster(),           traitSet,           convertList(union.getInputs(), traitSet),           union.all);     }   }    public static class MongoUnionRel       extends UnionRelBase       implements MongoRel {     public MongoUnionRel(         RelOptCluster cluster,         RelTraitSet traitSet,         List<RelNode> inputs,         boolean all) {       super(cluster, traitSet, inputs, all);     }      public MongoUnionRel copy(         RelTraitSet traitSet, List<RelNode> inputs, boolean all) {       return new MongoUnionRel(getCluster(), traitSet, inputs, all);     }      @Override     public RelOptCost computeSelfCost(RelOptPlanner planner) {       return super.computeSelfCost(planner).multiplyBy(.1);     }      public SqlString implement(MongoImplementor implementor) {       return setOpSql(this, implementor, "UNION");     }   }    private static SqlString setOpSql(       SetOpRel setOpRel, MongoImplementor implementor, String op) {     final SqlBuilder buf = new SqlBuilder(implementor.dialect);     for (Ord<RelNode> input : Ord.zip(setOpRel.getInputs())) {       if (input.i> 0) {         implementor.newline(buf)             .append(op + (setOpRel.all ? " ALL " : ""));         implementor.newline(buf);       }       buf.append(implementor.visitChild(input.i, input.e));     }     return buf.toSqlString();   }    /**    * Rule to convert an {@link org.eigenbase.rel.IntersectRel} to an    * {@link MongoIntersectRel}.    o/   private static class MongoIntersectRule       extends MongoConverterRule {     private MongoIntersectRule(MongoConvention out) {       super(           IntersectRel.class,           Convention.NONE,           out,           "MongoIntersectRule");     }      public RelNode convert(RelNode rel) {       final IntersectRel intersect = (IntersectRel) rel;       if (intersect.all) {         return null; // INTERSECT ALL not implemented       }       final RelTraitSet traitSet =           intersect.getTraitSet().replace(out);       return new MongoIntersectRel(           rel.getCluster(),           traitSet,           convertList(intersect.getInputs(), traitSet),           intersect.all);     }   }    public static class MongoIntersectRel       extends IntersectRelBase       implements MongoRel {     public MongoIntersectRel(         RelOptCluster cluster,         RelTraitSet traitSet,         List<RelNode> inputs,         boolean all) {       super(cluster, traitSet, inputs, all);       assert !all;     }      public MongoIntersectRel copy(         RelTraitSet traitSet, List<RelNode> inputs, boolean all) {       return new MongoIntersectRel(getCluster(), traitSet, inputs, all);     }      public SqlString implement(MongoImplementor implementor) {       return setOpSql(this, implementor, " intersect ");     }   }    /**    * Rule to convert an {@link org.eigenbase.rel.MinusRel} to an    * {@link MongoMinusRel}.    o/   private static class MongoMinusRule       extends MongoConverterRule {     private MongoMinusRule(MongoConvention out) {       super(           MinusRel.class,           Convention.NONE,           out,           "MongoMinusRule");     }      public RelNode convert(RelNode rel) {       final MinusRel minus = (MinusRel) rel;       if (minus.all) {         return null; // EXCEPT ALL not implemented       }       final RelTraitSet traitSet =           rel.getTraitSet().replace(out);       return new MongoMinusRel(           rel.getCluster(),           traitSet,           convertList(minus.getInputs(), traitSet),           minus.all);     }   }    public static class MongoMinusRel       extends MinusRelBase       implements MongoRel {     public MongoMinusRel(         RelOptCluster cluster,         RelTraitSet traitSet,         List<RelNode> inputs,         boolean all) {       super(cluster, traitSet, inputs, all);       assert !all;     }      public MongoMinusRel copy(         RelTraitSet traitSet, List<RelNode> inputs, boolean all) {       return new MongoMinusRel(getCluster(), traitSet, inputs, all);     }      public SqlString implement(MongoImplementor implementor) {       return setOpSql(this, implementor, " minus ");     }   }    public static class MongoTableModificationRule extends MongoConverterRule {     private MongoTableModificationRule(MongoConvention out) {       super(           TableModificationRel.class,           Convention.NONE,           out,           "MongoTableModificationRule");     }      @Override     public RelNode convert(RelNode rel) {       final TableModificationRel modify =           (TableModificationRel) rel;       final ModifiableTable modifiableTable =           modify.getTable().unwrap(ModifiableTable.class);       if (modifiableTable == null           || modifiableTable.getExpression() == null) {         return null;       }       final RelTraitSet traitSet =           modify.getTraitSet().replace(out);       return new MongoTableModificationRel(           modify.getCluster(), traitSet,           modify.getTable(),           modify.getCatalogReader(),           convert(modify.getChild(), traitSet),           modify.getOperation(),           modify.getUpdateColumnList(),           modify.isFlattened());     }   }    public static class MongoTableModificationRel       extends TableModificationRelBase       implements MongoRel {     private final Expression expression;      public MongoTableModificationRel(         RelOptCluster cluster,         RelTraitSet traits,         RelOptTable table,         Prepare.CatalogReader catalogReader,         RelNode child,         Operation operation,         List<String> updateColumnList,         boolean flattened) {       super(           cluster, traits, table, catalogReader, child, operation,           updateColumnList, flattened);       assert child.getConvention() instanceof MongoConvention;       assert getConvention() instanceof MongoConvention;       final ModifiableTable modifiableTable =           table.unwrap(ModifiableTable.class);       if (modifiableTable == null) {         throw new AssertionError(); // TODO: user error in validator       }       this.expression = modifiableTable.getExpression();       if (expression == null) {         throw new AssertionError(); // TODO: user error in validator       }     }      @Override     public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {       return new MongoTableModificationRel(           getCluster(), traitSet, getTable(), getCatalogReader(),           sole(inputs), getOperation(), getUpdateColumnList(),           isFlattened());     }      public SqlString implement(MongoImplementor implementor) {       throw new AssertionError(); // TODO:     }   }    public static class MongoValuesRule extends MongoConverterRule {     private MongoValuesRule(MongoConvention out) {       super(           ValuesRel.class,           Convention.NONE,           out,           "MongoValuesRule");     }      @Override     public RelNode convert(RelNode rel) {       ValuesRel valuesRel = (ValuesRel) rel;       return new MongoValuesRel(           valuesRel.getCluster(),           valuesRel.getRowType(),           valuesRel.getTuples(),           valuesRel.getTraitSet().plus(out));     }   }    public static class MongoValuesRel       extends ValuesRelBase       implements MongoRel {     MongoValuesRel(         RelOptCluster cluster,         RelDataType rowType,         List<List<RexLiteral>> tuples,         RelTraitSet traitSet) {       super(cluster, rowType, tuples, traitSet);     }      @Override     public RelNode copy(         RelTraitSet traitSet, List<RelNode> inputs) {       assert inputs.isEmpty();       return new MongoValuesRel(           getCluster(), rowType, tuples, traitSet);     }      public SqlString implement(MongoImplementor implementor) {       throw new AssertionError(); // TODO:     }   } */
block|}
end_class

begin_comment
comment|// End MongoRules.java
end_comment

end_unit

