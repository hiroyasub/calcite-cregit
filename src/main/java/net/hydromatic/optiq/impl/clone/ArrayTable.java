begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|clone
package|;
end_package

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|expressions
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|expressions
operator|.
name|Primitive
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelRecordType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Implementation of table that reads rows from column stores, one per column.  * Column store formats are chosen based on the type and distribution of the  * values in the column; see {@link Representation} and  * {@link RepresentationType}.  */
end_comment

begin_class
class|class
name|ArrayTable
parameter_list|<
name|T
parameter_list|>
extends|extends
name|BaseQueryable
argument_list|<
name|T
argument_list|>
implements|implements
name|Table
argument_list|<
name|T
argument_list|>
block|{
specifier|private
specifier|final
name|Schema
name|schema
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|Representation
argument_list|,
name|Object
argument_list|>
argument_list|>
name|pairs
decl_stmt|;
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
comment|/** Creates an ArrayTable. */
specifier|public
name|ArrayTable
parameter_list|(
name|Schema
name|schema
parameter_list|,
name|Type
name|elementType
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|Representation
argument_list|,
name|Object
argument_list|>
argument_list|>
name|pairs
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|schema
operator|.
name|getQueryProvider
argument_list|()
argument_list|,
name|elementType
argument_list|,
name|expression
argument_list|)
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|pairs
operator|=
name|pairs
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
assert|assert
operator|(
operator|(
name|RelRecordType
operator|)
name|elementType
operator|)
operator|.
name|getRecordFields
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|pairs
operator|.
name|size
argument_list|()
assert|;
block|}
specifier|public
name|DataContext
name|getDataContext
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|Enumerator
argument_list|<
name|T
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|()
block|{
specifier|final
name|int
name|rowCount
init|=
name|size
decl_stmt|;
specifier|final
name|int
name|columnCount
init|=
name|pairs
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|Object
index|[]
name|current
parameter_list|()
block|{
name|Object
index|[]
name|objects
init|=
operator|new
name|Object
index|[
name|columnCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|objects
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Pair
argument_list|<
name|Representation
argument_list|,
name|Object
argument_list|>
name|pair
init|=
name|pairs
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|objects
index|[
name|j
index|]
operator|=
name|pair
operator|.
name|left
operator|.
name|getObject
argument_list|(
name|pair
operator|.
name|right
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|objects
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
operator|(
operator|++
name|i
operator|<
name|rowCount
operator|)
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|;
block|}
enum|enum
name|RepresentationType
block|{
comment|/** Object array. Null values are represented by null. Values may or may          * not be canonized; if canonized, = and != can be implemented using          * pointer.          *          * @see ObjectArray          */
name|OBJECT_ARRAY
block|,
comment|/**          * Array of primitives. Null values not possible. Only for primitive          * types (and not optimal for boolean).          *          * @see PrimitiveArray          */
name|PRIMITIVE_ARRAY
block|,
comment|/** Bit-sliced primitive array. Values are {@code bitCount} bits each,          * and interpreted as signed. Stored as an array of long values.          *          *<p>If gcd(bitCount, 64) != 0, some values will cross boundaries.          * bits each. But for all of those values except 4, there is a primitive          * type (8 byte, 16 short, 32 int) which is more efficient.          *          * @see BitSlicedPrimitiveArray          */
name|BIT_SLICED_PRIMITIVE_ARRAY
block|,
comment|/**          * Dictionary of primitives. Use one of the previous methods to store          * unsigned offsets into the dictionary. Dictionary is canonized and          * sorted, so v1&lt; v2 if and only if code(v1)&lt; code(v2). The          * dictionary may or may not contain a null value.          *          *<p>The dictionary is not beneficial unless the codes are          * significantly shorter than the values. A column of {@code long}          * values with many duplicates is a win; a column of mostly distinct          * {@code short} values is likely a loss. The other win is if there are          * null values; otherwise the best option would be an          * {@link #OBJECT_ARRAY}.</p>          *          * @see PrimitiveDictionary          */
name|PRIMITIVE_DICTIONARY
block|,
comment|/**          * Dictionary of objects. Use one of the previous methods to store          * unsigned offsets into the dictionary.          *          * @see ObjectDictionary          */
name|OBJECT_DICTIONARY
block|,
comment|/**          * Compressed string table. Block of char data. Strings represented          * using an unsigned offset into the table (stored using one of the          * previous methods).          *          *<p>First 2 bytes are unsigned length; subsequent bytes are string          * contents. The null value, strings longer than 64k and strings that          * occur very commonly are held in an 'exceptions' array and are          * recognized by their high offsets. Other strings are created on demand          * (this reduces the number of objects that need to be created during          * deserialization from cache.</p>          *          * @see StringDictionary          */
name|STRING_DICTIONARY
block|,
comment|/**          * Compressed byte array table. Similar to compressed string table.          *          * @see ByteStringDictionary          */
name|BYTE_STRING_DICTIONARY
block|,     }
specifier|public
interface|interface
name|Representation
block|{
name|RepresentationType
name|getType
parameter_list|()
function_decl|;
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|)
function_decl|;
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
function_decl|;
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
function_decl|;
block|}
specifier|public
specifier|static
class|class
name|ObjectArray
implements|implements
name|Representation
block|{
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|public
name|ObjectArray
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|OBJECT_ARRAY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|)
block|{
comment|// We assume:
comment|// 1. The array does not need to be copied.
comment|// 2. The values have been canonized.
return|return
name|valueSet
operator|.
name|values
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|(
operator|(
name|List
operator|)
name|dataSet
operator|)
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|getObject
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|PrimitiveArray
implements|implements
name|Representation
block|{
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|private
specifier|final
name|Primitive
name|primitive
decl_stmt|;
specifier|private
specifier|final
name|Primitive
name|p
decl_stmt|;
specifier|public
name|PrimitiveArray
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|Primitive
name|primitive
parameter_list|,
name|Primitive
name|p
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|primitive
operator|=
name|primitive
expr_stmt|;
name|this
operator|.
name|p
operator|=
name|p
expr_stmt|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|PRIMITIVE_ARRAY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
specifier|final
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|primitive
operator|.
name|toArray2
argument_list|(
operator|(
name|List
operator|)
name|valueSet
operator|.
name|values
argument_list|)
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|DOUBLE
case|:
return|return
name|Array
operator|.
name|getDouble
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|FLOAT
case|:
return|return
name|Array
operator|.
name|getFloat
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|BOOLEAN
case|:
return|return
name|Array
operator|.
name|getBoolean
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|BYTE
case|:
return|return
name|Array
operator|.
name|getByte
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|CHARACTER
case|:
return|return
name|Array
operator|.
name|getChar
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|SHORT
case|:
return|return
name|Array
operator|.
name|getShort
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|INT
case|:
return|return
name|Array
operator|.
name|getInt
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
case|case
name|LONG
case|:
return|return
name|Array
operator|.
name|getLong
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|Array
operator|.
name|getInt
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|PrimitiveDictionary
implements|implements
name|Representation
block|{
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|PRIMITIVE_DICTIONARY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
block|}
specifier|public
specifier|static
class|class
name|ObjectDictionary
implements|implements
name|Representation
block|{
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|final
name|Representation
name|representation
decl_stmt|;
specifier|public
name|ObjectDictionary
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|Representation
name|representation
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|representation
operator|=
name|representation
expr_stmt|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|OBJECT_DICTIONARY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|)
block|{
specifier|final
name|int
name|n
init|=
name|valueSet
operator|.
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|extra
init|=
name|valueSet
operator|.
name|containsNull
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|Comparable
index|[]
name|codeValues
init|=
name|valueSet
operator|.
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Comparable
index|[
name|n
operator|+
name|extra
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|codeValues
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ColumnLoader
operator|.
name|ValueSet
name|codeValueSet
init|=
operator|new
name|ColumnLoader
operator|.
name|ValueSet
argument_list|(
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|Comparable
name|value
range|:
name|valueSet
operator|.
name|values
control|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|code
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|codeValues
argument_list|,
name|value
argument_list|)
expr_stmt|;
assert|assert
name|code
operator|>=
literal|0
operator|:
name|code
operator|+
literal|", "
operator|+
name|value
assert|;
block|}
name|codeValueSet
operator|.
name|add
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|Object
name|codes
init|=
name|representation
operator|.
name|freeze
argument_list|(
name|codeValueSet
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|codes
argument_list|,
name|codeValues
argument_list|)
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|Pair
argument_list|<
name|Object
argument_list|,
name|Object
index|[]
argument_list|>
name|pair
init|=
operator|(
name|Pair
argument_list|<
name|Object
argument_list|,
name|Object
index|[]
argument_list|>
operator|)
name|dataSet
decl_stmt|;
name|int
name|code
init|=
name|representation
operator|.
name|getInt
argument_list|(
name|pair
operator|.
name|left
argument_list|,
name|ordinal
argument_list|)
decl_stmt|;
return|return
name|pair
operator|.
name|right
index|[
name|code
index|]
return|;
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|getObject
argument_list|(
name|dataSet
argument_list|,
name|ordinal
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|StringDictionary
implements|implements
name|Representation
block|{
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|STRING_DICTIONARY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
block|}
specifier|public
specifier|static
class|class
name|ByteStringDictionary
implements|implements
name|Representation
block|{
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|BYTE_STRING_DICTIONARY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
comment|// TODO:
block|}
block|}
specifier|public
specifier|static
class|class
name|BitSlicedPrimitiveArray
implements|implements
name|Representation
block|{
specifier|final
name|int
name|bitCount
decl_stmt|;
specifier|private
specifier|final
name|Primitive
name|primitive
decl_stmt|;
specifier|private
specifier|final
name|int
name|ordinal
decl_stmt|;
name|BitSlicedPrimitiveArray
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|int
name|bitCount
parameter_list|,
name|Primitive
name|primitive
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|bitCount
operator|=
name|bitCount
expr_stmt|;
name|this
operator|.
name|primitive
operator|=
name|primitive
expr_stmt|;
block|}
specifier|public
name|RepresentationType
name|getType
parameter_list|()
block|{
return|return
name|RepresentationType
operator|.
name|BIT_SLICED_PRIMITIVE_ARRAY
return|;
block|}
specifier|public
name|Object
name|freeze
parameter_list|(
name|ColumnLoader
operator|.
name|ValueSet
name|valueSet
parameter_list|)
block|{
specifier|final
name|int
name|chunksPerWord
init|=
literal|64
operator|/
name|bitCount
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Comparable
argument_list|>
name|valueList
init|=
name|valueSet
operator|.
name|values
decl_stmt|;
specifier|final
name|int
name|valueCount
init|=
name|valueList
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|wordCount
init|=
operator|(
name|valueCount
operator|+
operator|(
name|chunksPerWord
operator|-
literal|1
operator|)
operator|)
operator|/
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|remainingChunkCount
init|=
name|valueCount
operator|%
name|chunksPerWord
decl_stmt|;
specifier|final
name|long
index|[]
name|longs
init|=
operator|new
name|long
index|[
name|wordCount
index|]
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|valueCount
operator|/
name|chunksPerWord
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|valueCount
operator|>
literal|0
operator|&&
name|valueList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|Boolean
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|Boolean
argument_list|>
name|booleans
init|=
operator|(
name|List
operator|)
name|valueSet
operator|.
name|values
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|chunksPerWord
condition|;
name|j
operator|++
control|)
block|{
name|v
operator||=
operator|(
name|booleans
operator|.
name|get
argument_list|(
name|k
operator|++
argument_list|)
condition|?
operator|(
literal|1
operator|<<
operator|(
name|bitCount
operator|*
name|j
operator|)
operator|)
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|longs
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|remainingChunkCount
operator|>
literal|0
condition|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|remainingChunkCount
condition|;
name|j
operator|++
control|)
block|{
name|v
operator||=
operator|(
name|booleans
operator|.
name|get
argument_list|(
name|k
operator|++
argument_list|)
condition|?
operator|(
literal|1
operator|<<
operator|(
name|bitCount
operator|*
name|j
operator|)
operator|)
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|longs
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|Number
argument_list|>
name|numbers
init|=
operator|(
name|List
operator|)
name|valueSet
operator|.
name|values
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|chunksPerWord
condition|;
name|j
operator|++
control|)
block|{
name|v
operator||=
operator|(
name|numbers
operator|.
name|get
argument_list|(
name|k
operator|++
argument_list|)
operator|.
name|longValue
argument_list|()
operator|<<
operator|(
name|bitCount
operator|*
name|j
operator|)
operator|)
expr_stmt|;
block|}
name|longs
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|remainingChunkCount
operator|>
literal|0
condition|)
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|remainingChunkCount
condition|;
name|j
operator|++
control|)
block|{
name|v
operator||=
operator|(
name|numbers
operator|.
name|get
argument_list|(
name|k
operator|++
argument_list|)
operator|.
name|longValue
argument_list|()
operator|<<
operator|(
name|bitCount
operator|*
name|j
operator|)
operator|)
expr_stmt|;
block|}
name|longs
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
return|return
name|longs
return|;
block|}
specifier|public
name|Object
name|getObject
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|long
index|[]
name|longs
init|=
operator|(
name|long
index|[]
operator|)
name|dataSet
decl_stmt|;
specifier|final
name|int
name|chunksPerWord
init|=
literal|64
operator|/
name|bitCount
decl_stmt|;
specifier|final
name|int
name|word
init|=
name|ordinal
operator|/
name|chunksPerWord
decl_stmt|;
specifier|final
name|long
name|v
init|=
name|longs
index|[
name|word
index|]
decl_stmt|;
specifier|final
name|int
name|chunk
init|=
name|ordinal
operator|%
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|bitCount
operator|)
operator|-
literal|1
decl_stmt|;
specifier|final
name|long
name|x
init|=
operator|(
name|v
operator|>>
operator|(
name|chunk
operator|*
name|bitCount
operator|)
operator|)
operator|&
name|mask
decl_stmt|;
switch|switch
condition|(
name|primitive
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
name|x
operator|!=
literal|0
return|;
case|case
name|BYTE
case|:
return|return
operator|(
name|byte
operator|)
name|x
return|;
case|case
name|CHARACTER
case|:
return|return
operator|(
name|char
operator|)
name|x
return|;
case|case
name|SHORT
case|:
return|return
operator|(
name|short
operator|)
name|x
return|;
case|case
name|INT
case|:
return|return
operator|(
name|int
operator|)
name|x
return|;
case|case
name|LONG
case|:
return|return
name|x
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|primitive
operator|+
literal|" unexpected"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|getInt
parameter_list|(
name|Object
name|dataSet
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|long
index|[]
name|longs
init|=
operator|(
name|long
index|[]
operator|)
name|dataSet
decl_stmt|;
specifier|final
name|int
name|chunksPerWord
init|=
literal|64
operator|/
name|bitCount
decl_stmt|;
specifier|final
name|int
name|word
init|=
name|ordinal
operator|/
name|chunksPerWord
decl_stmt|;
specifier|final
name|long
name|v
init|=
name|longs
index|[
name|word
index|]
decl_stmt|;
specifier|final
name|int
name|chunk
init|=
name|ordinal
operator|%
name|chunksPerWord
decl_stmt|;
specifier|final
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|bitCount
operator|)
operator|-
literal|1
decl_stmt|;
specifier|final
name|long
name|x
init|=
operator|(
name|v
operator|>>
operator|(
name|chunk
operator|*
name|bitCount
operator|)
operator|)
operator|&
name|mask
decl_stmt|;
return|return
operator|(
name|int
operator|)
name|x
return|;
block|}
specifier|public
specifier|static
name|long
name|getLong
parameter_list|(
name|int
name|bitCount
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|getLong
argument_list|(
name|bitCount
argument_list|,
literal|64
operator|/
name|bitCount
argument_list|,
operator|(
literal|1L
operator|<<
name|bitCount
operator|)
operator|-
literal|1L
argument_list|,
name|values
argument_list|,
name|ordinal
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|getLong
parameter_list|(
name|int
name|bitCount
parameter_list|,
name|int
name|chunksPerWord
parameter_list|,
name|long
name|mask
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
name|int
name|word
init|=
name|ordinal
operator|/
name|chunksPerWord
decl_stmt|;
name|int
name|chunk
init|=
name|ordinal
operator|%
name|chunksPerWord
decl_stmt|;
name|long
name|value
init|=
name|values
index|[
name|word
index|]
decl_stmt|;
return|return
operator|(
name|value
operator|>>
operator|(
name|chunk
operator|*
name|bitCount
operator|)
operator|)
operator|&
name|mask
return|;
block|}
specifier|public
specifier|static
name|void
name|orLong
parameter_list|(
name|int
name|bitCount
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|orLong
argument_list|(
name|bitCount
argument_list|,
literal|64
operator|/
name|bitCount
argument_list|,
name|values
argument_list|,
name|ordinal
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|orLong
parameter_list|(
name|int
name|bitCount
parameter_list|,
name|int
name|chunksPerWord
parameter_list|,
name|long
index|[]
name|values
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|int
name|word
init|=
name|ordinal
operator|/
name|chunksPerWord
decl_stmt|;
name|int
name|chunk
init|=
name|ordinal
operator|%
name|chunksPerWord
decl_stmt|;
name|values
index|[
name|word
index|]
operator||=
name|value
operator|<<
operator|(
name|chunk
operator|*
name|bitCount
operator|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End ArrayTable.java
end_comment

end_unit

