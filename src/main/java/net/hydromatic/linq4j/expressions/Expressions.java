begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|expressions
package|;
end_package

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Extensions
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|function
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Utility methods for expressions, including a lot of factory methods.  */
end_comment

begin_class
specifier|public
class|class
name|Expressions
block|{
comment|/** Converts an expression to Java source code, optionally omitting      * extra type information in generics. */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Node
name|expression
parameter_list|,
name|boolean
name|generics
parameter_list|)
block|{
specifier|final
name|ExpressionWriter
name|writer
init|=
operator|new
name|ExpressionWriter
argument_list|(
name|generics
argument_list|)
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|expression
argument_list|)
expr_stmt|;
return|return
name|writer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Converts an expression to Java source code. */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Node
name|expression
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|expression
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * addition operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|add
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Add
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * addition operation that does not have overflow checking. The      * implementing method can be specified. */
specifier|public
specifier|static
name|BinaryExpression
name|add
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an addition      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|addAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AddAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an addition      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|addAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an addition      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|addAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaLeft
parameter_list|,
name|LambdaExpression
name|lambdaRight
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an addition      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|addAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AddAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an addition      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|addAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an addition      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|addAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * addition operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|addChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AddChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * addition operation that has overflow checking. The implementing      * method can be specified. */
specifier|public
specifier|static
name|BinaryExpression
name|addChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise AND      * operation. */
specifier|public
specifier|static
name|BinaryExpression
name|and
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|And
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise AND      * operation. The implementing method can be specified. */
specifier|public
specifier|static
name|BinaryExpression
name|and
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a conditional AND      * operation that evaluates the second operand only if the first      * operand evaluates to true. */
specifier|public
specifier|static
name|BinaryExpression
name|andAlso
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AndAlso
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a conditional AND      * operation that evaluates the second operand only if the first      * operand is resolved to true. The implementing method can be      * specified. */
specifier|public
specifier|static
name|BinaryExpression
name|andAlso
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise AND      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|andAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AndAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise AND      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|andAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise AND      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|andAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an expression that represents applying an array      * index operator to an array of rank one. */
specifier|public
specifier|static
name|IndexExpression
name|arrayIndex
parameter_list|(
name|Expression
name|array
parameter_list|,
name|Expression
name|indexExpression
parameter_list|)
block|{
return|return
operator|new
name|IndexExpression
argument_list|(
name|array
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|indexExpression
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents an expression for      * obtaining the length of a one-dimensional array. */
specifier|public
specifier|static
name|UnaryExpression
name|arrayLength
parameter_list|(
name|Expression
name|array
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an assignment      * operation. */
specifier|public
specifier|static
name|BinaryExpression
name|assign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Assign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a MemberAssignment that represents the initialization      * of a field or property. */
specifier|public
specifier|static
name|MemberAssignment
name|bind
parameter_list|(
name|Member
name|member
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberAssignment that represents the initialization      * of a member by using a property accessor method. */
specifier|public
specifier|static
name|MemberAssignment
name|bind
parameter_list|(
name|Method
name|method
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BlockExpression that contains the given statements. */
specifier|public
specifier|static
name|BlockExpression
name|block
parameter_list|(
name|Statement
modifier|...
name|statements
parameter_list|)
block|{
return|return
name|block
argument_list|(
name|toList
argument_list|(
name|statements
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a BlockExpression that contains the given statements. */
specifier|public
specifier|static
name|BlockExpression
name|block
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Statement
argument_list|>
name|statements
parameter_list|)
block|{
return|return
name|block
argument_list|(
operator|(
name|Type
operator|)
literal|null
argument_list|,
name|statements
argument_list|)
return|;
block|}
comment|/** Creates a BlockExpression that contains the given expressions,      * has no variables and has specific result type. */
specifier|public
specifier|static
name|BlockExpression
name|block
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Statement
argument_list|>
name|expressions
parameter_list|)
block|{
name|List
argument_list|<
name|Statement
argument_list|>
name|list
init|=
name|toList
argument_list|(
name|expressions
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|type
operator|=
name|list
operator|.
name|get
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|Void
operator|.
name|TYPE
expr_stmt|;
block|}
block|}
return|return
operator|new
name|BlockExpression
argument_list|(
name|list
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/** Creates a BlockExpression that contains the given statements      * and has a specific result type. */
specifier|public
specifier|static
name|BlockExpression
name|block
parameter_list|(
name|Type
name|type
parameter_list|,
name|Statement
modifier|...
name|statements
parameter_list|)
block|{
return|return
name|block
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|statements
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a GotoExpression representing a break statement. */
specifier|public
specifier|static
name|GotoExpression
name|break_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a break statement. The      * value passed to the label upon jumping can be specified. */
specifier|public
specifier|static
name|GotoExpression
name|break_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a break statement with      * the specified type. */
specifier|public
specifier|static
name|GotoExpression
name|break_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a break statement with      * the specified type. The value passed to the label upon jumping      * can be specified. */
specifier|public
specifier|static
name|GotoExpression
name|break_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to a      * static method. */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to a      * static method that has arguments. */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to a      * method that takes arguments. */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
name|expression
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to a      * method that takes arguments, with an explicit return type.      *      *<p>The return type must be consistent with the return type of the method,      * but may contain extra information, such as type parameters.</p>      *      *<p>The {@code expression} argument may be null if and only if the method      * is static.</p>      */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Type
name|returnType
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|returnType
argument_list|,
name|method
argument_list|,
name|expression
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to a      * method that takes arguments. */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
name|expression
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to an      * instance method by calling the appropriate factory method. */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
name|Method
name|method
decl_stmt|;
try|try
block|{
name|method
operator|=
name|Types
operator|.
name|toClass
argument_list|(
name|expression
operator|.
name|getType
argument_list|()
argument_list|)
operator|.
name|getMethod
argument_list|(
name|methodName
argument_list|,
name|Types
operator|.
name|toClassArray
argument_list|(
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"while resolving method '"
operator|+
name|methodName
operator|+
literal|"' in class "
operator|+
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|call
argument_list|(
name|expression
argument_list|,
name|method
argument_list|,
name|arguments
argument_list|)
return|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to an      * instance method by calling the appropriate factory method. */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Expression
name|target
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|target
argument_list|,
name|methodName
argument_list|,
name|Arrays
operator|.
expr|<
name|Expression
operator|>
name|asList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to a      * static method by calling the      * appropriate factory method. */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
name|Method
name|method
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Types
operator|.
name|toClass
argument_list|(
name|type
argument_list|)
argument_list|,
name|methodName
argument_list|,
name|Types
operator|.
name|toClassArray
argument_list|(
name|arguments
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a MethodCallExpression that represents a call to a      * static method by calling the      * appropriate factory method. */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|type
argument_list|,
name|methodName
argument_list|,
name|Arrays
operator|.
expr|<
name|Expression
operator|>
name|asList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a CatchBlock representing a catch statement with a      * reference to the caught Exception object for use in the handler      * body. */
specifier|public
specifier|static
name|CatchBlock
name|catch_
parameter_list|(
name|ParameterExpression
name|expression0
parameter_list|,
name|Expression
name|expression1
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a CatchBlock representing a catch statement. */
specifier|public
specifier|static
name|CatchBlock
name|catch_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a CatchBlock representing a catch statement with an      * Exception filter and a reference to the caught Exception      * object. */
specifier|public
specifier|static
name|CatchBlock
name|catch_
parameter_list|(
name|ParameterExpression
name|expression0
parameter_list|,
name|Expression
name|expression1
parameter_list|,
name|Expression
name|expression2
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a CatchBlock representing a catch statement with an      * Exception filter but no reference to the caught Exception      * object. */
specifier|public
specifier|static
name|CatchBlock
name|catch_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|expression0
parameter_list|,
name|Expression
name|expression1
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DebugInfoExpression for clearing a sequence      * point. */
specifier|public
specifier|static
name|void
name|clearDebugInfo
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a coalescing      * operation. */
specifier|public
specifier|static
name|BinaryExpression
name|coalesce
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a coalescing      * operation, given a conversion function. */
specifier|public
specifier|static
name|BinaryExpression
name|coalesce
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ConditionalExpression that represents a conditional      * statement. */
specifier|public
specifier|static
name|ConditionalExpression
name|condition
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Expression
name|ifTrue
parameter_list|,
name|Expression
name|ifFalse
parameter_list|)
block|{
return|return
operator|new
name|ConditionalExpression
argument_list|(
name|Arrays
operator|.
expr|<
name|Node
operator|>
name|asList
argument_list|(
name|test
argument_list|,
name|ifFalse
argument_list|,
name|ifTrue
argument_list|)
argument_list|,
name|Types
operator|.
name|gcd
argument_list|(
name|ifTrue
operator|.
name|getType
argument_list|()
argument_list|,
name|ifFalse
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a ConditionalExpression that represents a conditional      * statement.      *      *<p>This method allows explicitly unifying the result type of the      * conditional expression in cases where the types of ifTrue and ifFalse      * expressions are not equal. Types of both ifTrue and ifFalse must be      * implicitly reference assignable to the result type. The type is allowed      * to be {@link Void#TYPE void}.</p> */
specifier|public
specifier|static
name|ConditionalExpression
name|condition
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Expression
name|ifTrue
parameter_list|,
name|Expression
name|ifFalse
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|ConditionalExpression
argument_list|(
name|Arrays
operator|.
expr|<
name|Node
operator|>
name|asList
argument_list|(
name|test
argument_list|,
name|ifFalse
argument_list|,
name|ifTrue
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/** Creates a ConstantExpression that has the Value property set      * to the specified value. */
specifier|public
specifier|static
name|ConstantExpression
name|constant
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
name|Class
name|type
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|type
operator|=
name|Object
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Class
name|clazz
init|=
name|value
operator|.
name|getClass
argument_list|()
decl_stmt|;
specifier|final
name|Class
name|primitiveType
init|=
name|Types
operator|.
name|toPrimitive
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitiveType
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|primitiveType
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|clazz
expr_stmt|;
block|}
block|}
return|return
operator|new
name|ConstantExpression
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Creates a ConstantExpression that has the Value and Type      * properties set to the specified values. */
specifier|public
specifier|static
name|ConstantExpression
name|constant
parameter_list|(
name|Object
name|value
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|ConstantExpression
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Creates a GotoExpression representing a continue statement. */
specifier|public
specifier|static
name|GotoExpression
name|continue_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a continue statement      * with the specified type. */
specifier|public
specifier|static
name|GotoExpression
name|continue_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents a type conversion      * operation. */
specifier|public
specifier|static
name|UnaryExpression
name|convert_
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|UnaryExpression
argument_list|(
name|ExpressionType
operator|.
name|Convert
argument_list|,
name|type
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents a conversion      * operation for which the implementing method is specified. */
specifier|public
specifier|static
name|UnaryExpression
name|convert_
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents a conversion      * operation that throws an exception if the target type is      * overflowed. */
specifier|public
specifier|static
name|UnaryExpression
name|convertChecked
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents a conversion      * operation that throws an exception if the target type is      * overflowed and for which the implementing method is      * specified. */
specifier|public
specifier|static
name|UnaryExpression
name|convertChecked_
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DebugInfoExpression with the specified span. */
specifier|public
specifier|static
name|void
name|debugInfo
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents the decrementing of      * the expression by 1. */
specifier|public
specifier|static
name|UnaryExpression
name|decrement
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents the decrementing of      * the expression by 1. */
specifier|public
specifier|static
name|UnaryExpression
name|decrement
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DefaultExpression that has the Type property set to      * the specified type. */
specifier|public
specifier|static
name|DefaultExpression
name|default_
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * division operation. */
specifier|public
specifier|static
name|BinaryExpression
name|divide
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Divide
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * division operation. The implementing method can be      * specified. */
specifier|public
specifier|static
name|BinaryExpression
name|divide
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Divide
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a division      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|divideAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|DivideAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a division      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|divideAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a division      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|divideAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DynamicExpression that represents a dynamic      * operation bound by the provided CallSiteBinder. */
specifier|public
specifier|static
name|DynamicExpression
name|dynamic
parameter_list|(
name|CallSiteBinder
name|binder
parameter_list|,
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DynamicExpression that represents a dynamic      * operation bound by the provided CallSiteBinder. */
specifier|public
specifier|static
name|DynamicExpression
name|dynamic
parameter_list|(
name|CallSiteBinder
name|binder
parameter_list|,
name|Type
name|type
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DynamicExpression that represents a dynamic      * operation bound by the provided CallSiteBinder. */
specifier|public
specifier|static
name|DynamicExpression
name|dynamic
parameter_list|(
name|CallSiteBinder
name|binder
parameter_list|,
name|Type
name|type
parameter_list|,
name|Expression
modifier|...
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an ElementInit, given an Iterable<T> as the second      * argument. */
specifier|public
specifier|static
name|ElementInit
name|elementInit
parameter_list|(
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an ElementInit, given an array of values as the second      * argument. */
specifier|public
specifier|static
name|ElementInit
name|elementInit
parameter_list|(
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an empty expression that has Void type. */
specifier|public
specifier|static
name|DefaultExpression
name|empty
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an equality      * comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|equal
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Equal
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an equality      * comparison. The implementing method can be specified. */
specifier|public
specifier|static
name|BinaryExpression
name|equal
parameter_list|(
name|Expression
name|expression0
parameter_list|,
name|Expression
name|expression1
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise XOR      * operation, using op_ExclusiveOr for user-defined types. */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOr
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ExclusiveOr
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise XOR      * operation, using op_ExclusiveOr for user-defined types. The      * implementing method can be specified. */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOr
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise XOR      * assignment operation, using op_ExclusiveOr for user-defined      * types. */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOrAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ExclusiveOrAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise XOR      * assignment operation, using op_ExclusiveOr for user-defined      * types. */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOrAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise XOR      * assignment operation, using op_ExclusiveOr for user-defined      * types. */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOrAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberExpression that represents accessing a field. */
specifier|public
specifier|static
name|MemberExpression
name|field
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Field
name|field
parameter_list|)
block|{
return|return
name|makeMemberAccess
argument_list|(
name|expression
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/** Creates a MemberExpression that represents accessing a field      * given the name of the field. */
specifier|public
specifier|static
name|MemberExpression
name|field
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|Field
name|field
init|=
name|Types
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|makeMemberAccess
argument_list|(
name|expression
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/** Creates a MemberExpression that represents accessing a field. */
specifier|public
specifier|static
name|MemberExpression
name|field
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
try|try
block|{
name|Field
name|field
init|=
name|Types
operator|.
name|toClass
argument_list|(
name|type
argument_list|)
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
return|return
name|makeMemberAccess
argument_list|(
name|expression
argument_list|,
name|field
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown field '"
operator|+
name|fieldName
operator|+
literal|"' in class "
operator|+
name|type
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a Type object that represents a generic System.Action      * delegate type that has specific type arguments. */
specifier|public
specifier|static
name|Class
name|getActionType
parameter_list|(
name|Class
modifier|...
name|typeArgs
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Gets a Type object that represents a generic System.Func or      * System.Action delegate type that has specific type      * arguments. */
specifier|public
specifier|static
name|Class
name|getDelegateType
parameter_list|(
name|Class
modifier|...
name|typeArgs
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a Type object that represents a generic System.Func      * delegate type that has specific type arguments. The last type      * argument specifies the return type of the created delegate. */
specifier|public
specifier|static
name|Class
name|getFuncType
parameter_list|(
name|Class
modifier|...
name|typeArgs
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a "go to" statement. */
specifier|public
specifier|static
name|GotoExpression
name|goto_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a "go to" statement. The      * value passed to the label upon jumping can be specified. */
specifier|public
specifier|static
name|GotoExpression
name|goto_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a "go to" statement with      * the specified type. */
specifier|public
specifier|static
name|GotoExpression
name|goto_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a "go to" statement with      * the specified type. The value passed to the label upon jumping      * can be specified. */
specifier|public
specifier|static
name|GotoExpression
name|goto_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a "greater than"      * numeric comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|greaterThan
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|GreaterThan
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a "greater than"      * numeric comparison. The implementing method can be      * specified. */
specifier|public
specifier|static
name|BinaryExpression
name|greaterThan
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a "greater than or      * equal" numeric comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|greaterThanOrEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|GreaterThanOrEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a "greater than or      * equal" numeric comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|greaterThanOrEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ConditionalExpression that represents a conditional      * block with an if statement. */
specifier|public
specifier|static
name|ConditionalStatement
name|ifThen
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Node
name|ifTrue
parameter_list|)
block|{
return|return
operator|new
name|ConditionalStatement
argument_list|(
name|Arrays
operator|.
expr|<
name|Node
operator|>
name|asList
argument_list|(
name|test
argument_list|,
name|ifTrue
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a ConditionalExpression that represents a conditional      * block with if and else statements. */
specifier|public
specifier|static
name|ConditionalStatement
name|ifThenElse
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Node
name|ifTrue
parameter_list|,
name|Node
name|ifFalse
parameter_list|)
block|{
return|return
operator|new
name|ConditionalStatement
argument_list|(
name|Arrays
operator|.
expr|<
name|Node
operator|>
name|asList
argument_list|(
name|test
argument_list|,
name|ifTrue
argument_list|,
name|ifFalse
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents the incrementing of      * the expression value by 1. */
specifier|public
specifier|static
name|UnaryExpression
name|increment
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents the incrementing of      * the expression by 1. */
specifier|public
specifier|static
name|UnaryExpression
name|increment
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an InvocationExpression that applies a delegate or      * lambda expression to a list of argument expressions. */
specifier|public
specifier|static
name|InvocationExpression
name|invoke
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an InvocationExpression that applies a delegate or      * lambda expression to a list of argument expressions. */
specifier|public
specifier|static
name|InvocationExpression
name|invoke
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Returns whether the expression evaluates to false. */
specifier|public
specifier|static
name|UnaryExpression
name|isFalse
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Returns whether the expression evaluates to false. */
specifier|public
specifier|static
name|UnaryExpression
name|isFalse
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Returns whether the expression evaluates to true. */
specifier|public
specifier|static
name|UnaryExpression
name|isTrue
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Returns whether the expression evaluates to true. */
specifier|public
specifier|static
name|UnaryExpression
name|isTrue
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LabelTarget representing a label with X type and      * no name. */
specifier|public
specifier|static
name|LabelTarget
name|label
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LabelExpression representing a label without a      * default value. */
specifier|public
specifier|static
name|LabelExpression
name|label
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LabelTarget representing a label with X type and      * the given name. */
specifier|public
specifier|static
name|LabelTarget
name|label
parameter_list|(
name|String
name|name
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LabelTarget representing a label with the given      * type. */
specifier|public
specifier|static
name|LabelTarget
name|label
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LabelExpression representing a label with the given      * default value. */
specifier|public
specifier|static
name|LabelExpression
name|label
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LabelTarget representing a label with the given type      * and name. */
specifier|public
specifier|static
name|LabelTarget
name|label
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a FunctionExpression from an actual function. */
specifier|public
specifier|static
parameter_list|<
name|F
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|F
name|function
parameter_list|)
block|{
comment|// REVIEW: Check that that function class is non-inner, has a public
comment|// default constructor, etc.?
comment|//noinspection unchecked
return|return
operator|new
name|FunctionExpression
argument_list|<
name|F
argument_list|>
argument_list|(
name|function
argument_list|)
return|;
block|}
comment|/** Creates a LambdaExpression by first constructing a delegate      * type. */
specifier|public
specifier|static
parameter_list|<
name|F
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|BlockExpression
name|body
parameter_list|,
name|Iterable
argument_list|<
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterList
init|=
name|toList
argument_list|(
name|parameters
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|F
argument_list|>
name|type
init|=
name|deduceType
argument_list|(
name|parameterList
argument_list|,
name|body
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|FunctionExpression
argument_list|<
name|F
argument_list|>
argument_list|(
name|type
argument_list|,
name|body
argument_list|,
name|parameterList
argument_list|)
return|;
block|}
comment|/** Creates a LambdaExpression by first constructing a delegate      * type. */
specifier|public
specifier|static
parameter_list|<
name|F
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Expression
name|body
parameter_list|,
name|Iterable
argument_list|<
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|Blocks
operator|.
name|toFunctionBlock
argument_list|(
name|body
argument_list|)
argument_list|,
name|parameters
argument_list|)
return|;
block|}
comment|/** Creates an Expression<TDelegate> where the delegate type is      * known at compile time. */
specifier|public
specifier|static
parameter_list|<
name|TDelegate
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|TDelegate
argument_list|>
name|lambda
parameter_list|(
name|BlockExpression
name|body
parameter_list|,
name|ParameterExpression
modifier|...
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|body
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an Expression<TDelegate> where the delegate type is      * known at compile time. */
specifier|public
specifier|static
parameter_list|<
name|TDelegate
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|TDelegate
argument_list|>
name|lambda
parameter_list|(
name|Expression
name|body
parameter_list|,
name|ParameterExpression
modifier|...
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|Blocks
operator|.
name|toFunctionBlock
argument_list|(
name|body
argument_list|)
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a LambdaExpression by first constructing a delegate      * type. It can be used when the delegate type is not known at      * compile time. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Class
argument_list|<
name|F
argument_list|>
name|type
parameter_list|,
name|BlockExpression
name|body
parameter_list|,
name|Iterable
argument_list|<
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
return|return
operator|new
name|FunctionExpression
argument_list|<
name|F
argument_list|>
argument_list|(
name|type
argument_list|,
name|body
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a LambdaExpression by first constructing a delegate      * type. It can be used when the delegate type is not known at      * compile time. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Class
argument_list|<
name|F
argument_list|>
name|type
parameter_list|,
name|Expression
name|body
parameter_list|,
name|Iterable
argument_list|<
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|type
argument_list|,
name|Blocks
operator|.
name|toFunctionBlock
argument_list|(
name|body
argument_list|)
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a LambdaExpression by first constructing a delegate      * type. It can be used when the delegate type is not known at      * compile time. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Class
argument_list|<
name|F
argument_list|>
name|type
parameter_list|,
name|BlockExpression
name|body
parameter_list|,
name|ParameterExpression
modifier|...
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|type
argument_list|,
name|body
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a LambdaExpression by first constructing a delegate      * type. It can be used when the delegate type is not known at      * compile time. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Class
argument_list|<
name|F
argument_list|>
name|type
parameter_list|,
name|Expression
name|body
parameter_list|,
name|ParameterExpression
modifier|...
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|type
argument_list|,
name|body
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a LambdaExpression by first constructing a delegate      * type. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Type
name|type
parameter_list|,
name|BlockExpression
name|body
parameter_list|,
name|String
name|name
parameter_list|,
name|Iterable
argument_list|<
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * left-shift operation. */
specifier|public
specifier|static
name|BinaryExpression
name|leftShift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|LeftShift
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * left-shift operation. */
specifier|public
specifier|static
name|BinaryExpression
name|leftShift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * left-shift assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|leftShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|LeftShiftAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * left-shift assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|leftShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * left-shift assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|leftShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a "less than"      * numeric comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|lessThan
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|LessThan
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a "less than"      * numeric comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|lessThan
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a " less than or      * equal" numeric comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|lessThanOrEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|LessThanOrEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a "less than or      * equal" numeric comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|lessThanOrEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberListBinding where the member is a field or      * property. */
specifier|public
specifier|static
name|MemberListBinding
name|listBind
parameter_list|(
name|Member
name|member
parameter_list|,
name|Iterable
argument_list|<
name|ElementInit
argument_list|>
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberListBinding where the member is a field or      * property. */
specifier|public
specifier|static
name|MemberListBinding
name|listBind
parameter_list|(
name|Member
name|member
parameter_list|,
name|ElementInit
modifier|...
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberListBinding based on a specified property      * accessor method. */
specifier|public
specifier|static
name|MemberListBinding
name|listBind
parameter_list|(
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|ElementInit
argument_list|>
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberListBinding object based on a specified      * property accessor method. */
specifier|public
specifier|static
name|MemberListBinding
name|listBind
parameter_list|(
name|Method
name|method
parameter_list|,
name|ElementInit
modifier|...
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ListInitExpression that uses specified ElementInit      * objects to initialize a collection. */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Iterable
argument_list|<
name|ElementInit
argument_list|>
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ListInitExpression that uses a method named "Add" to      * add elements to a collection. */
specifier|public
specifier|static
name|ListInitExpression
name|listInitE
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ListInitExpression that uses specified ElementInit      * objects to initialize a collection. */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|ElementInit
modifier|...
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ListInitExpression that uses a method named "Add" to      * add elements to a collection. */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ListInitExpression that uses a specified method to      * add elements to a collection. */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ListInitExpression that uses a specified method to      * add elements to a collection. */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LoopExpression with the given body. */
specifier|public
specifier|static
name|LoopExpression
name|loop
parameter_list|(
name|Expression
name|body
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LoopExpression with the given body and break      * target. */
specifier|public
specifier|static
name|LoopExpression
name|loop
parameter_list|(
name|Expression
name|body
parameter_list|,
name|LabelTarget
name|breakTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a LoopExpression with the given body. */
specifier|public
specifier|static
name|LoopExpression
name|loop
parameter_list|(
name|Expression
name|body
parameter_list|,
name|LabelTarget
name|breakTarget
parameter_list|,
name|LabelTarget
name|continueTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression, given the left and right operands,      * by calling an appropriate factory method. */
specifier|public
specifier|static
name|BinaryExpression
name|makeBinary
parameter_list|(
name|ExpressionType
name|binaryType
parameter_list|,
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
specifier|final
name|Type
name|type
decl_stmt|;
switch|switch
condition|(
name|binaryType
condition|)
block|{
case|case
name|Equal
case|:
case|case
name|NotEqual
case|:
case|case
name|LessThan
case|:
case|case
name|LessThanOrEqual
case|:
case|case
name|GreaterThan
case|:
case|case
name|GreaterThanOrEqual
case|:
name|type
operator|=
name|Boolean
operator|.
name|TYPE
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|left
operator|.
name|getType
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|new
name|BinaryExpression
argument_list|(
name|binaryType
argument_list|,
name|type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression, given the left operand, right      * operand and implementing method, by calling the appropriate      * factory method. */
specifier|public
specifier|static
name|BinaryExpression
name|makeBinary
parameter_list|(
name|ExpressionType
name|binaryType
parameter_list|,
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression, given the left operand, right      * operand, implementing method and type conversion function, by      * calling the appropriate factory method. */
specifier|public
specifier|static
name|BinaryExpression
name|makeBinary
parameter_list|(
name|ExpressionType
name|binaryType
parameter_list|,
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a CatchBlock representing a catch statement with the      * specified elements. */
specifier|public
specifier|static
name|CatchBlock
name|makeCatchBlock
parameter_list|(
name|Type
name|type
parameter_list|,
name|ParameterExpression
name|variable
parameter_list|,
name|Expression
name|body
parameter_list|,
name|Expression
name|filter
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DynamicExpression that represents a dynamic      * operation bound by the provided CallSiteBinder. */
specifier|public
specifier|static
name|DynamicExpression
name|makeDynamic
parameter_list|(
name|Type
name|type
parameter_list|,
name|CallSiteBinder
name|binder
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DynamicExpression that represents a dynamic      * operation bound by the provided CallSiteBinder and one      * argument. */
specifier|public
specifier|static
name|DynamicExpression
name|makeDynamic
parameter_list|(
name|Type
name|type
parameter_list|,
name|CallSiteBinder
name|binder
parameter_list|,
name|Expression
name|argument
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a DynamicExpression that represents a dynamic      * operation bound by the provided CallSiteBinder. */
specifier|public
specifier|static
name|DynamicExpression
name|makeDynamic
parameter_list|(
name|Type
name|type
parameter_list|,
name|CallSiteBinder
name|binder
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a jump of the specified      * GotoExpressionKind. The value passed to the label upon jumping      * can also be specified. */
specifier|public
specifier|static
name|GotoExpression
name|makeGoto
parameter_list|(
name|GotoExpressionKind
name|kind
parameter_list|,
name|LabelTarget
name|target
parameter_list|,
name|Expression
name|value
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an IndexExpression that represents accessing an      * indexed property in an object. */
specifier|public
specifier|static
name|IndexExpression
name|makeIndex
parameter_list|(
name|Expression
name|instance
parameter_list|,
name|PropertyInfo
name|indexer
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberExpression that represents accessing a field. */
specifier|public
specifier|static
name|MemberExpression
name|makeMemberAccess
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Field
name|member
parameter_list|)
block|{
return|return
operator|new
name|MemberExpression
argument_list|(
name|expression
argument_list|,
name|member
argument_list|)
return|;
block|}
comment|/** Creates a TryExpression representing a try block with the      * specified elements. */
specifier|public
specifier|static
name|TryExpression
name|makeTry
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|body
parameter_list|,
name|Expression
name|finally_
parameter_list|,
name|Expression
name|fault
parameter_list|,
name|Iterable
argument_list|<
name|CatchBlock
argument_list|>
name|handlers
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression, given an operand, by calling the      * appropriate factory method. */
specifier|public
specifier|static
name|UnaryExpression
name|makeUnary
parameter_list|(
name|ExpressionType
name|expressionType
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
return|return
operator|new
name|UnaryExpression
argument_list|(
name|expressionType
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression, given an operand and implementing      * method, by calling the appropriate factory method. */
specifier|public
specifier|static
name|UnaryExpression
name|makeUnary
parameter_list|(
name|ExpressionType
name|expressionType
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
assert|assert
name|type
operator|!=
literal|null
assert|;
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberMemberBinding that represents the recursive      * initialization of members of a field or property. */
specifier|public
specifier|static
name|MemberMemberBinding
name|memberBind
parameter_list|(
name|Member
name|member
parameter_list|,
name|Iterable
argument_list|<
name|MemberBinding
argument_list|>
name|bindings
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberMemberBinding that represents the recursive      * initialization of members of a field or property. */
specifier|public
specifier|static
name|MemberMemberBinding
name|memberBind
parameter_list|(
name|Member
name|member
parameter_list|,
name|MemberBinding
modifier|...
name|bindings
parameter_list|)
block|{
return|return
name|memberBind
argument_list|(
name|member
argument_list|,
name|toList
argument_list|(
name|bindings
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a MemberMemberBinding that represents the recursive      * initialization of members of a member that is accessed by using      * a property accessor method. */
specifier|public
specifier|static
name|MemberMemberBinding
name|memberBind
parameter_list|(
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|MemberBinding
argument_list|>
name|bindings
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberMemberBinding that represents the recursive      * initialization of members of a member that is accessed by using      * a property accessor method. */
specifier|public
specifier|static
name|MemberMemberBinding
name|memberBind
parameter_list|(
name|Method
name|method
parameter_list|,
name|MemberBinding
modifier|...
name|bindings
parameter_list|)
block|{
return|return
name|memberBind
argument_list|(
name|method
argument_list|,
name|toList
argument_list|(
name|bindings
argument_list|)
argument_list|)
return|;
block|}
comment|/** Represents an expression that creates a new object and      * initializes a property of the object. */
specifier|public
specifier|static
name|MemberInitExpression
name|memberInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Iterable
argument_list|<
name|MemberBinding
argument_list|>
name|bindings
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberInitExpression. */
specifier|public
specifier|static
name|MemberInitExpression
name|memberInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|MemberBinding
modifier|...
name|bindings
parameter_list|)
block|{
return|return
name|memberInit
argument_list|(
name|newExpression
argument_list|,
name|toList
argument_list|(
name|bindings
argument_list|)
argument_list|)
return|;
block|}
comment|/** Declares a method. */
specifier|public
specifier|static
name|MethodDeclaration
name|methodDecl
parameter_list|(
name|int
name|modifier
parameter_list|,
name|Type
name|resultType
parameter_list|,
name|String
name|name
parameter_list|,
name|Iterable
argument_list|<
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|,
name|BlockExpression
name|body
parameter_list|)
block|{
return|return
operator|new
name|MethodDeclaration
argument_list|(
name|modifier
argument_list|,
name|name
argument_list|,
name|resultType
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/** Declares a field. */
specifier|public
specifier|static
name|FieldDeclaration
name|fieldDecl
parameter_list|(
name|int
name|modifier
parameter_list|,
name|ParameterExpression
name|parameter
parameter_list|,
name|Expression
name|initializer
parameter_list|)
block|{
return|return
operator|new
name|FieldDeclaration
argument_list|(
name|modifier
argument_list|,
name|parameter
argument_list|,
name|initializer
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * remainder operation. */
specifier|public
specifier|static
name|BinaryExpression
name|modulo
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Modulo
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * remainder operation. */
specifier|public
specifier|static
name|BinaryExpression
name|modulo
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Modulo
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a remainder      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|moduloAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ModuloAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a remainder      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|moduloAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ModuloAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a remainder      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|moduloAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ModuloAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * multiplication operation that does not have overflow      * checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiply
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Multiply
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * multiplication operation that does not have overflow      * checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiply
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Multiply
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a multiplication      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a multiplication      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a multiplication      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a multiplication      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a multiplication      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a multiplication      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * multiplication operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * multiplication operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents an arithmetic      * negation operation. */
specifier|public
specifier|static
name|UnaryExpression
name|negate
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Negate
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents an arithmetic      * negation operation. */
specifier|public
specifier|static
name|UnaryExpression
name|negate
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Negate
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents an arithmetic      * negation operation that has overflow checking. */
specifier|public
specifier|static
name|UnaryExpression
name|negateChecked
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|NegateChecked
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents an arithmetic      * negation operation that has overflow checking. The implementing      * method can be specified. */
specifier|public
specifier|static
name|UnaryExpression
name|negateChecked
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|NegateChecked
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a NewExpression that represents calling the specified      * constructor that takes no arguments. */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|constructor
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|Collections
operator|.
expr|<
name|Expression
operator|>
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a NewExpression that represents calling the      * parameterless constructor of the specified type. */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|type
argument_list|,
name|Collections
operator|.
expr|<
name|Expression
operator|>
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a NewExpression that represents calling the constructor of the      * specified type whose parameters are assignable from the specified      * arguments. */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|type
argument_list|,
name|arguments
argument_list|,
name|Collections
operator|.
expr|<
name|Member
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Creates a NewExpression that represents calling the constructor of the      * specified type whose parameters are assignable from the specified      * arguments. */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|,
name|Iterable
argument_list|<
name|Member
argument_list|>
name|members
parameter_list|,
name|Iterable
argument_list|<
name|MemberDeclaration
argument_list|>
name|memberDeclarations
parameter_list|)
block|{
return|return
operator|new
name|NewExpression
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|,
name|toList
argument_list|(
name|members
argument_list|)
argument_list|,
name|toList
argument_list|(
name|memberDeclarations
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a NewExpression that represents calling the specified      * constructor with the specified arguments. */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|constructor
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|expressions
argument_list|,
name|Collections
operator|.
expr|<
name|Member
operator|>
name|emptyList
argument_list|()
argument_list|,
name|Collections
operator|.
expr|<
name|MemberDeclaration
operator|>
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a NewExpression that represents calling the specified      * constructor with the specified arguments. */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|constructor
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a NewExpression that represents calling the specified      * constructor with the specified arguments. The members that      * access the constructor initialized fields are specified. */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|,
name|Iterable
argument_list|<
name|Member
argument_list|>
name|members
parameter_list|,
name|Iterable
argument_list|<
name|MemberDeclaration
argument_list|>
name|memberDeclarations
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|constructor
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|,
name|toList
argument_list|(
name|members
argument_list|)
argument_list|,
name|toList
argument_list|(
name|memberDeclarations
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a NewExpression that represents calling the specified      * constructor with the specified arguments. The members that      * access the constructor initialized fields are specified as an      * array. */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|,
name|Member
modifier|...
name|members
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|constructor
argument_list|,
name|expressions
argument_list|,
name|toList
argument_list|(
name|members
argument_list|)
argument_list|,
name|Collections
operator|.
expr|<
name|MemberDeclaration
operator|>
name|emptyList
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a NewArrayExpression that represents creating an array      * that has a specified rank. */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayBounds
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a NewArrayExpression that represents creating an array      * that has a specified rank. */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayBounds
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
return|return
name|newArrayBounds
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a NewArrayExpression that represents creating a      * one-dimensional array and initializing it from a list of      * elements.      *      * @param type Element type of the array.      */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayInit
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
return|return
operator|new
name|NewArrayExpression
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a NewArrayExpression that represents creating a      * one-dimensional array and initializing it from a list of      * elements. */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayInit
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
return|return
name|newArrayInit
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents a bitwise complement      * operation. */
specifier|public
specifier|static
name|UnaryExpression
name|not
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Not
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents a bitwise complement      * operation. The implementing method can be specified. */
specifier|public
specifier|static
name|UnaryExpression
name|not
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Not
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an inequality      * comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|notEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|NotEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an inequality      * comparison. */
specifier|public
specifier|static
name|BinaryExpression
name|notEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|NotEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|liftToNull
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Returns the expression representing the ones complement. */
specifier|public
specifier|static
name|UnaryExpression
name|onesComplement
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|OnesComplement
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Returns the expression representing the ones complement. */
specifier|public
specifier|static
name|UnaryExpression
name|onesComplement
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|OnesComplement
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise OR      * operation. */
specifier|public
specifier|static
name|BinaryExpression
name|or
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Or
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise OR      * operation. */
specifier|public
specifier|static
name|BinaryExpression
name|or
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Or
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise OR      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|orAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise OR      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|orAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise OR      * assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|orAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a conditional OR      * operation that evaluates the second operand only if the first      * operand evaluates to false. */
specifier|public
specifier|static
name|BinaryExpression
name|orElse
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrElse
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a conditional OR      * operation that evaluates the second operand only if the first      * operand evaluates to false. */
specifier|public
specifier|static
name|BinaryExpression
name|orElse
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrElse
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a ParameterExpression node that can be used to      * identify a parameter or a variable in an expression tree. */
specifier|public
specifier|static
name|ParameterExpression
name|parameter
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|ParameterExpression
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/** Creates a ParameterExpression node that can be used to      * identify a parameter or a variable in an expression tree. */
specifier|public
specifier|static
name|ParameterExpression
name|parameter
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
operator|new
name|ParameterExpression
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents the assignment of      * the expression followed by a subsequent decrement by 1 of the      * original expression. */
specifier|public
specifier|static
name|UnaryExpression
name|postDecrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PostDecrementAssign
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents the assignment of      * the expression followed by a subsequent decrement by 1 of the      * original expression. */
specifier|public
specifier|static
name|UnaryExpression
name|postDecrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PostDecrementAssign
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents the assignment of      * the expression followed by a subsequent increment by 1 of the      * original expression. */
specifier|public
specifier|static
name|UnaryExpression
name|postIncrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PostIncrementAssign
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents the assignment of      * the expression followed by a subsequent increment by 1 of the      * original expression. */
specifier|public
specifier|static
name|UnaryExpression
name|PostIncrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PostIncrementAssign
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents raising a number to      * a power. */
comment|// REVIEW: In Java this is a call to a lib function, Math.pow.
specifier|public
specifier|static
name|BinaryExpression
name|power
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents raising a number to      * a power. */
comment|// REVIEW: In Java this is a call to a lib function, Math.pow.
specifier|public
specifier|static
name|BinaryExpression
name|power
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents raising an      * expression to a power and assigning the result back to the      * expression. */
comment|// REVIEW: In Java this is a call to a lib function, Math.pow.
specifier|public
specifier|static
name|BinaryExpression
name|powerAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents raising an      * expression to a power and assigning the result back to the      * expression. */
comment|// REVIEW: In Java this is a call to a lib function, Math.pow.
specifier|public
specifier|static
name|BinaryExpression
name|powerAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents raising an      * expression to a power and assigning the result back to the      * expression. */
specifier|public
specifier|static
name|BinaryExpression
name|powerAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that decrements the expression by 1      * and assigns the result back to the expression. */
specifier|public
specifier|static
name|UnaryExpression
name|preDecrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PreDecrementAssign
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that decrements the expression by 1      * and assigns the result back to the expression. */
specifier|public
specifier|static
name|UnaryExpression
name|preDecrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PreDecrementAssign
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that increments the expression by 1      * and assigns the result back to the expression. */
specifier|public
specifier|static
name|UnaryExpression
name|preIncrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PreIncrementAssign
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that increments the expression by 1      * and assigns the result back to the expression. */
specifier|public
specifier|static
name|UnaryExpression
name|preIncrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PreIncrementAssign
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a MemberExpression that represents accessing a      * property by using a property accessor method. */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|MemberExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberExpression that represents accessing a      * property. */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|MemberExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|PropertyInfo
name|property
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberExpression that represents accessing a      * property. */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|MemberExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|name
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an IndexExpression representing the access to an      * indexed property. */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|IndexExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|PropertyInfo
name|property
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an IndexExpression representing the access to an      * indexed property. */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|IndexExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|PropertyInfo
name|property
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an IndexExpression representing the access to an      * indexed property. */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|IndexExpression
name|Property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|name
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberExpression accessing a property. */
specifier|public
specifier|static
name|MemberExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a MemberExpression that represents accessing a      * property or field. */
comment|// REVIEW: Java does not have properties; can only be a field name.
specifier|public
specifier|static
name|MemberExpression
name|propertyOrField
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|propertyOfFieldName
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents an expression that      * has a constant value of type Expression. */
specifier|public
specifier|static
name|UnaryExpression
name|quote
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Quote
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Reduces this node to a simpler expression. If CanReduce      * returns true, this should return a valid expression. This      * method can return another node which itself must be reduced. */
specifier|public
specifier|static
name|Expression
name|reduce
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Reduces this node to a simpler expression. If CanReduce      * returns true, this should return a valid expression. This      * method can return another node which itself must be reduced. */
specifier|public
specifier|static
name|Expression
name|reduceAndCheck
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Reduces the expression to a known node type (that is not an      * Extension node) or just returns the expression if it is already      * a known type. */
specifier|public
specifier|static
name|Expression
name|reduceExtensions
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a reference      * equality comparison. */
specifier|public
specifier|static
name|Expression
name|referenceEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Equal
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a reference      * inequality comparison. */
specifier|public
specifier|static
name|Expression
name|referenceNotEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|NotEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents a rethrowing of an      * exception. */
specifier|public
specifier|static
name|UnaryExpression
name|rethrow
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents a rethrowing of an      * exception with a given type. */
specifier|public
specifier|static
name|UnaryExpression
name|rethrow
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a return statement. */
specifier|public
specifier|static
name|GotoExpression
name|return_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a return statement. The      * value passed to the label upon jumping can be specified. */
specifier|public
specifier|static
name|GotoExpression
name|return_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
return|return
operator|new
name|GotoExpression
argument_list|(
name|GotoExpressionKind
operator|.
name|Return
argument_list|,
name|labelTarget
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a GotoExpression representing a return statement with      * the specified type. */
specifier|public
specifier|static
name|GotoExpression
name|return_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a GotoExpression representing a return statement with      * the specified type. The value passed to the label upon jumping      * can be specified. */
specifier|public
specifier|static
name|GotoExpression
name|return_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * right-shift operation. */
specifier|public
specifier|static
name|BinaryExpression
name|rightShift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShift
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * right-shift operation. */
specifier|public
specifier|static
name|BinaryExpression
name|rightShift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShift
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * right-shift assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|rightShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShiftAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * right-shift assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|rightShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShiftAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a bitwise      * right-shift assignment operation. */
specifier|public
specifier|static
name|BinaryExpression
name|rightShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShiftAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/** Creates an instance of RuntimeVariablesExpression. */
specifier|public
specifier|static
name|RuntimeVariablesExpression
name|runtimeVariables
parameter_list|(
name|Iterable
argument_list|<
name|ParameterExpression
argument_list|>
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an instance of RuntimeVariablesExpression. */
specifier|public
specifier|static
name|RuntimeVariablesExpression
name|runtimeVariables
parameter_list|(
name|ParameterExpression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * subtraction operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtract
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Subtract
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * subtraction operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtract
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Subtract
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a subtraction      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a subtraction      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a subtraction      * assignment operation that does not have overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a subtraction      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a subtraction      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents a subtraction      * assignment operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * subtraction operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtractChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Creates a BinaryExpression that represents an arithmetic      * subtraction operation that has overflow checking. */
specifier|public
specifier|static
name|BinaryExpression
name|subtractChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a SwitchExpression that represents a switch statement      * without a default case. */
specifier|public
specifier|static
name|SwitchExpression
name|switch_
parameter_list|(
name|Expression
name|switchValue
parameter_list|,
name|SwitchCase
modifier|...
name|cases
parameter_list|)
block|{
return|return
name|switch_
argument_list|(
name|switchValue
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|cases
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a SwitchExpression that represents a switch statement      * that has a default case. */
specifier|public
specifier|static
name|SwitchExpression
name|switch_
parameter_list|(
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|SwitchCase
modifier|...
name|cases
parameter_list|)
block|{
return|return
name|switch_
argument_list|(
name|switchValue
argument_list|,
name|defaultBody
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|cases
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a SwitchExpression that represents a switch statement      * that has a default case. */
specifier|public
specifier|static
name|SwitchExpression
name|switch_
parameter_list|(
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|SwitchCase
argument_list|>
name|cases
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a SwitchExpression that represents a switch statement      * that has a default case. */
specifier|public
specifier|static
name|SwitchExpression
name|switch_
parameter_list|(
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|Method
name|method
parameter_list|,
name|SwitchCase
modifier|...
name|cases
parameter_list|)
block|{
return|return
name|switch_
argument_list|(
name|switchValue
argument_list|,
name|defaultBody
argument_list|,
name|method
argument_list|,
name|toList
argument_list|(
name|cases
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a SwitchExpression that represents a switch statement      * that has a default case. */
specifier|public
specifier|static
name|SwitchExpression
name|switch_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|SwitchCase
argument_list|>
name|cases
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a SwitchExpression that represents a switch statement      * that has a default case.. */
specifier|public
specifier|static
name|SwitchExpression
name|switch_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|Method
name|method
parameter_list|,
name|SwitchCase
modifier|...
name|cases
parameter_list|)
block|{
return|return
name|switch_
argument_list|(
name|type
argument_list|,
name|switchValue
argument_list|,
name|defaultBody
argument_list|,
name|method
argument_list|,
name|toList
argument_list|(
name|cases
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a SwitchCase object to be used in a SwitchExpression      * object. */
specifier|public
specifier|static
name|SwitchCase
name|switchCase
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Iterable
argument_list|<
name|Expression
argument_list|>
name|body
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a SwitchCase for use in a SwitchExpression. */
specifier|public
specifier|static
name|SwitchCase
name|switchCase
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Expression
modifier|...
name|body
parameter_list|)
block|{
return|return
name|switchCase
argument_list|(
name|expression
argument_list|,
name|toList
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an instance of SymbolDocumentInfo. */
specifier|public
specifier|static
name|SymbolDocumentInfo
name|symbolDocument
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an instance of SymbolDocumentInfo. */
specifier|public
specifier|static
name|SymbolDocumentInfo
name|symbolDocument
parameter_list|(
name|String
name|fileName
parameter_list|,
name|UUID
name|language
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an instance of SymbolDocumentInfo. */
specifier|public
specifier|static
name|SymbolDocumentInfo
name|symbolDocument
parameter_list|(
name|String
name|fileName
parameter_list|,
name|UUID
name|language
parameter_list|,
name|UUID
name|vendor
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates an instance of SymbolDocumentInfo. */
specifier|public
specifier|static
name|SymbolDocumentInfo
name|symbolDocument
parameter_list|(
name|String
name|filename
parameter_list|,
name|UUID
name|language
parameter_list|,
name|UUID
name|vendor
parameter_list|,
name|UUID
name|documentType
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents a throwing of an      * exception. */
specifier|public
specifier|static
name|UnaryExpression
name|throw_
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents a throwing of an      * exception with a given type. */
specifier|public
specifier|static
name|UnaryExpression
name|throw_
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a TryExpression representing a try block with any      * number of catch statements and neither a fault nor finally      * block. */
specifier|public
specifier|static
name|TryExpression
name|tryCatch
parameter_list|(
name|Expression
name|body
parameter_list|,
name|CatchBlock
modifier|...
name|handlers
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a TryExpression representing a try block with any      * number of catch statements and a finally block. */
specifier|public
specifier|static
name|TryExpression
name|tryCatchFinally
parameter_list|(
name|Expression
name|body
parameter_list|,
name|CatchBlock
modifier|...
name|handlers
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a TryExpression representing a try block with a fault      * block and no catch statements. */
specifier|public
specifier|static
name|TryExpression
name|tryFault
parameter_list|(
name|Expression
name|body
parameter_list|,
name|Expression
name|fault
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a TryExpression representing a try block with a      * finally block and no catch statements. */
specifier|public
specifier|static
name|TryExpression
name|tryFinally
parameter_list|(
name|Expression
name|body
parameter_list|,
name|Expression
name|fault
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a Type object that represents a generic System.Action      * delegate type that has specific type arguments. */
specifier|public
specifier|static
name|boolean
name|tryGetActionType
parameter_list|(
name|Class
index|[]
name|typeArgs
parameter_list|,
name|Class
index|[]
name|outActionType
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a Type object that represents a generic System.Func      * delegate type that has specific type arguments. The last type      * argument specifies the return type of the created delegate. */
specifier|public
specifier|static
name|boolean
name|tryGetFuncType
parameter_list|(
name|Class
index|[]
name|typeArgs
parameter_list|,
name|Class
index|[]
name|outFuncType
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents an explicit      * reference or boxing conversion where null is supplied if the      * conversion fails. */
specifier|public
specifier|static
name|UnaryExpression
name|typeAs
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a TypeBinaryExpression that compares run-time type      * identity. */
specifier|public
specifier|static
name|TypeBinaryExpression
name|typeEqual
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a TypeBinaryExpression. */
specifier|public
specifier|static
name|TypeBinaryExpression
name|typeIs
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a UnaryExpression that represents a unary plus      * operation. */
specifier|public
specifier|static
name|UnaryExpression
name|unaryPlus
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|UnaryPlus
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents a unary plus      * operation. */
specifier|public
specifier|static
name|UnaryExpression
name|unaryPlus
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|UnaryPlus
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/** Creates a UnaryExpression that represents an explicit      * unboxing. */
specifier|public
specifier|static
name|UnaryExpression
name|unbox
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|UnaryExpression
argument_list|(
name|ExpressionType
operator|.
name|Unbox
argument_list|,
name|type
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates a ParameterExpression node that can be used to      * identify a parameter or a variable in an expression tree. */
specifier|public
specifier|static
name|ParameterExpression
name|variable
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a ParameterExpression node that can be used to      * identify a parameter or a variable in an expression tree. */
specifier|public
specifier|static
name|ParameterExpression
name|variable
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
operator|new
name|ParameterExpression
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/** Reduces the node and then calls the visitor delegate on the      * reduced expression. The method throws an exception if the node      * is not reducible.*/
specifier|public
specifier|static
name|Expression
name|visitChildren
parameter_list|(
name|ExpressionVisitor
name|visitor
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/** Creates a WhileExpression representing a while loop. */
specifier|public
specifier|static
name|WhileExpression
name|while_
parameter_list|(
name|Expression
name|condition
parameter_list|,
name|Statement
name|body
parameter_list|)
block|{
return|return
operator|new
name|WhileExpression
argument_list|(
name|condition
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/** Creates a statement that declares a variable. */
specifier|public
specifier|static
name|DeclarationExpression
name|declare
parameter_list|(
name|int
name|modifiers
parameter_list|,
name|ParameterExpression
name|parameter
parameter_list|,
name|Expression
name|initializer
parameter_list|)
block|{
return|return
operator|new
name|DeclarationExpression
argument_list|(
name|modifiers
argument_list|,
name|parameter
argument_list|,
name|initializer
argument_list|)
return|;
block|}
comment|/** Creates an expression that declares and initializes a variable. No      * type is required; it is assumed that the variable is the same type as      * the initializer. You can retrieve the {@link ParameterExpression} from      * the {@link DeclarationExpression#parameter} field of the result. */
specifier|public
specifier|static
name|DeclarationExpression
name|declare
parameter_list|(
name|int
name|modifiers
parameter_list|,
name|String
name|name
parameter_list|,
name|Expression
name|initializer
parameter_list|)
block|{
return|return
name|declare
argument_list|(
name|modifiers
argument_list|,
name|parameter
argument_list|(
name|initializer
operator|.
name|getType
argument_list|()
argument_list|,
name|name
argument_list|)
argument_list|,
name|initializer
argument_list|)
return|;
block|}
comment|/** Creates a statement that executes an expression. */
specifier|public
specifier|static
name|Statement
name|statement
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
operator|new
name|GotoExpression
argument_list|(
name|GotoExpressionKind
operator|.
name|Sequence
argument_list|,
literal|null
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Creates an empty fluent list. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FluentList
argument_list|<
name|T
argument_list|>
name|list
parameter_list|()
block|{
return|return
operator|new
name|FluentArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
return|;
block|}
comment|/** Creates a fluent list with given elements. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FluentList
argument_list|<
name|T
argument_list|>
name|list
parameter_list|(
name|T
modifier|...
name|ts
parameter_list|)
block|{
return|return
operator|new
name|FluentArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|ts
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a fluent list with given elements. */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FluentList
argument_list|<
name|T
argument_list|>
name|list
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|ts
parameter_list|)
block|{
return|return
operator|new
name|FluentArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|toList
argument_list|(
name|ts
argument_list|)
argument_list|)
return|;
block|}
comment|// ~ Private helper methods ------------------------------------------------
specifier|private
specifier|static
name|boolean
name|shouldLift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
comment|// FIXME: Implement the rules in modulo
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|Class
name|deduceType
parameter_list|(
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterList
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|parameterList
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|Function0
operator|.
name|class
return|;
case|case
literal|1
case|:
return|return
name|type
operator|==
name|Boolean
operator|.
name|TYPE
condition|?
name|Predicate1
operator|.
name|class
else|:
name|Function1
operator|.
name|class
return|;
case|case
literal|2
case|:
return|return
name|type
operator|==
name|Boolean
operator|.
name|TYPE
condition|?
name|Predicate2
operator|.
name|class
else|:
name|Function2
operator|.
name|class
return|;
default|default:
return|return
name|Function
operator|.
name|class
return|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|toList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
return|return
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
return|;
block|}
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|parameter
range|:
name|iterable
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|toList
parameter_list|(
name|T
index|[]
name|ts
parameter_list|)
block|{
if|if
condition|(
name|ts
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|ts
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|toCollection
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|(
name|Collection
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
return|;
block|}
return|return
name|toList
argument_list|(
name|iterable
argument_list|)
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|T
index|[]
name|a
parameter_list|)
block|{
return|return
name|toCollection
argument_list|(
name|iterable
argument_list|)
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|// ~ Classes and interfaces ------------------------------------------------
comment|// Some interfaces we'd rather not implement yet. They don't seem relevant
comment|// in the Java world.
interface|interface
name|PropertyInfo
block|{}
interface|interface
name|RuntimeVariablesExpression
block|{}
interface|interface
name|SymbolDocumentInfo
block|{}
specifier|public
interface|interface
name|FluentList
parameter_list|<
name|T
parameter_list|>
extends|extends
name|List
argument_list|<
name|T
argument_list|>
block|{
name|FluentList
argument_list|<
name|T
argument_list|>
name|append
parameter_list|(
name|T
name|t
parameter_list|)
function_decl|;
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendIf
parameter_list|(
name|boolean
name|condition
parameter_list|,
name|T
name|t
parameter_list|)
function_decl|;
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendIfNotNull
parameter_list|(
name|T
name|t
parameter_list|)
function_decl|;
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendAll
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|ts
parameter_list|)
function_decl|;
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendAll
parameter_list|(
name|T
modifier|...
name|ts
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|static
class|class
name|FluentArrayList
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ArrayList
argument_list|<
name|T
argument_list|>
implements|implements
name|FluentList
argument_list|<
name|T
argument_list|>
block|{
specifier|public
name|FluentArrayList
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|FluentArrayList
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
parameter_list|)
block|{
name|super
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|append
parameter_list|(
name|T
name|t
parameter_list|)
block|{
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendIf
parameter_list|(
name|boolean
name|condition
parameter_list|,
name|T
name|t
parameter_list|)
block|{
if|if
condition|(
name|condition
condition|)
block|{
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendIfNotNull
parameter_list|(
name|T
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendAll
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|ts
parameter_list|)
block|{
name|addAll
argument_list|(
name|toCollection
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendAll
parameter_list|(
name|T
modifier|...
name|ts
parameter_list|)
block|{
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Expressions.java
end_comment

end_unit

