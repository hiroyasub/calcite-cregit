begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
package|;
end_package

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|function
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Functions
operator|.
name|adapt
import|;
end_import

begin_comment
comment|/**  * @author jhyde  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|EnumerableDefaults
block|{
comment|/**    * Applies an accumulator function over a sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|aggregate
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|func
parameter_list|)
block|{
name|TSource
name|result
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|result
operator|=
name|func
operator|.
name|apply
argument_list|(
name|result
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Applies an accumulator function over a    * sequence. The specified seed value is used as the initial    * accumulator value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TAccumulate
parameter_list|>
name|TAccumulate
name|aggregate
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|TAccumulate
name|seed
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|func
parameter_list|)
block|{
name|TAccumulate
name|result
init|=
name|seed
decl_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|result
operator|=
name|func
operator|.
name|apply
argument_list|(
name|result
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Applies an accumulator function over a    * sequence. The specified seed value is used as the initial    * accumulator value, and the specified function is used to select    * the result value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|TResult
name|aggregate
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|TAccumulate
name|seed
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|func
parameter_list|,
name|Function1
argument_list|<
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
name|TAccumulate
name|accumulate
init|=
name|seed
decl_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|accumulate
operator|=
name|func
operator|.
name|apply
argument_list|(
name|accumulate
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|selector
operator|.
name|apply
argument_list|(
name|accumulate
argument_list|)
return|;
block|}
comment|/**    * Determines whether all elements of a sequence    * satisfy a condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|all
parameter_list|(
name|Enumerable
argument_list|<
name|?
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Determines whether a sequence contains any    * elements.    */
specifier|public
specifier|static
name|boolean
name|any
parameter_list|(
name|Enumerable
name|enumerable
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|enumerator
argument_list|()
operator|.
name|moveNext
argument_list|()
return|;
block|}
comment|/**    * Determines whether any element of a sequence    * satisfies a condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|any
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the input typed as Enumerable<TSource>.    *    *<p>The AsEnumerable<TSource>(Enumerable<TSource>) method has no effect    * other than to change the compile-time type of source from a type that    * implements Enumerable<TSource> to Enumerable<TSource> itself.    *    *<p>AsEnumerable<TSource>(Enumerable<TSource>) can be used to choose    * between query implementations when a sequence implements    * Enumerable<TSource> but also has a different set of public query methods    * available. For example, given a generic class Table that implements    * Enumerable<TSource> and has its own methods such as Where, Select, and    * SelectMany, a call to Where would invoke the public Where method of    * Table. A Table type that represents a database table could have a Where    * method that takes the predicate argument as an expression tree and    * converts the tree to SQL for remote execution. If remote execution is not    * desired, for example because the predicate invokes a local method, the    * AsEnumerable<TSource> method can be used to hide the custom methods and    * instead make the standard query operators available.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|asEnumerable
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
return|return
name|enumerable
return|;
block|}
comment|/**    * Converts an Enumerable to an IQueryable.    *    *<p>Analogous to the LINQ's Enumerable.AsQueryable extension method.</p>    *    * @param enumerable Enumerable    * @param<TSource> Element type    *    * @return A queryable    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Queryable
argument_list|<
name|TSource
argument_list|>
name|asQueryable
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Computes the average of a sequence of Decimal    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|BigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|longCount
argument_list|(
name|source
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * Decimal values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableBigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|longCount
argument_list|(
name|source
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of Double    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|double
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|DoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * Double values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Double
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableDoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of int values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|IntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|count
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * int values that are obtained by invoking a transform function    * on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Integer
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableIntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|count
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of long values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|LongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * long values that are obtained by invoking a transform function    * on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Long
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableLongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of Float    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|float
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|FloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * Float values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Float
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableFloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    *<p>Analogous to LINQ's Enumerable.Cast extension method.</p>    *    * @param clazz Target type    * @param<T2> Target type    *    * @return Collection of T2    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|T2
parameter_list|>
name|Enumerable
argument_list|<
name|T2
argument_list|>
name|cast
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T2
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|T2
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|T2
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|CastingEnumerator
argument_list|<
name|T2
argument_list|>
argument_list|(
name|source
operator|.
name|enumerator
argument_list|()
argument_list|,
name|clazz
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Concatenates two sequences.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|concat
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable1
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|Linq4j
operator|.
name|concat
argument_list|(
name|Arrays
operator|.
expr|<
name|Enumerable
argument_list|<
name|TSource
argument_list|>
operator|>
name|asList
argument_list|(
name|enumerable0
argument_list|,
name|enumerable1
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Determines whether a sequence contains a specified    * element by using the default equality comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|contains
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|TSource
name|element
parameter_list|)
block|{
comment|// Implementations of Enumerable backed by a Collection call
comment|// Collection.contains, which may be more efficient, not this method.
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|element
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Determines whether a sequence contains a specified    * element by using a specified EqualityComparer<TSource>.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|contains
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|TSource
name|element
parameter_list|,
name|EqualityComparer
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the number of elements in a    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|count
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|longCount
argument_list|(
name|enumerable
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
operator|>
name|truePredicate1
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a number that represents how many elements    * in the specified sequence satisfy a condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|count
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|longCount
argument_list|(
name|enumerable
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns the elements of the specified sequence or    * the type parameter's default value in a singleton collection if    * the sequence is empty.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|defaultIfEmpty
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the elements of the specified sequence or    * the specified value in a singleton collection if the sequence    * is empty.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|defaultIfEmpty
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|TSource
name|value
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns distinct elements from a sequence by using    * the default equality comparer to compare values.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|distinct
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns distinct elements from a sequence by using    * a specified EqualityComparer<TSource> to compare values.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|distinct
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|EqualityComparer
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the element at a specified index in a    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|elementAt
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|int
name|index
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the element at a specified index in a    * sequence or a default value if the index is out of    * range.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|elementAtOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|int
name|index
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Produces the set difference of two sequences by    * using the default equality comparer to compare values. (Defined    * by Enumerable.)    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|except
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|)
block|{
name|Set
argument_list|<
name|TSource
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|TSource
argument_list|>
argument_list|()
decl_stmt|;
name|source0
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source1
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|set
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
return|;
block|}
comment|/**    * Produces the set difference of two sequences by    * using the specified EqualityComparer<TSource> to compare    * values.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|except
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|,
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapper
init|=
name|wrapperFor
argument_list|(
name|comparer
argument_list|)
decl_stmt|;
name|source0
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|os
init|=
name|source1
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|Wrapped
argument_list|<
name|TSource
argument_list|>
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|set
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
init|=
name|unwrapper
argument_list|()
decl_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
operator|.
name|select
argument_list|(
name|unwrapper
argument_list|)
return|;
block|}
comment|/**    * Returns the first element of a sequence. (Defined    * by Enumerable.)    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|first
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the first element in a sequence that    * satisfies a specified condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|first
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the first element of a sequence, or a    * default value if the sequence contains no elements.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|firstOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the first element of the sequence that    * satisfies a condition or a default value if no such element is    * found.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|firstOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|)
return|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and compares the keys by using    * a specified comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|,
name|comparer
argument_list|)
return|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and projects the elements for    * each group by using a specified function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and creates a result value from    * each group and its key.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TResult
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|queryable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function2
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|elementSelector
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * key selector function. The keys are compared by using a    * comparer and each group's elements are projected by using a    * specified function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and creates a result value from    * each group and its key. The keys are compared by using a    * specified comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function2
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|elementSelector
parameter_list|,
name|EqualityComparer
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and creates a result value from    * each group and its key. The elements of each group are    * projected by using a specified function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
name|Function2
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TElement
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and creates a result value from    * each group and its key. Key values are compared by using a    * specified comparer, and the elements of each group are    * projected by using a specified function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
name|Function2
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TElement
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function, initializing an accumulator for each    * group and adding to it each time an element with the same key is seen.    * Creates a result value from each accumulator and its key using a    * specified function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function0
argument_list|<
name|TAccumulate
argument_list|>
name|accumulatorInitializer
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|accumulatorAdder
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
name|groupBy_
argument_list|(
operator|new
name|HashMap
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
argument_list|()
argument_list|,
name|enumerable
argument_list|,
name|keySelector
argument_list|,
name|accumulatorInitializer
argument_list|,
name|accumulatorAdder
argument_list|,
name|resultSelector
argument_list|)
return|;
block|}
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function, initializing an accumulator for each    * group and adding to it each time an element with the same key is seen.    * Creates a result value from each accumulator and its key using a    * specified function. Key values are compared by using a    * specified comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function0
argument_list|<
name|TAccumulate
argument_list|>
name|accumulatorInitializer
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|accumulatorAdder
parameter_list|,
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|groupBy_
argument_list|(
operator|new
name|WrapMap
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
argument_list|(
name|comparer
argument_list|)
argument_list|,
name|enumerable
argument_list|,
name|keySelector
argument_list|,
name|accumulatorInitializer
argument_list|,
name|accumulatorAdder
argument_list|,
name|resultSelector
argument_list|)
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy_
parameter_list|(
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
name|map
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function0
argument_list|<
name|TAccumulate
argument_list|>
name|accumulatorInitializer
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|accumulatorAdder
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|TKey
name|key
init|=
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|TAccumulate
name|accumulator
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|accumulator
operator|==
literal|null
condition|)
block|{
name|accumulator
operator|=
name|accumulatorInitializer
operator|.
name|apply
argument_list|()
expr_stmt|;
name|accumulator
operator|=
name|accumulatorAdder
operator|.
name|apply
argument_list|(
name|accumulator
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|accumulator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAccumulate
name|accumulator0
init|=
name|accumulator
decl_stmt|;
name|accumulator
operator|=
name|accumulatorAdder
operator|.
name|apply
argument_list|(
name|accumulator
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|accumulator
operator|!=
name|accumulator0
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|accumulator
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|new
name|AbstractEnumerable2
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Iterator
argument_list|<
name|TResult
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
argument_list|>
name|iterator
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|TResult
name|next
parameter_list|()
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Correlates the elements of two sequences based on    * equality of keys and groups the results. The default equality    * comparer is used to compare keys.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|outerMap
init|=
name|outer
operator|.
name|toMap
argument_list|(
name|outerKeySelector
argument_list|)
decl_stmt|;
specifier|final
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TInner
argument_list|>
name|innerLookup
init|=
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|)
decl_stmt|;
specifier|final
name|Enumerator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
argument_list|>
name|entries
init|=
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|outerMap
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|TResult
name|current
parameter_list|()
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|entry
init|=
name|entries
operator|.
name|current
argument_list|()
decl_stmt|;
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inners
init|=
name|innerLookup
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|inners
operator|==
literal|null
condition|?
name|Linq4j
operator|.
expr|<
name|TInner
operator|>
name|emptyEnumerable
argument_list|()
else|:
name|inners
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
name|entries
operator|.
name|moveNext
argument_list|()
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|entries
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Correlates the elements of two sequences based on    * key equality and groups the results. A specified    * EqualityComparer<TSource> is used to compare keys.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupJoin
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Produces the set intersection of two sequences by    * using the default equality comparer to compare values. (Defined    * by Enumerable.)    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|intersect
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|)
block|{
name|Set
argument_list|<
name|TSource
argument_list|>
name|set0
init|=
operator|new
name|HashSet
argument_list|<
name|TSource
argument_list|>
argument_list|()
decl_stmt|;
name|source0
operator|.
name|into
argument_list|(
name|set0
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|TSource
argument_list|>
name|set1
init|=
operator|new
name|HashSet
argument_list|<
name|TSource
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source1
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|set0
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|set1
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set1
argument_list|)
return|;
block|}
comment|/**    * Produces the set intersection of two sequences by    * using the specified EqualityComparer<TSource> to compare    * values.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|intersect
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|,
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set0
init|=
operator|new
name|HashSet
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapper
init|=
name|wrapperFor
argument_list|(
name|comparer
argument_list|)
decl_stmt|;
name|source0
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set0
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set1
init|=
operator|new
name|HashSet
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|os
init|=
name|source1
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|Wrapped
argument_list|<
name|TSource
argument_list|>
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|set0
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|set1
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
init|=
name|unwrapper
argument_list|()
decl_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set1
argument_list|)
operator|.
name|select
argument_list|(
name|unwrapper
argument_list|)
return|;
block|}
comment|/**    * Correlates the elements of two sequences based on    * matching keys. The default equality comparer is used to compare    * keys.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|join
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
name|join_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|resultSelector
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Correlates the elements of two sequences based on    * matching keys. A specified EqualityComparer<TSource> is used to    * compare keys.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|join
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|join_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|resultSelector
argument_list|,
name|comparer
argument_list|)
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|join_
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|outerMap
init|=
name|comparer
operator|==
literal|null
condition|?
name|outer
operator|.
name|toLookup
argument_list|(
name|outerKeySelector
argument_list|)
else|:
name|outer
operator|.
name|toLookup
argument_list|(
name|outerKeySelector
argument_list|,
name|comparer
argument_list|)
decl_stmt|;
specifier|final
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TInner
argument_list|>
name|innerLookup
init|=
name|comparer
operator|==
literal|null
condition|?
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|)
else|:
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|,
name|comparer
argument_list|)
decl_stmt|;
specifier|final
name|Enumerator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|outerMap
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|Enumerator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|productEnumerator
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
operator|(
name|TSource
operator|)
name|productEnumerator
operator|.
name|current
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|TInner
operator|)
name|productEnumerator
operator|.
name|current
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|productEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|entries
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|outer
init|=
name|entries
operator|.
name|current
argument_list|()
decl_stmt|;
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outerEnumerable
init|=
name|outer
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|innerEnumerable
init|=
name|innerLookup
operator|.
name|get
argument_list|(
name|outer
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|innerEnumerable
operator|==
literal|null
operator|||
operator|!
name|innerEnumerable
operator|.
name|any
argument_list|()
operator|||
operator|!
name|outerEnumerable
operator|.
name|any
argument_list|()
condition|)
block|{
name|productEnumerator
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|productEnumerator
operator|=
name|Linq4j
operator|.
name|product
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|(
name|Enumerator
argument_list|<
name|Object
argument_list|>
operator|)
operator|(
name|Enumerator
operator|)
name|outerEnumerable
operator|.
name|enumerator
argument_list|()
argument_list|,
operator|(
name|Enumerator
argument_list|<
name|Object
argument_list|>
operator|)
operator|(
name|Enumerator
operator|)
name|innerEnumerable
operator|.
name|enumerator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|entries
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Returns the last element of a sequence. (Defined    * by Enumerable.)    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|last
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the last element of a sequence that    * satisfies a specified condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|last
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the last element of a sequence, or a    * default value if the sequence contains no elements.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|lastOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the last element of a sequence that    * satisfies a condition or a default value if no such element is    * found.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|lastOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns an long that represents the total number    * of elements in a sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|longCount
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
return|return
name|longCount
argument_list|(
name|source
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
operator|>
name|truePredicate1
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns an long that represents how many elements    * in a sequence satisfy a condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|longCount
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
comment|// Shortcut if this is a collection and the predicate is always true.
if|if
condition|(
name|predicate
operator|==
name|Predicate1
operator|.
name|TRUE
operator|&&
name|enumerable
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|(
operator|(
name|Collection
operator|)
name|enumerable
operator|)
operator|.
name|size
argument_list|()
return|;
block|}
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|o
argument_list|)
condition|)
block|{
operator|++
name|n
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
comment|/**    * Returns the maximum value in a generic    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
extends|extends
name|Comparable
argument_list|<
name|TSource
argument_list|>
parameter_list|>
name|TSource
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|max
init|=
name|maxFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
argument_list|,
literal|null
argument_list|,
name|max
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum Decimal value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|BigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|>
name|max
init|=
name|maxFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|max
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable Decimal    * value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableBigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|>
name|max
init|=
name|maxFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|max
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum Double value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|double
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|DoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|DOUBLE_MAX
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable Double    * value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Double
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableDoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|DOUBLE_MAX
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum int value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|IntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|INTEGER_MAX
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable int value. (Defined    * by Enumerable.)    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Integer
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableIntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|INTEGER_MAX
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum long value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|LongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|LONG_MAX
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable long value. (Defined    * by Enumerable.)    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Long
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableLongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|LONG_MAX
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum Float value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|float
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|FloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|FLOAT_MAX
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable Float    * value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Float
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableFloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|FLOAT_MAX
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * generic sequence and returns the maximum resulting    * value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
extends|extends
name|Comparable
argument_list|<
name|TResult
argument_list|>
parameter_list|>
name|TResult
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|TResult
argument_list|,
name|TResult
argument_list|,
name|TResult
argument_list|>
name|max
init|=
name|maxFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|max
argument_list|)
return|;
block|}
comment|/**    * Returns the minimum value in a generic    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
extends|extends
name|Comparable
argument_list|<
name|TSource
argument_list|>
parameter_list|>
name|TSource
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|min
init|=
name|minFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
argument_list|,
literal|null
argument_list|,
name|min
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|TSource
extends|extends
name|Comparable
argument_list|<
name|TSource
argument_list|>
parameter_list|>
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|minFunction
parameter_list|()
block|{
return|return
operator|(
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
operator|)
name|Extensions
operator|.
name|COMPARABLE_MIN
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|TSource
extends|extends
name|Comparable
argument_list|<
name|TSource
argument_list|>
parameter_list|>
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|maxFunction
parameter_list|()
block|{
return|return
operator|(
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
operator|)
name|Extensions
operator|.
name|COMPARABLE_MAX
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum Decimal value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|BigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|>
name|min
init|=
name|minFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|min
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable Decimal    * value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableBigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|>
name|min
init|=
name|minFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|min
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum Double value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|double
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|DoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|DOUBLE_MIN
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable Double    * value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Double
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableDoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|DOUBLE_MIN
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum int value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|IntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|INTEGER_MIN
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable int value. (Defined    * by Enumerable.)    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Integer
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableIntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|INTEGER_MIN
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum long value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|LongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|LONG_MIN
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable long value. (Defined    * by Enumerable.)    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Long
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableLongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|LONG_MIN
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum Float value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|float
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|FloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|FLOAT_MIN
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable Float    * value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Float
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableFloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|FLOAT_MIN
argument_list|)
return|;
block|}
comment|/**    * Invokes a transform function on each element of a    * generic sequence and returns the minimum resulting    * value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
extends|extends
name|Comparable
argument_list|<
name|TResult
argument_list|>
parameter_list|>
name|TResult
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|TResult
argument_list|,
name|TResult
argument_list|,
name|TResult
argument_list|>
name|min
init|=
name|minFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|min
argument_list|)
return|;
block|}
comment|/**    * Filters the elements of an Enumerable based on a    * specified type.    *    *<p>Analogous to LINQ's Enumerable.OfType extension method.</p>    *    * @param clazz Target type    * @param<TResult> Target type    *    * @return Collection of T2    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|ofType
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Class
argument_list|<
name|TResult
argument_list|>
name|clazz
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|Enumerable
operator|)
name|where
argument_list|(
name|enumerable
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
argument_list|,
name|TResult
operator|>
name|ofTypePredicate
argument_list|(
name|clazz
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Sorts the elements of a sequence in ascending    * order according to a key.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
extends|extends
name|Comparable
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|orderBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|orderBy
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Sorts the elements of a sequence in ascending    * order by using a specified comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|orderBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|)
block|{
comment|// NOTE: TreeMap allows null comparator. But the caller of this method
comment|// must supply a comparator if the key does not extend Comparable.
comment|// Otherwise there will be a ClassCastException while retrieving.
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TSource
argument_list|>
argument_list|>
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|LookupImpl
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|lookup
init|=
name|toLookup_
argument_list|(
name|map
argument_list|,
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
operator|>
name|identitySelector
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|lookup
operator|.
name|valuesEnumerable
argument_list|()
return|;
block|}
comment|/**    * Sorts the elements of a sequence in descending    * order according to a key.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
extends|extends
name|Comparable
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|orderByDescending
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|orderBy
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Collections
operator|.
expr|<
name|TKey
operator|>
name|reverseOrder
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Sorts the elements of a sequence in descending    * order by using a specified comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|orderByDescending
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
name|orderBy
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|(
name|comparator
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Inverts the order of the elements in a    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|reverse
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|TSource
argument_list|>
name|list
init|=
name|toList
argument_list|(
name|source
argument_list|)
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|TSource
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|n
operator|-
literal|1
operator|-
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|n
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Projects each element of a sequence into a new    * form.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|select
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|selector
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|moveNext
argument_list|()
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Projects each element of a sequence into a new    * form by incorporating the element's index.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|select
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|selector
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
name|n
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
if|if
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Projects each element of a sequence to an    * Enumerable<TSource> and flattens the resulting sequences into one    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|selectMany
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TResult
argument_list|>
argument_list|>
name|selector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|sourceEnumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|resultEnumerator
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultEnumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|resultEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|sourceEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|resultEnumerator
operator|=
name|selector
operator|.
name|apply
argument_list|(
name|sourceEnumerator
operator|.
name|current
argument_list|()
argument_list|)
operator|.
name|enumerator
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Projects each element of a sequence to an    * Enumerable<TSource>, and flattens the resulting sequences into one    * sequence. The index of each source element is used in the    * projected form of that element.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|selectMany
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|,
name|Enumerable
argument_list|<
name|TResult
argument_list|>
argument_list|>
name|selector
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Projects each element of a sequence to an    * Enumerable<TSource>, flattens the resulting sequences into one    * sequence, and invokes a result selector function on each    * element therein. The index of each source element is used in    * the intermediate projected form of that element.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TCollection
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|selectMany
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|,
name|Enumerable
argument_list|<
name|TCollection
argument_list|>
argument_list|>
name|collectionSelector
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TCollection
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Projects each element of a sequence to an    * Enumerable<TSource>, flattens the resulting sequences into one    * sequence, and invokes a result selector function on each    * element therein.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TCollection
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|selectMany
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TCollection
argument_list|>
argument_list|>
name|collectionSelector
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TCollection
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Determines whether two sequences are equal by    * comparing the elements by using the default equality comparer    * for their type.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|sequenceEqual
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable1
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Determines whether two sequences are equal by    * comparing their elements by using a specified    * EqualityComparer<TSource>.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|sequenceEqual
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable1
parameter_list|,
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the only element of a sequence, and throws    * an exception if there is not exactly one element in the    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|single
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the only element of a sequence that    * satisfies a specified condition, and throws an exception if    * more than one such element exists.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|single
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the only element of a sequence, or a    * default value if the sequence is empty; this method throws an    * exception if there is more than one element in the    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|singleOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns the only element of a sequence that    * satisfies a specified condition or a default value if no such    * element exists; this method throws an exception if more than    * one element satisfies the condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|singleOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Bypasses a specified number of elements in a    * sequence and then returns the remaining elements.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|skip
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|int
name|count
parameter_list|)
block|{
return|return
name|skipWhile
argument_list|(
name|source
argument_list|,
operator|new
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|TSource
name|v1
parameter_list|,
name|Integer
name|v2
parameter_list|)
block|{
comment|// Count is 1-based
return|return
name|v2
operator|<
name|count
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Bypasses elements in a sequence as long as a    * specified condition is true and then returns the remaining    * elements.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|skipWhile
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|skipWhile
argument_list|(
name|source
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
argument_list|,
name|Integer
operator|>
name|toPredicate2
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Bypasses elements in a sequence as long as a    * specified condition is true and then returns the remaining    * elements. The element's index is used in the logic of the    * predicate function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|skipWhile
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|SkipWhileEnumerator
argument_list|<
name|TSource
argument_list|>
argument_list|(
name|source
operator|.
name|enumerator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Computes the sum of the sequence of Decimal values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|BigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|Extensions
operator|.
name|BIG_DECIMAL_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of nullable    * Decimal values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableBigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|Extensions
operator|.
name|BIG_DECIMAL_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of Double values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|double
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|DoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|0d
argument_list|,
name|Extensions
operator|.
name|DOUBLE_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of nullable    * Double values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Double
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableDoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|0d
argument_list|,
name|Extensions
operator|.
name|DOUBLE_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of int values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|IntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Extensions
operator|.
name|INTEGER_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of nullable int    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Integer
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableIntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Extensions
operator|.
name|INTEGER_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of long values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|LongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|0L
argument_list|,
name|Extensions
operator|.
name|LONG_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of nullable long    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Long
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableLongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|0L
argument_list|,
name|Extensions
operator|.
name|LONG_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of Float values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|float
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|FloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|0F
argument_list|,
name|Extensions
operator|.
name|FLOAT_SUM
argument_list|)
return|;
block|}
comment|/**    * Computes the sum of the sequence of nullable    * Float values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Float
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableFloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|0F
argument_list|,
name|Extensions
operator|.
name|FLOAT_SUM
argument_list|)
return|;
block|}
comment|/**    * Returns a specified number of contiguous elements    * from the start of a sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|take
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|int
name|count
parameter_list|)
block|{
return|return
name|takeWhile
argument_list|(
name|source
argument_list|,
operator|new
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|TSource
name|v1
parameter_list|,
name|Integer
name|v2
parameter_list|)
block|{
comment|// Count is 1-based
return|return
name|v2
operator|<
name|count
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns elements from a sequence as long as a    * specified condition is true.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|takeWhile
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|takeWhile
argument_list|(
name|source
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
argument_list|,
name|Integer
operator|>
name|toPredicate2
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns elements from a sequence as long as a    * specified condition is true. The element's index is used in the    * logic of the predicate function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|takeWhile
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|TakeWhileEnumerator
argument_list|<
name|TSource
argument_list|>
argument_list|(
name|source
operator|.
name|enumerator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Performs a subsequent ordering of the elements in a sequence according    * to a key.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|createOrderedEnumerable
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|,
name|boolean
name|descending
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Performs a subsequent ordering of the elements in a sequence in    * ascending order according to a key.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
extends|extends
name|Comparable
argument_list|<
name|TKey
argument_list|>
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|thenBy
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|createOrderedEnumerable
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Extensions
operator|.
expr|<
name|TKey
operator|>
name|comparableComparator
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Performs a subsequent ordering of the elements in a sequence in    * ascending order according to a key, using a specified comparator.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|thenBy
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
name|createOrderedEnumerable
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|comparator
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Performs a subsequent ordering of the elements in a sequence in    * descending order according to a key.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
extends|extends
name|Comparable
argument_list|<
name|TKey
argument_list|>
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|thenByDescending
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|createOrderedEnumerable
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Extensions
operator|.
expr|<
name|TKey
operator|>
name|comparableComparator
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Performs a subsequent ordering of the elements in a sequence in    * descending order according to a key, using a specified comparator.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|thenByDescending
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
name|createOrderedEnumerable
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|comparator
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Creates a Map&lt;TKey, TValue&gt; from an    * Enumerable&lt;TSource&gt; according to a specified key selector    * function.    *    *<p>NOTE: Called {@code toDictionary} in LINQ.NET.</p>    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Map
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|toMap
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|toMap
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
operator|>
name|identitySelector
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a Dictionary<TKey, TValue> from an    * Enumerable<TSource> according to a specified key selector function    * and key comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Map
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|toMap
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a Dictionary<TKey, TValue> from an    * Enumerable<TSource> according to specified key selector and element    * selector functions.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Map
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toMap
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|)
block|{
comment|// Use LinkedHashMap because groupJoin requires order of keys to be
comment|// preserved.
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|,
name|elementSelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
comment|/**    * Creates a Dictionary<TKey, TValue> from an    * Enumerable<TSource> according to a specified key selector function,    * a comparer, and an element selector function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Map
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toMap
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a List<TSource> from an Enumerable<TSource>.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|List
argument_list|<
name|TSource
argument_list|>
name|toList
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|instanceof
name|List
operator|&&
name|source
operator|instanceof
name|RandomAccess
condition|)
block|{
return|return
operator|(
name|List
argument_list|<
name|TSource
argument_list|>
operator|)
name|source
return|;
block|}
else|else
block|{
return|return
name|source
operator|.
name|into
argument_list|(
name|source
operator|instanceof
name|Collection
condition|?
operator|new
name|ArrayList
argument_list|<
name|TSource
argument_list|>
argument_list|(
operator|(
operator|(
name|Collection
operator|)
name|source
operator|)
operator|.
name|size
argument_list|()
argument_list|)
else|:
operator|new
name|ArrayList
argument_list|<
name|TSource
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Creates a Lookup&lt;TKey, TElement&gt; from an    * Enumerable&lt;TSource&gt; according to a specified key selector    * function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|toLookup
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|toLookup
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
operator|>
name|identitySelector
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a Lookup<TKey, TElement> from an    * Enumerable<TSource> according to a specified key selector function    * and key comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|toLookup
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|toLookup
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
expr|<
name|TSource
operator|>
name|identitySelector
argument_list|()
argument_list|,
name|comparer
argument_list|)
return|;
block|}
comment|/**    * Creates a Lookup<TKey, TElement> from an    * Enumerable<TSource> according to specified key selector and element    * selector functions.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toLookup
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TElement
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TElement
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
return|return
name|toLookup_
argument_list|(
name|map
argument_list|,
name|source
argument_list|,
name|keySelector
argument_list|,
name|elementSelector
argument_list|)
return|;
block|}
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|LookupImpl
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toLookup_
parameter_list|(
name|Map
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TElement
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|)
block|{
for|for
control|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|;
name|os
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
specifier|final
name|TKey
name|key
init|=
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TElement
argument_list|>
name|list
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
comment|// for first entry, use a singleton list to save space
name|list
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|elementSelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// when we go from 1 to 2 elements, switch to array list
name|TElement
name|element
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|list
operator|=
operator|new
name|ArrayList
argument_list|<
name|TElement
argument_list|>
argument_list|()
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|elementSelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|LookupImpl
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
comment|/**    * Creates a Lookup<TKey, TElement> from an    * Enumerable<TSource> according to a specified key selector function,    * a comparer and an element selector function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toLookup
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|toLookup_
argument_list|(
operator|new
name|WrapMap
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TElement
argument_list|>
argument_list|>
argument_list|(
name|comparer
argument_list|)
argument_list|,
name|source
argument_list|,
name|keySelector
argument_list|,
name|elementSelector
argument_list|)
return|;
block|}
comment|/**    * Produces the set union of two sequences by using    * the default equality comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|union
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|)
block|{
name|Set
argument_list|<
name|TSource
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|TSource
argument_list|>
argument_list|()
decl_stmt|;
name|source0
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|source1
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
return|;
block|}
comment|/**    * Produces the set union of two sequences by using a    * specified EqualityComparer&lt;TSource&gt;.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|union
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
if|if
condition|(
name|comparer
operator|==
name|Functions
operator|.
name|identityComparer
argument_list|()
condition|)
block|{
return|return
name|union
argument_list|(
name|source0
argument_list|,
name|source1
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapper
init|=
name|wrapperFor
argument_list|(
name|comparer
argument_list|)
decl_stmt|;
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
init|=
name|unwrapper
argument_list|()
decl_stmt|;
name|source0
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|source1
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
operator|.
name|select
argument_list|(
name|unwrapper
argument_list|)
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
parameter_list|()
block|{
return|return
operator|new
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|TSource
name|apply
parameter_list|(
name|Wrapped
argument_list|<
name|TSource
argument_list|>
name|a0
parameter_list|)
block|{
return|return
name|a0
operator|.
name|element
return|;
block|}
block|}
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapperFor
parameter_list|(
specifier|final
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
operator|new
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|Wrapped
argument_list|<
name|TSource
argument_list|>
name|apply
parameter_list|(
name|TSource
name|a0
parameter_list|)
block|{
return|return
name|Wrapped
operator|.
name|upAs
argument_list|(
name|comparer
argument_list|,
name|a0
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Filters a sequence of values based on a    * predicate.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|where
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
assert|assert
name|predicate
operator|!=
literal|null
assert|;
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Enumerator
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
while|while
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Filters a sequence of values based on a    * predicate. Each element's index is used in the logic of the    * predicate function.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|where
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
while|while
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
name|n
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
comment|/**    * Applies a specified function to the corresponding    * elements of two sequences, producing a sequence of the    * results.    */
specifier|public
specifier|static
parameter_list|<
name|T0
parameter_list|,
name|T1
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|zip
parameter_list|(
name|Enumerable
argument_list|<
name|T0
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|T1
argument_list|>
name|source1
parameter_list|,
name|Function2
argument_list|<
name|T0
argument_list|,
name|T1
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|OrderedQueryable
argument_list|<
name|T
argument_list|>
name|asOrderedQueryable
parameter_list|(
name|Enumerable
argument_list|<
name|T
argument_list|>
name|source
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|source
operator|instanceof
name|OrderedQueryable
condition|?
operator|(
operator|(
name|OrderedQueryable
argument_list|<
name|T
argument_list|>
operator|)
name|source
operator|)
else|:
operator|new
name|EnumerableOrderedQueryable
argument_list|<
name|T
argument_list|>
argument_list|(
name|source
argument_list|,
operator|(
name|Class
operator|)
name|Object
operator|.
name|class
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|C
extends|extends
name|Collection
argument_list|<
name|?
super|super
name|T
argument_list|>
parameter_list|>
name|C
name|into
parameter_list|(
name|Enumerable
argument_list|<
name|T
argument_list|>
name|source
parameter_list|,
name|C
name|sink
parameter_list|)
block|{
for|for
control|(
name|Enumerator
argument_list|<
name|T
argument_list|>
name|ts
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|;
name|ts
operator|.
name|moveNext
argument_list|()
condition|;
control|)
block|{
name|T
name|t
init|=
name|ts
operator|.
name|current
argument_list|()
decl_stmt|;
name|sink
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|sink
return|;
block|}
specifier|static
class|class
name|TakeWhileEnumerator
parameter_list|<
name|TSource
parameter_list|>
implements|implements
name|Enumerator
argument_list|<
name|TSource
argument_list|>
block|{
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
decl_stmt|;
specifier|private
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|TakeWhileEnumerator
parameter_list|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|,
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|enumerator
operator|=
name|enumerator
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
operator|&&
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
operator|++
name|n
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|done
operator|=
literal|false
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|SkipWhileEnumerator
parameter_list|<
name|TSource
parameter_list|>
implements|implements
name|Enumerator
argument_list|<
name|TSource
argument_list|>
block|{
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
decl_stmt|;
specifier|private
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
decl_stmt|;
name|boolean
name|started
init|=
literal|false
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|SkipWhileEnumerator
parameter_list|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|,
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|enumerator
operator|=
name|enumerator
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|started
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
operator|++
name|n
argument_list|)
condition|)
block|{
name|started
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|started
operator|=
literal|false
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
specifier|static
class|class
name|CastingEnumerator
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Enumerator
argument_list|<
name|T
argument_list|>
block|{
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|?
argument_list|>
name|enumerator
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
decl_stmt|;
specifier|public
name|CastingEnumerator
parameter_list|(
name|Enumerator
argument_list|<
name|?
argument_list|>
name|enumerator
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
name|this
operator|.
name|enumerator
operator|=
name|enumerator
expr_stmt|;
name|this
operator|.
name|clazz
operator|=
name|clazz
expr_stmt|;
block|}
specifier|public
name|T
name|current
parameter_list|()
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|moveNext
argument_list|()
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|Wrapped
parameter_list|<
name|T
parameter_list|>
block|{
specifier|private
specifier|final
name|EqualityComparer
argument_list|<
name|T
argument_list|>
name|comparer
decl_stmt|;
specifier|private
specifier|final
name|T
name|element
decl_stmt|;
specifier|private
name|Wrapped
parameter_list|(
name|EqualityComparer
argument_list|<
name|T
argument_list|>
name|comparer
parameter_list|,
name|T
name|element
parameter_list|)
block|{
name|this
operator|.
name|comparer
operator|=
name|comparer
expr_stmt|;
name|this
operator|.
name|element
operator|=
name|element
expr_stmt|;
block|}
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Wrapped
argument_list|<
name|T
argument_list|>
name|upAs
parameter_list|(
name|EqualityComparer
argument_list|<
name|T
argument_list|>
name|comparer
parameter_list|,
name|T
name|element
parameter_list|)
block|{
return|return
operator|new
name|Wrapped
argument_list|<
name|T
argument_list|>
argument_list|(
name|comparer
argument_list|,
name|element
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|comparer
operator|.
name|hashCode
argument_list|(
name|element
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|obj
operator|==
name|this
operator|||
name|obj
operator|instanceof
name|Wrapped
operator|&&
name|comparer
operator|.
name|equal
argument_list|(
name|element
argument_list|,
operator|(
operator|(
name|Wrapped
argument_list|<
name|T
argument_list|>
operator|)
name|obj
operator|)
operator|.
name|element
argument_list|)
return|;
block|}
specifier|public
name|T
name|unwrap
parameter_list|()
block|{
return|return
name|element
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|WrapMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|Wrapped
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|Wrapped
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|EqualityComparer
argument_list|<
name|K
argument_list|>
name|comparer
decl_stmt|;
specifier|protected
name|WrapMap
parameter_list|(
name|EqualityComparer
argument_list|<
name|K
argument_list|>
name|comparer
parameter_list|)
block|{
name|this
operator|.
name|comparer
operator|=
name|comparer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Wrapped
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
name|Entry
argument_list|<
name|Wrapped
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|SimpleEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|next
operator|.
name|getKey
argument_list|()
operator|.
name|element
argument_list|,
name|next
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|wrap
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|Wrapped
argument_list|<
name|K
argument_list|>
name|wrap
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|Wrapped
operator|.
name|upAs
argument_list|(
name|comparer
argument_list|,
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|wrap
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|put
argument_list|(
name|wrap
argument_list|(
name|key
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|wrap
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|map
operator|.
name|values
argument_list|()
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End EnumerableDefaults.java
end_comment

end_unit

