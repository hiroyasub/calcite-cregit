begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|BigDecimalFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|DoubleFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|EqualityComparer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|FloatFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function0
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Functions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|IntegerFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|LongFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|NullableBigDecimalFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|NullableDoubleFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|NullableFloatFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|NullableIntegerFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|NullableLongFunction1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Predicate1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Predicate2
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Suppliers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
operator|.
name|CollectionEnumerable
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
operator|.
name|ListEnumerable
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Functions
operator|.
name|adapt
import|;
end_import

begin_comment
comment|/**  * Default implementations of methods in the {@link Enumerable} interface.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|EnumerableDefaults
block|{
comment|/**    * Applies an accumulator function over a sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|aggregate
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|func
parameter_list|)
block|{
name|TSource
name|result
init|=
literal|null
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|result
operator|=
name|func
operator|.
name|apply
argument_list|(
name|result
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**    * Applies an accumulator function over a    * sequence. The specified seed value is used as the initial    * accumulator value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TAccumulate
parameter_list|>
name|TAccumulate
name|aggregate
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|TAccumulate
name|seed
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|func
parameter_list|)
block|{
name|TAccumulate
name|result
init|=
name|seed
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|result
operator|=
name|func
operator|.
name|apply
argument_list|(
name|result
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**    * Applies an accumulator function over a    * sequence. The specified seed value is used as the initial    * accumulator value, and the specified function is used to select    * the result value.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|TResult
name|aggregate
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|TAccumulate
name|seed
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|func
parameter_list|,
name|Function1
argument_list|<
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
name|TAccumulate
name|accumulate
init|=
name|seed
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|accumulate
operator|=
name|func
operator|.
name|apply
argument_list|(
name|accumulate
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|selector
operator|.
name|apply
argument_list|(
name|accumulate
argument_list|)
return|;
block|}
block|}
comment|/**    * Determines whether all elements of a sequence    * satisfy a condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|all
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Determines whether a sequence contains any    * elements.    */
specifier|public
specifier|static
name|boolean
name|any
parameter_list|(
name|Enumerable
name|enumerable
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|enumerator
argument_list|()
operator|.
name|moveNext
argument_list|()
return|;
block|}
comment|/**    * Determines whether any element of a sequence    * satisfies a condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|any
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Returns the input typed as {@code Enumerable<TSource>}.    *    *<p>This method has no effect other than to change the compile-time type of    * source from a type that implements {@code Enumerable<TSource>} to    * {@code Enumerable<TSource>} itself.    *    *<p>{@code AsEnumerable<TSource>(Enumerable<TSource>)} can be used to choose    * between query implementations when a sequence implements    * {@code Enumerable<TSource>} but also has a different set of public query    * methods available. For example, given a generic class {@code Table} that    * implements {@code Enumerable<TSource>} and has its own methods such as    * {@code where}, {@code select}, and {@code selectMany}, a call to    * {@code where} would invoke the public {@code where} method of    * {@code Table}. A {@code Table} type that represents a database table could    * have a {@code where} method that takes the predicate argument as an    * expression tree and converts the tree to SQL for remote execution. If    * remote execution is not desired, for example because the predicate invokes    * a local method, the {@code asEnumerable<TSource>} method can be used to    * hide the custom methods and instead make the standard query operators    * available.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|asEnumerable
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
return|return
name|enumerable
return|;
block|}
comment|/**    * Converts an Enumerable to an IQueryable.    *    *<p>Analogous to the LINQ's Enumerable.AsQueryable extension method.</p>    *    * @param enumerable Enumerable    * @param<TSource> Element type    *    * @return A queryable    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Queryable
argument_list|<
name|TSource
argument_list|>
name|asQueryable
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Computes the average of a sequence of Decimal    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|BigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|longCount
argument_list|(
name|source
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * Decimal values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableBigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|longCount
argument_list|(
name|source
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of Double    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|double
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|DoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * Double values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Double
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableDoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of int values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|IntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|count
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * int values that are obtained by invoking a transform function    * on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Integer
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableIntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|count
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of long values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|LongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * long values that are obtained by invoking a transform function    * on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Long
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableLongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of Float    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|float
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|FloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    * Computes the average of a sequence of nullable    * Float values that are obtained by invoking a transform    * function on each element of the input sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Float
name|average
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableFloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|sum
argument_list|(
name|source
argument_list|,
name|selector
argument_list|)
operator|/
name|longCount
argument_list|(
name|source
argument_list|)
return|;
block|}
comment|/**    *<p>Analogous to LINQ's Enumerable.Cast extension method.</p>    *    * @param clazz Target type    * @param<T2> Target type    *    * @return Collection of T2    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|T2
parameter_list|>
name|Enumerable
argument_list|<
name|T2
argument_list|>
name|cast
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T2
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|T2
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|T2
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|CastingEnumerator
argument_list|<>
argument_list|(
name|source
operator|.
name|enumerator
argument_list|()
argument_list|,
name|clazz
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Concatenates two sequences.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|concat
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable1
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|Linq4j
operator|.
name|concat
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|enumerable0
argument_list|,
name|enumerable1
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Determines whether a sequence contains a specified    * element by using the default equality comparer.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|contains
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|TSource
name|element
parameter_list|)
block|{
comment|// Implementations of Enumerable backed by a Collection call
comment|// Collection.contains, which may be more efficient, not this method.
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|element
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Determines whether a sequence contains a specified    * element by using a specified {@code EqualityComparer<TSource>}.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|contains
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|TSource
name|element
parameter_list|,
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
for|for
control|(
name|TSource
name|o
range|:
name|enumerable
control|)
block|{
if|if
condition|(
name|comparer
operator|.
name|equal
argument_list|(
name|o
argument_list|,
name|element
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Returns the number of elements in a    * sequence.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|count
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|longCount
argument_list|(
name|enumerable
argument_list|,
name|Functions
operator|.
name|truePredicate1
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a number that represents how many elements    * in the specified sequence satisfy a condition.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|count
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|longCount
argument_list|(
name|enumerable
argument_list|,
name|predicate
argument_list|)
return|;
block|}
comment|/**    * Returns the elements of the specified sequence or    * the type parameter's default value in a singleton collection if    * the sequence is empty.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|defaultIfEmpty
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
return|return
name|defaultIfEmpty
argument_list|(
name|enumerable
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns the elements of the specified sequence or    * the specified value in a singleton collection if the sequence    * is empty.    */
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|defaultIfEmpty
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|TSource
name|value
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
parameter_list|()
lambda|->
operator|new
name|Iterator
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|private
name|boolean
name|nonFirst
argument_list|;
specifier|private
name|Iterator
argument_list|<
name|TSource
argument_list|>
name|rest
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|!
name|nonFirst
operator|||
name|rest
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|TSource
name|next
parameter_list|()
block|{
if|if
condition|(
name|nonFirst
condition|)
block|{
return|return
name|rest
operator|.
name|next
argument_list|()
return|;
block|}
else|else
block|{
specifier|final
name|TSource
name|first
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|nonFirst
operator|=
literal|true
expr_stmt|;
name|rest
operator|=
name|Linq4j
operator|.
name|enumeratorIterator
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"remove"
argument_list|)
throw|;
block|}
block|}
block_content|)
empty_stmt|;
block|}
else|else
block|{
return|return
name|Linq4j
operator|.
name|singletonEnumerable
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
unit|}
comment|/**    * Returns distinct elements from a sequence by using    * the default {@link EqualityComparer} to compare values.    */
end_comment

begin_function
unit|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|distinct
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|TSource
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|os
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns distinct elements from a sequence by using    * a specified {@link EqualityComparer} to compare values.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|distinct
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
if|if
condition|(
name|comparer
operator|==
name|Functions
operator|.
name|identityComparer
argument_list|()
condition|)
block|{
return|return
name|distinct
argument_list|(
name|enumerable
argument_list|)
return|;
block|}
specifier|final
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapper
init|=
name|wrapperFor
argument_list|(
name|comparer
argument_list|)
decl_stmt|;
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
init|=
name|unwrapper
argument_list|()
decl_stmt|;
name|enumerable
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
operator|.
name|select
argument_list|(
name|unwrapper
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the element at a specified index in a    * sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|elementAt
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|final
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
name|list
init|=
name|enumerable
operator|instanceof
name|ListEnumerable
condition|?
operator|(
operator|(
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
operator|)
name|enumerable
operator|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
return|return
name|list
operator|.
name|toList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
return|return
name|os
operator|.
name|current
argument_list|()
return|;
block|}
name|index
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * Returns the element at a specified index in a    * sequence or a default value if the index is out of    * range.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|elementAtOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|final
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
name|list
init|=
name|enumerable
operator|instanceof
name|ListEnumerable
condition|?
operator|(
operator|(
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
operator|)
name|enumerable
operator|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|TSource
argument_list|>
name|rawList
init|=
name|list
operator|.
name|toList
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|rawList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|rawList
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
else|else
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
return|return
name|os
operator|.
name|current
argument_list|()
return|;
block|}
name|index
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
end_function

begin_comment
comment|/**    * Produces the set difference of two sequences by    * using the default equality comparer to compare values. (Defined    * by Enumerable.)    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|except
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|)
block|{
name|Set
argument_list|<
name|TSource
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|source0
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source1
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|set
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Produces the set difference of two sequences by    * using the specified {@code EqualityComparer<TSource>} to compare    * values.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|except
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|,
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
if|if
condition|(
name|comparer
operator|==
name|Functions
operator|.
name|identityComparer
argument_list|()
condition|)
block|{
return|return
name|except
argument_list|(
name|source0
argument_list|,
name|source1
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapper
init|=
name|wrapperFor
argument_list|(
name|comparer
argument_list|)
decl_stmt|;
name|source0
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|os
init|=
name|source1
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|Wrapped
argument_list|<
name|TSource
argument_list|>
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|set
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
init|=
name|unwrapper
argument_list|()
decl_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
operator|.
name|select
argument_list|(
name|unwrapper
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the first element of a sequence. (Defined    * by Enumerable.)    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|first
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
name|os
operator|.
name|current
argument_list|()
return|;
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns the first element in a sequence that    * satisfies a specified condition.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|first
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|TSource
name|o
range|:
name|enumerable
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
name|o
return|;
block|}
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
end_function

begin_comment
comment|/**    * Returns the first element of a sequence, or a    * default value if the sequence contains no elements.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|firstOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
name|os
operator|.
name|current
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns the first element of the sequence that    * satisfies a condition or a default value if no such element is    * found.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|firstOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|TSource
name|o
range|:
name|enumerable
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
name|o
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and compares the keys by using    * a specified comparer.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|,
name|comparer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and projects the elements for    * each group by using a specified function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|,
name|elementSelector
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * key selector function. The keys are compared by using a    * comparer and each group's elements are projected by using a    * specified function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Enumerable
argument_list|<
name|Grouping
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|,
name|elementSelector
argument_list|,
name|comparer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and creates a result value from    * each group and its key.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|)
operator|.
name|select
argument_list|(
name|group
lambda|->
name|resultSelector
operator|.
name|apply
argument_list|(
name|group
operator|.
name|getKey
argument_list|()
argument_list|,
name|group
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and creates a result value from    * each group and its key. The keys are compared by using a    * specified comparer.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|,
name|comparer
argument_list|)
operator|.
name|select
argument_list|(
name|group
lambda|->
name|resultSelector
operator|.
name|apply
argument_list|(
name|group
operator|.
name|getKey
argument_list|()
argument_list|,
name|group
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and creates a result value from    * each group and its key. The elements of each group are    * projected by using a specified function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TElement
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|,
name|elementSelector
argument_list|)
operator|.
name|select
argument_list|(
name|group
lambda|->
name|resultSelector
operator|.
name|apply
argument_list|(
name|group
operator|.
name|getKey
argument_list|()
argument_list|,
name|group
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function and creates a result value from    * each group and its key. Key values are compared by using a    * specified comparer, and the elements of each group are    * projected by using a specified function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|Enumerable
argument_list|<
name|TElement
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|enumerable
operator|.
name|toLookup
argument_list|(
name|keySelector
argument_list|,
name|elementSelector
argument_list|,
name|comparer
argument_list|)
operator|.
name|select
argument_list|(
name|group
lambda|->
name|resultSelector
operator|.
name|apply
argument_list|(
name|group
operator|.
name|getKey
argument_list|()
argument_list|,
name|group
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function, initializing an accumulator for each    * group and adding to it each time an element with the same key is seen.    * Creates a result value from each accumulator and its key using a    * specified function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function0
argument_list|<
name|TAccumulate
argument_list|>
name|accumulatorInitializer
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|accumulatorAdder
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
name|groupBy_
argument_list|(
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|,
name|enumerable
argument_list|,
name|keySelector
argument_list|,
name|accumulatorInitializer
argument_list|,
name|accumulatorAdder
argument_list|,
name|resultSelector
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a list of    * specified key selector functions, initializing an accumulator for each    * group and adding to it each time an element with the same key is seen.    * Creates a result value from each accumulator and its key using a    * specified function.    *    *<p>This method exists to support SQL {@code GROUPING SETS}.    * It does not correspond to any method in {@link Enumerable}.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupByMultiple
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|List
argument_list|<
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
argument_list|>
name|keySelectors
parameter_list|,
name|Function0
argument_list|<
name|TAccumulate
argument_list|>
name|accumulatorInitializer
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|accumulatorAdder
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
name|groupByMultiple_
argument_list|(
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|,
name|enumerable
argument_list|,
name|keySelectors
argument_list|,
name|accumulatorInitializer
argument_list|,
name|accumulatorAdder
argument_list|,
name|resultSelector
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Groups the elements of a sequence according to a    * specified key selector function, initializing an accumulator for each    * group and adding to it each time an element with the same key is seen.    * Creates a result value from each accumulator and its key using a    * specified function. Key values are compared by using a    * specified comparer.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function0
argument_list|<
name|TAccumulate
argument_list|>
name|accumulatorInitializer
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|accumulatorAdder
parameter_list|,
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|groupBy_
argument_list|(
operator|new
name|WrapMap
argument_list|<>
argument_list|(
comment|// Java 8 cannot infer return type with HashMap::new is used
parameter_list|()
lambda|->
operator|new
name|HashMap
argument_list|<
name|Wrapped
argument_list|<
name|TKey
argument_list|>
argument_list|,
name|TAccumulate
argument_list|>
argument_list|()
argument_list|,
name|comparer
argument_list|)
argument_list|,
name|enumerable
argument_list|,
name|keySelector
argument_list|,
name|accumulatorInitializer
argument_list|,
name|accumulatorAdder
argument_list|,
name|resultSelector
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy_
parameter_list|(
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
name|map
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function0
argument_list|<
name|TAccumulate
argument_list|>
name|accumulatorInitializer
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|accumulatorAdder
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|TKey
name|key
init|=
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|TAccumulate
name|accumulator
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|accumulator
operator|==
literal|null
condition|)
block|{
name|accumulator
operator|=
name|accumulatorInitializer
operator|.
name|apply
argument_list|()
expr_stmt|;
name|accumulator
operator|=
name|accumulatorAdder
operator|.
name|apply
argument_list|(
name|accumulator
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|accumulator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAccumulate
name|accumulator0
init|=
name|accumulator
decl_stmt|;
name|accumulator
operator|=
name|accumulatorAdder
operator|.
name|apply
argument_list|(
name|accumulator
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|accumulator
operator|!=
name|accumulator0
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|accumulator
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|new
name|LookupResultEnumerable
argument_list|<>
argument_list|(
name|map
argument_list|,
name|resultSelector
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupByMultiple_
parameter_list|(
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
name|map
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|List
argument_list|<
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
argument_list|>
name|keySelectors
parameter_list|,
name|Function0
argument_list|<
name|TAccumulate
argument_list|>
name|accumulatorInitializer
parameter_list|,
name|Function2
argument_list|<
name|TAccumulate
argument_list|,
name|TSource
argument_list|,
name|TAccumulate
argument_list|>
name|accumulatorAdder
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
for|for
control|(
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
range|:
name|keySelectors
control|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|TKey
name|key
init|=
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|TAccumulate
name|accumulator
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|accumulator
operator|==
literal|null
condition|)
block|{
name|accumulator
operator|=
name|accumulatorInitializer
operator|.
name|apply
argument_list|()
expr_stmt|;
name|accumulator
operator|=
name|accumulatorAdder
operator|.
name|apply
argument_list|(
name|accumulator
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|accumulator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAccumulate
name|accumulator0
init|=
name|accumulator
decl_stmt|;
name|accumulator
operator|=
name|accumulatorAdder
operator|.
name|apply
argument_list|(
name|accumulator
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|accumulator
operator|!=
name|accumulator0
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|accumulator
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|new
name|LookupResultEnumerable
argument_list|<>
argument_list|(
name|map
argument_list|,
name|resultSelector
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupBy_
parameter_list|(
specifier|final
name|Set
argument_list|<
name|TKey
argument_list|>
name|map
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TKey
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|TKey
name|key
init|=
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|map
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|map
argument_list|)
operator|.
name|select
argument_list|(
name|resultSelector
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Correlates the elements of two sequences based on    * equality of keys and groups the results. The default equality    * comparer is used to compare keys.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|outerMap
init|=
name|outer
operator|.
name|toMap
argument_list|(
name|outerKeySelector
argument_list|)
decl_stmt|;
specifier|final
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TInner
argument_list|>
name|innerLookup
init|=
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|)
decl_stmt|;
specifier|final
name|Enumerator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
argument_list|>
name|entries
init|=
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|outerMap
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|TResult
name|current
parameter_list|()
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|entry
init|=
name|entries
operator|.
name|current
argument_list|()
decl_stmt|;
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inners
init|=
name|innerLookup
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|inners
operator|==
literal|null
condition|?
name|Linq4j
operator|.
name|emptyEnumerable
argument_list|()
else|:
name|inners
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
name|entries
operator|.
name|moveNext
argument_list|()
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|entries
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Correlates the elements of two sequences based on    * key equality and groups the results. A specified    * {@code EqualityComparer<TSource>} is used to compare keys.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|groupJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|outerMap
init|=
name|outer
operator|.
name|toMap
argument_list|(
name|outerKeySelector
argument_list|,
name|comparer
argument_list|)
decl_stmt|;
specifier|final
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TInner
argument_list|>
name|innerLookup
init|=
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|,
name|comparer
argument_list|)
decl_stmt|;
specifier|final
name|Enumerator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
argument_list|>
name|entries
init|=
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|outerMap
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|TResult
name|current
parameter_list|()
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|entry
init|=
name|entries
operator|.
name|current
argument_list|()
decl_stmt|;
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inners
init|=
name|innerLookup
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|inners
operator|==
literal|null
condition|?
name|Linq4j
operator|.
name|emptyEnumerable
argument_list|()
else|:
name|inners
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
name|entries
operator|.
name|moveNext
argument_list|()
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|entries
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Produces the set intersection of two sequences by    * using the default equality comparer to compare values. (Defined    * by Enumerable.)    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|intersect
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|)
block|{
name|Set
argument_list|<
name|TSource
argument_list|>
name|set0
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|source0
operator|.
name|into
argument_list|(
name|set0
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|TSource
argument_list|>
name|set1
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source1
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|set0
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|set1
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Produces the set intersection of two sequences by    * using the specified {@code EqualityComparer<TSource>} to compare    * values.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|intersect
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|,
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
if|if
condition|(
name|comparer
operator|==
name|Functions
operator|.
name|identityComparer
argument_list|()
condition|)
block|{
return|return
name|intersect
argument_list|(
name|source0
argument_list|,
name|source1
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set0
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapper
init|=
name|wrapperFor
argument_list|(
name|comparer
argument_list|)
decl_stmt|;
name|source0
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set0
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set1
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|os
init|=
name|source1
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|Wrapped
argument_list|<
name|TSource
argument_list|>
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|set0
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|set1
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
init|=
name|unwrapper
argument_list|()
decl_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set1
argument_list|)
operator|.
name|select
argument_list|(
name|unwrapper
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Correlates the elements of two sequences based on    * matching keys. The default equality comparer is used to compare    * keys.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|hashJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
name|hashJoin
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|resultSelector
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Correlates the elements of two sequences based on    * matching keys. A specified {@code EqualityComparer<TSource>} is used to    * compare keys.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|hashJoin
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|hashJoin
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|resultSelector
argument_list|,
name|comparer
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Correlates the elements of two sequences based on    * matching keys. A specified {@code EqualityComparer<TSource>} is used to    * compare keys.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|hashJoin
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
name|boolean
name|generateNullsOnLeft
parameter_list|,
name|boolean
name|generateNullsOnRight
parameter_list|)
block|{
return|return
name|hashEquiJoin_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|resultSelector
argument_list|,
name|comparer
argument_list|,
name|generateNullsOnLeft
argument_list|,
name|generateNullsOnRight
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Correlates the elements of two sequences based on    * matching keys. A specified {@code EqualityComparer<TSource>} is used to    * compare keys.A predicate is used to filter the join result per-row.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|hashJoin
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
name|boolean
name|generateNullsOnLeft
parameter_list|,
name|boolean
name|generateNullsOnRight
parameter_list|,
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|>
name|predicate
parameter_list|)
block|{
if|if
condition|(
name|predicate
operator|==
literal|null
condition|)
block|{
return|return
name|hashEquiJoin_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|resultSelector
argument_list|,
name|comparer
argument_list|,
name|generateNullsOnLeft
argument_list|,
name|generateNullsOnRight
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|hashJoinWithPredicate_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|resultSelector
argument_list|,
name|comparer
argument_list|,
name|generateNullsOnLeft
argument_list|,
name|generateNullsOnRight
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/** Implementation of join that builds the right input and probes with the    * left. */
end_comment

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|hashEquiJoin_
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
specifier|final
name|boolean
name|generateNullsOnLeft
parameter_list|,
specifier|final
name|boolean
name|generateNullsOnRight
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
specifier|final
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TInner
argument_list|>
name|innerLookup
init|=
name|comparer
operator|==
literal|null
condition|?
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|)
else|:
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|,
name|comparer
argument_list|)
decl_stmt|;
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|outers
init|=
name|outer
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|inners
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|TKey
argument_list|>
name|unmatchedKeys
init|=
name|generateNullsOnLeft
condition|?
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|innerLookup
operator|.
name|keySet
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|outers
operator|.
name|current
argument_list|()
argument_list|,
name|inners
operator|.
name|current
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|inners
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|outers
operator|.
name|moveNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|unmatchedKeys
operator|!=
literal|null
condition|)
block|{
comment|// We've seen everything else. If we are doing a RIGHT or FULL
comment|// join (leftNull = true) there are any keys which right but
comment|// not the left.
name|List
argument_list|<
name|TInner
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TKey
name|key
range|:
name|unmatchedKeys
control|)
block|{
for|for
control|(
name|TInner
name|tInner
range|:
name|innerLookup
operator|.
name|get
argument_list|(
name|key
argument_list|)
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|tInner
argument_list|)
expr_stmt|;
block|}
block|}
name|inners
operator|=
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|outers
operator|.
name|close
argument_list|()
expr_stmt|;
name|outers
operator|=
name|Linq4j
operator|.
name|singletonNullEnumerator
argument_list|()
expr_stmt|;
name|outers
operator|.
name|moveNext
argument_list|()
expr_stmt|;
name|unmatchedKeys
operator|=
literal|null
expr_stmt|;
comment|// don't do the 'leftovers' again
continue|continue;
block|}
return|return
literal|false
return|;
block|}
specifier|final
name|TSource
name|outer
init|=
name|outers
operator|.
name|current
argument_list|()
decl_stmt|;
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|innerEnumerable
decl_stmt|;
if|if
condition|(
name|outer
operator|==
literal|null
condition|)
block|{
name|innerEnumerable
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|TKey
name|outerKey
init|=
name|outerKeySelector
operator|.
name|apply
argument_list|(
name|outer
argument_list|)
decl_stmt|;
if|if
condition|(
name|outerKey
operator|==
literal|null
condition|)
block|{
name|innerEnumerable
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|unmatchedKeys
operator|!=
literal|null
condition|)
block|{
name|unmatchedKeys
operator|.
name|remove
argument_list|(
name|outerKey
argument_list|)
expr_stmt|;
block|}
name|innerEnumerable
operator|=
name|innerLookup
operator|.
name|get
argument_list|(
name|outerKey
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|innerEnumerable
operator|==
literal|null
operator|||
operator|!
name|innerEnumerable
operator|.
name|any
argument_list|()
condition|)
block|{
if|if
condition|(
name|generateNullsOnRight
condition|)
block|{
name|inners
operator|=
name|Linq4j
operator|.
name|singletonNullEnumerator
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inners
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|inners
operator|=
name|innerEnumerable
operator|.
name|enumerator
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|outers
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|outers
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/** Implementation of join that builds the right input and probes with the    * left */
end_comment

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|hashJoinWithPredicate_
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
specifier|final
name|boolean
name|generateNullsOnLeft
parameter_list|,
specifier|final
name|boolean
name|generateNullsOnRight
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
comment|/**          * the innerToLookUp will refer the inner , if current join          * is a right join, we should figure out the right list first, if          * not, then keep the original inner here.          */
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|innerToLookUp
init|=
name|generateNullsOnLeft
condition|?
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|inner
operator|.
name|toList
argument_list|()
argument_list|)
else|:
name|inner
decl_stmt|;
specifier|final
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TInner
argument_list|>
name|innerLookup
init|=
name|comparer
operator|==
literal|null
condition|?
name|innerToLookUp
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|)
else|:
name|innerToLookUp
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|,
name|comparer
argument_list|)
decl_stmt|;
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|outers
init|=
name|outer
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|inners
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TInner
argument_list|>
name|innersUnmatched
init|=
name|generateNullsOnLeft
condition|?
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|innerToLookUp
operator|.
name|toList
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|outers
operator|.
name|current
argument_list|()
argument_list|,
name|inners
operator|.
name|current
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|inners
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|outers
operator|.
name|moveNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|innersUnmatched
operator|!=
literal|null
condition|)
block|{
name|inners
operator|=
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|innersUnmatched
argument_list|)
expr_stmt|;
name|outers
operator|.
name|close
argument_list|()
expr_stmt|;
name|outers
operator|=
name|Linq4j
operator|.
name|singletonNullEnumerator
argument_list|()
expr_stmt|;
name|outers
operator|.
name|moveNext
argument_list|()
expr_stmt|;
name|innersUnmatched
operator|=
literal|null
expr_stmt|;
comment|// don't do the 'leftovers' again
continue|continue;
block|}
return|return
literal|false
return|;
block|}
specifier|final
name|TSource
name|outer
init|=
name|outers
operator|.
name|current
argument_list|()
decl_stmt|;
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|innerEnumerable
decl_stmt|;
if|if
condition|(
name|outer
operator|==
literal|null
condition|)
block|{
name|innerEnumerable
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|TKey
name|outerKey
init|=
name|outerKeySelector
operator|.
name|apply
argument_list|(
name|outer
argument_list|)
decl_stmt|;
if|if
condition|(
name|outerKey
operator|==
literal|null
condition|)
block|{
name|innerEnumerable
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|innerEnumerable
operator|=
name|innerLookup
operator|.
name|get
argument_list|(
name|outerKey
argument_list|)
expr_stmt|;
comment|//apply predicate to filter per-row
if|if
condition|(
name|innerEnumerable
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|TInner
argument_list|>
name|matchedInners
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|innerEnumerator
init|=
name|innerEnumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|innerEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
specifier|final
name|TInner
name|inner
init|=
name|innerEnumerator
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|)
condition|)
block|{
name|matchedInners
operator|.
name|add
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|innerEnumerable
operator|=
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|matchedInners
argument_list|)
expr_stmt|;
if|if
condition|(
name|innersUnmatched
operator|!=
literal|null
condition|)
block|{
name|innersUnmatched
operator|.
name|removeAll
argument_list|(
name|matchedInners
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|innerEnumerable
operator|==
literal|null
operator|||
operator|!
name|innerEnumerable
operator|.
name|any
argument_list|()
condition|)
block|{
if|if
condition|(
name|generateNullsOnRight
condition|)
block|{
name|inners
operator|=
name|Linq4j
operator|.
name|singletonNullEnumerator
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|inners
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|inners
operator|=
name|innerEnumerable
operator|.
name|enumerator
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|outers
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|outers
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * For each row of the {@code outer} enumerable returns the correlated rows    * from the {@code inner} enumerable.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|correlateJoin
parameter_list|(
specifier|final
name|JoinType
name|joinType
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
if|if
condition|(
name|joinType
operator|==
name|JoinType
operator|.
name|RIGHT
operator|||
name|joinType
operator|==
name|JoinType
operator|.
name|FULL
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"JoinType "
operator|+
name|joinType
operator|+
literal|" is not valid for correlation"
argument_list|)
throw|;
block|}
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|private
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|outerEnumerator
init|=
name|outer
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|private
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|innerEnumerator
decl_stmt|;
name|TSource
name|outerValue
decl_stmt|;
name|TInner
name|innerValue
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
comment|// 0 -- moving outer, 1 moving inner;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|outerValue
argument_list|,
name|innerValue
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|// move outer
if|if
condition|(
operator|!
name|outerEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|outerValue
operator|=
name|outerEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
comment|// initial move inner
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|innerEnumerable
init|=
name|inner
operator|.
name|apply
argument_list|(
name|outerValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|innerEnumerable
operator|==
literal|null
condition|)
block|{
name|innerEnumerable
operator|=
name|Linq4j
operator|.
name|emptyEnumerable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|innerEnumerator
operator|!=
literal|null
condition|)
block|{
name|innerEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|innerEnumerator
operator|=
name|innerEnumerable
operator|.
name|enumerator
argument_list|()
expr_stmt|;
if|if
condition|(
name|innerEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|ANTI
case|:
comment|// For anti-join need to try next outer row
comment|// Current does not match
continue|continue;
case|case
name|SEMI
case|:
return|return
literal|true
return|;
comment|// current row matches
block|}
comment|// INNER and LEFT just return result
name|innerValue
operator|=
name|innerEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
comment|// iterate over inner results
return|return
literal|true
return|;
block|}
comment|// No match detected
name|innerValue
operator|=
literal|null
expr_stmt|;
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
case|case
name|ANTI
case|:
return|return
literal|true
return|;
block|}
comment|// For INNER and LEFT need to find another outer row
continue|continue;
case|case
literal|1
case|:
comment|// subsequent move inner
if|if
condition|(
name|innerEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|innerValue
operator|=
name|innerEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|state
operator|=
literal|0
expr_stmt|;
comment|// continue loop, move outer
block|}
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|state
operator|=
literal|0
expr_stmt|;
name|outerEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|closeInner
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|outerEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
name|closeInner
argument_list|()
expr_stmt|;
name|outerValue
operator|=
literal|null
expr_stmt|;
block|}
specifier|private
name|void
name|closeInner
parameter_list|()
block|{
name|innerValue
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|innerEnumerator
operator|!=
literal|null
condition|)
block|{
name|innerEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
name|innerEnumerator
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the last element of a sequence. (Defined    * by Enumerable.)    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|last
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
specifier|final
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
name|list
init|=
name|enumerable
operator|instanceof
name|ListEnumerable
condition|?
operator|(
operator|(
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
operator|)
name|enumerable
operator|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|TSource
argument_list|>
name|rawList
init|=
name|list
operator|.
name|toList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|rawList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
return|return
name|rawList
operator|.
name|get
argument_list|(
name|count
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
else|else
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|result
decl_stmt|;
do|do
block|{
name|result
operator|=
name|os
operator|.
name|current
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
do|;
return|return
name|result
return|;
block|}
block|}
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
end_function

begin_comment
comment|/**    *<p>Fetches blocks of size {@code batchSize} from {@code outer},    * storing each block into a list ({@code outerValues}).    * For each block, it uses the {@code inner} function to    * obtain an enumerable with the correlated rows from the right (inner) input.</p>    *    *<p>Each result present in the {@code innerEnumerator} has matched at least one    * value from the block {@code outerValues}.    * At this point a mini nested loop is performed between the outer values    * and inner values using the {@code predicate} to find out the actual matching join results.</p>    *    *<p>In order to optimize this mini nested loop, during the first iteration    * (the first value from {@code outerValues}) we use the {@code innerEnumerator}    * to compare it to inner rows, and at the same time we fill a list ({@code innerValues})    * with said {@code innerEnumerator} rows. In the subsequent iterations    * (2nd, 3rd, etc. value from {@code outerValues}) the list {@code innerValues} is used,    * since it contains all the {@code innerEnumerator} values,    * which were stored in the first iteration.</p>    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|correlateBatchJoin
parameter_list|(
specifier|final
name|JoinType
name|joinType
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|List
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|Enumerable
argument_list|<
name|TInner
argument_list|>
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|>
name|predicate
parameter_list|,
specifier|final
name|int
name|batchSize
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|outerEnumerator
init|=
name|outer
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TSource
argument_list|>
name|outerValues
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|batchSize
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TInner
argument_list|>
name|innerValues
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|TSource
name|outerValue
decl_stmt|;
name|TInner
name|innerValue
decl_stmt|;
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|innerEnumerable
decl_stmt|;
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|innerEnumerator
decl_stmt|;
name|boolean
name|innerEnumHasNext
init|=
literal|false
decl_stmt|;
name|boolean
name|atLeastOneResult
init|=
literal|false
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
comment|// outer position
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
comment|// inner position
annotation|@
name|Override
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|outerValue
argument_list|,
name|innerValue
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// Fetch a new batch
if|if
condition|(
name|i
operator|==
name|outerValues
operator|.
name|size
argument_list|()
operator|||
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|outerValues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|innerValues
operator|.
name|clear
argument_list|()
expr_stmt|;
while|while
condition|(
name|outerValues
operator|.
name|size
argument_list|()
operator|<
name|batchSize
operator|&&
name|outerEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|tSource
init|=
name|outerEnumerator
operator|.
name|current
argument_list|()
decl_stmt|;
name|outerValues
operator|.
name|add
argument_list|(
name|tSource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outerValues
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|innerEnumerable
operator|=
name|inner
operator|.
name|apply
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
comment|// If the last batch isn't complete fill it with the first value
comment|// No harm since it's a disjunction
annotation|@
name|Override
specifier|public
name|TSource
name|get
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|index
operator|<
name|outerValues
operator|.
name|size
argument_list|()
condition|?
name|outerValues
operator|.
name|get
argument_list|(
name|index
argument_list|)
else|:
name|outerValues
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|batchSize
return|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|innerEnumerable
operator|==
literal|null
condition|)
block|{
name|innerEnumerable
operator|=
name|Linq4j
operator|.
name|emptyEnumerable
argument_list|()
expr_stmt|;
block|}
name|innerEnumerator
operator|=
name|innerEnumerable
operator|.
name|enumerator
argument_list|()
expr_stmt|;
name|innerEnumHasNext
operator|=
name|innerEnumerator
operator|.
name|moveNext
argument_list|()
expr_stmt|;
comment|// If no inner values skip the whole batch
comment|// in case of SEMI and INNER join
if|if
condition|(
operator|!
name|innerEnumHasNext
operator|&&
operator|(
name|joinType
operator|==
name|JoinType
operator|.
name|SEMI
operator|||
name|joinType
operator|==
name|JoinType
operator|.
name|INNER
operator|)
condition|)
block|{
name|i
operator|=
name|outerValues
operator|.
name|size
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|innerHasNext
argument_list|()
condition|)
block|{
name|outerValue
operator|=
name|outerValues
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// get current outer value
name|nextInnerValue
argument_list|()
expr_stmt|;
comment|// Compare current block row to current inner value
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|outerValue
argument_list|,
name|innerValue
argument_list|)
condition|)
block|{
name|atLeastOneResult
operator|=
literal|true
expr_stmt|;
comment|// Skip the rest of inner values in case of
comment|// ANTI and SEMI when a match is found
if|if
condition|(
name|joinType
operator|==
name|JoinType
operator|.
name|ANTI
operator|||
name|joinType
operator|==
name|JoinType
operator|.
name|SEMI
condition|)
block|{
comment|// Two ways of skipping inner values,
comment|// enumerator way and ArrayList way
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|innerEnumHasNext
condition|)
block|{
name|innerValues
operator|.
name|add
argument_list|(
name|innerEnumerator
operator|.
name|current
argument_list|()
argument_list|)
expr_stmt|;
name|innerEnumHasNext
operator|=
name|innerEnumerator
operator|.
name|moveNext
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|j
operator|=
name|innerValues
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|joinType
operator|==
name|JoinType
operator|.
name|ANTI
condition|)
block|{
continue|continue;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
comment|// End of inner
if|if
condition|(
operator|!
name|atLeastOneResult
operator|&&
operator|(
name|joinType
operator|==
name|JoinType
operator|.
name|LEFT
operator|||
name|joinType
operator|==
name|JoinType
operator|.
name|ANTI
operator|)
condition|)
block|{
name|outerValue
operator|=
name|outerValues
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// get current outer value
name|innerValue
operator|=
literal|null
expr_stmt|;
name|nextOuterValue
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|nextOuterValue
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|nextOuterValue
parameter_list|()
block|{
name|i
operator|++
expr_stmt|;
comment|// next outerValue
name|j
operator|=
literal|0
expr_stmt|;
comment|// rewind innerValues
name|atLeastOneResult
operator|=
literal|false
expr_stmt|;
block|}
specifier|private
name|void
name|nextInnerValue
parameter_list|()
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|innerValue
operator|=
name|innerEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
name|innerValues
operator|.
name|add
argument_list|(
name|innerValue
argument_list|)
expr_stmt|;
name|innerEnumHasNext
operator|=
name|innerEnumerator
operator|.
name|moveNext
argument_list|()
expr_stmt|;
comment|// next enumerator inner value
block|}
else|else
block|{
name|innerValue
operator|=
name|innerValues
operator|.
name|get
argument_list|(
name|j
operator|++
argument_list|)
expr_stmt|;
comment|// next ArrayList inner value
block|}
block|}
specifier|private
name|boolean
name|innerHasNext
parameter_list|()
block|{
return|return
name|i
operator|==
literal|0
condition|?
name|innerEnumHasNext
else|:
name|j
operator|<
name|innerValues
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|outerEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|innerValue
operator|=
literal|null
expr_stmt|;
name|outerValue
operator|=
literal|null
expr_stmt|;
name|outerValues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|innerValues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|atLeastOneResult
operator|=
literal|false
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|outerEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|innerEnumerator
operator|!=
literal|null
condition|)
block|{
name|innerEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|outerValue
operator|=
literal|null
expr_stmt|;
name|innerValue
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Returns elements of {@code outer} for which there is a member of    * {@code inner} with a matching key.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|semiJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|)
block|{
return|return
name|semiEquiJoin_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|semiJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|semiEquiJoin_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|comparer
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|semiJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|>
name|nonEquiPredicate
parameter_list|)
block|{
return|return
name|semiJoin
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|comparer
argument_list|,
literal|false
argument_list|,
name|nonEquiPredicate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns elements of {@code outer} for which there is NOT a member of    * {@code inner} with a matching key.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|antiJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|)
block|{
return|return
name|semiEquiJoin_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|antiJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|semiEquiJoin_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|comparer
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|antiJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|>
name|nonEquiPredicate
parameter_list|)
block|{
return|return
name|semiJoin
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|comparer
argument_list|,
literal|true
argument_list|,
name|nonEquiPredicate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns elements of {@code outer} for which there is (semi-join) / is not (anti-semi-join)    * a member of {@code inner} with a matching key. A specified    * {@code EqualityComparer<TSource>} is used to compare keys.    * A predicate is used to filter the join result per-row.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|semiJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
specifier|final
name|boolean
name|anti
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|>
name|nonEquiPredicate
parameter_list|)
block|{
if|if
condition|(
name|nonEquiPredicate
operator|==
literal|null
condition|)
block|{
return|return
name|semiEquiJoin_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|comparer
argument_list|,
name|anti
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|semiJoinWithPredicate_
argument_list|(
name|outer
argument_list|,
name|inner
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|comparer
argument_list|,
name|anti
argument_list|,
name|nonEquiPredicate
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|semiJoinWithPredicate_
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
specifier|final
name|boolean
name|anti
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|>
name|nonEquiPredicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
comment|// CALCITE-2909 Delay the computation of the innerLookup until the
comment|// moment when we are sure
comment|// that it will be really needed, i.e. when the first outer
comment|// enumerator item is processed
specifier|final
name|Supplier
argument_list|<
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TInner
argument_list|>
argument_list|>
name|innerLookup
init|=
name|Suppliers
operator|.
name|memoize
argument_list|(
operator|(
operator|)
operator|->
name|comparer
operator|==
literal|null
condition|?
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|)
else|:
name|inner
operator|.
name|toLookup
argument_list|(
name|innerKeySelector
argument_list|,
name|comparer
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
init|=
name|v0
lambda|->
block|{
name|TKey
name|key
init|=
name|outerKeySelector
operator|.
name|apply
argument_list|(
name|v0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|innerLookup
operator|.
name|get
argument_list|()
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
name|anti
return|;
block|}
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|innersOfKey
init|=
name|innerLookup
operator|.
name|get
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|os
init|=
name|innersOfKey
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TInner
name|v1
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|nonEquiPredicate
operator|.
name|apply
argument_list|(
name|v0
argument_list|,
name|v1
argument_list|)
condition|)
block|{
return|return
operator|!
name|anti
return|;
block|}
block|}
return|return
name|anti
return|;
block|}
block|}
decl_stmt|;
return|return
name|EnumerableDefaults
operator|.
name|where
argument_list|(
name|outer
operator|.
name|enumerator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Returns elements of {@code outer} for which there is (semi-join) / is not (anti-semi-join)    * a member of {@code inner} with a matching key. A specified    * {@code EqualityComparer<TSource>} is used to compare keys.    */
end_comment

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|semiEquiJoin_
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|,
specifier|final
name|boolean
name|anti
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
comment|// CALCITE-2909 Delay the computation of the innerLookup until the moment when we are sure
comment|// that it will be really needed, i.e. when the first outer enumerator item is processed
specifier|final
name|Supplier
argument_list|<
name|Enumerable
argument_list|<
name|TKey
argument_list|>
argument_list|>
name|innerLookup
init|=
name|Suppliers
operator|.
name|memoize
argument_list|(
operator|(
operator|)
operator|->
name|comparer
operator|==
literal|null
condition|?
name|inner
operator|.
name|select
argument_list|(
name|innerKeySelector
argument_list|)
operator|.
name|distinct
argument_list|()
else|:
name|inner
operator|.
name|select
argument_list|(
name|innerKeySelector
argument_list|)
operator|.
name|distinct
argument_list|(
name|comparer
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
init|=
name|anti
condition|?
name|v0
lambda|->
operator|!
name|innerLookup
operator|.
name|get
argument_list|()
operator|.
name|contains
argument_list|(
name|outerKeySelector
operator|.
name|apply
argument_list|(
name|v0
argument_list|)
argument_list|)
else|:
name|v0
lambda|->
name|innerLookup
operator|.
name|get
argument_list|()
operator|.
name|contains
argument_list|(
name|outerKeySelector
operator|.
name|apply
argument_list|(
name|v0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|EnumerableDefaults
operator|.
name|where
argument_list|(
name|outer
operator|.
name|enumerator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Correlates the elements of two sequences based on a predicate.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|nestedLoopJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|>
name|predicate
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
specifier|final
name|JoinType
name|joinType
parameter_list|)
block|{
comment|// Building the result as a list is easy but hogs memory. We should iterate.
specifier|final
name|boolean
name|generateNullsOnLeft
init|=
name|joinType
operator|.
name|generatesNullsOnLeft
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|generateNullsOnRight
init|=
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TResult
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|lefts
init|=
name|outer
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TInner
argument_list|>
name|rightList
init|=
name|inner
operator|.
name|toList
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|TInner
argument_list|>
name|rightUnmatched
decl_stmt|;
if|if
condition|(
name|generateNullsOnLeft
condition|)
block|{
name|rightUnmatched
operator|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
expr_stmt|;
name|rightUnmatched
operator|.
name|addAll
argument_list|(
name|rightList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rightUnmatched
operator|=
literal|null
expr_stmt|;
block|}
while|while
condition|(
name|lefts
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|int
name|leftMatchCount
init|=
literal|0
decl_stmt|;
specifier|final
name|TSource
name|left
init|=
name|lefts
operator|.
name|current
argument_list|()
decl_stmt|;
specifier|final
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|rights
init|=
name|Linq4j
operator|.
name|iterableEnumerator
argument_list|(
name|rightList
argument_list|)
decl_stmt|;
while|while
condition|(
name|rights
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TInner
name|right
init|=
name|rights
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
condition|)
block|{
operator|++
name|leftMatchCount
expr_stmt|;
if|if
condition|(
name|joinType
operator|==
name|JoinType
operator|.
name|ANTI
condition|)
block|{
break|break;
block|}
else|else
block|{
if|if
condition|(
name|rightUnmatched
operator|!=
literal|null
condition|)
block|{
name|rightUnmatched
operator|.
name|remove
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
name|resultSelector
operator|.
name|apply
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|leftMatchCount
operator|==
literal|0
operator|&&
operator|(
name|generateNullsOnRight
operator|||
name|joinType
operator|==
name|JoinType
operator|.
name|ANTI
operator|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|resultSelector
operator|.
name|apply
argument_list|(
name|left
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rightUnmatched
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|rights
init|=
name|Linq4j
operator|.
name|iterableEnumerator
argument_list|(
name|rightUnmatched
argument_list|)
decl_stmt|;
while|while
condition|(
name|rights
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TInner
name|right
init|=
name|rights
operator|.
name|current
argument_list|()
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|resultSelector
operator|.
name|apply
argument_list|(
literal|null
argument_list|,
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Joins two inputs that are sorted on the key. */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
extends|extends
name|Comparable
argument_list|<
name|TKey
argument_list|>
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|mergeJoin
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|outer
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|TInner
argument_list|>
name|inner
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|,
name|boolean
name|generateNullsOnLeft
parameter_list|,
name|boolean
name|generateNullsOnRight
parameter_list|)
block|{
if|if
condition|(
name|generateNullsOnLeft
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"not implemented, mergeJoin with generateNullsOnLeft"
argument_list|)
throw|;
block|}
if|if
condition|(
name|generateNullsOnRight
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"not implemented, mergeJoin with generateNullsOnRight"
argument_list|)
throw|;
block|}
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|MergeJoinEnumerator
argument_list|<>
argument_list|(
name|outer
operator|.
name|enumerator
argument_list|()
argument_list|,
name|inner
operator|.
name|enumerator
argument_list|()
argument_list|,
name|outerKeySelector
argument_list|,
name|innerKeySelector
argument_list|,
name|resultSelector
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the last element of a sequence that    * satisfies a specified condition.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|last
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
specifier|final
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
name|list
init|=
name|enumerable
operator|instanceof
name|ListEnumerable
condition|?
operator|(
operator|(
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
operator|)
name|enumerable
operator|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|TSource
argument_list|>
name|rawList
init|=
name|list
operator|.
name|toList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|rawList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|TSource
name|result
init|=
name|rawList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
else|else
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|result
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|result
argument_list|)
condition|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|element
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|result
operator|=
name|element
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
block|}
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
end_function

begin_comment
comment|/**    * Returns the last element of a sequence, or a    * default value if the sequence contains no elements.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|lastOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|)
block|{
specifier|final
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
name|list
init|=
name|enumerable
operator|instanceof
name|ListEnumerable
condition|?
operator|(
operator|(
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
operator|)
name|enumerable
operator|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|TSource
argument_list|>
name|rawList
init|=
name|list
operator|.
name|toList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|rawList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
return|return
name|rawList
operator|.
name|get
argument_list|(
name|count
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
else|else
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|result
decl_stmt|;
do|do
block|{
name|result
operator|=
name|os
operator|.
name|current
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
do|;
return|return
name|result
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the last element of a sequence that    * satisfies a condition or a default value if no such element is    * found.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|lastOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
specifier|final
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
name|list
init|=
name|enumerable
operator|instanceof
name|ListEnumerable
condition|?
operator|(
operator|(
name|ListEnumerable
argument_list|<
name|TSource
argument_list|>
operator|)
name|enumerable
operator|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|TSource
argument_list|>
name|rawList
init|=
name|list
operator|.
name|toList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|rawList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|TSource
name|result
init|=
name|rawList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
else|else
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|result
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|result
argument_list|)
condition|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|element
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|result
operator|=
name|element
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an long that represents the total number    * of elements in a sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|longCount
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
return|return
name|longCount
argument_list|(
name|source
argument_list|,
name|Functions
operator|.
name|truePredicate1
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an long that represents how many elements    * in a sequence satisfy a condition.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|longCount
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
comment|// Shortcut if this is a collection and the predicate is always true.
if|if
condition|(
name|predicate
operator|==
name|Predicate1
operator|.
name|TRUE
operator|&&
name|enumerable
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|(
operator|(
name|Collection
operator|)
name|enumerable
operator|)
operator|.
name|size
argument_list|()
return|;
block|}
name|int
name|n
init|=
literal|0
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|enumerable
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|o
argument_list|)
condition|)
block|{
operator|++
name|n
expr_stmt|;
block|}
block|}
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the maximum value in a generic    * sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
extends|extends
name|Comparable
argument_list|<
name|TSource
argument_list|>
parameter_list|>
name|TSource
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|max
init|=
name|maxFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
argument_list|,
literal|null
argument_list|,
name|max
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum Decimal value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|BigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|>
name|max
init|=
name|maxFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|max
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable Decimal    * value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableBigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|>
name|max
init|=
name|maxFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|max
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum Double value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|double
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|DoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|DOUBLE_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable Double    * value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Double
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableDoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|DOUBLE_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum int value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|IntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|INTEGER_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable int value. (Defined    * by Enumerable.)    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Integer
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableIntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|INTEGER_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum long value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|LongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|LONG_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable long value. (Defined    * by Enumerable.)    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Long
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableLongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|LONG_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum Float value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|float
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|FloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|FLOAT_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the maximum nullable Float    * value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Float
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableFloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|FLOAT_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * generic sequence and returns the maximum resulting    * value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
extends|extends
name|Comparable
argument_list|<
name|TResult
argument_list|>
parameter_list|>
name|TResult
name|max
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|TResult
argument_list|,
name|TResult
argument_list|,
name|TResult
argument_list|>
name|max
init|=
name|maxFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|max
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the minimum value in a generic    * sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
extends|extends
name|Comparable
argument_list|<
name|TSource
argument_list|>
parameter_list|>
name|TSource
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|min
init|=
name|minFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
argument_list|,
literal|null
argument_list|,
name|min
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|TSource
extends|extends
name|Comparable
argument_list|<
name|TSource
argument_list|>
parameter_list|>
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|minFunction
parameter_list|()
block|{
return|return
operator|(
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
operator|)
operator|(
name|Function2
operator|)
name|Extensions
operator|.
name|COMPARABLE_MIN
return|;
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
parameter_list|<
name|TSource
extends|extends
name|Comparable
argument_list|<
name|TSource
argument_list|>
parameter_list|>
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
name|maxFunction
parameter_list|()
block|{
return|return
operator|(
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TSource
argument_list|,
name|TSource
argument_list|>
operator|)
operator|(
name|Function2
operator|)
name|Extensions
operator|.
name|COMPARABLE_MAX
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum Decimal value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|BigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|>
name|min
init|=
name|minFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|min
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable Decimal    * value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableBigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|,
name|BigDecimal
argument_list|>
name|min
init|=
name|minFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|min
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum Double value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|double
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|DoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|DOUBLE_MIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable Double    * value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Double
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableDoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|DOUBLE_MIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum int value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|IntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|INTEGER_MIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable int value. (Defined    * by Enumerable.)    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Integer
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableIntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|INTEGER_MIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum long value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|LongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|LONG_MIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable long value. (Defined    * by Enumerable.)    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Long
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableLongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|LONG_MIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum Float value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|float
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|FloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|FLOAT_MIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * sequence and returns the minimum nullable Float    * value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Float
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableFloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|Extensions
operator|.
name|FLOAT_MIN
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Invokes a transform function on each element of a    * generic sequence and returns the minimum resulting    * value.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
extends|extends
name|Comparable
argument_list|<
name|TResult
argument_list|>
parameter_list|>
name|TResult
name|min
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
name|Function2
argument_list|<
name|TResult
argument_list|,
name|TResult
argument_list|,
name|TResult
argument_list|>
name|min
init|=
name|minFunction
argument_list|()
decl_stmt|;
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|null
argument_list|,
name|min
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Filters the elements of an Enumerable based on a    * specified type.    *    *<p>Analogous to LINQ's Enumerable.OfType extension method.</p>    *    * @param clazz Target type    * @param<TResult> Target type    *    * @return Collection of T2    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|ofType
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|enumerable
parameter_list|,
name|Class
argument_list|<
name|TResult
argument_list|>
name|clazz
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|Enumerable
operator|)
name|where
argument_list|(
name|enumerable
argument_list|,
name|Functions
operator|.
name|ofTypePredicate
argument_list|(
name|clazz
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Sorts the elements of a sequence in ascending    * order according to a key.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
extends|extends
name|Comparable
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|orderBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|orderBy
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Sorts the elements of a sequence in ascending    * order by using a specified comparer.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|orderBy
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|)
block|{
comment|// NOTE: TreeMap allows null comparator. But the caller of this method
comment|// must supply a comparator if the key does not extend Comparable.
comment|// Otherwise there will be a ClassCastException while retrieving.
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|LookupImpl
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|lookup
init|=
name|toLookup_
argument_list|(
name|map
argument_list|,
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
name|identitySelector
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|lookup
operator|.
name|valuesEnumerable
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Sorts the elements of a sequence in descending    * order according to a key.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
extends|extends
name|Comparable
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|orderByDescending
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|orderBy
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Sorts the elements of a sequence in descending    * order by using a specified comparer.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|orderByDescending
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
name|orderBy
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|(
name|comparator
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Inverts the order of the elements in a    * sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|reverse
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|TSource
argument_list|>
name|list
init|=
name|toList
argument_list|(
name|source
argument_list|)
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|list
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|TSource
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
name|n
operator|-
literal|1
operator|-
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|n
return|;
block|}
block|}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Projects each element of a sequence into a new form.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|select
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
if|if
condition|(
name|selector
operator|==
name|Functions
operator|.
name|identitySelector
argument_list|()
condition|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|Enumerable
argument_list|<
name|TResult
argument_list|>
operator|)
name|source
return|;
block|}
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|selector
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|moveNext
argument_list|()
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|enumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Projects each element of a sequence into a new    * form by incorporating the element's index.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|select
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|,
name|TResult
argument_list|>
name|selector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|selector
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
name|n
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
if|if
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|enumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Projects each element of a sequence to an    * {@code Enumerable<TSource>} and flattens the resulting sequences into one    * sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|selectMany
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TResult
argument_list|>
argument_list|>
name|selector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|sourceEnumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|resultEnumerator
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultEnumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|resultEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|sourceEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|resultEnumerator
operator|=
name|selector
operator|.
name|apply
argument_list|(
name|sourceEnumerator
operator|.
name|current
argument_list|()
argument_list|)
operator|.
name|enumerator
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Projects each element of a sequence to an    * {@code Enumerable<TSource>}, and flattens the resulting sequences into one    * sequence. The index of each source element is used in the    * projected form of that element.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|selectMany
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|,
name|Enumerable
argument_list|<
name|TResult
argument_list|>
argument_list|>
name|selector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|sourceEnumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|resultEnumerator
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultEnumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|resultEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|sourceEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|index
operator|+=
literal|1
expr_stmt|;
name|resultEnumerator
operator|=
name|selector
operator|.
name|apply
argument_list|(
name|sourceEnumerator
operator|.
name|current
argument_list|()
argument_list|,
name|index
argument_list|)
operator|.
name|enumerator
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Projects each element of a sequence to an    * {@code Enumerable<TSource>}, flattens the resulting sequences into one    * sequence, and invokes a result selector function on each    * element therein. The index of each source element is used in    * the intermediate projected form of that element.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TCollection
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|selectMany
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|,
name|Enumerable
argument_list|<
name|TCollection
argument_list|>
argument_list|>
name|collectionSelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TCollection
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|sourceEnumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TCollection
argument_list|>
name|collectionEnumerator
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|resultEnumerator
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultEnumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|resultEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|sourceEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|index
operator|+=
literal|1
expr_stmt|;
specifier|final
name|TSource
name|sourceElement
init|=
name|sourceEnumerator
operator|.
name|current
argument_list|()
decl_stmt|;
name|collectionEnumerator
operator|=
name|collectionSelector
operator|.
name|apply
argument_list|(
name|sourceElement
argument_list|,
name|index
argument_list|)
operator|.
name|enumerator
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|=
operator|new
name|TransformedEnumerator
argument_list|<
name|TCollection
argument_list|,
name|TResult
argument_list|>
argument_list|(
name|collectionEnumerator
argument_list|)
block|{
specifier|protected
name|TResult
name|transform
parameter_list|(
name|TCollection
name|collectionElement
parameter_list|)
block|{
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|sourceElement
argument_list|,
name|collectionElement
argument_list|)
return|;
block|}
block|}
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Projects each element of a sequence to an    * {@code Enumerable<TSource>}, flattens the resulting sequences into one    * sequence, and invokes a result selector function on each    * element therein.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TCollection
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|selectMany
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Enumerable
argument_list|<
name|TCollection
argument_list|>
argument_list|>
name|collectionSelector
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TCollection
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|sourceEnumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TCollection
argument_list|>
name|collectionEnumerator
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|resultEnumerator
init|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultEnumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
name|boolean
name|incremented
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|resultEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|sourceEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|TSource
name|sourceElement
init|=
name|sourceEnumerator
operator|.
name|current
argument_list|()
decl_stmt|;
name|collectionEnumerator
operator|=
name|collectionSelector
operator|.
name|apply
argument_list|(
name|sourceElement
argument_list|)
operator|.
name|enumerator
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|=
operator|new
name|TransformedEnumerator
argument_list|<
name|TCollection
argument_list|,
name|TResult
argument_list|>
argument_list|(
name|collectionEnumerator
argument_list|)
block|{
specifier|protected
name|TResult
name|transform
parameter_list|(
name|TCollection
name|collectionElement
parameter_list|)
block|{
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|sourceElement
argument_list|,
name|collectionElement
argument_list|)
return|;
block|}
block|}
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|sourceEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
name|resultEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Determines whether two sequences are equal by    * comparing the elements by using the default equality comparer    * for their type.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|sequenceEqual
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|first
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|second
parameter_list|)
block|{
return|return
name|sequenceEqual
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Determines whether two sequences are equal by    * comparing their elements by using a specified    * {@code EqualityComparer<TSource>}.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|boolean
name|sequenceEqual
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|first
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|second
parameter_list|,
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparer
operator|==
literal|null
condition|)
block|{
name|comparer
operator|=
operator|new
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|equal
parameter_list|(
name|TSource
name|v1
parameter_list|,
name|TSource
name|v2
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|(
name|TSource
name|tSource
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|hashCode
argument_list|(
name|tSource
argument_list|)
return|;
block|}
block|}
expr_stmt|;
block|}
specifier|final
name|CollectionEnumerable
argument_list|<
name|TSource
argument_list|>
name|firstCollection
init|=
name|first
operator|instanceof
name|CollectionEnumerable
condition|?
operator|(
operator|(
name|CollectionEnumerable
argument_list|<
name|TSource
argument_list|>
operator|)
name|first
operator|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|firstCollection
operator|!=
literal|null
condition|)
block|{
specifier|final
name|CollectionEnumerable
argument_list|<
name|TSource
argument_list|>
name|secondCollection
init|=
name|second
operator|instanceof
name|CollectionEnumerable
condition|?
operator|(
operator|(
name|CollectionEnumerable
argument_list|<
name|TSource
argument_list|>
operator|)
name|second
operator|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|secondCollection
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|firstCollection
operator|.
name|getCollection
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|secondCollection
operator|.
name|getCollection
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os1
init|=
name|first
operator|.
name|enumerator
argument_list|()
init|;
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os2
init|=
name|second
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os1
operator|.
name|moveNext
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|os2
operator|.
name|moveNext
argument_list|()
operator|&&
name|comparer
operator|.
name|equal
argument_list|(
name|os1
operator|.
name|current
argument_list|()
argument_list|,
name|os2
operator|.
name|current
argument_list|()
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
operator|!
name|os2
operator|.
name|moveNext
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns the only element of a sequence, and throws    * an exception if there is not exactly one element in the    * sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|single
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
name|TSource
name|toRet
init|=
literal|null
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|toRet
operator|=
name|os
operator|.
name|current
argument_list|()
expr_stmt|;
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
block|}
if|if
condition|(
name|toRet
operator|!=
literal|null
condition|)
block|{
return|return
name|toRet
return|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns the only element of a sequence that    * satisfies a specified condition, and throws an exception if    * more than one such element exists.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|single
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
name|TSource
name|toRet
init|=
literal|null
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|os
operator|.
name|current
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|toRet
operator|==
literal|null
condition|)
block|{
name|toRet
operator|=
name|os
operator|.
name|current
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
block|}
block|}
if|if
condition|(
name|toRet
operator|!=
literal|null
condition|)
block|{
return|return
name|toRet
return|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns the only element of a sequence, or a    * default value if the sequence is empty; this method throws an    * exception if there is more than one element in the    * sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|singleOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
name|TSource
name|toRet
init|=
literal|null
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|toRet
operator|=
name|os
operator|.
name|current
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|toRet
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Returns the only element of a sequence that    * satisfies a specified condition or a default value if no such    * element exists; this method throws an exception if more than    * one element satisfies the condition.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|TSource
name|singleOrDefault
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
name|TSource
name|toRet
init|=
literal|null
decl_stmt|;
for|for
control|(
name|TSource
name|s
range|:
name|source
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|toRet
operator|!=
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|toRet
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
return|return
name|toRet
return|;
block|}
end_function

begin_comment
comment|/**    * Bypasses a specified number of elements in a    * sequence and then returns the remaining elements.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|skip
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|int
name|count
parameter_list|)
block|{
return|return
name|skipWhile
argument_list|(
name|source
argument_list|,
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
lambda|->
block|{
comment|// Count is 1-based
return|return
name|v2
operator|<
name|count
return|;
block|}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Bypasses elements in a sequence as long as a    * specified condition is true and then returns the remaining    * elements.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|skipWhile
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|skipWhile
argument_list|(
name|source
argument_list|,
name|Functions
operator|.
name|toPredicate2
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Bypasses elements in a sequence as long as a    * specified condition is true and then returns the remaining    * elements. The element's index is used in the logic of the    * predicate function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|skipWhile
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|SkipWhileEnumerator
argument_list|<>
argument_list|(
name|source
operator|.
name|enumerator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of Decimal values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|BigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|Extensions
operator|.
name|BIG_DECIMAL_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of nullable    * Decimal values that are obtained by invoking a transform    * function on each element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|BigDecimal
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableBigDecimalFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|Extensions
operator|.
name|BIG_DECIMAL_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of Double values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|double
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|DoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|0d
argument_list|,
name|Extensions
operator|.
name|DOUBLE_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of nullable    * Double values that are obtained by invoking a transform    * function on each element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Double
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableDoubleFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|0d
argument_list|,
name|Extensions
operator|.
name|DOUBLE_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of int values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|int
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|IntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Extensions
operator|.
name|INTEGER_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of nullable int    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Integer
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableIntegerFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Extensions
operator|.
name|INTEGER_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of long values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|long
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|LongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|0L
argument_list|,
name|Extensions
operator|.
name|LONG_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of nullable long    * values that are obtained by invoking a transform function on    * each element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Long
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableLongFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|0L
argument_list|,
name|Extensions
operator|.
name|LONG_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of Float values    * that are obtained by invoking a transform function on each    * element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|float
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|FloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|adapt
argument_list|(
name|selector
argument_list|)
argument_list|)
argument_list|,
literal|0F
argument_list|,
name|Extensions
operator|.
name|FLOAT_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Computes the sum of the sequence of nullable    * Float values that are obtained by invoking a transform    * function on each element of the input sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Float
name|sum
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|NullableFloatFunction1
argument_list|<
name|TSource
argument_list|>
name|selector
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|source
operator|.
name|select
argument_list|(
name|selector
argument_list|)
argument_list|,
literal|0F
argument_list|,
name|Extensions
operator|.
name|FLOAT_SUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a specified number of contiguous elements    * from the start of a sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|take
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|int
name|count
parameter_list|)
block|{
return|return
name|takeWhile
argument_list|(
name|source
argument_list|,
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
lambda|->
block|{
comment|// Count is 1-based
return|return
name|v2
operator|<
name|count
return|;
block|}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a specified number of contiguous elements    * from the start of a sequence.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|take
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|long
name|count
parameter_list|)
block|{
return|return
name|takeWhileLong
argument_list|(
name|source
argument_list|,
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
lambda|->
block|{
comment|// Count is 1-based
return|return
name|v2
operator|<
name|count
return|;
block|}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns elements from a sequence as long as a    * specified condition is true.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|takeWhile
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
name|takeWhile
argument_list|(
name|source
argument_list|,
name|Functions
operator|.
name|toPredicate2
argument_list|(
name|predicate
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns elements from a sequence as long as a    * specified condition is true. The element's index is used in the    * logic of the predicate function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|takeWhile
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|TakeWhileEnumerator
argument_list|<>
argument_list|(
name|source
operator|.
name|enumerator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Returns elements from a sequence as long as a    * specified condition is true. The element's index is used in the    * logic of the predicate function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|takeWhileLong
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Long
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|TakeWhileLongEnumerator
argument_list|<>
argument_list|(
name|source
operator|.
name|enumerator
argument_list|()
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Performs a subsequent ordering of the elements in a sequence according    * to a key.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|createOrderedEnumerable
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|,
name|boolean
name|descending
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
end_function

begin_comment
comment|/**    * Performs a subsequent ordering of the elements in a sequence in    * ascending order according to a key.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
extends|extends
name|Comparable
argument_list|<
name|TKey
argument_list|>
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|thenBy
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|createOrderedEnumerable
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Extensions
operator|.
name|comparableComparator
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Performs a subsequent ordering of the elements in a sequence in    * ascending order according to a key, using a specified comparator.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|thenBy
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
name|createOrderedEnumerable
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|comparator
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Performs a subsequent ordering of the elements in a sequence in    * descending order according to a key.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
extends|extends
name|Comparable
argument_list|<
name|TKey
argument_list|>
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|thenByDescending
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|createOrderedEnumerable
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Extensions
operator|.
name|comparableComparator
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Performs a subsequent ordering of the elements in a sequence in    * descending order according to a key, using a specified comparator.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|thenByDescending
parameter_list|(
name|OrderedEnumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Comparator
argument_list|<
name|TKey
argument_list|>
name|comparator
parameter_list|)
block|{
return|return
name|createOrderedEnumerable
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|comparator
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a Map&lt;TKey, TValue&gt; from an    * Enumerable&lt;TSource&gt; according to a specified key selector    * function.    *    *<p>NOTE: Called {@code toDictionary} in LINQ.NET.</p>    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Map
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|toMap
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|toMap
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
name|identitySelector
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code Map<TKey, TValue>} from an    * {@code Enumerable<TSource>} according to a specified key selector function    * and key comparer.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Map
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|toMap
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|toMap
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
name|identitySelector
argument_list|()
argument_list|,
name|comparer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code Map<TKey, TValue>} from an    * {@code Enumerable<TSource>} according to specified key selector and element    * selector functions.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Map
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toMap
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|)
block|{
comment|// Use LinkedHashMap because groupJoin requires order of keys to be
comment|// preserved.
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|,
name|elementSelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code Map<TKey, TValue>} from an    * {@code Enumerable<TSource>} according to a specified key selector function,    * a comparer, and an element selector function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Map
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toMap
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
comment|// Use LinkedHashMap because groupJoin requires order of keys to be
comment|// preserved.
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|map
init|=
operator|new
name|WrapMap
argument_list|<>
argument_list|(
comment|// Java 8 cannot infer return type with LinkedHashMap::new is used
parameter_list|()
lambda|->
operator|new
name|LinkedHashMap
argument_list|<
name|Wrapped
argument_list|<
name|TKey
argument_list|>
argument_list|,
name|TElement
argument_list|>
argument_list|()
argument_list|,
name|comparer
argument_list|)
decl_stmt|;
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|,
name|elementSelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code List<TSource>} from an {@code Enumerable<TSource>}.    */
end_comment

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|List
argument_list|<
name|TSource
argument_list|>
name|toList
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|instanceof
name|List
operator|&&
name|source
operator|instanceof
name|RandomAccess
condition|)
block|{
return|return
operator|(
name|List
argument_list|<
name|TSource
argument_list|>
operator|)
name|source
return|;
block|}
else|else
block|{
return|return
name|source
operator|.
name|into
argument_list|(
name|source
operator|instanceof
name|Collection
condition|?
operator|new
name|ArrayList
argument_list|<>
argument_list|(
operator|(
operator|(
name|Collection
operator|)
name|source
operator|)
operator|.
name|size
argument_list|()
argument_list|)
else|:
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * Creates a Lookup&lt;TKey, TElement&gt; from an    * Enumerable&lt;TSource&gt; according to a specified key selector    * function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|toLookup
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|)
block|{
return|return
name|toLookup
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
name|identitySelector
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code Lookup<TKey, TElement>} from an    * {@code Enumerable<TSource>} according to a specified key selector function    * and key comparer.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|>
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TSource
argument_list|>
name|toLookup
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|toLookup
argument_list|(
name|source
argument_list|,
name|keySelector
argument_list|,
name|Functions
operator|.
name|identitySelector
argument_list|()
argument_list|,
name|comparer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code Lookup<TKey, TElement>} from an    * {@code Enumerable<TSource>} according to specified key selector and element    * selector functions.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toLookup
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TElement
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
return|return
name|toLookup_
argument_list|(
name|map
argument_list|,
name|source
argument_list|,
name|keySelector
argument_list|,
name|elementSelector
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|LookupImpl
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toLookup_
parameter_list|(
name|Map
argument_list|<
name|TKey
argument_list|,
name|List
argument_list|<
name|TElement
argument_list|>
argument_list|>
name|map
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|os
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|os
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|TSource
name|o
init|=
name|os
operator|.
name|current
argument_list|()
decl_stmt|;
specifier|final
name|TKey
name|key
init|=
name|keySelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TElement
argument_list|>
name|list
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
comment|// for first entry, use a singleton list to save space
name|list
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|elementSelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// when we go from 1 to 2 elements, switch to array list
name|TElement
name|element
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|elementSelector
operator|.
name|apply
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|LookupImpl
argument_list|<>
argument_list|(
name|map
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@code Lookup<TKey, TElement>} from an    * {@code Enumerable<TSource>} according to a specified key selector function,    * a comparer and an element selector function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|,
name|TKey
parameter_list|,
name|TElement
parameter_list|>
name|Lookup
argument_list|<
name|TKey
argument_list|,
name|TElement
argument_list|>
name|toLookup
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|keySelector
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TElement
argument_list|>
name|elementSelector
parameter_list|,
name|EqualityComparer
argument_list|<
name|TKey
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|toLookup_
argument_list|(
operator|new
name|WrapMap
argument_list|<>
argument_list|(
comment|// Java 8 cannot infer return type with HashMap::new is used
parameter_list|()
lambda|->
operator|new
name|HashMap
argument_list|<
name|Wrapped
argument_list|<
name|TKey
argument_list|>
argument_list|,
name|List
argument_list|<
name|TElement
argument_list|>
argument_list|>
argument_list|()
argument_list|,
name|comparer
argument_list|)
argument_list|,
name|source
argument_list|,
name|keySelector
argument_list|,
name|elementSelector
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Produces the set union of two sequences by using    * the default equality comparer.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|union
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|)
block|{
name|Set
argument_list|<
name|TSource
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|source0
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|source1
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Produces the set union of two sequences by using a    * specified EqualityComparer&lt;TSource&gt;.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|union
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source0
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source1
parameter_list|,
specifier|final
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
if|if
condition|(
name|comparer
operator|==
name|Functions
operator|.
name|identityComparer
argument_list|()
condition|)
block|{
return|return
name|union
argument_list|(
name|source0
argument_list|,
name|source1
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapper
init|=
name|wrapperFor
argument_list|(
name|comparer
argument_list|)
decl_stmt|;
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
init|=
name|unwrapper
argument_list|()
decl_stmt|;
name|source0
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|source1
operator|.
name|select
argument_list|(
name|wrapper
argument_list|)
operator|.
name|into
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|set
argument_list|)
operator|.
name|select
argument_list|(
name|unwrapper
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Function1
argument_list|<
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|,
name|TSource
argument_list|>
name|unwrapper
parameter_list|()
block|{
return|return
name|a0
lambda|->
name|a0
operator|.
name|element
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Function1
argument_list|<
name|TSource
argument_list|,
name|Wrapped
argument_list|<
name|TSource
argument_list|>
argument_list|>
name|wrapperFor
parameter_list|(
specifier|final
name|EqualityComparer
argument_list|<
name|TSource
argument_list|>
name|comparer
parameter_list|)
block|{
return|return
name|a0
lambda|->
name|Wrapped
operator|.
name|upAs
argument_list|(
name|comparer
argument_list|,
name|a0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Filters a sequence of values based on a    * predicate.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|where
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
assert|assert
name|predicate
operator|!=
literal|null
assert|;
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
return|return
name|EnumerableDefaults
operator|.
name|where
argument_list|(
name|enumerator
argument_list|,
name|predicate
argument_list|)
return|;
block|}
block|}
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|where
parameter_list|(
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|,
specifier|final
name|Predicate1
argument_list|<
name|TSource
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
while|while
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|enumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Filters a sequence of values based on a    * predicate. Each element's index is used in the logic of the    * predicate function.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|where
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|source
parameter_list|,
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
while|while
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
name|n
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|enumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Applies a specified function to the corresponding    * elements of two sequences, producing a sequence of the    * results.    */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|T0
parameter_list|,
name|T1
parameter_list|,
name|TResult
parameter_list|>
name|Enumerable
argument_list|<
name|TResult
argument_list|>
name|zip
parameter_list|(
specifier|final
name|Enumerable
argument_list|<
name|T0
argument_list|>
name|first
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|T1
argument_list|>
name|second
parameter_list|,
specifier|final
name|Function2
argument_list|<
name|T0
argument_list|,
name|T1
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|TResult
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|final
name|Enumerator
argument_list|<
name|T0
argument_list|>
name|e1
init|=
name|first
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|final
name|Enumerator
argument_list|<
name|T1
argument_list|>
name|e2
init|=
name|second
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|public
name|TResult
name|current
parameter_list|()
block|{
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|e1
operator|.
name|current
argument_list|()
argument_list|,
name|e2
operator|.
name|current
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
name|e1
operator|.
name|moveNext
argument_list|()
operator|&&
name|e2
operator|.
name|moveNext
argument_list|()
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|e1
operator|.
name|reset
argument_list|()
expr_stmt|;
name|e2
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|e1
operator|.
name|close
argument_list|()
expr_stmt|;
name|e2
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_function
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|OrderedQueryable
argument_list|<
name|T
argument_list|>
name|asOrderedQueryable
parameter_list|(
name|Enumerable
argument_list|<
name|T
argument_list|>
name|source
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|source
operator|instanceof
name|OrderedQueryable
condition|?
operator|(
operator|(
name|OrderedQueryable
argument_list|<
name|T
argument_list|>
operator|)
name|source
operator|)
else|:
operator|new
name|EnumerableOrderedQueryable
argument_list|<>
argument_list|(
name|source
argument_list|,
operator|(
name|Class
operator|)
name|Object
operator|.
name|class
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Default implementation of {@link ExtendedEnumerable#into(Collection)}. */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|C
extends|extends
name|Collection
argument_list|<
name|?
super|super
name|T
argument_list|>
parameter_list|>
name|C
name|into
parameter_list|(
name|Enumerable
argument_list|<
name|T
argument_list|>
name|source
parameter_list|,
name|C
name|sink
parameter_list|)
block|{
try|try
init|(
name|Enumerator
argument_list|<
name|T
argument_list|>
name|enumerator
init|=
name|source
operator|.
name|enumerator
argument_list|()
init|)
block|{
while|while
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|T
name|t
init|=
name|enumerator
operator|.
name|current
argument_list|()
decl_stmt|;
name|sink
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sink
return|;
block|}
end_function

begin_comment
comment|/** Default implementation of {@link ExtendedEnumerable#removeAll(Collection)}. */
end_comment

begin_function
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|C
extends|extends
name|Collection
argument_list|<
name|?
super|super
name|T
argument_list|>
parameter_list|>
name|C
name|remove
parameter_list|(
name|Enumerable
argument_list|<
name|T
argument_list|>
name|source
parameter_list|,
name|C
name|sink
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|tempList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|source
operator|.
name|into
argument_list|(
name|tempList
argument_list|)
expr_stmt|;
name|sink
operator|.
name|removeAll
argument_list|(
name|tempList
argument_list|)
expr_stmt|;
return|return
name|sink
return|;
block|}
end_function

begin_comment
comment|/** Enumerable that implements take-while.    *    * @param<TSource> element type */
end_comment

begin_class
specifier|static
class|class
name|TakeWhileEnumerator
parameter_list|<
name|TSource
parameter_list|>
implements|implements
name|Enumerator
argument_list|<
name|TSource
argument_list|>
block|{
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
decl_stmt|;
specifier|private
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|TakeWhileEnumerator
parameter_list|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|,
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|enumerator
operator|=
name|enumerator
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
operator|&&
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
operator|++
name|n
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|done
operator|=
literal|false
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|enumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/** Enumerable that implements take-while.    *    * @param<TSource> element type */
end_comment

begin_class
specifier|static
class|class
name|TakeWhileLongEnumerator
parameter_list|<
name|TSource
parameter_list|>
implements|implements
name|Enumerator
argument_list|<
name|TSource
argument_list|>
block|{
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
decl_stmt|;
specifier|private
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Long
argument_list|>
name|predicate
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
name|long
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|TakeWhileLongEnumerator
parameter_list|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|,
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Long
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|enumerator
operator|=
name|enumerator
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|enumerator
operator|.
name|moveNext
argument_list|()
operator|&&
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
operator|++
name|n
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|done
operator|=
literal|false
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|enumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/** Enumerator that implements skip-while.    *    * @param<TSource> element type */
end_comment

begin_class
specifier|static
class|class
name|SkipWhileEnumerator
parameter_list|<
name|TSource
parameter_list|>
implements|implements
name|Enumerator
argument_list|<
name|TSource
argument_list|>
block|{
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
decl_stmt|;
specifier|private
specifier|final
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
decl_stmt|;
name|boolean
name|started
init|=
literal|false
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|SkipWhileEnumerator
parameter_list|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|,
name|Predicate2
argument_list|<
name|TSource
argument_list|,
name|Integer
argument_list|>
name|predicate
parameter_list|)
block|{
name|this
operator|.
name|enumerator
operator|=
name|enumerator
expr_stmt|;
name|this
operator|.
name|predicate
operator|=
name|predicate
expr_stmt|;
block|}
specifier|public
name|TSource
name|current
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|current
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|enumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|started
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|predicate
operator|.
name|apply
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|,
operator|++
name|n
argument_list|)
condition|)
block|{
name|started
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|started
operator|=
literal|false
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|enumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/** Enumerator that casts each value.    *    * @param<T> element type */
end_comment

begin_class
specifier|static
class|class
name|CastingEnumerator
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Enumerator
argument_list|<
name|T
argument_list|>
block|{
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|?
argument_list|>
name|enumerator
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
decl_stmt|;
name|CastingEnumerator
parameter_list|(
name|Enumerator
argument_list|<
name|?
argument_list|>
name|enumerator
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
name|this
operator|.
name|enumerator
operator|=
name|enumerator
expr_stmt|;
name|this
operator|.
name|clazz
operator|=
name|clazz
expr_stmt|;
block|}
specifier|public
name|T
name|current
parameter_list|()
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|enumerator
operator|.
name|current
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
return|return
name|enumerator
operator|.
name|moveNext
argument_list|()
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|enumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|enumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/** Value wrapped with a comparer.    *    * @param<T> element type */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|Wrapped
parameter_list|<
name|T
parameter_list|>
block|{
specifier|private
specifier|final
name|EqualityComparer
argument_list|<
name|T
argument_list|>
name|comparer
decl_stmt|;
specifier|private
specifier|final
name|T
name|element
decl_stmt|;
specifier|private
name|Wrapped
parameter_list|(
name|EqualityComparer
argument_list|<
name|T
argument_list|>
name|comparer
parameter_list|,
name|T
name|element
parameter_list|)
block|{
name|this
operator|.
name|comparer
operator|=
name|comparer
expr_stmt|;
name|this
operator|.
name|element
operator|=
name|element
expr_stmt|;
block|}
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Wrapped
argument_list|<
name|T
argument_list|>
name|upAs
parameter_list|(
name|EqualityComparer
argument_list|<
name|T
argument_list|>
name|comparer
parameter_list|,
name|T
name|element
parameter_list|)
block|{
return|return
operator|new
name|Wrapped
argument_list|<>
argument_list|(
name|comparer
argument_list|,
name|element
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|comparer
operator|.
name|hashCode
argument_list|(
name|element
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|obj
operator|==
name|this
operator|||
name|obj
operator|instanceof
name|Wrapped
operator|&&
name|comparer
operator|.
name|equal
argument_list|(
name|element
argument_list|,
operator|(
operator|(
name|Wrapped
argument_list|<
name|T
argument_list|>
operator|)
name|obj
operator|)
operator|.
name|element
argument_list|)
return|;
block|}
specifier|public
name|T
name|unwrap
parameter_list|()
block|{
return|return
name|element
return|;
block|}
block|}
end_class

begin_comment
comment|/** Map that wraps each value.    *    * @param<K> key type    * @param<V> value type */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|WrapMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|Wrapped
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
specifier|private
specifier|final
name|EqualityComparer
argument_list|<
name|K
argument_list|>
name|comparer
decl_stmt|;
specifier|protected
name|WrapMap
parameter_list|(
name|Function0
argument_list|<
name|Map
argument_list|<
name|Wrapped
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
argument_list|>
name|mapProvider
parameter_list|,
name|EqualityComparer
argument_list|<
name|K
argument_list|>
name|comparer
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|mapProvider
operator|.
name|apply
argument_list|()
expr_stmt|;
name|this
operator|.
name|comparer
operator|=
name|comparer
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Wrapped
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
name|Entry
argument_list|<
name|Wrapped
argument_list|<
name|K
argument_list|>
argument_list|,
name|V
argument_list|>
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|new
name|SimpleEntry
argument_list|<>
argument_list|(
name|next
operator|.
name|getKey
argument_list|()
operator|.
name|element
argument_list|,
name|next
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|wrap
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|Wrapped
argument_list|<
name|K
argument_list|>
name|wrap
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|Wrapped
operator|.
name|upAs
argument_list|(
name|comparer
argument_list|,
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|wrap
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|map
operator|.
name|put
argument_list|(
name|wrap
argument_list|(
name|key
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|wrap
argument_list|(
operator|(
name|K
operator|)
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|map
operator|.
name|values
argument_list|()
return|;
block|}
block|}
end_class

begin_comment
comment|/** Reads a populated map, applying a selector function.    *    * @param<TResult> result type    * @param<TKey> key type    * @param<TAccumulate> accumulator type */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|LookupResultEnumerable
parameter_list|<
name|TResult
parameter_list|,
name|TKey
parameter_list|,
name|TAccumulate
parameter_list|>
extends|extends
name|AbstractEnumerable2
argument_list|<
name|TResult
argument_list|>
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
name|map
decl_stmt|;
specifier|private
specifier|final
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
decl_stmt|;
name|LookupResultEnumerable
parameter_list|(
name|Map
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
name|map
parameter_list|,
name|Function2
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|resultSelector
operator|=
name|resultSelector
expr_stmt|;
block|}
specifier|public
name|Iterator
argument_list|<
name|TResult
argument_list|>
name|iterator
parameter_list|()
block|{
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
argument_list|>
name|iterator
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|TResult
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
specifier|public
name|TResult
name|next
parameter_list|()
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|TKey
argument_list|,
name|TAccumulate
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
end_class

begin_comment
comment|/** Enumerator that performs a merge join on its sorted inputs.    *    * @param<TResult> result type    * @param<TSource> left input record type    * @param<TKey> key type    * @param<TInner> right input record type */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|MergeJoinEnumerator
parameter_list|<
name|TResult
parameter_list|,
name|TSource
parameter_list|,
name|TInner
parameter_list|,
name|TKey
extends|extends
name|Comparable
parameter_list|<
name|TKey
parameter_list|>
parameter_list|>
implements|implements
name|Enumerator
argument_list|<
name|TResult
argument_list|>
block|{
specifier|final
name|List
argument_list|<
name|TSource
argument_list|>
name|lefts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TInner
argument_list|>
name|rights
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|leftEnumerator
decl_stmt|;
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|rightEnumerator
decl_stmt|;
specifier|private
specifier|final
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
decl_stmt|;
specifier|private
specifier|final
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
decl_stmt|;
specifier|private
specifier|final
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
decl_stmt|;
name|boolean
name|done
decl_stmt|;
name|Enumerator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|cartesians
decl_stmt|;
name|MergeJoinEnumerator
parameter_list|(
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|leftEnumerator
parameter_list|,
name|Enumerator
argument_list|<
name|TInner
argument_list|>
name|rightEnumerator
parameter_list|,
name|Function1
argument_list|<
name|TSource
argument_list|,
name|TKey
argument_list|>
name|outerKeySelector
parameter_list|,
name|Function1
argument_list|<
name|TInner
argument_list|,
name|TKey
argument_list|>
name|innerKeySelector
parameter_list|,
name|Function2
argument_list|<
name|TSource
argument_list|,
name|TInner
argument_list|,
name|TResult
argument_list|>
name|resultSelector
parameter_list|)
block|{
name|this
operator|.
name|leftEnumerator
operator|=
name|leftEnumerator
expr_stmt|;
name|this
operator|.
name|rightEnumerator
operator|=
name|rightEnumerator
expr_stmt|;
name|this
operator|.
name|outerKeySelector
operator|=
name|outerKeySelector
expr_stmt|;
name|this
operator|.
name|innerKeySelector
operator|=
name|innerKeySelector
expr_stmt|;
name|this
operator|.
name|resultSelector
operator|=
name|resultSelector
expr_stmt|;
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
operator|!
name|leftEnumerator
operator|.
name|moveNext
argument_list|()
operator|||
operator|!
name|rightEnumerator
operator|.
name|moveNext
argument_list|()
operator|||
operator|!
name|advance
argument_list|()
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|cartesians
operator|=
name|Linq4j
operator|.
name|emptyEnumerator
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Moves to the next key that is present in both sides. Populates      * lefts and rights with the rows. Restarts the cross-join      * enumerator. */
specifier|private
name|boolean
name|advance
parameter_list|()
block|{
name|TSource
name|left
init|=
name|leftEnumerator
operator|.
name|current
argument_list|()
decl_stmt|;
name|TKey
name|leftKey
init|=
name|outerKeySelector
operator|.
name|apply
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|TInner
name|right
init|=
name|rightEnumerator
operator|.
name|current
argument_list|()
decl_stmt|;
name|TKey
name|rightKey
init|=
name|innerKeySelector
operator|.
name|apply
argument_list|(
name|right
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|leftKey
operator|.
name|compareTo
argument_list|(
name|rightKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|leftEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|left
operator|=
name|leftEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
name|leftKey
operator|=
name|outerKeySelector
operator|.
name|apply
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rightEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|right
operator|=
name|rightEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
name|rightKey
operator|=
name|innerKeySelector
operator|.
name|apply
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
block|}
name|lefts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lefts
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|leftEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|left
operator|=
name|leftEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
name|TKey
name|leftKey2
init|=
name|outerKeySelector
operator|.
name|apply
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|leftKey
operator|.
name|compareTo
argument_list|(
name|leftKey2
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"mergeJoin assumes inputs sorted in ascending order, "
operator|+
literal|"however "
operator|+
name|leftKey
operator|+
literal|" is greater than "
operator|+
name|leftKey2
argument_list|)
throw|;
block|}
break|break;
block|}
name|lefts
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|}
name|rights
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rights
operator|.
name|add
argument_list|(
name|right
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|rightEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|right
operator|=
name|rightEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
name|TKey
name|rightKey2
init|=
name|innerKeySelector
operator|.
name|apply
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|rightKey
operator|.
name|compareTo
argument_list|(
name|rightKey2
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"mergeJoin assumes input sorted in ascending order, "
operator|+
literal|"however "
operator|+
name|rightKey
operator|+
literal|" is greater than "
operator|+
name|rightKey2
argument_list|)
throw|;
block|}
break|break;
block|}
name|rights
operator|.
name|add
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
name|cartesians
operator|=
name|Linq4j
operator|.
name|product
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|lefts
argument_list|)
argument_list|,
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|rights
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|TResult
name|current
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
name|cartesians
operator|.
name|current
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|TSource
name|left
init|=
operator|(
name|TSource
operator|)
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|TInner
name|right
init|=
operator|(
name|TInner
operator|)
name|list
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|resultSelector
operator|.
name|apply
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cartesians
operator|.
name|moveNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|done
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|advance
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|done
operator|=
literal|false
expr_stmt|;
name|leftEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|rightEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|start
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
block|}
end_class

begin_decl_stmt
specifier|private
specifier|static
specifier|final
name|Object
name|DUMMY
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * Repeat Union All enumerable: it will evaluate the seed enumerable once, and then    * it will start to evaluate the iteration enumerable over and over until either it returns    * no results, or an optional maximum numbers of iterations is reached    * @param seed seed enumerable    * @param iteration iteration enumerable    * @param iterationLimit maximum numbers of repetitions for the iteration enumerable    *                       (negative value means no limit)    * @param<TSource> record type    */
end_comment

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|repeatUnionAll
parameter_list|(
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|seed
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|iteration
parameter_list|,
name|int
name|iterationLimit
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|private
name|TSource
name|current
init|=
operator|(
name|TSource
operator|)
name|DUMMY
decl_stmt|;
specifier|private
name|boolean
name|seedProcessed
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|currentIteration
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|seedEnumerator
init|=
name|seed
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|private
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|iterativeEnumerator
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TSource
name|current
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|current
operator|==
name|DUMMY
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|this
operator|.
name|current
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
comment|// if we are not done with the seed moveNext on it
if|if
condition|(
operator|!
name|this
operator|.
name|seedProcessed
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|seedEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|this
operator|.
name|current
operator|=
name|this
operator|.
name|seedEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|this
operator|.
name|seedProcessed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// if we are done with the seed, moveNext on the iterative part
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|iterationLimit
operator|>=
literal|0
operator|&&
name|this
operator|.
name|currentIteration
operator|==
name|iterationLimit
condition|)
block|{
comment|// max number of iterations reached, we are done
name|this
operator|.
name|current
operator|=
operator|(
name|TSource
operator|)
name|DUMMY
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|iterativeEnumerator
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|iterativeEnumerator
operator|=
name|iteration
operator|.
name|enumerator
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|iterativeEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|this
operator|.
name|current
operator|=
name|this
operator|.
name|iterativeEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|this
operator|.
name|current
operator|==
name|DUMMY
condition|)
block|{
comment|// current iteration did not return any value, we are done
return|return
literal|false
return|;
block|}
comment|// current iteration level (which returned some values) is finished, go to next one
name|this
operator|.
name|current
operator|=
operator|(
name|TSource
operator|)
name|DUMMY
expr_stmt|;
name|this
operator|.
name|iterativeEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|iterativeEnumerator
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentIteration
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|this
operator|.
name|seedEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|iterativeEnumerator
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|iterativeEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|iterativeEnumerator
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|currentIteration
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|seedEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|iterativeEnumerator
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|iterativeEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
comment|/**    * Lazy read and lazy write spool that stores data into a collection    */
end_comment

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|TSource
parameter_list|>
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|lazyCollectionSpool
parameter_list|(
name|Collection
argument_list|<
name|TSource
argument_list|>
name|outputCollection
parameter_list|,
name|Enumerable
argument_list|<
name|TSource
argument_list|>
name|input
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|TSource
argument_list|>
argument_list|()
block|{
specifier|private
name|TSource
name|current
init|=
operator|(
name|TSource
operator|)
name|DUMMY
decl_stmt|;
specifier|private
specifier|final
name|Enumerator
argument_list|<
name|TSource
argument_list|>
name|inputEnumerator
init|=
name|input
operator|.
name|enumerator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Collection
argument_list|<
name|TSource
argument_list|>
name|collection
init|=
name|outputCollection
decl_stmt|;
specifier|private
specifier|final
name|Collection
argument_list|<
name|TSource
argument_list|>
name|tempCollection
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TSource
name|current
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|current
operator|==
name|DUMMY
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|this
operator|.
name|current
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|inputEnumerator
operator|.
name|moveNext
argument_list|()
condition|)
block|{
name|this
operator|.
name|current
operator|=
name|this
operator|.
name|inputEnumerator
operator|.
name|current
argument_list|()
expr_stmt|;
name|this
operator|.
name|tempCollection
operator|.
name|add
argument_list|(
name|this
operator|.
name|current
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|this
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|flush
parameter_list|()
block|{
name|this
operator|.
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|collection
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|tempCollection
argument_list|)
expr_stmt|;
name|this
operator|.
name|tempCollection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|this
operator|.
name|inputEnumerator
operator|.
name|reset
argument_list|()
expr_stmt|;
name|this
operator|.
name|collection
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|tempCollection
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|inputEnumerator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
end_function

begin_comment
unit|}
comment|// End EnumerableDefaults.java
end_comment

end_unit

