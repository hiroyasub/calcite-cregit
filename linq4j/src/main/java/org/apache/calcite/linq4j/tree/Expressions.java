begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Extensions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function0
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Predicate1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Predicate2
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Member
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_comment
comment|/**  * Utility methods for expressions, including a lot of factory methods.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Expressions
block|{
specifier|private
name|Expressions
parameter_list|()
block|{
block|}
comment|/**    * Converts a list of expressions to Java source code, optionally emitting    * extra type information in generics.    */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Node
argument_list|>
name|expressions
parameter_list|,
name|String
name|sep
parameter_list|,
name|boolean
name|generics
parameter_list|)
block|{
specifier|final
name|ExpressionWriter
name|writer
init|=
operator|new
name|ExpressionWriter
argument_list|(
name|generics
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
name|expression
range|:
name|expressions
control|)
block|{
name|writer
operator|.
name|write
argument_list|(
name|expression
argument_list|)
expr_stmt|;
name|writer
operator|.
name|append
argument_list|(
name|sep
argument_list|)
expr_stmt|;
block|}
return|return
name|writer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Converts an expression to Java source code.    */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Node
name|expression
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|expression
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * addition operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|add
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Add
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * addition operation that does not have overflow checking. The    * implementing method can be specified.    */
specifier|public
specifier|static
name|BinaryExpression
name|add
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an addition    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|addAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AddAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an addition    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|addAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an addition    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|addAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaLeft
parameter_list|,
name|LambdaExpression
name|lambdaRight
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an addition    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|addAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AddAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an addition    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|addAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an addition    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|addAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * addition operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|addChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AddChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * addition operation that has overflow checking. The implementing    * method can be specified.    */
specifier|public
specifier|static
name|BinaryExpression
name|addChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise AND    * operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|and
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|And
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise AND    * operation. The implementing method can be specified.    */
specifier|public
specifier|static
name|BinaryExpression
name|and
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a conditional AND    * operation that evaluates the second operand only if the first    * operand evaluates to true.    */
specifier|public
specifier|static
name|BinaryExpression
name|andAlso
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AndAlso
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a conditional AND    * operation that evaluates the second operand only if the first    * operand is resolved to true. The implementing method can be    * specified.    */
specifier|public
specifier|static
name|BinaryExpression
name|andAlso
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise AND    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|andAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|AndAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise AND    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|andAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise AND    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|andAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an expression that represents applying an array    * index operator to an array of rank one.    */
specifier|public
specifier|static
name|IndexExpression
name|arrayIndex
parameter_list|(
name|Expression
name|array
parameter_list|,
name|Expression
name|indexExpression
parameter_list|)
block|{
return|return
operator|new
name|IndexExpression
argument_list|(
name|array
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|indexExpression
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents an expression for    * obtaining the length of a one-dimensional array.    */
specifier|public
specifier|static
name|UnaryExpression
name|arrayLength
parameter_list|(
name|Expression
name|array
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an assignment    * operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|assign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Assign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a MemberAssignment that represents the initialization    * of a field or property.    */
specifier|public
specifier|static
name|MemberAssignment
name|bind
parameter_list|(
name|Member
name|member
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberAssignment that represents the initialization    * of a member by using a property accessor method.    */
specifier|public
specifier|static
name|MemberAssignment
name|bind
parameter_list|(
name|Method
name|method
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BlockExpression that contains the given statements.    */
specifier|public
specifier|static
name|BlockStatement
name|block
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Statement
argument_list|>
name|statements
parameter_list|)
block|{
return|return
name|block
argument_list|(
operator|(
name|Type
operator|)
literal|null
argument_list|,
name|statements
argument_list|)
return|;
block|}
comment|/**    * Creates a BlockExpression that contains the given statements,    * using varargs.    */
specifier|public
specifier|static
name|BlockStatement
name|block
parameter_list|(
name|Statement
modifier|...
name|statements
parameter_list|)
block|{
return|return
name|block
argument_list|(
name|toList
argument_list|(
name|statements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a BlockExpression that contains the given expressions,    * has no variables and has specific result type.    */
specifier|public
specifier|static
name|BlockStatement
name|block
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Statement
argument_list|>
name|expressions
parameter_list|)
block|{
name|List
argument_list|<
name|Statement
argument_list|>
name|list
init|=
name|toList
argument_list|(
name|expressions
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|type
operator|=
name|list
operator|.
name|get
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|Void
operator|.
name|TYPE
expr_stmt|;
block|}
block|}
return|return
operator|new
name|BlockStatement
argument_list|(
name|list
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates a BlockExpression that contains the given statements    * and has a specific result type, using varargs.    */
specifier|public
specifier|static
name|BlockStatement
name|block
parameter_list|(
name|Type
name|type
parameter_list|,
name|Statement
modifier|...
name|statements
parameter_list|)
block|{
return|return
name|block
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|statements
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a GotoExpression representing a break statement.    */
specifier|public
specifier|static
name|GotoStatement
name|break_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
return|return
operator|new
name|GotoStatement
argument_list|(
name|GotoExpressionKind
operator|.
name|Break
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a GotoExpression representing a break statement. The    * value passed to the label upon jumping can be specified.    */
specifier|public
specifier|static
name|GotoStatement
name|break_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
return|return
operator|new
name|GotoStatement
argument_list|(
name|GotoExpressionKind
operator|.
name|Break
argument_list|,
literal|null
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a GotoExpression representing a break statement with    * the specified type.    */
specifier|public
specifier|static
name|GotoStatement
name|break_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a GotoExpression representing a break statement with    * the specified type. The value passed to the label upon jumping    * can be specified.    */
specifier|public
specifier|static
name|GotoStatement
name|break_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to a    * static method that has arguments.    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to a    * static method that has arguments, using varargs.    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to a    * method that takes arguments.    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
name|expression
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to a    * method that takes arguments, using varargs.    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
name|expression
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to a    * method that takes arguments, with an explicit return type.    *    *<p>The return type must be consistent with the return type of the method,    * but may contain extra information, such as type parameters.</p>    *    *<p>The {@code expression} argument may be null if and only if the method    * is static.</p>    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Type
name|returnType
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|returnType
argument_list|,
name|method
argument_list|,
name|expression
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to a    * method that takes arguments, with an explicit return type, with varargs.    *    *<p>The return type must be consistent with the return type of the method,    * but may contain extra information, such as type parameters.</p>    *    *<p>The {@code expression} argument may be null if and only if the method    * is static.</p>    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Type
name|returnType
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|returnType
argument_list|,
name|method
argument_list|,
name|expression
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to an    * instance method by calling the appropriate factory method.    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Expression
name|target
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
name|Method
name|method
decl_stmt|;
try|try
block|{
comment|//noinspection unchecked
name|method
operator|=
name|Types
operator|.
name|toClass
argument_list|(
name|target
operator|.
name|getType
argument_list|()
argument_list|)
operator|.
name|getMethod
argument_list|(
name|methodName
argument_list|,
name|Types
operator|.
name|toClassArray
argument_list|(
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"while resolving method '"
operator|+
name|methodName
operator|+
literal|"' in class "
operator|+
name|target
operator|.
name|getType
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|call
argument_list|(
name|target
argument_list|,
name|method
argument_list|,
name|arguments
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to an    * instance method by calling the appropriate factory method, using varargs.    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Expression
name|target
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|target
argument_list|,
name|methodName
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to a    * static method by calling the    * appropriate factory method.    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
name|Method
name|method
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Types
operator|.
name|toClass
argument_list|(
name|type
argument_list|)
argument_list|,
name|methodName
argument_list|,
name|Types
operator|.
name|toClassArray
argument_list|(
name|arguments
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|MethodCallExpression
argument_list|(
name|method
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MethodCallExpression that represents a call to a    * static method by calling the    * appropriate factory method, using varargs.    */
specifier|public
specifier|static
name|MethodCallExpression
name|call
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|type
argument_list|,
name|methodName
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a CatchBlock representing a catch statement with a    * reference to the caught Exception object for use in the handler    * body.    */
specifier|public
specifier|static
name|CatchBlock
name|catch_
parameter_list|(
name|ParameterExpression
name|parameter
parameter_list|,
name|Statement
name|statement
parameter_list|)
block|{
return|return
operator|new
name|CatchBlock
argument_list|(
name|parameter
argument_list|,
name|statement
argument_list|)
return|;
block|}
comment|/**    * Creates a DebugInfoExpression for clearing a sequence    * point.    */
specifier|public
specifier|static
name|void
name|clearDebugInfo
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a coalescing    * operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|coalesce
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a coalescing    * operation, given a conversion function.    */
specifier|public
specifier|static
name|BinaryExpression
name|coalesce
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ConditionalExpression that represents a conditional    * statement.    */
specifier|public
specifier|static
name|Expression
name|condition
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Expression
name|ifTrue
parameter_list|,
name|Expression
name|ifFalse
parameter_list|)
block|{
return|return
name|makeTernary
argument_list|(
name|ExpressionType
operator|.
name|Conditional
argument_list|,
name|test
argument_list|,
name|ifTrue
argument_list|,
name|ifFalse
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Type
name|box
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|Primitive
name|primitive
init|=
name|Primitive
operator|.
name|of
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitive
operator|!=
literal|null
condition|)
block|{
return|return
name|primitive
operator|.
name|boxClass
return|;
block|}
return|return
name|type
return|;
block|}
comment|/** Returns whether an expression always evaluates to null. */
specifier|public
specifier|static
name|boolean
name|isConstantNull
parameter_list|(
name|Expression
name|e
parameter_list|)
block|{
return|return
name|e
operator|instanceof
name|ConstantExpression
operator|&&
operator|(
operator|(
name|ConstantExpression
operator|)
name|e
operator|)
operator|.
name|value
operator|==
literal|null
return|;
block|}
comment|/**    * Creates a ConditionalExpression that represents a conditional    * statement.    *    *<p>This method allows explicitly unifying the result type of the    * conditional expression in cases where the types of ifTrue and ifFalse    * expressions are not equal. Types of both ifTrue and ifFalse must be    * implicitly reference assignable to the result type. The type is allowed    * to be {@link Void#TYPE void}.</p>    */
specifier|public
specifier|static
name|ConditionalExpression
name|condition
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Expression
name|ifTrue
parameter_list|,
name|Expression
name|ifFalse
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|ConditionalExpression
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test
argument_list|,
name|ifFalse
argument_list|,
name|ifTrue
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates a ConstantExpression that has the Value property set    * to the specified value.    *    *<p>Does the right thing for null, String, primitive values (e.g. int 12,    * short 12, double 3.14 and boolean false), boxed primitives    * (e.g. Integer.valueOf(12)), enums, classes, BigDecimal, BigInteger,    * classes that have a constructor with a parameter for each field, and    * arrays.</p>    */
specifier|public
specifier|static
name|ConstantExpression
name|constant
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
name|Class
name|type
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
name|ConstantUntypedNull
operator|.
name|INSTANCE
return|;
block|}
else|else
block|{
specifier|final
name|Class
name|clazz
init|=
name|value
operator|.
name|getClass
argument_list|()
decl_stmt|;
specifier|final
name|Primitive
name|primitive
init|=
name|Primitive
operator|.
name|ofBox
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitive
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|primitive
operator|.
name|primitiveClass
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|clazz
expr_stmt|;
block|}
block|}
return|return
operator|new
name|ConstantExpression
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Creates a ConstantExpression that has the Value and Type    * properties set to the specified values.    */
specifier|public
specifier|static
name|ConstantExpression
name|constant
parameter_list|(
name|Object
name|value
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|type
operator|instanceof
name|Class
condition|)
block|{
comment|// Fix up value so that it matches type.
name|Class
name|clazz
init|=
operator|(
name|Class
operator|)
name|type
decl_stmt|;
name|Primitive
name|primitive
init|=
name|Primitive
operator|.
name|ofBoxOr
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitive
operator|!=
literal|null
condition|)
block|{
name|clazz
operator|=
name|primitive
operator|.
name|boxClass
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|clazz
operator|==
name|Float
operator|.
name|class
operator|||
name|clazz
operator|==
name|Double
operator|.
name|class
operator|)
operator|&&
name|value
operator|instanceof
name|BigDecimal
condition|)
block|{
comment|// Don't try to convert the value of float and double literals.
comment|// We'd experience rounding, e.g. 3.2 becomes 3.1999998.
block|}
if|else if
condition|(
operator|!
name|clazz
operator|.
name|isInstance
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|String
name|stringValue
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|BigDecimal
operator|.
name|class
condition|)
block|{
name|value
operator|=
operator|new
name|BigDecimal
argument_list|(
name|stringValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|BigInteger
operator|.
name|class
condition|)
block|{
name|value
operator|=
operator|new
name|BigInteger
argument_list|(
name|stringValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|primitive
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|primitive
operator|.
name|parse
argument_list|(
name|stringValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|new
name|ConstantExpression
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Creates a GotoExpression representing a continue statement.    */
specifier|public
specifier|static
name|GotoStatement
name|continue_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
return|return
operator|new
name|GotoStatement
argument_list|(
name|GotoExpressionKind
operator|.
name|Continue
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a GotoExpression representing a continue statement    * with the specified type.    */
specifier|public
specifier|static
name|GotoStatement
name|continue_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that represents a type conversion    * operation.    */
specifier|public
specifier|static
name|UnaryExpression
name|convert_
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|UnaryExpression
argument_list|(
name|ExpressionType
operator|.
name|Convert
argument_list|,
name|type
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents a conversion    * operation for which the implementing method is specified.    */
specifier|public
specifier|static
name|UnaryExpression
name|convert_
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that represents a conversion    * operation that throws an exception if the target type is    * overflowed.    */
specifier|public
specifier|static
name|UnaryExpression
name|convertChecked
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that represents a conversion    * operation that throws an exception if the target type is    * overflowed and for which the implementing method is    * specified.    */
specifier|public
specifier|static
name|UnaryExpression
name|convertChecked_
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a DebugInfoExpression with the specified span.    */
specifier|public
specifier|static
name|void
name|debugInfo
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that represents the decrementing of    * the expression by 1.    */
specifier|public
specifier|static
name|UnaryExpression
name|decrement
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that represents the decrementing of    * the expression by 1.    */
specifier|public
specifier|static
name|UnaryExpression
name|decrement
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a DefaultExpression that has the Type property set to    * the specified type.    */
specifier|public
specifier|static
name|DefaultExpression
name|default_
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * division operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|divide
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Divide
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * division operation. The implementing method can be    * specified.    */
specifier|public
specifier|static
name|BinaryExpression
name|divide
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Divide
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a division    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|divideAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|DivideAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a division    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|divideAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a division    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|divideAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a DynamicExpression that represents a dynamic    * operation bound by the provided CallSiteBinder.    */
specifier|public
specifier|static
name|DynamicExpression
name|dynamic
parameter_list|(
name|CallSiteBinder
name|binder
parameter_list|,
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a {@code DynamicExpression} that represents a dynamic    * operation bound by the provided {@code CallSiteBinder}, using varargs.    */
specifier|public
specifier|static
name|DynamicExpression
name|dynamic
parameter_list|(
name|CallSiteBinder
name|binder
parameter_list|,
name|Type
name|type
parameter_list|,
name|Expression
modifier|...
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an {@code ElementInit}, given an {@code Iterable<T>} as the second    * argument.    */
specifier|public
specifier|static
name|ElementInit
name|elementInit
parameter_list|(
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an ElementInit, given an array of values as the second    * argument, using varargs.    */
specifier|public
specifier|static
name|ElementInit
name|elementInit
parameter_list|(
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an empty expression that has Void type.    */
specifier|public
specifier|static
name|DefaultExpression
name|empty
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an equality    * comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|equal
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Equal
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an equality    * comparison. The implementing method can be specified.    */
specifier|public
specifier|static
name|BinaryExpression
name|equal
parameter_list|(
name|Expression
name|expression0
parameter_list|,
name|Expression
name|expression1
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise XOR    * operation, using op_ExclusiveOr for user-defined types.    */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOr
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ExclusiveOr
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise XOR    * operation, using op_ExclusiveOr for user-defined types. The    * implementing method can be specified.    */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOr
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise XOR    * assignment operation, using op_ExclusiveOr for user-defined    * types.    */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOrAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ExclusiveOrAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise XOR    * assignment operation, using op_ExclusiveOr for user-defined    * types.    */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOrAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise XOR    * assignment operation, using op_ExclusiveOr for user-defined    * types.    */
specifier|public
specifier|static
name|BinaryExpression
name|exclusiveOrAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a field.    */
specifier|public
specifier|static
name|MemberExpression
name|field
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Field
name|field
parameter_list|)
block|{
return|return
name|makeMemberAccess
argument_list|(
name|expression
argument_list|,
name|Types
operator|.
name|field
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a field.    */
specifier|public
specifier|static
name|MemberExpression
name|field
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|PseudoField
name|field
parameter_list|)
block|{
return|return
name|makeMemberAccess
argument_list|(
name|expression
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a field    * given the name of the field.    */
specifier|public
specifier|static
name|MemberExpression
name|field
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|PseudoField
name|field
init|=
name|Types
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|makeMemberAccess
argument_list|(
name|expression
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a field.    */
specifier|public
specifier|static
name|MemberExpression
name|field
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|PseudoField
name|field
init|=
name|Types
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|,
name|type
argument_list|)
decl_stmt|;
return|return
name|makeMemberAccess
argument_list|(
name|expression
argument_list|,
name|field
argument_list|)
return|;
block|}
comment|/**    * Creates a Type object that represents a generic System.Action    * delegate type that has specific type arguments.    */
specifier|public
specifier|static
name|Class
name|getActionType
parameter_list|(
name|Class
modifier|...
name|typeArgs
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Gets a Type object that represents a generic System.Func or    * System.Action delegate type that has specific type    * arguments.    */
specifier|public
specifier|static
name|Class
name|getDelegateType
parameter_list|(
name|Class
modifier|...
name|typeArgs
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a Type object that represents a generic System.Func    * delegate type that has specific type arguments. The last type    * argument specifies the return type of the created delegate.    */
specifier|public
specifier|static
name|Class
name|getFuncType
parameter_list|(
name|Class
modifier|...
name|typeArgs
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a GotoExpression representing a "go to" statement.    */
specifier|public
specifier|static
name|GotoStatement
name|goto_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a GotoExpression representing a "go to" statement. The    * value passed to the label upon jumping can be specified.    */
specifier|public
specifier|static
name|GotoStatement
name|goto_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a GotoExpression representing a "go to" statement with    * the specified type.    */
specifier|public
specifier|static
name|GotoStatement
name|goto_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a GotoExpression representing a "go to" statement with    * the specified type. The value passed to the label upon jumping    * can be specified.    */
specifier|public
specifier|static
name|GotoStatement
name|goto_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a "greater than"    * numeric comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|greaterThan
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|GreaterThan
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a "greater than"    * numeric comparison. The implementing method can be    * specified.    */
specifier|public
specifier|static
name|BinaryExpression
name|greaterThan
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a "greater than or    * equal" numeric comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|greaterThanOrEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|GreaterThanOrEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a "greater than or    * equal" numeric comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|greaterThanOrEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ConditionalExpression that represents a conditional    * block with an if statement.    */
specifier|public
specifier|static
name|ConditionalStatement
name|ifThen
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Node
name|ifTrue
parameter_list|)
block|{
return|return
operator|new
name|ConditionalStatement
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test
argument_list|,
name|ifTrue
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a ConditionalExpression that represents a conditional    * block with if and else statements.    */
specifier|public
specifier|static
name|ConditionalStatement
name|ifThenElse
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Node
name|ifTrue
parameter_list|,
name|Node
name|ifFalse
parameter_list|)
block|{
return|return
operator|new
name|ConditionalStatement
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test
argument_list|,
name|ifTrue
argument_list|,
name|ifFalse
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a ConditionalExpression that represents a conditional    * block with if and else statements:    *<code>if (test) stmt1 [ else if (test2) stmt2 ]... [ else stmtN ]</code>.    */
specifier|public
specifier|static
name|ConditionalStatement
name|ifThenElse
parameter_list|(
name|Expression
name|test
parameter_list|,
name|Node
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|ifThenElse
argument_list|(
operator|new
name|FluentArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
operator|.
name|append
argument_list|(
name|test
argument_list|)
operator|.
name|appendAll
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a ConditionalExpression that represents a conditional    * block with if and else statements:    *<code>if (test) stmt1 [ else if (test2) stmt2 ]... [ else stmtN ]</code>.    */
specifier|public
specifier|static
name|ConditionalStatement
name|ifThenElse
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Node
argument_list|>
name|nodes
parameter_list|)
block|{
name|List
argument_list|<
name|Node
argument_list|>
name|list
init|=
name|toList
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
assert|assert
name|list
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|:
literal|"At least one test and one statement is required"
assert|;
return|return
operator|new
name|ConditionalStatement
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents the incrementing of    * the expression value by 1.    */
specifier|public
specifier|static
name|UnaryExpression
name|increment
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that represents the incrementing of    * the expression by 1.    */
specifier|public
specifier|static
name|UnaryExpression
name|increment
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an InvocationExpression that applies a delegate or    * lambda expression to a list of argument expressions.    */
specifier|public
specifier|static
name|InvocationExpression
name|invoke
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an InvocationExpression that applies a delegate or    * lambda expression to a list of argument expressions, using varargs.    */
specifier|public
specifier|static
name|InvocationExpression
name|invoke
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns whether the expression evaluates to false.    */
specifier|public
specifier|static
name|UnaryExpression
name|isFalse
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns whether the expression evaluates to false.    */
specifier|public
specifier|static
name|UnaryExpression
name|isFalse
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns whether the expression evaluates to true.    */
specifier|public
specifier|static
name|UnaryExpression
name|isTrue
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Returns whether the expression evaluates to true.    */
specifier|public
specifier|static
name|UnaryExpression
name|isTrue
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a LabelTarget representing a label with X type and    * no name.    */
specifier|public
specifier|static
name|LabelTarget
name|label
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a LabelExpression representing a label without a    * default value.    */
specifier|public
specifier|static
name|LabelStatement
name|label
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a LabelTarget representing a label with X type and    * the given name.    */
specifier|public
specifier|static
name|LabelTarget
name|label
parameter_list|(
name|String
name|name
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a LabelTarget representing a label with the given    * type.    */
specifier|public
specifier|static
name|LabelTarget
name|label
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a LabelExpression representing a label with the given    * default value.    */
specifier|public
specifier|static
name|LabelStatement
name|label
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a LabelTarget representing a label with the given type    * and name.    */
specifier|public
specifier|static
name|LabelTarget
name|label
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a FunctionExpression from an actual function.    */
specifier|public
specifier|static
parameter_list|<
name|F
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|F
name|function
parameter_list|)
block|{
comment|// REVIEW: Check that that function class is non-inner, has a public
comment|// default constructor, etc.?
comment|//noinspection unchecked
return|return
operator|new
name|FunctionExpression
argument_list|<>
argument_list|(
name|function
argument_list|)
return|;
block|}
comment|/**    * Creates a LambdaExpression by first constructing a delegate    * type.    */
specifier|public
specifier|static
parameter_list|<
name|F
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|BlockStatement
name|body
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterList
init|=
name|toList
argument_list|(
name|parameters
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Class
argument_list|<
name|F
argument_list|>
name|type
init|=
name|deduceType
argument_list|(
name|parameterList
argument_list|,
name|body
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|FunctionExpression
argument_list|<>
argument_list|(
name|type
argument_list|,
name|body
argument_list|,
name|parameterList
argument_list|)
return|;
block|}
comment|/**    * Creates a LambdaExpression by first constructing a delegate    * type, using varargs.    */
specifier|public
specifier|static
parameter_list|<
name|F
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|BlockStatement
name|body
parameter_list|,
name|ParameterExpression
modifier|...
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|body
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an Expression where the delegate type {@code F} is    * known at compile time.    */
specifier|public
specifier|static
parameter_list|<
name|F
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Expression
name|body
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|Blocks
operator|.
name|toFunctionBlock
argument_list|(
name|body
argument_list|)
argument_list|,
name|parameters
argument_list|)
return|;
block|}
comment|/**    * Creates an Expression where the delegate type {@code F} is    * known at compile time, using varargs.    */
specifier|public
specifier|static
parameter_list|<
name|F
extends|extends
name|Function
argument_list|<
name|?
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Expression
name|body
parameter_list|,
name|ParameterExpression
modifier|...
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|Blocks
operator|.
name|toFunctionBlock
argument_list|(
name|body
argument_list|)
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a LambdaExpression by first constructing a delegate    * type.    *    *<p>It can be used when the delegate type is not known at compile time.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Class
argument_list|<
name|F
argument_list|>
name|type
parameter_list|,
name|BlockStatement
name|body
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
return|return
operator|new
name|FunctionExpression
argument_list|<>
argument_list|(
name|type
argument_list|,
name|body
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a LambdaExpression by first constructing a delegate    * type, using varargs.    *    *<p>It can be used when the delegate type is not known at compile time.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Class
argument_list|<
name|F
argument_list|>
name|type
parameter_list|,
name|BlockStatement
name|body
parameter_list|,
name|ParameterExpression
modifier|...
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|type
argument_list|,
name|body
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a LambdaExpression by first constructing a delegate    * type.    *    *<p>It can be used when the delegate type is not known at compile time.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Class
argument_list|<
name|F
argument_list|>
name|type
parameter_list|,
name|Expression
name|body
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|type
argument_list|,
name|Blocks
operator|.
name|toFunctionBlock
argument_list|(
name|body
argument_list|)
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a LambdaExpression by first constructing a delegate    * type, using varargs.    *    *<p>It can be used when the delegate type is not known at compile time.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|F
extends|extends
name|Function
argument_list|<
name|?
extends|extends
name|T
argument_list|>
parameter_list|>
name|FunctionExpression
argument_list|<
name|F
argument_list|>
name|lambda
parameter_list|(
name|Class
argument_list|<
name|F
argument_list|>
name|type
parameter_list|,
name|Expression
name|body
parameter_list|,
name|ParameterExpression
modifier|...
name|parameters
parameter_list|)
block|{
return|return
name|lambda
argument_list|(
name|type
argument_list|,
name|Blocks
operator|.
name|toFunctionBlock
argument_list|(
name|body
argument_list|)
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * left-shift operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|leftShift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|LeftShift
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * left-shift operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|leftShift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * left-shift assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|leftShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|LeftShiftAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * left-shift assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|leftShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * left-shift assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|leftShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a "less than"    * numeric comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|lessThan
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|LessThan
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a "less than"    * numeric comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|lessThan
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a " less than or    * equal" numeric comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|lessThanOrEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|LessThanOrEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a "less than or    * equal" numeric comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|lessThanOrEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberListBinding where the member is a field or    * property.    */
specifier|public
specifier|static
name|MemberListBinding
name|listBind
parameter_list|(
name|Member
name|member
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ElementInit
argument_list|>
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberListBinding where the member is a field or    * property, using varargs.    */
specifier|public
specifier|static
name|MemberListBinding
name|listBind
parameter_list|(
name|Member
name|member
parameter_list|,
name|ElementInit
modifier|...
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberListBinding based on a specified property    * accessor method.    */
specifier|public
specifier|static
name|MemberListBinding
name|listBind
parameter_list|(
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ElementInit
argument_list|>
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberListBinding object based on a specified    * property accessor method, using varargs.    */
specifier|public
specifier|static
name|MemberListBinding
name|listBind
parameter_list|(
name|Method
name|method
parameter_list|,
name|ElementInit
modifier|...
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ListInitExpression that uses specified ElementInit    * objects to initialize a collection.    */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ElementInit
argument_list|>
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ListInitExpression that uses specified ElementInit    * objects to initialize a collection, using varargs.    */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|ElementInit
modifier|...
name|elementInits
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ListInitExpression that uses a method named "Add" to    * add elements to a collection.    */
specifier|public
specifier|static
name|ListInitExpression
name|listInitE
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ListInitExpression that uses a method named "Add" to    * add elements to a collection, using varargs.    */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ListInitExpression that uses a specified method to    * add elements to a collection.    */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ListInitExpression that uses a specified method to    * add elements to a collection, using varargs.    */
specifier|public
specifier|static
name|ListInitExpression
name|listInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Method
name|method
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a LoopExpression with the given body.    */
specifier|public
specifier|static
name|ForStatement
name|for_
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|DeclarationStatement
argument_list|>
name|declarations
parameter_list|,
name|Expression
name|condition
parameter_list|,
name|Expression
name|post
parameter_list|,
name|Statement
name|body
parameter_list|)
block|{
return|return
operator|new
name|ForStatement
argument_list|(
name|toList
argument_list|(
name|declarations
argument_list|)
argument_list|,
name|condition
argument_list|,
name|post
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/**    * Creates a LoopExpression with the given body.    */
specifier|public
specifier|static
name|ForStatement
name|for_
parameter_list|(
name|DeclarationStatement
name|declaration
parameter_list|,
name|Expression
name|condition
parameter_list|,
name|Expression
name|post
parameter_list|,
name|Statement
name|body
parameter_list|)
block|{
return|return
operator|new
name|ForStatement
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|declaration
argument_list|)
argument_list|,
name|condition
argument_list|,
name|post
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/**    * Creates a ForEachExpression with the given body.    */
specifier|public
specifier|static
name|ForEachStatement
name|forEach
parameter_list|(
name|ParameterExpression
name|parameter
parameter_list|,
name|Expression
name|iterable
parameter_list|,
name|Statement
name|body
parameter_list|)
block|{
return|return
operator|new
name|ForEachStatement
argument_list|(
name|parameter
argument_list|,
name|iterable
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression, given the left and right operands,    * by calling an appropriate factory method.    */
specifier|public
specifier|static
name|BinaryExpression
name|makeBinary
parameter_list|(
name|ExpressionType
name|binaryType
parameter_list|,
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
specifier|final
name|Type
name|type
decl_stmt|;
switch|switch
condition|(
name|binaryType
condition|)
block|{
case|case
name|Equal
case|:
case|case
name|NotEqual
case|:
case|case
name|LessThan
case|:
case|case
name|LessThanOrEqual
case|:
case|case
name|GreaterThan
case|:
case|case
name|GreaterThanOrEqual
case|:
case|case
name|AndAlso
case|:
case|case
name|OrElse
case|:
name|type
operator|=
name|Boolean
operator|.
name|TYPE
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|larger
argument_list|(
name|left
operator|.
name|type
argument_list|,
name|right
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|new
name|BinaryExpression
argument_list|(
name|binaryType
argument_list|,
name|type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/** Returns an expression to box the value of a primitive expression.    * E.g. {@code box(e, Primitive.INT)} returns {@code Integer.valueOf(e)}. */
specifier|public
specifier|static
name|Expression
name|box
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Primitive
name|primitive
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|primitive
operator|.
name|boxClass
argument_list|,
literal|"valueOf"
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Converts e.g. "anInteger" to "Integer.valueOf(anInteger)". */
specifier|public
specifier|static
name|Expression
name|box
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
name|Primitive
name|primitive
init|=
name|Primitive
operator|.
name|of
argument_list|(
name|expression
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitive
operator|==
literal|null
condition|)
block|{
return|return
name|expression
return|;
block|}
return|return
name|box
argument_list|(
name|expression
argument_list|,
name|primitive
argument_list|)
return|;
block|}
comment|/** Returns an expression to unbox the value of a boxed-primitive expression.    * E.g. {@code unbox(e, Primitive.INT)} returns {@code e.intValue()}.    * It is assumed that e is of the right box type (or {@link Number})."Value */
specifier|public
specifier|static
name|Expression
name|unbox
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Primitive
name|primitive
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|expression
argument_list|,
name|primitive
operator|.
name|primitiveName
operator|+
literal|"Value"
argument_list|)
return|;
block|}
comment|/** Converts e.g. "anInteger" to "anInteger.intValue()". */
specifier|public
specifier|static
name|Expression
name|unbox
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
name|Primitive
name|primitive
init|=
name|Primitive
operator|.
name|ofBox
argument_list|(
name|expression
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|primitive
operator|==
literal|null
condition|)
block|{
return|return
name|expression
return|;
block|}
return|return
name|unbox
argument_list|(
name|expression
argument_list|,
name|primitive
argument_list|)
return|;
block|}
specifier|private
name|Type
name|largest
parameter_list|(
name|Type
modifier|...
name|types
parameter_list|)
block|{
name|Type
name|max
init|=
name|types
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|types
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|max
operator|=
name|larger
argument_list|(
name|max
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
specifier|private
specifier|static
name|Type
name|larger
parameter_list|(
name|Type
name|type0
parameter_list|,
name|Type
name|type1
parameter_list|)
block|{
comment|// curiously, "short + short" has type "int".
comment|// similarly, "byte + byte" has type "int".
comment|// "byte / long" has type "long".
if|if
condition|(
name|type0
operator|==
name|double
operator|.
name|class
operator|||
name|type0
operator|==
name|Double
operator|.
name|class
operator|||
name|type1
operator|==
name|double
operator|.
name|class
operator|||
name|type1
operator|==
name|Double
operator|.
name|class
condition|)
block|{
return|return
name|double
operator|.
name|class
return|;
block|}
if|if
condition|(
name|type0
operator|==
name|float
operator|.
name|class
operator|||
name|type0
operator|==
name|Float
operator|.
name|class
operator|||
name|type1
operator|==
name|float
operator|.
name|class
operator|||
name|type1
operator|==
name|Float
operator|.
name|class
condition|)
block|{
return|return
name|float
operator|.
name|class
return|;
block|}
if|if
condition|(
name|type0
operator|==
name|long
operator|.
name|class
operator|||
name|type0
operator|==
name|Long
operator|.
name|class
operator|||
name|type1
operator|==
name|long
operator|.
name|class
operator|||
name|type1
operator|==
name|Long
operator|.
name|class
condition|)
block|{
return|return
name|long
operator|.
name|class
return|;
block|}
return|return
name|int
operator|.
name|class
return|;
block|}
comment|/**    * Creates a BinaryExpression, given the left operand, right    * operand and implementing method, by calling the appropriate    * factory method.    */
specifier|public
specifier|static
name|BinaryExpression
name|makeBinary
parameter_list|(
name|ExpressionType
name|binaryType
parameter_list|,
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression, given the left operand, right    * operand, implementing method and type conversion function, by    * calling the appropriate factory method.    */
specifier|public
specifier|static
name|BinaryExpression
name|makeBinary
parameter_list|(
name|ExpressionType
name|binaryType
parameter_list|,
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a TernaryExpression, given the left and right operands,    * by calling an appropriate factory method.    */
specifier|public
specifier|static
name|TernaryExpression
name|makeTernary
parameter_list|(
name|ExpressionType
name|ternaryType
parameter_list|,
name|Expression
name|e0
parameter_list|,
name|Expression
name|e1
parameter_list|,
name|Expression
name|e2
parameter_list|)
block|{
specifier|final
name|Type
name|type
decl_stmt|;
switch|switch
condition|(
name|ternaryType
condition|)
block|{
case|case
name|Conditional
case|:
if|if
condition|(
name|e1
operator|instanceof
name|ConstantUntypedNull
condition|)
block|{
name|type
operator|=
name|box
argument_list|(
name|e2
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|.
name|getType
argument_list|()
operator|!=
name|type
condition|)
block|{
name|e1
operator|=
name|constant
argument_list|(
literal|null
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|e2
operator|instanceof
name|ConstantUntypedNull
condition|)
block|{
name|type
operator|=
name|box
argument_list|(
name|e1
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|.
name|getType
argument_list|()
operator|!=
name|type
condition|)
block|{
name|e2
operator|=
name|constant
argument_list|(
literal|null
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|type
operator|=
name|Types
operator|.
name|gcd
argument_list|(
name|e1
operator|.
name|getType
argument_list|()
argument_list|,
name|e2
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|type
operator|=
name|e1
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|TernaryExpression
argument_list|(
name|ternaryType
argument_list|,
name|type
argument_list|,
name|e0
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
return|;
block|}
comment|/**    * Creates a CatchBlock representing a catch statement with the    * specified elements.    */
specifier|public
specifier|static
name|CatchBlock
name|makeCatchBlock
parameter_list|(
name|Type
name|type
parameter_list|,
name|ParameterExpression
name|variable
parameter_list|,
name|Expression
name|body
parameter_list|,
name|Expression
name|filter
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a DynamicExpression that represents a dynamic    * operation bound by the provided CallSiteBinder.    */
specifier|public
specifier|static
name|DynamicExpression
name|makeDynamic
parameter_list|(
name|Type
name|type
parameter_list|,
name|CallSiteBinder
name|binder
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a DynamicExpression that represents a dynamic    * operation bound by the provided CallSiteBinder, using varargs.    */
specifier|public
specifier|static
name|DynamicExpression
name|makeDynamic
parameter_list|(
name|Type
name|type
parameter_list|,
name|CallSiteBinder
name|binder
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a GotoExpression representing a jump of the specified    * GotoExpressionKind. The value passed to the label upon jumping    * can also be specified.    */
specifier|public
specifier|static
name|GotoStatement
name|makeGoto
parameter_list|(
name|GotoExpressionKind
name|kind
parameter_list|,
name|LabelTarget
name|target
parameter_list|,
name|Expression
name|value
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a field.    */
specifier|public
specifier|static
name|MemberExpression
name|makeMemberAccess
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|PseudoField
name|member
parameter_list|)
block|{
return|return
operator|new
name|MemberExpression
argument_list|(
name|expression
argument_list|,
name|member
argument_list|)
return|;
block|}
comment|/**    * Creates a TryExpression representing a try block with the    * specified elements.    */
specifier|public
specifier|static
name|TryStatement
name|makeTry
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|body
parameter_list|,
name|Expression
name|finally_
parameter_list|,
name|Expression
name|fault
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|CatchBlock
argument_list|>
name|handlers
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a TryExpression representing a try block with the    * specified elements, using varargs.    */
specifier|public
specifier|static
name|TryStatement
name|makeTry
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|body
parameter_list|,
name|Expression
name|finally_
parameter_list|,
name|Expression
name|fault
parameter_list|,
name|CatchBlock
modifier|...
name|handlers
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression, given an operand, by calling the    * appropriate factory method.    */
specifier|public
specifier|static
name|UnaryExpression
name|makeUnary
parameter_list|(
name|ExpressionType
name|expressionType
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
name|Type
name|type
init|=
name|expression
operator|.
name|getType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|expressionType
condition|)
block|{
case|case
name|Negate
case|:
if|if
condition|(
name|type
operator|==
name|byte
operator|.
name|class
operator|||
name|type
operator|==
name|short
operator|.
name|class
condition|)
block|{
name|type
operator|=
name|int
operator|.
name|class
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|new
name|UnaryExpression
argument_list|(
name|expressionType
argument_list|,
name|type
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression, given an operand and implementing    * method, by calling the appropriate factory method.    */
specifier|public
specifier|static
name|UnaryExpression
name|makeUnary
parameter_list|(
name|ExpressionType
name|expressionType
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
assert|assert
name|type
operator|!=
literal|null
assert|;
return|return
operator|new
name|UnaryExpression
argument_list|(
name|expressionType
argument_list|,
name|type
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a MemberMemberBinding that represents the recursive    * initialization of members of a field or property.    */
specifier|public
specifier|static
name|MemberMemberBinding
name|memberBind
parameter_list|(
name|Member
name|member
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|MemberBinding
argument_list|>
name|bindings
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberMemberBinding that represents the recursive    * initialization of members of a field or property, using varargs.    */
specifier|public
specifier|static
name|MemberMemberBinding
name|memberBind
parameter_list|(
name|Member
name|member
parameter_list|,
name|MemberBinding
modifier|...
name|bindings
parameter_list|)
block|{
return|return
name|memberBind
argument_list|(
name|member
argument_list|,
name|toList
argument_list|(
name|bindings
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a MemberMemberBinding that represents the recursive    * initialization of members of a member that is accessed by using    * a property accessor method.    */
specifier|public
specifier|static
name|MemberMemberBinding
name|memberBind
parameter_list|(
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|MemberBinding
argument_list|>
name|bindings
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberMemberBinding that represents the recursive    * initialization of members of a member that is accessed by using    * a property accessor method, using varargs.    */
specifier|public
specifier|static
name|MemberMemberBinding
name|memberBind
parameter_list|(
name|Method
name|method
parameter_list|,
name|MemberBinding
modifier|...
name|bindings
parameter_list|)
block|{
return|return
name|memberBind
argument_list|(
name|method
argument_list|,
name|toList
argument_list|(
name|bindings
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Represents an expression that creates a new object and    * initializes a property of the object.    */
specifier|public
specifier|static
name|MemberInitExpression
name|memberInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|MemberBinding
argument_list|>
name|bindings
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Represents an expression that creates a new object and    * initializes a property of the object, using varargs.    */
specifier|public
specifier|static
name|MemberInitExpression
name|memberInit
parameter_list|(
name|NewExpression
name|newExpression
parameter_list|,
name|MemberBinding
modifier|...
name|bindings
parameter_list|)
block|{
return|return
name|memberInit
argument_list|(
name|newExpression
argument_list|,
name|toList
argument_list|(
name|bindings
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Declares a method.    */
specifier|public
specifier|static
name|MethodDeclaration
name|methodDecl
parameter_list|(
name|int
name|modifier
parameter_list|,
name|Type
name|resultType
parameter_list|,
name|String
name|name
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|,
name|BlockStatement
name|body
parameter_list|)
block|{
return|return
operator|new
name|MethodDeclaration
argument_list|(
name|modifier
argument_list|,
name|name
argument_list|,
name|resultType
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/**    * Declares a constructor.    */
specifier|public
specifier|static
name|ConstructorDeclaration
name|constructorDecl
parameter_list|(
name|int
name|modifier
parameter_list|,
name|Type
name|declaredAgainst
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|ParameterExpression
argument_list|>
name|parameters
parameter_list|,
name|BlockStatement
name|body
parameter_list|)
block|{
return|return
operator|new
name|ConstructorDeclaration
argument_list|(
name|modifier
argument_list|,
name|declaredAgainst
argument_list|,
name|toList
argument_list|(
name|parameters
argument_list|)
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/**    * Declares a field with an initializer.    */
specifier|public
specifier|static
name|FieldDeclaration
name|fieldDecl
parameter_list|(
name|int
name|modifier
parameter_list|,
name|ParameterExpression
name|parameter
parameter_list|,
name|Expression
name|initializer
parameter_list|)
block|{
return|return
operator|new
name|FieldDeclaration
argument_list|(
name|modifier
argument_list|,
name|parameter
argument_list|,
name|initializer
argument_list|)
return|;
block|}
comment|/**    * Declares a field.    */
specifier|public
specifier|static
name|FieldDeclaration
name|fieldDecl
parameter_list|(
name|int
name|modifier
parameter_list|,
name|ParameterExpression
name|parameter
parameter_list|)
block|{
return|return
operator|new
name|FieldDeclaration
argument_list|(
name|modifier
argument_list|,
name|parameter
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Declares a class.    */
specifier|public
specifier|static
name|ClassDeclaration
name|classDecl
parameter_list|(
name|int
name|modifier
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
name|extended
parameter_list|,
name|List
argument_list|<
name|Type
argument_list|>
name|implemented
parameter_list|,
name|List
argument_list|<
name|MemberDeclaration
argument_list|>
name|memberDeclarations
parameter_list|)
block|{
return|return
operator|new
name|ClassDeclaration
argument_list|(
name|modifier
argument_list|,
name|name
argument_list|,
name|extended
argument_list|,
name|implemented
argument_list|,
name|memberDeclarations
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * remainder operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|modulo
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Modulo
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * remainder operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|modulo
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Modulo
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a remainder    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|moduloAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ModuloAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a remainder    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|moduloAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ModuloAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a remainder    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|moduloAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|ModuloAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * multiplication operation that does not have overflow    * checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiply
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Multiply
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * multiplication operation that does not have overflow    * checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiply
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Multiply
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a multiplication    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a multiplication    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a multiplication    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a multiplication    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a multiplication    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a multiplication    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * multiplication operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * multiplication operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|multiplyChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|MultiplyChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents an arithmetic    * negation operation.    */
specifier|public
specifier|static
name|UnaryExpression
name|negate
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Negate
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents an arithmetic    * negation operation.    */
specifier|public
specifier|static
name|UnaryExpression
name|negate
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Negate
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents an arithmetic    * negation operation that has overflow checking.    */
specifier|public
specifier|static
name|UnaryExpression
name|negateChecked
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|NegateChecked
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents an arithmetic    * negation operation that has overflow checking. The implementing    * method can be specified.    */
specifier|public
specifier|static
name|UnaryExpression
name|negateChecked
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|NegateChecked
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the specified    * constructor that takes no arguments.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|constructor
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the    * parameterless constructor of the specified type.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|type
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the constructor of the    * specified type whose parameters are assignable from the specified    * arguments.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
comment|// Note that the last argument is not an empty list. That would cause
comment|// an anonymous inner-class with no members to be generated.
return|return
operator|new
name|NewExpression
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the constructor of the    * specified type whose parameters are assignable from the specified    * arguments, using varargs.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
comment|// Note that the last argument is not an empty list. That would cause
comment|// an anonymous inner-class with no members to be generated.
return|return
operator|new
name|NewExpression
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the constructor of the    * specified type whose parameters are assignable from the specified    * arguments.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|MemberDeclaration
argument_list|>
name|memberDeclarations
parameter_list|)
block|{
return|return
operator|new
name|NewExpression
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|,
name|toList
argument_list|(
name|memberDeclarations
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the constructor of the    * specified type whose parameters are assignable from the specified    * arguments, using varargs.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|,
name|MemberDeclaration
modifier|...
name|memberDeclarations
parameter_list|)
block|{
return|return
operator|new
name|NewExpression
argument_list|(
name|type
argument_list|,
name|toList
argument_list|(
name|arguments
argument_list|)
argument_list|,
name|toList
argument_list|(
name|memberDeclarations
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the specified    * constructor with the specified arguments.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
comment|// Note that the last argument is not an empty list. That would cause
comment|// an anonymous inner-class with no members to be generated.
return|return
operator|new
name|NewExpression
argument_list|(
name|constructor
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the specified    * constructor with the specified arguments, using varargs.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
return|return
operator|new
name|NewExpression
argument_list|(
name|constructor
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the specified    * constructor with the specified arguments.    *    *<p>The members that access the constructor initialized fields are    * specified.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|expressions
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|MemberDeclaration
argument_list|>
name|memberDeclarations
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|constructor
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|,
name|toList
argument_list|(
name|memberDeclarations
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a NewExpression that represents calling the specified    * constructor with the specified arguments, using varargs.    *    *<p>The members that access the constructor initialized fields are    * specified.    */
specifier|public
specifier|static
name|NewExpression
name|new_
parameter_list|(
name|Constructor
name|constructor
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|expressions
parameter_list|,
name|MemberDeclaration
modifier|...
name|memberDeclarations
parameter_list|)
block|{
return|return
name|new_
argument_list|(
name|constructor
operator|.
name|getDeclaringClass
argument_list|()
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|,
name|toList
argument_list|(
name|memberDeclarations
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a NewArrayExpression that represents creating an array    * that has a specified rank.    */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayBounds
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|dimension
parameter_list|,
name|Expression
name|bound
parameter_list|)
block|{
return|return
operator|new
name|NewArrayExpression
argument_list|(
name|type
argument_list|,
name|dimension
argument_list|,
name|bound
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a NewArrayExpression that represents creating a    * one-dimensional array and initializing it from a list of    * elements.    *    * @param type Element type of the array.    */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayInit
parameter_list|(
name|Type
name|type
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
return|return
operator|new
name|NewArrayExpression
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a NewArrayExpression that represents creating a    * one-dimensional array and initializing it from a list of    * elements, using varargs.    *    * @param type Element type of the array.    */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayInit
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
return|return
operator|new
name|NewArrayExpression
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a NewArrayExpression that represents creating a    * n-dimensional array and initializing it from a list of    * elements.    *    * @param type Element type of the array.    */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayInit
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|dimension
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
return|return
operator|new
name|NewArrayExpression
argument_list|(
name|type
argument_list|,
name|dimension
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a NewArrayExpression that represents creating an    * n-dimensional array and initializing it from a list of    * elements, using varargs.    *    * @param type Element type of the array.    */
specifier|public
specifier|static
name|NewArrayExpression
name|newArrayInit
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|dimension
parameter_list|,
name|Expression
modifier|...
name|expressions
parameter_list|)
block|{
return|return
operator|new
name|NewArrayExpression
argument_list|(
name|type
argument_list|,
name|dimension
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|expressions
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents a bitwise complement    * operation.    */
specifier|public
specifier|static
name|UnaryExpression
name|not
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Not
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents a bitwise complement    * operation. The implementing method can be specified.    */
specifier|public
specifier|static
name|UnaryExpression
name|not
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Not
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an inequality    * comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|notEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|NotEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an inequality    * comparison.    */
specifier|public
specifier|static
name|BinaryExpression
name|notEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|boolean
name|liftToNull
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|NotEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|liftToNull
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Returns the expression representing the ones complement.    */
specifier|public
specifier|static
name|UnaryExpression
name|onesComplement
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|OnesComplement
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Returns the expression representing the ones complement.    */
specifier|public
specifier|static
name|UnaryExpression
name|onesComplement
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|OnesComplement
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise OR    * operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|or
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Or
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise OR    * operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|or
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Or
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise OR    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|orAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise OR    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|orAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise OR    * assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|orAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a conditional OR    * operation that evaluates the second operand only if the first    * operand evaluates to false.    */
specifier|public
specifier|static
name|BinaryExpression
name|orElse
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrElse
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a conditional OR    * operation that evaluates the second operand only if the first    * operand evaluates to false.    */
specifier|public
specifier|static
name|BinaryExpression
name|orElse
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|OrElse
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a ParameterExpression node that can be used to    * identify a parameter or a variable in an expression tree.    */
specifier|public
specifier|static
name|ParameterExpression
name|parameter
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|ParameterExpression
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates a ParameterExpression node that can be used to    * identify a parameter or a variable in an expression tree.    */
specifier|public
specifier|static
name|ParameterExpression
name|parameter
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
operator|new
name|ParameterExpression
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * Creates a ParameterExpression.    */
specifier|public
specifier|static
name|ParameterExpression
name|parameter
parameter_list|(
name|int
name|modifiers
parameter_list|,
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
operator|new
name|ParameterExpression
argument_list|(
name|modifiers
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents the assignment of    * the expression followed by a subsequent decrement by 1 of the    * original expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|postDecrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PostDecrementAssign
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents the assignment of    * the expression followed by a subsequent decrement by 1 of the    * original expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|postDecrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PostDecrementAssign
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents the assignment of    * the expression followed by a subsequent increment by 1 of the    * original expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|postIncrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PostIncrementAssign
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents the assignment of    * the expression followed by a subsequent increment by 1 of the    * original expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|postIncrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PostIncrementAssign
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents raising a number to    * a power.    */
comment|// REVIEW: In Java this is a call to a lib function, Math.pow.
specifier|public
specifier|static
name|BinaryExpression
name|power
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents raising a number to    * a power.    */
comment|// REVIEW: In Java this is a call to a lib function, Math.pow.
specifier|public
specifier|static
name|BinaryExpression
name|power
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents raising an    * expression to a power and assigning the result back to the    * expression.    */
comment|// REVIEW: In Java this is a call to a lib function, Math.pow.
specifier|public
specifier|static
name|BinaryExpression
name|powerAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents raising an    * expression to a power and assigning the result back to the    * expression.    */
comment|// REVIEW: In Java this is a call to a lib function, Math.pow.
specifier|public
specifier|static
name|BinaryExpression
name|powerAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents raising an    * expression to a power and assigning the result back to the    * expression.    */
specifier|public
specifier|static
name|BinaryExpression
name|powerAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that decrements the expression by 1    * and assigns the result back to the expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|preDecrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PreDecrementAssign
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that decrements the expression by 1    * and assigns the result back to the expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|preDecrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PreDecrementAssign
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that increments the expression by 1    * and assigns the result back to the expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|preIncrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PreIncrementAssign
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that increments the expression by 1    * and assigns the result back to the expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|preIncrementAssign
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|PreIncrementAssign
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a    * property by using a property accessor method.    */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|MemberExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a    * property.    */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|MemberExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|PropertyInfo
name|property
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a    * property.    */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|MemberExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|name
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an IndexExpression representing the access to an    * indexed property.    */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|IndexExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|PropertyInfo
name|property
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an IndexExpression representing the access to an    * indexed property, using varargs.    */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|IndexExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|PropertyInfo
name|property
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an IndexExpression representing the access to an    * indexed property.    */
comment|// REVIEW: No equivalent to properties in Java.
specifier|public
specifier|static
name|IndexExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|name
parameter_list|,
name|Expression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberExpression accessing a property.    */
specifier|public
specifier|static
name|MemberExpression
name|property
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a MemberExpression that represents accessing a    * property or field.    */
comment|// REVIEW: Java does not have properties; can only be a field name.
specifier|public
specifier|static
name|MemberExpression
name|propertyOrField
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|String
name|propertyOfFieldName
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that represents an expression that    * has a constant value of type Expression.    */
specifier|public
specifier|static
name|UnaryExpression
name|quote
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|Quote
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Reduces this node to a simpler expression. If CanReduce    * returns true, this should return a valid expression. This    * method can return another node which itself must be reduced.    */
specifier|public
specifier|static
name|Expression
name|reduce
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Reduces this node to a simpler expression. If CanReduce    * returns true, this should return a valid expression. This    * method can return another node which itself must be reduced.    */
specifier|public
specifier|static
name|Expression
name|reduceAndCheck
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Reduces the expression to a known node type (that is not an    * Extension node) or just returns the expression if it is already    * a known type.    */
specifier|public
specifier|static
name|Expression
name|reduceExtensions
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a reference    * equality comparison.    */
specifier|public
specifier|static
name|Expression
name|referenceEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Equal
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a reference    * inequality comparison.    */
specifier|public
specifier|static
name|Expression
name|referenceNotEqual
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|NotEqual
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents a rethrowing of an    * exception.    */
specifier|public
specifier|static
name|UnaryExpression
name|rethrow
parameter_list|()
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a UnaryExpression that represents a rethrowing of an    * exception with a given type.    */
specifier|public
specifier|static
name|UnaryExpression
name|rethrow
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a GotoExpression representing a return statement.    */
specifier|public
specifier|static
name|GotoStatement
name|return_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|)
block|{
return|return
name|return_
argument_list|(
name|labelTarget
argument_list|,
operator|(
name|Expression
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a GotoExpression representing a return statement. The    * value passed to the label upon jumping can be specified.    */
specifier|public
specifier|static
name|GotoStatement
name|return_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeGoto
argument_list|(
name|GotoExpressionKind
operator|.
name|Return
argument_list|,
name|labelTarget
argument_list|,
name|expression
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|GotoStatement
name|makeGoto
parameter_list|(
name|GotoExpressionKind
name|kind
parameter_list|,
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|)
block|{
return|return
operator|new
name|GotoStatement
argument_list|(
name|kind
argument_list|,
name|labelTarget
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a GotoExpression representing a return statement with    * the specified type.    */
specifier|public
specifier|static
name|GotoStatement
name|return_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a GotoExpression representing a return statement with    * the specified type. The value passed to the label upon jumping    * can be specified.    */
specifier|public
specifier|static
name|GotoStatement
name|return_
parameter_list|(
name|LabelTarget
name|labelTarget
parameter_list|,
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * right-shift operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|rightShift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShift
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * right-shift operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|rightShift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShift
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * right-shift assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|rightShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShiftAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * right-shift assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|rightShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShiftAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a bitwise    * right-shift assignment operation.    */
specifier|public
specifier|static
name|BinaryExpression
name|rightShiftAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|RightShiftAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/**    * Creates an instance of RuntimeVariablesExpression.    */
specifier|public
specifier|static
name|RuntimeVariablesExpression
name|runtimeVariables
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|ParameterExpression
argument_list|>
name|expressions
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an instance of RuntimeVariablesExpression, using varargs.    */
specifier|public
specifier|static
name|RuntimeVariablesExpression
name|runtimeVariables
parameter_list|(
name|ParameterExpression
modifier|...
name|arguments
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * subtraction operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtract
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Subtract
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * subtraction operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtract
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|Subtract
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a subtraction    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a subtraction    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a subtraction    * assignment operation that does not have overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssign
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssign
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a subtraction    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a subtraction    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents a subtraction    * assignment operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtractAssignChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|,
name|LambdaExpression
name|lambdaExpression
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractAssignChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|,
name|method
argument_list|,
name|lambdaExpression
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * subtraction operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtractChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Creates a BinaryExpression that represents an arithmetic    * subtraction operation that has overflow checking.    */
specifier|public
specifier|static
name|BinaryExpression
name|subtractChecked
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeBinary
argument_list|(
name|ExpressionType
operator|.
name|SubtractChecked
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|shouldLift
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|method
argument_list|)
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a SwitchExpression that represents a switch statement    * without a default case.    */
specifier|public
specifier|static
name|SwitchStatement
name|switch_
parameter_list|(
name|Expression
name|switchValue
parameter_list|,
name|SwitchCase
modifier|...
name|cases
parameter_list|)
block|{
return|return
name|switch_
argument_list|(
name|switchValue
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|cases
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a SwitchExpression that represents a switch statement    * that has a default case.    */
specifier|public
specifier|static
name|SwitchStatement
name|switch_
parameter_list|(
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|SwitchCase
modifier|...
name|cases
parameter_list|)
block|{
return|return
name|switch_
argument_list|(
name|switchValue
argument_list|,
name|defaultBody
argument_list|,
literal|null
argument_list|,
name|toList
argument_list|(
name|cases
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a SwitchExpression that represents a switch statement    * that has a default case.    */
specifier|public
specifier|static
name|SwitchStatement
name|switch_
parameter_list|(
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|SwitchCase
argument_list|>
name|cases
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a SwitchExpression that represents a switch statement    * that has a default case, using varargs.    */
specifier|public
specifier|static
name|SwitchStatement
name|switch_
parameter_list|(
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|Method
name|method
parameter_list|,
name|SwitchCase
modifier|...
name|cases
parameter_list|)
block|{
return|return
name|switch_
argument_list|(
name|switchValue
argument_list|,
name|defaultBody
argument_list|,
name|method
argument_list|,
name|toList
argument_list|(
name|cases
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a SwitchExpression that represents a switch statement    * that has a default case.    */
specifier|public
specifier|static
name|SwitchStatement
name|switch_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|Method
name|method
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|SwitchCase
argument_list|>
name|cases
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a SwitchExpression that represents a switch statement    * that has a default case, using varargs.    */
specifier|public
specifier|static
name|SwitchStatement
name|switch_
parameter_list|(
name|Type
name|type
parameter_list|,
name|Expression
name|switchValue
parameter_list|,
name|Expression
name|defaultBody
parameter_list|,
name|Method
name|method
parameter_list|,
name|SwitchCase
modifier|...
name|cases
parameter_list|)
block|{
return|return
name|switch_
argument_list|(
name|type
argument_list|,
name|switchValue
argument_list|,
name|defaultBody
argument_list|,
name|method
argument_list|,
name|toList
argument_list|(
name|cases
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a SwitchCase for use in a SwitchExpression.    */
specifier|public
specifier|static
name|SwitchCase
name|switchCase
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Expression
argument_list|>
name|body
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a SwitchCase for use in a SwitchExpression, with varargs.    */
specifier|public
specifier|static
name|SwitchCase
name|switchCase
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Expression
modifier|...
name|body
parameter_list|)
block|{
return|return
name|switchCase
argument_list|(
name|expression
argument_list|,
name|toList
argument_list|(
name|body
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates an instance of SymbolDocumentInfo.    */
specifier|public
specifier|static
name|SymbolDocumentInfo
name|symbolDocument
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an instance of SymbolDocumentInfo.    */
specifier|public
specifier|static
name|SymbolDocumentInfo
name|symbolDocument
parameter_list|(
name|String
name|fileName
parameter_list|,
name|UUID
name|language
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an instance of SymbolDocumentInfo.    */
specifier|public
specifier|static
name|SymbolDocumentInfo
name|symbolDocument
parameter_list|(
name|String
name|fileName
parameter_list|,
name|UUID
name|language
parameter_list|,
name|UUID
name|vendor
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates an instance of SymbolDocumentInfo.    */
specifier|public
specifier|static
name|SymbolDocumentInfo
name|symbolDocument
parameter_list|(
name|String
name|filename
parameter_list|,
name|UUID
name|language
parameter_list|,
name|UUID
name|vendor
parameter_list|,
name|UUID
name|documentType
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a statement that represents the throwing of an exception.    */
specifier|public
specifier|static
name|ThrowStatement
name|throw_
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
operator|new
name|ThrowStatement
argument_list|(
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a TryExpression representing a try block with any    * number of catch statements and neither a fault nor finally    * block.    */
specifier|public
specifier|static
name|TryStatement
name|tryCatch
parameter_list|(
name|Statement
name|body
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|CatchBlock
argument_list|>
name|handlers
parameter_list|)
block|{
return|return
operator|new
name|TryStatement
argument_list|(
name|body
argument_list|,
name|toList
argument_list|(
name|handlers
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a TryExpression representing a try block with any    * number of catch statements and neither a fault nor finally    * block, with varargs.    */
specifier|public
specifier|static
name|TryStatement
name|tryCatch
parameter_list|(
name|Statement
name|body
parameter_list|,
name|CatchBlock
modifier|...
name|handlers
parameter_list|)
block|{
return|return
operator|new
name|TryStatement
argument_list|(
name|body
argument_list|,
name|toList
argument_list|(
name|handlers
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates a TryExpression representing a try block with any    * number of catch statements and a finally block.    */
specifier|public
specifier|static
name|TryStatement
name|tryCatchFinally
parameter_list|(
name|Statement
name|body
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|CatchBlock
argument_list|>
name|handlers
parameter_list|,
name|Statement
name|finally_
parameter_list|)
block|{
return|return
operator|new
name|TryStatement
argument_list|(
name|body
argument_list|,
name|toList
argument_list|(
name|handlers
argument_list|)
argument_list|,
name|finally_
argument_list|)
return|;
block|}
comment|/**    * Creates a TryExpression representing a try block with any    * number of catch statements and a finally block, with varargs.    */
specifier|public
specifier|static
name|TryStatement
name|tryCatchFinally
parameter_list|(
name|Statement
name|body
parameter_list|,
name|Statement
name|finally_
parameter_list|,
name|CatchBlock
modifier|...
name|handlers
parameter_list|)
block|{
return|return
operator|new
name|TryStatement
argument_list|(
name|body
argument_list|,
name|toList
argument_list|(
name|handlers
argument_list|)
argument_list|,
name|finally_
argument_list|)
return|;
block|}
comment|/**    * Creates a TryExpression representing a try block with a    * finally block and no catch statements.    */
specifier|public
specifier|static
name|TryStatement
name|tryFinally
parameter_list|(
name|Statement
name|body
parameter_list|,
name|Statement
name|finally_
parameter_list|)
block|{
return|return
operator|new
name|TryStatement
argument_list|(
name|body
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|finally_
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents an explicit    * reference or boxing conversion where null is supplied if the    * conversion fails.    */
specifier|public
specifier|static
name|UnaryExpression
name|typeAs
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a TypeBinaryExpression that compares run-time type    * identity.    */
specifier|public
specifier|static
name|TypeBinaryExpression
name|typeEqual
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a TypeBinaryExpression.    */
specifier|public
specifier|static
name|TypeBinaryExpression
name|typeIs
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|TypeBinaryExpression
argument_list|(
name|ExpressionType
operator|.
name|TypeIs
argument_list|,
name|expression
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents a unary plus    * operation.    */
specifier|public
specifier|static
name|UnaryExpression
name|unaryPlus
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|UnaryPlus
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents a unary plus    * operation.    */
specifier|public
specifier|static
name|UnaryExpression
name|unaryPlus
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
name|makeUnary
argument_list|(
name|ExpressionType
operator|.
name|UnaryPlus
argument_list|,
name|expression
argument_list|,
name|expression
operator|.
name|getType
argument_list|()
argument_list|,
name|method
argument_list|)
return|;
block|}
comment|/**    * Creates a UnaryExpression that represents an explicit    * unboxing.    */
specifier|public
specifier|static
name|UnaryExpression
name|unbox
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
return|return
operator|new
name|UnaryExpression
argument_list|(
name|ExpressionType
operator|.
name|Unbox
argument_list|,
name|type
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/**    * Creates a ParameterExpression node that can be used to    * identify a parameter or a variable in an expression tree.    */
specifier|public
specifier|static
name|ParameterExpression
name|variable
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a ParameterExpression node that can be used to    * identify a parameter or a variable in an expression tree.    */
specifier|public
specifier|static
name|ParameterExpression
name|variable
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
operator|new
name|ParameterExpression
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * Reduces the node and then calls the visitor delegate on the    * reduced expression. The method throws an exception if the node    * is not reducible.    */
specifier|public
specifier|static
name|Expression
name|visitChildren
parameter_list|(
name|ExpressionVisitor
name|visitor
parameter_list|)
block|{
throw|throw
name|Extensions
operator|.
name|todo
argument_list|()
throw|;
block|}
comment|/**    * Creates a WhileExpression representing a while loop.    */
specifier|public
specifier|static
name|WhileStatement
name|while_
parameter_list|(
name|Expression
name|condition
parameter_list|,
name|Statement
name|body
parameter_list|)
block|{
return|return
operator|new
name|WhileStatement
argument_list|(
name|condition
argument_list|,
name|body
argument_list|)
return|;
block|}
comment|/**    * Creates a statement that declares a variable.    */
specifier|public
specifier|static
name|DeclarationStatement
name|declare
parameter_list|(
name|int
name|modifiers
parameter_list|,
name|ParameterExpression
name|parameter
parameter_list|,
name|Expression
name|initializer
parameter_list|)
block|{
return|return
operator|new
name|DeclarationStatement
argument_list|(
name|modifiers
argument_list|,
name|parameter
argument_list|,
name|initializer
argument_list|)
return|;
block|}
comment|/**    * Creates an expression that declares and initializes a variable. No    * type is required; it is assumed that the variable is the same type as    * the initializer. You can retrieve the {@link ParameterExpression} from    * the {@link DeclarationStatement#parameter} field of the result.    */
specifier|public
specifier|static
name|DeclarationStatement
name|declare
parameter_list|(
name|int
name|modifiers
parameter_list|,
name|String
name|name
parameter_list|,
name|Expression
name|initializer
parameter_list|)
block|{
assert|assert
name|initializer
operator|!=
literal|null
operator|:
literal|"empty initializer for variable declaration with name '"
operator|+
name|name
operator|+
literal|"', modifiers "
operator|+
name|modifiers
operator|+
literal|". Please use declare(int, ParameterExpression, initializer) instead"
assert|;
return|return
name|declare
argument_list|(
name|modifiers
argument_list|,
name|parameter
argument_list|(
name|initializer
operator|.
name|getType
argument_list|()
argument_list|,
name|name
argument_list|)
argument_list|,
name|initializer
argument_list|)
return|;
block|}
comment|/**    * Creates a statement that executes an expression.    */
specifier|public
specifier|static
name|Statement
name|statement
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
return|return
operator|new
name|GotoStatement
argument_list|(
name|GotoExpressionKind
operator|.
name|Sequence
argument_list|,
literal|null
argument_list|,
name|expression
argument_list|)
return|;
block|}
comment|/** Combines a list of expressions using AND.    * Returns TRUE if the list is empty.    * Returns FALSE if any of the conditions are constant FALSE;    * otherwise returns NULL if any of the conditions are constant NULL. */
specifier|public
specifier|static
name|Expression
name|foldAnd
parameter_list|(
name|List
argument_list|<
name|Expression
argument_list|>
name|conditions
parameter_list|)
block|{
name|Expression
name|e
init|=
literal|null
decl_stmt|;
name|int
name|nullCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Expression
name|condition
range|:
name|conditions
control|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|ConstantExpression
condition|)
block|{
specifier|final
name|Boolean
name|value
init|=
operator|(
name|Boolean
operator|)
operator|(
operator|(
name|ConstantExpression
operator|)
name|condition
operator|)
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
operator|++
name|nullCount
expr_stmt|;
continue|continue;
block|}
if|else if
condition|(
name|value
condition|)
block|{
continue|continue;
block|}
else|else
block|{
return|return
name|constant
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|e
operator|=
name|condition
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|andAlso
argument_list|(
name|e
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nullCount
operator|>
literal|0
condition|)
block|{
return|return
name|constant
argument_list|(
literal|null
argument_list|)
return|;
block|}
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
name|constant
argument_list|(
literal|true
argument_list|)
return|;
block|}
return|return
name|e
return|;
block|}
comment|/** Combines a list of expressions using OR.    * Returns FALSE if the list is empty.    * Returns TRUE if any of the conditions are constant TRUE;    * otherwise returns NULL if all of the conditions are constant NULL. */
specifier|public
specifier|static
name|Expression
name|foldOr
parameter_list|(
name|List
argument_list|<
name|Expression
argument_list|>
name|conditions
parameter_list|)
block|{
name|Expression
name|e
init|=
literal|null
decl_stmt|;
name|int
name|nullCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Expression
name|condition
range|:
name|conditions
control|)
block|{
if|if
condition|(
name|condition
operator|instanceof
name|ConstantExpression
condition|)
block|{
specifier|final
name|Boolean
name|value
init|=
operator|(
name|Boolean
operator|)
operator|(
operator|(
name|ConstantExpression
operator|)
name|condition
operator|)
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
operator|++
name|nullCount
expr_stmt|;
continue|continue;
block|}
if|else if
condition|(
name|value
condition|)
block|{
return|return
name|constant
argument_list|(
literal|true
argument_list|)
return|;
block|}
else|else
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|e
operator|=
name|condition
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|orElse
argument_list|(
name|e
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|nullCount
operator|>
literal|0
condition|)
block|{
return|return
name|constant
argument_list|(
literal|null
argument_list|)
return|;
block|}
return|return
name|constant
argument_list|(
literal|false
argument_list|)
return|;
block|}
return|return
name|e
return|;
block|}
comment|/**    * Creates an empty fluent list.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FluentList
argument_list|<
name|T
argument_list|>
name|list
parameter_list|()
block|{
return|return
operator|new
name|FluentArrayList
argument_list|<>
argument_list|()
return|;
block|}
comment|/**    * Creates a fluent list with given elements.    */
annotation|@
name|SafeVarargs
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FluentList
argument_list|<
name|T
argument_list|>
name|list
parameter_list|(
name|T
modifier|...
name|ts
parameter_list|)
block|{
return|return
operator|new
name|FluentArrayList
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|ts
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a fluent list with elements from the given collection.    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|FluentList
argument_list|<
name|T
argument_list|>
name|list
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|ts
parameter_list|)
block|{
return|return
operator|new
name|FluentArrayList
argument_list|<>
argument_list|(
name|toList
argument_list|(
name|ts
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Evaluates an expression and returns the result.    */
specifier|public
specifier|static
name|Object
name|evaluate
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
specifier|final
name|Evaluator
name|evaluator
init|=
operator|new
name|Evaluator
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|AbstractNode
operator|)
name|node
operator|)
operator|.
name|evaluate
argument_list|(
name|evaluator
argument_list|)
return|;
block|}
comment|// ~ Private helper methods ------------------------------------------------
specifier|private
specifier|static
name|boolean
name|shouldLift
parameter_list|(
name|Expression
name|left
parameter_list|,
name|Expression
name|right
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
comment|// FIXME: Implement the rules in modulo
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|Class
name|deduceType
parameter_list|(
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterList
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|parameterList
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
return|return
name|Function0
operator|.
name|class
return|;
case|case
literal|1
case|:
return|return
name|type
operator|==
name|Boolean
operator|.
name|TYPE
condition|?
name|Predicate1
operator|.
name|class
else|:
name|Function1
operator|.
name|class
return|;
case|case
literal|2
case|:
return|return
name|type
operator|==
name|Boolean
operator|.
name|TYPE
condition|?
name|Predicate2
operator|.
name|class
else|:
name|Function2
operator|.
name|class
return|;
default|default:
return|return
name|Function
operator|.
name|class
return|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|toList
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|iterable
operator|instanceof
name|List
condition|)
block|{
return|return
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
return|;
block|}
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|parameter
range|:
name|iterable
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|toList
parameter_list|(
name|T
index|[]
name|ts
parameter_list|)
block|{
if|if
condition|(
name|ts
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|ts
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|toCollection
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|)
block|{
if|if
condition|(
name|iterable
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|(
name|Collection
argument_list|<
name|T
argument_list|>
operator|)
name|iterable
return|;
block|}
return|return
name|toList
argument_list|(
name|iterable
argument_list|)
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|iterable
parameter_list|,
name|T
index|[]
name|a
parameter_list|)
block|{
return|return
name|toCollection
argument_list|(
name|iterable
argument_list|)
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
specifier|static
parameter_list|<
name|T
extends|extends
name|Expression
parameter_list|>
name|Expression
name|accept
parameter_list|(
name|T
name|node
parameter_list|,
name|Shuttle
name|shuttle
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|node
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|static
parameter_list|<
name|T
extends|extends
name|Statement
parameter_list|>
name|Statement
name|accept
parameter_list|(
name|T
name|node
parameter_list|,
name|Shuttle
name|shuttle
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|node
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
return|;
block|}
specifier|static
name|List
argument_list|<
name|Statement
argument_list|>
name|acceptStatements
parameter_list|(
name|List
argument_list|<
name|Statement
argument_list|>
name|statements
parameter_list|,
name|Shuttle
name|shuttle
parameter_list|)
block|{
if|if
condition|(
name|statements
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|statements
return|;
comment|// short cut
block|}
specifier|final
name|List
argument_list|<
name|Statement
argument_list|>
name|statements1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Statement
name|statement
range|:
name|statements
control|)
block|{
name|Statement
name|newStatement
init|=
name|statement
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
if|if
condition|(
name|newStatement
operator|instanceof
name|GotoStatement
condition|)
block|{
name|GotoStatement
name|goto_
init|=
operator|(
name|GotoStatement
operator|)
name|newStatement
decl_stmt|;
if|if
condition|(
name|goto_
operator|.
name|kind
operator|==
name|GotoExpressionKind
operator|.
name|Sequence
operator|&&
name|goto_
operator|.
name|expression
operator|==
literal|null
condition|)
block|{
comment|// ignore empty statements
continue|continue;
block|}
block|}
name|statements1
operator|.
name|add
argument_list|(
name|newStatement
argument_list|)
expr_stmt|;
block|}
return|return
name|statements1
return|;
block|}
specifier|static
name|List
argument_list|<
name|Node
argument_list|>
name|acceptNodes
parameter_list|(
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
parameter_list|,
name|Shuttle
name|shuttle
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|nodes
return|;
comment|// short cut
block|}
specifier|final
name|List
argument_list|<
name|Node
argument_list|>
name|statements1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
name|statements1
operator|.
name|add
argument_list|(
name|node
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|statements1
return|;
block|}
specifier|static
name|List
argument_list|<
name|Expression
argument_list|>
name|acceptParameterExpressions
parameter_list|(
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterExpressions
parameter_list|,
name|Shuttle
name|shuttle
parameter_list|)
block|{
if|if
condition|(
name|parameterExpressions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
comment|// short cut
block|}
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|parameterExpressions1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParameterExpression
name|parameterExpression
range|:
name|parameterExpressions
control|)
block|{
name|parameterExpressions1
operator|.
name|add
argument_list|(
name|parameterExpression
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|parameterExpressions1
return|;
block|}
specifier|static
name|List
argument_list|<
name|DeclarationStatement
argument_list|>
name|acceptDeclarations
parameter_list|(
name|List
argument_list|<
name|DeclarationStatement
argument_list|>
name|declarations
parameter_list|,
name|Shuttle
name|shuttle
parameter_list|)
block|{
if|if
condition|(
name|declarations
operator|==
literal|null
operator|||
name|declarations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|declarations
return|;
comment|// short cut
block|}
specifier|final
name|List
argument_list|<
name|DeclarationStatement
argument_list|>
name|declarations1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DeclarationStatement
name|declaration
range|:
name|declarations
control|)
block|{
name|declarations1
operator|.
name|add
argument_list|(
name|declaration
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|declarations1
return|;
block|}
specifier|static
name|List
argument_list|<
name|MemberDeclaration
argument_list|>
name|acceptMemberDeclarations
parameter_list|(
name|List
argument_list|<
name|MemberDeclaration
argument_list|>
name|memberDeclarations
parameter_list|,
name|Shuttle
name|shuttle
parameter_list|)
block|{
if|if
condition|(
name|memberDeclarations
operator|==
literal|null
operator|||
name|memberDeclarations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|memberDeclarations
return|;
comment|// short cut
block|}
specifier|final
name|List
argument_list|<
name|MemberDeclaration
argument_list|>
name|memberDeclarations1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|MemberDeclaration
name|memberDeclaration
range|:
name|memberDeclarations
control|)
block|{
name|memberDeclarations1
operator|.
name|add
argument_list|(
name|memberDeclaration
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|memberDeclarations1
return|;
block|}
specifier|static
name|List
argument_list|<
name|Expression
argument_list|>
name|acceptExpressions
parameter_list|(
name|List
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|,
name|Shuttle
name|shuttle
parameter_list|)
block|{
if|if
condition|(
name|expressions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|expressions
return|;
comment|// short cut
block|}
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|expressions1
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Expression
name|expression
range|:
name|expressions
control|)
block|{
name|expressions1
operator|.
name|add
argument_list|(
name|expression
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expressions1
return|;
block|}
specifier|static
parameter_list|<
name|R
parameter_list|>
name|R
name|acceptNodes
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Node
argument_list|>
name|nodes
parameter_list|,
name|Visitor
argument_list|<
name|R
argument_list|>
name|visitor
parameter_list|)
block|{
name|R
name|r
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
name|r
operator|=
name|node
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
comment|// ~ Classes and interfaces ------------------------------------------------
comment|// Some interfaces we'd rather not implement yet. They don't seem relevant
comment|// in the Java world.
comment|/** Property info. */
interface|interface
name|PropertyInfo
block|{   }
comment|/** Runtime variables expression. */
interface|interface
name|RuntimeVariablesExpression
block|{   }
comment|/** Symbol document info. */
interface|interface
name|SymbolDocumentInfo
block|{   }
comment|/** Fluent list.    *    * @param<T> element type */
specifier|public
interface|interface
name|FluentList
parameter_list|<
name|T
parameter_list|>
extends|extends
name|List
argument_list|<
name|T
argument_list|>
block|{
name|FluentList
argument_list|<
name|T
argument_list|>
name|append
parameter_list|(
name|T
name|t
parameter_list|)
function_decl|;
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendIf
parameter_list|(
name|boolean
name|condition
parameter_list|,
name|T
name|t
parameter_list|)
function_decl|;
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendIfNotNull
parameter_list|(
name|T
name|t
parameter_list|)
function_decl|;
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendAll
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|ts
parameter_list|)
function_decl|;
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendAll
parameter_list|(
name|T
modifier|...
name|ts
parameter_list|)
function_decl|;
block|}
comment|/** Fluent array list.    *    * @param<T> element type */
specifier|private
specifier|static
class|class
name|FluentArrayList
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ArrayList
argument_list|<
name|T
argument_list|>
implements|implements
name|FluentList
argument_list|<
name|T
argument_list|>
block|{
name|FluentArrayList
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
name|FluentArrayList
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|c
parameter_list|)
block|{
name|super
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|append
parameter_list|(
name|T
name|t
parameter_list|)
block|{
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendIf
parameter_list|(
name|boolean
name|condition
parameter_list|,
name|T
name|t
parameter_list|)
block|{
if|if
condition|(
name|condition
condition|)
block|{
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendIfNotNull
parameter_list|(
name|T
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendAll
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|ts
parameter_list|)
block|{
name|addAll
argument_list|(
name|toCollection
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|FluentList
argument_list|<
name|T
argument_list|>
name|appendAll
parameter_list|(
name|T
modifier|...
name|ts
parameter_list|)
block|{
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
block|}
end_class

end_unit

