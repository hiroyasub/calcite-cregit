begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|jdbc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLFeatureNotSupportedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_comment
comment|/**  * All we know about a statement. Encapsulates a {@link ResultSet}.  */
end_comment

begin_class
specifier|public
class|class
name|StatementInfo
block|{
specifier|private
specifier|volatile
name|Boolean
name|relativeSupported
init|=
literal|null
decl_stmt|;
specifier|final
name|Statement
name|statement
decl_stmt|;
comment|// sometimes a PreparedStatement
specifier|private
name|ResultSet
name|resultSet
decl_stmt|;
specifier|private
name|long
name|position
init|=
literal|0
decl_stmt|;
comment|// True when setResultSet(ResultSet) is called to let us determine the difference between
comment|// a null ResultSet (from an update) from the lack of a ResultSet.
specifier|private
name|boolean
name|resultsInitialized
init|=
literal|false
decl_stmt|;
specifier|public
name|StatementInfo
parameter_list|(
name|Statement
name|statement
parameter_list|)
block|{
name|this
operator|.
name|statement
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|statement
argument_list|)
expr_stmt|;
block|}
comment|// Visible for testing
name|void
name|setPosition
parameter_list|(
name|long
name|position
parameter_list|)
block|{
name|this
operator|.
name|position
operator|=
name|position
expr_stmt|;
block|}
comment|// Visible for testing
name|long
name|getPosition
parameter_list|()
block|{
return|return
name|this
operator|.
name|position
return|;
block|}
comment|/**    * Set a ResultSet on this object.    *    * @param resultSet The current ResultSet    */
specifier|public
name|void
name|setResultSet
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
block|{
name|resultsInitialized
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|resultSet
operator|=
name|resultSet
expr_stmt|;
block|}
comment|/**    * @return The {@link ResultSet} for this Statement, may be null.    */
specifier|public
name|ResultSet
name|getResultSet
parameter_list|()
block|{
return|return
name|this
operator|.
name|resultSet
return|;
block|}
comment|/**    * @return True if {@link #setResultSet(ResultSet)} was ever invoked.    */
specifier|public
name|boolean
name|isResultSetInitialized
parameter_list|()
block|{
return|return
name|resultsInitialized
return|;
block|}
comment|/**    * @see ResultSet#next()    */
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|SQLException
block|{
return|return
name|_next
argument_list|(
name|resultSet
argument_list|)
return|;
block|}
name|boolean
name|_next
parameter_list|(
name|ResultSet
name|results
parameter_list|)
throws|throws
name|SQLException
block|{
name|boolean
name|ret
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
name|position
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Consumes<code>offset - position</code> elements from the {@link ResultSet}.    *    * @param offset The offset to advance to    * @return True if the resultSet was advanced to the current point, false if insufficient rows    *      were present to advance to the requested offset.    */
specifier|public
name|boolean
name|advanceResultSetToOffset
parameter_list|(
name|ResultSet
name|results
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|<
name|position
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Offset should be "
operator|+
literal|" non-negative and not less than the current position. "
operator|+
name|offset
operator|+
literal|", "
operator|+
name|position
argument_list|)
throw|;
block|}
if|if
condition|(
name|position
operator|>=
name|offset
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
literal|null
operator|==
name|relativeSupported
condition|)
block|{
name|Boolean
name|moreResults
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
literal|null
operator|==
name|relativeSupported
condition|)
block|{
try|try
block|{
name|moreResults
operator|=
name|advanceByRelative
argument_list|(
name|results
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|relativeSupported
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLFeatureNotSupportedException
name|e
parameter_list|)
block|{
name|relativeSupported
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|null
operator|!=
name|moreResults
condition|)
block|{
comment|// We figured out whether or not relative is supported.
comment|// Make sure we actually do the necessary work.
if|if
condition|(
operator|!
name|relativeSupported
condition|)
block|{
comment|// We avoided calling advanceByNext in the synchronized block earlier.
name|moreResults
operator|=
name|advanceByNext
argument_list|(
name|results
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|moreResults
return|;
block|}
comment|// Another thread updated the RELATIVE_SUPPORTED before we did, fall through.
block|}
if|if
condition|(
name|relativeSupported
condition|)
block|{
return|return
name|advanceByRelative
argument_list|(
name|results
argument_list|,
name|offset
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|advanceByNext
argument_list|(
name|results
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
specifier|private
name|boolean
name|advanceByRelative
parameter_list|(
name|ResultSet
name|results
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|SQLException
block|{
name|long
name|diff
init|=
name|offset
operator|-
name|position
decl_stmt|;
while|while
condition|(
name|diff
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
if|if
condition|(
operator|!
name|results
operator|.
name|relative
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
condition|)
block|{
comment|// Avoid updating position until relative succeeds.
name|position
operator|+=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Avoid updating position until relative succeeds.
name|position
operator|+=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
name|diff
operator|-=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|boolean
name|ret
init|=
name|results
operator|.
name|relative
argument_list|(
operator|(
name|int
operator|)
name|diff
argument_list|)
decl_stmt|;
comment|// Make sure we only update the position after successfully calling relative(int).
name|position
operator|+=
name|diff
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
name|boolean
name|advanceByNext
parameter_list|(
name|ResultSet
name|results
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|SQLException
block|{
while|while
condition|(
name|position
operator|<
name|offset
condition|)
block|{
comment|// Advance while maintaining `position`
if|if
condition|(
operator|!
name|_next
argument_list|(
name|results
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

begin_comment
comment|// End StatementInfo.java
end_comment

end_unit

