begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Casing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Quoting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|Lex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|dialect
operator|.
name|AnsiSqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|StringAndPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
operator|.
name|AbstractSqlTester
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
operator|.
name|SqlTestFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
operator|.
name|SqlTester
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
operator|.
name|SqlTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlConformance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlConformanceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonotonicity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorNamespace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|catalog
operator|.
name|MockCatalogReaderExtended
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|UnaryOperator
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
operator|.
name|stripAs
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|notNullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * A fixture for testing the SQL validator.  *  *<p>It provides a fluent API so that you can write tests by chaining method  * calls.  *  *<p>It is immutable. If you have two test cases that require a similar set up  * (for example, the same SQL expression and parser configuration), it is safe  * to use the same fixture object as a starting point for both tests.  */
end_comment

begin_class
specifier|public
class|class
name|SqlValidatorFixture
block|{
specifier|public
specifier|final
name|SqlTester
name|tester
decl_stmt|;
specifier|public
specifier|final
name|SqlTestFactory
name|factory
decl_stmt|;
specifier|public
specifier|final
name|StringAndPos
name|sap
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|expression
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|whole
decl_stmt|;
comment|/**    * Creates a SqlValidatorFixture.    *    * @param tester     Tester    * @param sap        SQL query or expression    * @param expression True if {@code sql} is an expression,    *                   false if it is a query    * @param whole      Whether the failure location is the whole query or    *                   expression    */
specifier|protected
name|SqlValidatorFixture
parameter_list|(
name|SqlTester
name|tester
parameter_list|,
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|boolean
name|expression
parameter_list|,
name|boolean
name|whole
parameter_list|)
block|{
name|this
operator|.
name|tester
operator|=
name|tester
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|expression
operator|=
name|expression
expr_stmt|;
name|this
operator|.
name|sap
operator|=
name|sap
expr_stmt|;
name|this
operator|.
name|whole
operator|=
name|whole
expr_stmt|;
block|}
specifier|public
name|SqlValidatorFixture
name|withTester
parameter_list|(
name|UnaryOperator
argument_list|<
name|SqlTester
argument_list|>
name|transform
parameter_list|)
block|{
specifier|final
name|SqlTester
name|tester
init|=
name|transform
operator|.
name|apply
argument_list|(
name|this
operator|.
name|tester
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlValidatorFixture
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|sap
argument_list|,
name|expression
argument_list|,
name|whole
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withFactory
parameter_list|(
name|UnaryOperator
argument_list|<
name|SqlTestFactory
argument_list|>
name|transform
parameter_list|)
block|{
specifier|final
name|SqlTestFactory
name|factory
init|=
name|transform
operator|.
name|apply
argument_list|(
name|this
operator|.
name|factory
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlValidatorFixture
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|sap
argument_list|,
name|expression
argument_list|,
name|whole
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withParserConfig
parameter_list|(
name|UnaryOperator
argument_list|<
name|SqlParser
operator|.
name|Config
argument_list|>
name|transform
parameter_list|)
block|{
return|return
name|withFactory
argument_list|(
name|f
lambda|->
name|f
operator|.
name|withParserConfig
argument_list|(
name|transform
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|SqlParser
operator|.
name|Config
name|parserConfig
parameter_list|()
block|{
return|return
name|factory
operator|.
name|parserConfig
argument_list|()
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withSql
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|StringAndPos
name|sap
init|=
name|StringAndPos
operator|.
name|of
argument_list|(
name|sql
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlValidatorFixture
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|sap
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withExpr
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|StringAndPos
name|sap
init|=
name|StringAndPos
operator|.
name|of
argument_list|(
name|sql
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlValidatorFixture
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|sap
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|StringAndPos
name|toSql
parameter_list|(
name|boolean
name|withCaret
parameter_list|)
block|{
return|return
name|expression
condition|?
name|StringAndPos
operator|.
name|of
argument_list|(
name|AbstractSqlTester
operator|.
name|buildQuery
argument_list|(
name|sap
operator|.
name|addCarets
argument_list|()
argument_list|)
argument_list|)
else|:
name|sap
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withExtendedCatalog
parameter_list|()
block|{
return|return
name|withCatalogReader
argument_list|(
name|MockCatalogReaderExtended
operator|::
name|create
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withCatalogReader
parameter_list|(
name|SqlTestFactory
operator|.
name|CatalogReaderFactory
name|catalogReaderFactory
parameter_list|)
block|{
return|return
name|withFactory
argument_list|(
name|f
lambda|->
name|f
operator|.
name|withCatalogReader
argument_list|(
name|catalogReaderFactory
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withQuoting
parameter_list|(
name|Quoting
name|quoting
parameter_list|)
block|{
return|return
name|withParserConfig
argument_list|(
name|config
lambda|->
name|config
operator|.
name|withQuoting
argument_list|(
name|quoting
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withLex
parameter_list|(
name|Lex
name|lex
parameter_list|)
block|{
return|return
name|withParserConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withQuoting
argument_list|(
name|lex
operator|.
name|quoting
argument_list|)
operator|.
name|withCaseSensitive
argument_list|(
name|lex
operator|.
name|caseSensitive
argument_list|)
operator|.
name|withQuotedCasing
argument_list|(
name|lex
operator|.
name|quotedCasing
argument_list|)
operator|.
name|withUnquotedCasing
argument_list|(
name|lex
operator|.
name|unquotedCasing
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withConformance
parameter_list|(
name|SqlConformance
name|conformance
parameter_list|)
block|{
return|return
name|withValidatorConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withConformance
argument_list|(
name|conformance
argument_list|)
argument_list|)
operator|.
name|withParserConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withConformance
argument_list|(
name|conformance
argument_list|)
argument_list|)
operator|.
name|withFactory
argument_list|(
name|f
lambda|->
name|conformance
operator|instanceof
name|SqlConformanceEnum
condition|?
name|f
operator|.
name|withConnectionFactory
argument_list|(
name|cf
lambda|->
name|cf
operator|.
name|with
argument_list|(
name|CalciteConnectionProperty
operator|.
name|CONFORMANCE
argument_list|,
name|conformance
argument_list|)
argument_list|)
else|:
name|f
argument_list|)
return|;
block|}
specifier|public
name|SqlConformance
name|conformance
parameter_list|()
block|{
return|return
name|factory
operator|.
name|parserConfig
argument_list|()
operator|.
name|conformance
argument_list|()
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|withTypeCoercion
parameter_list|(
name|boolean
name|typeCoercion
parameter_list|)
block|{
return|return
name|withValidatorConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withTypeCoercionEnabled
argument_list|(
name|typeCoercion
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a tester that does not fail validation if it encounters an    * unknown function.    */
specifier|public
name|SqlValidatorFixture
name|withLenientOperatorLookup
parameter_list|(
name|boolean
name|lenient
parameter_list|)
block|{
return|return
name|withValidatorConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withLenientOperatorLookup
argument_list|(
name|lenient
argument_list|)
argument_list|)
return|;
block|}
name|SqlValidatorFixture
name|withWhole
parameter_list|(
name|boolean
name|whole
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|sap
operator|.
name|cursor
operator|<
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|StringAndPos
name|sap
init|=
name|StringAndPos
operator|.
name|of
argument_list|(
literal|"^"
operator|+
name|this
operator|.
name|sap
operator|.
name|sql
operator|+
literal|"^"
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlValidatorFixture
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|sap
argument_list|,
name|expression
argument_list|,
name|whole
argument_list|)
return|;
block|}
name|SqlValidatorFixture
name|ok
parameter_list|()
block|{
name|tester
operator|.
name|assertExceptionIsThrown
argument_list|(
name|factory
argument_list|,
name|toSql
argument_list|(
literal|false
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Checks that a SQL expression gives a particular error.    */
name|SqlValidatorFixture
name|fails
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
name|requireNonNull
argument_list|(
name|expected
argument_list|,
literal|"expected"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|assertExceptionIsThrown
argument_list|(
name|factory
argument_list|,
name|toSql
argument_list|(
literal|true
argument_list|)
argument_list|,
name|expected
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Checks that a SQL expression fails, giving an {@code expected} error,    * if {@code b} is true, otherwise succeeds.    */
name|SqlValidatorFixture
name|failsIf
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
if|if
condition|(
name|b
condition|)
block|{
name|fails
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ok
argument_list|()
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Checks that a query returns a row of the expected type. For example,    *    *<blockquote>    *<code>sql("select empno, name from emp")<br>    * .type("{EMPNO INTEGER NOT NULL, NAME VARCHAR(10) NOT NULL}");</code>    *</blockquote>    *    * @param expectedType Expected row type    */
specifier|public
name|SqlValidatorFixture
name|type
parameter_list|(
name|String
name|expectedType
parameter_list|)
block|{
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|sap
argument_list|,
parameter_list|(
name|sql1
parameter_list|,
name|validator
parameter_list|,
name|n
parameter_list|)
lambda|->
block|{
name|RelDataType
name|actualType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|String
name|actual
init|=
name|SqlTests
operator|.
name|getTypeString
argument_list|(
name|actualType
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|actual
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Checks that a query returns a single column, and that the column has the    * expected type. For example,    *    *<blockquote>    *<code>sql("SELECT empno FROM Emp").columnType("INTEGER NOT NULL");</code>    *</blockquote>    *    * @param expectedType Expected type, including nullability    */
specifier|public
name|SqlValidatorFixture
name|columnType
parameter_list|(
name|String
name|expectedType
parameter_list|)
block|{
name|tester
operator|.
name|checkColumnType
argument_list|(
name|factory
argument_list|,
name|toSql
argument_list|(
literal|false
argument_list|)
operator|.
name|sql
argument_list|,
name|expectedType
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Tests that the first column of the query has a given monotonicity.    *    * @param matcher Expected monotonicity    */
specifier|public
name|SqlValidatorFixture
name|assertMonotonicity
parameter_list|(
name|Matcher
argument_list|<
name|SqlMonotonicity
argument_list|>
name|matcher
parameter_list|)
block|{
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|toSql
argument_list|(
literal|false
argument_list|)
argument_list|,
parameter_list|(
name|sap
parameter_list|,
name|validator
parameter_list|,
name|n
parameter_list|)
lambda|->
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|selectNamespace
init|=
name|validator
operator|.
name|getNamespace
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|String
name|field0
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|SqlMonotonicity
name|monotonicity
init|=
name|selectNamespace
operator|.
name|getMonotonicity
argument_list|(
name|field0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|monotonicity
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|SqlValidatorFixture
name|assertBindType
parameter_list|(
name|Matcher
argument_list|<
name|String
argument_list|>
name|matcher
parameter_list|)
block|{
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|sap
argument_list|,
parameter_list|(
name|sap
parameter_list|,
name|validator
parameter_list|,
name|validatedNode
parameter_list|)
lambda|->
block|{
specifier|final
name|RelDataType
name|parameterRowType
init|=
name|validator
operator|.
name|getParameterRowType
argument_list|(
name|validatedNode
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|parameterRowType
operator|.
name|toString
argument_list|()
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|void
name|assertCharset
parameter_list|(
name|Matcher
argument_list|<
name|Charset
argument_list|>
name|charsetMatcher
parameter_list|)
block|{
name|tester
operator|.
name|forEachQuery
argument_list|(
name|factory
argument_list|,
name|sap
operator|.
name|addCarets
argument_list|()
argument_list|,
name|query
lambda|->
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
name|query
argument_list|)
argument_list|,
parameter_list|(
name|sap
parameter_list|,
name|validator
parameter_list|,
name|n
parameter_list|)
lambda|->
block|{
name|final
name|RelDataType
name|rowType
operator|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|n
argument_list|)
argument_list|;
name|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
operator|=
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|;
name|assertThat
argument_list|(
literal|"expected query to return 1 field"
argument_list|,
name|fields
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|;
name|RelDataType
name|actualType
operator|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|;
name|Charset
name|actualCharset
operator|=
name|actualType
operator|.
name|getCharset
argument_list|()
argument_list|;
name|assertThat
argument_list|(
name|actualCharset
argument_list|,
name|charsetMatcher
argument_list|)
argument_list|;
block|}
block|)
end_class

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
unit|}    public
name|void
name|assertCollation
parameter_list|(
name|Matcher
argument_list|<
name|String
argument_list|>
name|collationMatcher
parameter_list|,
name|Matcher
argument_list|<
name|SqlCollation
operator|.
name|Coercibility
argument_list|>
name|coercibilityMatcher
parameter_list|)
block|{
name|tester
operator|.
name|forEachQuery
argument_list|(
name|factory
argument_list|,
name|sap
operator|.
name|addCarets
argument_list|()
argument_list|,
name|query
lambda|->
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
name|query
argument_list|)
argument_list|,
parameter_list|(
name|sap
parameter_list|,
name|validator
parameter_list|,
name|n
parameter_list|)
lambda|->
block|{
name|RelDataType
name|rowType
operator|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|n
argument_list|)
argument_list|;
name|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
operator|=
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|;
name|assertThat
argument_list|(
literal|"expected query to return 1 field"
argument_list|,
name|fields
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|;
name|RelDataType
name|actualType
operator|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|;
name|SqlCollation
name|collation
operator|=
name|actualType
operator|.
name|getCollation
argument_list|()
argument_list|;
name|assertThat
argument_list|(
name|collation
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
argument_list|;
name|assertThat
argument_list|(
name|collation
operator|.
name|getCollationName
argument_list|()
argument_list|,
name|collationMatcher
argument_list|)
argument_list|;
name|assertThat
argument_list|(
name|collation
operator|.
name|getCoercibility
argument_list|()
argument_list|,
name|coercibilityMatcher
argument_list|)
argument_list|;
block|}
end_function

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Checks if the interval value conversion to milliseconds is valid. For    * example,    *    *<blockquote>    *<code>sql("VALUES (INTERVAL '1' Minute)").intervalConv("60000");</code>    *</blockquote>    */
end_comment

begin_function
unit|public
name|void
name|assertInterval
parameter_list|(
name|Matcher
argument_list|<
name|Long
argument_list|>
name|matcher
parameter_list|)
block|{
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|toSql
argument_list|(
literal|false
argument_list|)
argument_list|,
parameter_list|(
name|sap
parameter_list|,
name|validator
parameter_list|,
name|validatedNode
parameter_list|)
lambda|->
block|{
specifier|final
name|SqlCall
name|n
init|=
operator|(
name|SqlCall
operator|)
name|validatedNode
decl_stmt|;
name|SqlNode
name|node
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
operator|.
name|operandCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|stripAs
argument_list|(
name|n
operator|.
name|operand
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
name|node
operator|=
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|assertNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SqlIntervalLiteral
name|intervalLiteral
init|=
operator|(
name|SqlIntervalLiteral
operator|)
name|node
decl_stmt|;
name|SqlIntervalLiteral
operator|.
name|IntervalValue
name|interval
init|=
name|intervalLiteral
operator|.
name|getValueAs
argument_list|(
name|SqlIntervalLiteral
operator|.
name|IntervalValue
operator|.
name|class
argument_list|)
decl_stmt|;
name|long
name|l
init|=
name|interval
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|isYearMonth
argument_list|()
condition|?
name|SqlParserUtil
operator|.
name|intervalToMonths
argument_list|(
name|interval
argument_list|)
else|:
name|SqlParserUtil
operator|.
name|intervalToMillis
argument_list|(
name|interval
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|l
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|withCaseSensitive
parameter_list|(
name|boolean
name|caseSensitive
parameter_list|)
block|{
return|return
name|withParserConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withCaseSensitive
argument_list|(
name|caseSensitive
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|withOperatorTable
parameter_list|(
name|SqlOperatorTable
name|operatorTable
parameter_list|)
block|{
return|return
name|withFactory
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withOperatorTable
argument_list|(
name|o
lambda|->
name|operatorTable
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|withQuotedCasing
parameter_list|(
name|Casing
name|casing
parameter_list|)
block|{
return|return
name|withParserConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withQuotedCasing
argument_list|(
name|casing
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|withUnquotedCasing
parameter_list|(
name|Casing
name|casing
parameter_list|)
block|{
return|return
name|withParserConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withUnquotedCasing
argument_list|(
name|casing
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|withValidatorConfig
parameter_list|(
name|UnaryOperator
argument_list|<
name|SqlValidator
operator|.
name|Config
argument_list|>
name|transform
parameter_list|)
block|{
return|return
name|withFactory
argument_list|(
name|f
lambda|->
name|f
operator|.
name|withValidatorConfig
argument_list|(
name|transform
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|withValidatorIdentifierExpansion
parameter_list|(
name|boolean
name|expansion
parameter_list|)
block|{
return|return
name|withValidatorConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withIdentifierExpansion
argument_list|(
name|expansion
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|withValidatorCallRewrite
parameter_list|(
name|boolean
name|rewrite
parameter_list|)
block|{
return|return
name|withValidatorConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withCallRewrite
argument_list|(
name|rewrite
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|withValidatorColumnReferenceExpansion
parameter_list|(
name|boolean
name|expansion
parameter_list|)
block|{
return|return
name|withValidatorConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withColumnReferenceExpansion
argument_list|(
name|expansion
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|rewritesTo
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|toSql
argument_list|(
literal|false
argument_list|)
argument_list|,
parameter_list|(
name|sap
parameter_list|,
name|validator
parameter_list|,
name|validatedNode
parameter_list|)
lambda|->
block|{
name|String
name|actualRewrite
init|=
name|validatedNode
operator|.
name|toSqlString
argument_list|(
name|AnsiSqlDialect
operator|.
name|DEFAULT
argument_list|,
literal|false
argument_list|)
operator|.
name|getSql
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
name|expected
argument_list|,
name|Util
operator|.
name|toLinux
argument_list|(
name|actualRewrite
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_function
specifier|public
name|SqlValidatorFixture
name|isAggregate
parameter_list|(
name|Matcher
argument_list|<
name|Boolean
argument_list|>
name|matcher
parameter_list|)
block|{
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|toSql
argument_list|(
literal|false
argument_list|)
argument_list|,
parameter_list|(
name|sap
parameter_list|,
name|validator
parameter_list|,
name|validatedNode
parameter_list|)
lambda|->
name|assertThat
argument_list|(
name|validator
operator|.
name|isAggregate
argument_list|(
operator|(
name|SqlSelect
operator|)
name|validatedNode
argument_list|)
argument_list|,
name|matcher
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * Tests that the list of the origins of each result field of    * the current query match expected.    *    *<p>The field origin list looks like this:    *<code>"{(CATALOG.SALES.EMP.EMPNO, null)}"</code>.    */
end_comment

begin_function
specifier|public
name|SqlValidatorFixture
name|assertFieldOrigin
parameter_list|(
name|Matcher
argument_list|<
name|String
argument_list|>
name|matcher
parameter_list|)
block|{
name|tester
operator|.
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|toSql
argument_list|(
literal|false
argument_list|)
argument_list|,
parameter_list|(
name|sap
parameter_list|,
name|validator
parameter_list|,
name|n
parameter_list|)
lambda|->
block|{
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|list
init|=
name|validator
operator|.
name|getFieldOrigins
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"{"
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|strings
range|:
name|list
control|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strings
operator|==
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|strings
control|)
block|{
if|if
condition|(
name|j
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_function
specifier|public
name|void
name|setFor
parameter_list|(
name|SqlOperator
name|operator
parameter_list|)
block|{
block|}
end_function

unit|}
end_unit

