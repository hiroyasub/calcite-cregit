begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUnresolvedFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|StringAndPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|RelFieldTrimmer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlToRelConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|DiffRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|relIsValid
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|core
operator|.
name|Is
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Abstract implementation of {@link SqlTester}  * that talks to a mock catalog.  *  *<p>This is to implement the default behavior: testing is only against the  * {@link SqlValidator}.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|AbstractSqlTester
implements|implements
name|SqlTester
implements|,
name|AutoCloseable
block|{
specifier|private
specifier|static
specifier|final
name|String
name|NL
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
specifier|public
name|AbstractSqlTester
parameter_list|()
block|{
block|}
comment|/**    * {@inheritDoc}    *    *<p>This default implementation does nothing.    */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
comment|// no resources to release
block|}
annotation|@
name|Override
specifier|public
name|void
name|assertExceptionIsThrown
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
annotation|@
name|Nullable
name|String
name|expectedMsgPattern
parameter_list|)
block|{
specifier|final
name|SqlNode
name|sqlNode
decl_stmt|;
try|try
block|{
name|sqlNode
operator|=
name|parseQuery
argument_list|(
name|factory
argument_list|,
name|sap
operator|.
name|sql
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|SqlTests
operator|.
name|checkEx
argument_list|(
name|e
argument_list|,
name|expectedMsgPattern
argument_list|,
name|sap
argument_list|,
name|SqlTests
operator|.
name|Stage
operator|.
name|PARSE
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|SqlValidator
name|validator
init|=
name|factory
operator|.
name|createValidator
argument_list|()
decl_stmt|;
name|Throwable
name|thrown
init|=
literal|null
decl_stmt|;
try|try
block|{
name|validator
operator|.
name|validate
argument_list|(
name|sqlNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|thrown
operator|=
name|ex
expr_stmt|;
block|}
name|SqlTests
operator|.
name|checkEx
argument_list|(
name|thrown
argument_list|,
name|expectedMsgPattern
argument_list|,
name|sap
argument_list|,
name|SqlTests
operator|.
name|Stage
operator|.
name|VALIDATE
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|checkParseEx
parameter_list|(
name|Throwable
name|e
parameter_list|,
annotation|@
name|Nullable
name|String
name|expectedMsgPattern
parameter_list|,
name|StringAndPos
name|sap
parameter_list|)
block|{
try|try
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|spe
parameter_list|)
block|{
name|String
name|errMessage
init|=
name|spe
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedMsgPattern
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error while parsing query:"
operator|+
name|sap
argument_list|,
name|spe
argument_list|)
throw|;
block|}
if|else if
condition|(
name|errMessage
operator|==
literal|null
operator|||
operator|!
name|Util
operator|.
name|toLinux
argument_list|(
name|errMessage
argument_list|)
operator|.
name|matches
argument_list|(
name|expectedMsgPattern
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error did not match expected ["
operator|+
name|expectedMsgPattern
operator|+
literal|"] while parsing query ["
operator|+
name|sap
operator|+
literal|"]"
argument_list|,
name|spe
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error while parsing query: "
operator|+
name|sap
argument_list|,
name|t
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|RelDataType
name|getColumnType
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
return|return
name|validateAndApply
argument_list|(
name|factory
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
name|sql
argument_list|)
argument_list|,
parameter_list|(
name|sql1
parameter_list|,
name|validator
parameter_list|,
name|n
parameter_list|)
lambda|->
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
literal|"expected query to return 1 field"
argument_list|,
name|fields
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelDataType
name|getResultType
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
return|return
name|validateAndApply
argument_list|(
name|factory
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
name|sql
argument_list|)
argument_list|,
parameter_list|(
name|sql1
parameter_list|,
name|validator
parameter_list|,
name|n
parameter_list|)
lambda|->
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
block|}
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|SqlNode
argument_list|>
name|parseAndValidate
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|SqlNode
name|sqlNode
decl_stmt|;
try|try
block|{
name|sqlNode
operator|=
name|parseQuery
argument_list|(
name|factory
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error while parsing query: "
operator|+
name|sql
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|SqlValidator
name|validator
init|=
name|factory
operator|.
name|createValidator
argument_list|()
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|validator
argument_list|,
name|validator
operator|.
name|validate
argument_list|(
name|sqlNode
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|parseQuery
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|)
throws|throws
name|SqlParseException
block|{
name|SqlParser
name|parser
init|=
name|factory
operator|.
name|createParser
argument_list|(
name|sql
argument_list|)
decl_stmt|;
return|return
name|parser
operator|.
name|parseQuery
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|parseExpression
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|)
throws|throws
name|SqlParseException
block|{
name|SqlParser
name|parser
init|=
name|factory
operator|.
name|createParser
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|parser
operator|.
name|parseExpression
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkColumnType
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|validateAndThen
argument_list|(
name|factory
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
name|sql
argument_list|)
argument_list|,
name|checkColumnTypeAction
argument_list|(
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|ValidatedNodeConsumer
name|checkColumnTypeAction
parameter_list|(
name|Matcher
argument_list|<
name|String
argument_list|>
name|matcher
parameter_list|)
block|{
return|return
parameter_list|(
name|sql1
parameter_list|,
name|validator
parameter_list|,
name|validatedNode
parameter_list|)
lambda|->
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|validatedNode
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fields
operator|.
name|size
argument_list|()
argument_list|,
literal|"expected query to return 1 field"
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|actualType
init|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|String
name|actual
init|=
name|SqlTests
operator|.
name|getTypeString
argument_list|(
name|actualType
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|actual
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
return|;
block|}
comment|// SqlTester methods
annotation|@
name|Override
specifier|public
name|void
name|setFor
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|VmName
modifier|...
name|unimplementedVmNames
parameter_list|)
block|{
comment|// do nothing
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkAgg
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|,
name|String
index|[]
name|inputValues
parameter_list|,
name|ResultChecker
name|resultChecker
parameter_list|)
block|{
name|String
name|query
init|=
name|SqlTests
operator|.
name|generateAggQuery
argument_list|(
name|expr
argument_list|,
name|inputValues
argument_list|)
decl_stmt|;
name|check
argument_list|(
name|factory
argument_list|,
name|query
argument_list|,
name|SqlTests
operator|.
name|ANY_TYPE_CHECKER
argument_list|,
name|resultChecker
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkWinAgg
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|,
name|String
index|[]
name|inputValues
parameter_list|,
name|String
name|windowSpec
parameter_list|,
name|String
name|type
parameter_list|,
name|ResultChecker
name|resultChecker
parameter_list|)
block|{
name|String
name|query
init|=
name|SqlTests
operator|.
name|generateWinAggQuery
argument_list|(
name|expr
argument_list|,
name|windowSpec
argument_list|,
name|inputValues
argument_list|)
decl_stmt|;
name|check
argument_list|(
name|factory
argument_list|,
name|query
argument_list|,
name|SqlTests
operator|.
name|ANY_TYPE_CHECKER
argument_list|,
name|resultChecker
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|check
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|query
parameter_list|,
name|TypeChecker
name|typeChecker
parameter_list|,
name|ParameterChecker
name|parameterChecker
parameter_list|,
name|ResultChecker
name|resultChecker
parameter_list|)
block|{
comment|// This implementation does NOT check the result!
comment|// All it does is check the return type.
name|requireNonNull
argument_list|(
name|typeChecker
argument_list|,
literal|"typeChecker"
argument_list|)
expr_stmt|;
name|requireNonNull
argument_list|(
name|parameterChecker
argument_list|,
literal|"parameterChecker"
argument_list|)
expr_stmt|;
name|requireNonNull
argument_list|(
name|resultChecker
argument_list|,
literal|"resultChecker"
argument_list|)
expr_stmt|;
comment|// Parse and validate. There should be no errors.
comment|// There must be 1 column. Get its type.
name|RelDataType
name|actualType
init|=
name|getColumnType
argument_list|(
name|factory
argument_list|,
name|query
argument_list|)
decl_stmt|;
comment|// Check result type.
name|typeChecker
operator|.
name|checkType
argument_list|(
name|actualType
argument_list|)
expr_stmt|;
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|SqlNode
argument_list|>
name|p
init|=
name|parseAndValidate
argument_list|(
name|factory
argument_list|,
name|query
argument_list|)
decl_stmt|;
name|SqlValidator
name|validator
init|=
name|requireNonNull
argument_list|(
name|p
operator|.
name|left
argument_list|)
decl_stmt|;
name|SqlNode
name|n
init|=
name|requireNonNull
argument_list|(
name|p
operator|.
name|right
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|parameterRowType
init|=
name|validator
operator|.
name|getParameterRowType
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|parameterChecker
operator|.
name|checkParameters
argument_list|(
name|parameterRowType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|validateAndThen
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|ValidatedNodeConsumer
name|consumer
parameter_list|)
block|{
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|SqlNode
argument_list|>
name|p
init|=
name|parseAndValidate
argument_list|(
name|factory
argument_list|,
name|sap
operator|.
name|sql
argument_list|)
decl_stmt|;
name|SqlValidator
name|validator
init|=
name|requireNonNull
argument_list|(
name|p
operator|.
name|left
argument_list|)
decl_stmt|;
name|SqlNode
name|rewrittenNode
init|=
name|requireNonNull
argument_list|(
name|p
operator|.
name|right
argument_list|)
decl_stmt|;
name|consumer
operator|.
name|accept
argument_list|(
name|sap
argument_list|,
name|validator
argument_list|,
name|rewrittenNode
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|R
parameter_list|>
name|R
name|validateAndApply
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|ValidatedNodeFunction
argument_list|<
name|R
argument_list|>
name|function
parameter_list|)
block|{
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|SqlNode
argument_list|>
name|p
init|=
name|parseAndValidate
argument_list|(
name|factory
argument_list|,
name|sap
operator|.
name|sql
argument_list|)
decl_stmt|;
name|SqlValidator
name|validator
init|=
name|requireNonNull
argument_list|(
name|p
operator|.
name|left
argument_list|)
decl_stmt|;
name|SqlNode
name|rewrittenNode
init|=
name|requireNonNull
argument_list|(
name|p
operator|.
name|right
argument_list|)
decl_stmt|;
return|return
name|function
operator|.
name|apply
argument_list|(
name|sap
argument_list|,
name|validator
argument_list|,
name|rewrittenNode
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkFails
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|String
name|expectedError
parameter_list|,
name|boolean
name|runtime
parameter_list|)
block|{
if|if
condition|(
name|runtime
condition|)
block|{
comment|// We need to test that the expression fails at runtime.
comment|// Ironically, that means that it must succeed at prepare time.
specifier|final
name|String
name|sql
init|=
name|buildQuery
argument_list|(
name|sap
operator|.
name|addCarets
argument_list|()
argument_list|)
decl_stmt|;
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|SqlNode
argument_list|>
name|p
init|=
name|parseAndValidate
argument_list|(
name|factory
argument_list|,
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|n
init|=
name|p
operator|.
name|right
decl_stmt|;
name|assertNotNull
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StringAndPos
name|sap1
init|=
name|StringAndPos
operator|.
name|of
argument_list|(
name|buildQuery
argument_list|(
name|sap
operator|.
name|addCarets
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|checkQueryFails
argument_list|(
name|factory
argument_list|,
name|sap1
argument_list|,
name|expectedError
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkQueryFails
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|String
name|expectedError
parameter_list|)
block|{
name|assertExceptionIsThrown
argument_list|(
name|factory
argument_list|,
name|sap
argument_list|,
name|expectedError
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkAggFails
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|,
name|String
index|[]
name|inputValues
parameter_list|,
name|String
name|expectedError
parameter_list|,
name|boolean
name|runtime
parameter_list|)
block|{
specifier|final
name|String
name|sql
init|=
name|SqlTests
operator|.
name|generateAggQuery
argument_list|(
name|expr
argument_list|,
name|inputValues
argument_list|)
decl_stmt|;
if|if
condition|(
name|runtime
condition|)
block|{
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|SqlNode
argument_list|>
name|p
init|=
name|parseAndValidate
argument_list|(
name|factory
argument_list|,
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|n
init|=
name|p
operator|.
name|right
decl_stmt|;
name|assertNotNull
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkQueryFails
argument_list|(
name|factory
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
name|sql
argument_list|)
argument_list|,
name|expectedError
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|String
name|buildQuery
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
return|return
literal|"values ("
operator|+
name|expression
operator|+
literal|")"
return|;
block|}
specifier|public
specifier|static
name|String
name|buildQueryAgg
parameter_list|(
name|String
name|expression
parameter_list|)
block|{
return|return
literal|"select "
operator|+
name|expression
operator|+
literal|" from (values (1)) as t(x) group by x"
return|;
block|}
comment|/**    * Builds a query that extracts all literals as columns in an underlying    * select.    *    *<p>For example,</p>    *    *<blockquote>{@code 1< 5}</blockquote>    *    *<p>becomes</p>    *    *<blockquote>{@code SELECT p0< p1    * FROM (VALUES (1, 5)) AS t(p0, p1)}</blockquote>    *    *<p>Null literals don't have enough type information to be extracted.    * We push down {@code CAST(NULL AS type)} but raw nulls such as    * {@code CASE 1 WHEN 2 THEN 'a' ELSE NULL END} are left as is.</p>    *    * @param factory Test factory    * @param expression Scalar expression    * @return Query that evaluates a scalar expression    */
specifier|protected
name|String
name|buildQuery2
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expression
parameter_list|)
block|{
if|if
condition|(
name|expression
operator|.
name|matches
argument_list|(
literal|"(?i).*(percentile_(cont|disc)|convert)\\(.*"
argument_list|)
condition|)
block|{
comment|// PERCENTILE_CONT requires its argument to be a literal,
comment|// so converting its argument to a column will cause false errors.
comment|// Similarly, MSSQL-style CONVERT.
return|return
name|buildQuery
argument_list|(
name|expression
argument_list|)
return|;
block|}
comment|// "values (1< 5)"
comment|// becomes
comment|// "select p0< p1 from (values (1, 5)) as t(p0, p1)"
name|SqlNode
name|x
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"values ("
operator|+
name|expression
operator|+
literal|")"
decl_stmt|;
try|try
block|{
name|x
operator|=
name|parseQuery
argument_list|(
name|factory
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
specifier|final
name|Collection
argument_list|<
name|SqlNode
argument_list|>
name|literalSet
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|x
operator|.
name|accept
argument_list|(
operator|new
name|SqlShuttle
argument_list|()
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|ops
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LITERAL_CHAIN
argument_list|,
name|SqlStdOperatorTable
operator|.
name|LOCALTIME
argument_list|,
name|SqlStdOperatorTable
operator|.
name|LOCALTIMESTAMP
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CURRENT_TIME
argument_list|,
name|SqlStdOperatorTable
operator|.
name|CURRENT_TIMESTAMP
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isNull
argument_list|(
name|literal
argument_list|)
operator|&&
name|literal
operator|.
name|getTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|SYMBOL
condition|)
block|{
name|literalSet
operator|.
name|add
argument_list|(
name|literal
argument_list|)
expr_stmt|;
block|}
return|return
name|literal
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|operator
operator|instanceof
name|SqlUnresolvedFunction
condition|)
block|{
specifier|final
name|SqlUnresolvedFunction
name|unresolvedFunction
init|=
operator|(
name|SqlUnresolvedFunction
operator|)
name|operator
decl_stmt|;
specifier|final
name|SqlOperator
name|lookup
init|=
name|SqlValidatorUtil
operator|.
name|lookupSqlFunctionByID
argument_list|(
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
argument_list|,
name|unresolvedFunction
operator|.
name|getSqlIdentifier
argument_list|()
argument_list|,
name|unresolvedFunction
operator|.
name|getFunctionType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lookup
operator|!=
literal|null
condition|)
block|{
name|operator
operator|=
name|lookup
expr_stmt|;
name|call
operator|=
name|operator
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getFunctionQuantifier
argument_list|()
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operator
operator|==
name|SqlStdOperatorTable
operator|.
name|CAST
operator|&&
name|isNull
argument_list|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|literalSet
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
name|call
return|;
block|}
if|else if
condition|(
name|ops
operator|.
name|contains
argument_list|(
name|operator
argument_list|)
condition|)
block|{
comment|// "Argument to function 'LOCALTIME' must be a
comment|// literal"
return|return
name|call
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|visit
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
specifier|private
name|boolean
name|isNull
parameter_list|(
name|SqlNode
name|sqlNode
parameter_list|)
block|{
return|return
name|sqlNode
operator|instanceof
name|SqlLiteral
operator|&&
operator|(
operator|(
name|SqlLiteral
operator|)
name|sqlNode
operator|)
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
return|;
block|}
block|}
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|literalSet
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|sort
argument_list|(
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
specifier|final
name|SqlParserPos
name|pos0
init|=
name|o1
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
specifier|final
name|SqlParserPos
name|pos1
init|=
name|o2
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
name|int
name|c
init|=
operator|-
name|Utilities
operator|.
name|compare
argument_list|(
name|pos0
operator|.
name|getLineNum
argument_list|()
argument_list|,
name|pos1
operator|.
name|getLineNum
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
name|c
return|;
block|}
return|return
operator|-
name|Utilities
operator|.
name|compare
argument_list|(
name|pos0
operator|.
name|getColumnNum
argument_list|()
argument_list|,
name|pos1
operator|.
name|getColumnNum
argument_list|()
argument_list|)
return|;
block|}
argument_list|)
expr_stmt|;
name|String
name|sql2
init|=
name|sql
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SqlNode
name|literal
range|:
name|nodes
control|)
block|{
specifier|final
name|SqlParserPos
name|pos
init|=
name|literal
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
specifier|final
name|int
name|start
init|=
name|SqlParserUtil
operator|.
name|lineColToIndex
argument_list|(
name|sql
argument_list|,
name|pos
operator|.
name|getLineNum
argument_list|()
argument_list|,
name|pos
operator|.
name|getColumnNum
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|SqlParserUtil
operator|.
name|lineColToIndex
argument_list|(
name|sql
argument_list|,
name|pos
operator|.
name|getEndLineNum
argument_list|()
argument_list|,
name|pos
operator|.
name|getEndColumnNum
argument_list|()
argument_list|)
operator|+
literal|1
decl_stmt|;
name|String
name|param
init|=
literal|"p"
operator|+
name|p
operator|++
decl_stmt|;
name|values
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|sql2
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|,
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|sql2
operator|=
name|sql2
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|start
argument_list|)
operator|+
name|param
operator|+
name|sql2
operator|.
name|substring
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|values
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
literal|"1"
argument_list|,
literal|"p0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|"select "
operator|+
name|sql2
operator|.
name|substring
argument_list|(
literal|"values ("
operator|.
name|length
argument_list|()
argument_list|,
name|sql2
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|+
literal|" from (values ("
operator|+
name|Util
operator|.
name|commaList
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|values
argument_list|)
argument_list|)
operator|+
literal|")) as t("
operator|+
name|Util
operator|.
name|commaList
argument_list|(
name|Pair
operator|.
name|right
argument_list|(
name|values
argument_list|)
argument_list|)
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|forEachQuery
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expression
parameter_list|,
name|Consumer
argument_list|<
name|String
argument_list|>
name|consumer
parameter_list|)
block|{
comment|// Why not return a list? If there is a syntax error in the expression, the
comment|// consumer will discover it before we try to parse it to do substitutions
comment|// on the parse tree.
name|consumer
operator|.
name|accept
argument_list|(
literal|"values ("
operator|+
name|expression
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|consumer
operator|.
name|accept
argument_list|(
name|buildQuery2
argument_list|(
name|factory
argument_list|,
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|assertConvertsTo
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|DiffRepository
name|diffRepos
parameter_list|,
name|String
name|sql
parameter_list|,
name|String
name|plan
parameter_list|,
name|boolean
name|trim
parameter_list|,
name|boolean
name|expression
parameter_list|,
name|boolean
name|decorrelate
parameter_list|)
block|{
if|if
condition|(
name|expression
condition|)
block|{
name|assertExprConvertsTo
argument_list|(
name|factory
argument_list|,
name|diffRepos
argument_list|,
name|sql
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertSqlConvertsTo
argument_list|(
name|factory
argument_list|,
name|diffRepos
argument_list|,
name|sql
argument_list|,
name|plan
argument_list|,
name|trim
argument_list|,
name|decorrelate
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|assertExprConvertsTo
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|DiffRepository
name|diffRepos
parameter_list|,
name|String
name|expr
parameter_list|,
name|String
name|plan
parameter_list|)
block|{
name|String
name|expr2
init|=
name|diffRepos
operator|.
name|expand
argument_list|(
literal|"sql"
argument_list|,
name|expr
argument_list|)
decl_stmt|;
name|RexNode
name|rex
init|=
name|convertExprToRex
argument_list|(
name|factory
argument_list|,
name|expr2
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|rex
argument_list|)
expr_stmt|;
comment|// NOTE jvs 28-Mar-2006:  insert leading newline so
comment|// that plans come out nicely stacked instead of first
comment|// line immediately after CDATA start
name|String
name|actual
init|=
name|NL
operator|+
name|rex
operator|+
name|NL
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"plan"
argument_list|,
name|plan
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assertSqlConvertsTo
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|DiffRepository
name|diffRepos
parameter_list|,
name|String
name|sql
parameter_list|,
name|String
name|plan
parameter_list|,
name|boolean
name|trim
parameter_list|,
name|boolean
name|decorrelate
parameter_list|)
block|{
name|String
name|sql2
init|=
name|diffRepos
operator|.
name|expand
argument_list|(
literal|"sql"
argument_list|,
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|RelRoot
argument_list|>
name|pair
init|=
name|convertSqlToRel2
argument_list|(
name|factory
argument_list|,
name|sql2
argument_list|,
name|decorrelate
argument_list|,
name|trim
argument_list|)
decl_stmt|;
specifier|final
name|RelRoot
name|root
init|=
name|requireNonNull
argument_list|(
name|pair
operator|.
name|right
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidator
name|validator
init|=
name|requireNonNull
argument_list|(
name|pair
operator|.
name|left
argument_list|)
decl_stmt|;
name|RelNode
name|rel
init|=
name|root
operator|.
name|project
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rel
argument_list|,
name|relIsValid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|trim
condition|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|RelFieldTrimmer
name|trimmer
init|=
name|createFieldTrimmer
argument_list|(
name|validator
argument_list|,
name|relBuilder
argument_list|)
decl_stmt|;
name|rel
operator|=
name|trimmer
operator|.
name|trim
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rel
argument_list|,
name|relIsValid
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// NOTE jvs 28-Mar-2006:  insert leading newline so
comment|// that plans come out nicely stacked instead of first
comment|// line immediately after CDATA start
name|String
name|actual
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"plan"
argument_list|,
name|plan
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RexNode
name|convertExprToRex
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|)
block|{
name|requireNonNull
argument_list|(
name|expr
argument_list|,
literal|"expr"
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|sqlQuery
decl_stmt|;
try|try
block|{
name|sqlQuery
operator|=
name|parseExpression
argument_list|(
name|factory
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
decl||
name|Error
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
specifier|final
name|SqlToRelConverter
name|converter
init|=
name|factory
operator|.
name|createSqlToRelConverter
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidator
name|validator
init|=
name|requireNonNull
argument_list|(
name|converter
operator|.
name|validator
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|validatedQuery
init|=
name|validator
operator|.
name|validate
argument_list|(
name|sqlQuery
argument_list|)
decl_stmt|;
return|return
name|converter
operator|.
name|convertExpression
argument_list|(
name|validatedQuery
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|RelRoot
argument_list|>
name|convertSqlToRel2
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|decorrelate
parameter_list|,
name|boolean
name|trim
parameter_list|)
block|{
name|requireNonNull
argument_list|(
name|sql
argument_list|,
literal|"sql"
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|sqlQuery
decl_stmt|;
try|try
block|{
name|sqlQuery
operator|=
name|parseQuery
argument_list|(
name|factory
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
decl||
name|Error
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
specifier|final
name|SqlToRelConverter
name|converter
init|=
name|factory
operator|.
name|createSqlToRelConverter
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidator
name|validator
init|=
name|requireNonNull
argument_list|(
name|converter
operator|.
name|validator
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|validatedQuery
init|=
name|validator
operator|.
name|validate
argument_list|(
name|sqlQuery
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|converter
operator|.
name|convertQuery
argument_list|(
name|validatedQuery
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|requireNonNull
argument_list|(
name|root
argument_list|,
literal|"root"
argument_list|)
expr_stmt|;
if|if
condition|(
name|decorrelate
operator|||
name|trim
condition|)
block|{
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|flattenTypes
argument_list|(
name|root
operator|.
name|rel
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decorrelate
condition|)
block|{
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|decorrelate
argument_list|(
name|sqlQuery
argument_list|,
name|root
operator|.
name|rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trim
condition|)
block|{
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|trimUnusedFields
argument_list|(
literal|true
argument_list|,
name|root
operator|.
name|rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|validator
argument_list|,
name|root
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|trimRelNode
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|RelNode
name|relNode
parameter_list|)
block|{
specifier|final
name|SqlToRelConverter
name|converter
init|=
name|factory
operator|.
name|createSqlToRelConverter
argument_list|()
decl_stmt|;
name|RelNode
name|r2
init|=
name|converter
operator|.
name|flattenTypes
argument_list|(
name|relNode
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|converter
operator|.
name|trimUnusedFields
argument_list|(
literal|true
argument_list|,
name|r2
argument_list|)
return|;
block|}
comment|/**    * Creates a RelFieldTrimmer.    *    * @param validator Validator    * @param relBuilder Builder    * @return Field trimmer    */
specifier|public
name|RelFieldTrimmer
name|createFieldTrimmer
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|)
block|{
return|return
operator|new
name|RelFieldTrimmer
argument_list|(
name|validator
argument_list|,
name|relBuilder
argument_list|)
return|;
block|}
block|}
end_class

end_unit

