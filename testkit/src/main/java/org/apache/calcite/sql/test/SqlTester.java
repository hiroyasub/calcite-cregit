begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|StringAndPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|DiffRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Callback for testing SQL queries and expressions.  *  *<p>The idea is that when you define an operator (or another piece of SQL  * functionality), you can define the logical behavior of that operator once, as  * part of that operator. Later you can define one or more physical  * implementations of that operator, and test them all using the same set of  * tests.  *  *<p>Specific implementations of<code>SqlTester</code> might evaluate the  * queries in different ways, for example, using a C++ versus Java calculator.  * An implementation might even ignore certain calls altogether.  */
end_comment

begin_interface
specifier|public
interface|interface
name|SqlTester
extends|extends
name|AutoCloseable
block|{
comment|//~ Enums ------------------------------------------------------------------
comment|/**    * Name of a virtual machine that can potentially implement an operator.    */
enum|enum
name|VmName
block|{
name|FENNEL
block|,
name|JAVA
block|,
name|EXPAND
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/** Given a scalar expression, generates a sequence of SQL queries that    * evaluate it, and calls a given action with each.    *    * @param factory    Factory    * @param expression Scalar expression    * @param consumer   Action to be called for each query    */
name|void
name|forEachQuery
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expression
parameter_list|,
name|Consumer
argument_list|<
name|String
argument_list|>
name|consumer
parameter_list|)
function_decl|;
comment|/** Parses a query. */
name|SqlNode
name|parseQuery
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|)
throws|throws
name|SqlParseException
function_decl|;
comment|/** Parses an expression. */
name|SqlNode
name|parseExpression
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|)
throws|throws
name|SqlParseException
function_decl|;
comment|/** Parses and validates a query, then calls an action on the result. */
name|void
name|validateAndThen
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|ValidatedNodeConsumer
name|consumer
parameter_list|)
function_decl|;
comment|/** Parses and validates a query, then calls a function on the result. */
parameter_list|<
name|R
parameter_list|>
name|R
name|validateAndApply
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|ValidatedNodeFunction
argument_list|<
name|R
argument_list|>
name|function
parameter_list|)
function_decl|;
comment|/**    * Checks that a query is valid, or, if invalid, throws the right    * message at the right location.    *    *<p>If<code>expectedMsgPattern</code> is null, the query must    * succeed.    *    *<p>If<code>expectedMsgPattern</code> is not null, the query must    * fail, and give an error location of (expectedLine, expectedColumn)    * through (expectedEndLine, expectedEndColumn).    *    * @param factory            Factory    * @param sap                SQL statement    * @param expectedMsgPattern If this parameter is null the query must be    */
name|void
name|assertExceptionIsThrown
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
annotation|@
name|Nullable
name|String
name|expectedMsgPattern
parameter_list|)
function_decl|;
comment|/**    * Returns the data type of the sole column of a SQL query.    *    *<p>For example,<code>getResultType("VALUES (1")</code> returns    *<code>INTEGER</code>.    *    *<p>Fails if query returns more than one column.    *    * @see #getResultType(SqlTestFactory, String)    */
name|RelDataType
name|getColumnType
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|)
function_decl|;
comment|/**    * Returns the data type of the row returned by a SQL query.    *    *<p>For example,<code>getResultType("VALUES (1, 'foo')")</code>    * returns<code>RecordType(INTEGER EXPR$0, CHAR(3) EXPR#1)</code>.    */
name|RelDataType
name|getResultType
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|)
function_decl|;
comment|/**    * Checks that a query returns one column of an expected type. For example,    *<code>checkType("VALUES (1 + 2)", "INTEGER NOT NULL")</code>.    *    * @param factory    Factory    * @param sql        Query expression    * @param type       Type string    */
name|void
name|checkColumnType
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|,
name|String
name|type
parameter_list|)
function_decl|;
comment|/**    * Tests that a SQL query returns a single column with the given type. For    * example,    *    *<blockquote>    *<pre>check("VALUES (1 + 2)", "3", SqlTypeName.Integer);</pre>    *</blockquote>    *    *<p>If<code>result</code> is null, the expression must yield the SQL NULL    * value. If<code>result</code> is a {@link java.util.regex.Pattern}, the    * result must match that pattern.    *    * @param factory       Factory    * @param query         SQL query    * @param typeChecker   Checks whether the result is the expected type    * @param resultChecker Checks whether the result has the expected value    */
specifier|default
name|void
name|check
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|query
parameter_list|,
name|TypeChecker
name|typeChecker
parameter_list|,
name|ResultChecker
name|resultChecker
parameter_list|)
block|{
name|check
argument_list|(
name|factory
argument_list|,
name|query
argument_list|,
name|typeChecker
argument_list|,
name|SqlTests
operator|.
name|ANY_PARAMETER_CHECKER
argument_list|,
name|resultChecker
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that a SQL query returns a result of expected type and value.    * Checking of type and value are abstracted using {@link TypeChecker}    * and {@link ResultChecker} functors.    *    * @param factory       Factory    * @param query         SQL query    * @param typeChecker   Checks whether the result is the expected type    * @param parameterChecker Checks whether the parameters are of expected    *                      types    * @param resultChecker Checks whether the result has the expected value    */
name|void
name|check
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|query
parameter_list|,
name|TypeChecker
name|typeChecker
parameter_list|,
name|ParameterChecker
name|parameterChecker
parameter_list|,
name|ResultChecker
name|resultChecker
parameter_list|)
function_decl|;
comment|/**    * Declares that this test is for a given operator. So we can check that all    * operators are tested.    *    * @param operator             Operator    * @param unimplementedVmNames Names of virtual machines for which this    */
name|void
name|setFor
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|VmName
modifier|...
name|unimplementedVmNames
parameter_list|)
function_decl|;
comment|/**    * Checks that an aggregate expression returns the expected result.    *    *<p>For example,<code>checkAgg("AVG(DISTINCT x)", new String[] {"2", "3",    * null, "3" }, new Double(2.5), 0);</code>    *    * @param factory     Factory    * @param expr        Aggregate expression, e.g. {@code SUM(DISTINCT x)}    * @param inputValues Array of input values, e.g. {@code ["1", null, "2"]}    * @param resultChecker Checks whether the result has the expected value    */
name|void
name|checkAgg
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|,
name|String
index|[]
name|inputValues
parameter_list|,
name|ResultChecker
name|resultChecker
parameter_list|)
function_decl|;
comment|/**    * Checks that a windowed aggregate expression returns the expected result.    *    *<p>For example,<code>checkWinAgg("FIRST_VALUE(x)", new String[] {"2",    * "3", null, "3" }, "INTEGER NOT NULL", 2, 0d);</code>    *    * @param factory     Factory    * @param expr        Aggregate expression, e.g. {@code SUM(DISTINCT x)}    * @param inputValues Array of input values, e.g. {@code ["1", null, "2"]}    * @param type        Expected result type    * @param resultChecker Checks whether the result has the expected value    */
name|void
name|checkWinAgg
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|,
name|String
index|[]
name|inputValues
parameter_list|,
name|String
name|windowSpec
parameter_list|,
name|String
name|type
parameter_list|,
name|ResultChecker
name|resultChecker
parameter_list|)
function_decl|;
comment|/**    * Tests that an aggregate expression fails at run time.    *    * @param factory       Factory    * @param expr          An aggregate expression    * @param inputValues   Array of input values    * @param expectedError Pattern for expected error    * @param runtime       If true, must fail at runtime; if false, must fail at    *                      validate time    */
name|void
name|checkAggFails
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expr
parameter_list|,
name|String
index|[]
name|inputValues
parameter_list|,
name|String
name|expectedError
parameter_list|,
name|boolean
name|runtime
parameter_list|)
function_decl|;
comment|/**    * Tests that a scalar SQL expression fails at run time.    *    * @param factory       Factory    * @param expression    SQL scalar expression    * @param expectedError Pattern for expected error. If !runtime, must    *                      include an error location.    * @param runtime       If true, must fail at runtime; if false, must fail at    *                      validate time    */
name|void
name|checkFails
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|expression
parameter_list|,
name|String
name|expectedError
parameter_list|,
name|boolean
name|runtime
parameter_list|)
function_decl|;
comment|/** As {@link #checkFails(SqlTestFactory, StringAndPos, String, boolean)},    * but with a string that contains carets. */
specifier|default
name|void
name|checkFails
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|expression
parameter_list|,
name|String
name|expectedError
parameter_list|,
name|boolean
name|runtime
parameter_list|)
block|{
name|checkFails
argument_list|(
name|factory
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
name|expression
argument_list|)
argument_list|,
name|expectedError
argument_list|,
name|runtime
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that a SQL query fails at prepare time.    *    * @param factory       Factory    * @param sap           SQL query and error position    * @param expectedError Pattern for expected error. Must    *                      include an error location.    */
name|void
name|checkQueryFails
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|String
name|expectedError
parameter_list|)
function_decl|;
comment|/**    * Converts a SQL string to a {@link RelNode} tree.    *    * @param factory Factory    * @param sql SQL statement    * @param decorrelate Whether to decorrelate    * @param trim Whether to trim    * @return Relational expression, never null    */
specifier|default
name|RelRoot
name|convertSqlToRel
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|decorrelate
parameter_list|,
name|boolean
name|trim
parameter_list|)
block|{
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|RelRoot
argument_list|>
name|pair
init|=
name|convertSqlToRel2
argument_list|(
name|factory
argument_list|,
name|sql
argument_list|,
name|decorrelate
argument_list|,
name|trim
argument_list|)
decl_stmt|;
return|return
name|requireNonNull
argument_list|(
name|pair
operator|.
name|right
argument_list|)
return|;
block|}
comment|/** Converts a SQL string to a (SqlValidator, RelNode) pair. */
name|Pair
argument_list|<
name|SqlValidator
argument_list|,
name|RelRoot
argument_list|>
name|convertSqlToRel2
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|decorrelate
parameter_list|,
name|boolean
name|trim
parameter_list|)
function_decl|;
comment|/**    * Checks that a SQL statement converts to a given plan, optionally    * trimming columns that are not needed.    *    * @param factory Factory    * @param diffRepos Diff repository    * @param sql  SQL query or expression    * @param plan Expected plan    * @param trim Whether to trim columns that are not needed    * @param expression True if {@code sql} is an expression, false if it is a query    */
name|void
name|assertConvertsTo
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|DiffRepository
name|diffRepos
parameter_list|,
name|String
name|sql
parameter_list|,
name|String
name|plan
parameter_list|,
name|boolean
name|trim
parameter_list|,
name|boolean
name|expression
parameter_list|,
name|boolean
name|decorrelate
parameter_list|)
function_decl|;
comment|/** Trims a RelNode. */
name|RelNode
name|trimRelNode
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|,
name|RelNode
name|relNode
parameter_list|)
function_decl|;
comment|//~ Inner Interfaces -------------------------------------------------------
comment|/** Type checker. */
interface|interface
name|TypeChecker
block|{
name|void
name|checkType
parameter_list|(
name|RelDataType
name|type
parameter_list|)
function_decl|;
block|}
comment|/** Parameter checker. */
interface|interface
name|ParameterChecker
block|{
name|void
name|checkParameters
parameter_list|(
name|RelDataType
name|parameterRowType
parameter_list|)
function_decl|;
block|}
comment|/** Result checker. */
interface|interface
name|ResultChecker
block|{
name|void
name|checkResult
parameter_list|(
name|ResultSet
name|result
parameter_list|)
throws|throws
name|Exception
function_decl|;
block|}
comment|/** Action that is called after validation.    *    * @see #validateAndThen    */
interface|interface
name|ValidatedNodeConsumer
block|{
name|void
name|accept
parameter_list|(
name|StringAndPos
name|sap
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|SqlNode
name|validatedNode
parameter_list|)
function_decl|;
block|}
comment|/** A function to apply to the result of validation.    *    * @param<R> Result type of the function    *    * @see AbstractSqlTester#validateAndApply */
interface|interface
name|ValidatedNodeFunction
parameter_list|<
name|R
parameter_list|>
block|{
name|R
name|apply
parameter_list|(
name|StringAndPos
name|sap
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|SqlNode
name|validatedNode
parameter_list|)
function_decl|;
block|}
block|}
end_interface

end_unit

