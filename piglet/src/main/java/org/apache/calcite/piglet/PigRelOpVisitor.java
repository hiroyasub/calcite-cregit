begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|piglet
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCorrelate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindowBound
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|builtin
operator|.
name|CubeDimensions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|builtin
operator|.
name|RollupDimensions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|impl
operator|.
name|logicalLayer
operator|.
name|FrontendException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|impl
operator|.
name|util
operator|.
name|LinkedMultiMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|impl
operator|.
name|util
operator|.
name|MultiMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|OperatorPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|PlanWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|LogicalExpressionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|UserFuncExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOCogroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOCross
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOCube
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LODistinct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOForEach
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOGenerate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOInnerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOLimit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LONative
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LORank
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOSplitOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LogicalPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LogicalRelationalOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LogicalSchema
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Visits Pig logical operators and converts them into corresponding relational  * algebra plans.  */
end_comment

begin_class
class|class
name|PigRelOpVisitor
extends|extends
name|PigRelOpWalker
operator|.
name|PlanPreVisitor
block|{
specifier|private
specifier|static
specifier|final
name|String
name|RANK_PREFIX
init|=
literal|"rank_"
decl_stmt|;
comment|// The relational algebra builder customized for Pig
specifier|protected
specifier|final
name|PigRelBuilder
name|builder
decl_stmt|;
specifier|private
name|Operator
name|currentRoot
decl_stmt|;
comment|/**    * Type of Pig groups    */
specifier|private
enum|enum
name|GroupType
block|{
name|CUBE
block|,
name|ROLLUP
block|,
name|REGULAR
block|}
comment|/**    * Creates a PigRelOpVisitor.    *    * @param plan    Pig logical plan    * @param walker  The walker over Pig logical plan    * @param builder Relational algebra builder    * @throws FrontendException Exception during processing Pig operators    */
name|PigRelOpVisitor
parameter_list|(
name|OperatorPlan
name|plan
parameter_list|,
name|PlanWalker
name|walker
parameter_list|,
name|PigRelBuilder
name|builder
parameter_list|)
throws|throws
name|FrontendException
block|{
name|super
argument_list|(
name|plan
argument_list|,
name|walker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|walker
operator|instanceof
name|PigRelOpWalker
operator|)
condition|)
block|{
throw|throw
operator|new
name|FrontendException
argument_list|(
literal|"Expected PigRelOpWalker"
argument_list|,
literal|2223
argument_list|)
throw|;
block|}
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
name|this
operator|.
name|currentRoot
operator|=
literal|null
expr_stmt|;
block|}
name|Operator
name|getCurrentRoot
parameter_list|()
block|{
return|return
name|currentRoot
return|;
block|}
comment|/**    * Translates the given pig logical plan into a list of relational algebra plans.    *    * @return The list of roots of translated plans, each corresponding to a sink    * operator in the Pig plan    * @throws FrontendException Exception during processing Pig operators    */
name|List
argument_list|<
name|RelNode
argument_list|>
name|translate
parameter_list|()
throws|throws
name|FrontendException
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|relNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
name|pigOp
range|:
name|plan
operator|.
name|getSinks
argument_list|()
control|)
block|{
name|currentRoot
operator|=
name|pigOp
expr_stmt|;
name|currentWalker
operator|.
name|walk
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pigOp
operator|instanceof
name|LOStore
operator|)
condition|)
block|{
name|relNodes
operator|.
name|add
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|relNodes
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOLoad
name|load
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// Two types of tables to load:
comment|// 1. LOAD '[schemaName.]tableName': load table from database catalog
comment|// 2. LOAD '/path/to/tableName': load from a file
name|String
name|fullName
init|=
name|load
operator|.
name|getSchemaFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullName
operator|.
name|contains
argument_list|(
literal|"file://"
argument_list|)
condition|)
block|{
comment|// load from database catalog. Pig will see it as a file in the working directory
name|fullName
operator|=
name|Paths
operator|.
name|get
argument_list|(
name|load
operator|.
name|getSchemaFile
argument_list|()
argument_list|)
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|String
index|[]
name|tableNames
decl_stmt|;
if|if
condition|(
name|fullName
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
comment|// load from file
name|tableNames
operator|=
operator|new
name|String
index|[
literal|1
index|]
expr_stmt|;
name|tableNames
index|[
literal|0
index|]
operator|=
name|fullName
expr_stmt|;
block|}
else|else
block|{
comment|// load from catalog
name|tableNames
operator|=
name|fullName
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
expr_stmt|;
block|}
specifier|final
name|LogicalSchema
name|pigSchema
init|=
name|load
operator|.
name|getSchema
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|pigRelOptTable
decl_stmt|;
if|if
condition|(
name|pigSchema
operator|==
literal|null
condition|)
block|{
name|pigRelOptTable
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// If Pig schema is provided in the load command, convert it into
comment|// relational row type
specifier|final
name|RelDataType
name|rowType
init|=
name|PigTypes
operator|.
name|convertSchema
argument_list|(
name|pigSchema
argument_list|)
decl_stmt|;
name|pigRelOptTable
operator|=
name|PigTable
operator|.
name|createRelOptTable
argument_list|(
name|builder
operator|.
name|getRelOptSchema
argument_list|()
argument_list|,
name|rowType
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|tableNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|scan
argument_list|(
name|pigRelOptTable
argument_list|,
name|tableNames
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|load
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOFilter
name|filter
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|RexNode
name|relExFilter
init|=
name|PigRelExVisitor
operator|.
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|filter
operator|.
name|getFilterPlan
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|filter
argument_list|(
name|relExFilter
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOForEach
name|foreach
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// Use an inner visitor to translate Pig inner plan into a relational plan
comment|// See @PigRelOpInnerVisitor for details.
name|PigRelOpWalker
name|innerWalker
init|=
operator|new
name|PigRelOpWalker
argument_list|(
name|foreach
operator|.
name|getInnerPlan
argument_list|()
argument_list|)
decl_stmt|;
name|PigRelOpInnerVisitor
name|innerVisitor
init|=
operator|new
name|PigRelOpInnerVisitor
argument_list|(
name|foreach
operator|.
name|getInnerPlan
argument_list|()
argument_list|,
name|innerWalker
argument_list|,
name|builder
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|innerVisitor
operator|.
name|translate
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|builder
operator|.
name|push
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|foreach
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOCogroup
name|loCogroup
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// Pig parser already converted CUBE operator into a set of operators, including LOCogroup.
comment|// Thus this method handles all GROUP/COGROUP/CUBE commands
specifier|final
name|GroupType
name|groupType
init|=
name|getGroupType
argument_list|(
name|loCogroup
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupType
operator|==
name|GroupType
operator|.
name|REGULAR
condition|)
block|{
name|processRegularGroup
argument_list|(
name|loCogroup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for CUBE and ROLLUP
name|processCube
argument_list|(
name|groupType
argument_list|,
name|loCogroup
argument_list|)
expr_stmt|;
block|}
comment|// Finally project the group and aggregate fields. Note that if group consists of multiple
comment|// group keys, we do grouping using multiple keys and then convert these group keys into
comment|// a single composite group key (with tuple/struct type) in this step.
comment|// The other option is to create the composite group key first and do grouping on this
comment|// composite key. But this option is less friendly the relational algebra, which flat
comment|// types are more common.
name|projectGroup
argument_list|(
name|loCogroup
operator|.
name|getExpressionPlans
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|loCogroup
argument_list|)
expr_stmt|;
block|}
comment|/**    * Projects group key with 'group' alias so that upstream operator can refer to, along    * with other aggregate columns. If group consists of multiple group keys, construct    * a composite tuple/struct type to make it compatible with PIG group semantic.    *    * @param groupCount Number of group keys.    */
specifier|private
name|void
name|projectGroup
parameter_list|(
name|int
name|groupCount
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|builder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|RexNode
name|groupRex
decl_stmt|;
comment|// First construct the group field
if|if
condition|(
name|groupCount
operator|==
literal|1
condition|)
block|{
comment|// Single group key, just project it out directly
name|groupRex
operator|=
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise, build a struct for all group keys use SQL ROW operator
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|fieldTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|fieldRexes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|groupCount
condition|;
name|j
operator|++
control|)
block|{
name|fieldTypes
operator|.
name|add
argument_list|(
name|inputFields
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|inputFields
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|fieldRexes
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|groupDataType
init|=
name|PigTypes
operator|.
name|TYPE_FACTORY
operator|.
name|createStructType
argument_list|(
name|fieldTypes
argument_list|,
name|fieldNames
argument_list|)
decl_stmt|;
name|groupRex
operator|=
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|groupDataType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|,
name|fieldRexes
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|outputFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Project group field first
name|outputFields
operator|.
name|add
argument_list|(
name|groupRex
argument_list|)
expr_stmt|;
name|outputNames
operator|.
name|add
argument_list|(
literal|"group"
argument_list|)
expr_stmt|;
comment|// Then all other aggregate fields
for|for
control|(
name|int
name|i
init|=
name|groupCount
init|;
name|i
operator|<
name|inputFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|outputFields
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|outputNames
operator|.
name|add
argument_list|(
name|inputFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|project
argument_list|(
name|outputFields
argument_list|,
name|outputNames
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Processes regular a group/group.    *    * @param loCogroup Pig logical group operator    * @throws FrontendException Exception during processing Pig operators    */
specifier|private
name|void
name|processRegularGroup
parameter_list|(
name|LOCogroup
name|loCogroup
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|List
argument_list|<
name|RelBuilder
operator|.
name|GroupKey
argument_list|>
name|groupKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numRels
init|=
name|loCogroup
operator|.
name|getExpressionPlans
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Project out the group keys and the whole row, which will be aggregated with
comment|// COLLECT operator later.
name|preprocessCogroup
argument_list|(
name|loCogroup
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Build the group key
for|for
control|(
name|Integer
name|key
range|:
name|loCogroup
operator|.
name|getExpressionPlans
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
specifier|final
name|int
name|groupCount
init|=
name|loCogroup
operator|.
name|getExpressionPlans
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|relKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupCount
condition|;
name|i
operator|++
control|)
block|{
name|relKeys
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
name|numRels
operator|-
name|key
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|groupKeys
operator|.
name|add
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|relKeys
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// The do COLLECT aggregate.
name|builder
operator|.
name|cogroup
argument_list|(
name|groupKeys
argument_list|)
expr_stmt|;
block|}
comment|/**    * Processes a CUBE/ROLLUP group type.    *    * @param groupType type of the group, either ROLLUP or CUBE    * @param loCogroup Pig logical group operator    * @throws FrontendException Exception during processing Pig operator    */
specifier|private
name|void
name|processCube
parameter_list|(
name|GroupType
name|groupType
parameter_list|,
name|LOCogroup
name|loCogroup
parameter_list|)
throws|throws
name|FrontendException
block|{
assert|assert
name|loCogroup
operator|.
name|getExpressionPlans
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
comment|// First adjust the top rel in the builder, which will be served as input rel for
comment|// the CUBE COGROUP operator because Pig already convert LOCube into
comment|// a ForEach (to project out the group set using @CubeDimensions or @RollupDimension UDFs)
comment|// and a @LOCogroup. We dont need to use these UDFs to generate the groupset.
comment|// So we need to undo the effect of translate this ForEach int relational
comment|// algebra nodes before.
name|adjustCubeInput
argument_list|()
expr_stmt|;
comment|// Project out the group keys and the whole row, which will be aggregated with
comment|// COLLECT operator later.
name|preprocessCogroup
argument_list|(
name|loCogroup
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Generate the group set for the corresponding group type.
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupsetBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|keyIndexs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|groupsetBuilder
operator|.
name|add
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|keyIndexs
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|groupCount
init|=
name|loCogroup
operator|.
name|getExpressionPlans
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|groupCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|keyIndexs
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|groupsetBuilder
operator|.
name|add
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|keyIndexs
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|keyIndexs
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
init|=
operator|(
name|groupType
operator|==
name|GroupType
operator|.
name|CUBE
operator|)
condition|?
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSet
operator|.
name|powerSet
argument_list|()
argument_list|)
else|:
name|groupsetBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelBuilder
operator|.
name|GroupKey
name|groupKey
init|=
name|builder
operator|.
name|groupKey
argument_list|(
name|groupSet
argument_list|,
name|groupSets
argument_list|)
decl_stmt|;
comment|// Finally, do COLLECT aggregate.
name|builder
operator|.
name|cogroup
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adjusts the rel input for Pig Cube operator.    */
specifier|private
name|void
name|adjustCubeInput
parameter_list|()
block|{
name|RelNode
name|project1
init|=
name|builder
operator|.
name|peek
argument_list|()
decl_stmt|;
assert|assert
name|project1
operator|instanceof
name|LogicalProject
assert|;
name|RelNode
name|correl
init|=
operator|(
operator|(
name|LogicalProject
operator|)
name|project1
operator|)
operator|.
name|getInput
argument_list|()
decl_stmt|;
assert|assert
name|correl
operator|instanceof
name|LogicalCorrelate
assert|;
name|RelNode
name|project2
init|=
operator|(
operator|(
name|LogicalCorrelate
operator|)
name|correl
operator|)
operator|.
name|getLeft
argument_list|()
decl_stmt|;
assert|assert
name|project2
operator|instanceof
name|LogicalProject
assert|;
name|builder
operator|.
name|replaceTop
argument_list|(
operator|(
operator|(
name|LogicalProject
operator|)
name|project2
operator|)
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Projects out group key and the row for each relation    *    * @param loCogroup Pig logical group operator    * @throws FrontendException Exception during processing Pig operator    */
specifier|private
name|void
name|preprocessCogroup
parameter_list|(
name|LOCogroup
name|loCogroup
parameter_list|,
name|boolean
name|isCubeRollup
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|int
name|numRels
init|=
name|loCogroup
operator|.
name|getExpressionPlans
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Pull out all cogrouped relations from the builder
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRels
condition|;
name|i
operator|++
control|)
block|{
name|inputRels
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Then adding back with the corresponding projection
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRels
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelNode
name|originalRel
init|=
name|inputRels
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|builder
operator|.
name|push
argument_list|(
name|originalRel
argument_list|)
expr_stmt|;
specifier|final
name|Collection
argument_list|<
name|LogicalExpressionPlan
argument_list|>
name|pigGroupKeys
init|=
name|loCogroup
operator|.
name|getExpressionPlans
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|fieldRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LogicalExpressionPlan
name|pigKey
range|:
name|pigGroupKeys
control|)
block|{
name|fieldRels
operator|.
name|add
argument_list|(
name|PigRelExVisitor
operator|.
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|pigKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|row
init|=
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|getGroupRowType
argument_list|(
name|fieldRels
argument_list|,
name|isCubeRollup
argument_list|)
argument_list|,
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|,
name|getGroupRowOperands
argument_list|(
name|fieldRels
argument_list|,
name|isCubeRollup
argument_list|)
argument_list|)
decl_stmt|;
name|fieldRels
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|builder
operator|.
name|project
argument_list|(
name|fieldRels
argument_list|)
expr_stmt|;
name|builder
operator|.
name|updateAlias
argument_list|(
name|builder
operator|.
name|getPig
argument_list|(
name|originalRel
argument_list|)
argument_list|,
name|builder
operator|.
name|getAlias
argument_list|(
name|originalRel
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Gets row type for the group column
specifier|private
name|RelDataType
name|getGroupRowType
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|groupFields
parameter_list|,
name|boolean
name|isCubeRollup
parameter_list|)
block|{
if|if
condition|(
name|isCubeRollup
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rowFields
init|=
name|builder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|fieldTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|groupColIndexes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// First copy fields of grouping columns
for|for
control|(
name|RexNode
name|rex
range|:
name|groupFields
control|)
block|{
assert|assert
name|rex
operator|instanceof
name|RexInputRef
assert|;
name|int
name|colIndex
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|groupColIndexes
operator|.
name|add
argument_list|(
name|colIndex
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|rowFields
operator|.
name|get
argument_list|(
name|colIndex
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|fieldTypes
operator|.
name|add
argument_list|(
name|rowFields
operator|.
name|get
argument_list|(
name|colIndex
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Then copy the remaining fields from the parent rel
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|groupColIndexes
operator|.
name|contains
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|fieldTypes
operator|.
name|add
argument_list|(
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|PigTypes
operator|.
name|TYPE_FACTORY
operator|.
name|createStructType
argument_list|(
name|fieldTypes
argument_list|,
name|fieldNames
argument_list|)
return|;
block|}
return|return
name|builder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
return|;
block|}
comment|/** Gets the operands for the ROW operator to construct the group column. */
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|getGroupRowOperands
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|fieldRels
parameter_list|,
name|boolean
name|isCubeRollup
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|rowFields
init|=
name|builder
operator|.
name|fields
argument_list|()
decl_stmt|;
if|if
condition|(
name|isCubeRollup
condition|)
block|{
comment|// Add group by columns first
name|List
argument_list|<
name|RexNode
argument_list|>
name|cubeRowFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fieldRels
argument_list|)
decl_stmt|;
comment|// Then and remaining columns
for|for
control|(
name|RexNode
name|field
range|:
name|rowFields
control|)
block|{
if|if
condition|(
operator|!
name|cubeRowFields
operator|.
name|contains
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|cubeRowFields
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|cubeRowFields
return|;
block|}
return|return
name|rowFields
return|;
block|}
comment|/**    * Checks the group type of a group.    *    * @param pigGroup Pig logical group operator    * @return The group type, either CUBE, ROLLUP, or REGULAR    */
specifier|private
specifier|static
name|GroupType
name|getGroupType
parameter_list|(
name|LOCogroup
name|pigGroup
parameter_list|)
block|{
if|if
condition|(
name|pigGroup
operator|.
name|getInputs
argument_list|(
operator|(
name|LogicalPlan
operator|)
name|pigGroup
operator|.
name|getPlan
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
specifier|final
name|Operator
name|input
init|=
name|pigGroup
operator|.
name|getInputs
argument_list|(
operator|(
name|LogicalPlan
operator|)
name|pigGroup
operator|.
name|getPlan
argument_list|()
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|input
operator|instanceof
name|LOForEach
condition|)
block|{
specifier|final
name|LOForEach
name|foreach
init|=
operator|(
name|LOForEach
operator|)
name|input
decl_stmt|;
if|if
condition|(
name|foreach
operator|.
name|getInnerPlan
argument_list|()
operator|.
name|getSinks
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
specifier|final
name|LOGenerate
name|generate
init|=
operator|(
name|LOGenerate
operator|)
name|foreach
operator|.
name|getInnerPlan
argument_list|()
operator|.
name|getSinks
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|LogicalExpressionPlan
argument_list|>
name|projectList
init|=
name|generate
operator|.
name|getOutputPlans
argument_list|()
decl_stmt|;
if|if
condition|(
name|projectList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
specifier|final
name|LogicalExpressionPlan
name|exPlan
init|=
name|projectList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exPlan
operator|.
name|getSources
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|exPlan
operator|.
name|getSources
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|UserFuncExpression
condition|)
block|{
specifier|final
name|UserFuncExpression
name|func
init|=
operator|(
name|UserFuncExpression
operator|)
name|exPlan
operator|.
name|getSources
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|.
name|getFuncSpec
argument_list|()
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
name|CubeDimensions
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|GroupType
operator|.
name|CUBE
return|;
block|}
if|if
condition|(
name|func
operator|.
name|getFuncSpec
argument_list|()
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
name|RollupDimensions
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|GroupType
operator|.
name|ROLLUP
return|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|GroupType
operator|.
name|REGULAR
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOLimit
name|loLimit
parameter_list|)
throws|throws
name|FrontendException
block|{
name|builder
operator|.
name|limit
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|loLimit
operator|.
name|getLimit
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|loLimit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOSort
name|loSort
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// TODO Hanlde custom sortFunc from Pig???
specifier|final
name|int
name|limit
init|=
operator|(
name|int
operator|)
name|loSort
operator|.
name|getLimit
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|relSortCols
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|loSort
operator|.
name|isStar
argument_list|()
condition|)
block|{
comment|// Sort using all columns
name|RelNode
name|top
init|=
name|builder
operator|.
name|peek
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|top
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|relSortCols
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Sort using specific columns
assert|assert
name|loSort
operator|.
name|getSortColPlans
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|loSort
operator|.
name|getAscendingCols
argument_list|()
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loSort
operator|.
name|getSortColPlans
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|sortColsNoDirection
init|=
name|PigRelExVisitor
operator|.
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|loSort
operator|.
name|getSortColPlans
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
comment|// Add sort directions
if|if
condition|(
operator|!
name|loSort
operator|.
name|getAscendingCols
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|relSortCols
operator|.
name|add
argument_list|(
name|builder
operator|.
name|desc
argument_list|(
name|sortColsNoDirection
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relSortCols
operator|.
name|add
argument_list|(
name|sortColsNoDirection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|builder
operator|.
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
name|relSortCols
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|loSort
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOJoin
name|join
parameter_list|)
throws|throws
name|FrontendException
block|{
name|joinInternal
argument_list|(
name|join
operator|.
name|getExpressionPlans
argument_list|()
argument_list|,
name|join
operator|.
name|getInnerFlags
argument_list|()
argument_list|)
expr_stmt|;
name|LogicalJoin
name|joinRel
init|=
operator|(
name|LogicalJoin
operator|)
name|builder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|duplicateNames
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|joinRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
name|duplicateNames
operator|.
name|retainAll
argument_list|(
name|joinRel
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicateNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|leftField
range|:
name|joinRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|builder
operator|.
name|getAlias
argument_list|(
name|joinRel
operator|.
name|getLeft
argument_list|()
argument_list|)
operator|+
literal|"::"
operator|+
name|leftField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
name|leftField
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|leftCount
init|=
name|joinRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|rightField
range|:
name|joinRel
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|builder
operator|.
name|getAlias
argument_list|(
name|joinRel
operator|.
name|getRight
argument_list|()
argument_list|)
operator|+
literal|"::"
operator|+
name|rightField
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
name|rightField
operator|.
name|getIndex
argument_list|()
operator|+
name|leftCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|project
argument_list|(
name|fields
argument_list|,
name|fieldNames
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|register
argument_list|(
name|join
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOCross
name|loCross
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|int
name|numInputs
init|=
name|loCross
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|MultiMap
argument_list|<
name|Integer
argument_list|,
name|LogicalExpressionPlan
argument_list|>
name|joinPlans
init|=
operator|new
name|LinkedMultiMap
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
index|[]
name|innerFlags
init|=
operator|new
name|boolean
index|[
name|numInputs
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numInputs
condition|;
name|i
operator|++
control|)
block|{
comment|// Adding empty join keys
name|joinPlans
operator|.
name|put
argument_list|(
name|i
argument_list|,
operator|new
name|LinkedList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|innerFlags
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
name|joinInternal
argument_list|(
name|joinPlans
argument_list|,
name|innerFlags
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|loCross
argument_list|)
expr_stmt|;
block|}
comment|/**    * Joins a list of relations (previously pushed into the builder).    *    * @param joinPlans  Join keys    * @param innerFlags Join type    * @throws FrontendException Exception during processing Pig operator    */
specifier|private
name|void
name|joinInternal
parameter_list|(
name|MultiMap
argument_list|<
name|Integer
argument_list|,
name|LogicalExpressionPlan
argument_list|>
name|joinPlans
parameter_list|,
name|boolean
index|[]
name|innerFlags
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|int
name|numRels
init|=
name|joinPlans
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Pull out all joined relations from the builder
name|List
argument_list|<
name|RelNode
argument_list|>
name|joinRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRels
condition|;
name|i
operator|++
control|)
block|{
name|joinRels
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Then join each pair from left to right
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRels
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|push
argument_list|(
name|joinRels
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|predicates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|LogicalExpressionPlan
argument_list|>
name|leftJoinExprs
init|=
name|joinPlans
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LogicalExpressionPlan
argument_list|>
name|rightJoinExprs
init|=
name|joinPlans
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|leftJoinExprs
operator|.
name|size
argument_list|()
operator|==
name|rightJoinExprs
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|leftJoinExprs
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|RexNode
name|leftRelExpr
init|=
name|PigRelExVisitor
operator|.
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|leftJoinExprs
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|rightRelExpr
init|=
name|PigRelExVisitor
operator|.
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|rightJoinExprs
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|predicates
operator|.
name|add
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|leftRelExpr
argument_list|,
name|rightRelExpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|join
argument_list|(
name|getJoinType
argument_list|(
name|innerFlags
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|innerFlags
index|[
name|i
index|]
argument_list|)
argument_list|,
name|builder
operator|.
name|and
argument_list|(
name|predicates
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Decides the join type from the inner types of both relation.    *    * @param leftInner  true if the left requires inner    * @param rightInner true if the right requires inner    * @return The join type, either INNER, LEFT, RIGHT, or FULL    */
specifier|private
specifier|static
name|JoinRelType
name|getJoinType
parameter_list|(
name|boolean
name|leftInner
parameter_list|,
name|boolean
name|rightInner
parameter_list|)
block|{
if|if
condition|(
name|leftInner
operator|&&
name|rightInner
condition|)
block|{
return|return
name|JoinRelType
operator|.
name|INNER
return|;
block|}
if|else if
condition|(
name|leftInner
condition|)
block|{
return|return
name|JoinRelType
operator|.
name|LEFT
return|;
block|}
if|else if
condition|(
name|rightInner
condition|)
block|{
return|return
name|JoinRelType
operator|.
name|RIGHT
return|;
block|}
else|else
block|{
return|return
name|JoinRelType
operator|.
name|FULL
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOUnion
name|loUnion
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// The tricky thing to translate union are the input schemas. Relational algebra does not
comment|// support UNION of input with different schemas, so we need to make sure to have inputs
comment|// with same schema first.
name|LogicalSchema
name|unionSchema
init|=
name|loUnion
operator|.
name|getSchema
argument_list|()
decl_stmt|;
if|if
condition|(
name|unionSchema
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"UNION on incompatible types is not supported. "
operator|+
literal|"Please consider using ONSCHEMA option"
argument_list|)
throw|;
block|}
comment|// First get the shared schema
name|int
name|numInputs
init|=
name|loUnion
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|RelDataType
name|unionRelType
init|=
name|PigTypes
operator|.
name|convertSchema
argument_list|(
name|unionSchema
argument_list|)
decl_stmt|;
comment|// Then using projections to adjust input relations with the shared schema
name|List
argument_list|<
name|RelNode
argument_list|>
name|adjustedInputs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numInputs
condition|;
name|i
operator|++
control|)
block|{
name|adjustedInputs
operator|.
name|add
argument_list|(
name|builder
operator|.
name|project
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|,
name|unionRelType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Push the adjusted input back to the builder to do union
for|for
control|(
name|int
name|i
init|=
name|numInputs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|builder
operator|.
name|push
argument_list|(
name|adjustedInputs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Finally do union
name|builder
operator|.
name|union
argument_list|(
literal|true
argument_list|,
name|numInputs
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|loUnion
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LODistinct
name|loDistinct
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// Straightforward, just build distinct on the top relation
name|builder
operator|.
name|distinct
argument_list|()
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|loDistinct
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOCube
name|cube
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// Invalid to get here
throw|throw
operator|new
name|FrontendException
argument_list|(
literal|"Cube should be translated into group by Pig parser"
argument_list|,
literal|10000
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOInnerLoad
name|load
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// InnerLoad should be handled by @PigRelOpInnerVisitor
throw|throw
operator|new
name|FrontendException
argument_list|(
literal|"Not implemented"
argument_list|,
literal|10000
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOSplit
name|loSplit
parameter_list|)
throws|throws
name|FrontendException
block|{
name|builder
operator|.
name|register
argument_list|(
name|loSplit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOSplitOutput
name|loSplitOutput
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|RexNode
name|relExFilter
init|=
name|PigRelExVisitor
operator|.
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|loSplitOutput
operator|.
name|getFilterPlan
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|filter
argument_list|(
name|relExFilter
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|loSplitOutput
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOStore
name|store
parameter_list|)
throws|throws
name|FrontendException
block|{
name|builder
operator|.
name|store
argument_list|(
name|store
operator|.
name|getAlias
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOGenerate
name|gen
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// LOGenerate should be handled by @PigRelOpInnerVisitor
throw|throw
operator|new
name|FrontendException
argument_list|(
literal|"Not implemented"
argument_list|,
literal|10000
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LORank
name|loRank
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// First build the rank field using window function with information from loRank
specifier|final
name|RexNode
name|rankField
init|=
name|buildRankField
argument_list|(
name|loRank
argument_list|)
decl_stmt|;
comment|// Then project out the rank field along with all other fields
specifier|final
name|RelDataType
name|inputRowType
init|=
name|builder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectedFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|projectedFields
operator|.
name|add
argument_list|(
name|rankField
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|RANK_PREFIX
operator|+
name|loRank
operator|.
name|getAlias
argument_list|()
argument_list|)
expr_stmt|;
comment|// alias of the rank field
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projectedFields
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|inputRowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Finally do project
name|builder
operator|.
name|project
argument_list|(
name|projectedFields
argument_list|,
name|fieldNames
argument_list|)
expr_stmt|;
name|builder
operator|.
name|register
argument_list|(
name|loRank
argument_list|)
expr_stmt|;
block|}
comment|/**    * Builds a window function for {@link LORank}.    *    * @param loRank Pig logical rank operator    * @return The window function    * @throws FrontendException Exception during processing Pig operator    */
specifier|private
name|RexNode
name|buildRankField
parameter_list|(
name|LORank
name|loRank
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// Aggregate function is either RANK or DENSE_RANK
name|SqlAggFunction
name|rank
init|=
name|loRank
operator|.
name|isDenseRank
argument_list|()
condition|?
name|SqlStdOperatorTable
operator|.
name|DENSE_RANK
else|:
name|SqlStdOperatorTable
operator|.
name|RANK
decl_stmt|;
comment|// Build the order keys
name|List
argument_list|<
name|RexFieldCollation
argument_list|>
name|orderNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loRank
operator|.
name|getRankColPlans
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|orderNode
init|=
name|PigRelExVisitor
operator|.
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|loRank
operator|.
name|getRankColPlans
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|SqlKind
argument_list|>
name|flags
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|loRank
operator|.
name|getAscendingCol
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|flags
operator|.
name|add
argument_list|(
name|SqlKind
operator|.
name|DESCENDING
argument_list|)
expr_stmt|;
block|}
name|orderNodes
operator|.
name|add
argument_list|(
operator|new
name|RexFieldCollation
argument_list|(
name|orderNode
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeOver
argument_list|(
name|PigTypes
operator|.
name|TYPE_FACTORY
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|,
comment|// Return type
name|rank
argument_list|,
comment|// Aggregate function
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
comment|// Operands for the aggregate function, empty here
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
comment|// No partition keys
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|orderNodes
argument_list|)
argument_list|,
comment|// order keys
name|RexWindowBound
operator|.
name|create
argument_list|(
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|,
comment|// window with unbounded lower
name|RexWindowBound
operator|.
name|create
argument_list|(
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|,
comment|// till current
literal|false
argument_list|,
comment|// Range-based
literal|true
argument_list|,
comment|// allow partial
literal|false
argument_list|,
comment|// not return null when count is zero
literal|false
argument_list|,
comment|// no distinct
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOStream
name|loStream
parameter_list|)
throws|throws
name|FrontendException
block|{
throw|throw
operator|new
name|FrontendException
argument_list|(
literal|"Not implemented"
argument_list|,
literal|10000
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LONative
name|nativeMR
parameter_list|)
throws|throws
name|FrontendException
block|{
throw|throw
operator|new
name|FrontendException
argument_list|(
literal|"Not implemented"
argument_list|,
literal|10000
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|preVisit
parameter_list|(
name|LogicalRelationalOperator
name|root
parameter_list|)
block|{
return|return
name|builder
operator|.
name|checkMap
argument_list|(
name|root
argument_list|)
return|;
block|}
block|}
end_class

end_unit

