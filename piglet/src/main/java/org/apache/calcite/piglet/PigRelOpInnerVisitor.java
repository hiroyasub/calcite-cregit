begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|piglet
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|MultisetSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|impl
operator|.
name|logicalLayer
operator|.
name|FrontendException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|OperatorPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|PlanWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|LogicalExpressionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOGenerate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOInnerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LogicalRelationalOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LogicalSchema
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Visits Pig logical operators of Pig inner logical plans  * (in {@link org.apache.pig.newplan.logical.relational.LOForEach})  * and converts them into corresponding relational algebra plans.  */
end_comment

begin_class
class|class
name|PigRelOpInnerVisitor
extends|extends
name|PigRelOpVisitor
block|{
comment|// The relational algebra operator corresponding to the input of LOForeach operator.
specifier|private
specifier|final
name|RelNode
name|inputRel
decl_stmt|;
comment|// Stack contains correlation id required for processing inner plan.
specifier|private
specifier|final
name|Deque
argument_list|<
name|CorrelationId
argument_list|>
name|corStack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Creates a PigRelOpInnerVisitor.    *    * @param plan Pig inner logical plan    * @param walker The walker over Pig logical plan    * @param builder Relational algebra builder    * @throws FrontendException Exception during processing Pig operators    */
name|PigRelOpInnerVisitor
parameter_list|(
name|OperatorPlan
name|plan
parameter_list|,
name|PlanWalker
name|walker
parameter_list|,
name|PigRelBuilder
name|builder
parameter_list|)
throws|throws
name|FrontendException
block|{
name|super
argument_list|(
name|plan
argument_list|,
name|walker
argument_list|,
name|builder
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputRel
operator|=
name|builder
operator|.
name|peek
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOGenerate
name|gen
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// @LOGenerate is the root of the inner plan, meaning if we reach here, all operators
comment|// except this node have been converted into relational algebra nodes stored in the builder.
comment|// Here we do the final step of generating the relational algebra output node for the
comment|// @LOForEach operator.
comment|// First rejoin all results of columns processed in nested block, if any, using correlation ids
comment|// we remembered before (in visit(LOForeach)).
name|makeCorrelates
argument_list|()
expr_stmt|;
comment|// The project all expressions in the generate command, but ignore flattened columns now
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|multisetFlattens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|flattenOutputAliases
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|doGenerateWithoutMultisetFlatten
argument_list|(
name|gen
argument_list|,
name|multisetFlattens
argument_list|,
name|flattenOutputAliases
argument_list|)
expr_stmt|;
if|if
condition|(
name|multisetFlattens
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|multiSetFlatten
argument_list|(
name|multisetFlattens
argument_list|,
name|flattenOutputAliases
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Rejoins all multiset (bag) columns that have been processed in the nested    * foreach block.    *    * @throws FrontendException Exception during processing Pig operators    */
specifier|private
name|void
name|makeCorrelates
parameter_list|()
throws|throws
name|FrontendException
block|{
name|List
argument_list|<
name|CorrelationId
argument_list|>
name|corIds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|rightRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// First pull out all correlation ids we remembered from the InnerLoads
while|while
condition|(
operator|!
name|corStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|CorrelationId
name|corId
init|=
name|corStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|corIds
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|corId
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|corRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// All output rels from same inner load
while|while
condition|(
operator|!
name|RelOptUtil
operator|.
name|notContainsCorrelation
argument_list|(
name|builder
operator|.
name|peek
argument_list|()
argument_list|,
name|corId
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
name|corRels
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|corRels
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
name|builder
operator|.
name|push
argument_list|(
name|corRels
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|collect
argument_list|()
expr_stmt|;
comment|// Now collapse these rels to a single multiset row and join them together
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|corRels
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|push
argument_list|(
name|corRels
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|collect
argument_list|()
expr_stmt|;
name|builder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rightRels
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// The do correlate join
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|corIds
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|push
argument_list|(
name|rightRels
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|corIds
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Projects all expressions in LOGenerate output expressions, but not consider flatten    * multiset columns yet.    *    * @param gen Pig logical generate operator    * @throws FrontendException Exception during processing Pig operators    */
specifier|private
name|void
name|doGenerateWithoutMultisetFlatten
parameter_list|(
name|LOGenerate
name|gen
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|multisetFlattens
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|flattenOutputAliases
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|List
argument_list|<
name|LogicalExpressionPlan
argument_list|>
name|pigProjections
init|=
name|gen
operator|.
name|getOutputPlans
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|innerCols
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// For projection expressions
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldAlias
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// For projection names/alias
if|if
condition|(
name|gen
operator|.
name|getOutputPlanSchemas
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Generate statement at line "
operator|+
name|gen
operator|.
name|getLocation
argument_list|()
operator|.
name|line
argument_list|()
operator|+
literal|" produces empty schema"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pigProjections
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|LogicalSchema
name|outputFieldSchema
init|=
name|gen
operator|.
name|getOutputPlanSchemas
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|rexNode
init|=
name|PigRelExVisitor
operator|.
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|pigProjections
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|RelDataType
name|dataType
init|=
name|rexNode
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// If project field in null constant, dataType will by NULL type, need to check the original
comment|// type of Pig Schema
if|if
condition|(
name|dataType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|NULL
condition|)
block|{
name|dataType
operator|=
name|PigTypes
operator|.
name|convertSchema
argument_list|(
name|outputFieldSchema
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outputFieldSchema
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|gen
operator|.
name|getFlattenFlags
argument_list|()
index|[
name|i
index|]
condition|)
block|{
specifier|final
name|RelDataType
name|scriptType
init|=
name|PigTypes
operator|.
name|convertSchemaField
argument_list|(
name|outputFieldSchema
operator|.
name|getField
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|ANY
operator|||
operator|!
name|SqlTypeUtil
operator|.
name|isComparable
argument_list|(
name|dataType
argument_list|,
name|scriptType
argument_list|)
condition|)
block|{
comment|// Script schema is different from project expression schema, need to do type cast
name|rexNode
operator|=
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|scriptType
argument_list|,
name|rexNode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gen
operator|.
name|getFlattenFlags
argument_list|()
index|[
name|i
index|]
operator|&&
name|dataType
operator|.
name|isStruct
argument_list|()
operator|&&
operator|(
name|dataType
operator|.
name|getFieldCount
argument_list|()
operator|>
literal|0
operator|||
name|dataType
operator|instanceof
name|DynamicTupleRecordType
operator|)
condition|)
block|{
if|if
condition|(
name|dataType
operator|instanceof
name|DynamicTupleRecordType
condition|)
block|{
operator|(
operator|(
name|DynamicTupleRecordType
operator|)
name|dataType
operator|)
operator|.
name|resize
argument_list|(
name|outputFieldSchema
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|dataType
operator|.
name|getFieldCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|innerCols
operator|.
name|add
argument_list|(
name|builder
operator|.
name|dot
argument_list|(
name|rexNode
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|fieldAlias
operator|.
name|add
argument_list|(
name|outputFieldSchema
operator|.
name|getField
argument_list|(
name|j
argument_list|)
operator|.
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|innerCols
operator|.
name|add
argument_list|(
name|rexNode
argument_list|)
expr_stmt|;
name|String
name|alias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|outputFieldSchema
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// If simple type, take user alias if available
name|alias
operator|=
name|outputFieldSchema
operator|.
name|getField
argument_list|(
literal|0
argument_list|)
operator|.
name|alias
expr_stmt|;
block|}
name|fieldAlias
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|.
name|getFlattenFlags
argument_list|()
index|[
name|i
index|]
operator|&&
name|dataType
operator|.
name|getFamily
argument_list|()
operator|instanceof
name|MultisetSqlType
condition|)
block|{
name|multisetFlattens
operator|.
name|add
argument_list|(
name|innerCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|LogicalSchema
operator|.
name|LogicalFieldSchema
name|field
range|:
name|outputFieldSchema
operator|.
name|getFields
argument_list|()
control|)
block|{
name|String
name|colAlias
init|=
name|field
operator|.
name|alias
decl_stmt|;
if|if
condition|(
name|colAlias
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|String
index|[]
name|tokens
init|=
name|colAlias
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|colAlias
operator|=
name|tokens
index|[
name|tokens
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|flattenOutputAliases
operator|.
name|add
argument_list|(
name|colAlias
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|builder
operator|.
name|project
argument_list|(
name|innerCols
argument_list|,
name|fieldAlias
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LOInnerLoad
name|load
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// Inner loads are the first operator the post order walker (@PigRelOpWalker) visits first
comment|// We first look at the plan structure to see if the inner load is for a simple projection,
comment|// which will not be processed in the nested block
name|List
argument_list|<
name|Operator
argument_list|>
name|succesors
init|=
name|load
operator|.
name|getPlan
argument_list|()
operator|.
name|getSuccessors
argument_list|(
name|load
argument_list|)
decl_stmt|;
comment|// An inner load is for a simple projection if it is a direct input of the @LOGenerate.
comment|// Nothing need to be done further here.
if|if
condition|(
name|succesors
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|succesors
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|LOGenerate
condition|)
block|{
return|return;
block|}
comment|// Now get the index of projected column using its alias
name|RelDataType
name|inputType
init|=
name|inputRel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|String
name|colAlias
init|=
name|load
operator|.
name|getProjection
argument_list|()
operator|.
name|getColAlias
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|colAlias
operator|!=
literal|null
condition|?
name|inputType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|indexOf
argument_list|(
name|colAlias
argument_list|)
else|:
name|load
operator|.
name|getProjection
argument_list|()
operator|.
name|getColNum
argument_list|()
decl_stmt|;
assert|assert
name|index
operator|>=
literal|0
assert|;
comment|// The column should have multiset type to serve as input for the inner plan
assert|assert
name|inputType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|instanceof
name|MultisetSqlType
assert|;
comment|// Build a correlated expression from the input row
specifier|final
name|CorrelationId
name|correlId
init|=
name|builder
operator|.
name|nextCorrelId
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|cor
init|=
name|builder
operator|.
name|correl
argument_list|(
name|inputType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|correlId
argument_list|)
decl_stmt|;
comment|// The project out the column from the correlated expression
name|RexNode
name|fieldAccess
init|=
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|cor
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|builder
operator|.
name|push
argument_list|(
name|LogicalValues
operator|.
name|createOneRow
argument_list|(
name|builder
operator|.
name|getCluster
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|project
argument_list|(
name|fieldAccess
argument_list|)
expr_stmt|;
comment|// Flatten the column value so that it can be served as the input relation for the inner plan
name|builder
operator|.
name|multiSetFlatten
argument_list|()
expr_stmt|;
comment|// Remember the correlation id, then the walker will walk up successor Pig operators. These
comment|// operators will be processed in @PigRelOpVisitor until it hits the @LOGenerate operator,
comment|// which will be processed in this class in visit(LOGenerate)
name|corStack
operator|.
name|push
argument_list|(
name|correlId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|preVisit
parameter_list|(
name|LogicalRelationalOperator
name|root
parameter_list|)
block|{
comment|// Do not remember the visited PigOp in the inner plan, otherwise, we have trouble in doing
comment|// correlate with shared PigOp
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

