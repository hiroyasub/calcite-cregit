begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|piglet
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|immutables
operator|.
name|value
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|piglet
operator|.
name|PigTypes
operator|.
name|TYPE_FACTORY
import|;
end_import

begin_comment
comment|/**  * Planner rule that converts Pig aggregate UDF calls to built-in SQL  * aggregates.  *  *<p>This rule is applied for logical relational algebra plan that is  * the result of Pig translation. In Pig, aggregate calls are separate  * from grouping where we create a bag of all tuples in each group  * first then apply the Pig aggregate UDF later.  It is inefficient to  * do that in SQL.  */
end_comment

begin_class
annotation|@
name|Value
operator|.
name|Enclosing
specifier|public
class|class
name|PigToSqlAggregateRule
extends|extends
name|RelRule
argument_list|<
name|PigToSqlAggregateRule
operator|.
name|Config
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|String
name|MULTISET_PROJECTION
init|=
literal|"MULTISET_PROJECTION"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|PigToSqlAggregateRule
name|INSTANCE
init|=
name|ImmutablePigToSqlAggregateRule
operator|.
name|Config
operator|.
name|builder
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b2
lambda|->
name|b2
operator|.
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b3
lambda|->
name|b3
operator|.
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Creates a PigToSqlAggregateRule. */
specifier|protected
name|PigToSqlAggregateRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
comment|/**    * Visitor that finds all Pig aggregate UDFs or multiset    * projection called in an expression and also whether a column is    * referred in that expression.    */
specifier|private
specifier|static
class|class
name|PigAggUdfFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
comment|// Index of the column
specifier|private
specifier|final
name|int
name|projectCol
decl_stmt|;
comment|// List of all Pig aggregate UDFs found in the expression
specifier|private
specifier|final
name|List
argument_list|<
name|RexCall
argument_list|>
name|pigAggCalls
decl_stmt|;
comment|// True iff the column is referred in the expression
specifier|private
name|boolean
name|projectColReferred
decl_stmt|;
comment|// True to ignore multiset projection inside a PigUDF
specifier|private
name|boolean
name|ignoreMultisetProject
init|=
literal|false
decl_stmt|;
name|PigAggUdfFinder
parameter_list|(
name|int
name|projectCol
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|projectCol
operator|=
name|projectCol
expr_stmt|;
name|pigAggCalls
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|projectColReferred
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|PigRelUdfConverter
operator|.
name|getSqlAggFuncForPigUdf
argument_list|(
name|call
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|pigAggCalls
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|ignoreMultisetProject
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
name|isMultisetProjection
argument_list|(
name|call
argument_list|)
operator|&&
operator|!
name|ignoreMultisetProject
condition|)
block|{
name|pigAggCalls
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
name|visitEach
argument_list|(
name|call
operator|.
name|operands
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|==
name|projectCol
condition|)
block|{
name|projectColReferred
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Helper class to replace each {@link RexCall} by a corresponding    * {@link RexNode}, defined in a given map, for an expression.    *    *<p>It also replaces a projection by a new projection.    */
specifier|private
specifier|static
class|class
name|RexCallReplacer
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|replacementMap
decl_stmt|;
specifier|private
specifier|final
name|RexBuilder
name|builder
decl_stmt|;
specifier|private
specifier|final
name|int
name|oldProjectCol
decl_stmt|;
specifier|private
specifier|final
name|RexNode
name|newProjectCol
decl_stmt|;
name|RexCallReplacer
parameter_list|(
name|RexBuilder
name|builder
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|replacementMap
parameter_list|,
name|int
name|oldProjectCol
parameter_list|,
name|RexNode
name|newProjectCol
parameter_list|)
block|{
name|this
operator|.
name|replacementMap
operator|=
name|replacementMap
expr_stmt|;
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
name|this
operator|.
name|oldProjectCol
operator|=
name|oldProjectCol
expr_stmt|;
name|this
operator|.
name|newProjectCol
operator|=
name|newProjectCol
expr_stmt|;
block|}
name|RexCallReplacer
parameter_list|(
name|RexBuilder
name|builder
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|replacementMap
parameter_list|)
block|{
name|this
argument_list|(
name|builder
argument_list|,
name|replacementMap
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|replacementMap
operator|.
name|containsKey
argument_list|(
name|call
argument_list|)
condition|)
block|{
return|return
name|replacementMap
operator|.
name|get
argument_list|(
name|call
argument_list|)
return|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|call
operator|.
name|operands
control|)
block|{
if|if
condition|(
name|replacementMap
operator|.
name|containsKey
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|newOperands
operator|.
name|add
argument_list|(
name|replacementMap
operator|.
name|get
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newOperands
operator|.
name|add
argument_list|(
name|operand
operator|.
name|accept
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|type
argument_list|,
name|call
operator|.
name|op
argument_list|,
name|newOperands
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|==
name|oldProjectCol
operator|&&
name|newProjectCol
operator|!=
literal|null
operator|&&
name|inputRef
operator|.
name|getType
argument_list|()
operator|==
name|newProjectCol
operator|.
name|getType
argument_list|()
condition|)
block|{
return|return
name|newProjectCol
return|;
block|}
return|return
name|inputRef
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|oldTopProject
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Project
name|oldMiddleProject
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|Aggregate
name|oldAgg
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|Project
name|oldBottomProject
init|=
name|call
operator|.
name|rel
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|call
operator|.
name|builder
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldAgg
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|oldAgg
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getAggregation
argument_list|()
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|COLLECT
condition|)
block|{
comment|// Prevent the rule to be re-applied. Nothing to do here
return|return;
block|}
comment|// Step 0: Find all target Pig aggregate UDFs to rewrite
specifier|final
name|List
argument_list|<
name|RexCall
argument_list|>
name|pigAggUdfs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Whether we need to keep the grouping aggregate call in the new aggregate
name|boolean
name|needGroupingCol
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|oldTopProject
operator|.
name|getProjects
argument_list|()
control|)
block|{
name|PigAggUdfFinder
name|udfVisitor
init|=
operator|new
name|PigAggUdfFinder
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|rex
operator|.
name|accept
argument_list|(
name|udfVisitor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|udfVisitor
operator|.
name|pigAggCalls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RexCall
name|pigAgg
range|:
name|udfVisitor
operator|.
name|pigAggCalls
control|)
block|{
if|if
condition|(
operator|!
name|pigAggUdfs
operator|.
name|contains
argument_list|(
name|pigAgg
argument_list|)
condition|)
block|{
name|pigAggUdfs
operator|.
name|add
argument_list|(
name|pigAgg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|else if
condition|(
name|udfVisitor
operator|.
name|projectColReferred
condition|)
block|{
name|needGroupingCol
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Step 1 Build new bottom project
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newBottomProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|oldBottomProject
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
comment|// First project all group keys, just copy from old one
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldAgg
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|newBottomProjects
operator|.
name|add
argument_list|(
name|oldBottomProject
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If grouping aggregate is needed, project the whole ROW
if|if
condition|(
name|needGroupingCol
condition|)
block|{
specifier|final
name|RexNode
name|row
init|=
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|,
name|relBuilder
operator|.
name|fields
argument_list|()
argument_list|)
decl_stmt|;
name|newBottomProjects
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|groupCount
init|=
name|oldAgg
operator|.
name|getGroupCount
argument_list|()
operator|+
operator|(
name|needGroupingCol
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
comment|// Now figure out which columns need to be projected for Pig UDF aggregate calls
comment|// We need to project these columns for the new aggregate
comment|// This is a map from old index to new index
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|projectedAggColumns
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newBottomProjects
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newBottomProjects
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|RexInputRef
condition|)
block|{
name|projectedAggColumns
operator|.
name|put
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|newBottomProjects
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Build a map of each agg call to a list of columns in the new projection for later use
specifier|final
name|Map
argument_list|<
name|RexCall
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|aggCallColumns
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexCall
name|rexCall
range|:
name|pigAggUdfs
control|)
block|{
comment|// Get columns in old projection required for the agg call
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|requiredColumns
init|=
name|getAggColumns
argument_list|(
name|rexCall
argument_list|)
decl_stmt|;
comment|// And map it to columns of new projection
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|newColIndexes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|col
range|:
name|requiredColumns
control|)
block|{
name|Integer
name|newCol
init|=
name|projectedAggColumns
operator|.
name|get
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|newCol
operator|!=
literal|null
condition|)
block|{
comment|// The column has been projected before
name|newColIndexes
operator|.
name|add
argument_list|(
name|newCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Add it to the projection list if we never project it before
comment|// First get the ROW operator call
specifier|final
name|RexCall
name|rowCall
init|=
operator|(
name|RexCall
operator|)
name|oldBottomProject
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|oldAgg
operator|.
name|getGroupCount
argument_list|()
argument_list|)
decl_stmt|;
comment|// Get the corresponding column index in parent rel through the call operand list
specifier|final
name|RexInputRef
name|columnRef
init|=
operator|(
name|RexInputRef
operator|)
name|rowCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
name|col
argument_list|)
decl_stmt|;
specifier|final
name|int
name|newIndex
init|=
name|newBottomProjects
operator|.
name|size
argument_list|()
decl_stmt|;
name|newBottomProjects
operator|.
name|add
argument_list|(
name|columnRef
argument_list|)
expr_stmt|;
name|projectedAggColumns
operator|.
name|put
argument_list|(
name|columnRef
operator|.
name|getIndex
argument_list|()
argument_list|,
name|newIndex
argument_list|)
expr_stmt|;
name|newColIndexes
operator|.
name|add
argument_list|(
name|newIndex
argument_list|)
expr_stmt|;
block|}
block|}
name|aggCallColumns
operator|.
name|put
argument_list|(
name|rexCall
argument_list|,
name|newColIndexes
argument_list|)
expr_stmt|;
block|}
comment|// Now do the projection
name|relBuilder
operator|.
name|project
argument_list|(
name|newBottomProjects
argument_list|)
expr_stmt|;
comment|// Step 2 build new Aggregate
comment|// Copy the group key
specifier|final
name|RelBuilder
operator|.
name|GroupKey
name|groupKey
init|=
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|oldAgg
operator|.
name|getGroupSet
argument_list|()
argument_list|,
name|oldAgg
operator|.
name|groupSets
argument_list|)
decl_stmt|;
comment|// The construct the agg call list
specifier|final
name|List
argument_list|<
name|RelBuilder
operator|.
name|AggCall
argument_list|>
name|aggCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|needGroupingCol
condition|)
block|{
name|aggCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COLLECT
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
name|groupCount
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RexCall
name|rexCall
range|:
name|pigAggUdfs
control|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|aggOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|aggCallColumns
operator|.
name|get
argument_list|(
name|rexCall
argument_list|)
control|)
block|{
name|aggOperands
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isMultisetProjection
argument_list|(
name|rexCall
argument_list|)
condition|)
block|{
if|if
condition|(
name|aggOperands
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Project single column
name|aggCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COLLECT
argument_list|,
name|aggOperands
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Project more than one column, need to construct a record (ROW)
comment|// from them
specifier|final
name|RelDataType
name|rowType
init|=
name|createRecordType
argument_list|(
name|relBuilder
argument_list|,
name|aggCallColumns
operator|.
name|get
argument_list|(
name|rexCall
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|row
init|=
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|rowType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|,
name|aggOperands
argument_list|)
decl_stmt|;
name|aggCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COLLECT
argument_list|,
name|row
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|SqlAggFunction
name|udf
init|=
name|PigRelUdfConverter
operator|.
name|getSqlAggFuncForPigUdf
argument_list|(
name|rexCall
argument_list|)
decl_stmt|;
name|aggCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|udf
argument_list|,
name|aggOperands
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|relBuilder
operator|.
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|aggCalls
argument_list|)
expr_stmt|;
comment|// Step 3 build new top projection
specifier|final
name|RelDataType
name|aggType
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
comment|// First construct a map from old Pig agg UDF call to a projection
comment|// on new aggregate.
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|pigCallToNewProjections
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pigAggUdfs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexCall
name|pigAgg
init|=
name|pigAggUdfs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|colIndex
init|=
name|i
operator|+
name|groupCount
decl_stmt|;
specifier|final
name|RelDataType
name|fieldType
init|=
name|aggType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|colIndex
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|oldFieldType
init|=
name|pigAgg
operator|.
name|getType
argument_list|()
decl_stmt|;
comment|// If the data type is different, we need to do a type CAST
if|if
condition|(
name|fieldType
operator|.
name|equals
argument_list|(
name|oldFieldType
argument_list|)
condition|)
block|{
name|pigCallToNewProjections
operator|.
name|put
argument_list|(
name|pigAgg
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
name|colIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pigCallToNewProjections
operator|.
name|put
argument_list|(
name|pigAgg
argument_list|,
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|oldFieldType
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
name|colIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now build all expression for the new top project
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|newTopProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|oldUpperProjects
init|=
name|oldTopProject
operator|.
name|getProjects
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rexNode
range|:
name|oldUpperProjects
control|)
block|{
name|int
name|groupRefIndex
init|=
name|getGroupRefIndex
argument_list|(
name|rexNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupRefIndex
operator|>=
literal|0
condition|)
block|{
comment|// project a field of the group
name|newTopProjects
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
name|groupRefIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|rexNode
operator|instanceof
name|RexInputRef
operator|&&
operator|(
operator|(
name|RexInputRef
operator|)
name|rexNode
operator|)
operator|.
name|getIndex
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// project the whole group (as a record)
name|newTopProjects
operator|.
name|add
argument_list|(
name|oldMiddleProject
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// aggregate functions
name|RexCallReplacer
name|replacer
init|=
name|needGroupingCol
condition|?
operator|new
name|RexCallReplacer
argument_list|(
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|pigCallToNewProjections
argument_list|,
literal|1
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
name|groupCount
operator|-
literal|1
argument_list|)
argument_list|)
else|:
operator|new
name|RexCallReplacer
argument_list|(
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|pigCallToNewProjections
argument_list|)
decl_stmt|;
name|newTopProjects
operator|.
name|add
argument_list|(
name|rexNode
operator|.
name|accept
argument_list|(
name|replacer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finally make the top projection
name|relBuilder
operator|.
name|project
argument_list|(
name|newTopProjects
argument_list|,
name|oldTopProject
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|RelDataType
name|createRecordType
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|fields
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|destNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|destTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|index
range|:
name|fields
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|fieldList
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|destNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|destTypes
operator|.
name|add
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|TYPE_FACTORY
operator|.
name|createStructType
argument_list|(
name|destTypes
argument_list|,
name|destNames
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|getGroupRefIndex
parameter_list|(
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
name|rex
operator|instanceof
name|RexFieldAccess
condition|)
block|{
specifier|final
name|RexFieldAccess
name|fieldAccess
init|=
operator|(
name|RexFieldAccess
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
operator|instanceof
name|RexInputRef
condition|)
block|{
specifier|final
name|RexInputRef
name|inputRef
init|=
operator|(
name|RexInputRef
operator|)
name|fieldAccess
operator|.
name|getReferenceExpr
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Project from 'group' column
return|return
name|fieldAccess
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns a list of columns accessed in a Pig aggregate UDF call.    *    * @param pigAggCall Pig aggregate UDF call    */
specifier|private
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|getAggColumns
parameter_list|(
name|RexCall
name|pigAggCall
parameter_list|)
block|{
if|if
condition|(
name|isMultisetProjection
argument_list|(
name|pigAggCall
argument_list|)
condition|)
block|{
return|return
name|getColsFromMultisetProjection
argument_list|(
name|pigAggCall
argument_list|)
return|;
block|}
comment|// The only operand should be PIG_BAG
assert|assert
name|pigAggCall
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|pigAggCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexCall
assert|;
specifier|final
name|RexCall
name|pigBag
init|=
operator|(
name|RexCall
operator|)
name|pigAggCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|pigBag
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
specifier|final
name|RexNode
name|pigBagInput
init|=
name|pigBag
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pigBagInput
operator|instanceof
name|RexCall
condition|)
block|{
comment|// Multiset-projection call
specifier|final
name|RexCall
name|multisetProjection
init|=
operator|(
name|RexCall
operator|)
name|pigBagInput
decl_stmt|;
assert|assert
name|isMultisetProjection
argument_list|(
name|multisetProjection
argument_list|)
assert|;
return|return
name|getColsFromMultisetProjection
argument_list|(
name|multisetProjection
argument_list|)
return|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|getColsFromMultisetProjection
parameter_list|(
name|RexCall
name|multisetProjection
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
assert|assert
name|multisetProjection
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
literal|1
assert|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|multisetProjection
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexLiteral
name|indexLiteral
init|=
operator|(
name|RexLiteral
operator|)
name|multisetProjection
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|columns
operator|.
name|add
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|indexLiteral
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|columns
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isMultisetProjection
parameter_list|(
name|RexCall
name|rexCall
parameter_list|)
block|{
return|return
name|rexCall
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|MULTISET_PROJECTION
argument_list|)
return|;
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|false
argument_list|)
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|PigToSqlAggregateRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|PigToSqlAggregateRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

