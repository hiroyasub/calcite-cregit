begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|piglet
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|ScalarFunctionImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|MultisetSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlUserDefinedFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|impl
operator|.
name|logicalLayer
operator|.
name|FrontendException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|OperatorPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|PlanWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|AddExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|AndExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|BinCondExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|CastExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|ConstantExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|DereferenceExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|DivideExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|EqualExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|GreaterThanEqualExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|GreaterThanExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|IsNullExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|LessThanEqualExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|LessThanExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|LogicalExpressionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|LogicalExpressionVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|MapLookupExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|ModExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|MultiplyExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|NegativeExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|NotEqualExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|NotExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|OrExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|ProjectExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|RegexExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|ScalarExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|SubtractExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|expression
operator|.
name|UserFuncExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LOInnerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LogicalRelationalOperator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Visits pig expression plans and converts them into corresponding RexNodes.  */
end_comment

begin_class
class|class
name|PigRelExVisitor
extends|extends
name|LogicalExpressionVisitor
block|{
comment|/** Stack used during post-order walking process when processing a Pig    * expression plan. */
specifier|private
specifier|final
name|Deque
argument_list|<
name|RexNode
argument_list|>
name|stack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** The relational algebra builder customized for Pig. */
specifier|private
specifier|final
name|PigRelBuilder
name|builder
decl_stmt|;
comment|// inputCount and inputOrdinal are used to select which relation in the builder
comment|// stack to build the projection
comment|/** Number of inputs. */
specifier|private
specifier|final
name|int
name|inputCount
decl_stmt|;
comment|/** Input ordinal. */
specifier|private
specifier|final
name|int
name|inputOrdinal
decl_stmt|;
comment|/**    * Creates a PigRelExVisitor.    *    * @param expressionPlan Pig expression plan    * @param walker The walker over Pig expression plan.    * @param builder Relational algebra builder    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    * @throws FrontendException Exception during processing Pig operators    */
specifier|private
name|PigRelExVisitor
parameter_list|(
name|OperatorPlan
name|expressionPlan
parameter_list|,
name|PlanWalker
name|walker
parameter_list|,
name|PigRelBuilder
name|builder
parameter_list|,
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
throws|throws
name|FrontendException
block|{
name|super
argument_list|(
name|expressionPlan
argument_list|,
name|walker
argument_list|)
expr_stmt|;
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
name|this
operator|.
name|inputCount
operator|=
name|inputCount
expr_stmt|;
name|this
operator|.
name|inputOrdinal
operator|=
name|inputOrdinal
expr_stmt|;
block|}
comment|/**    * Translates the given pig expression plan into a list of relational algebra    * expressions.    *    * @return Relational algebra expressions    * @throws FrontendException Exception during processing Pig operators    */
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|translate
parameter_list|()
throws|throws
name|FrontendException
block|{
name|currentWalker
operator|.
name|walk
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|stack
argument_list|)
return|;
block|}
comment|/**    * Translates a Pig expression plans into relational algebra expressions.    *    * @param builder Relational algebra builder    * @param pigEx Pig expression plan    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    * @return Relational algebra expressions    * @throws FrontendException Exception during processing Pig operators    */
specifier|static
name|RexNode
name|translatePigEx
parameter_list|(
name|PigRelBuilder
name|builder
parameter_list|,
name|LogicalExpressionPlan
name|pigEx
parameter_list|,
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|PigRelExWalker
name|walker
init|=
operator|new
name|PigRelExWalker
argument_list|(
name|pigEx
argument_list|)
decl_stmt|;
specifier|final
name|PigRelExVisitor
name|exVisitor
init|=
operator|new
name|PigRelExVisitor
argument_list|(
name|pigEx
argument_list|,
name|walker
argument_list|,
name|builder
argument_list|,
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|result
init|=
name|exVisitor
operator|.
name|translate
argument_list|()
decl_stmt|;
assert|assert
name|result
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|result
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Translates a Pig expression plans into relational algebra expressions.    *    * @param builder Relational algebra builder    * @param pigEx Pig expression plan    * @return Relational algebra expressions    * @throws FrontendException Exception during processing Pig operators    */
specifier|static
name|RexNode
name|translatePigEx
parameter_list|(
name|PigRelBuilder
name|builder
parameter_list|,
name|LogicalExpressionPlan
name|pigEx
parameter_list|)
throws|throws
name|FrontendException
block|{
return|return
name|translatePigEx
argument_list|(
name|builder
argument_list|,
name|pigEx
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Builds operands for an operator from expressions on the top of the visitor stack.    *    * @param numOps number of operands    * @return List of operand expressions    */
specifier|private
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|buildOperands
parameter_list|(
name|int
name|numOps
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|opList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOps
condition|;
name|i
operator|++
control|)
block|{
name|opList
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|opList
argument_list|)
return|;
block|}
comment|/**    * Builds operands for a binary operator.    *    * @return List of two operand expressions    */
specifier|private
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|buildBinaryOperands
parameter_list|()
block|{
return|return
name|buildOperands
argument_list|(
literal|2
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|ConstantExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|RelDataType
name|constType
init|=
name|PigTypes
operator|.
name|convertSchemaField
argument_list|(
name|op
operator|.
name|getFieldSchema
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
name|op
operator|.
name|getValue
argument_list|()
argument_list|,
name|constType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|ProjectExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|String
name|fullAlias
init|=
name|op
operator|.
name|getFieldSchema
argument_list|()
operator|.
name|alias
decl_stmt|;
if|if
condition|(
name|fullAlias
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|inputRef
decl_stmt|;
try|try
block|{
comment|// First try the exact name match for the alias
name|inputRef
operator|=
name|builder
operator|.
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|fullAlias
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// If not found, look for the field name match only.
comment|// Note that the full alias may have the format of 'tableName::fieldName'
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|builder
operator|.
name|peek
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fullAlias
operator|.
name|endsWith
argument_list|(
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|String
name|shortAlias
init|=
name|fullAlias
decl_stmt|;
if|if
condition|(
name|fullAlias
operator|.
name|contains
argument_list|(
literal|"::"
argument_list|)
condition|)
block|{
name|String
index|[]
name|tokens
init|=
name|fullAlias
operator|.
name|split
argument_list|(
literal|"::"
argument_list|)
decl_stmt|;
name|shortAlias
operator|=
name|tokens
index|[
name|tokens
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|shortAlias
argument_list|)
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ["
operator|+
name|fullAlias
operator|+
literal|"] not found; input fields are: "
operator|+
name|fieldNames
argument_list|)
throw|;
block|}
block|}
name|inputRef
operator|=
name|builder
operator|.
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|inputRef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Alias not provided, get data from input of LOGenerate
assert|assert
name|op
operator|.
name|getInputNum
argument_list|()
operator|>=
literal|0
assert|;
specifier|final
name|Operator
name|pigRelOp
init|=
name|op
operator|.
name|getAttachedRelationalOp
argument_list|()
decl_stmt|;
specifier|final
name|LogicalRelationalOperator
name|childOp
init|=
operator|(
name|LogicalRelationalOperator
operator|)
name|pigRelOp
operator|.
name|getPlan
argument_list|()
operator|.
name|getPredecessors
argument_list|(
name|pigRelOp
argument_list|)
operator|.
name|get
argument_list|(
name|op
operator|.
name|getInputNum
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|.
name|checkMap
argument_list|(
name|childOp
argument_list|)
condition|)
block|{
comment|// Inner plan that has been processed before (nested foreach or flatten)
name|builder
operator|.
name|push
argument_list|(
name|builder
operator|.
name|getRel
argument_list|(
name|childOp
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|fields
init|=
name|builder
operator|.
name|getFields
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|op
operator|.
name|getColNum
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|fields
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Simple inner load
assert|assert
name|childOp
operator|instanceof
name|LOInnerLoad
assert|;
name|visit
argument_list|(
operator|(
operator|(
name|LOInnerLoad
operator|)
name|childOp
operator|)
operator|.
name|getProjection
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|NegativeExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|RexNode
name|operand
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|RexLiteral
condition|)
block|{
specifier|final
name|Comparable
name|value
init|=
operator|(
operator|(
name|RexLiteral
operator|)
name|operand
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
assert|assert
name|value
operator|instanceof
name|BigDecimal
assert|;
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|value
operator|)
operator|.
name|negate
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|UNARY_MINUS
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|EqualExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|NotEqualExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LessThanExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|LessThanEqualExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|GreaterThanExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|GreaterThanEqualExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RegexExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|RexNode
name|operand1
init|=
name|replacePatternIfPossible
argument_list|(
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
decl_stmt|;
name|RexNode
name|operand2
init|=
name|replacePatternIfPossible
argument_list|(
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LIKE
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|operand2
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Replaces Pig regular expressions with SQL regular expressions in a string.    *    * @param rexNode The string literal    * @return New string literal with Pig regular expressions replaced by SQL regular expressions    */
specifier|private
specifier|static
name|RexNode
name|replacePatternIfPossible
parameter_list|(
name|RexNode
name|rexNode
parameter_list|)
block|{
comment|// Until
comment|//   [CALCITE-3194] Convert Pig string patterns into SQL string patterns
comment|// is fixed, return the pattern unchanged.
return|return
name|rexNode
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|IsNullExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|NotExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|stack
operator|.
name|pop
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|AndExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|OrExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|AddExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|SubtractExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|MultiplyExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|ModExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MOD
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|DivideExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DIVIDE
argument_list|,
name|buildBinaryOperands
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|BinCondExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|buildOperands
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|UserFuncExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
if|if
condition|(
name|op
operator|.
name|getFuncSpec
argument_list|()
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.pig.impl.builtin.IdentityColumn"
argument_list|)
condition|)
block|{
comment|// Skip this Pig dummy function
return|return;
block|}
specifier|final
name|int
name|numAgrs
init|=
name|optSize
argument_list|(
name|op
operator|.
name|getPlan
argument_list|()
operator|.
name|getSuccessors
argument_list|(
name|op
argument_list|)
argument_list|)
operator|+
name|optSize
argument_list|(
name|op
operator|.
name|getPlan
argument_list|()
operator|.
name|getSoftLinkSuccessors
argument_list|(
name|op
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|returnType
init|=
name|PigTypes
operator|.
name|convertSchemaField
argument_list|(
name|op
operator|.
name|getFieldSchema
argument_list|()
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|PigRelUdfConverter
operator|.
name|convertPigFunction
argument_list|(
name|builder
argument_list|,
name|op
operator|.
name|getFuncSpec
argument_list|()
argument_list|,
name|buildOperands
argument_list|(
name|numAgrs
argument_list|)
argument_list|,
name|returnType
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|className
init|=
name|op
operator|.
name|getFuncSpec
argument_list|()
operator|.
name|getClassName
argument_list|()
decl_stmt|;
name|SqlOperator
name|sqlOp
init|=
operator|(
operator|(
name|RexCall
operator|)
name|stack
operator|.
name|peek
argument_list|()
operator|)
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|sqlOp
operator|instanceof
name|SqlUserDefinedFunction
condition|)
block|{
name|ScalarFunctionImpl
name|sqlFunc
init|=
operator|(
name|ScalarFunctionImpl
operator|)
operator|(
operator|(
name|SqlUserDefinedFunction
operator|)
name|sqlOp
operator|)
operator|.
name|getFunction
argument_list|()
decl_stmt|;
comment|// "Exec" method can be implemented from the parent class.
name|className
operator|=
name|sqlFunc
operator|.
name|method
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
name|builder
operator|.
name|registerPigUDF
argument_list|(
name|className
argument_list|,
name|op
operator|.
name|getFuncSpec
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|optSize
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|>
name|list
parameter_list|)
block|{
return|return
name|list
operator|!=
literal|null
condition|?
name|list
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|DereferenceExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|RexNode
name|parentField
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|cols
init|=
name|op
operator|.
name|getBagColumns
argument_list|()
decl_stmt|;
assert|assert
name|cols
operator|!=
literal|null
operator|&&
name|cols
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
if|if
condition|(
name|parentField
operator|.
name|getType
argument_list|()
operator|instanceof
name|MultisetSqlType
condition|)
block|{
comment|// Calcite does not support projection on Multiset type. We build
comment|// our own multiset projection in @PigRelSqlUDFs and use it here
specifier|final
name|RexNode
index|[]
name|rexCols
init|=
operator|new
name|RexNode
index|[
name|cols
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
comment|// First parent field
name|rexCols
index|[
literal|0
index|]
operator|=
name|parentField
expr_stmt|;
comment|// The sub-fields to be projected from parent field
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|rexCols
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|builder
operator|.
name|literal
argument_list|(
name|cols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|PigRelSqlUdfs
operator|.
name|MULTISET_PROJECTION
argument_list|,
name|rexCols
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cols
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Single field projection
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|dot
argument_list|(
name|parentField
argument_list|,
name|cols
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Multiple field projection, build a sub struct from the parent struct
name|List
argument_list|<
name|RexNode
argument_list|>
name|relFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|col
range|:
name|cols
control|)
block|{
name|relFields
operator|.
name|add
argument_list|(
name|builder
operator|.
name|dot
argument_list|(
name|parentField
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|newRelType
init|=
name|RexUtil
operator|.
name|createStructType
argument_list|(
name|PigTypes
operator|.
name|TYPE_FACTORY
argument_list|,
name|relFields
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|newRelType
argument_list|,
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|,
name|relFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|CastExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|RelDataType
name|relType
init|=
name|PigTypes
operator|.
name|convertSchemaField
argument_list|(
name|op
operator|.
name|getFieldSchema
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|castOperand
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|castOperand
operator|instanceof
name|RexLiteral
operator|&&
operator|(
operator|(
name|RexLiteral
operator|)
name|castOperand
operator|)
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|relType
operator|.
name|isStruct
argument_list|()
operator|&&
name|relType
operator|.
name|getComponentType
argument_list|()
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeNullLiteral
argument_list|(
name|relType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stack
operator|.
name|push
argument_list|(
name|castOperand
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|relType
argument_list|,
name|castOperand
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|MapLookupExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
specifier|final
name|RexNode
name|relKey
init|=
name|builder
operator|.
name|literal
argument_list|(
name|op
operator|.
name|getLookupKey
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|relMap
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ITEM
argument_list|,
name|relMap
argument_list|,
name|relKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|ScalarExpression
name|op
parameter_list|)
throws|throws
name|FrontendException
block|{
comment|// First operand is the path to the materialized view
name|RexNode
name|operand1
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
assert|assert
name|operand1
operator|instanceof
name|RexLiteral
operator|&&
operator|(
operator|(
name|RexLiteral
operator|)
name|operand1
operator|)
operator|.
name|getValue
argument_list|()
operator|instanceof
name|NlsString
assert|;
comment|// Second operand is the projection index
name|RexNode
name|operand2
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
assert|assert
name|operand2
operator|instanceof
name|RexLiteral
operator|&&
operator|(
operator|(
name|RexLiteral
operator|)
name|operand2
operator|)
operator|.
name|getValue
argument_list|()
operator|instanceof
name|BigDecimal
assert|;
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|BigDecimal
operator|)
operator|(
operator|(
name|RexLiteral
operator|)
name|operand2
operator|)
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|RelNode
name|referencedRel
init|=
name|builder
operator|.
name|getRel
argument_list|(
operator|(
operator|(
name|LogicalRelationalOperator
operator|)
name|op
operator|.
name|getImplicitReferencedOperator
argument_list|()
operator|)
operator|.
name|getAlias
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|push
argument_list|(
name|referencedRel
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectCol
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|builder
operator|.
name|field
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|builder
operator|.
name|project
argument_list|(
name|projectCol
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
name|RexSubQuery
operator|.
name|scalar
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

