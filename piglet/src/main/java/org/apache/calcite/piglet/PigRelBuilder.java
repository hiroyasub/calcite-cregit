begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|piglet
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Convention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|SingleRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Uncollect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|MultisetSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|FrameworkConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|FuncSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|data
operator|.
name|DataBag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|data
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|newplan
operator|.
name|logical
operator|.
name|relational
operator|.
name|LogicalRelationalOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pig
operator|.
name|scripting
operator|.
name|jython
operator|.
name|JythonFunction
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Extension to {@link RelBuilder} for Pig logical operators.  */
end_comment

begin_class
specifier|public
class|class
name|PigRelBuilder
extends|extends
name|RelBuilder
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|String
argument_list|>
name|reverseAliasMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|aliasMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Operator
argument_list|,
name|RelNode
argument_list|>
name|pigRelMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Operator
argument_list|>
name|relPigMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelNode
argument_list|>
name|storeMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nextCorrelId
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|PigRelTranslationContext
name|pigRelContext
init|=
operator|new
name|PigRelTranslationContext
argument_list|()
decl_stmt|;
specifier|private
name|PigRelBuilder
parameter_list|(
name|Context
name|context
parameter_list|,
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|,
name|cluster
argument_list|,
name|relOptSchema
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a PigRelBuilder. */
specifier|public
specifier|static
name|PigRelBuilder
name|create
parameter_list|(
name|FrameworkConfig
name|config
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
operator|.
name|addThread
argument_list|(
name|Hook
operator|.
name|propertyJ
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|PigRelBuilder
argument_list|(
name|config
operator|.
name|getContext
argument_list|()
argument_list|,
name|relBuilder
operator|.
name|getCluster
argument_list|()
argument_list|,
name|relBuilder
operator|.
name|getRelOptSchema
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|getRel
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
return|return
name|aliasMap
operator|.
name|get
argument_list|(
name|alias
argument_list|)
return|;
block|}
specifier|public
name|RelNode
name|getRel
parameter_list|(
name|Operator
name|pig
parameter_list|)
block|{
return|return
name|pigRelMap
operator|.
name|get
argument_list|(
name|pig
argument_list|)
return|;
block|}
name|Operator
name|getPig
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|relPigMap
operator|.
name|get
argument_list|(
name|rel
argument_list|)
return|;
block|}
name|String
name|getAlias
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|reverseAliasMap
operator|.
name|get
argument_list|(
name|rel
argument_list|)
return|;
block|}
comment|/**    * Gets the next correlation id.    *    * @return The correlation id    */
name|CorrelationId
name|nextCorrelId
parameter_list|()
block|{
return|return
operator|new
name|CorrelationId
argument_list|(
name|nextCorrelId
operator|++
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|shouldMergeProject
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|String
name|getAlias
parameter_list|()
block|{
specifier|final
name|RelNode
name|input
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|reverseAliasMap
operator|.
name|containsKey
argument_list|(
name|input
argument_list|)
condition|)
block|{
return|return
name|reverseAliasMap
operator|.
name|get
argument_list|(
name|input
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|super
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reverseAliasMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|aliasMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|pigRelMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|relPigMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|storeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nextCorrelId
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Checks if a Pig logical operator has been translated before. If it has,    * push the corresponding relational algebra operator on top instead of    * doing the translation work again.    *    * @param pigOp The Pig logical operator to check.    * @return true iff the pigOp has been processed before.    */
specifier|public
name|boolean
name|checkMap
parameter_list|(
name|LogicalRelationalOperator
name|pigOp
parameter_list|)
block|{
if|if
condition|(
name|pigRelMap
operator|.
name|containsKey
argument_list|(
name|pigOp
argument_list|)
condition|)
block|{
name|push
argument_list|(
name|pigRelMap
operator|.
name|get
argument_list|(
name|pigOp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Updates the Pig logical operator and its alias with the top    * relational algebra node.    *    * @param pigOp the Pig logical operator    * @param alias the alias    * @param updatePigRelMap whether to update the PigRelMap    */
specifier|public
name|void
name|updateAlias
parameter_list|(
name|Operator
name|pigOp
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|updatePigRelMap
parameter_list|)
block|{
specifier|final
name|RelNode
name|rel
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|updatePigRelMap
condition|)
block|{
name|pigRelMap
operator|.
name|put
argument_list|(
name|pigOp
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
name|relPigMap
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|pigOp
argument_list|)
expr_stmt|;
name|aliasMap
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|reverseAliasMap
operator|.
name|put
argument_list|(
name|rel
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers the Pig logical operator with the top relational algebra node.    *    * @param pigOp the Pig logical operator    */
name|void
name|register
parameter_list|(
name|LogicalRelationalOperator
name|pigOp
parameter_list|)
block|{
name|updateAlias
argument_list|(
name|pigOp
argument_list|,
name|pigOp
operator|.
name|getAlias
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|void
name|registerPigUDF
parameter_list|(
name|String
name|className
parameter_list|,
name|FuncSpec
name|pigFunc
parameter_list|)
block|{
name|Class
name|udfClass
init|=
name|pigFunc
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|className
decl_stmt|;
if|if
condition|(
name|udfClass
operator|==
name|JythonFunction
operator|.
name|class
condition|)
block|{
specifier|final
name|String
index|[]
name|args
init|=
name|pigFunc
operator|.
name|getCtorArgs
argument_list|()
decl_stmt|;
assert|assert
name|args
operator|!=
literal|null
operator|&&
name|args
operator|.
name|length
operator|==
literal|2
assert|;
specifier|final
name|String
name|fileName
init|=
name|args
index|[
literal|0
index|]
operator|.
name|substring
argument_list|(
name|args
index|[
literal|0
index|]
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
operator|+
literal|1
argument_list|,
name|args
index|[
literal|0
index|]
operator|.
name|lastIndexOf
argument_list|(
literal|".py"
argument_list|)
argument_list|)
decl_stmt|;
comment|// key = [clas name]_[file name]_[function name]
name|key
operator|=
name|udfClass
operator|.
name|getName
argument_list|()
operator|+
literal|"_"
operator|+
name|fileName
operator|+
literal|"_"
operator|+
name|args
index|[
literal|1
index|]
expr_stmt|;
block|}
name|pigRelContext
operator|.
name|pigUdfs
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|pigFunc
argument_list|)
expr_stmt|;
block|}
comment|/**    * Replaces the relational algebra operator at the top of the stack with    * a new one.    *    * @param newRel the new relational algebra operator to replace    */
name|void
name|replaceTop
parameter_list|(
name|RelNode
name|newRel
parameter_list|)
block|{
specifier|final
name|RelNode
name|topRel
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|topRel
operator|instanceof
name|SingleRel
condition|)
block|{
name|String
name|alias
init|=
name|reverseAliasMap
operator|.
name|get
argument_list|(
name|topRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|!=
literal|null
condition|)
block|{
name|reverseAliasMap
operator|.
name|remove
argument_list|(
name|topRel
argument_list|)
expr_stmt|;
name|reverseAliasMap
operator|.
name|put
argument_list|(
name|newRel
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|aliasMap
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|newRel
argument_list|)
expr_stmt|;
block|}
name|Operator
name|pig
init|=
name|getPig
argument_list|(
name|topRel
argument_list|)
decl_stmt|;
if|if
condition|(
name|pig
operator|!=
literal|null
condition|)
block|{
name|relPigMap
operator|.
name|remove
argument_list|(
name|topRel
argument_list|)
expr_stmt|;
name|relPigMap
operator|.
name|put
argument_list|(
name|newRel
argument_list|,
name|pig
argument_list|)
expr_stmt|;
name|pigRelMap
operator|.
name|put
argument_list|(
name|pig
argument_list|,
name|newRel
argument_list|)
expr_stmt|;
block|}
name|build
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|newRel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Scans a table with its given schema and names.    *    * @param userSchema The schema of the table to scan    * @param tableNames The names of the table to scan    * @return This builder    */
specifier|public
name|RelBuilder
name|scan
parameter_list|(
name|RelOptTable
name|userSchema
parameter_list|,
name|String
modifier|...
name|tableNames
parameter_list|)
block|{
comment|// First, look up the database schema to find the table schema with the given names
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableNames
argument_list|)
decl_stmt|;
specifier|final
name|RelOptTable
name|systemSchema
init|=
name|relOptSchema
operator|.
name|getTableForMember
argument_list|(
name|names
argument_list|)
decl_stmt|;
comment|// Now we may end up with two different schemas.
if|if
condition|(
name|systemSchema
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|userSchema
operator|!=
literal|null
operator|&&
operator|!
name|compatibleType
argument_list|(
name|userSchema
operator|.
name|getRowType
argument_list|()
argument_list|,
name|systemSchema
operator|.
name|getRowType
argument_list|()
argument_list|)
condition|)
block|{
comment|// If both schemas are valid, they must be compatible
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Pig script schema does not match database schema for table "
operator|+
name|names
operator|+
literal|".\n"
operator|+
literal|"\t Scrip schema: "
operator|+
name|userSchema
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"\t Database schema: "
operator|+
name|systemSchema
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
throw|;
block|}
comment|// We choose to use systemSchema if it is valid
return|return
name|scan
argument_list|(
name|systemSchema
argument_list|)
return|;
block|}
if|else if
condition|(
name|userSchema
operator|!=
literal|null
condition|)
block|{
comment|// If systemSchema is not valid, use userSchema if it is valid
return|return
name|scan
argument_list|(
name|userSchema
argument_list|)
return|;
block|}
else|else
block|{
comment|// At least one of them needs to be valid
throw|throw
name|Static
operator|.
name|RESOURCE
operator|.
name|tableNotFound
argument_list|(
name|String
operator|.
name|join
argument_list|(
literal|"."
argument_list|,
name|names
argument_list|)
argument_list|)
operator|.
name|ex
argument_list|()
throw|;
block|}
block|}
comment|/**    * Scans a table with a given schema.    *    * @param tableSchema The table schema    * @return This builder    */
specifier|private
name|RelBuilder
name|scan
parameter_list|(
name|RelOptTable
name|tableSchema
parameter_list|)
block|{
specifier|final
name|RelNode
name|scan
init|=
name|getScanFactory
argument_list|()
operator|.
name|createScan
argument_list|(
name|cluster
argument_list|,
name|tableSchema
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|scan
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Makes a table scan operator for a given row type and names    *    * @param rowType Row type    * @param tableNames Table names    * @return This builder    */
specifier|public
name|RelBuilder
name|scan
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|String
modifier|...
name|tableNames
parameter_list|)
block|{
return|return
name|scan
argument_list|(
name|rowType
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|tableNames
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Makes a table scan operator for a given row type and names    *    * @param rowType Row type    * @param tableNames Table names    * @return This builder    */
specifier|public
name|RelBuilder
name|scan
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
block|{
specifier|final
name|RelOptTable
name|relOptTable
init|=
name|PigTable
operator|.
name|createRelOptTable
argument_list|(
name|getRelOptSchema
argument_list|()
argument_list|,
name|rowType
argument_list|,
name|tableNames
argument_list|)
decl_stmt|;
return|return
name|scan
argument_list|(
name|relOptTable
argument_list|)
return|;
block|}
comment|/**    * Projects a specific row type out of a relation algebra operator.    * For any field in output type, if there is no matching input field, we project    * null value of the corresponding output field type.    *    *<p>For example, given:    *<ul>    *<li>Input rel {@code A} with {@code A_type(X: int, Y: varchar)}    *<li>Output type {@code B_type(X: int, Y: varchar, Z: boolean, W: double)}    *</ul>    *    *<p>{@code project(A, B_type)} gives new relation    * {@code C(X: int, Y: varchar, null, null)}.    *    * @param input The relation algebra operator to be projected    * @param outputType The data type for the projected relation algebra operator    * @return The projected relation algebra operator    */
specifier|public
name|RelNode
name|project
parameter_list|(
name|RelNode
name|input
parameter_list|,
name|RelDataType
name|outputType
parameter_list|)
block|{
specifier|final
name|RelDataType
name|inputType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|compatibleType
argument_list|(
name|inputType
argument_list|,
name|outputType
argument_list|)
operator|&&
name|inputType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|equals
argument_list|(
name|outputType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
condition|)
block|{
comment|// Same data type, simply returns the input rel
return|return
name|input
return|;
block|}
comment|// Now build the projection expressions on top of the input rel.
name|push
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|project
argument_list|(
name|projects
argument_list|(
name|inputType
argument_list|,
name|outputType
argument_list|)
argument_list|,
name|outputType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|()
return|;
block|}
comment|/**    * Builds the projection expressions for a data type on top of an input data type.    * For any field in output type, if there is no matching input field, we build    * the literal null expression with the corresponding output field type.    *    * @param inputType The input data type    * @param outputType The output data type that defines the types of projection expressions    * @return List of projection expressions    */
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
parameter_list|(
name|RelDataType
name|inputType
parameter_list|,
name|RelDataType
name|outputType
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|outputFields
init|=
name|outputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|inputType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectionExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|outputField
range|:
name|outputFields
control|)
block|{
name|RelDataTypeField
name|matchInputField
init|=
literal|null
decl_stmt|;
comment|// First find the matching input field
for|for
control|(
name|RelDataTypeField
name|inputField
range|:
name|inputFields
control|)
block|{
if|if
condition|(
name|inputField
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|outputField
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// Matched if same name
name|matchInputField
operator|=
name|inputField
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|matchInputField
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|fieldProject
init|=
name|field
argument_list|(
name|matchInputField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchInputField
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|outputField
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
comment|// If found and on same type, just project the field
name|projectionExprs
operator|.
name|add
argument_list|(
name|fieldProject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Different types, CAST is required
name|projectionExprs
operator|.
name|add
argument_list|(
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|outputField
operator|.
name|getType
argument_list|()
argument_list|,
name|fieldProject
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|RelDataType
name|columnType
init|=
name|outputField
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|columnType
operator|.
name|isStruct
argument_list|()
operator|&&
name|columnType
operator|.
name|getComponentType
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// If not, project the null Literal with the same basic type
name|projectionExprs
operator|.
name|add
argument_list|(
name|getRexBuilder
argument_list|()
operator|.
name|makeNullLiteral
argument_list|(
name|outputField
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If Record or Multiset just project a constant null
name|projectionExprs
operator|.
name|add
argument_list|(
name|literal
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|projectionExprs
return|;
block|}
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Cogroups relations on top of the stack. The number of relations and the    * group key are specified in groupKeys    *    * @param groupKeys Lists of group keys of relations to be cogrouped.    * @return This builder    */
specifier|public
name|RelBuilder
name|cogroup
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|GroupKey
argument_list|>
name|groupKeys
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|GroupKeyImpl
argument_list|>
name|groupKeyList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
operator|(
name|Iterable
operator|)
name|groupKeys
argument_list|)
decl_stmt|;
specifier|final
name|int
name|groupCount
init|=
name|groupKeyList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|nodes
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Pull out all relations needed for the group
specifier|final
name|int
name|numRels
init|=
name|groupKeyList
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|cogroupRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRels
condition|;
name|i
operator|++
control|)
block|{
name|cogroupRels
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Group and join relations from left to right
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRels
condition|;
name|i
operator|++
control|)
block|{
comment|// 1. Group each rel first by using COLLECT operator
name|push
argument_list|(
name|cogroupRels
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create a ROW to pass to COLLECT.
specifier|final
name|RexNode
name|row
init|=
name|field
argument_list|(
name|groupCount
argument_list|)
decl_stmt|;
name|aggregate
argument_list|(
name|groupKeyList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COLLECT
argument_list|,
name|row
argument_list|)
operator|.
name|as
argument_list|(
name|getAlias
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|// 2. Then join with the previous group relation
name|List
argument_list|<
name|RexNode
argument_list|>
name|predicates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|key
range|:
name|Util
operator|.
name|range
argument_list|(
name|groupCount
argument_list|)
control|)
block|{
name|predicates
operator|.
name|add
argument_list|(
name|equals
argument_list|(
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|key
argument_list|)
argument_list|,
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|join
argument_list|(
name|JoinRelType
operator|.
name|FULL
argument_list|,
name|and
argument_list|(
name|predicates
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Project group keys from one of these two joined relations, whichever
comment|// is not null and the remaining payload columns
name|RexNode
index|[]
name|projectFields
init|=
operator|new
name|RexNode
index|[
name|groupCount
operator|+
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|String
index|[]
name|fieldNames
init|=
operator|new
name|String
index|[
name|groupCount
operator|+
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|LogicalJoin
name|join
init|=
operator|(
name|LogicalJoin
operator|)
name|peek
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|groupCount
condition|;
name|j
operator|++
control|)
block|{
name|RexNode
index|[]
name|caseOperands
init|=
operator|new
name|RexNode
index|[
literal|3
index|]
decl_stmt|;
comment|// WHEN groupKey[i] of leftRel IS NOT NULL
name|caseOperands
index|[
literal|0
index|]
operator|=
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|field
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|// THEN choose groupKey[i] of leftRel
name|caseOperands
index|[
literal|1
index|]
operator|=
name|field
argument_list|(
name|j
argument_list|)
expr_stmt|;
comment|// ELSE choose groupKey[i] of rightRel
name|caseOperands
index|[
literal|2
index|]
operator|=
name|field
argument_list|(
name|j
operator|+
name|groupCount
operator|+
name|i
argument_list|)
expr_stmt|;
name|projectFields
index|[
name|j
index|]
operator|=
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|caseOperands
argument_list|)
expr_stmt|;
name|String
name|leftName
init|=
name|join
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|String
name|rightName
init|=
name|join
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|fieldNames
index|[
name|j
index|]
operator|=
name|leftName
operator|.
name|equals
argument_list|(
name|rightName
argument_list|)
condition|?
name|leftName
else|:
name|rightName
expr_stmt|;
block|}
comment|// Project the group fields of the leftRel
for|for
control|(
name|int
name|j
init|=
name|groupCount
init|;
name|j
operator|<
name|groupCount
operator|+
name|i
operator|+
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|projectFields
index|[
name|j
index|]
operator|=
name|field
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|fieldNames
index|[
name|j
index|]
operator|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
comment|// Project the group fields of the rightRel
name|projectFields
index|[
name|groupCount
operator|+
name|i
index|]
operator|=
name|field
argument_list|(
literal|2
operator|*
name|groupCount
operator|+
name|i
argument_list|)
expr_stmt|;
name|fieldNames
index|[
name|groupCount
operator|+
name|i
index|]
operator|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
literal|2
operator|*
name|groupCount
operator|+
name|i
argument_list|)
expr_stmt|;
name|project
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|projectFields
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Flattens the top relation on provided columns.    *    * @param flattenCols Indexes of columns to be flattened. These columns should have multiset type.    * @return This builder    */
specifier|public
name|RelBuilder
name|multiSetFlatten
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|flattenCols
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|flattenOutputAliases
parameter_list|)
block|{
specifier|final
name|int
name|colCount
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|CorrelationId
name|correlId
init|=
name|nextCorrelId
argument_list|()
decl_stmt|;
comment|// First build a correlated expression from the input row
specifier|final
name|RexNode
name|cor
init|=
name|correl
argument_list|(
name|inputFields
argument_list|,
name|correlId
argument_list|)
decl_stmt|;
comment|// Then project out flatten columns from the correlated expression
name|List
argument_list|<
name|RexNode
argument_list|>
name|flattenNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|flattenCols
control|)
block|{
assert|assert
name|inputFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|instanceof
name|MultisetSqlType
assert|;
name|flattenNodes
operator|.
name|add
argument_list|(
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|cor
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|push
argument_list|(
name|LogicalValues
operator|.
name|createOneRow
argument_list|(
name|getCluster
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|project
argument_list|(
name|flattenNodes
argument_list|)
expr_stmt|;
comment|// Now do flatten on input rel that contains only multiset columns
name|multiSetFlatten
argument_list|()
expr_stmt|;
comment|// And rejoin the result -> output: original columns + new flattened columns
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|correlId
argument_list|)
argument_list|)
expr_stmt|;
comment|// Finally project out only required columns. The original multiset columns are replaced
comment|// by the new corresponding flattened columns
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|finnalCols
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|finnalColNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|flattenCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|flattenCols
operator|.
name|indexOf
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|// The original multiset columns to be flattened, select new flattened columns instead
name|RelDataType
name|componentType
init|=
name|inputFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numSubFields
init|=
name|componentType
operator|.
name|isStruct
argument_list|()
condition|?
name|componentType
operator|.
name|getFieldCount
argument_list|()
else|:
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numSubFields
condition|;
name|j
operator|++
control|)
block|{
name|finnalCols
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|colCount
operator|+
name|flattenCount
argument_list|)
argument_list|)
expr_stmt|;
name|finnalColNames
operator|.
name|add
argument_list|(
name|flattenOutputAliases
operator|.
name|get
argument_list|(
name|flattenCount
argument_list|)
argument_list|)
expr_stmt|;
name|flattenCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Otherwise, just copy the original column
name|finnalCols
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|finnalColNames
operator|.
name|add
argument_list|(
name|inputFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|project
argument_list|(
name|finnalCols
argument_list|,
name|finnalColNames
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Flattens the top relation will all multiset columns. Call this method only if    * the top relation contains multiset columns only.    *    * @return This builder.    */
specifier|public
name|RelBuilder
name|multiSetFlatten
parameter_list|()
block|{
comment|// [CALCITE-3193] Add RelBuilder.uncollect method, and interface
comment|// UncollectFactory, to instantiate Uncollect
name|Uncollect
name|uncollect
init|=
operator|new
name|Uncollect
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|Convention
operator|.
name|NONE
argument_list|)
argument_list|,
name|build
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|uncollect
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Makes the correlated expression from rel input fields and correlation id.    *    * @param inputFields Rel input field list    * @param correlId Correlation id    *    * @return This builder    */
specifier|public
name|RexNode
name|correl
parameter_list|(
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputFields
parameter_list|,
name|CorrelationId
name|correlId
parameter_list|)
block|{
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|fieldBuilder
init|=
name|PigTypes
operator|.
name|TYPE_FACTORY
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|inputFields
control|)
block|{
name|fieldBuilder
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeCorrel
argument_list|(
name|fieldBuilder
operator|.
name|uniquify
argument_list|()
operator|.
name|build
argument_list|()
argument_list|,
name|correlId
argument_list|)
return|;
block|}
comment|/**    * Collects all rows of the top rel into a single multiset value.    *    * @return This builder    */
specifier|public
name|RelBuilder
name|collect
parameter_list|()
block|{
specifier|final
name|RelNode
name|inputRel
init|=
name|peek
argument_list|()
decl_stmt|;
comment|// First project out a combined column which is a of all other columns
specifier|final
name|RexNode
name|row
init|=
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|inputRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|,
name|fields
argument_list|()
argument_list|)
decl_stmt|;
name|project
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|literal
argument_list|(
literal|"all"
argument_list|)
argument_list|,
name|row
argument_list|)
argument_list|)
expr_stmt|;
comment|// Update the alias map for the new projected rel.
name|updateAlias
argument_list|(
name|getPig
argument_list|(
name|inputRel
argument_list|)
argument_list|,
name|getAlias
argument_list|(
name|inputRel
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Build a single group for all rows
name|cogroup
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupKey
argument_list|(
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|of
argument_list|(
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Finally project out the final multiset value
name|project
argument_list|(
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|RexNode
name|dot
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|Object
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|instanceof
name|Integer
condition|)
block|{
name|int
name|fieldIndex
init|=
operator|(
name|Integer
operator|)
name|field
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|instanceof
name|DynamicTupleRecordType
condition|)
block|{
operator|(
operator|(
name|DynamicTupleRecordType
operator|)
name|type
operator|)
operator|.
name|resize
argument_list|(
name|fieldIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|dot
argument_list|(
name|node
argument_list|,
name|fieldIndex
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|dot
argument_list|(
name|node
argument_list|,
operator|(
name|String
operator|)
name|field
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|literal
parameter_list|(
name|Object
name|value
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Tuple
condition|)
block|{
assert|assert
name|type
operator|.
name|isStruct
argument_list|()
assert|;
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
operator|(
operator|(
name|Tuple
operator|)
name|value
operator|)
operator|.
name|getAll
argument_list|()
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|DataBag
condition|)
block|{
assert|assert
name|type
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
operator|&&
name|type
operator|.
name|getComponentType
argument_list|()
operator|.
name|isStruct
argument_list|()
assert|;
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|multisetObj
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Tuple
name|tuple
range|:
operator|(
name|DataBag
operator|)
name|value
control|)
block|{
name|multisetObj
operator|.
name|add
argument_list|(
name|tuple
operator|.
name|getAll
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
name|multisetObj
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Save the store alias with the corresponding relational algebra node    *    * @param storeAlias alias of the Pig store operator    * @return This builder    */
name|RelBuilder
name|store
parameter_list|(
name|String
name|storeAlias
parameter_list|)
block|{
name|storeMap
operator|.
name|put
argument_list|(
name|storeAlias
argument_list|,
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Gets all relational plans corresponding to Pig Store operators.    *    */
specifier|public
name|List
argument_list|<
name|RelNode
argument_list|>
name|getRelsForStores
parameter_list|()
block|{
if|if
condition|(
name|storeMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|storeMap
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|getFields
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|)
block|{
if|if
condition|(
name|fieldOrdinal
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|fields
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
return|;
block|}
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|fieldOrdinal
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Checks if two relational data types are compatible.    *    * @param t1 first type    * @param t2 second type    * @return true if t1 is compatible with t2    */
specifier|public
specifier|static
name|boolean
name|compatibleType
parameter_list|(
name|RelDataType
name|t1
parameter_list|,
name|RelDataType
name|t2
parameter_list|)
block|{
if|if
condition|(
name|t1
operator|.
name|isStruct
argument_list|()
operator|||
name|t2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|t1
operator|.
name|isStruct
argument_list|()
operator|||
operator|!
name|t2
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t1
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|t2
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields1
init|=
name|t1
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields2
init|=
name|t2
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields1
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|compatibleType
argument_list|(
name|fields1
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|fields2
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
name|RelDataType
name|comp1
init|=
name|t1
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|RelDataType
name|comp2
init|=
name|t2
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|comp1
operator|!=
literal|null
operator|)
operator|||
operator|(
name|comp2
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|comp1
operator|==
literal|null
operator|)
operator|||
operator|(
name|comp2
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|compatibleType
argument_list|(
name|comp1
argument_list|,
name|comp2
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|t1
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|t2
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
return|;
block|}
comment|/**    * Context constructed during Pig-to-{@link RelNode} translation process.    */
specifier|public
class|class
name|PigRelTranslationContext
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FuncSpec
argument_list|>
name|pigUdfs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
block|}
block|}
end_class

end_unit

