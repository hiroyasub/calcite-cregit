begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|test
package|;
end_package

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|avatica
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|expressions
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function1
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|clone
operator|.
name|CloneSchema
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|generate
operator|.
name|RangeTable
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|java
operator|.
name|AbstractQueryableTable
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|java
operator|.
name|JavaTypeFactory
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|java
operator|.
name|ReflectiveSchema
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|jdbc
operator|.
name|JdbcConvention
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|jdbc
operator|.
name|JdbcSchema
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|Driver
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|runtime
operator|.
name|SqlFunctions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelProtoDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|resource
operator|.
name|EigenbaseNewResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Bug
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hsqldb
operator|.
name|jdbcDriver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Tests for using Optiq via JDBC.  */
end_comment

begin_class
specifier|public
class|class
name|JdbcTest
block|{
specifier|public
specifier|static
specifier|final
name|Method
name|GENERATE_STRINGS_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|JdbcTest
operator|.
name|class
argument_list|,
literal|"generateStrings"
argument_list|,
name|Integer
operator|.
name|TYPE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|VIEW_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|JdbcTest
operator|.
name|class
argument_list|,
literal|"view"
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|STRING_UNION_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|JdbcTest
operator|.
name|class
argument_list|,
literal|"stringUnion"
argument_list|,
name|Queryable
operator|.
name|class
argument_list|,
name|Queryable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FOODMART_SCHEMA
init|=
literal|"     {\n"
operator|+
literal|"       type: 'jdbc',\n"
operator|+
literal|"       name: 'foodmart',\n"
operator|+
literal|"       jdbcDriver: '"
operator|+
name|OptiqAssert
operator|.
name|CONNECTION_SPEC
operator|.
name|driver
operator|+
literal|"',\n"
operator|+
literal|"       jdbcUser: '"
operator|+
name|OptiqAssert
operator|.
name|CONNECTION_SPEC
operator|.
name|username
operator|+
literal|"',\n"
operator|+
literal|"       jdbcPassword: '"
operator|+
name|OptiqAssert
operator|.
name|CONNECTION_SPEC
operator|.
name|password
operator|+
literal|"',\n"
operator|+
literal|"       jdbcUrl: '"
operator|+
name|OptiqAssert
operator|.
name|CONNECTION_SPEC
operator|.
name|url
operator|+
literal|"',\n"
operator|+
literal|"       jdbcCatalog: null,\n"
operator|+
literal|"       jdbcSchema: 'foodmart'\n"
operator|+
literal|"     }\n"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FOODMART_MODEL
init|=
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"  defaultSchema: 'foodmart',\n"
operator|+
literal|"   schemas: [\n"
operator|+
name|FOODMART_SCHEMA
operator|+
literal|"   ]\n"
operator|+
literal|"}"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|HR_SCHEMA
init|=
literal|"     {\n"
operator|+
literal|"       type: 'custom',\n"
operator|+
literal|"       name: 'hr',\n"
operator|+
literal|"       factory: '"
operator|+
name|ReflectiveSchema
operator|.
name|Factory
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"       operand: {\n"
operator|+
literal|"         class: '"
operator|+
name|HrSchema
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"'\n"
operator|+
literal|"       }\n"
operator|+
literal|"     }\n"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|HR_MODEL
init|=
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"  defaultSchema: 'hr',\n"
operator|+
literal|"   schemas: [\n"
operator|+
name|HR_SCHEMA
operator|+
literal|"   ]\n"
operator|+
literal|"}"
decl_stmt|;
specifier|public
specifier|static
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|getFoodmartQueries
parameter_list|()
block|{
return|return
name|FOODMART_QUERIES
return|;
block|}
comment|/**    * Tests a relation that is accessed via method syntax.    *    *<p>The function ({@link #generateStrings(int)} has a return type    * {@link Table} and the actual returned value implements    * {@link net.hydromatic.optiq.QueryableTable} but not    * {@link net.hydromatic.optiq.TranslatableTable}.    */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testTableFunction
parameter_list|()
throws|throws
name|SQLException
throws|,
name|ClassNotFoundException
block|{
name|Class
operator|.
name|forName
argument_list|(
literal|"net.hydromatic.optiq.jdbc.Driver"
argument_list|)
expr_stmt|;
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:optiq:"
argument_list|)
decl_stmt|;
name|OptiqConnection
name|optiqConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|OptiqConnection
operator|.
name|class
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|optiqConnection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|SchemaPlus
name|schema
init|=
name|rootSchema
operator|.
name|add
argument_list|(
literal|"s"
argument_list|,
operator|new
name|AbstractSchema
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|TableMacro
name|tableMacro
init|=
name|TableMacroImpl
operator|.
name|create
argument_list|(
name|GENERATE_STRINGS_METHOD
argument_list|)
decl_stmt|;
name|schema
operator|.
name|add
argument_list|(
literal|"GenerateStrings"
argument_list|,
name|tableMacro
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|connection
operator|.
name|createStatement
argument_list|()
operator|.
name|executeQuery
argument_list|(
literal|"select *\n"
operator|+
literal|"from table(\"s\".\"GenerateStrings\"(5)) as t(n, c)\n"
operator|+
literal|"where char_length(c)> 3"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a relation that is accessed via method syntax.    *    *<p>The function ({@link #view(String)} has a return type    * {@link Table} and the actual returned value implements    * {@link net.hydromatic.optiq.TranslatableTable}.    */
annotation|@
name|Test
specifier|public
name|void
name|testTableMacro
parameter_list|()
throws|throws
name|SQLException
throws|,
name|ClassNotFoundException
block|{
name|Class
operator|.
name|forName
argument_list|(
literal|"net.hydromatic.optiq.jdbc.Driver"
argument_list|)
expr_stmt|;
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:optiq:"
argument_list|)
decl_stmt|;
name|OptiqConnection
name|optiqConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|OptiqConnection
operator|.
name|class
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|optiqConnection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|SchemaPlus
name|schema
init|=
name|rootSchema
operator|.
name|add
argument_list|(
literal|"s"
argument_list|,
operator|new
name|AbstractSchema
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|TableMacro
name|tableMacro
init|=
name|TableMacroImpl
operator|.
name|create
argument_list|(
name|VIEW_METHOD
argument_list|)
decl_stmt|;
name|schema
operator|.
name|add
argument_list|(
literal|"View"
argument_list|,
name|tableMacro
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|connection
operator|.
name|createStatement
argument_list|()
operator|.
name|executeQuery
argument_list|(
literal|"select *\n"
operator|+
literal|"from table(\"s\".\"View\"('(10), (20)')) as t(n)\n"
operator|+
literal|"where n< 15"
argument_list|)
decl_stmt|;
comment|// The call to "View('(10), (2)')" expands to 'values (1), (3), (10), (20)'.
name|assertThat
argument_list|(
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|resultSet
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"N=1\n"
operator|+
literal|"N=3\n"
operator|+
literal|"N=10\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a JDBC connection that provides a model that contains a table    *  macro. */
annotation|@
name|Test
specifier|public
name|void
name|testTableMacroInModel
parameter_list|()
throws|throws
name|Exception
block|{
name|checkTableMacroInModel
argument_list|(
name|TableMacroFunction
operator|.
name|class
argument_list|)
expr_stmt|;
name|checkTableMacroInModel
argument_list|(
name|StaticTableMacroFunction
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkTableMacroInModel
parameter_list|(
name|Class
name|clazz
parameter_list|)
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc',\n"
operator|+
literal|"       functions: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'View',\n"
operator|+
literal|"           className: '"
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"'\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from table(\"adhoc\".\"View\"('(30)'))"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"c=1\n"
operator|+
literal|"c=3\n"
operator|+
literal|"c=30\n"
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Queryable
argument_list|<
name|T
argument_list|>
name|stringUnion
parameter_list|(
name|Queryable
argument_list|<
name|T
argument_list|>
name|q0
parameter_list|,
name|Queryable
argument_list|<
name|T
argument_list|>
name|q1
parameter_list|)
block|{
return|return
name|q0
operator|.
name|concat
argument_list|(
name|q1
argument_list|)
return|;
block|}
comment|/** A function that generates a table that generates a sequence of    * {@link net.hydromatic.optiq.test.JdbcTest.IntString} values. */
specifier|public
specifier|static
name|Table
name|generateStrings
parameter_list|(
specifier|final
name|int
name|count
parameter_list|)
block|{
return|return
operator|new
name|AbstractQueryableTable
argument_list|(
name|IntString
operator|.
name|class
argument_list|)
block|{
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"n"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"s"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Queryable
argument_list|<
name|T
argument_list|>
name|asQueryable
parameter_list|(
name|QueryProvider
name|queryProvider
parameter_list|,
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
name|BaseQueryable
argument_list|<
name|IntString
argument_list|>
name|queryable
init|=
operator|new
name|BaseQueryable
argument_list|<
name|IntString
argument_list|>
argument_list|(
literal|null
argument_list|,
name|IntString
operator|.
name|class
argument_list|,
literal|null
argument_list|)
block|{
specifier|public
name|Enumerator
argument_list|<
name|IntString
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|IntString
argument_list|>
argument_list|()
block|{
specifier|static
specifier|final
name|String
name|Z
init|=
literal|"abcdefghijklm"
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|IntString
name|o
decl_stmt|;
specifier|public
name|IntString
name|current
parameter_list|()
block|{
return|return
name|o
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
if|if
condition|(
name|i
operator|<
name|count
operator|-
literal|1
condition|)
block|{
name|o
operator|=
operator|new
name|IntString
argument_list|(
name|i
argument_list|,
name|Z
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
operator|%
name|Z
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
block|}
return|;
block|}
block|}
decl_stmt|;
comment|//noinspection unchecked
return|return
operator|(
name|Queryable
argument_list|<
name|T
argument_list|>
operator|)
name|queryable
return|;
block|}
block|}
return|;
block|}
comment|/** Tests {@link net.hydromatic.avatica.Handler#onConnectionClose}    * and  {@link net.hydromatic.avatica.Handler#onStatementClose}. */
annotation|@
name|Test
specifier|public
name|void
name|testOnConnectionClose
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|int
index|[]
name|closeCount
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|final
name|int
index|[]
name|statementCloseCount
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HandlerDriver
operator|.
name|HANDLERS
operator|.
name|set
argument_list|(
operator|new
name|HandlerImpl
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onConnectionClose
parameter_list|(
name|AvaticaConnection
name|connection
parameter_list|)
block|{
operator|++
name|closeCount
index|[
literal|0
index|]
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onStatementClose
parameter_list|(
name|AvaticaStatement
name|statement
parameter_list|)
block|{
operator|++
name|statementCloseCount
index|[
literal|0
index|]
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
specifier|final
name|HandlerDriver
name|driver
init|=
operator|new
name|HandlerDriver
argument_list|()
decl_stmt|;
name|OptiqConnection
name|connection
init|=
operator|(
name|OptiqConnection
operator|)
name|driver
operator|.
name|connect
argument_list|(
literal|"jdbc:optiq:"
argument_list|,
operator|new
name|Properties
argument_list|()
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|connection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setSchema
argument_list|(
literal|"hr"
argument_list|)
expr_stmt|;
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|closeCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|statementCloseCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|closeCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|statementCloseCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Close statement. It throws SQLException, but statement is still closed.
try|try
block|{
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"expecting error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|closeCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|statementCloseCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Close connection. It throws SQLException, but connection is still closed.
try|try
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"expecting error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|closeCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|statementCloseCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Close a closed connection. Handler is not called again.
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|closeCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|statementCloseCount
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|HandlerDriver
operator|.
name|HANDLERS
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link java.sql.Statement}.{@code closeOnCompletion()}. */
annotation|@
name|Test
specifier|public
name|void
name|testStatementCloseOnCompletion
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|javaVersion
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.version"
argument_list|)
decl_stmt|;
if|if
condition|(
name|javaVersion
operator|.
name|compareTo
argument_list|(
literal|"1.7"
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Statement.closeOnCompletion was introduced in JDK 1.7.
return|return;
block|}
specifier|final
name|Driver
name|driver
init|=
operator|new
name|Driver
argument_list|()
decl_stmt|;
name|OptiqConnection
name|connection
init|=
operator|(
name|OptiqConnection
operator|)
name|driver
operator|.
name|connect
argument_list|(
literal|"jdbc:optiq:"
argument_list|,
operator|new
name|Properties
argument_list|()
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|connection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setSchema
argument_list|(
literal|"hr"
argument_list|)
expr_stmt|;
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
operator|(
name|Boolean
operator|)
name|OptiqAssert
operator|.
name|call
argument_list|(
name|statement
argument_list|,
literal|"isCloseOnCompletion"
argument_list|)
argument_list|)
expr_stmt|;
name|OptiqAssert
operator|.
name|call
argument_list|(
name|statement
argument_list|,
literal|"closeOnCompletion"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|(
name|Boolean
operator|)
name|OptiqAssert
operator|.
name|call
argument_list|(
name|statement
argument_list|,
literal|"isCloseOnCompletion"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|statement
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
comment|// when result set is closed, statement is closed automatically
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|statement
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|statement
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * The example in the README.    */
annotation|@
name|Test
specifier|public
name|void
name|testReadme
parameter_list|()
throws|throws
name|ClassNotFoundException
throws|,
name|SQLException
block|{
name|Class
operator|.
name|forName
argument_list|(
literal|"net.hydromatic.optiq.jdbc.Driver"
argument_list|)
expr_stmt|;
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:optiq:"
argument_list|)
decl_stmt|;
name|OptiqConnection
name|optiqConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|OptiqConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|optiqConnection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Statement
name|statement
init|=
name|optiqConnection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select d.\"deptno\", min(e.\"empid\")\n"
operator|+
literal|"from \"hr\".\"emps\" as e\n"
operator|+
literal|"join \"hr\".\"depts\" as d\n"
operator|+
literal|"  on e.\"deptno\" = d.\"deptno\"\n"
operator|+
literal|"group by d.\"deptno\"\n"
operator|+
literal|"having count(*)> 1"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|s
init|=
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|resultSet
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|s
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Test for {@link Driver#getPropertyInfo(String, Properties)}. */
annotation|@
name|Test
specifier|public
name|void
name|testConnectionProperties
parameter_list|()
throws|throws
name|ClassNotFoundException
throws|,
name|SQLException
block|{
name|Class
operator|.
name|forName
argument_list|(
literal|"net.hydromatic.optiq.jdbc.Driver"
argument_list|)
expr_stmt|;
name|java
operator|.
name|sql
operator|.
name|Driver
name|driver
init|=
name|DriverManager
operator|.
name|getDriver
argument_list|(
literal|"jdbc:optiq:"
argument_list|)
decl_stmt|;
specifier|final
name|DriverPropertyInfo
index|[]
name|propertyInfo
init|=
name|driver
operator|.
name|getPropertyInfo
argument_list|(
literal|"jdbc:optiq:"
argument_list|,
operator|new
name|Properties
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|HashSet
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|DriverPropertyInfo
name|info
range|:
name|propertyInfo
control|)
block|{
name|names
operator|.
name|add
argument_list|(
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|names
operator|.
name|contains
argument_list|(
literal|"SCHEMA"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|names
operator|.
name|contains
argument_list|(
literal|"TIMEZONE"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|names
operator|.
name|contains
argument_list|(
literal|"MATERIALIZATIONS_ENABLED"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make sure that the properties look sane.    */
annotation|@
name|Test
specifier|public
name|void
name|testVersion
parameter_list|()
throws|throws
name|ClassNotFoundException
throws|,
name|SQLException
block|{
name|Class
operator|.
name|forName
argument_list|(
literal|"net.hydromatic.optiq.jdbc.Driver"
argument_list|)
expr_stmt|;
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:optiq:"
argument_list|)
decl_stmt|;
name|OptiqConnection
name|optiqConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|OptiqConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|DatabaseMetaData
name|metaData
init|=
name|optiqConnection
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Optiq JDBC Driver"
argument_list|,
name|metaData
operator|.
name|getDriverName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|String
name|driverVersion
init|=
name|metaData
operator|.
name|getDriverVersion
argument_list|()
decl_stmt|;
specifier|final
name|int
name|driverMajorVersion
init|=
name|metaData
operator|.
name|getDriverMajorVersion
argument_list|()
decl_stmt|;
specifier|final
name|int
name|driverMinorVersion
init|=
name|metaData
operator|.
name|getDriverMinorVersion
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|driverMajorVersion
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|driverMinorVersion
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Optiq"
argument_list|,
name|metaData
operator|.
name|getDatabaseProductName
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|String
name|databaseProductVersion
init|=
name|metaData
operator|.
name|getDatabaseProductVersion
argument_list|()
decl_stmt|;
specifier|final
name|int
name|databaseMajorVersion
init|=
name|metaData
operator|.
name|getDatabaseMajorVersion
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|driverMajorVersion
argument_list|,
name|databaseMajorVersion
argument_list|)
expr_stmt|;
specifier|final
name|int
name|databaseMinorVersion
init|=
name|metaData
operator|.
name|getDatabaseMinorVersion
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|driverMinorVersion
argument_list|,
name|databaseMinorVersion
argument_list|)
expr_stmt|;
comment|// Check how version is composed of major and minor version. Note that
comment|// version is stored in pom.xml; major and minor version are
comment|// stored in net-hydromatic-optiq-jdbc.properties.
if|if
condition|(
operator|!
name|driverVersion
operator|.
name|endsWith
argument_list|(
literal|"-SNAPSHOT"
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
name|driverVersion
operator|.
name|startsWith
argument_list|(
literal|"0."
argument_list|)
argument_list|)
expr_stmt|;
name|String
index|[]
name|split
init|=
name|driverVersion
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|split
operator|.
name|length
operator|>=
literal|2
argument_list|)
expr_stmt|;
specifier|final
name|String
name|majorMinor
init|=
name|driverMajorVersion
operator|+
literal|"."
operator|+
name|driverMinorVersion
decl_stmt|;
name|assertTrue
argument_list|(
name|driverVersion
operator|.
name|equals
argument_list|(
name|majorMinor
argument_list|)
operator|||
name|driverVersion
operator|.
name|startsWith
argument_list|(
name|majorMinor
operator|+
literal|"."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|databaseProductVersion
operator|.
name|endsWith
argument_list|(
literal|"-SNAPSHOT"
argument_list|)
condition|)
block|{
name|assertTrue
argument_list|(
name|databaseProductVersion
operator|.
name|startsWith
argument_list|(
literal|"0."
argument_list|)
argument_list|)
expr_stmt|;
name|String
index|[]
name|split
init|=
name|databaseProductVersion
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|split
operator|.
name|length
operator|>=
literal|2
argument_list|)
expr_stmt|;
specifier|final
name|String
name|majorMinor
init|=
name|databaseMajorVersion
operator|+
literal|"."
operator|+
name|databaseMinorVersion
decl_stmt|;
name|assertTrue
argument_list|(
name|databaseProductVersion
operator|.
name|equals
argument_list|(
name|majorMinor
argument_list|)
operator|||
name|databaseProductVersion
operator|.
name|startsWith
argument_list|(
name|majorMinor
operator|+
literal|"."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Tests driver's implementation of {@link DatabaseMetaData#getColumns}. */
annotation|@
name|Test
specifier|public
name|void
name|testMetaDataColumns
parameter_list|()
throws|throws
name|ClassNotFoundException
throws|,
name|SQLException
block|{
name|Connection
name|connection
init|=
name|OptiqAssert
operator|.
name|getConnection
argument_list|(
literal|"hr"
argument_list|,
literal|"foodmart"
argument_list|)
decl_stmt|;
name|DatabaseMetaData
name|metaData
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|metaData
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
comment|// there's something
name|String
name|name
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|resultSet
operator|.
name|getInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|String
name|typeName
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|int
name|columnSize
init|=
name|resultSet
operator|.
name|getInt
argument_list|(
literal|7
argument_list|)
decl_stmt|;
name|int
name|decimalDigits
init|=
name|resultSet
operator|.
name|getInt
argument_list|(
literal|9
argument_list|)
decl_stmt|;
name|int
name|numPrecRadix
init|=
name|resultSet
operator|.
name|getInt
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|charOctetLength
init|=
name|resultSet
operator|.
name|getInt
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|String
name|isNullable
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|18
argument_list|)
decl_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Tests driver's implementation of {@link DatabaseMetaData#getPrimaryKeys}.    * It is empty but it should still have column definitions. */
annotation|@
name|Test
specifier|public
name|void
name|testMetaDataPrimaryKeys
parameter_list|()
throws|throws
name|ClassNotFoundException
throws|,
name|SQLException
block|{
name|Connection
name|connection
init|=
name|OptiqAssert
operator|.
name|getConnection
argument_list|(
literal|"hr"
argument_list|,
literal|"foodmart"
argument_list|)
decl_stmt|;
name|DatabaseMetaData
name|metaData
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|metaData
operator|.
name|getPrimaryKeys
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
comment|// catalog never contains primary keys
name|ResultSetMetaData
name|resultSetMetaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|resultSetMetaData
operator|.
name|getColumnCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"TABLE_CAT"
argument_list|,
name|resultSetMetaData
operator|.
name|getColumnName
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|VARCHAR
argument_list|,
name|resultSetMetaData
operator|.
name|getColumnType
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"PK_NAME"
argument_list|,
name|resultSetMetaData
operator|.
name|getColumnName
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Unit test for    * {@link net.hydromatic.optiq.jdbc.MetaImpl#likeToRegex(net.hydromatic.avatica.Meta.Pat)}. */
annotation|@
name|Test
specifier|public
name|void
name|testLikeToRegex
parameter_list|()
block|{
name|checkLikeToRegex
argument_list|(
literal|true
argument_list|,
literal|"%"
argument_list|,
literal|"abc"
argument_list|)
expr_stmt|;
name|checkLikeToRegex
argument_list|(
literal|true
argument_list|,
literal|"abc"
argument_list|,
literal|"abc"
argument_list|)
expr_stmt|;
name|checkLikeToRegex
argument_list|(
literal|false
argument_list|,
literal|"abc"
argument_list|,
literal|"abcd"
argument_list|)
expr_stmt|;
comment|// trailing char fails match
name|checkLikeToRegex
argument_list|(
literal|false
argument_list|,
literal|"abc"
argument_list|,
literal|"0abc"
argument_list|)
expr_stmt|;
comment|// leading char fails match
name|checkLikeToRegex
argument_list|(
literal|false
argument_list|,
literal|"abc"
argument_list|,
literal|"aBc"
argument_list|)
expr_stmt|;
comment|// case-sensitive match
name|checkLikeToRegex
argument_list|(
literal|true
argument_list|,
literal|"a[b]c"
argument_list|,
literal|"a[b]c"
argument_list|)
expr_stmt|;
comment|// nothing special about brackets
name|checkLikeToRegex
argument_list|(
literal|true
argument_list|,
literal|"a$c"
argument_list|,
literal|"a$c"
argument_list|)
expr_stmt|;
comment|// nothing special about dollar
name|checkLikeToRegex
argument_list|(
literal|false
argument_list|,
literal|"a$"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
comment|// nothing special about dollar
name|checkLikeToRegex
argument_list|(
literal|true
argument_list|,
literal|"a%c"
argument_list|,
literal|"ac"
argument_list|)
expr_stmt|;
name|checkLikeToRegex
argument_list|(
literal|true
argument_list|,
literal|"a%c"
argument_list|,
literal|"abbbc"
argument_list|)
expr_stmt|;
name|checkLikeToRegex
argument_list|(
literal|false
argument_list|,
literal|"a%c"
argument_list|,
literal|"acccd"
argument_list|)
expr_stmt|;
comment|// escape using back-slash
name|checkLikeToRegex
argument_list|(
literal|true
argument_list|,
literal|"a\\%c"
argument_list|,
literal|"a%c"
argument_list|)
expr_stmt|;
name|checkLikeToRegex
argument_list|(
literal|false
argument_list|,
literal|"a\\%c"
argument_list|,
literal|"abc"
argument_list|)
expr_stmt|;
name|checkLikeToRegex
argument_list|(
literal|false
argument_list|,
literal|"a\\%c"
argument_list|,
literal|"a\\%c"
argument_list|)
expr_stmt|;
comment|// multiple wild-cards
name|checkLikeToRegex
argument_list|(
literal|true
argument_list|,
literal|"a%c%d"
argument_list|,
literal|"abcdaaad"
argument_list|)
expr_stmt|;
name|checkLikeToRegex
argument_list|(
literal|false
argument_list|,
literal|"a%c%d"
argument_list|,
literal|"abcdc"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkLikeToRegex
parameter_list|(
name|boolean
name|b
parameter_list|,
name|String
name|pattern
parameter_list|,
name|String
name|abc
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|b
operator|==
name|MetaImpl
operator|.
name|likeToRegex
argument_list|(
name|Meta
operator|.
name|Pat
operator|.
name|of
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|.
name|matcher
argument_list|(
name|abc
argument_list|)
operator|.
name|matches
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Tests driver's implementation of {@link DatabaseMetaData#getColumns}. */
annotation|@
name|Test
specifier|public
name|void
name|testResultSetMetaData
parameter_list|()
throws|throws
name|ClassNotFoundException
throws|,
name|SQLException
block|{
name|Connection
name|connection
init|=
name|OptiqAssert
operator|.
name|getConnection
argument_list|(
literal|"hr"
argument_list|,
literal|"foodmart"
argument_list|)
decl_stmt|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select \"empid\", \"deptno\" as x, 1 as y\n"
operator|+
literal|"from \"hr\".\"emps\""
argument_list|)
decl_stmt|;
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|metaData
operator|.
name|getColumnCount
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"empid"
argument_list|,
name|metaData
operator|.
name|getColumnLabel
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"empid"
argument_list|,
name|metaData
operator|.
name|getColumnName
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"emps"
argument_list|,
name|metaData
operator|.
name|getTableName
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"X"
argument_list|,
name|metaData
operator|.
name|getColumnLabel
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"deptno"
argument_list|,
name|metaData
operator|.
name|getColumnName
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"emps"
argument_list|,
name|metaData
operator|.
name|getTableName
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Y"
argument_list|,
name|metaData
operator|.
name|getColumnLabel
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Y"
argument_list|,
name|metaData
operator|.
name|getColumnName
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|null
argument_list|,
name|metaData
operator|.
name|getTableName
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Tests some queries that have expedited processing because connection pools    * like to use them to check whether the connection is alive.    */
annotation|@
name|Test
specifier|public
name|void
name|testSimple
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"SELECT 1"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EXPR$0=1\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests accessing columns by name. */
annotation|@
name|Test
specifier|public
name|void
name|testGetByName
parameter_list|()
throws|throws
name|Exception
block|{
comment|// JDBC 3.0 specification: "Column names supplied to getter methods are case
comment|// insensitive. If a select list contains the same column more than once,
comment|// the first instance of the column will be returned."
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|OptiqConnection
name|c
parameter_list|)
block|{
try|try
block|{
name|Statement
name|s
init|=
name|c
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
name|s
operator|.
name|executeQuery
argument_list|(
literal|"SELECT 1 as \"a\", 2 as \"b\", 3 as \"a\", 4 as \"B\"\n"
operator|+
literal|"FROM (VALUES (0))"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"A"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|"B"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|int
name|x
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|"z"
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|x
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// ok
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rs
operator|.
name|findColumn
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rs
operator|.
name|findColumn
argument_list|(
literal|"A"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rs
operator|.
name|findColumn
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rs
operator|.
name|findColumn
argument_list|(
literal|"B"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|int
name|x
init|=
name|rs
operator|.
name|findColumn
argument_list|(
literal|"z"
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|x
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"column 'z' not found"
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|int
name|x
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|x
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"invalid column ordinal: 0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|int
name|x
init|=
name|rs
operator|.
name|getInt
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|x
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"invalid column ordinal: 5"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCloneSchema
parameter_list|()
throws|throws
name|ClassNotFoundException
throws|,
name|SQLException
block|{
specifier|final
name|OptiqConnection
name|connection
init|=
name|OptiqAssert
operator|.
name|getConnection
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|connection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
specifier|final
name|SchemaPlus
name|foodmart
init|=
name|rootSchema
operator|.
name|getSubSchema
argument_list|(
literal|"foodmart"
argument_list|)
decl_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"foodmart2"
argument_list|,
operator|new
name|CloneSchema
argument_list|(
name|foodmart
argument_list|)
argument_list|)
expr_stmt|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select count(*) from \"foodmart2\".\"time_by_day\""
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|730
argument_list|,
name|resultSet
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCloneGroupBy
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"the_year\", count(*) as c, min(\"the_month\") as m\n"
operator|+
literal|"from \"foodmart2\".\"time_by_day\"\n"
operator|+
literal|"group by \"the_year\"\n"
operator|+
literal|"order by 1, 2"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"the_year=1997; C=365; M=April\n"
operator|+
literal|"the_year=1998; C=365; M=April\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testCloneGroupBy2
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"time_by_day\".\"the_year\" as \"c0\", \"time_by_day\".\"quarter\" as \"c1\", \"product_class\".\"product_family\" as \"c2\", sum(\"sales_fact_1997\".\"unit_sales\") as \"m0\" from \"time_by_day\" as \"time_by_day\", \"sales_fact_1997\" as \"sales_fact_1997\", \"product_class\" as \"product_class\", \"product\" as \"product\" where \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\" and \"time_by_day\".\"the_year\" = 1997 and \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\" and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\" group by \"time_by_day\".\"the_year\", \"time_by_day\".\"quarter\", \"product_class\".\"product_family\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"c0=1997; c1=Q2; c2=Drink; m0=5895.0000\n"
operator|+
literal|"c0=1997; c1=Q1; c2=Food; m0=47809.0000\n"
operator|+
literal|"c0=1997; c1=Q3; c2=Drink; m0=6065.0000\n"
operator|+
literal|"c0=1997; c1=Q4; c2=Drink; m0=6661.0000\n"
operator|+
literal|"c0=1997; c1=Q4; c2=Food; m0=51866.0000\n"
operator|+
literal|"c0=1997; c1=Q1; c2=Drink; m0=5976.0000\n"
operator|+
literal|"c0=1997; c1=Q3; c2=Non-Consumable; m0=12343.0000\n"
operator|+
literal|"c0=1997; c1=Q4; c2=Non-Consumable; m0=13497.0000\n"
operator|+
literal|"c0=1997; c1=Q2; c2=Non-Consumable; m0=11890.0000\n"
operator|+
literal|"c0=1997; c1=Q2; c2=Food; m0=44825.0000\n"
operator|+
literal|"c0=1997; c1=Q3; c2=Food; m0=47440.0000\n"
operator|+
literal|"c0=1997; c1=Q1; c2=Non-Consumable; m0=12506.0000\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests plan for a query with 4 tables, 3 joins. */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testCloneGroupBy2Plan
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"explain plan for select \"time_by_day\".\"the_year\" as \"c0\", \"time_by_day\".\"quarter\" as \"c1\", \"product_class\".\"product_family\" as \"c2\", sum(\"sales_fact_1997\".\"unit_sales\") as \"m0\" from \"time_by_day\" as \"time_by_day\", \"sales_fact_1997\" as \"sales_fact_1997\", \"product_class\" as \"product_class\", \"product\" as \"product\" where \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\" and \"time_by_day\".\"the_year\" = 1997 and \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\" and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\" group by \"time_by_day\".\"the_year\", \"time_by_day\".\"quarter\", \"product_class\".\"product_family\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"PLAN=EnumerableAggregateRel(group=[{0, 1, 2}], m0=[SUM($3)])\n"
operator|+
literal|"  EnumerableCalcRel(expr#0..37=[{inputs}], c0=[$t9], c1=[$t13], c2=[$t4], unit_sales=[$t22])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($23, $0)], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[foodmart2, product_class]])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($10, $19)], joinType=[inner])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($11, $0)], joinType=[inner])\n"
operator|+
literal|"          EnumerableCalcRel(expr#0..9=[{inputs}], expr#10=[CAST($t4):INTEGER], expr#11=[1997], expr#12=[=($t10, $t11)], proj#0..9=[{exprs}], $condition=[$t12])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, time_by_day]])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, product]])\n"
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrderByCase
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"time_by_day\".\"the_year\" as \"c0\" from \"time_by_day\" as \"time_by_day\" group by \"time_by_day\".\"the_year\" order by CASE WHEN \"time_by_day\".\"the_year\" IS NULL THEN 1 ELSE 0 END, \"time_by_day\".\"the_year\" ASC"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"c0=1997\n"
operator|+
literal|"c0=1998\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|QUERIES
init|=
block|{
literal|"select count(*) from (select 1 as \"c0\" from \"salary\" as \"salary\") as \"init\""
block|,
literal|"EXPR$0=21252\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"salary\" as \"salary2\") as \"init\""
block|,
literal|"EXPR$0=21252\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"department\" as \"department\") as \"init\""
block|,
literal|"EXPR$0=12\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"employee\" as \"employee\") as \"init\""
block|,
literal|"EXPR$0=1155\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"employee_closure\" as \"employee_closure\") as \"init\""
block|,
literal|"EXPR$0=7179\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"position\" as \"position\") as \"init\""
block|,
literal|"EXPR$0=18\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"promotion\" as \"promotion\") as \"init\""
block|,
literal|"EXPR$0=1864\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"store\" as \"store\") as \"init\""
block|,
literal|"EXPR$0=25\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"product\" as \"product\") as \"init\""
block|,
literal|"EXPR$0=1560\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"product_class\" as \"product_class\") as \"init\""
block|,
literal|"EXPR$0=110\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"time_by_day\" as \"time_by_day\") as \"init\""
block|,
literal|"EXPR$0=730\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"customer\" as \"customer\") as \"init\""
block|,
literal|"EXPR$0=10281\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"sales_fact_1997\" as \"sales_fact_1997\") as \"init\""
block|,
literal|"EXPR$0=86837\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"inventory_fact_1997\" as \"inventory_fact_1997\") as \"init\""
block|,
literal|"EXPR$0=4070\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"warehouse\" as \"warehouse\") as \"init\""
block|,
literal|"EXPR$0=24\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"agg_c_special_sales_fact_1997\" as \"agg_c_special_sales_fact_1997\") as \"init\""
block|,
literal|"EXPR$0=86805\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"agg_pl_01_sales_fact_1997\" as \"agg_pl_01_sales_fact_1997\") as \"init\""
block|,
literal|"EXPR$0=86829\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"agg_l_05_sales_fact_1997\" as \"agg_l_05_sales_fact_1997\") as \"init\""
block|,
literal|"EXPR$0=86154\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"agg_g_ms_pcat_sales_fact_1997\" as \"agg_g_ms_pcat_sales_fact_1997\") as \"init\""
block|,
literal|"EXPR$0=2637\n"
block|,
literal|"select count(*) from (select 1 as \"c0\" from \"agg_c_14_sales_fact_1997\" as \"agg_c_14_sales_fact_1997\") as \"init\""
block|,
literal|"EXPR$0=86805\n"
block|,
literal|"select \"time_by_day\".\"the_year\" as \"c0\" from \"time_by_day\" as \"time_by_day\" group by \"time_by_day\".\"the_year\" order by \"time_by_day\".\"the_year\" ASC"
block|,
literal|"c0=1997\n"
operator|+
literal|"c0=1998\n"
block|,
literal|"select \"store\".\"store_country\" as \"c0\" from \"store\" as \"store\" where UPPER(\"store\".\"store_country\") = UPPER('USA') group by \"store\".\"store_country\" order by \"store\".\"store_country\" ASC"
block|,
literal|"c0=USA\n"
block|,
literal|"select \"store\".\"store_state\" as \"c0\" from \"store\" as \"store\" where (\"store\".\"store_country\" = 'USA') and UPPER(\"store\".\"store_state\") = UPPER('CA') group by \"store\".\"store_state\" order by \"store\".\"store_state\" ASC"
block|,
literal|"c0=CA\n"
block|,
literal|"select \"store\".\"store_city\" as \"c0\", \"store\".\"store_state\" as \"c1\" from \"store\" as \"store\" where (\"store\".\"store_state\" = 'CA' and \"store\".\"store_country\" = 'USA') and UPPER(\"store\".\"store_city\") = UPPER('Los Angeles') group by \"store\".\"store_city\", \"store\".\"store_state\" order by \"store\".\"store_city\" ASC"
block|,
literal|"c0=Los Angeles; c1=CA\n"
block|,
literal|"select \"customer\".\"country\" as \"c0\" from \"customer\" as \"customer\" where UPPER(\"customer\".\"country\") = UPPER('USA') group by \"customer\".\"country\" order by \"customer\".\"country\" ASC"
block|,
literal|"c0=USA\n"
block|,
literal|"select \"customer\".\"state_province\" as \"c0\", \"customer\".\"country\" as \"c1\" from \"customer\" as \"customer\" where (\"customer\".\"country\" = 'USA') and UPPER(\"customer\".\"state_province\") = UPPER('CA') group by \"customer\".\"state_province\", \"customer\".\"country\" order by \"customer\".\"state_province\" ASC"
block|,
literal|"c0=CA; c1=USA\n"
block|,
literal|"select \"customer\".\"city\" as \"c0\", \"customer\".\"country\" as \"c1\", \"customer\".\"state_province\" as \"c2\" from \"customer\" as \"customer\" where (\"customer\".\"country\" = 'USA' and \"customer\".\"state_province\" = 'CA' and \"customer\".\"country\" = 'USA' and \"customer\".\"state_province\" = 'CA' and \"customer\".\"country\" = 'USA') and UPPER(\"customer\".\"city\") = UPPER('Los Angeles') group by \"customer\".\"city\", \"customer\".\"country\", \"customer\".\"state_province\" order by \"customer\".\"city\" ASC"
block|,
literal|"c0=Los Angeles; c1=USA; c2=CA\n"
block|,
literal|"select \"store\".\"store_country\" as \"c0\" from \"store\" as \"store\" where UPPER(\"store\".\"store_country\") = UPPER('Gender') group by \"store\".\"store_country\" order by \"store\".\"store_country\" ASC"
block|,
literal|""
block|,
literal|"select \"store\".\"store_type\" as \"c0\" from \"store\" as \"store\" where UPPER(\"store\".\"store_type\") = UPPER('Gender') group by \"store\".\"store_type\" order by \"store\".\"store_type\" ASC"
block|,
literal|""
block|,
literal|"select \"product_class\".\"product_family\" as \"c0\" from \"product\" as \"product\", \"product_class\" as \"product_class\" where \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\" and UPPER(\"product_class\".\"product_family\") = UPPER('Gender') group by \"product_class\".\"product_family\" order by \"product_class\".\"product_family\" ASC"
block|,
literal|""
block|,
literal|"select \"promotion\".\"media_type\" as \"c0\" from \"promotion\" as \"promotion\" where UPPER(\"promotion\".\"media_type\") = UPPER('Gender') group by \"promotion\".\"media_type\" order by \"promotion\".\"media_type\" ASC"
block|,
literal|""
block|,
literal|"select \"promotion\".\"promotion_name\" as \"c0\" from \"promotion\" as \"promotion\" where UPPER(\"promotion\".\"promotion_name\") = UPPER('Gender') group by \"promotion\".\"promotion_name\" order by \"promotion\".\"promotion_name\" ASC"
block|,
literal|""
block|,
literal|"select \"promotion\".\"media_type\" as \"c0\" from \"promotion\" as \"promotion\" where UPPER(\"promotion\".\"media_type\") = UPPER('No Media') group by \"promotion\".\"media_type\" order by \"promotion\".\"media_type\" ASC"
block|,
literal|"c0=No Media\n"
block|,
literal|"select \"promotion\".\"media_type\" as \"c0\" from \"promotion\" as \"promotion\" group by \"promotion\".\"media_type\" order by \"promotion\".\"media_type\" ASC"
block|,
literal|"c0=Bulk Mail\n"
operator|+
literal|"c0=Cash Register Handout\n"
operator|+
literal|"c0=Daily Paper\n"
operator|+
literal|"c0=Daily Paper, Radio\n"
operator|+
literal|"c0=Daily Paper, Radio, TV\n"
operator|+
literal|"c0=In-Store Coupon\n"
operator|+
literal|"c0=No Media\n"
operator|+
literal|"c0=Product Attachment\n"
operator|+
literal|"c0=Radio\n"
operator|+
literal|"c0=Street Handout\n"
operator|+
literal|"c0=Sunday Paper\n"
operator|+
literal|"c0=Sunday Paper, Radio\n"
operator|+
literal|"c0=Sunday Paper, Radio, TV\n"
operator|+
literal|"c0=TV\n"
block|,
literal|"select count(distinct \"the_year\") from \"time_by_day\""
block|,
literal|"EXPR$0=2\n"
block|,
literal|"select \"time_by_day\".\"the_year\" as \"c0\", sum(\"sales_fact_1997\".\"unit_sales\") as \"m0\" from \"time_by_day\" as \"time_by_day\", \"sales_fact_1997\" as \"sales_fact_1997\" where \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\" and \"time_by_day\".\"the_year\" = 1997 group by \"time_by_day\".\"the_year\""
block|,
literal|"c0=1997; m0=266773.0000\n"
block|,
literal|"select \"time_by_day\".\"the_year\" as \"c0\", \"promotion\".\"media_type\" as \"c1\", sum(\"sales_fact_1997\".\"unit_sales\") as \"m0\" from \"time_by_day\" as \"time_by_day\", \"sales_fact_1997\" as \"sales_fact_1997\", \"promotion\" as \"promotion\" where \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\" and \"time_by_day\".\"the_year\" = 1997 and \"sales_fact_1997\".\"promotion_id\" = \"promotion\".\"promotion_id\" group by \"time_by_day\".\"the_year\", \"promotion\".\"media_type\""
block|,
literal|"c0=1997; c1=Bulk Mail; m0=4320.0000\n"
operator|+
literal|"c0=1997; c1=Radio; m0=2454.0000\n"
operator|+
literal|"c0=1997; c1=Street Handout; m0=5753.0000\n"
operator|+
literal|"c0=1997; c1=TV; m0=3607.0000\n"
operator|+
literal|"c0=1997; c1=No Media; m0=195448.0000\n"
operator|+
literal|"c0=1997; c1=In-Store Coupon; m0=3798.0000\n"
operator|+
literal|"c0=1997; c1=Sunday Paper, Radio, TV; m0=2726.0000\n"
operator|+
literal|"c0=1997; c1=Product Attachment; m0=7544.0000\n"
operator|+
literal|"c0=1997; c1=Daily Paper; m0=7738.0000\n"
operator|+
literal|"c0=1997; c1=Cash Register Handout; m0=6697.0000\n"
operator|+
literal|"c0=1997; c1=Daily Paper, Radio; m0=6891.0000\n"
operator|+
literal|"c0=1997; c1=Daily Paper, Radio, TV; m0=9513.0000\n"
operator|+
literal|"c0=1997; c1=Sunday Paper, Radio; m0=5945.0000\n"
operator|+
literal|"c0=1997; c1=Sunday Paper; m0=4339.0000\n"
block|,
literal|"select \"store\".\"store_country\" as \"c0\", sum(\"inventory_fact_1997\".\"supply_time\") as \"m0\" from \"store\" as \"store\", \"inventory_fact_1997\" as \"inventory_fact_1997\" where \"inventory_fact_1997\".\"store_id\" = \"store\".\"store_id\" group by \"store\".\"store_country\""
block|,
literal|"c0=USA; m0=10425\n"
block|,
literal|"select \"sn\".\"desc\" as \"c0\" from (SELECT * FROM (VALUES (1, 'SameName')) AS \"t\" (\"id\", \"desc\")) as \"sn\" group by \"sn\".\"desc\" order by \"sn\".\"desc\" ASC NULLS LAST"
block|,
literal|"c0=SameName\n"
block|,
literal|"select \"the_year\", count(*) as c, min(\"the_month\") as m\n"
operator|+
literal|"from \"foodmart2\".\"time_by_day\"\n"
operator|+
literal|"group by \"the_year\"\n"
operator|+
literal|"order by 1, 2"
block|,
literal|"the_year=1997; C=365; M=April\n"
operator|+
literal|"the_year=1998; C=365; M=April\n"
block|,
literal|"select\n"
operator|+
literal|" \"store\".\"store_state\" as \"c0\",\n"
operator|+
literal|" \"time_by_day\".\"the_year\" as \"c1\",\n"
operator|+
literal|" sum(\"sales_fact_1997\".\"unit_sales\") as \"m0\",\n"
operator|+
literal|" sum(\"sales_fact_1997\".\"store_sales\") as \"m1\"\n"
operator|+
literal|"from \"store\" as \"store\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"time_by_day\" as \"time_by_day\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"store_id\" = \"store\".\"store_id\"\n"
operator|+
literal|"and \"store\".\"store_state\" in ('DF', 'WA')\n"
operator|+
literal|"and \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\"\n"
operator|+
literal|"and \"time_by_day\".\"the_year\" = 1997\n"
operator|+
literal|"group by \"store\".\"store_state\", \"time_by_day\".\"the_year\""
block|,
literal|"c0=WA; c1=1997; m0=124366.0000; m1=263793.2200\n"
block|,
literal|"select count(distinct \"product_id\") from \"product\""
block|,
literal|"EXPR$0=1560\n"
block|,
literal|"select \"store\".\"store_name\" as \"c0\",\n"
operator|+
literal|" \"time_by_day\".\"the_year\" as \"c1\",\n"
operator|+
literal|" sum(\"sales_fact_1997\".\"store_sales\") as \"m0\"\n"
operator|+
literal|"from \"store\" as \"store\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"time_by_day\" as \"time_by_day\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"store_id\" = \"store\".\"store_id\"\n"
operator|+
literal|"and \"store\".\"store_name\" in ('Store 1', 'Store 10', 'Store 11', 'Store 15', 'Store 16', 'Store 24', 'Store 3', 'Store 7')\n"
operator|+
literal|"and \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\"\n"
operator|+
literal|"and \"time_by_day\".\"the_year\" = 1997\n"
operator|+
literal|"group by \"store\".\"store_name\",\n"
operator|+
literal|" \"time_by_day\".\"the_year\"\n"
block|,
literal|"c0=Store 7; c1=1997; m0=54545.2800\n"
operator|+
literal|"c0=Store 24; c1=1997; m0=54431.1400\n"
operator|+
literal|"c0=Store 16; c1=1997; m0=49634.4600\n"
operator|+
literal|"c0=Store 3; c1=1997; m0=52896.3000\n"
operator|+
literal|"c0=Store 15; c1=1997; m0=52644.0700\n"
operator|+
literal|"c0=Store 11; c1=1997; m0=55058.7900\n"
block|,
literal|"select \"customer\".\"yearly_income\" as \"c0\","
operator|+
literal|" \"customer\".\"education\" as \"c1\" \n"
operator|+
literal|"from \"customer\" as \"customer\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"sales_fact_1997\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"customer_id\" = \"customer\".\"customer_id\"\n"
operator|+
literal|" and ((not (\"customer\".\"yearly_income\" in ('$10K - $30K', '$50K - $70K'))\n"
operator|+
literal|" or (\"customer\".\"yearly_income\" is null)))\n"
operator|+
literal|"group by \"customer\".\"yearly_income\",\n"
operator|+
literal|" \"customer\".\"education\"\n"
operator|+
literal|"order by \"customer\".\"yearly_income\" ASC NULLS LAST,\n"
operator|+
literal|" \"customer\".\"education\" ASC NULLS LAST"
block|,
literal|"c0=$110K - $130K; c1=Bachelors Degree\n"
operator|+
literal|"c0=$110K - $130K; c1=Graduate Degree\n"
operator|+
literal|"c0=$110K - $130K; c1=High School Degree\n"
operator|+
literal|"c0=$110K - $130K; c1=Partial College\n"
operator|+
literal|"c0=$110K - $130K; c1=Partial High School\n"
operator|+
literal|"c0=$130K - $150K; c1=Bachelors Degree\n"
operator|+
literal|"c0=$130K - $150K; c1=Graduate Degree\n"
operator|+
literal|"c0=$130K - $150K; c1=High School Degree\n"
operator|+
literal|"c0=$130K - $150K; c1=Partial College\n"
operator|+
literal|"c0=$130K - $150K; c1=Partial High School\n"
operator|+
literal|"c0=$150K +; c1=Bachelors Degree\n"
operator|+
literal|"c0=$150K +; c1=Graduate Degree\n"
operator|+
literal|"c0=$150K +; c1=High School Degree\n"
operator|+
literal|"c0=$150K +; c1=Partial College\n"
operator|+
literal|"c0=$150K +; c1=Partial High School\n"
operator|+
literal|"c0=$30K - $50K; c1=Bachelors Degree\n"
operator|+
literal|"c0=$30K - $50K; c1=Graduate Degree\n"
operator|+
literal|"c0=$30K - $50K; c1=High School Degree\n"
operator|+
literal|"c0=$30K - $50K; c1=Partial College\n"
operator|+
literal|"c0=$30K - $50K; c1=Partial High School\n"
operator|+
literal|"c0=$70K - $90K; c1=Bachelors Degree\n"
operator|+
literal|"c0=$70K - $90K; c1=Graduate Degree\n"
operator|+
literal|"c0=$70K - $90K; c1=High School Degree\n"
operator|+
literal|"c0=$70K - $90K; c1=Partial College\n"
operator|+
literal|"c0=$70K - $90K; c1=Partial High School\n"
operator|+
literal|"c0=$90K - $110K; c1=Bachelors Degree\n"
operator|+
literal|"c0=$90K - $110K; c1=Graduate Degree\n"
operator|+
literal|"c0=$90K - $110K; c1=High School Degree\n"
operator|+
literal|"c0=$90K - $110K; c1=Partial College\n"
operator|+
literal|"c0=$90K - $110K; c1=Partial High School\n"
block|,
literal|"ignore:select \"time_by_day\".\"the_year\" as \"c0\", \"product_class\".\"product_family\" as \"c1\", \"customer\".\"state_province\" as \"c2\", \"customer\".\"city\" as \"c3\", sum(\"sales_fact_1997\".\"unit_sales\") as \"m0\" from \"time_by_day\" as \"time_by_day\", \"sales_fact_1997\" as \"sales_fact_1997\", \"product_class\" as \"product_class\", \"product\" as \"product\", \"customer\" as \"customer\" where \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\" and \"time_by_day\".\"the_year\" = 1997 and \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\" and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\" and \"product_class\".\"product_family\" = 'Drink' and \"sales_fact_1997\".\"customer_id\" = \"customer\".\"customer_id\" and \"customer\".\"state_province\" = 'WA' and \"customer\".\"city\" in ('Anacortes', 'Ballard', 'Bellingham', 'Bremerton', 'Burien', 'Edmonds', 'Everett', 'Issaquah', 'Kirkland', 'Lynnwood', 'Marysville', 'Olympia', 'Port Orchard', 'Puyallup', 'Redmond', 'Renton', 'Seattle', 'Sedro Woolley', 'Spokane', 'Tacoma', 'Walla Walla', 'Yakima') group by \"time_by_day\".\"the_year\", \"product_class\".\"product_family\", \"customer\".\"state_province\", \"customer\".\"city\""
block|,
literal|"c0=1997; c1=Drink; c2=WA; c3=Sedro Woolley; m0=58.0000\n"
block|,
literal|"select \"store\".\"store_country\" as \"c0\",\n"
operator|+
literal|" \"time_by_day\".\"the_year\" as \"c1\",\n"
operator|+
literal|" sum(\"sales_fact_1997\".\"store_cost\") as \"m0\",\n"
operator|+
literal|" count(\"sales_fact_1997\".\"product_id\") as \"m1\",\n"
operator|+
literal|" count(distinct \"sales_fact_1997\".\"customer_id\") as \"m2\",\n"
operator|+
literal|" sum((case when \"sales_fact_1997\".\"promotion_id\" = 0 then 0\n"
operator|+
literal|"     else \"sales_fact_1997\".\"store_sales\" end)) as \"m3\"\n"
operator|+
literal|"from \"store\" as \"store\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"time_by_day\" as \"time_by_day\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"store_id\" = \"store\".\"store_id\"\n"
operator|+
literal|"and \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\"\n"
operator|+
literal|"and \"time_by_day\".\"the_year\" = 1997\n"
operator|+
literal|"group by \"store\".\"store_country\", \"time_by_day\".\"the_year\""
block|,
literal|"c0=USA; c1=1997; m0=225627.2336; m1=86837; m2=5581; m3=151211.2100\n"
block|,
comment|// query 6077
comment|// disabled (runs out of memory)
literal|"ignore:select \"time_by_day\".\"the_year\" as \"c0\",\n"
operator|+
literal|" count(distinct \"sales_fact_1997\".\"customer_id\") as \"m0\"\n"
operator|+
literal|"from \"time_by_day\" as \"time_by_day\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"product_class\" as \"product_class\",\n"
operator|+
literal|" \"product\" as \"product\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\"\n"
operator|+
literal|"and \"time_by_day\".\"the_year\" = 1997\n"
operator|+
literal|"and \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\"\n"
operator|+
literal|"and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\"\n"
operator|+
literal|"and (((\"product\".\"brand_name\" = 'Cormorant'\n"
operator|+
literal|"   and \"product_class\".\"product_subcategory\" = 'Pot Scrubbers'\n"
operator|+
literal|"   and \"product_class\".\"product_category\" = 'Kitchen Products'\n"
operator|+
literal|"   and \"product_class\".\"product_department\" = 'Household'\n"
operator|+
literal|"   and \"product_class\".\"product_family\" = 'Non-Consumable')\n"
operator|+
literal|" or (\"product\".\"brand_name\" = 'Denny'\n"
operator|+
literal|"   and \"product_class\".\"product_subcategory\" = 'Pot Scrubbers'\n"
operator|+
literal|"   and \"product_class\".\"product_category\" = 'Kitchen Products'\n"
operator|+
literal|"   and \"product_class\".\"product_department\" = 'Household'\n"
operator|+
literal|"   and \"product_class\".\"product_family\" = 'Non-Consumable')\n"
operator|+
literal|" or (\"product\".\"brand_name\" = 'High Quality'\n"
operator|+
literal|"   and \"product_class\".\"product_subcategory\" = 'Pot Scrubbers'\n"
operator|+
literal|"   and \"product_class\".\"product_category\" = 'Kitchen Products'\n"
operator|+
literal|"   and \"product_class\".\"product_department\" = 'Household'\n"
operator|+
literal|"   and \"product_class\".\"product_family\" = 'Non-Consumable')\n"
operator|+
literal|" or (\"product\".\"brand_name\" = 'Red Wing'\n"
operator|+
literal|"   and \"product_class\".\"product_subcategory\" = 'Pot Scrubbers'\n"
operator|+
literal|"   and \"product_class\".\"product_category\" = 'Kitchen Products'\n"
operator|+
literal|"   and \"product_class\".\"product_department\" = 'Household'\n"
operator|+
literal|"   and \"product_class\".\"product_family\" = 'Non-Consumable'))\n"
operator|+
literal|" or (\"product_class\".\"product_subcategory\" = 'Pots and Pans'\n"
operator|+
literal|"   and \"product_class\".\"product_category\" = 'Kitchen Products'\n"
operator|+
literal|"   and \"product_class\".\"product_department\" = 'Household'\n"
operator|+
literal|"   and \"product_class\".\"product_family\" = 'Non-Consumable'))\n"
operator|+
literal|"group by \"time_by_day\".\"the_year\"\n"
block|,
literal|"xxtodo"
block|,
comment|// query 6077, simplified
comment|// disabled (slow)
literal|"ignore:select count(\"sales_fact_1997\".\"customer_id\") as \"m0\"\n"
operator|+
literal|"from \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"product_class\" as \"product_class\",\n"
operator|+
literal|" \"product\" as \"product\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\"\n"
operator|+
literal|"and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\"\n"
operator|+
literal|"and ((\"product\".\"brand_name\" = 'Cormorant'\n"
operator|+
literal|"   and \"product_class\".\"product_subcategory\" = 'Pot Scrubbers')\n"
operator|+
literal|" or (\"product_class\".\"product_subcategory\" = 'Pots and Pans'))\n"
block|,
literal|"xxxx"
block|,
comment|// query 6077, simplified further
literal|"select count(distinct \"sales_fact_1997\".\"customer_id\") as \"m0\"\n"
operator|+
literal|"from \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"product_class\" as \"product_class\",\n"
operator|+
literal|" \"product\" as \"product\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\"\n"
operator|+
literal|"and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\"\n"
operator|+
literal|"and \"product\".\"brand_name\" = 'Cormorant'\n"
block|,
literal|"m0=1298"
block|,
comment|// query 193
literal|"select \"store\".\"store_country\" as \"c0\",\n"
operator|+
literal|" \"time_by_day\".\"the_year\" as \"c1\",\n"
operator|+
literal|" \"time_by_day\".\"quarter\" as \"c2\",\n"
operator|+
literal|" \"product_class\".\"product_family\" as \"c3\",\n"
operator|+
literal|" count(\"sales_fact_1997\".\"product_id\") as \"m0\",\n"
operator|+
literal|" count(distinct \"sales_fact_1997\".\"customer_id\") as \"m1\"\n"
operator|+
literal|"from \"store\" as \"store\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"time_by_day\" as \"time_by_day\",\n"
operator|+
literal|" \"product_class\" as \"product_class\",\n"
operator|+
literal|" \"product\" as \"product\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"store_id\" = \"store\".\"store_id\"\n"
operator|+
literal|"and \"store\".\"store_country\" = 'USA'\n"
operator|+
literal|"and \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\"\n"
operator|+
literal|"and \"time_by_day\".\"the_year\" = 1997\n"
operator|+
literal|"and \"time_by_day\".\"quarter\" = 'Q3'\n"
operator|+
literal|"and \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\"\n"
operator|+
literal|"and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\"\n"
operator|+
literal|"and \"product_class\".\"product_family\" = 'Food'\n"
operator|+
literal|"group by \"store\".\"store_country\",\n"
operator|+
literal|" \"time_by_day\".\"the_year\",\n"
operator|+
literal|" \"time_by_day\".\"quarter\",\n"
operator|+
literal|" \"product_class\".\"product_family\""
block|,
literal|"c0=USA; c1=1997; c2=Q3; c3=Food; m0=15449; m1=2939"
block|,   }
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|FOODMART_QUERIES
init|=
name|querify
argument_list|(
name|QUERIES
argument_list|)
decl_stmt|;
comment|/** Janino bug    *<a href="https://jira.codehaus.org/browse/JANINO-169">JANINO-169</a>    * running queries against the JDBC adapter. As of janino-2.7.3 bug is    * open but we have a workaround in EnumerableRelImplementor. */
annotation|@
name|Test
specifier|public
name|void
name|testJanino169
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"time_id\" from \"foodmart\".\"time_by_day\" as \"t\"\n"
argument_list|)
operator|.
name|returnsCount
argument_list|(
literal|730
argument_list|)
expr_stmt|;
block|}
comment|/** Tests 3-way AND.    *    *<p>With<a href="https://github.com/julianhyde/optiq/issues/127">optiq-127,    * "EnumerableCalcRel can't support 3+ AND conditions"</a>, the last condition    * is ignored and rows with deptno=10 are wrongly returned.</p>    */
annotation|@
name|Test
specifier|public
name|void
name|testAnd3
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"deptno\" from \"hr\".\"emps\"\n"
operator|+
literal|"where \"emps\".\"empid\"< 240\n"
operator|+
literal|"and \"salary\"> 7500.0"
operator|+
literal|"and \"emps\".\"deptno\"> 10\n"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"deptno=20"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a date literal against a JDBC data source. */
annotation|@
name|Test
specifier|public
name|void
name|testJdbcDate
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from (\n"
operator|+
literal|"  select 1 from \"foodmart\".\"employee\" as e1\n"
operator|+
literal|"  where \"position_title\" = 'VP Country Manager'\n"
operator|+
literal|"  and \"birth_date\"< DATE '1950-01-01'\n"
operator|+
literal|"  and \"gender\" = 'F')"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=1\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a timestamp literal against JDBC data source. */
annotation|@
name|Test
specifier|public
name|void
name|testJdbcTimestamp
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from (\n"
operator|+
literal|"  select 1 from \"foodmart\".\"employee\" as e1\n"
operator|+
literal|"  where \"hire_date\"< TIMESTAMP '1996-06-05 00:00:00'\n"
operator|+
literal|"  and \"gender\" = 'F')"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=287\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for self-join. Left and right children of the join are the same    * relational expression. */
annotation|@
name|Test
specifier|public
name|void
name|testSelfJoin
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from (\n"
operator|+
literal|"  select 1 from \"foodmart\".\"employee\" as e1\n"
operator|+
literal|"  join \"foodmart\".\"employee\" as e2 using (\"position_title\"))"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=247149\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Self-join on different columns, select a different column, and sort and    * limit on yet another column. */
annotation|@
name|Test
specifier|public
name|void
name|testSelfJoinDifferentColumns
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|query
argument_list|(
literal|"select e1.\"full_name\"\n"
operator|+
literal|"  from \"foodmart\".\"employee\" as e1\n"
operator|+
literal|"  join \"foodmart\".\"employee\" as e2 on e1.\"first_name\" = e2.\"last_name\"\n"
operator|+
literal|"order by e1.\"last_name\" limit 3"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"full_name=James Aguilar\n"
operator|+
literal|"full_name=Carol Amyotte\n"
operator|+
literal|"full_name=Terry Anderson\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://github.com/julianhyde/optiq/issues/35">issue #35</a>. */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testJoinJoin
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select\n"
operator|+
literal|"   \"product_class\".\"product_family\" as \"c0\",\n"
operator|+
literal|"   \"product_class\".\"product_department\" as \"c1\",\n"
operator|+
literal|"   \"customer\".\"country\" as \"c2\",\n"
operator|+
literal|"   \"customer\".\"state_province\" as \"c3\",\n"
operator|+
literal|"   \"customer\".\"city\" as \"c4\"\n"
operator|+
literal|"from\n"
operator|+
literal|"   \"sales_fact_1997\" as \"sales_fact_1997\"\n"
operator|+
literal|"join (\"product\" as \"product\"\n"
operator|+
literal|"     join \"product_class\" as \"product_class\"\n"
operator|+
literal|"     on \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\")\n"
operator|+
literal|"on  \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\"\n"
operator|+
literal|"join \"customer\" as \"customer\"\n"
operator|+
literal|"on  \"sales_fact_1997\".\"customer_id\" = \"customer\".\"customer_id\"\n"
operator|+
literal|"join \"promotion\" as \"promotion\"\n"
operator|+
literal|"on \"sales_fact_1997\".\"promotion_id\" = \"promotion\".\"promotion_id\"\n"
operator|+
literal|"where (\"promotion\".\"media_type\" = 'Radio'\n"
operator|+
literal|" or \"promotion\".\"media_type\" = 'TV'\n"
operator|+
literal|" or \"promotion\".\"media_type\" = 'Sunday Paper'\n"
operator|+
literal|" or \"promotion\".\"media_type\" = 'Street Handout')\n"
operator|+
literal|" and (\"product_class\".\"product_family\" = 'Drink')\n"
operator|+
literal|" and (\"customer\".\"country\" = 'USA' and \"customer\".\"state_province\""
operator|+
literal|" = 'WA' and \"customer\".\"city\" = 'Bellingham')\n"
operator|+
literal|"group by \"product_class\".\"product_family\",\n"
operator|+
literal|"   \"product_class\".\"product_department\",\n"
operator|+
literal|"   \"customer\".\"country\",\n"
operator|+
literal|"   \"customer\".\"state_province\",\n"
operator|+
literal|"   \"customer\".\"city\"\n"
operator|+
literal|"order by ISNULL(\"product_class\".\"product_family\") ASC,   \"product_class\".\"product_family\" ASC,\n"
operator|+
literal|"   ISNULL(\"product_class\".\"product_department\") ASC,   \"product_class\".\"product_department\" ASC,\n"
operator|+
literal|"   ISNULL(\"customer\".\"country\") ASC,   \"customer\".\"country\" ASC,\n"
operator|+
literal|"   ISNULL(\"customer\".\"state_province\") ASC,   \"customer\".\"state_province\" ASC,\n"
operator|+
literal|"   ISNULL(\"customer\".\"city\") ASC,   \"customer\".\"city\" ASC"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"+-------+---------------------+-----+------+------------+\n"
operator|+
literal|"| c0    | c1                  | c2  | c3   | c4         |\n"
operator|+
literal|"+-------+---------------------+-----+------+------------+\n"
operator|+
literal|"| Drink | Alcoholic Beverages | USA | WA   | Bellingham |\n"
operator|+
literal|"| Drink | Dairy               | USA | WA   | Bellingham |\n"
operator|+
literal|"+-------+---------------------+-----+------+------------+"
argument_list|)
expr_stmt|;
block|}
comment|/** Four-way join. Used to take 80 seconds. */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testJoinFiveWay
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store\".\"store_country\" as \"c0\",\n"
operator|+
literal|" \"time_by_day\".\"the_year\" as \"c1\",\n"
operator|+
literal|" \"product_class\".\"product_family\" as \"c2\",\n"
operator|+
literal|" count(\"sales_fact_1997\".\"product_id\") as \"m0\"\n"
operator|+
literal|"from \"store\" as \"store\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"time_by_day\" as \"time_by_day\",\n"
operator|+
literal|" \"product_class\" as \"product_class\",\n"
operator|+
literal|" \"product\" as \"product\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"store_id\" = \"store\".\"store_id\"\n"
operator|+
literal|"and \"store\".\"store_country\" = 'USA'\n"
operator|+
literal|"and \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\"\n"
operator|+
literal|"and \"time_by_day\".\"the_year\" = 1997\n"
operator|+
literal|"and \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\"\n"
operator|+
literal|"and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\"\n"
operator|+
literal|"group by \"store\".\"store_country\",\n"
operator|+
literal|" \"time_by_day\".\"the_year\",\n"
operator|+
literal|" \"product_class\".\"product_family\""
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableAggregateRel(group=[{0, 1, 2}], m0=[COUNT($3)])\n"
operator|+
literal|"  EnumerableCalcRel(expr#0..61=[{inputs}], c0=[$t19], c1=[$t4], c2=[$t46], product_id=[$t34])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($35, $0)], joinType=[inner])\n"
operator|+
literal|"      EnumerableCalcRel(expr#0..9=[{inputs}], expr#10=[CAST($t4):INTEGER], expr#11=[1997], expr#12=[=($t10, $t11)], proj#0..9=[{exprs}], $condition=[$t12])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, time_by_day]])\n"
operator|+
literal|"      EnumerableCalcRel(expr#0..51=[{inputs}], proj#0..23=[{exprs}], product_id=[$t44], time_id=[$t45], customer_id=[$t46], promotion_id=[$t47], store_id0=[$t48], store_sales=[$t49], store_cost=[$t50], unit_sales=[$t51], product_class_id=[$t24], product_subcategory=[$t25], product_category=[$t26], product_department=[$t27], product_family=[$t28], product_class_id0=[$t29], product_id0=[$t30], brand_name=[$t31], product_name=[$t32], SKU=[$t33], SRP=[$t34], gross_weight=[$t35], net_weight=[$t36], recyclable_package=[$t37], low_fat=[$t38], units_per_case=[$t39], cases_per_pallet=[$t40], shelf_width=[$t41], shelf_height=[$t42], shelf_depth=[$t43])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($48, $0)], joinType=[inner])\n"
operator|+
literal|"          EnumerableCalcRel(expr#0..23=[{inputs}], expr#24=['USA'], expr#25=[=($t9, $t24)], proj#0..23=[{exprs}], $condition=[$t25])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, store]])\n"
operator|+
literal|"          EnumerableCalcRel(expr#0..27=[{inputs}], proj#0..4=[{exprs}], product_class_id0=[$t13], product_id=[$t14], brand_name=[$t15], product_name=[$t16], SKU=[$t17], SRP=[$t18], gross_weight=[$t19], net_weight=[$t20], recyclable_package=[$t21], low_fat=[$t22], units_per_case=[$t23], cases_per_pallet=[$t24], shelf_width=[$t25], shelf_height=[$t26], shelf_depth=[$t27], product_id0=[$t5], time_id=[$t6], customer_id=[$t7], promotion_id=[$t8], store_id=[$t9], store_sales=[$t10], store_cost=[$t11], unit_sales=[$t12])\n"
operator|+
literal|"            EnumerableJoinRel(condition=[=($13, $0)], joinType=[inner])\n"
operator|+
literal|"              EnumerableTableAccessRel(table=[[foodmart2, product_class]])\n"
operator|+
literal|"              EnumerableJoinRel(condition=[=($0, $9)], joinType=[inner])\n"
operator|+
literal|"                EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
operator|+
literal|"                EnumerableTableAccessRel(table=[[foodmart2, product]])\n"
operator|+
literal|"\n"
operator|+
literal|"]>"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"+-------+---------------------+-----+------+------------+\n"
operator|+
literal|"| c0    | c1                  | c2  | c3   | c4         |\n"
operator|+
literal|"+-------+---------------------+-----+------+------------+\n"
operator|+
literal|"| Drink | Alcoholic Beverages | USA | WA   | Bellingham |\n"
operator|+
literal|"| Drink | Dairy               | USA | WA   | Bellingham |\n"
operator|+
literal|"+-------+---------------------+-----+------+------------+"
argument_list|)
expr_stmt|;
block|}
comment|/** Returns a list of (query, expected) pairs. The expected result is    * sometimes null. */
specifier|private
specifier|static
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|querify
parameter_list|(
name|String
index|[]
name|queries1
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queries1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|query
init|=
name|queries1
index|[
name|i
index|]
decl_stmt|;
name|String
name|expected
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|queries1
operator|.
name|length
operator|&&
name|queries1
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|null
operator|&&
operator|!
name|queries1
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|startsWith
argument_list|(
literal|"select"
argument_list|)
condition|)
block|{
name|expected
operator|=
name|queries1
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|query
argument_list|,
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/** A selection of queries generated by Mondrian. */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testCloneQueries
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|query
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|FOODMART_QUERIES
argument_list|)
control|)
block|{
try|try
block|{
comment|// uncomment to run specific queries:
comment|//      if (query.i != FOODMART_QUERIES.size() - 1) continue;
specifier|final
name|String
name|sql
init|=
name|query
operator|.
name|e
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|sql
operator|.
name|startsWith
argument_list|(
literal|"ignore:"
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|String
name|expected
init|=
name|query
operator|.
name|e
operator|.
name|right
decl_stmt|;
specifier|final
name|OptiqAssert
operator|.
name|AssertQuery
name|query1
init|=
name|with
operator|.
name|query
argument_list|(
name|sql
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sql
operator|.
name|contains
argument_list|(
literal|"order by"
argument_list|)
condition|)
block|{
name|query1
operator|.
name|returns
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query1
operator|.
name|returnsUnordered
argument_list|(
name|expected
operator|.
name|split
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|query1
operator|.
name|runs
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"while running query #"
operator|+
name|query
operator|.
name|i
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Tests accessing a column in a JDBC source whose type is ARRAY. */
annotation|@
name|Test
specifier|public
name|void
name|testArray
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|hsqldbMemUrl
init|=
literal|"jdbc:hsqldb:mem:."
decl_stmt|;
name|Connection
name|baseConnection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
name|hsqldbMemUrl
argument_list|)
decl_stmt|;
name|Statement
name|baseStmt
init|=
name|baseConnection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|baseStmt
operator|.
name|execute
argument_list|(
literal|"CREATE TABLE ARR_TABLE (\n"
operator|+
literal|"ID INTEGER,\n"
operator|+
literal|"VALS INTEGER ARRAY)"
argument_list|)
expr_stmt|;
name|baseStmt
operator|.
name|execute
argument_list|(
literal|"INSERT INTO ARR_TABLE VALUES (1, ARRAY[1,2,3])"
argument_list|)
expr_stmt|;
name|baseStmt
operator|.
name|execute
argument_list|(
literal|"CREATE TABLE ARR_TABLE2 (\n"
operator|+
literal|"ID INTEGER,\n"
operator|+
literal|"VALS INTEGER ARRAY,\n"
operator|+
literal|"VALVALS VARCHAR(10) ARRAY)"
argument_list|)
expr_stmt|;
name|baseStmt
operator|.
name|execute
argument_list|(
literal|"INSERT INTO ARR_TABLE2 VALUES (1, ARRAY[1,2,3], ARRAY['x','y'])"
argument_list|)
expr_stmt|;
name|baseStmt
operator|.
name|close
argument_list|()
expr_stmt|;
name|baseConnection
operator|.
name|commit
argument_list|()
expr_stmt|;
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|info
operator|.
name|put
argument_list|(
literal|"model"
argument_list|,
literal|"inline:"
operator|+
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"  defaultSchema: 'BASEJDBC',\n"
operator|+
literal|"  schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       type: 'jdbc',\n"
operator|+
literal|"       name: 'BASEJDBC',\n"
operator|+
literal|"       jdbcDriver: '"
operator|+
name|jdbcDriver
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"       jdbcUrl: '"
operator|+
name|hsqldbMemUrl
operator|+
literal|"',\n"
operator|+
literal|"       jdbcCatalog: null,\n"
operator|+
literal|"       jdbcSchema: null\n"
operator|+
literal|"     }\n"
operator|+
literal|"  ]\n"
operator|+
literal|"}"
argument_list|)
expr_stmt|;
name|Connection
name|optiqConnection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:optiq:"
argument_list|,
name|info
argument_list|)
decl_stmt|;
name|Statement
name|optiqStatement
init|=
name|optiqConnection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
name|optiqStatement
operator|.
name|executeQuery
argument_list|(
literal|"SELECT ID, VALS FROM ARR_TABLE"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Array
name|array
init|=
name|rs
operator|.
name|getArray
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|}
argument_list|,
operator|(
name|Object
index|[]
operator|)
name|array
operator|.
name|getArray
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
name|rs
operator|=
name|optiqStatement
operator|.
name|executeQuery
argument_list|(
literal|"SELECT ID, CARDINALITY(VALS), VALS[2] FROM ARR_TABLE"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
name|rs
operator|=
name|optiqStatement
operator|.
name|executeQuery
argument_list|(
literal|"SELECT * FROM ARR_TABLE2"
argument_list|)
expr_stmt|;
specifier|final
name|ResultSetMetaData
name|metaData
init|=
name|rs
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnTypeName
argument_list|(
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"INTEGER"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnTypeName
argument_list|(
literal|2
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"INTEGER ARRAY"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnTypeName
argument_list|(
literal|3
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"VARCHAR(10) ARRAY"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|rs
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rs
operator|.
name|getArray
argument_list|(
literal|2
argument_list|)
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rs
operator|.
name|getArray
argument_list|(
literal|3
argument_list|)
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|optiqConnection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|private
name|OptiqAssert
operator|.
name|AssertQuery
name|withFoodMartQuery
parameter_list|(
name|int
name|id
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FoodmartTest
operator|.
name|FoodMartQuerySet
name|set
init|=
name|FoodmartTest
operator|.
name|FoodMartQuerySet
operator|.
name|instance
argument_list|()
decl_stmt|;
return|return
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
name|set
operator|.
name|queries
operator|.
name|get
argument_list|(
name|id
argument_list|)
operator|.
name|sql
argument_list|)
return|;
block|}
comment|/** Makes sure that a projection introduced by a call to    * {@link org.eigenbase.rel.rules.SwapJoinRule} does not manifest as an    * {@link net.hydromatic.optiq.rules.java.JavaRules.EnumerableCalcRel} in the    * plan.    *    *<p>Test case for (not yet fixed)    *<a href="https://github.com/julianhyde/optiq/issues/92">#92</a>, "Project    * should be optimized away, not converted to EnumerableCalcRel".</p>    */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testNoCalcBetweenJoins
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FoodmartTest
operator|.
name|FoodMartQuerySet
name|set
init|=
name|FoodmartTest
operator|.
name|FoodMartQuerySet
operator|.
name|instance
argument_list|()
decl_stmt|;
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
name|set
operator|.
name|queries
operator|.
name|get
argument_list|(
literal|16
argument_list|)
operator|.
name|sql
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableSortRel(sort0=[$0], sort1=[$1], sort2=[$2], sort3=[$4], sort4=[$10], sort5=[$11], sort6=[$12], sort7=[$13], sort8=[$22], sort9=[$23], sort10=[$24], sort11=[$25], sort12=[$26], sort13=[$27], dir0=[Ascending-nulls-last], dir1=[Ascending-nulls-last], dir2=[Ascending-nulls-last], dir3=[Ascending-nulls-last], dir4=[Ascending-nulls-last], dir5=[Ascending-nulls-last], dir6=[Ascending-nulls-last], dir7=[Ascending-nulls-last], dir8=[Ascending-nulls-last], dir9=[Ascending-nulls-last], dir10=[Ascending-nulls-last], dir11=[Ascending-nulls-last], dir12=[Ascending-nulls-last], dir13=[Ascending-nulls-last])\n"
operator|+
literal|"  EnumerableCalcRel(expr#0..26=[{inputs}], proj#0..4=[{exprs}], c5=[$t4], c6=[$t5], c7=[$t6], c8=[$t7], c9=[$t8], c10=[$t9], c11=[$t10], c12=[$t11], c13=[$t12], c14=[$t13], c15=[$t14], c16=[$t15], c17=[$t16], c18=[$t17], c19=[$t18], c20=[$t19], c21=[$t20], c22=[$t21], c23=[$t22], c24=[$t23], c25=[$t24], c26=[$t25], c27=[$t26])\n"
operator|+
literal|"    EnumerableAggregateRel(group=[{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26}])\n"
operator|+
literal|"      EnumerableCalcRel(expr#0..80=[{inputs}], c0=[$t12], c1=[$t10], c2=[$t9], c3=[$t0], fullname=[$t28], c6=[$t19], c7=[$t17], c8=[$t22], c9=[$t18], c10=[$t46], c11=[$t44], c12=[$t43], c13=[$t40], c14=[$t38], c15=[$t47], c16=[$t52], c17=[$t53], c18=[$t54], c19=[$t55], c20=[$t56], c21=[$t42], c22=[$t80], c23=[$t79], c24=[$t78], c25=[$t77], c26=[$t63], c27=[$t64])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($61, $76)], joinType=[inner])\n"
operator|+
literal|"          EnumerableJoinRel(condition=[=($29, $62)], joinType=[inner])\n"
operator|+
literal|"            EnumerableJoinRel(condition=[=($33, $37)], joinType=[inner])\n"
operator|+
literal|"              EnumerableCalcRel(expr#0..36=[{inputs}], customer_id=[$t8], account_num=[$t9], lname=[$t10], fname=[$t11], mi=[$t12], address1=[$t13], address2=[$t14], address3=[$t15], address4=[$t16], city=[$t17], state_province=[$t18], postal_code=[$t19], country=[$t20], customer_region_id=[$t21], phone1=[$t22], phone2=[$t23], birthdate=[$t24], marital_status=[$t25], yearly_income=[$t26], gender=[$t27], total_children=[$t28], num_children_at_home=[$t29], education=[$t30], date_accnt_opened=[$t31], member_card=[$t32], occupation=[$t33], houseowner=[$t34], num_cars_owned=[$t35], fullname=[$t36], product_id=[$t0], time_id=[$t1], customer_id0=[$t2], promotion_id=[$t3], store_id=[$t4], store_sales=[$t5], store_cost=[$t6], unit_sales=[$t7])\n"
operator|+
literal|"                EnumerableJoinRel(condition=[=($2, $8)], joinType=[inner])\n"
operator|+
literal|"                  EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
operator|+
literal|"                  EnumerableTableAccessRel(table=[[foodmart2, customer]])\n"
operator|+
literal|"              EnumerableTableAccessRel(table=[[foodmart2, store]])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, product]])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, product_class]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that a 3-way join is re-ordered so that join conditions can be    * applied. The plan must not contain cartesian joins.    * {@link org.eigenbase.rel.rules.PushJoinThroughJoinRule} makes this    * possible. */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testExplainJoin
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
name|FOODMART_QUERIES
operator|.
name|get
argument_list|(
literal|48
argument_list|)
operator|.
name|left
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableAggregateRel(group=[{}], m0=[COUNT($0)])\n"
operator|+
literal|"  EnumerableAggregateRel(group=[{0}])\n"
operator|+
literal|"    EnumerableCalcRel(expr#0..27=[{inputs}], customer_id=[$t7])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($13, $0)], joinType=[inner])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, product_class]])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($0, $9)], joinType=[inner])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
operator|+
literal|"          EnumerableCalcRel(expr#0..14=[{inputs}], expr#15=['Cormorant'], expr#16=[=($t2, $t15)], proj#0..14=[{exprs}], $condition=[$t16])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, product]]"
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that a 3-way join is re-ordered so that join conditions can be    * applied. The plan is left-deep (agg_c_14_sales_fact_1997 the most    * rows, then time_by_day, then store). This makes for efficient    * hash-joins. */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testExplainJoin2
parameter_list|()
throws|throws
name|IOException
block|{
name|withFoodMartQuery
argument_list|(
literal|2482
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableSortRel(sort0=[$0], sort1=[$1], dir0=[Ascending-nulls-last], dir1=[Ascending-nulls-last])\n"
operator|+
literal|"  EnumerableAggregateRel(group=[{0, 1}])\n"
operator|+
literal|"    EnumerableCalcRel(expr#0..5=[{inputs}], c0=[$t4], c1=[$t1])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($3, $5)], joinType=[inner])\n"
operator|+
literal|"        EnumerableCalcRel(expr#0..3=[{inputs}], store_id=[$t2], store_country=[$t3], store_id0=[$t0], month_of_year=[$t1])\n"
operator|+
literal|"          EnumerableJoinRel(condition=[=($0, $2)], joinType=[inner])\n"
operator|+
literal|"            EnumerableCalcRel(expr#0..10=[{inputs}], store_id=[$t2], month_of_year=[$t4])\n"
operator|+
literal|"              EnumerableTableAccessRel(table=[[foodmart2, agg_c_14_sales_fact_1997]])\n"
operator|+
literal|"            EnumerableCalcRel(expr#0..23=[{inputs}], store_id=[$t0], store_country=[$t9])\n"
operator|+
literal|"              EnumerableTableAccessRel(table=[[foodmart2, store]])\n"
operator|+
literal|"        EnumerableCalcRel(expr#0..9=[{inputs}], the_year=[$t4], month_of_year=[$t7])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, time_by_day]])\n"
argument_list|)
operator|.
name|runs
argument_list|()
expr_stmt|;
block|}
comment|/** One of the most expensive foodmart queries. */
annotation|@
name|Ignore
comment|// OOME on Travis; works on most other machines
annotation|@
name|Test
specifier|public
name|void
name|testExplainJoin3
parameter_list|()
throws|throws
name|IOException
block|{
name|withFoodMartQuery
argument_list|(
literal|8
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableSortRel(sort0=[$0], sort1=[$1], sort2=[$2], sort3=[$4], dir0=[Ascending-nulls-last], dir1=[Ascending-nulls-last], dir2=[Ascending-nulls-last], dir3=[Ascending-nulls-last])\n"
operator|+
literal|"  EnumerableCalcRel(expr#0..8=[{inputs}], expr#9=['%Jeanne%'], expr#10=[LIKE($t4, $t9)], proj#0..4=[{exprs}], c5=[$t4], c6=[$t5], c7=[$t6], c8=[$t7], c9=[$t8], $condition=[$t10])\n"
operator|+
literal|"    EnumerableAggregateRel(group=[{0, 1, 2, 3, 4, 5, 6, 7, 8}])\n"
operator|+
literal|"      EnumerableCalcRel(expr#0..46=[{inputs}], c0=[$t12], c1=[$t10], c2=[$t9], c3=[$t0], fullname=[$t28], c6=[$t19], c7=[$t17], c8=[$t22], c9=[$t18])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($30, $37)], joinType=[inner])\n"
operator|+
literal|"          EnumerableCalcRel(expr#0..36=[{inputs}], customer_id=[$t8], account_num=[$t9], lname=[$t10], fname=[$t11], mi=[$t12], address1=[$t13], address2=[$t14], address3=[$t15], address4=[$t16], city=[$t17], state_province=[$t18], postal_code=[$t19], country=[$t20], customer_region_id=[$t21], phone1=[$t22], phone2=[$t23], birthdate=[$t24], marital_status=[$t25], yearly_income=[$t26], gender=[$t27], total_children=[$t28], num_children_at_home=[$t29], education=[$t30], date_accnt_opened=[$t31], member_card=[$t32], occupation=[$t33], houseowner=[$t34], num_cars_owned=[$t35], fullname=[$t36], product_id=[$t0], time_id=[$t1], customer_id0=[$t2], promotion_id=[$t3], store_id=[$t4], store_sales=[$t5], store_cost=[$t6], unit_sales=[$t7])\n"
operator|+
literal|"            EnumerableJoinRel(condition=[=($2, $8)], joinType=[inner])\n"
operator|+
literal|"              EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
operator|+
literal|"              EnumerableTableAccessRel(table=[[foodmart2, customer]])\n"
operator|+
literal|"          EnumerableCalcRel(expr#0..9=[{inputs}], expr#10=[CAST($t4):INTEGER], expr#11=[1997], expr#12=[=($t10, $t11)], proj#0..9=[{exprs}], $condition=[$t12])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, time_by_day]])"
argument_list|)
operator|.
name|runs
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for (not yet fixed)    *<a href="https://github.com/julianhyde/optiq/issues/99">issue #99</a>,    * "Recognize semi-join that has high selectivity and push it down". */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testExplainJoin4
parameter_list|()
throws|throws
name|IOException
block|{
name|withFoodMartQuery
argument_list|(
literal|5217
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableAggregateRel(group=[{0, 1, 2, 3}], m0=[COUNT($4)])\n"
operator|+
literal|"  EnumerableCalcRel(expr#0..69=[{inputs}], c0=[$t4], c1=[$t27], c2=[$t61], c3=[$t66], $f11=[$t11])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($68, $69)], joinType=[inner])\n"
operator|+
literal|"      EnumerableCalcRel(expr#0..67=[{inputs}], proj#0..67=[{exprs}], $f68=[$t66])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($11, $65)], joinType=[inner])\n"
operator|+
literal|"          EnumerableJoinRel(condition=[=($46, $59)], joinType=[inner])\n"
operator|+
literal|"            EnumerableCalcRel(expr#0..58=[{inputs}], $f0=[$t49], $f1=[$t50], $f2=[$t51], $f3=[$t52], $f4=[$t53], $f5=[$t54], $f6=[$t55], $f7=[$t56], $f8=[$t57], $f9=[$t58], $f10=[$t41], $f11=[$t42], $f12=[$t43], $f13=[$t44], $f14=[$t45], $f15=[$t46], $f16=[$t47], $f17=[$t48], $f18=[$t0], $f19=[$t1], $f20=[$t2], $f21=[$t3], $f22=[$t4], $f23=[$t5], $f24=[$t6], $f25=[$t7], $f26=[$t8], $f27=[$t9], $f28=[$t10], $f29=[$t11], $f30=[$t12], $f31=[$t13], $f32=[$t14], $f33=[$t15], $f34=[$t16], $f35=[$t17], $f36=[$t18], $f37=[$t19], $f38=[$t20], $f39=[$t21], $f40=[$t22], $f41=[$t23], $f42=[$t24], $f43=[$t25], $f44=[$t26], $f45=[$t27], $f46=[$t28], $f47=[$t29], $f48=[$t30], $f49=[$t31], $f50=[$t32], $f51=[$t33], $f52=[$t34], $f53=[$t35], $f54=[$t36], $f55=[$t37], $f56=[$t38], $f57=[$t39], $f58=[$t40])\n"
operator|+
literal|"              EnumerableJoinRel(condition=[=($41, $50)], joinType=[inner])\n"
operator|+
literal|"                EnumerableCalcRel(expr#0..48=[{inputs}], $f0=[$t25], $f1=[$t26], $f2=[$t27], $f3=[$t28], $f4=[$t29], $f5=[$t30], $f6=[$t31], $f7=[$t32], $f8=[$t33], $f9=[$t34], $f10=[$t35], $f11=[$t36], $f12=[$t37], $f13=[$t38], $f14=[$t39], $f15=[$t40], $f16=[$t41], $f17=[$t42], $f18=[$t43], $f19=[$t44], $f20=[$t45], $f21=[$t46], $f22=[$t47], $f23=[$t48], $f24=[$t8], $f25=[$t9], $f26=[$t10], $f27=[$t11], $f28=[$t12], $f29=[$t13], $f30=[$t14], $f31=[$t15], $f32=[$t16], $f33=[$t17], $f34=[$t18], $f35=[$t19], $f36=[$t20], $f37=[$t21], $f38=[$t22], $f39=[$t23], $f40=[$t24], $f41=[$t0], $f42=[$t1], $f43=[$t2], $f44=[$t3], $f45=[$t4], $f46=[$t5], $f47=[$t6], $f48=[$t7])\n"
operator|+
literal|"                  EnumerableJoinRel(condition=[=($14, $25)], joinType=[inner])\n"
operator|+
literal|"                    EnumerableJoinRel(condition=[=($1, $8)], joinType=[inner])\n"
operator|+
literal|"                      EnumerableTableAccessRel(table=[[foodmart2, salary]])\n"
operator|+
literal|"                      EnumerableTableAccessRel(table=[[foodmart2, employee]])\n"
operator|+
literal|"                    EnumerableTableAccessRel(table=[[foodmart2, store]])\n"
operator|+
literal|"                EnumerableTableAccessRel(table=[[foodmart2, time_by_day]])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, position]])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, employee_closure]])\n"
operator|+
literal|"      EnumerableAggregateRel(group=[{0}])\n"
operator|+
literal|"        EnumerableValuesRel(tuples=[[{ 1 }, { 2 }, { 20 }, { 21 }, { 22 }, { 23 }, { 24 }, { 25 }, { 26 }, { 27 }, { 28 }, { 29 }, { 30 }, { 31 }, { 53 }, { 54 }, { 55 }, { 56 }, { 57 }, { 58 }, { 59 }, { 60 }, { 61 }, { 62 }, { 63 }, { 64 }, { 65 }, { 66 }, { 67 }, { 68 }, { 69 }, { 70 }, { 71 }, { 72 }, { 73 }, { 74 }, { 75 }, { 76 }, { 77 }, { 78 }, { 79 }, { 80 }, { 81 }, { 82 }, { 83 }, { 84 }, { 85 }, { 86 }, { 87 }, { 88 }, { 89 }, { 90 }, { 91 }, { 92 }, { 93 }, { 94 }, { 95 }, { 96 }, { 97 }, { 98 }, { 99 }, { 100 }, { 101 }, { 102 }, { 103 }, { 104 }, { 105 }, { 106 }, { 107 }, { 108 }, { 109 }, { 110 }, { 111 }, { 112 }, { 113 }, { 114 }, { 115 }, { 116 }, { 117 }, { 118 }, { 119 }, { 120 }, { 121 }, { 122 }, { 123 }, { 124 }, { 125 }, { 126 }, { 127 }, { 128 }, { 129 }, { 130 }, { 131 }, { 132 }, { 133 }, { 134 }, { 135 }, { 136 }, { 137 }, { 138 }, { 139 }, { 140 }, { 141 }, { 142 }, { 143 }, { 144 }, { 145 }, { 146 }, { 147 }, { 148 }, { 149 }, { 150 }, { 151 }, { 152 }, { 153 }, { 154 }, { 155 }, { 156 }, { 157 }, { 158 }, { 159 }, { 160 }, { 161 }, { 162 }, { 163 }, { 164 }, { 165 }, { 166 }, { 167 }, { 168 }, { 169 }, { 170 }, { 171 }, { 172 }, { 173 }, { 174 }, { 175 }, { 176 }, { 177 }, { 178 }, { 179 }, { 180 }, { 181 }, { 182 }, { 183 }, { 184 }, { 185 }, { 186 }, { 187 }, { 188 }, { 189 }, { 190 }, { 191 }, { 192 }, { 193 }, { 194 }, { 195 }, { 196 }, { 197 }, { 198 }, { 199 }, { 200 }, { 201 }, { 202 }, { 203 }, { 204 }, { 205 }, { 206 }, { 207 }, { 208 }, { 209 }, { 210 }, { 211 }, { 212 }, { 213 }, { 214 }, { 215 }, { 216 }, { 217 }, { 218 }, { 219 }, { 220 }, { 221 }, { 222 }, { 223 }, { 224 }, { 225 }, { 226 }, { 227 }, { 228 }, { 229 }, { 230 }, { 231 }, { 232 }, { 233 }, { 234 }, { 235 }, { 236 }, { 237 }, { 238 }, { 239 }, { 240 }, { 241 }, { 242 }, { 243 }, { 244 }, { 245 }, { 246 }, { 247 }, { 248 }, { 249 }, { 250 }, { 251 }, { 252 }, { 253 }, { 254 }, { 255 }, { 256 }, { 257 }, { 258 }, { 259 }, { 260 }, { 261 }, { 262 }, { 263 }, { 264 }, { 265 }, { 266 }, { 267 }, { 268 }, { 269 }, { 270 }, { 271 }, { 272 }, { 273 }, { 274 }, { 275 }, { 276 }, { 277 }, { 278 }, { 279 }, { 280 }, { 281 }, { 282 }, { 283 }, { 284 }, { 285 }, { 286 }, { 287 }, { 288 }, { 289 }, { 290 }, { 291 }, { 292 }, { 293 }, { 294 }, { 295 }, { 296 }, { 297 }, { 298 }, { 299 }, { 300 }, { 301 }, { 302 }, { 303 }, { 304 }, { 305 }, { 306 }, { 307 }, { 308 }, { 309 }, { 310 }, { 311 }, { 312 }, { 313 }, { 314 }, { 315 }, { 316 }, { 317 }, { 318 }, { 319 }, { 320 }, { 321 }, { 322 }, { 323 }, { 324 }, { 325 }, { 326 }, { 327 }, { 328 }, { 329 }, { 330 }, { 331 }, { 332 }, { 333 }, { 334 }, { 335 }, { 336 }, { 337 }, { 338 }, { 339 }, { 340 }, { 341 }, { 342 }, { 343 }, { 344 }, { 345 }, { 346 }, { 347 }, { 348 }, { 349 }, { 350 }, { 351 }, { 352 }, { 353 }, { 354 }, { 355 }, { 356 }, { 357 }, { 358 }, { 359 }, { 360 }, { 361 }, { 362 }, { 363 }, { 364 }, { 365 }, { 366 }, { 367 }, { 368 }, { 369 }, { 370 }, { 371 }, { 372 }, { 373 }, { 374 }, { 375 }, { 376 }, { 377 }, { 378 }, { 379 }, { 380 }, { 381 }, { 382 }, { 383 }, { 384 }, { 385 }, { 386 }, { 387 }, { 388 }, { 389 }, { 390 }, { 391 }, { 392 }, { 393 }, { 394 }, { 395 }, { 396 }, { 397 }, { 398 }, { 399 }, { 400 }, { 401 }, { 402 }, { 403 }, { 404 }, { 405 }, { 406 }, { 407 }, { 408 }, { 409 }, { 410 }, { 411 }, { 412 }, { 413 }, { 414 }, { 415 }, { 416 }, { 417 }, { 418 }, { 419 }, { 420 }, { 421 }, { 422 }, { 423 }, { 424 }, { 425 }, { 430 }, { 431 }, { 432 }, { 433 }, { 434 }, { 435 }, { 436 }, { 437 }, { 442 }, { 443 }, { 444 }, { 445 }, { 446 }, { 447 }, { 448 }, { 449 }, { 450 }, { 451 }, { 457 }, { 458 }, { 459 }, { 460 }, { 461 }, { 462 }, { 463 }, { 469 }, { 470 }, { 471 }, { 472 }, { 473 }]])\n"
argument_list|)
operator|.
name|runs
argument_list|()
expr_stmt|;
block|}
comment|/** Condition involving OR makes this more complex than    * {@link #testExplainJoin()}. */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testExplainJoinOrderingWithOr
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
name|FOODMART_QUERIES
operator|.
name|get
argument_list|(
literal|47
argument_list|)
operator|.
name|left
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"xxx"
argument_list|)
expr_stmt|;
block|}
comment|/** There was a bug representing a nullable timestamp using a {@link Long}    * internally. */
annotation|@
name|Test
specifier|public
name|void
name|testNullableTimestamp
parameter_list|()
block|{
name|checkNullableTimestamp
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
expr_stmt|;
block|}
comment|/** Similar to {@link #testNullableTimestamp} but directly off JDBC. */
annotation|@
name|Test
specifier|public
name|void
name|testNullableTimestamp2
parameter_list|()
block|{
name|checkNullableTimestamp
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkNullableTimestamp
parameter_list|(
name|OptiqAssert
operator|.
name|Config
name|config
parameter_list|)
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|config
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"hire_date\", \"end_date\", \"birth_date\" from \"foodmart\".\"employee\" where \"employee_id\" = 1"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"hire_date=1994-12-01 00:00:00; end_date=null; birth_date=1961-08-26\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValues
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|query
argument_list|(
literal|"values (1), (2)"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EXPR$0=1\n"
operator|+
literal|"EXPR$0=2\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesAlias
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|query
argument_list|(
literal|"select \"desc\" from (VALUES ROW(1, 'SameName')) AS \"t\" (\"id\", \"desc\")"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"desc=SameName\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesMinus
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|query
argument_list|(
literal|"values (-2-1)"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EXPR$0=-3\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Conversions table, per JDBC 1.1 specification, table 6.    *    *<pre>    *                    T S I B R F D D N B C V L B V L D T T    *                    I M N I E L O E U I H A O I A O A I I    *                    N A T G A O U C M T A R N N R N T M M    *                    Y L E I L A B I E   R C G A B G E E E    *                    I L G N     L M R     H V R I V E   S    *                    N I E T     E A I     A A Y   A     T    *                    T N R         L C     R R     R     A    *                      T                     C     B     M    *                                            H     I     P    * Java type    * ================== = = = = = = = = = = = = = = = = = = =    * String             x x x x x x x x x x x x x x x x x x x    * BigDecimal         x x x x x x x x x x x x . . . . . . .    * Boolean            x x x x x x x x x x x x . . . . . . .    * Integer            x x x x x x x x x x x x . . . . . . .    * Long               x x x x x x x x x x x x . . . . . . .    * Float              x x x x x x x x x x x x . . . . . . .    * Double             x x x x x x x x x x x x . . . . . . .    * byte[]             . . . . . . . . . . . . . x x x . . .    * java.sql.Date      . . . . . . . . . . x x x . . . x . x    * java.sql.Time      . . . . . . . . . . x x x . . . . x .    * java.sql.Timestamp . . . . . . . . . . x x x . . . x x x    *</pre>    */
specifier|public
specifier|static
specifier|final
name|ImmutableMultimap
argument_list|<
name|Class
argument_list|,
name|Integer
argument_list|>
name|CONVERSIONS
init|=
name|x
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|ImmutableMultimap
argument_list|<
name|Class
argument_list|,
name|Integer
argument_list|>
name|x
parameter_list|()
block|{
specifier|final
name|ImmutableMultimap
operator|.
name|Builder
argument_list|<
name|Class
argument_list|,
name|Integer
argument_list|>
name|builder
init|=
name|ImmutableMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
index|[]
name|allTypes
init|=
block|{
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TINYINT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|SMALLINT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|INTEGER
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|BIGINT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|REAL
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|FLOAT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DOUBLE
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DECIMAL
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|NUMERIC
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|BIT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|CHAR
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|VARCHAR
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|LONGVARCHAR
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|BINARY
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|VARBINARY
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|LONGVARBINARY
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DATE
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIME
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIMESTAMP
block|}
decl_stmt|;
name|int
index|[]
name|numericTypes
init|=
block|{
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TINYINT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|SMALLINT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|INTEGER
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|BIGINT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|REAL
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|FLOAT
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DOUBLE
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DECIMAL
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|NUMERIC
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|BIT
block|}
decl_stmt|;
name|Class
index|[]
name|numericClasses
init|=
block|{
name|BigDecimal
operator|.
name|class
block|,
name|Boolean
operator|.
name|class
block|,
name|Integer
operator|.
name|class
block|,
name|Long
operator|.
name|class
block|,
name|Float
operator|.
name|class
block|,
name|Double
operator|.
name|class
block|}
decl_stmt|;
name|Class
index|[]
name|allClasses
init|=
block|{
name|String
operator|.
name|class
block|,
name|BigDecimal
operator|.
name|class
block|,
name|Boolean
operator|.
name|class
block|,
name|Integer
operator|.
name|class
block|,
name|Long
operator|.
name|class
block|,
name|Float
operator|.
name|class
block|,
name|Double
operator|.
name|class
block|,
name|byte
index|[]
operator|.
name|class
block|,
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
block|,
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|class
block|,
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|class
block|,     }
decl_stmt|;
name|int
index|[]
name|charTypes
init|=
block|{
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|CHAR
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|VARCHAR
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|LONGVARCHAR
block|}
decl_stmt|;
name|int
index|[]
name|binaryTypes
init|=
block|{
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|BINARY
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|VARBINARY
block|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|LONGVARBINARY
block|}
decl_stmt|;
for|for
control|(
name|int
name|type
range|:
name|allTypes
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Class
name|clazz
range|:
name|numericClasses
control|)
block|{
for|for
control|(
name|int
name|type
range|:
name|numericTypes
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|clazz
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|type
range|:
name|charTypes
control|)
block|{
for|for
control|(
name|Class
name|clazz
range|:
name|allClasses
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|clazz
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|type
range|:
name|binaryTypes
control|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|byte
index|[]
operator|.
expr|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|put
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DATE
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIMESTAMP
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|class
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIME
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|class
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DATE
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Time
operator|.
name|class
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIME
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
operator|.
name|class
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIMESTAMP
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Tests a table constructor that has multiple rows and multiple columns.    *    *<p>Note that the character literals become CHAR(3) and that the first is    * correctly rendered with trailing spaces: 'a  '. If we were inserting    * into a VARCHAR column the behavior would be different; the literals    * would be converted into VARCHAR(3) values and the implied cast from    * CHAR(1) to CHAR(3) that appends trailing spaces does not occur. See    * "contextually typed value specification" in the SQL spec.</p>    */
annotation|@
name|Test
specifier|public
name|void
name|testValuesComposite
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|query
argument_list|(
literal|"values (1, 'a'), (2, 'abc')"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EXPR$0=1; EXPR$1=a  \n"
operator|+
literal|"EXPR$0=2; EXPR$1=abc\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests inner join to an inline table ({@code VALUES} clause). */
annotation|@
name|Test
specifier|public
name|void
name|testInnerJoinValues
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|LINGUAL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select empno, desc from sales.emps,\n"
operator|+
literal|"  (SELECT * FROM (VALUES (10, 'SameName')) AS t (id, desc)) as sn\n"
operator|+
literal|"where emps.deptno = sn.id and sn.desc = 'SameName' group by empno, desc"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EMPNO=1; DESC=SameName\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a cartesian product aka cross join. */
annotation|@
name|Test
specifier|public
name|void
name|testCartesianJoin
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\", \"hr\".\"depts\" where \"emps\".\"empid\"< 140 and \"depts\".\"deptno\"> 20"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000; deptno0=30; name0=Marketing; employees=[]"
argument_list|,
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000; deptno0=40; name0=HR; employees=[Employee [empid: 200, deptno: 20, name: Eric]]"
argument_list|,
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250; deptno0=30; name0=Marketing; employees=[]"
argument_list|,
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250; deptno0=40; name0=HR; employees=[Employee [empid: 200, deptno: 20, name: Eric]]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCount
parameter_list|()
block|{
specifier|final
name|String
name|s
init|=
literal|"select \"time_by_day\".\"the_year\" as \"c0\", sum(\"sales_fact_1997\".\"unit_sales\") as \"m0\" from \"time_by_day\" as \"time_by_day\", \"sales_fact_1997\" as \"sales_fact_1997\" where \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\" and \"time_by_day\".\"the_year\" = 1997 group by \"time_by_day\".\"the_year\""
decl_stmt|;
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
name|s
argument_list|)
operator|.
name|returns
argument_list|(
literal|"c0=1997; m0=266773.0000\n"
argument_list|)
expr_stmt|;
block|}
comment|/** A difficult query: an IN list so large that the planner promotes it    * to a semi-join against a VALUES relation. */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testIn
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"time_by_day\".\"the_year\" as \"c0\",\n"
operator|+
literal|" \"product_class\".\"product_family\" as \"c1\",\n"
operator|+
literal|" \"customer\".\"country\" as \"c2\",\n"
operator|+
literal|" \"customer\".\"state_province\" as \"c3\",\n"
operator|+
literal|" \"customer\".\"city\" as \"c4\",\n"
operator|+
literal|" sum(\"sales_fact_1997\".\"unit_sales\") as \"m0\"\n"
operator|+
literal|"from \"time_by_day\" as \"time_by_day\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"sales_fact_1997\",\n"
operator|+
literal|" \"product_class\" as \"product_class\",\n"
operator|+
literal|" \"product\" as \"product\", \"customer\" as \"customer\"\n"
operator|+
literal|"where \"sales_fact_1997\".\"time_id\" = \"time_by_day\".\"time_id\"\n"
operator|+
literal|"and \"time_by_day\".\"the_year\" = 1997\n"
operator|+
literal|"and \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\"\n"
operator|+
literal|"and \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\"\n"
operator|+
literal|"and \"product_class\".\"product_family\" = 'Drink'\n"
operator|+
literal|"and \"sales_fact_1997\".\"customer_id\" = \"customer\".\"customer_id\"\n"
operator|+
literal|"and \"customer\".\"country\" = 'USA'\n"
operator|+
literal|"and \"customer\".\"state_province\" = 'WA'\n"
operator|+
literal|"and \"customer\".\"city\" in ('Anacortes', 'Ballard', 'Bellingham', 'Bremerton', 'Burien', 'Edmonds', 'Everett', 'Issaquah', 'Kirkland', 'Lynnwood', 'Marysville', 'Olympia', 'Port Orchard', 'Puyallup', 'Redmond', 'Renton', 'Seattle', 'Sedro Woolley', 'Spokane', 'Tacoma', 'Walla Walla', 'Yakima')\n"
operator|+
literal|"group by \"time_by_day\".\"the_year\",\n"
operator|+
literal|" \"product_class\".\"product_family\",\n"
operator|+
literal|" \"customer\".\"country\",\n"
operator|+
literal|" \"customer\".\"state_province\",\n"
operator|+
literal|" \"customer\".\"city\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"c0=1997; c1=Drink; c2=USA; c3=WA; c4=Sedro Woolley; m0=58.0000\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Query that uses parenthesized JOIN. */
annotation|@
name|Test
specifier|public
name|void
name|testSql92JoinParenthesized
parameter_list|()
block|{
if|if
condition|(
operator|!
name|Bug
operator|.
name|TODO_FIXED
condition|)
block|{
return|return;
block|}
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select\n"
operator|+
literal|"   \"product_class\".\"product_family\" as \"c0\",\n"
operator|+
literal|"   \"product_class\".\"product_department\" as \"c1\",\n"
operator|+
literal|"   \"customer\".\"country\" as \"c2\",\n"
operator|+
literal|"   \"customer\".\"state_province\" as \"c3\",\n"
operator|+
literal|"   \"customer\".\"city\" as \"c4\"\n"
operator|+
literal|"from\n"
operator|+
literal|"   \"sales_fact_1997\" as \"sales_fact_1997\"\n"
operator|+
literal|"join (\"product\" as \"product\"\n"
operator|+
literal|"     join \"product_class\" as \"product_class\"\n"
operator|+
literal|"     on \"product\".\"product_class_id\" = \"product_class\".\"product_class_id\")\n"
operator|+
literal|"on  \"sales_fact_1997\".\"product_id\" = \"product\".\"product_id\"\n"
operator|+
literal|"join \"customer\" as \"customer\"\n"
operator|+
literal|"on  \"sales_fact_1997\".\"customer_id\" = \"customer\".\"customer_id\"\n"
operator|+
literal|"join \"promotion\" as \"promotion\"\n"
operator|+
literal|"on \"sales_fact_1997\".\"promotion_id\" = \"promotion\".\"promotion_id\"\n"
operator|+
literal|"where (\"promotion\".\"media_type\" = 'Radio'\n"
operator|+
literal|" or \"promotion\".\"media_type\" = 'TV'\n"
operator|+
literal|" or \"promotion\".\"media_type\" = 'Sunday Paper'\n"
operator|+
literal|" or \"promotion\".\"media_type\" = 'Street Handout')\n"
operator|+
literal|" and (\"product_class\".\"product_family\" = 'Drink')\n"
operator|+
literal|" and (\"customer\".\"country\" = 'USA' and \"customer\".\"state_province\""
operator|+
literal|" = 'WA' and \"customer\".\"city\" = 'Bellingham')\n"
operator|+
literal|"group by \"product_class\".\"product_family\",\n"
operator|+
literal|"   \"product_class\".\"product_department\",\n"
operator|+
literal|"   \"customer\".\"country\",\n"
operator|+
literal|"   \"customer\".\"state_province\",\n"
operator|+
literal|"   \"customer\".\"city\"\n"
operator|+
literal|"order by \"product_class\".\"product_family\" ASC,\n"
operator|+
literal|"   \"product_class\".\"product_department\" ASC,\n"
operator|+
literal|"   \"customer\".\"country\" ASC,\n"
operator|+
literal|"   \"customer\".\"state_province\" ASC,\n"
operator|+
literal|"   \"customer\".\"city\" ASC"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"+-------+---------------------+-----+------+------------+\n"
operator|+
literal|"| c0    | c1                  | c2  | c3   | c4         |\n"
operator|+
literal|"+-------+---------------------+-----+------+------------+\n"
operator|+
literal|"| Drink | Alcoholic Beverages | USA | WA   | Bellingham |\n"
operator|+
literal|"| Drink | Dairy               | USA | WA   | Bellingham |\n"
operator|+
literal|"+-------+---------------------+-----+------+------------+\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests ORDER BY with no options. Nulls come last.    *    * @see net.hydromatic.avatica.AvaticaDatabaseMetaData#nullsAreSortedAtEnd()    */
annotation|@
name|Test
specifier|public
name|void
name|testOrderBy
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store_id\", \"grocery_sqft\" from \"store\"\n"
operator|+
literal|"where \"store_id\"< 3 order by 2"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"store_id=1; grocery_sqft=17475\n"
operator|+
literal|"store_id=2; grocery_sqft=22271\n"
operator|+
literal|"store_id=0; grocery_sqft=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests ORDER BY ... DESC. Nulls come last, as for ASC. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByDesc
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store_id\", \"grocery_sqft\" from \"store\"\n"
operator|+
literal|"where \"store_id\"< 3 order by 2 desc"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"store_id=2; grocery_sqft=22271\n"
operator|+
literal|"store_id=1; grocery_sqft=17475\n"
operator|+
literal|"store_id=0; grocery_sqft=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests sorting by an expression not in the select clause. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByExpr
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"name\", \"empid\" from \"hr\".\"emps\"\n"
operator|+
literal|"order by - \"empid\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"name=Eric; empid=200\n"
operator|+
literal|"name=Sebastian; empid=150\n"
operator|+
literal|"name=Theodore; empid=110\n"
operator|+
literal|"name=Bill; empid=100\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests sorting by an expression not in the '*' select clause. Test case for    *<a href="https://github.com/julianhyde/optiq/issues/176">issue #176</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderStarByExpr
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\"\n"
operator|+
literal|"order by - \"empid\""
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableCalcRel(expr#0..5=[{inputs}], proj#0..4=[{exprs}])\n"
operator|+
literal|"  EnumerableSortRel(sort0=[$5], dir0=[ASC])\n"
operator|+
literal|"    EnumerableCalcRel(expr#0..4=[{inputs}], expr#5=[-($t0)], proj#0..5=[{exprs}])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[hr, emps]])"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=200; deptno=20; name=Eric; salary=8000.0; commission=500\n"
operator|+
literal|"empid=150; deptno=10; name=Sebastian; salary=7000.0; commission=null\n"
operator|+
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250\n"
operator|+
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrderUnionStarByExpr
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\" where \"empid\"< 150\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from \"hr\".\"emps\" where \"empid\"> 150\n"
operator|+
literal|"order by - \"empid\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=200; deptno=20; name=Eric; salary=8000.0; commission=500\n"
operator|+
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250\n"
operator|+
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests sorting by a CAST expression not in the select clause. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByCast
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"customer_id\", \"postal_code\" from \"customer\"\n"
operator|+
literal|"where \"customer_id\"< 5\n"
operator|+
literal|"order by cast(substring(\"postal_code\" from 3) as integer) desc"
argument_list|)
comment|// ordered by last 3 digits (980, 674, 172, 057)
operator|.
name|returns
argument_list|(
literal|"customer_id=3; postal_code=73980\n"
operator|+
literal|"customer_id=4; postal_code=74674\n"
operator|+
literal|"customer_id=2; postal_code=17172\n"
operator|+
literal|"customer_id=1; postal_code=15057\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests ORDER BY ... DESC NULLS FIRST. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByDescNullsFirst
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store_id\", \"grocery_sqft\" from \"store\"\n"
operator|+
literal|"where \"store_id\"< 3 order by 2 desc nulls first"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"store_id=0; grocery_sqft=null\n"
operator|+
literal|"store_id=2; grocery_sqft=22271\n"
operator|+
literal|"store_id=1; grocery_sqft=17475\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests ORDER BY ... NULLS FIRST. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByNullsFirst
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store_id\", \"grocery_sqft\" from \"store\"\n"
operator|+
literal|"where \"store_id\"< 3 order by 2 nulls first"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"store_id=0; grocery_sqft=null\n"
operator|+
literal|"store_id=1; grocery_sqft=17475\n"
operator|+
literal|"store_id=2; grocery_sqft=22271\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests ORDER BY ... DESC NULLS LAST. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByDescNullsLast
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store_id\", \"grocery_sqft\" from \"store\"\n"
operator|+
literal|"where \"store_id\"< 3 order by 2 desc nulls last"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"store_id=2; grocery_sqft=22271\n"
operator|+
literal|"store_id=1; grocery_sqft=17475\n"
operator|+
literal|"store_id=0; grocery_sqft=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests ORDER BY ... NULLS LAST. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByNullsLast
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store_id\", \"grocery_sqft\" from \"store\"\n"
operator|+
literal|"where \"store_id\"< 3 order by 2 nulls last"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"store_id=1; grocery_sqft=17475\n"
operator|+
literal|"store_id=2; grocery_sqft=22271\n"
operator|+
literal|"store_id=0; grocery_sqft=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests ORDER BY ... FETCH. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByFetch
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store_id\", \"grocery_sqft\" from \"store\"\n"
operator|+
literal|"where \"store_id\"< 10\n"
operator|+
literal|"order by 1 fetch first 5 rows only"
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"PLAN=EnumerableLimitRel(fetch=[5])\n"
operator|+
literal|"  EnumerableSortRel(sort0=[$0], dir0=[ASC])\n"
operator|+
literal|"    EnumerableCalcRel(expr#0..23=[{inputs}], expr#24=[10], expr#25=[<($t0, $t24)], store_id=[$t0], grocery_sqft=[$t16], $condition=[$t25])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[foodmart2, store]])\n"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"store_id=0; grocery_sqft=null\n"
operator|+
literal|"store_id=1; grocery_sqft=17475\n"
operator|+
literal|"store_id=2; grocery_sqft=22271\n"
operator|+
literal|"store_id=3; grocery_sqft=24390\n"
operator|+
literal|"store_id=4; grocery_sqft=16844\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests ORDER BY ... OFFSET ... FETCH. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByOffsetFetch
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"store_id\", \"grocery_sqft\" from \"store\"\n"
operator|+
literal|"where \"store_id\"< 10\n"
operator|+
literal|"order by 1 offset 2 rows fetch next 5 rows only"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"store_id=2; grocery_sqft=22271\n"
operator|+
literal|"store_id=3; grocery_sqft=24390\n"
operator|+
literal|"store_id=4; grocery_sqft=16844\n"
operator|+
literal|"store_id=5; grocery_sqft=15012\n"
operator|+
literal|"store_id=6; grocery_sqft=15337\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests FETCH with no ORDER BY. */
annotation|@
name|Test
specifier|public
name|void
name|testFetch
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"empid\" from \"hr\".\"emps\"\n"
operator|+
literal|"fetch first 2 rows only"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=100\n"
operator|+
literal|"empid=200\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFetchStar
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\"\n"
operator|+
literal|"fetch first 2 rows only"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
operator|+
literal|"empid=200; deptno=20; name=Eric; salary=8000.0; commission=500\n"
argument_list|)
expr_stmt|;
block|}
comment|/** "SELECT ... LIMIT 0" is executed differently. A planner rule converts the    * whole query to an empty rel. */
annotation|@
name|Test
specifier|public
name|void
name|testLimitZero
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\"\n"
operator|+
literal|"limit 0"
argument_list|)
operator|.
name|returns
argument_list|(
literal|""
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"return net.hydromatic.linq4j.Linq4j.asEnumerable(new Object[] {})"
argument_list|)
expr_stmt|;
block|}
comment|/** Alternative formulation for {@link #testFetchStar()}. */
annotation|@
name|Test
specifier|public
name|void
name|testLimitStar
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\"\n"
operator|+
literal|"limit 2"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
operator|+
literal|"empid=200; deptno=20; name=Eric; salary=8000.0; commission=500\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Limit implemented using {@link Queryable#take}. Test case for    *<a href="https://github.com/julianhyde/optiq/issues/96">issue #96</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testLimitOnQueryableTable
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"days\"\n"
operator|+
literal|"limit 2"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"day=1; week_day=Sunday\n"
operator|+
literal|"day=2; week_day=Monday\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Limit implemented using {@link Queryable#take}. Test case for    *<a href="https://github.com/julianhyde/optiq/issues/70">issue #70</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSelfJoinCount
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"foodmart\".\"sales_fact_1997\" as p1 join \"foodmart\".\"sales_fact_1997\" as p2 using (\"store_id\")"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=749681031\n"
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableAggregateRel(group=[{}], C=[COUNT()])\n"
operator|+
literal|"  EnumerableCalcRel(expr#0..1=[{inputs}], expr#2=[0], DUMMY=[$t2])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($0, $1)], joinType=[inner])\n"
operator|+
literal|"      JdbcToEnumerableConverter\n"
operator|+
literal|"        JdbcProjectRel(store_id=[$4])\n"
operator|+
literal|"          JdbcTableScan(table=[[foodmart, sales_fact_1997]])\n"
operator|+
literal|"      JdbcToEnumerableConverter\n"
operator|+
literal|"        JdbcProjectRel(store_id=[$4])\n"
operator|+
literal|"          JdbcTableScan(table=[[foodmart, sales_fact_1997]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests composite GROUP BY where one of the columns has NULL values. */
annotation|@
name|Test
specifier|public
name|void
name|testGroupByNull
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"deptno\", \"commission\", sum(\"salary\") s\n"
operator|+
literal|"from \"hr\".\"emps\"\n"
operator|+
literal|"group by \"deptno\", \"commission\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"deptno=10; commission=null; S=7000.0"
argument_list|,
literal|"deptno=20; commission=500; S=8000.0"
argument_list|,
literal|"deptno=10; commission=1000; S=10000.0"
argument_list|,
literal|"deptno=10; commission=250; S=11500.0"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectDistinct
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select distinct \"deptno\"\n"
operator|+
literal|"from \"hr\".\"emps\"\n"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"deptno=10"
argument_list|,
literal|"deptno=20"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|".distinct("
argument_list|)
expr_stmt|;
block|}
comment|/** Select distinct on composite key, one column of which is boolean to    * boot. */
annotation|@
name|Test
specifier|public
name|void
name|testSelectDistinctComposite
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select distinct \"empid\"> 140 as c, \"deptno\"\n"
operator|+
literal|"from \"hr\".\"emps\"\n"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"C=false; deptno=10"
argument_list|,
literal|"C=false; deptno=10"
argument_list|,
literal|"C=true; deptno=10"
argument_list|,
literal|"C=true; deptno=20"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|".distinct("
argument_list|)
expr_stmt|;
block|}
comment|/** Same result (and plan) as {@link #testSelectDistinct}. */
annotation|@
name|Test
specifier|public
name|void
name|testGroupByNoAggregates
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"deptno\"\n"
operator|+
literal|"from \"hr\".\"emps\"\n"
operator|+
literal|"group by \"deptno\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"deptno=10"
argument_list|,
literal|"deptno=20"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|".distinct("
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that SUM and AVG over empty set return null. COUNT returns 0. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateEmpty
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select\n"
operator|+
literal|" count(*) as cs,\n"
operator|+
literal|" count(\"deptno\") as c,\n"
operator|+
literal|" sum(\"deptno\") as s,\n"
operator|+
literal|" avg(\"deptno\") as a\n"
operator|+
literal|"from \"hr\".\"emps\"\n"
operator|+
literal|"where \"deptno\"< 0"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"CS=0; C=0; S=null; A=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests sorting by a column that is already sorted. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByOnSortedTable
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"time_by_day\"\n"
operator|+
literal|"order by \"time_id\""
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"PLAN=EnumerableSortRel(sort0=[$0], dir0=[ASC])\n"
operator|+
literal|"  EnumerableTableAccessRel(table=[[foodmart2, time_by_day]])\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests sorting by a column that is already sorted. */
annotation|@
name|Ignore
argument_list|(
literal|"fix output for timezone"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testOrderByOnSortedTable2
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"time_id\", \"the_date\" from \"time_by_day\"\n"
operator|+
literal|"where \"time_id\"< 370\n"
operator|+
literal|"order by \"time_id\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"time_id=367; the_date=1997-01-01 00:00:00.0\n"
operator|+
literal|"time_id=368; the_date=1997-01-02 00:00:00.0\n"
operator|+
literal|"time_id=369; the_date=1997-01-03 00:00:00.0\n"
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"PLAN=EnumerableSortRel(sort0=[$0], dir0=[Ascending])\n"
operator|+
literal|"  EnumerableCalcRel(expr#0..9=[{inputs}], expr#10=[370], expr#11=[<($t0, $t10)], proj#0..1=[{exprs}], $condition=[$t11])\n"
operator|+
literal|"    EnumerableTableAccessRel(table=[[foodmart2, time_by_day]])\n\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWithInsideWhereExists
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"deptno\" from \"hr\".\"emps\"\n"
operator|+
literal|"where exists (\n"
operator|+
literal|"  with dept2 as (select * from \"hr\".\"depts\" where \"depts\".\"deptno\">= \"emps\".\"deptno\")\n"
operator|+
literal|"  select 1 from dept2 where \"deptno\"<= \"emps\".\"deptno\")"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"deptno=10"
argument_list|,
literal|"deptno=10"
argument_list|,
literal|"deptno=10"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests windowed aggregation. */
annotation|@
name|Test
specifier|public
name|void
name|testWinAgg
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select sum(\"salary\" + \"empid\") over w as s,\n"
operator|+
literal|" 5 as five,\n"
operator|+
literal|" min(\"salary\") over w as m,\n"
operator|+
literal|" count(*) over w as c,\n"
operator|+
literal|" \"deptno\",\n"
operator|+
literal|" \"empid\"\n"
operator|+
literal|"from \"hr\".\"emps\"\n"
operator|+
literal|"window w as (partition by \"deptno\" order by \"empid\" rows 1 preceding)"
argument_list|)
operator|.
name|typeIs
argument_list|(
literal|"[S REAL, FIVE INTEGER NOT NULL, M REAL, C BIGINT, deptno INTEGER NOT NULL, empid INTEGER NOT NULL]"
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"EnumerableCalcRel(expr#0..7=[{inputs}], expr#8=[0], expr#9=[>($t4, $t8)], expr#10=[null], expr#11=[CASE($t9, $t5, $t10)], expr#12=[CAST($t11):JavaType(class java.lang.Float)], expr#13=[5], expr#14=[CAST($t6):JavaType(class java.lang.Float)], expr#15=[CAST($t7):BIGINT], S=[$t12], FIVE=[$t13], M=[$t14], C=[$t15], deptno=[$t1], empid=[$t0])\n"
operator|+
literal|"  EnumerableWindowRel(window#0=[window(partition {1} order by [0] rows between 1 PRECEDING and CURRENT ROW aggs [COUNT($3), $SUM0($3), MIN($2), COUNT()])])\n"
operator|+
literal|"    EnumerableCalcRel(expr#0..4=[{inputs}], expr#5=[+($t3, $t0)], proj#0..1=[{exprs}], salary=[$t3], $3=[$t5])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"S=8200.0; FIVE=5; M=8000.0; C=1; deptno=20; empid=200\n"
operator|+
literal|"S=10100.0; FIVE=5; M=10000.0; C=1; deptno=10; empid=100\n"
operator|+
literal|"S=23220.0; FIVE=5; M=11500.0; C=2; deptno=10; empid=110\n"
operator|+
literal|"S=14300.0; FIVE=5; M=7000.0; C=2; deptno=10; empid=150\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests windowed aggregation with multiple windows.    * One window straddles the current row.    * Some windows have no PARTITION BY clause. */
annotation|@
name|Test
specifier|public
name|void
name|testWinAgg2
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select sum(\"salary\" + \"empid\") over w as s,\n"
operator|+
literal|" 5 as five,\n"
operator|+
literal|" min(\"salary\") over w as m,\n"
operator|+
literal|" count(*) over w as c,\n"
operator|+
literal|" count(*) over w2 as c2,\n"
operator|+
literal|" count(*) over w11 as c11,\n"
operator|+
literal|" count(*) over w11dept as c11dept,\n"
operator|+
literal|" \"deptno\",\n"
operator|+
literal|" \"empid\"\n"
operator|+
literal|"from \"hr\".\"emps\"\n"
operator|+
literal|"window w as (order by \"empid\" rows 1 preceding),\n"
operator|+
literal|" w2 as (order by \"empid\" rows 2 preceding),\n"
operator|+
literal|" w11 as (order by \"empid\" rows between 1 preceding and 1 following),\n"
operator|+
literal|" w11dept as (partition by \"deptno\" order by \"empid\" rows between 1 preceding and 1 following)"
argument_list|)
operator|.
name|typeIs
argument_list|(
literal|"[S REAL, FIVE INTEGER NOT NULL, M REAL, C BIGINT, C2 BIGINT, C11 BIGINT, C11DEPT BIGINT, deptno INTEGER NOT NULL, empid INTEGER NOT NULL]"
argument_list|)
comment|// Check that optimizes for window whose PARTITION KEY is empty
operator|.
name|planContains
argument_list|(
literal|"tempList.size()"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"S=16400.0; FIVE=5; M=8000.0; C=2; C2=3; C11=2; C11DEPT=1; deptno=20; empid=200\n"
operator|+
literal|"S=10100.0; FIVE=5; M=10000.0; C=1; C2=1; C11=2; C11DEPT=2; deptno=10; empid=100\n"
operator|+
literal|"S=23220.0; FIVE=5; M=11500.0; C=2; C2=2; C11=3; C11DEPT=3; deptno=10; empid=110\n"
operator|+
literal|"S=14300.0; FIVE=5; M=7000.0; C=2; C2=3; C11=3; C11DEPT=2; deptno=10; empid=150\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests for RANK and ORDER BY ... DESCENDING, NULLS FIRST, NULLS LAST. */
annotation|@
name|Test
specifier|public
name|void
name|testWinAggRank
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select  \"deptno\",\n"
operator|+
literal|" \"empid\",\n"
operator|+
literal|" \"commission\",\n"
operator|+
literal|" rank() over (partition by \"deptno\" order by \"commission\" desc nulls first) as rcnf,\n"
operator|+
literal|" rank() over (partition by \"deptno\" order by \"commission\" desc nulls last) as rcnl,\n"
operator|+
literal|" rank() over (partition by \"deptno\" order by \"empid\") as r,\n"
operator|+
literal|" rank() over (partition by \"deptno\" order by \"empid\" desc) as rd\n"
operator|+
literal|"from \"hr\".\"emps\""
argument_list|)
operator|.
name|typeIs
argument_list|(
literal|"[deptno INTEGER NOT NULL, empid INTEGER NOT NULL, commission INTEGER, RCNF INTEGER, RCNL INTEGER, R INTEGER, RD INTEGER]"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"deptno=20; empid=200; commission=500; RCNF=1; RCNL=1; R=1; RD=1\n"
operator|+
literal|"deptno=10; empid=150; commission=null; RCNF=1; RCNL=3; R=3; RD=1\n"
operator|+
literal|"deptno=10; empid=110; commission=250; RCNF=3; RCNL=2; R=2; RD=2\n"
operator|+
literal|"deptno=10; empid=100; commission=1000; RCNF=2; RCNL=1; R=1; RD=3\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests WHERE comparing a nullable integer with an integer literal. */
annotation|@
name|Test
specifier|public
name|void
name|testWhereNullable
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\"\n"
operator|+
literal|"where \"commission\"> 800"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests the LIKE operator. */
annotation|@
name|Test
specifier|public
name|void
name|testLike
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\"\n"
operator|+
literal|"where \"name\" like '%i__'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
operator|+
literal|"empid=150; deptno=10; name=Sebastian; salary=7000.0; commission=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests array index. */
annotation|@
name|Test
specifier|public
name|void
name|testArrayIndexing
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"deptno\", \"employees\"[1] as e from \"hr\".\"depts\"\n"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"deptno=10; E=Employee [empid: 100, deptno: 10, name: Bill]\n"
operator|+
literal|"deptno=30; E=null\n"
operator|+
literal|"deptno=40; E=Employee [empid: 200, deptno: 20, name: Eric]\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testVarcharEquals
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|FOODMART_MODEL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"lname\" from \"customer\" where \"lname\" = 'Nowmer'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"lname=Nowmer\n"
argument_list|)
expr_stmt|;
comment|// lname is declared as VARCHAR(30), comparing it with a string longer
comment|// than 30 characters would introduce a cast to the least restrictive
comment|// type, thus lname would be cast to a varchar(40) in this case.
comment|// These sorts of casts are removed though when constructing the jdbc
comment|// sql, since e.g. HSQLDB does not support them.
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|FOODMART_MODEL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"customer\" "
operator|+
literal|"where \"lname\" = 'this string is longer than 30 characters'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=0\n"
argument_list|)
expr_stmt|;
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|FOODMART_MODEL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"customer\" "
operator|+
literal|"where cast(\"customer_id\" as char(20)) = 'this string is longer than 30 characters'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=0\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests the NOT IN operator. Problems arose in code-generation because    * the column allows nulls. */
annotation|@
name|Test
specifier|public
name|void
name|testNotIn
parameter_list|()
block|{
name|predicate
argument_list|(
literal|"\"name\" not in ('a', 'b') or \"name\" is null"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
operator|+
literal|"empid=200; deptno=20; name=Eric; salary=8000.0; commission=500\n"
operator|+
literal|"empid=150; deptno=10; name=Sebastian; salary=7000.0; commission=null\n"
operator|+
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250\n"
argument_list|)
expr_stmt|;
comment|// And some similar combinations...
name|predicate
argument_list|(
literal|"\"name\" in ('a', 'b') or \"name\" is null"
argument_list|)
expr_stmt|;
name|predicate
argument_list|(
literal|"\"name\" in ('a', 'b', null) or \"name\" is null"
argument_list|)
expr_stmt|;
name|predicate
argument_list|(
literal|"\"name\" in ('a', 'b') or \"name\" is not null"
argument_list|)
expr_stmt|;
name|predicate
argument_list|(
literal|"\"name\" in ('a', 'b', null) or \"name\" is not null"
argument_list|)
expr_stmt|;
name|predicate
argument_list|(
literal|"\"name\" not in ('a', 'b', null) or \"name\" is not null"
argument_list|)
expr_stmt|;
name|predicate
argument_list|(
literal|"\"name\" not in ('a', 'b', null) and \"name\" is not null"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTrim
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|FOODMART_MODEL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select trim(\"lname\") as \"lname\" "
operator|+
literal|"from \"customer\" where \"lname\" = 'Nowmer'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"lname=Nowmer\n"
argument_list|)
expr_stmt|;
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|FOODMART_MODEL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select trim(leading 'N' from \"lname\") as \"lname\" "
operator|+
literal|"from \"customer\" where \"lname\" = 'Nowmer'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"lname=owmer\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|OptiqAssert
operator|.
name|AssertQuery
name|predicate
parameter_list|(
name|String
name|foo
parameter_list|)
block|{
return|return
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"hr\".\"emps\"\n"
operator|+
literal|"where "
operator|+
name|foo
argument_list|)
operator|.
name|runs
argument_list|()
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExistsCorrelated
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|query
argument_list|(
literal|"select*from \"hr\".\"emps\" where exists (\n"
operator|+
literal|" select 1 from \"hr\".\"depts\"\n"
operator|+
literal|" where \"emps\".\"deptno\"=\"depts\".\"deptno\")"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000"
argument_list|,
literal|"empid=150; deptno=10; name=Sebastian; salary=7000.0; commission=null"
argument_list|,
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests the TABLES table in the information schema. */
annotation|@
name|Test
specifier|public
name|void
name|testMetaTables
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR_PLUS_METADATA
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"metadata\".TABLES"
argument_list|)
operator|.
name|returns
argument_list|(
name|OptiqAssert
operator|.
name|checkResultContains
argument_list|(
literal|"tableSchem=metadata; tableName=COLUMNS; tableType=SYSTEM_TABLE; "
argument_list|)
argument_list|)
expr_stmt|;
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR_PLUS_METADATA
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(distinct \"tableSchem\") as c\n"
operator|+
literal|"from \"metadata\".TABLES"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=3\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that {@link java.sql.Statement#setMaxRows(int)} is honored. */
annotation|@
name|Test
specifier|public
name|void
name|testSetMaxRows
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|OptiqConnection
name|a0
parameter_list|)
block|{
try|try
block|{
specifier|final
name|Statement
name|statement
init|=
name|a0
operator|.
name|createStatement
argument_list|()
decl_stmt|;
try|try
block|{
name|statement
operator|.
name|setMaxRows
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
literal|"illegal maxRows value: -1"
argument_list|)
expr_stmt|;
block|}
name|statement
operator|.
name|setMaxRows
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|statement
operator|.
name|getMaxRows
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"hr\".\"emps\""
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a {@link PreparedStatement} with parameters. */
annotation|@
name|Test
specifier|public
name|void
name|testPreparedStatement
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
specifier|final
name|PreparedStatement
name|preparedStatement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"select \"deptno\", \"name\" from \"hr\".\"emps\"\n"
operator|+
literal|"where \"deptno\"< ? and \"name\" like ?"
argument_list|)
decl_stmt|;
comment|// execute with both vars null - no results
name|ResultSet
name|resultSet
init|=
name|preparedStatement
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
comment|// execute with ?0=15, ?1='%' - 3 rows
name|preparedStatement
operator|.
name|setInt
argument_list|(
literal|1
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|preparedStatement
operator|.
name|setString
argument_list|(
literal|2
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|resultSet
operator|=
name|preparedStatement
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"deptno=10; name=Bill\n"
operator|+
literal|"deptno=10; name=Sebastian\n"
operator|+
literal|"deptno=10; name=Theodore\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|resultSet
argument_list|)
argument_list|)
expr_stmt|;
comment|// execute with ?0=15 (from last bind), ?1='%r%' - 1 row
name|preparedStatement
operator|.
name|setString
argument_list|(
literal|2
argument_list|,
literal|"%r%"
argument_list|)
expr_stmt|;
name|resultSet
operator|=
name|preparedStatement
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"deptno=10; name=Theodore\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|resultSet
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|preparedStatement
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a JDBC connection that provides a model (a single schema based on    * a JDBC database). */
annotation|@
name|Test
specifier|public
name|void
name|testModel
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|FOODMART_MODEL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"foodmart\".\"time_by_day\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=730\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a JSON model with a comment. Not standard JSON, but harmless to    * allow Jackson's comments extension.    *    *<p>Test case for<a href="https://github.com/julianhyde/optiq/issues/160">    *   optiq-160, "Allow comments in schema definitions"</a>.</p> */
annotation|@
name|Test
specifier|public
name|void
name|testModelWithComment
parameter_list|()
block|{
specifier|final
name|String
name|model
init|=
name|FOODMART_MODEL
operator|.
name|replace
argument_list|(
literal|"schemas:"
argument_list|,
literal|"/* comment */ schemas:"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|model
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
name|FOODMART_MODEL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|model
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"foodmart\".\"time_by_day\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=730\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Defines a materialized view and tests that the query is rewritten to use    * it, and that the query produces the same result with and without it. There    * are more comprehensive tests in {@link MaterializationTest}. */
annotation|@
name|Ignore
argument_list|(
literal|"until JdbcSchema can define materialized views"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testModelWithMaterializedView
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|FOODMART_MODEL
argument_list|)
operator|.
name|enable
argument_list|(
literal|false
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"foodmart\".\"sales_fact_1997\" join \"foodmart\".\"time_by_day\" using (\"time_id\")"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=86837\n"
argument_list|)
expr_stmt|;
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withMaterializations
argument_list|(
name|FOODMART_MODEL
argument_list|,
literal|"agg_c_10_sales_fact_1997"
argument_list|,
literal|"select t.`month_of_year`, t.`quarter`, t.`the_year`, sum(s.`store_sales`) as `store_sales`, sum(s.`store_cost`), sum(s.`unit_sales`), count(distinct s.`customer_id`), count(*) as `fact_count` from `time_by_day` as t join `sales_fact_1997` as s using (`time_id`) group by t.`month_of_year`, t.`quarter`, t.`the_year`"
argument_list|)
operator|.
name|query
argument_list|(
literal|"select t.\"month_of_year\", t.\"quarter\", t.\"the_year\", sum(s.\"store_sales\") as \"store_sales\", sum(s.\"store_cost\"), sum(s.\"unit_sales\"), count(distinct s.\"customer_id\"), count(*) as \"fact_count\" from \"time_by_day\" as t join \"sales_fact_1997\" as s using (\"time_id\") group by t.\"month_of_year\", t.\"quarter\", t.\"the_year\""
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"JdbcTableScan(table=[[foodmart, agg_c_10_sales_fact_1997]])"
argument_list|)
operator|.
name|enableMaterializations
argument_list|(
literal|false
argument_list|)
operator|.
name|explainContains
argument_list|(
literal|"JdbcTableScan(table=[[foodmart, sales_fact_1997]])"
argument_list|)
operator|.
name|sameResultWithMaterializationsDisabled
argument_list|()
expr_stmt|;
block|}
comment|/** Tests a JDBC connection that provides a model that contains custom    * tables. */
annotation|@
name|Test
specifier|public
name|void
name|testModelCustomTable
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc',\n"
operator|+
literal|"       tables: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'EMPLOYEES',\n"
operator|+
literal|"           type: 'custom',\n"
operator|+
literal|"           factory: '"
operator|+
name|EmpDeptTableFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"           operand: {'foo': 1, 'bar': [345, 357] }\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"adhoc\".EMPLOYEES where \"deptno\" = 10"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
operator|+
literal|"empid=150; deptno=10; name=Sebastian; salary=7000.0; commission=null\n"
operator|+
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a JDBC connection that provides a model that contains custom    * tables. */
annotation|@
name|Test
specifier|public
name|void
name|testModelCustomTable2
parameter_list|()
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'MATH',\n"
operator|+
literal|"       tables: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'INTEGERS',\n"
operator|+
literal|"           type: 'custom',\n"
operator|+
literal|"           factory: '"
operator|+
name|RangeTable
operator|.
name|Factory
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"           operand: {'column': 'N', 'start': 3, 'end': 7 }\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from math.integers"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"N=3\n"
operator|+
literal|"N=4\n"
operator|+
literal|"N=5\n"
operator|+
literal|"N=6\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a JDBC connection that provides a model that contains a custom    * schema. */
annotation|@
name|Test
specifier|public
name|void
name|testModelCustomSchema
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|that
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"  defaultSchema: 'adhoc',\n"
operator|+
literal|"  schemas: [\n"
operator|+
literal|"    {\n"
operator|+
literal|"      name: 'empty'\n"
operator|+
literal|"    },\n"
operator|+
literal|"    {\n"
operator|+
literal|"      name: 'adhoc',\n"
operator|+
literal|"      type: 'custom',\n"
operator|+
literal|"      factory: '"
operator|+
name|MySchemaFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"      operand: {'tableName': 'ELVIS'}\n"
operator|+
literal|"    }\n"
operator|+
literal|"  ]\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
comment|// check that the specified 'defaultSchema' was used
name|that
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|assertEquals
argument_list|(
literal|"adhoc"
argument_list|,
name|connection
operator|.
name|getSchema
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|that
operator|.
name|query
argument_list|(
literal|"select * from \"adhoc\".ELVIS where \"deptno\" = 10"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
operator|+
literal|"empid=150; deptno=10; name=Sebastian; salary=7000.0; commission=null\n"
operator|+
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250\n"
argument_list|)
expr_stmt|;
name|that
operator|.
name|query
argument_list|(
literal|"select * from \"adhoc\".EMPLOYEES"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Table 'adhoc.EMPLOYEES' not found"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that an immutable schema in a model cannot contain a view. */
annotation|@
name|Test
specifier|public
name|void
name|testModelImmutableSchemaCannotContainView
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|that
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"  defaultSchema: 'adhoc',\n"
operator|+
literal|"  schemas: [\n"
operator|+
literal|"    {\n"
operator|+
literal|"      name: 'empty'\n"
operator|+
literal|"    },\n"
operator|+
literal|"    {\n"
operator|+
literal|"      name: 'adhoc',\n"
operator|+
literal|"      type: 'custom',\n"
operator|+
literal|"      tables: [\n"
operator|+
literal|"        {\n"
operator|+
literal|"          name: 'v',\n"
operator|+
literal|"          type: 'view',\n"
operator|+
literal|"          sql: 'values (1)'\n"
operator|+
literal|"        }\n"
operator|+
literal|"      ],\n"
operator|+
literal|"      factory: '"
operator|+
name|MySchemaFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"      operand: {\n"
operator|+
literal|"           'tableName': 'ELVIS',\n"
operator|+
literal|"           'mutable': false\n"
operator|+
literal|"      }\n"
operator|+
literal|"    }\n"
operator|+
literal|"  ]\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|that
operator|.
name|connectThrows
argument_list|(
literal|"Cannot define view; parent schema 'adhoc' is not mutable"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|OptiqAssert
operator|.
name|AssertThat
name|modelWithView
parameter_list|(
name|String
name|view
parameter_list|)
block|{
specifier|final
name|Class
argument_list|<
name|EmpDeptTableFactory
argument_list|>
name|clazz
init|=
name|EmpDeptTableFactory
operator|.
name|class
decl_stmt|;
return|return
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc',\n"
operator|+
literal|"       tables: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'EMPLOYEES',\n"
operator|+
literal|"           type: 'custom',\n"
operator|+
literal|"           factory: '"
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"           operand: {'foo': true, 'bar': 345}\n"
operator|+
literal|"         },\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'V',\n"
operator|+
literal|"           type: 'view',\n"
operator|+
literal|"           sql: '"
operator|+
name|view
operator|+
literal|"'\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
return|;
block|}
comment|/** Tests a JDBC connection that provides a model that contains a view. */
annotation|@
name|Test
specifier|public
name|void
name|testModelView
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|modelWithView
argument_list|(
literal|"select * from \"EMPLOYEES\" where \"deptno\" = 10"
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select * from \"adhoc\".V order by \"name\" desc"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250\n"
operator|+
literal|"empid=150; deptno=10; name=Sebastian; salary=7000.0; commission=null\n"
operator|+
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
argument_list|)
expr_stmt|;
comment|// Make sure that views appear in metadata.
name|with
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|OptiqConnection
name|a0
parameter_list|)
block|{
try|try
block|{
specifier|final
name|DatabaseMetaData
name|metaData
init|=
name|a0
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
comment|// all table types
name|assertEquals
argument_list|(
literal|"TABLE_CAT=null; TABLE_SCHEM=adhoc; TABLE_NAME=EMPLOYEES; TABLE_TYPE=TABLE; REMARKS=null; TYPE_CAT=null; TYPE_SCHEM=null; TYPE_NAME=null; SELF_REFERENCING_COL_NAME=null; REF_GENERATION=null\n"
operator|+
literal|"TABLE_CAT=null; TABLE_SCHEM=adhoc; TABLE_NAME=V; TABLE_TYPE=VIEW; REMARKS=null; TYPE_CAT=null; TYPE_SCHEM=null; TYPE_NAME=null; SELF_REFERENCING_COL_NAME=null; REF_GENERATION=null\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|metaData
operator|.
name|getTables
argument_list|(
literal|null
argument_list|,
literal|"adhoc"
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// views only
name|assertEquals
argument_list|(
literal|"TABLE_CAT=null; TABLE_SCHEM=adhoc; TABLE_NAME=V; TABLE_TYPE=VIEW; REMARKS=null; TYPE_CAT=null; TYPE_SCHEM=null; TYPE_NAME=null; SELF_REFERENCING_COL_NAME=null; REF_GENERATION=null\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|metaData
operator|.
name|getTables
argument_list|(
literal|null
argument_list|,
literal|"adhoc"
argument_list|,
literal|null
argument_list|,
operator|new
name|String
index|[]
block|{
name|Schema
operator|.
name|TableType
operator|.
name|VIEW
operator|.
name|name
argument_list|()
block|}
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// columns
name|assertEquals
argument_list|(
literal|"TABLE_CAT=null; TABLE_SCHEM=adhoc; TABLE_NAME=V; COLUMN_NAME=empid; DATA_TYPE=4; TYPE_NAME=JavaType(int) NOT NULL; COLUMN_SIZE=-1; BUFFER_LENGTH=null; DECIMAL_DIGITS=null; NUM_PREC_RADIX=10; NULLABLE=0; REMARKS=null; COLUMN_DEF=null; SQL_DATA_TYPE=null; SQL_DATETIME_SUB=null; CHAR_OCTET_LENGTH=-1; ORDINAL_POSITION=1; IS_NULLABLE=NO; SCOPE_CATALOG=null; SCOPE_TABLE=null; SOURCE_DATA_TYPE=null; IS_AUTOINCREMENT=null; IS_GENERATEDCOLUMN=null\n"
operator|+
literal|"TABLE_CAT=null; TABLE_SCHEM=adhoc; TABLE_NAME=V; COLUMN_NAME=deptno; DATA_TYPE=4; TYPE_NAME=JavaType(int) NOT NULL; COLUMN_SIZE=-1; BUFFER_LENGTH=null; DECIMAL_DIGITS=null; NUM_PREC_RADIX=10; NULLABLE=0; REMARKS=null; COLUMN_DEF=null; SQL_DATA_TYPE=null; SQL_DATETIME_SUB=null; CHAR_OCTET_LENGTH=-1; ORDINAL_POSITION=2; IS_NULLABLE=NO; SCOPE_CATALOG=null; SCOPE_TABLE=null; SOURCE_DATA_TYPE=null; IS_AUTOINCREMENT=null; IS_GENERATEDCOLUMN=null\n"
operator|+
literal|"TABLE_CAT=null; TABLE_SCHEM=adhoc; TABLE_NAME=V; COLUMN_NAME=name; DATA_TYPE=12; TYPE_NAME=JavaType(class java.lang.String); COLUMN_SIZE=-1; BUFFER_LENGTH=null; DECIMAL_DIGITS=null; NUM_PREC_RADIX=10; NULLABLE=1; REMARKS=null; COLUMN_DEF=null; SQL_DATA_TYPE=null; SQL_DATETIME_SUB=null; CHAR_OCTET_LENGTH=-1; ORDINAL_POSITION=3; IS_NULLABLE=YES; SCOPE_CATALOG=null; SCOPE_TABLE=null; SOURCE_DATA_TYPE=null; IS_AUTOINCREMENT=null; IS_GENERATEDCOLUMN=null\n"
operator|+
literal|"TABLE_CAT=null; TABLE_SCHEM=adhoc; TABLE_NAME=V; COLUMN_NAME=salary; DATA_TYPE=7; TYPE_NAME=JavaType(float) NOT NULL; COLUMN_SIZE=-1; BUFFER_LENGTH=null; DECIMAL_DIGITS=null; NUM_PREC_RADIX=10; NULLABLE=0; REMARKS=null; COLUMN_DEF=null; SQL_DATA_TYPE=null; SQL_DATETIME_SUB=null; CHAR_OCTET_LENGTH=-1; ORDINAL_POSITION=4; IS_NULLABLE=NO; SCOPE_CATALOG=null; SCOPE_TABLE=null; SOURCE_DATA_TYPE=null; IS_AUTOINCREMENT=null; IS_GENERATEDCOLUMN=null\n"
operator|+
literal|"TABLE_CAT=null; TABLE_SCHEM=adhoc; TABLE_NAME=V; COLUMN_NAME=commission; DATA_TYPE=4; TYPE_NAME=JavaType(class java.lang.Integer); COLUMN_SIZE=-1; BUFFER_LENGTH=null; DECIMAL_DIGITS=null; NUM_PREC_RADIX=10; NULLABLE=1; REMARKS=null; COLUMN_DEF=null; SQL_DATA_TYPE=null; SQL_DATETIME_SUB=null; CHAR_OCTET_LENGTH=-1; ORDINAL_POSITION=5; IS_NULLABLE=YES; SCOPE_CATALOG=null; SCOPE_TABLE=null; SOURCE_DATA_TYPE=null; IS_AUTOINCREMENT=null; IS_GENERATEDCOLUMN=null\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|metaData
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|"adhoc"
argument_list|,
literal|"V"
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// catalog
name|assertEquals
argument_list|(
literal|"TABLE_CATALOG=null\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|metaData
operator|.
name|getCatalogs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// schemas
name|assertEquals
argument_list|(
literal|"TABLE_SCHEM=adhoc; TABLE_CATALOG=null\n"
operator|+
literal|"TABLE_SCHEM=metadata; TABLE_CATALOG=null\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|metaData
operator|.
name|getSchemas
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// schemas (qualified)
name|assertEquals
argument_list|(
literal|"TABLE_SCHEM=adhoc; TABLE_CATALOG=null\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|metaData
operator|.
name|getSchemas
argument_list|(
literal|null
argument_list|,
literal|"adhoc"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// table types
name|assertEquals
argument_list|(
literal|"TABLE_TYPE=TABLE\n"
operator|+
literal|"TABLE_TYPE=VIEW\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|metaData
operator|.
name|getTableTypes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a view with ORDER BY and LIMIT clauses. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByView
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|modelWithView
argument_list|(
literal|"select * from \"EMPLOYEES\" where \"deptno\" = 10 "
operator|+
literal|"order by \"empid\" limit 2"
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"name\" from \"adhoc\".V order by \"name\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"name=Bill\n"
operator|+
literal|"name=Theodore\n"
argument_list|)
expr_stmt|;
comment|// Now a sub-query with ORDER BY and LIMIT clauses. (Same net effect, but
comment|// ORDER BY and LIMIT in sub-query were not standard SQL until SQL:2008.)
name|with
operator|.
name|query
argument_list|(
literal|"select \"name\" from (\n"
operator|+
literal|"select * from \"adhoc\".\"EMPLOYEES\" where \"deptno\" = 10\n"
operator|+
literal|"order by \"empid\" limit 2)\n"
operator|+
literal|"order by \"name\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"name=Bill\n"
operator|+
literal|"name=Theodore\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests saving query results into temporary tables, per    * {@link net.hydromatic.avatica.Handler.ResultSink}. */
annotation|@
name|Test
specifier|public
name|void
name|testAutomaticTemporaryTable
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|objects
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
operator|new
name|OptiqAssert
operator|.
name|ConnectionFactory
argument_list|()
block|{
specifier|public
name|OptiqConnection
name|createConnection
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqConnection
name|connection
init|=
operator|(
name|OptiqConnection
operator|)
operator|new
name|AutoTempDriver
argument_list|(
name|objects
argument_list|)
operator|.
name|connect
argument_list|(
literal|"jdbc:optiq:"
argument_list|,
operator|new
name|Properties
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|connection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setSchema
argument_list|(
literal|"hr"
argument_list|)
expr_stmt|;
return|return
name|connection
return|;
block|}
block|}
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|OptiqConnection
name|a0
parameter_list|)
block|{
try|try
block|{
name|a0
operator|.
name|createStatement
argument_list|()
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"hr\".\"emps\" "
operator|+
literal|"where \"deptno\" = 10"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|objects
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|OptiqAssert
operator|.
name|AssertThat
name|withUdf
parameter_list|()
block|{
return|return
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc',\n"
operator|+
literal|"       tables: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'EMPLOYEES',\n"
operator|+
literal|"           type: 'custom',\n"
operator|+
literal|"           factory: '"
operator|+
name|EmpDeptTableFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"',\n"
operator|+
literal|"           operand: {'foo': true, 'bar': 345}\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ],\n"
operator|+
literal|"       functions: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'MY_PLUS',\n"
operator|+
literal|"           className: '"
operator|+
name|MyPlusFunction
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"'\n"
operator|+
literal|"         },\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'MY_STR',\n"
operator|+
literal|"           className: '"
operator|+
name|MyToStringFunction
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"'\n"
operator|+
literal|"         },\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'MY_DOUBLE',\n"
operator|+
literal|"           className: '"
operator|+
name|MyDoubleFunction
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"'\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
return|;
block|}
comment|/** Tests user-defined function. */
annotation|@
name|Test
specifier|public
name|void
name|testUserDefinedFunction
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|withUdf
argument_list|()
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"adhoc\".my_plus(\"deptno\", 100) as p from \"adhoc\".EMPLOYEES"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=110\n"
operator|+
literal|"P=120\n"
operator|+
literal|"P=110\n"
operator|+
literal|"P=110\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"adhoc\".my_double(\"deptno\") as p from \"adhoc\".EMPLOYEES"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=20\n"
operator|+
literal|"P=40\n"
operator|+
literal|"P=20\n"
operator|+
literal|"P=20\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that IS NULL/IS NOT NULL is properly implemented for non-strict    * functions.    */
annotation|@
name|Test
specifier|public
name|void
name|testNotNullImplementor
parameter_list|()
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|withUdf
argument_list|()
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select upper(\"adhoc\".my_str(\"name\")) as p from \"adhoc\".EMPLOYEES"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=<BILL>\n"
operator|+
literal|"P=<ERIC>\n"
operator|+
literal|"P=<SEBASTIAN>\n"
operator|+
literal|"P=<THEODORE>\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"name\" as p from \"adhoc\".EMPLOYEES\n"
operator|+
literal|"where \"adhoc\".my_str(\"name\") is not null"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=Bill\n"
operator|+
literal|"P=Eric\n"
operator|+
literal|"P=Sebastian\n"
operator|+
literal|"P=Theodore\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"name\" as p from \"adhoc\".EMPLOYEES\n"
operator|+
literal|"where \"adhoc\".my_str(upper(\"name\")) is not null"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=Bill\n"
operator|+
literal|"P=Eric\n"
operator|+
literal|"P=Sebastian\n"
operator|+
literal|"P=Theodore\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"name\" as p from \"adhoc\".EMPLOYEES\n"
operator|+
literal|"where upper(\"adhoc\".my_str(\"name\")) is not null"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=Bill\n"
operator|+
literal|"P=Eric\n"
operator|+
literal|"P=Sebastian\n"
operator|+
literal|"P=Theodore\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"name\" as p from \"adhoc\".EMPLOYEES\n"
operator|+
literal|"where \"adhoc\".my_str(\"name\") is null"
argument_list|)
operator|.
name|returns
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/** Tests derived return type of user-defined function. */
annotation|@
name|Test
specifier|public
name|void
name|testUdfDerivedReturnType
parameter_list|()
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|withUdf
argument_list|()
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select max(\"adhoc\".my_double(\"deptno\")) as p from \"adhoc\".EMPLOYEES"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=40\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select max(\"adhoc\".my_str(\"name\")) as p from \"adhoc\".EMPLOYEES\n"
operator|+
literal|"where \"adhoc\".my_str(\"name\") is null"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Test for {@link EigenbaseNewResource#requireDefaultConstructor(String)}. */
annotation|@
name|Test
specifier|public
name|void
name|testUserDefinedFunction2
parameter_list|()
throws|throws
name|Exception
block|{
name|withBadUdf
argument_list|(
name|AwkwardFunction
operator|.
name|class
argument_list|)
operator|.
name|connectThrows
argument_list|(
literal|"Declaring class 'net.hydromatic.optiq.test.JdbcTest$AwkwardFunction' of non-static user-defined function must have a public constructor with zero parameters"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests user-defined aggregate function. */
annotation|@
name|Test
specifier|public
name|void
name|testUserDefinedAggregateFunction
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|empDept
init|=
name|EmpDeptTableFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sum
init|=
name|MyStaticSumFunction
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sum2
init|=
name|MySumFunction
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc',\n"
operator|+
literal|"       tables: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'EMPLOYEES',\n"
operator|+
literal|"           type: 'custom',\n"
operator|+
literal|"           factory: '"
operator|+
name|empDept
operator|+
literal|"',\n"
operator|+
literal|"           operand: {'foo': true, 'bar': 345}\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ],\n"
operator|+
literal|"       functions: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'MY_SUM',\n"
operator|+
literal|"           className: '"
operator|+
name|sum
operator|+
literal|"'\n"
operator|+
literal|"         },\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'MY_SUM2',\n"
operator|+
literal|"           className: '"
operator|+
name|sum2
operator|+
literal|"'\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
operator|.
name|withSchema
argument_list|(
literal|"adhoc"
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select my_sum(\"empid\"), \"deptno\" as p from EMPLOYEES\n"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Expression 'deptno' is not being grouped"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select my_sum(\"deptno\") as p from EMPLOYEES\n"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=50\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select my_sum(\"name\") as p from EMPLOYEES\n"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Cannot apply 'MY_SUM' to arguments of type 'MY_SUM(<JAVATYPE(CLASS JAVA.LANG.STRING)>)'. Supported form(s): 'MY_SUM(<NUMERIC>)"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select my_sum(\"deptno\", 1) as p from EMPLOYEES\n"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Invalid number of arguments to function 'MY_SUM'. Was expecting 1 arguments"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select my_sum() as p from EMPLOYEES\n"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Invalid number of arguments to function 'MY_SUM'. Was expecting 1 arguments"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"deptno\", my_sum(\"deptno\") as p from EMPLOYEES\n"
operator|+
literal|"group by \"deptno\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"deptno=20; P=20"
argument_list|,
literal|"deptno=10; P=30"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"deptno\", my_sum2(\"deptno\") as p from EMPLOYEES\n"
operator|+
literal|"group by \"deptno\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"deptno=20; P=20"
argument_list|,
literal|"deptno=10; P=30"
argument_list|)
expr_stmt|;
block|}
comment|/** Test for {@link EigenbaseNewResource#initAddWrongParamTypes(String)}. */
annotation|@
name|Test
specifier|public
name|void
name|testUserDefinedAggregateFunction2
parameter_list|()
throws|throws
name|Exception
block|{
name|Util
operator|.
name|discard
argument_list|(
name|EigenbaseNewResource
operator|.
name|class
argument_list|)
expr_stmt|;
name|withBadUdf
argument_list|(
name|SumFunctionBadInitAdd
operator|.
name|class
argument_list|)
operator|.
name|connectThrows
argument_list|(
literal|"In user-defined aggregate class 'net.hydromatic.optiq.test.JdbcTest$SumFunctionBadInitAdd', parameter types of 'initAdd' method must be same as value type(s)"
argument_list|)
expr_stmt|;
block|}
comment|/** Test for {@link EigenbaseNewResource#firstParameterOfAdd(String)}. */
annotation|@
name|Test
specifier|public
name|void
name|testUserDefinedAggregateFunction3
parameter_list|()
throws|throws
name|Exception
block|{
name|withBadUdf
argument_list|(
name|SumFunctionBadIAdd
operator|.
name|class
argument_list|)
operator|.
name|connectThrows
argument_list|(
literal|"Caused by: java.lang.RuntimeException: In user-defined aggregate class 'net.hydromatic.optiq.test.JdbcTest$SumFunctionBadIAdd', first parameter to 'add' method must be the accumulator (the return type of the 'init' method)"
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|OptiqAssert
operator|.
name|AssertThat
name|withBadUdf
parameter_list|(
name|Class
name|clazz
parameter_list|)
block|{
specifier|final
name|String
name|empDept
init|=
name|EmpDeptTableFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|className
init|=
name|clazz
operator|.
name|getName
argument_list|()
decl_stmt|;
return|return
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc',\n"
operator|+
literal|"       tables: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'EMPLOYEES',\n"
operator|+
literal|"           type: 'custom',\n"
operator|+
literal|"           factory: '"
operator|+
name|empDept
operator|+
literal|"',\n"
operator|+
literal|"           operand: {'foo': true, 'bar': 345}\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ],\n"
operator|+
literal|"       functions: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'AWKWARD',\n"
operator|+
literal|"           className: '"
operator|+
name|className
operator|+
literal|"'\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
operator|.
name|withSchema
argument_list|(
literal|"adhoc"
argument_list|)
return|;
block|}
comment|/** Tests resolution of functions using schema paths. */
annotation|@
name|Test
specifier|public
name|void
name|testPath
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|name
init|=
name|MyPlusFunction
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
literal|"{\n"
operator|+
literal|"  version: '1.0',\n"
operator|+
literal|"   schemas: [\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc',\n"
operator|+
literal|"       functions: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'MY_PLUS',\n"
operator|+
literal|"           className: '"
operator|+
name|name
operator|+
literal|"'\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     },\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc2',\n"
operator|+
literal|"       functions: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'MY_PLUS2',\n"
operator|+
literal|"           className: '"
operator|+
name|name
operator|+
literal|"'\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     },\n"
operator|+
literal|"     {\n"
operator|+
literal|"       name: 'adhoc3',\n"
operator|+
literal|"       path: ['adhoc2','adhoc3'],\n"
operator|+
literal|"       functions: [\n"
operator|+
literal|"         {\n"
operator|+
literal|"           name: 'MY_PLUS3',\n"
operator|+
literal|"           className: '"
operator|+
name|name
operator|+
literal|"'\n"
operator|+
literal|"         }\n"
operator|+
literal|"       ]\n"
operator|+
literal|"     }\n"
operator|+
literal|"   ]\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|err
init|=
literal|"No match found for function signature"
decl_stmt|;
specifier|final
name|String
name|res
init|=
literal|"EXPR$0=2\n"
decl_stmt|;
comment|// adhoc can see own function MY_PLUS but not adhoc2.MY_PLUS2 unless
comment|// qualified
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|adhoc
init|=
name|with
operator|.
name|withSchema
argument_list|(
literal|"adhoc"
argument_list|)
decl_stmt|;
name|adhoc
operator|.
name|query
argument_list|(
literal|"values MY_PLUS(1, 1)"
argument_list|)
operator|.
name|returns
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|adhoc
operator|.
name|query
argument_list|(
literal|"values MY_PLUS2(1, 1)"
argument_list|)
operator|.
name|throws_
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|adhoc
operator|.
name|query
argument_list|(
literal|"values \"adhoc2\".MY_PLUS(1, 1)"
argument_list|)
operator|.
name|throws_
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|adhoc
operator|.
name|query
argument_list|(
literal|"values \"adhoc2\".MY_PLUS2(1, 1)"
argument_list|)
operator|.
name|returns
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|// adhoc2 can see own function MY_PLUS2 but not adhoc2.MY_PLUS unless
comment|// qualified
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|adhoc2
init|=
name|with
operator|.
name|withSchema
argument_list|(
literal|"adhoc2"
argument_list|)
decl_stmt|;
name|adhoc2
operator|.
name|query
argument_list|(
literal|"values MY_PLUS2(1, 1)"
argument_list|)
operator|.
name|returns
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|adhoc2
operator|.
name|query
argument_list|(
literal|"values MY_PLUS(1, 1)"
argument_list|)
operator|.
name|throws_
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|adhoc2
operator|.
name|query
argument_list|(
literal|"values \"adhoc\".MY_PLUS(1, 1)"
argument_list|)
operator|.
name|returns
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|// adhoc3 can see own adhoc2.MY_PLUS2 because in path, with or without
comment|// qualification, but can only see adhoc.MY_PLUS with qualification
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|adhoc3
init|=
name|with
operator|.
name|withSchema
argument_list|(
literal|"adhoc3"
argument_list|)
decl_stmt|;
name|adhoc3
operator|.
name|query
argument_list|(
literal|"values MY_PLUS2(1, 1)"
argument_list|)
operator|.
name|returns
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|adhoc3
operator|.
name|query
argument_list|(
literal|"values MY_PLUS(1, 1)"
argument_list|)
operator|.
name|throws_
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|adhoc3
operator|.
name|query
argument_list|(
literal|"values \"adhoc\".MY_PLUS(1, 1)"
argument_list|)
operator|.
name|returns
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExplain
parameter_list|()
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"explain plan for values (1, 'ab')"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"PLAN=EnumerableValuesRel(tuples=[[{ 1, 'ab' }]])\n\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"explain plan with implementation for values (1, 'ab')"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"PLAN=EnumerableValuesRel(tuples=[[{ 1, 'ab' }]])\n\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"explain plan without implementation for values (1, 'ab')"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"PLAN=ValuesRel(tuples=[[{ 1, 'ab' }]])\n\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"explain plan with type for values (1, 'ab')"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"PLAN=EXPR$0 INTEGER NOT NULL,\n"
operator|+
literal|"EXPR$1 CHAR(2) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for bug where if two tables have different element classes    * but those classes have identical fields, Optiq would generate code to use    * the wrong element class; a {@link ClassCastException} would ensue. */
annotation|@
name|Test
specifier|public
name|void
name|testDifferentTypesSameFields
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
operator|.
name|forName
argument_list|(
literal|"net.hydromatic.optiq.jdbc.Driver"
argument_list|)
expr_stmt|;
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:optiq:"
argument_list|)
decl_stmt|;
name|OptiqConnection
name|optiqConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|OptiqConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|optiqConnection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"TEST"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
literal|"TEST"
argument_list|,
operator|new
name|MySchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Statement
name|statement
init|=
name|optiqConnection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"SELECT \"myvalue\" from TEST.\"mytable2\""
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"myvalue=2\n"
argument_list|,
name|OptiqAssert
operator|.
name|toString
argument_list|(
name|resultSet
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that CURRENT_TIMESTAMP gives different values each time a statement    * is executed. */
annotation|@
name|Test
specifier|public
name|void
name|testCurrentTimestamp
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"timezone"
argument_list|,
literal|"GMT+1:00"
argument_list|)
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
specifier|final
name|PreparedStatement
name|statement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
literal|"VALUES CURRENT_TIMESTAMP"
argument_list|)
decl_stmt|;
name|ResultSet
name|resultSet
decl_stmt|;
name|resultSet
operator|=
name|statement
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|s0
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|resultSet
operator|=
name|statement
operator|.
name|executeQuery
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|s1
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"\n"
operator|+
literal|"s0="
operator|+
name|s0
operator|+
literal|"\n"
operator|+
literal|"s1="
operator|+
name|s1
operator|+
literal|"\n"
argument_list|,
name|s0
operator|.
name|compareTo
argument_list|(
name|s1
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Test for timestamps and time zones, based on pgsql TimezoneTest. */
annotation|@
name|Test
specifier|public
name|void
name|testGetTimestamp
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"timezone"
argument_list|,
literal|"GMT+1:00"
argument_list|)
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|checkGetTimestamp
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkGetTimestamp
parameter_list|(
name|Connection
name|con
parameter_list|)
throws|throws
name|SQLException
block|{
name|Statement
name|statement
init|=
name|con
operator|.
name|createStatement
argument_list|()
decl_stmt|;
comment|// Not supported yet. We set timezone using connect-string parameters.
comment|//statement.executeUpdate("alter session set timezone = 'gmt-3'");
name|ResultSet
name|rs
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"SELECT * FROM (VALUES(\n"
operator|+
literal|" TIMESTAMP '1970-01-01 00:00:00',\n"
operator|+
literal|" /* TIMESTAMP '2005-01-01 15:00:00 +0300', */\n"
operator|+
literal|" TIMESTAMP '2005-01-01 15:00:00',\n"
operator|+
literal|" TIME '15:00:00',\n"
operator|+
literal|" /* TIME '15:00:00 +0300', */\n"
operator|+
literal|" DATE '2005-01-01'\n"
operator|+
literal|")) AS t(ts0, /* tstz, */ ts, t, /* tz, */ d)"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|TimeZone
name|tzUtc
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
decl_stmt|;
comment|// +0000 always
name|TimeZone
name|tzGmt03
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT+03"
argument_list|)
decl_stmt|;
comment|// +0300 always
name|TimeZone
name|tzGmt05
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT-05"
argument_list|)
decl_stmt|;
comment|// -0500 always
name|TimeZone
name|tzGmt13
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT+13"
argument_list|)
decl_stmt|;
comment|// +1000 always
name|Calendar
name|cUtc
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|tzUtc
argument_list|)
decl_stmt|;
name|Calendar
name|cGmt03
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|tzGmt03
argument_list|)
decl_stmt|;
name|Calendar
name|cGmt05
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|tzGmt05
argument_list|)
decl_stmt|;
name|Calendar
name|cGmt13
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|tzGmt13
argument_list|)
decl_stmt|;
name|Timestamp
name|ts
decl_stmt|;
name|String
name|s
decl_stmt|;
name|int
name|c
init|=
literal|1
decl_stmt|;
comment|// timestamp: 1970-01-01 00:00:00
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// Convert timestamp to +0100
name|assertEquals
argument_list|(
operator|-
literal|3600000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 00:00:00 +0100
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cUtc
argument_list|)
expr_stmt|;
comment|// Convert timestamp to UTC
name|assertEquals
argument_list|(
literal|0L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 00:00:00 +0000
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt03
argument_list|)
expr_stmt|;
comment|// Convert timestamp to +0300
name|assertEquals
argument_list|(
operator|-
literal|10800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 00:00:00 +0300
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt05
argument_list|)
expr_stmt|;
comment|// Convert timestamp to -0500
name|assertEquals
argument_list|(
literal|18000000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 00:00:00 -0500
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt13
argument_list|)
expr_stmt|;
comment|// Convert timestamp to +1300
name|assertEquals
argument_list|(
operator|-
literal|46800000
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 00:00:00 +1300
name|s
operator|=
name|rs
operator|.
name|getString
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1970-01-01 00:00:00"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
comment|// timestamptz: 2005-01-01 15:00:00+03
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// Represents an instant in
comment|// time, TZ is irrelevant.
name|assertEquals
argument_list|(
literal|1104580800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 12:00:00 UTC
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cUtc
argument_list|)
expr_stmt|;
comment|// TZ irrelevant, as above
name|assertEquals
argument_list|(
literal|1104580800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 12:00:00 UTC
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt03
argument_list|)
expr_stmt|;
comment|// TZ irrelevant, as above
name|assertEquals
argument_list|(
literal|1104580800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 12:00:00 UTC
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt05
argument_list|)
expr_stmt|;
comment|// TZ irrelevant, as above
name|assertEquals
argument_list|(
literal|1104580800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 12:00:00 UTC
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt13
argument_list|)
expr_stmt|;
comment|// TZ irrelevant, as above
name|assertEquals
argument_list|(
literal|1104580800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 12:00:00 UTC
operator|++
name|c
expr_stmt|;
block|}
comment|// timestamp: 2005-01-01 15:00:00
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// Convert timestamp to +0100
name|assertEquals
argument_list|(
literal|1104588000000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 15:00:00 +0100
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cUtc
argument_list|)
expr_stmt|;
comment|// Convert timestamp to UTC
name|assertEquals
argument_list|(
literal|1104591600000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 15:00:00 +0000
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt03
argument_list|)
expr_stmt|;
comment|// Convert timestamp to +0300
name|assertEquals
argument_list|(
literal|1104580800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 15:00:00 +0300
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt05
argument_list|)
expr_stmt|;
comment|// Convert timestamp to -0500
name|assertEquals
argument_list|(
literal|1104609600000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 15:00:00 -0500
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt13
argument_list|)
expr_stmt|;
comment|// Convert timestamp to +1300
name|assertEquals
argument_list|(
literal|1104544800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 15:00:00 +1300
name|s
operator|=
name|rs
operator|.
name|getString
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2005-01-01 15:00:00"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
comment|// time: 15:00:00
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|50400000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +0100
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cUtc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|54000000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +0000
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt03
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|43200000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +0300
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt05
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|72000000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 -0500
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt13
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7200000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +1300
name|s
operator|=
name|rs
operator|.
name|getString
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"15:00:00"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
comment|// timetz: 15:00:00+03
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|43200000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +0300 ->
comment|// 1970-01-01 13:00:00 +0100
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cUtc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|43200000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +0300 ->
comment|// 1970-01-01 12:00:00 +0000
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt03
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|43200000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +0300 ->
comment|// 1970-01-01 15:00:00 +0300
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt05
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|43200000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +0300 ->
comment|// 1970-01-01 07:00:00 -0500
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt13
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|43200000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1970-01-01 15:00:00 +0300 ->
comment|// 1970-01-02 01:00:00 +1300
operator|++
name|c
expr_stmt|;
block|}
comment|// date: 2005-01-01
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1104534000000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 00:00:00 +0100
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cUtc
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1104537600000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 00:00:00 +0000
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt03
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1104526800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 00:00:00 +0300
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt05
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1104555600000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 00:00:00 -0500
name|ts
operator|=
name|rs
operator|.
name|getTimestamp
argument_list|(
name|c
argument_list|,
name|cGmt13
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1104490800000L
argument_list|,
name|ts
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2005-01-01 00:00:00 +1300
name|s
operator|=
name|rs
operator|.
name|getString
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2005-01-01"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|// 2005-01-01 00:00:00 +0100
operator|++
name|c
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Tests accessing a column in a JDBC source whose type is DATE. */
annotation|@
name|Test
specifier|public
name|void
name|testGetDate
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|OptiqConnection
name|conn
parameter_list|)
block|{
try|try
block|{
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select min(\"date\") mindate from \"foodmart\".\"currency\""
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Date
operator|.
name|valueOf
argument_list|(
literal|"1997-01-01"
argument_list|)
argument_list|,
name|rs
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests accessing a date as a string in a JDBC source whose type is DATE. */
annotation|@
name|Test
specifier|public
name|void
name|testGetDateAsString
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|query
argument_list|(
literal|"select min(\"date\") mindate from \"foodmart\".\"currency\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"MINDATE=1997-01-01\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetTimestampObject
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|OptiqConnection
name|conn
parameter_list|)
block|{
try|try
block|{
name|Statement
name|stmt
init|=
name|conn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|rs
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
literal|"select \"hire_date\" from \"foodmart\".\"employee\" where \"employee_id\" = 1"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|Timestamp
operator|.
name|valueOf
argument_list|(
literal|"1994-12-01 00:00:00"
argument_list|)
argument_list|,
name|rs
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|rs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnicode
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|FOODMART_CLONE
argument_list|)
decl_stmt|;
comment|// Note that \u82f1 in a Java string is a Java unicode escape;
comment|// But \\82f1 in a SQL string is a SQL unicode escape.
comment|// various ways to create a unicode string literal
name|with
operator|.
name|query
argument_list|(
literal|"values _UTF16'\u82f1\u56fd'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EXPR$0=\u82f1\u56fd\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"values U&'\\82F1\\56FD'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EXPR$0=\u82f1\u56fd\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"values u&'\\82f1\\56fd'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EXPR$0=\u82f1\u56fd\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"values '\u82f1\u56fd'"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Failed to encode '\u82f1\u56fd' in character set 'ISO-8859-1'"
argument_list|)
expr_stmt|;
comment|// comparing a unicode string literal with a regular string literal
name|with
operator|.
name|query
argument_list|(
literal|"select * from \"employee\" where \"full_name\" = '\u82f1\u56fd'"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Failed to encode '\u82f1\u56fd' in character set 'ISO-8859-1'"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select * from \"employee\" where \"full_name\" = _UTF16'\u82f1\u56fd'"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Cannot apply = to the two different charsets ISO-8859-1 and UTF-16LE"
argument_list|)
expr_stmt|;
comment|// The CONVERT function (what SQL:2011 calls "character transliteration") is
comment|// not implemented yet. See https://github.com/julianhyde/optiq/issues/111.
name|with
operator|.
name|query
argument_list|(
literal|"select * from \"employee\"\n"
operator|+
literal|"where convert(\"full_name\" using UTF16) = _UTF16'\u82f1\u56fd'"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Column 'UTF16' not found in any table"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests metadata for the MySQL lexical scheme. */
annotation|@
name|Test
specifier|public
name|void
name|testLexMySQL
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"lex"
argument_list|,
literal|"MYSQL"
argument_list|)
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|DatabaseMetaData
name|metaData
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getIdentifierQuoteString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"`"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests metadata for different the "SQL_SERVER" lexical scheme. */
annotation|@
name|Test
specifier|public
name|void
name|testLexSqlServer
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"lex"
argument_list|,
literal|"SQL_SERVER"
argument_list|)
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|DatabaseMetaData
name|metaData
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getIdentifierQuoteString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"["
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests metadata for the ORACLE (and default) lexical scheme. */
annotation|@
name|Test
specifier|public
name|void
name|testLexOracle
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"lex"
argument_list|,
literal|"ORACLE"
argument_list|)
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|DatabaseMetaData
name|metaData
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getIdentifierQuoteString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"\""
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Oracle JDBC 12.1.0.1.0 returns true here, however it is
comment|// not clear if the bug is in JDBC specification or Oracle
comment|// driver
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests metadata for the JAVA lexical scheme. */
annotation|@
name|Test
specifier|public
name|void
name|testLexJava
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"lex"
argument_list|,
literal|"JAVA"
argument_list|)
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|DatabaseMetaData
name|metaData
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getIdentifierQuoteString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"`"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests metadata for the ORACLE lexical scheme overriden like JAVA. */
annotation|@
name|Test
specifier|public
name|void
name|testLexOracleAsJava
parameter_list|()
throws|throws
name|Exception
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|builder
argument_list|()
operator|.
name|put
argument_list|(
literal|"lex"
argument_list|,
literal|"ORACLE"
argument_list|)
operator|.
name|put
argument_list|(
literal|"quoting"
argument_list|,
literal|"BACK_TICK"
argument_list|)
operator|.
name|put
argument_list|(
literal|"unquotedCasing"
argument_list|,
literal|"UNCHANGED"
argument_list|)
operator|.
name|put
argument_list|(
literal|"quotedCasing"
argument_list|,
literal|"UNCHANGED"
argument_list|)
operator|.
name|put
argument_list|(
literal|"caseSensitive"
argument_list|,
literal|"TRUE"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|doWithConnection
argument_list|(
operator|new
name|Function1
argument_list|<
name|OptiqConnection
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|OptiqConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|DatabaseMetaData
name|metaData
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getIdentifierQuoteString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"`"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|supportsMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesMixedCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesUpperCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|storesLowerCaseQuotedIdentifiers
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Tests case-insensitive resolution of schema and table names. */
annotation|@
name|Test
specifier|public
name|void
name|testLexCaseInsensitive
parameter_list|()
block|{
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"lex"
argument_list|,
literal|"MYSQL"
argument_list|)
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select COUNT(*) as c from metaData.tAbles"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"c=3\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select COUNT(*) as c from `metaData`.`tAbles`"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"c=3\n"
argument_list|)
expr_stmt|;
comment|// case-sensitive gives error
specifier|final
name|OptiqAssert
operator|.
name|AssertThat
name|with2
init|=
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"lex"
argument_list|,
literal|"JAVA"
argument_list|)
argument_list|)
decl_stmt|;
name|with2
operator|.
name|query
argument_list|(
literal|"select COUNT(*) as c from `metaData`.`tAbles`"
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Table 'metaData.tAbles' not found"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that {@link Hook#PARSE_TREE} works. */
annotation|@
name|Test
specifier|public
name|void
name|testHook
parameter_list|()
block|{
specifier|final
name|int
index|[]
name|callCount
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|final
name|Hook
operator|.
name|Closeable
name|hook
init|=
name|Hook
operator|.
name|PARSE_TREE
operator|.
name|addThread
argument_list|(
operator|new
name|Function1
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|Object
name|a0
parameter_list|)
block|{
name|Object
index|[]
name|args
init|=
operator|(
name|Object
index|[]
operator|)
name|a0
decl_stmt|;
name|assertThat
argument_list|(
name|args
operator|.
name|length
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|instanceOf
argument_list|(
name|String
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
operator|(
name|String
operator|)
name|args
index|[
literal|0
index|]
argument_list|,
name|equalTo
argument_list|(
literal|"select \"deptno\", \"commission\", sum(\"salary\") s\n"
operator|+
literal|"from \"hr\".\"emps\"\n"
operator|+
literal|"group by \"deptno\", \"commission\""
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|instanceOf
argument_list|(
name|SqlSelect
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|callCount
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Simple query does not run the hook.
name|testSimple
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|callCount
index|[
literal|0
index|]
argument_list|,
name|equalTo
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Non-trivial query runs hook once.
name|testGroupByNull
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|callCount
index|[
literal|0
index|]
argument_list|,
name|equalTo
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|hook
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Tests {@link SqlDialect}. */
annotation|@
name|Test
specifier|public
name|void
name|testDialect
parameter_list|()
block|{
specifier|final
name|String
index|[]
name|sqls
init|=
block|{
literal|null
block|}
decl_stmt|;
specifier|final
name|Hook
operator|.
name|Closeable
name|hook
init|=
name|Hook
operator|.
name|QUERY_PLAN
operator|.
name|addThread
argument_list|(
operator|new
name|Function1
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|apply
parameter_list|(
name|Object
name|a0
parameter_list|)
block|{
name|String
name|sql
init|=
operator|(
name|String
operator|)
name|a0
decl_stmt|;
name|sqls
index|[
literal|0
index|]
operator|=
name|sql
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
decl_stmt|;
try|try
block|{
name|OptiqAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|OptiqAssert
operator|.
name|Config
operator|.
name|JDBC_FOODMART
argument_list|)
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"foodmart\".\"employee\" as e1\n"
operator|+
literal|"  where \"first_name\" = 'abcde'\n"
operator|+
literal|"  and \"gender\" = 'F'"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=0\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OptiqAssert
operator|.
name|CONNECTION_SPEC
condition|)
block|{
case|case
name|HSQLDB
case|:
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|sqls
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"SELECT COUNT(*) AS \"C\"\n"
operator|+
literal|"FROM (SELECT 0 AS \"DUMMY\"\n"
operator|+
literal|"FROM \"foodmart\".\"employee\"\n"
operator|+
literal|"WHERE \"first_name\" = 'abcde' AND \"gender\" = 'F') AS \"t0\""
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
finally|finally
block|{
name|hook
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Disable checkstyle, so it doesn't complain about fields like "customer_id".
comment|//CHECKSTYLE: OFF
specifier|public
specifier|static
class|class
name|HrSchema
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"HrSchema"
return|;
block|}
specifier|public
specifier|final
name|Employee
index|[]
name|emps
init|=
block|{
operator|new
name|Employee
argument_list|(
literal|100
argument_list|,
literal|10
argument_list|,
literal|"Bill"
argument_list|,
literal|10000
argument_list|,
literal|1000
argument_list|)
block|,
operator|new
name|Employee
argument_list|(
literal|200
argument_list|,
literal|20
argument_list|,
literal|"Eric"
argument_list|,
literal|8000
argument_list|,
literal|500
argument_list|)
block|,
operator|new
name|Employee
argument_list|(
literal|150
argument_list|,
literal|10
argument_list|,
literal|"Sebastian"
argument_list|,
literal|7000
argument_list|,
literal|null
argument_list|)
block|,
operator|new
name|Employee
argument_list|(
literal|110
argument_list|,
literal|10
argument_list|,
literal|"Theodore"
argument_list|,
literal|11500
argument_list|,
literal|250
argument_list|)
block|,     }
decl_stmt|;
specifier|public
specifier|final
name|Department
index|[]
name|depts
init|=
block|{
operator|new
name|Department
argument_list|(
literal|10
argument_list|,
literal|"Sales"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|emps
index|[
literal|0
index|]
argument_list|,
name|emps
index|[
literal|2
index|]
argument_list|)
argument_list|)
block|,
operator|new
name|Department
argument_list|(
literal|30
argument_list|,
literal|"Marketing"
argument_list|,
name|Collections
operator|.
expr|<
name|Employee
operator|>
name|emptyList
argument_list|()
argument_list|)
block|,
operator|new
name|Department
argument_list|(
literal|40
argument_list|,
literal|"HR"
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|emps
index|[
literal|1
index|]
argument_list|)
argument_list|)
block|,     }
decl_stmt|;
specifier|public
name|Table
name|foo
parameter_list|(
name|int
name|count
parameter_list|)
block|{
return|return
name|generateStrings
argument_list|(
name|count
argument_list|)
return|;
block|}
specifier|public
name|Table
name|view
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|JdbcTest
operator|.
name|view
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|Table
name|view
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|new
name|ViewTable
argument_list|(
name|Object
operator|.
name|class
argument_list|,
operator|new
name|RelProtoDataType
argument_list|()
block|{
specifier|public
name|RelDataType
name|apply
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
argument_list|,
literal|"values (1), (3), "
operator|+
name|s
argument_list|,
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
class|class
name|Employee
block|{
specifier|public
specifier|final
name|int
name|empid
decl_stmt|;
specifier|public
specifier|final
name|int
name|deptno
decl_stmt|;
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
specifier|public
specifier|final
name|float
name|salary
decl_stmt|;
specifier|public
specifier|final
name|Integer
name|commission
decl_stmt|;
specifier|public
name|Employee
parameter_list|(
name|int
name|empid
parameter_list|,
name|int
name|deptno
parameter_list|,
name|String
name|name
parameter_list|,
name|float
name|salary
parameter_list|,
name|Integer
name|commission
parameter_list|)
block|{
name|this
operator|.
name|empid
operator|=
name|empid
expr_stmt|;
name|this
operator|.
name|deptno
operator|=
name|deptno
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|salary
operator|=
name|salary
expr_stmt|;
name|this
operator|.
name|commission
operator|=
name|commission
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Employee [empid: "
operator|+
name|empid
operator|+
literal|", deptno: "
operator|+
name|deptno
operator|+
literal|", name: "
operator|+
name|name
operator|+
literal|"]"
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|Department
block|{
specifier|public
specifier|final
name|int
name|deptno
decl_stmt|;
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
specifier|public
specifier|final
name|List
argument_list|<
name|Employee
argument_list|>
name|employees
decl_stmt|;
specifier|public
name|Department
parameter_list|(
name|int
name|deptno
parameter_list|,
name|String
name|name
parameter_list|,
name|List
argument_list|<
name|Employee
argument_list|>
name|employees
parameter_list|)
block|{
name|this
operator|.
name|deptno
operator|=
name|deptno
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|employees
operator|=
name|employees
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Department [deptno: "
operator|+
name|deptno
operator|+
literal|", name: "
operator|+
name|name
operator|+
literal|", employees: "
operator|+
name|employees
operator|+
literal|"]"
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|FoodmartSchema
block|{
specifier|public
specifier|final
name|SalesFact
index|[]
name|sales_fact_1997
init|=
block|{
operator|new
name|SalesFact
argument_list|(
literal|100
argument_list|,
literal|10
argument_list|)
block|,
operator|new
name|SalesFact
argument_list|(
literal|150
argument_list|,
literal|20
argument_list|)
block|,     }
decl_stmt|;
block|}
specifier|public
specifier|static
class|class
name|LingualSchema
block|{
specifier|public
specifier|final
name|LingualEmp
index|[]
name|EMPS
init|=
block|{
operator|new
name|LingualEmp
argument_list|(
literal|1
argument_list|,
literal|10
argument_list|)
block|,
operator|new
name|LingualEmp
argument_list|(
literal|2
argument_list|,
literal|30
argument_list|)
block|}
decl_stmt|;
block|}
specifier|public
specifier|static
class|class
name|LingualEmp
block|{
specifier|public
specifier|final
name|int
name|EMPNO
decl_stmt|;
specifier|public
specifier|final
name|int
name|DEPTNO
decl_stmt|;
specifier|public
name|LingualEmp
parameter_list|(
name|int
name|EMPNO
parameter_list|,
name|int
name|DEPTNO
parameter_list|)
block|{
name|this
operator|.
name|EMPNO
operator|=
name|EMPNO
expr_stmt|;
name|this
operator|.
name|DEPTNO
operator|=
name|DEPTNO
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
class|class
name|FoodmartJdbcSchema
extends|extends
name|JdbcSchema
block|{
specifier|public
name|FoodmartJdbcSchema
parameter_list|(
name|DataSource
name|dataSource
parameter_list|,
name|SqlDialect
name|dialect
parameter_list|,
name|JdbcConvention
name|convention
parameter_list|,
name|String
name|catalog
parameter_list|,
name|String
name|schema
parameter_list|)
block|{
name|super
argument_list|(
name|dataSource
argument_list|,
name|dialect
argument_list|,
name|convention
argument_list|,
name|catalog
argument_list|,
name|schema
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|final
name|Table
name|customer
init|=
name|getTable
argument_list|(
literal|"customer"
argument_list|)
decl_stmt|;
block|}
specifier|public
specifier|static
class|class
name|Customer
block|{
specifier|public
specifier|final
name|int
name|customer_id
decl_stmt|;
specifier|public
name|Customer
parameter_list|(
name|int
name|customer_id
parameter_list|)
block|{
name|this
operator|.
name|customer_id
operator|=
name|customer_id
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
class|class
name|SalesFact
block|{
specifier|public
specifier|final
name|int
name|cust_id
decl_stmt|;
specifier|public
specifier|final
name|int
name|prod_id
decl_stmt|;
specifier|public
name|SalesFact
parameter_list|(
name|int
name|cust_id
parameter_list|,
name|int
name|prod_id
parameter_list|)
block|{
name|this
operator|.
name|cust_id
operator|=
name|cust_id
expr_stmt|;
name|this
operator|.
name|prod_id
operator|=
name|prod_id
expr_stmt|;
block|}
block|}
comment|//CHECKSTYLE: ON
specifier|public
specifier|static
class|class
name|IntString
block|{
specifier|public
specifier|final
name|int
name|n
decl_stmt|;
specifier|public
specifier|final
name|String
name|s
decl_stmt|;
specifier|public
name|IntString
parameter_list|(
name|int
name|n
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|n
operator|=
name|n
expr_stmt|;
name|this
operator|.
name|s
operator|=
name|s
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{n="
operator|+
name|n
operator|+
literal|", s="
operator|+
name|s
operator|+
literal|"}"
return|;
block|}
block|}
specifier|public
specifier|abstract
specifier|static
class|class
name|AbstractModifiableTable
extends|extends
name|AbstractTable
implements|implements
name|ModifiableTable
block|{
specifier|protected
name|AbstractModifiableTable
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|TableModificationRelBase
name|toModificationRel
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|table
parameter_list|,
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
parameter_list|,
name|RelNode
name|child
parameter_list|,
name|TableModificationRelBase
operator|.
name|Operation
name|operation
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|updateColumnList
parameter_list|,
name|boolean
name|flattened
parameter_list|)
block|{
return|return
operator|new
name|TableModificationRel
argument_list|(
name|cluster
argument_list|,
name|table
argument_list|,
name|catalogReader
argument_list|,
name|child
argument_list|,
name|operation
argument_list|,
name|updateColumnList
argument_list|,
name|flattened
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|EmpDeptTableFactory
implements|implements
name|TableFactory
argument_list|<
name|Table
argument_list|>
block|{
specifier|public
name|Table
name|create
parameter_list|(
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|name
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|operand
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
specifier|final
name|Class
name|clazz
decl_stmt|;
specifier|final
name|Object
index|[]
name|array
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"EMPLOYEES"
argument_list|)
condition|)
block|{
name|clazz
operator|=
name|Employee
operator|.
name|class
expr_stmt|;
name|array
operator|=
operator|new
name|HrSchema
argument_list|()
operator|.
name|emps
expr_stmt|;
block|}
else|else
block|{
name|clazz
operator|=
name|Department
operator|.
name|class
expr_stmt|;
name|array
operator|=
operator|new
name|HrSchema
argument_list|()
operator|.
name|depts
expr_stmt|;
block|}
return|return
operator|new
name|AbstractQueryableTable
argument_list|(
name|clazz
argument_list|)
block|{
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
operator|(
operator|(
name|JavaTypeFactory
operator|)
name|typeFactory
operator|)
operator|.
name|createType
argument_list|(
name|clazz
argument_list|)
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Queryable
argument_list|<
name|T
argument_list|>
name|asQueryable
parameter_list|(
name|QueryProvider
name|queryProvider
parameter_list|,
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
return|return
operator|new
name|AbstractTableQueryable
argument_list|<
name|T
argument_list|>
argument_list|(
name|queryProvider
argument_list|,
name|schema
argument_list|,
name|this
argument_list|,
name|tableName
argument_list|)
block|{
specifier|public
name|Enumerator
argument_list|<
name|T
argument_list|>
name|enumerator
parameter_list|()
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
operator|)
name|Arrays
operator|.
name|asList
argument_list|(
name|array
argument_list|)
decl_stmt|;
return|return
name|Linq4j
operator|.
name|enumerator
argument_list|(
name|list
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|MySchemaFactory
implements|implements
name|SchemaFactory
block|{
specifier|public
name|Schema
name|create
parameter_list|(
name|SchemaPlus
name|parentSchema
parameter_list|,
name|String
name|name
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|operand
parameter_list|)
block|{
specifier|final
name|boolean
name|mutable
init|=
name|SqlFunctions
operator|.
name|isNotFalse
argument_list|(
operator|(
name|Boolean
operator|)
name|operand
operator|.
name|get
argument_list|(
literal|"mutable"
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReflectiveSchema
argument_list|(
name|name
argument_list|,
operator|new
name|HrSchema
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
name|getTableMap
parameter_list|()
block|{
comment|// Mine the EMPS table and add it under another name e.g. ELVIS
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
name|tableMap
init|=
name|super
operator|.
name|getTableMap
argument_list|()
decl_stmt|;
specifier|final
name|Table
name|table
init|=
name|tableMap
operator|.
name|get
argument_list|(
literal|"emps"
argument_list|)
decl_stmt|;
specifier|final
name|String
name|tableName
init|=
operator|(
name|String
operator|)
name|operand
operator|.
name|get
argument_list|(
literal|"tableName"
argument_list|)
decl_stmt|;
return|return
name|ImmutableMap
operator|.
expr|<
name|String
operator|,
name|Table
operator|>
name|builder
argument_list|()
operator|.
name|putAll
argument_list|(
name|tableMap
argument_list|)
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|table
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isMutable
parameter_list|()
block|{
return|return
name|mutable
return|;
block|}
block|}
return|;
block|}
block|}
comment|/** Mock driver that has a handler that stores the results of each query in    * a temporary table. */
specifier|public
specifier|static
class|class
name|AutoTempDriver
extends|extends
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|Driver
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|results
decl_stmt|;
name|AutoTempDriver
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|results
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|results
operator|=
name|results
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Handler
name|createHandler
parameter_list|()
block|{
return|return
operator|new
name|HandlerImpl
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onStatementExecute
parameter_list|(
name|AvaticaStatement
name|statement
parameter_list|,
name|ResultSink
name|resultSink
parameter_list|)
block|{
name|super
operator|.
name|onStatementExecute
argument_list|(
name|statement
argument_list|,
name|resultSink
argument_list|)
expr_stmt|;
name|results
operator|.
name|add
argument_list|(
name|resultSink
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
block|}
comment|/** Mock driver that a given {@link Handler}. */
specifier|public
specifier|static
class|class
name|HandlerDriver
extends|extends
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|Driver
block|{
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Handler
argument_list|>
name|HANDLERS
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Handler
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|HandlerDriver
parameter_list|()
block|{
block|}
annotation|@
name|Override
specifier|protected
name|Handler
name|createHandler
parameter_list|()
block|{
return|return
name|HANDLERS
operator|.
name|get
argument_list|()
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|MyTable
block|{
specifier|public
name|String
name|mykey
init|=
literal|"foo"
decl_stmt|;
specifier|public
name|Integer
name|myvalue
init|=
literal|1
decl_stmt|;
block|}
specifier|public
specifier|static
class|class
name|MyTable2
block|{
specifier|public
name|String
name|mykey
init|=
literal|"foo"
decl_stmt|;
specifier|public
name|Integer
name|myvalue
init|=
literal|2
decl_stmt|;
block|}
specifier|public
specifier|static
class|class
name|MySchema
block|{
specifier|public
name|MyTable
index|[]
name|mytable
init|=
block|{
operator|new
name|MyTable
argument_list|()
block|}
decl_stmt|;
specifier|public
name|MyTable2
index|[]
name|mytable2
init|=
block|{
operator|new
name|MyTable2
argument_list|()
block|}
decl_stmt|;
block|}
comment|/** Example of a UDF with a non-static {@code eval} method. */
specifier|public
specifier|static
class|class
name|MyPlusFunction
block|{
specifier|public
name|int
name|eval
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
name|x
operator|+
name|y
return|;
block|}
block|}
comment|/** Example of a non-strict UDF. (Does something useful when passed NULL.) */
specifier|public
specifier|static
class|class
name|MyToStringFunction
block|{
specifier|public
specifier|static
name|String
name|eval
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|"<null>"
return|;
block|}
return|return
literal|"<"
operator|+
name|o
operator|.
name|toString
argument_list|()
operator|+
literal|">"
return|;
block|}
block|}
comment|/** Example of a UDF with a static {@code eval} method. Class is abstract,    * but code-generator should not need to instantiate it. */
specifier|public
specifier|abstract
specifier|static
class|class
name|MyDoubleFunction
block|{
specifier|private
name|MyDoubleFunction
parameter_list|()
block|{
block|}
specifier|public
specifier|static
name|int
name|eval
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
name|x
operator|*
literal|2
return|;
block|}
block|}
comment|/** Example of a UDF class that needs to be instantiated but cannot be. */
specifier|public
specifier|abstract
specifier|static
class|class
name|AwkwardFunction
block|{
specifier|private
name|AwkwardFunction
parameter_list|()
block|{
block|}
specifier|public
name|int
name|eval
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/** Example of a user-defined aggregate function (UDAF). */
specifier|public
specifier|static
class|class
name|MySumFunction
block|{
specifier|public
name|MySumFunction
parameter_list|()
block|{
block|}
specifier|public
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
name|long
name|initAdd
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
name|v
return|;
block|}
specifier|public
name|long
name|add
parameter_list|(
name|long
name|accumulator
parameter_list|,
name|int
name|v
parameter_list|)
block|{
return|return
name|accumulator
operator|+
name|v
return|;
block|}
specifier|public
name|long
name|merge
parameter_list|(
name|long
name|accumulator0
parameter_list|,
name|long
name|accumulator1
parameter_list|)
block|{
return|return
name|accumulator0
operator|+
name|accumulator1
return|;
block|}
specifier|public
name|long
name|result
parameter_list|(
name|long
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
comment|/** Example of a user-defined aggregate function (UDAF), whose methods are    * static. */
specifier|public
specifier|static
class|class
name|MyStaticSumFunction
block|{
specifier|public
specifier|static
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
specifier|static
name|long
name|initAdd
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
name|v
return|;
block|}
specifier|public
specifier|static
name|long
name|add
parameter_list|(
name|long
name|accumulator
parameter_list|,
name|int
name|v
parameter_list|)
block|{
return|return
name|accumulator
operator|+
name|v
return|;
block|}
specifier|public
specifier|static
name|long
name|merge
parameter_list|(
name|long
name|accumulator0
parameter_list|,
name|long
name|accumulator1
parameter_list|)
block|{
return|return
name|accumulator0
operator|+
name|accumulator1
return|;
block|}
specifier|public
specifier|static
name|long
name|result
parameter_list|(
name|long
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|SumFunctionBadInitAdd
block|{
specifier|public
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
name|long
name|initAdd
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
name|v
return|;
block|}
specifier|public
name|long
name|add
parameter_list|(
name|long
name|accumulator
parameter_list|,
name|long
name|v
parameter_list|)
block|{
return|return
name|accumulator
operator|+
name|v
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|SumFunctionBadIAdd
block|{
specifier|public
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
name|long
name|add
parameter_list|(
name|short
name|accumulator
parameter_list|,
name|int
name|v
parameter_list|)
block|{
return|return
name|accumulator
operator|+
name|v
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|TableMacroFunction
block|{
specifier|public
name|Table
name|eval
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|view
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|StaticTableMacroFunction
block|{
specifier|public
specifier|static
name|Table
name|eval
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|view
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End JdbcTest.java
end_comment

end_unit

