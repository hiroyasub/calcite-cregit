begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|config
operator|.
name|Lex
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|java
operator|.
name|ReflectiveSchema
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|jdbc
operator|.
name|*
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|jdbc
operator|.
name|JdbcRules
operator|.
name|JdbcProjectRel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|rules
operator|.
name|java
operator|.
name|EnumerableConvention
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|rules
operator|.
name|java
operator|.
name|JavaRules
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|rules
operator|.
name|java
operator|.
name|JavaRules
operator|.
name|EnumerableProjectRel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|test
operator|.
name|OptiqAssert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|convert
operator|.
name|ConverterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|util
operator|.
name|ChainedSqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|util
operator|.
name|ListSqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Unit tests for {@link Planner}.  */
end_comment

begin_class
specifier|public
class|class
name|PlannerTest
block|{
specifier|private
name|void
name|checkParseAndConvert
parameter_list|(
name|String
name|query
parameter_list|,
name|String
name|queryFromParseTree
parameter_list|,
name|String
name|expectedRelExpr
parameter_list|)
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|parse
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|queryFromParseTree
argument_list|)
argument_list|)
expr_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|rel
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|rel
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|expectedRelExpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testParseAndConvert
parameter_list|()
throws|throws
name|Exception
block|{
name|checkParseAndConvert
argument_list|(
literal|"select * from \"emps\" where \"name\" like '%e%'"
argument_list|,
literal|"SELECT *\n"
operator|+
literal|"FROM `emps`\n"
operator|+
literal|"WHERE `name` LIKE '%e%'"
argument_list|,
literal|"ProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  FilterRel(condition=[LIKE($2, '%e%')])\n"
operator|+
literal|"    EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates and converts the query using    * order by and offset. */
annotation|@
name|Test
specifier|public
name|void
name|testParseAndConvertWithOrderByAndOffset
parameter_list|()
throws|throws
name|Exception
block|{
name|checkParseAndConvert
argument_list|(
literal|"select * from \"emps\" "
operator|+
literal|"order by \"emps\".\"deptno\" offset 10"
argument_list|,
literal|"SELECT *\n"
operator|+
literal|"FROM `emps`\n"
operator|+
literal|"ORDER BY `emps`.`deptno`\n"
operator|+
literal|"OFFSET 10 ROWS"
argument_list|,
literal|"SortRel(sort0=[$1], dir0=[ASC], offset=[10])\n"
operator|+
literal|"  ProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"    EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|toString
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|Util
operator|.
name|toLinux
argument_list|(
name|RelOptUtil
operator|.
name|dumpPlan
argument_list|(
literal|""
argument_list|,
name|rel
argument_list|,
literal|false
argument_list|,
name|SqlExplainLevel
operator|.
name|DIGEST_ATTRIBUTES
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testParseFails
parameter_list|()
throws|throws
name|SqlParseException
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * * from \"emps\""
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|parse
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"Encountered \"*\" at line 1, column 10."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValidateFails
parameter_list|()
throws|throws
name|SqlParseException
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\" where \"Xname\" like '%e%'"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|parse
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"SELECT *\n"
operator|+
literal|"FROM `emps`\n"
operator|+
literal|"WHERE `Xname` LIKE '%e%'"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|validate
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ValidationException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|Util
operator|.
name|getStackTrace
argument_list|(
name|e
argument_list|)
argument_list|,
name|containsString
argument_list|(
literal|"Column 'Xname' not found in any table"
argument_list|)
argument_list|)
expr_stmt|;
comment|// ok
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValidateUserDefinedAggregate
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|SqlStdOperatorTable
name|stdOpTab
init|=
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
decl_stmt|;
name|SqlOperatorTable
name|opTab
init|=
operator|new
name|ChainedSqlOperatorTable
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|stdOpTab
argument_list|,
operator|new
name|ListSqlOperatorTable
argument_list|(
name|ImmutableList
operator|.
expr|<
name|SqlOperator
operator|>
name|of
argument_list|(
operator|new
name|MyCountAggFunction
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|defaultSchema
argument_list|(
name|OptiqAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|OptiqAssert
operator|.
name|SchemaSpec
operator|.
name|HR
argument_list|)
argument_list|)
operator|.
name|operatorTable
argument_list|(
name|opTab
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Planner
name|planner
init|=
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select \"deptno\", my_count(\"empid\") from \"emps\"\n"
operator|+
literal|"group by \"deptno\""
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|parse
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"SELECT `deptno`, `MY_COUNT`(`empid`)\n"
operator|+
literal|"FROM `emps`\n"
operator|+
literal|"GROUP BY `deptno`"
argument_list|)
argument_list|)
expr_stmt|;
comment|// MY_COUNT is recognized as an aggregate function, and therefore it is OK
comment|// that its argument empid is not in the GROUP BY clause.
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|validate
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// The presence of an aggregate function in the SELECT clause causes it
comment|// to become an aggregate query. Non-aggregate expressions become illegal.
name|planner
operator|.
name|close
argument_list|()
expr_stmt|;
name|planner
operator|.
name|reset
argument_list|()
expr_stmt|;
name|parse
operator|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select \"deptno\", count(1) from \"emps\""
argument_list|)
expr_stmt|;
try|try
block|{
name|validate
operator|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected exception, got "
operator|+
name|validate
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ValidationException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"Expression 'deptno' is not being grouped"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Planner
name|getPlanner
parameter_list|(
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
parameter_list|,
name|Program
modifier|...
name|programs
parameter_list|)
block|{
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|lex
argument_list|(
name|Lex
operator|.
name|ORACLE
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|OptiqAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|OptiqAssert
operator|.
name|SchemaSpec
operator|.
name|HR
argument_list|)
argument_list|)
operator|.
name|traitDefs
argument_list|(
name|traitDefs
argument_list|)
operator|.
name|programs
argument_list|(
name|programs
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
return|;
block|}
comment|/** Tests that planner throws an error if you pass to    * {@link Planner#convert(org.eigenbase.sql.SqlNode)}    * a {@link org.eigenbase.sql.SqlNode} that has been parsed but not    * validated. */
annotation|@
name|Test
specifier|public
name|void
name|testConvertWithoutValidateFails
parameter_list|()
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
try|try
block|{
name|RelNode
name|rel
init|=
name|planner
operator|.
name|convert
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|rel
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"cannot move from STATE_3_PARSED to STATE_4_VALIDATED"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Unit test that parses, validates, converts and plans. */
annotation|@
name|Test
specifier|public
name|void
name|testPlan
parameter_list|()
throws|throws
name|Exception
block|{
name|Program
name|program
init|=
name|Programs
operator|.
name|ofRules
argument_list|(
name|MergeFilterRule
operator|.
name|INSTANCE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|program
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and    * plans for query using order by */
annotation|@
name|Test
specifier|public
name|void
name|testSortPlan
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|RemoveSortRule
operator|.
name|INSTANCE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\" "
operator|+
literal|"order by \"emps\".\"deptno\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableSortRel(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"  EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"    EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and    * plans for query using two duplicate order by.    * The duplicate order by should be removed by RemoveSortRule*/
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateSortPlan
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|RemoveSortRule
operator|.
name|INSTANCE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select \"empid\" from ( "
operator|+
literal|"select * "
operator|+
literal|"from \"emps\" "
operator|+
literal|"order by \"emps\".\"deptno\") "
operator|+
literal|"order by \"deptno\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProjectRel(empid=[$0])\n"
operator|+
literal|"  EnumerableProjectRel(empid=[$0], deptno=[$1])\n"
operator|+
literal|"    EnumerableSortRel(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"      EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and    * plans for query using two duplicate order by.*/
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateSortPlanWORemoveSortRule
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|JavaRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select \"empid\" from ( "
operator|+
literal|"select * "
operator|+
literal|"from \"emps\" "
operator|+
literal|"order by \"emps\".\"deptno\") "
operator|+
literal|"order by \"deptno\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProjectRel(empid=[$0])\n"
operator|+
literal|"  EnumerableSortRel(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"    EnumerableProjectRel(empid=[$0], deptno=[$1])\n"
operator|+
literal|"      EnumerableSortRel(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"        EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and plans. Planner is    * provided with a list of RelTraitDefs to register. */
annotation|@
name|Test
specifier|public
name|void
name|testPlanWithExplicitTraitDefs
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|MergeFilterRule
operator|.
name|INSTANCE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelTraitDef
argument_list|>
argument_list|()
decl_stmt|;
name|traitDefs
operator|.
name|add
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|traitDefs
operator|.
name|add
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
name|traitDefs
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that calls {@link Planner#transform} twice. */
annotation|@
name|Test
specifier|public
name|void
name|testPlanTransformTwice
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|MergeFilterRule
operator|.
name|INSTANCE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|RelNode
name|transform2
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|transform
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform2
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  EnumerableTableAccessRel(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that Hive dialect does not generate "AS". */
annotation|@
name|Test
specifier|public
name|void
name|testHiveDialect
parameter_list|()
throws|throws
name|SqlParseException
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from (select * from \"emps\") as t\n"
operator|+
literal|"where \"name\" like '%e%'"
argument_list|)
decl_stmt|;
specifier|final
name|SqlDialect
name|hiveDialect
init|=
operator|new
name|SqlDialect
argument_list|(
name|SqlDialect
operator|.
name|DatabaseProduct
operator|.
name|HIVE
argument_list|,
literal|"Hive"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|parse
operator|.
name|toSqlString
argument_list|(
name|hiveDialect
argument_list|)
operator|.
name|getSql
argument_list|()
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"SELECT *\n"
operator|+
literal|"FROM (SELECT *\n"
operator|+
literal|"FROM emps) T\n"
operator|+
literal|"WHERE name LIKE '%e%'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that calls {@link Planner#transform} twice,    * with different rule sets, with different conventions.    *    *<p>{@link net.hydromatic.optiq.impl.jdbc.JdbcConvention} is different    * from the typical convention in that it is not a singleton. Switching to    * a different instance causes problems unless planner state is wiped clean    * between calls to {@link Planner#transform}. */
annotation|@
name|Test
specifier|public
name|void
name|testPlanTransformWithDiffRuleSetAndConvention
parameter_list|()
throws|throws
name|Exception
block|{
name|Program
name|program0
init|=
name|Programs
operator|.
name|ofRules
argument_list|(
name|MergeFilterRule
operator|.
name|INSTANCE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|JavaRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
name|JdbcConvention
name|out
init|=
operator|new
name|JdbcConvention
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"myjdbc"
argument_list|)
decl_stmt|;
name|Program
name|program1
init|=
name|Programs
operator|.
name|ofRules
argument_list|(
operator|new
name|MockJdbcProjectRule
argument_list|(
name|out
argument_list|)
argument_list|,
operator|new
name|MockJdbcTableRule
argument_list|(
name|out
argument_list|)
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|program0
argument_list|,
name|program1
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select T1.\"name\" from \"emps\" as T1 "
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet0
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet1
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet0
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|RelNode
name|transform2
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|1
argument_list|,
name|traitSet1
argument_list|,
name|transform
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform2
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"JdbcProjectRel(name=[$2])\n"
operator|+
literal|"  MockJdbcTableScan(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that plans a query with a large number of joins. */
annotation|@
name|Test
specifier|public
name|void
name|testPlanNWayJoin
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Here the times before and after enabling LoptOptimizeJoinRule.
comment|//
comment|// Note the jump between N=6 and N=7; LoptOptimizeJoinRule is disabled if
comment|// there are fewer than 6 joins (7 relations).
comment|//
comment|//       N    Before     After
comment|//         time (ms) time (ms)
comment|// ======= ========= =========
comment|//       5                 382
comment|//       6                 790
comment|//       7                  26
comment|//       9    6,000         39
comment|//      10    9,000         47
comment|//      11   19,000         67
comment|//      12   40,000         63
comment|//      13 OOM              96
comment|//      35 OOM           1,716
comment|//      60 OOM          12,230
name|checkJoinNWay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// LoptOptimizeJoinRule disabled; takes about .4s
name|checkJoinNWay
argument_list|(
literal|9
argument_list|)
expr_stmt|;
comment|// LoptOptimizeJoinRule enabled; takes about 0.04s
name|checkJoinNWay
argument_list|(
literal|35
argument_list|)
expr_stmt|;
comment|// takes about 2s
if|if
condition|(
name|OptiqAssert
operator|.
name|ENABLE_SLOW
condition|)
block|{
name|checkJoinNWay
argument_list|(
literal|60
argument_list|)
expr_stmt|;
comment|// takes about 15s
block|}
block|}
specifier|private
name|void
name|checkJoinNWay
parameter_list|(
name|int
name|n
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"select *"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|"\nfrom "
else|:
literal|",\n "
argument_list|)
operator|.
name|append
argument_list|(
literal|"\"depts\" as d"
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|i
operator|==
literal|1
condition|?
literal|"\nwhere"
else|:
literal|"\nand"
argument_list|)
operator|.
name|append
argument_list|(
literal|" d"
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
operator|.
name|append
argument_list|(
literal|".\"deptno\" = d"
argument_list|)
operator|.
name|append
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|append
argument_list|(
literal|".\"deptno\""
argument_list|)
expr_stmt|;
block|}
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|heuristicJoinOrder
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|,
literal|false
argument_list|,
literal|6
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|containsString
argument_list|(
literal|"EnumerableJoinRel(condition=[=($0, $3)], joinType=[inner])"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-435">CALCITE-435</a>,    * "LoptOptimizeJoinRule incorrectly re-orders outer joins".    *    *<p>Checks the {@link org.eigenbase.rel.rules.LoptOptimizeJoinRule} on a    * query with a left outer join.    *    *<p>Specifically, tests that a relation (dependents) in an inner join    * cannot be pushed into an outer join (emps left join depts).    */
annotation|@
name|Test
specifier|public
name|void
name|testHeuristicLeftJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|checkHeuristic
argument_list|(
literal|"select * from \"emps\" as e\n"
operator|+
literal|"left join \"depts\" as d using (\"deptno\")\n"
operator|+
literal|"join \"dependents\" as p on e.\"empid\" = p.\"empid\""
argument_list|,
literal|"EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7], empid0=[$8], name1=[$9])\n"
operator|+
literal|"  EnumerableProjectRel(empid=[$2], deptno=[$3], name=[$4], salary=[$5], commission=[$6], deptno0=[$7], name0=[$8], employees=[$9], empid0=[$0], name1=[$1])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($0, $2)], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[hr, dependents]])\n"
operator|+
literal|"      EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($1, $5)], joinType=[left])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[hr, emps]])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[hr, depts]])"
argument_list|)
expr_stmt|;
block|}
comment|/** It would probably be OK to transform    * {@code (emps right join depts) join dependents}    * to    * {@code (emps  join dependents) right join depts}    * but we do not currently allow it.    */
annotation|@
name|Test
specifier|public
name|void
name|testHeuristicPushInnerJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|checkHeuristic
argument_list|(
literal|"select * from \"emps\" as e\n"
operator|+
literal|"right join \"depts\" as d using (\"deptno\")\n"
operator|+
literal|"join \"dependents\" as p on e.\"empid\" = p.\"empid\""
argument_list|,
literal|"EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7], empid0=[$8], name1=[$9])\n"
operator|+
literal|"  EnumerableProjectRel(empid=[$2], deptno=[$3], name=[$4], salary=[$5], commission=[$6], deptno0=[$7], name0=[$8], employees=[$9], empid0=[$0], name1=[$1])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($0, $2)], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[hr, dependents]])\n"
operator|+
literal|"      EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($1, $5)], joinType=[right])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[hr, emps]])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[hr, depts]])"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a relation (dependents) that is on the null-generating side of    * an outer join cannot be pushed into an inner join (emps join depts). */
annotation|@
name|Test
specifier|public
name|void
name|testHeuristicRightJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|checkHeuristic
argument_list|(
literal|"select * from \"emps\" as e\n"
operator|+
literal|"join \"depts\" as d using (\"deptno\")\n"
operator|+
literal|"right join \"dependents\" as p on e.\"empid\" = p.\"empid\""
argument_list|,
literal|"EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7], empid0=[$8], name1=[$9])\n"
operator|+
literal|"  EnumerableProjectRel(empid=[$2], deptno=[$3], name=[$4], salary=[$5], commission=[$6], deptno0=[$7], name0=[$8], employees=[$9], empid0=[$0], name1=[$1])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($0, $2)], joinType=[left])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[hr, dependents]])\n"
operator|+
literal|"      EnumerableProjectRel(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($1, $5)], joinType=[inner])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[hr, emps]])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[hr, depts]])"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkHeuristic
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|heuristicJoinOrder
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|containsString
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Plans a 3-table join query on the FoodMart schema. The ideal plan is not    * bushy, but nevertheless exercises the bushy-join heuristic optimizer. */
annotation|@
name|Test
specifier|public
name|void
name|testAlmostBushy
parameter_list|()
throws|throws
name|Exception
block|{
name|checkBushy
argument_list|(
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\" as s\n"
operator|+
literal|"  join \"customer\" as c using (\"customer_id\")\n"
operator|+
literal|"  join \"product\" as p using (\"product_id\")\n"
operator|+
literal|"where c.\"city\" = 'San Francisco'\n"
operator|+
literal|"and p.\"brand_name\" = 'Washington'"
argument_list|,
literal|"EnumerableProjectRel(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], product_class_id=[$37], product_id0=[$38], brand_name=[$39], product_name=[$40], SKU=[$41], SRP=[$42], gross_weight=[$43], net_weight=[$44], recyclable_package=[$45], low_fat=[$46], units_per_case=[$47], cases_per_pallet=[$48], shelf_width=[$49], shelf_height=[$50], shelf_depth=[$51])\n"
operator|+
literal|"  EnumerableProjectRel($f0=[$44], $f1=[$45], $f2=[$46], $f3=[$47], $f4=[$48], $f5=[$49], $f6=[$50], $f7=[$51], $f8=[$15], $f9=[$16], $f10=[$17], $f11=[$18], $f12=[$19], $f13=[$20], $f14=[$21], $f15=[$22], $f16=[$23], $f17=[$24], $f18=[$25], $f19=[$26], $f20=[$27], $f21=[$28], $f22=[$29], $f23=[$30], $f24=[$31], $f25=[$32], $f26=[$33], $f27=[$34], $f28=[$35], $f29=[$36], $f30=[$37], $f31=[$38], $f32=[$39], $f33=[$40], $f34=[$41], $f35=[$42], $f36=[$43], $f37=[$0], $f38=[$1], $f39=[$2], $f40=[$3], $f41=[$4], $f42=[$5], $f43=[$6], $f44=[$7], $f45=[$8], $f46=[$9], $f47=[$10], $f48=[$11], $f49=[$12], $f50=[$13], $f51=[$14])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($1, $44)], joinType=[inner])\n"
operator|+
literal|"      EnumerableFilterRel(condition=[=($2, 'Washington')])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, product]])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($0, $31)], joinType=[inner])\n"
operator|+
literal|"        EnumerableFilterRel(condition=[=($9, 'San Francisco')])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, customer]])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Plans a 4-table join query on the FoodMart schema.    *    *<p>The ideal plan is bushy:    *   customer x (product_class x  product x sales)    * which would be written    *   (customer x ((product_class x product) x sales))    * if you don't assume 'x' is left-associative. */
annotation|@
name|Test
specifier|public
name|void
name|testBushy
parameter_list|()
throws|throws
name|Exception
block|{
name|checkBushy
argument_list|(
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\" as s\n"
operator|+
literal|"  join \"customer\" as c using (\"customer_id\")\n"
operator|+
literal|"  join \"product\" as p using (\"product_id\")\n"
operator|+
literal|"  join \"product_class\" as pc using (\"product_class_id\")\n"
operator|+
literal|"where c.\"city\" = 'San Francisco'\n"
operator|+
literal|"and p.\"brand_name\" = 'Washington'"
argument_list|,
literal|"EnumerableProjectRel(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], product_class_id=[$37], product_id0=[$38], brand_name=[$39], product_name=[$40], SKU=[$41], SRP=[$42], gross_weight=[$43], net_weight=[$44], recyclable_package=[$45], low_fat=[$46], units_per_case=[$47], cases_per_pallet=[$48], shelf_width=[$49], shelf_height=[$50], shelf_depth=[$51], product_class_id0=[$52], product_subcategory=[$53], product_category=[$54], product_department=[$55], product_family=[$56])\n"
operator|+
literal|"  EnumerableProjectRel($f0=[$49], $f1=[$50], $f2=[$51], $f3=[$52], $f4=[$53], $f5=[$54], $f6=[$55], $f7=[$56], $f8=[$0], $f9=[$1], $f10=[$2], $f11=[$3], $f12=[$4], $f13=[$5], $f14=[$6], $f15=[$7], $f16=[$8], $f17=[$9], $f18=[$10], $f19=[$11], $f20=[$12], $f21=[$13], $f22=[$14], $f23=[$15], $f24=[$16], $f25=[$17], $f26=[$18], $f27=[$19], $f28=[$20], $f29=[$21], $f30=[$22], $f31=[$23], $f32=[$24], $f33=[$25], $f34=[$26], $f35=[$27], $f36=[$28], $f37=[$34], $f38=[$35], $f39=[$36], $f40=[$37], $f41=[$38], $f42=[$39], $f43=[$40], $f44=[$41], $f45=[$42], $f46=[$43], $f47=[$44], $f48=[$45], $f49=[$46], $f50=[$47], $f51=[$48], $f52=[$29], $f53=[$30], $f54=[$31], $f55=[$32], $f56=[$33])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($0, $51)], joinType=[inner])\n"
operator|+
literal|"      EnumerableFilterRel(condition=[=($9, 'San Francisco')])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, customer]])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($6, $20)], joinType=[inner])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($0, $5)], joinType=[inner])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, product_class]])\n"
operator|+
literal|"          EnumerableFilterRel(condition=[=($2, 'Washington')])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, product]])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Plans a 5-table join query on the FoodMart schema. The ideal plan is    * bushy: store x (customer x (product_class x product x sales)). */
annotation|@
name|Test
specifier|public
name|void
name|testBushy5
parameter_list|()
throws|throws
name|Exception
block|{
name|checkBushy
argument_list|(
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\" as s\n"
operator|+
literal|"  join \"customer\" as c using (\"customer_id\")\n"
operator|+
literal|"  join \"product\" as p using (\"product_id\")\n"
operator|+
literal|"  join \"product_class\" as pc using (\"product_class_id\")\n"
operator|+
literal|"  join \"store\" as st using (\"store_id\")\n"
operator|+
literal|"where c.\"city\" = 'San Francisco'\n"
argument_list|,
literal|"EnumerableProjectRel(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], product_class_id=[$37], product_id0=[$38], brand_name=[$39], product_name=[$40], SKU=[$41], SRP=[$42], gross_weight=[$43], net_weight=[$44], recyclable_package=[$45], low_fat=[$46], units_per_case=[$47], cases_per_pallet=[$48], shelf_width=[$49], shelf_height=[$50], shelf_depth=[$51], product_class_id0=[$52], product_subcategory=[$53], product_category=[$54], product_department=[$55], product_family=[$56], store_id0=[$57], store_type=[$58], region_id=[$59], store_name=[$60], store_number=[$61], store_street_address=[$62], store_city=[$63], store_state=[$64], store_postal_code=[$65], store_country=[$66], store_manager=[$67], store_phone=[$68], store_fax=[$69], first_opened_date=[$70], last_remodel_date=[$71], store_sqft=[$72], grocery_sqft=[$73], frozen_sqft=[$74], meat_sqft=[$75], coffee_bar=[$76], video_store=[$77], salad_bar=[$78], prepared_food=[$79], florist=[$80])\n"
operator|+
literal|"  EnumerableProjectRel($f0=[$73], $f1=[$74], $f2=[$75], $f3=[$76], $f4=[$77], $f5=[$78], $f6=[$79], $f7=[$80], $f8=[$24], $f9=[$25], $f10=[$26], $f11=[$27], $f12=[$28], $f13=[$29], $f14=[$30], $f15=[$31], $f16=[$32], $f17=[$33], $f18=[$34], $f19=[$35], $f20=[$36], $f21=[$37], $f22=[$38], $f23=[$39], $f24=[$40], $f25=[$41], $f26=[$42], $f27=[$43], $f28=[$44], $f29=[$45], $f30=[$46], $f31=[$47], $f32=[$48], $f33=[$49], $f34=[$50], $f35=[$51], $f36=[$52], $f37=[$58], $f38=[$59], $f39=[$60], $f40=[$61], $f41=[$62], $f42=[$63], $f43=[$64], $f44=[$65], $f45=[$66], $f46=[$67], $f47=[$68], $f48=[$69], $f49=[$70], $f50=[$71], $f51=[$72], $f52=[$53], $f53=[$54], $f54=[$55], $f55=[$56], $f56=[$57], $f57=[$0], $f58=[$1], $f59=[$2], $f60=[$3], $f61=[$4], $f62=[$5], $f63=[$6], $f64=[$7], $f65=[$8], $f66=[$9], $f67=[$10], $f68=[$11], $f69=[$12], $f70=[$13], $f71=[$14], $f72=[$15], $f73=[$16], $f74=[$17], $f75=[$18], $f76=[$19], $f77=[$20], $f78=[$21], $f79=[$22], $f80=[$23])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[=($0, $77)], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[foodmart2, store]])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($0, $51)], joinType=[inner])\n"
operator|+
literal|"        EnumerableFilterRel(condition=[=($9, 'San Francisco')])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, customer]])\n"
operator|+
literal|"        EnumerableJoinRel(condition=[=($6, $20)], joinType=[inner])\n"
operator|+
literal|"          EnumerableJoinRel(condition=[=($0, $5)], joinType=[inner])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, product_class]])\n"
operator|+
literal|"            EnumerableTableAccessRel(table=[[foodmart2, product]])\n"
operator|+
literal|"          EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests the bushy join algorithm where one table does not join to    * anything. */
annotation|@
name|Test
specifier|public
name|void
name|testBushyCrossJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|checkBushy
argument_list|(
literal|"select * from \"sales_fact_1997\"\n"
operator|+
literal|"join \"customer\" using (\"customer_id\")\n"
operator|+
literal|"cross join \"department\""
argument_list|,
literal|"EnumerableProjectRel(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], department_id=[$37], department_description=[$38])\n"
operator|+
literal|"  EnumerableProjectRel($f0=[$31], $f1=[$32], $f2=[$33], $f3=[$34], $f4=[$35], $f5=[$36], $f6=[$37], $f7=[$38], $f8=[$2], $f9=[$3], $f10=[$4], $f11=[$5], $f12=[$6], $f13=[$7], $f14=[$8], $f15=[$9], $f16=[$10], $f17=[$11], $f18=[$12], $f19=[$13], $f20=[$14], $f21=[$15], $f22=[$16], $f23=[$17], $f24=[$18], $f25=[$19], $f26=[$20], $f27=[$21], $f28=[$22], $f29=[$23], $f30=[$24], $f31=[$25], $f32=[$26], $f33=[$27], $f34=[$28], $f35=[$29], $f36=[$30], $f37=[$0], $f38=[$1])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[true], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableAccessRel(table=[[foodmart2, department]])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($0, $31)], joinType=[inner])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, customer]])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests the bushy join algorithm against a query where not all tables have a    * join condition to the others. */
annotation|@
name|Test
specifier|public
name|void
name|testBushyCrossJoin2
parameter_list|()
throws|throws
name|Exception
block|{
name|checkBushy
argument_list|(
literal|"select * from \"sales_fact_1997\"\n"
operator|+
literal|"join \"customer\" using (\"customer_id\")\n"
operator|+
literal|"cross join \"department\"\n"
operator|+
literal|"join \"employee\" using (\"department_id\")"
argument_list|,
literal|"EnumerableProjectRel(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], department_id=[$37], department_description=[$38], employee_id=[$39], full_name=[$40], first_name=[$41], last_name=[$42], position_id=[$43], position_title=[$44], store_id0=[$45], department_id0=[$46], birth_date=[$47], hire_date=[$48], end_date=[$49], salary=[$50], supervisor_id=[$51], education_level=[$52], marital_status0=[$53], gender0=[$54], management_role=[$55])\n"
operator|+
literal|"  EnumerableProjectRel($f0=[$48], $f1=[$49], $f2=[$50], $f3=[$51], $f4=[$52], $f5=[$53], $f6=[$54], $f7=[$55], $f8=[$19], $f9=[$20], $f10=[$21], $f11=[$22], $f12=[$23], $f13=[$24], $f14=[$25], $f15=[$26], $f16=[$27], $f17=[$28], $f18=[$29], $f19=[$30], $f20=[$31], $f21=[$32], $f22=[$33], $f23=[$34], $f24=[$35], $f25=[$36], $f26=[$37], $f27=[$38], $f28=[$39], $f29=[$40], $f30=[$41], $f31=[$42], $f32=[$43], $f33=[$44], $f34=[$45], $f35=[$46], $f36=[$47], $f37=[$0], $f38=[$1], $f39=[$2], $f40=[$3], $f41=[$4], $f42=[$5], $f43=[$6], $f44=[$7], $f45=[$8], $f46=[$9], $f47=[$10], $f48=[$11], $f49=[$12], $f50=[$13], $f51=[$14], $f52=[$15], $f53=[$16], $f54=[$17], $f55=[$18])\n"
operator|+
literal|"    EnumerableJoinRel(condition=[true], joinType=[inner])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($0, $9)], joinType=[inner])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, department]])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, employee]])\n"
operator|+
literal|"      EnumerableJoinRel(condition=[=($0, $31)], joinType=[inner])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, customer]])\n"
operator|+
literal|"        EnumerableTableAccessRel(table=[[foodmart2, sales_fact_1997]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that a query returns a particular plan, using a planner with    * OptimizeBushyJoinRule enabled. */
specifier|private
name|void
name|checkBushy
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|lex
argument_list|(
name|Lex
operator|.
name|ORACLE
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|OptiqAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|OptiqAssert
operator|.
name|SchemaSpec
operator|.
name|CLONE_FOODMART
argument_list|)
argument_list|)
operator|.
name|traitDefs
argument_list|(
operator|(
name|List
argument_list|<
name|RelTraitDef
argument_list|>
operator|)
literal|null
argument_list|)
operator|.
name|programs
argument_list|(
name|Programs
operator|.
name|heuristicJoinOrder
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|,
literal|true
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|Planner
name|planner
init|=
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|convert
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|planner
operator|.
name|getEmptyTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|containsString
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rule to convert a {@link EnumerableProjectRel} to an    * {@link JdbcProjectRel}.    */
specifier|private
class|class
name|MockJdbcProjectRule
extends|extends
name|ConverterRule
block|{
specifier|private
name|MockJdbcProjectRule
parameter_list|(
name|JdbcConvention
name|out
parameter_list|)
block|{
name|super
argument_list|(
name|EnumerableProjectRel
operator|.
name|class
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|,
name|out
argument_list|,
literal|"MockJdbcProjectRule"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelNode
name|convert
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|EnumerableProjectRel
name|project
init|=
operator|(
name|EnumerableProjectRel
operator|)
name|rel
decl_stmt|;
return|return
operator|new
name|JdbcProjectRel
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|getOutConvention
argument_list|()
argument_list|)
argument_list|,
name|convert
argument_list|(
name|project
operator|.
name|getChild
argument_list|()
argument_list|,
name|project
operator|.
name|getChild
argument_list|()
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|getOutConvention
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
argument_list|,
name|ProjectRelBase
operator|.
name|Flags
operator|.
name|BOXED
argument_list|)
return|;
block|}
block|}
comment|/**    * Rule to convert a {@link JavaRules.EnumerableTableAccessRel} to an    * {@link MockJdbcTableScan}.    */
specifier|private
class|class
name|MockJdbcTableRule
extends|extends
name|ConverterRule
block|{
specifier|private
name|MockJdbcTableRule
parameter_list|(
name|JdbcConvention
name|out
parameter_list|)
block|{
name|super
argument_list|(
name|JavaRules
operator|.
name|EnumerableTableAccessRel
operator|.
name|class
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|,
name|out
argument_list|,
literal|"MockJdbcTableRule"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelNode
name|convert
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|JavaRules
operator|.
name|EnumerableTableAccessRel
name|scan
init|=
operator|(
name|JavaRules
operator|.
name|EnumerableTableAccessRel
operator|)
name|rel
decl_stmt|;
return|return
operator|new
name|MockJdbcTableScan
argument_list|(
name|scan
operator|.
name|getCluster
argument_list|()
argument_list|,
name|scan
operator|.
name|getTable
argument_list|()
argument_list|,
operator|(
name|JdbcConvention
operator|)
name|getOutConvention
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Relational expression representing a "mock" scan of a table in a    * JDBC data source.    */
specifier|private
class|class
name|MockJdbcTableScan
extends|extends
name|TableAccessRelBase
implements|implements
name|JdbcRel
block|{
specifier|public
name|MockJdbcTableScan
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|table
parameter_list|,
name|JdbcConvention
name|jdbcConvention
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|jdbcConvention
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|copy
parameter_list|(
name|RelTraitSet
name|traitSet
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|)
block|{
return|return
operator|new
name|MockJdbcTableScan
argument_list|(
name|getCluster
argument_list|()
argument_list|,
name|table
argument_list|,
operator|(
name|JdbcConvention
operator|)
name|getConvention
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|register
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
specifier|final
name|JdbcConvention
name|out
init|=
operator|(
name|JdbcConvention
operator|)
name|getConvention
argument_list|()
decl_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|JdbcRules
operator|.
name|rules
argument_list|(
name|out
argument_list|)
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|JdbcImplementor
operator|.
name|Result
name|implement
parameter_list|(
name|JdbcImplementor
name|implementor
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Test to determine whether de-correlation correctly removes CorrelatorRel.    */
annotation|@
name|Test
specifier|public
name|void
name|testOldJoinStyleDeCorrelation
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFalse
argument_list|(
name|checkTpchQuery
argument_list|(
literal|"select\n p.`pPartkey`\n"
operator|+
literal|"from\n"
operator|+
literal|"  `tpch`.`part` p,\n"
operator|+
literal|"  `tpch`.`partsupp` ps1\n"
operator|+
literal|"where\n"
operator|+
literal|"  p.`pPartkey` = ps1.`psPartkey`\n"
operator|+
literal|"  and ps1.`psSupplyCost` = (\n"
operator|+
literal|"    select\n"
operator|+
literal|"      min(ps.`psSupplyCost`)\n"
operator|+
literal|"    from\n"
operator|+
literal|"      `tpch`.`partsupp` ps\n"
operator|+
literal|"    where\n"
operator|+
literal|"      p.`pPartkey` = ps.`psPartkey`\n"
operator|+
literal|"  )\n"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"CorrelatorRel"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|checkTpchQuery
parameter_list|(
name|String
name|tpchTestQuery
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|SchemaPlus
name|schema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
operator|.
name|add
argument_list|(
literal|"tpch"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|TpchSchema
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|lex
argument_list|(
name|Lex
operator|.
name|MYSQL
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|schema
argument_list|)
operator|.
name|programs
argument_list|(
name|Programs
operator|.
name|ofRules
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|Planner
name|p
init|=
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|SqlNode
name|n
init|=
name|p
operator|.
name|parse
argument_list|(
name|tpchTestQuery
argument_list|)
decl_stmt|;
name|n
operator|=
name|p
operator|.
name|validate
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|RelNode
name|r
init|=
name|p
operator|.
name|convert
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|String
name|plan
init|=
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|p
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|plan
return|;
block|}
comment|/** User-defined aggregate function. */
specifier|public
specifier|static
class|class
name|MyCountAggFunction
extends|extends
name|SqlAggFunction
block|{
specifier|public
name|MyCountAggFunction
parameter_list|()
block|{
name|super
argument_list|(
literal|"MY_COUNT"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|BIGINT
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|RelDataType
argument_list|>
name|getParameterTypes
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|ANY
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|getReturnType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|deriveType
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Check for COUNT(*) function.  If it is we don't
comment|// want to try and derive the "*"
if|if
condition|(
name|call
operator|.
name|isCountStar
argument_list|()
condition|)
block|{
return|return
name|validator
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|deriveType
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End PlannerTest.java
end_comment

end_unit

