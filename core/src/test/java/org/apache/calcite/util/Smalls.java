begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|DataContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|AbstractQueryableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|AbstractEnumerable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|BaseQueryable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Enumerable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Enumerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|QueryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Queryable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Deterministic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Parameter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelProtoDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|SqlFunctions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|QueryableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|ScannableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Statistic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|TranslatableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|AbstractTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|ViewTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_comment
comment|/**  * Holder for various classes and functions used in tests as user-defined  * functions and so forth.  */
end_comment

begin_class
specifier|public
class|class
name|Smalls
block|{
specifier|public
specifier|static
specifier|final
name|Method
name|GENERATE_STRINGS_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"generateStrings"
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|MAZE_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|MazeTable
operator|.
name|class
argument_list|,
literal|"generate"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|MAZE2_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|MazeTable
operator|.
name|class
argument_list|,
literal|"generate2"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|MAZE3_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|MazeTable
operator|.
name|class
argument_list|,
literal|"generate3"
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|MULTIPLICATION_TABLE_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"multiplicationTable"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|FIBONACCI_TABLE_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"fibonacciTable"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|FIBONACCI2_TABLE_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"fibonacciTableWithLimit"
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|VIEW_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"view"
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|STR_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"str"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|STRING_UNION_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"stringUnion"
argument_list|,
name|Queryable
operator|.
name|class
argument_list|,
name|Queryable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|PROCESS_CURSOR_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"processCursor"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|Enumerable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Method
name|PROCESS_CURSORS_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Smalls
operator|.
name|class
argument_list|,
literal|"processCursors"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|Enumerable
operator|.
name|class
argument_list|,
name|Enumerable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Smalls
parameter_list|()
block|{
block|}
specifier|private
specifier|static
name|QueryableTable
name|oneThreePlus
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|items
decl_stmt|;
comment|// Argument is null in case SQL contains function call with expression.
comment|// Then the engine calls a function with null arguments to get getRowType.
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|items
operator|=
name|ImmutableList
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Integer
name|latest
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|items
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
name|latest
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Enumerable
argument_list|<
name|Integer
argument_list|>
name|enumerable
init|=
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|items
argument_list|)
decl_stmt|;
return|return
operator|new
name|AbstractQueryableTable
argument_list|(
name|Integer
operator|.
name|class
argument_list|)
block|{
specifier|public
parameter_list|<
name|E
parameter_list|>
name|Queryable
argument_list|<
name|E
argument_list|>
name|asQueryable
parameter_list|(
name|QueryProvider
name|queryProvider
parameter_list|,
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
operator|(
name|Queryable
argument_list|<
name|E
argument_list|>
operator|)
name|enumerable
operator|.
name|asQueryable
argument_list|()
return|;
block|}
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Queryable
argument_list|<
name|T
argument_list|>
name|stringUnion
parameter_list|(
name|Queryable
argument_list|<
name|T
argument_list|>
name|q0
parameter_list|,
name|Queryable
argument_list|<
name|T
argument_list|>
name|q1
parameter_list|)
block|{
return|return
name|q0
operator|.
name|concat
argument_list|(
name|q1
argument_list|)
return|;
block|}
comment|/** A function that generates a table that generates a sequence of    * {@link IntString} values. */
specifier|public
specifier|static
name|QueryableTable
name|generateStrings
parameter_list|(
specifier|final
name|Integer
name|count
parameter_list|)
block|{
return|return
operator|new
name|AbstractQueryableTable
argument_list|(
name|IntString
operator|.
name|class
argument_list|)
block|{
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createJavaType
argument_list|(
name|IntString
operator|.
name|class
argument_list|)
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Queryable
argument_list|<
name|T
argument_list|>
name|asQueryable
parameter_list|(
name|QueryProvider
name|queryProvider
parameter_list|,
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
name|BaseQueryable
argument_list|<
name|IntString
argument_list|>
name|queryable
init|=
operator|new
name|BaseQueryable
argument_list|<
name|IntString
argument_list|>
argument_list|(
literal|null
argument_list|,
name|IntString
operator|.
name|class
argument_list|,
literal|null
argument_list|)
block|{
specifier|public
name|Enumerator
argument_list|<
name|IntString
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|IntString
argument_list|>
argument_list|()
block|{
specifier|static
specifier|final
name|String
name|Z
init|=
literal|"abcdefghijklm"
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|curI
decl_stmt|;
name|String
name|curS
decl_stmt|;
specifier|public
name|IntString
name|current
parameter_list|()
block|{
return|return
operator|new
name|IntString
argument_list|(
name|curI
argument_list|,
name|curS
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
if|if
condition|(
name|i
operator|<
name|count
condition|)
block|{
name|curI
operator|=
name|i
expr_stmt|;
name|curS
operator|=
name|Z
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
operator|%
name|Z
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
block|}
return|;
block|}
block|}
decl_stmt|;
comment|//noinspection unchecked
return|return
operator|(
name|Queryable
argument_list|<
name|T
argument_list|>
operator|)
name|queryable
return|;
block|}
block|}
return|;
block|}
comment|/** A function that generates multiplication table of {@code ncol} columns x    * {@code nrow} rows. */
specifier|public
specifier|static
name|QueryableTable
name|multiplicationTable
parameter_list|(
specifier|final
name|int
name|ncol
parameter_list|,
specifier|final
name|int
name|nrow
parameter_list|,
name|Integer
name|offset
parameter_list|)
block|{
specifier|final
name|int
name|offs
init|=
name|offset
operator|==
literal|null
condition|?
literal|0
else|:
name|offset
decl_stmt|;
return|return
operator|new
name|AbstractQueryableTable
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
block|{
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
literal|"row_name"
argument_list|,
name|typeFactory
operator|.
name|createJavaType
argument_list|(
name|String
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|int_
init|=
name|typeFactory
operator|.
name|createJavaType
argument_list|(
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|ncol
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
literal|"c"
operator|+
name|i
argument_list|,
name|int_
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
name|Queryable
argument_list|<
name|Object
index|[]
argument_list|>
name|asQueryable
parameter_list|(
name|QueryProvider
name|queryProvider
parameter_list|,
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|table
init|=
operator|new
name|AbstractList
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|Object
index|[]
name|cur
init|=
operator|new
name|Object
index|[
name|ncol
operator|+
literal|1
index|]
decl_stmt|;
name|cur
index|[
literal|0
index|]
operator|=
literal|"row "
operator|+
name|index
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|ncol
condition|;
name|j
operator|++
control|)
block|{
name|cur
index|[
name|j
index|]
operator|=
name|j
operator|*
operator|(
name|index
operator|+
literal|1
operator|)
operator|+
name|offs
expr_stmt|;
block|}
return|return
name|cur
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|nrow
return|;
block|}
block|}
decl_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|table
argument_list|)
operator|.
name|asQueryable
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/** A function that generates the Fibonacci sequence.    * Interesting because it has one column and no arguments. */
specifier|public
specifier|static
name|ScannableTable
name|fibonacciTable
parameter_list|()
block|{
return|return
name|fibonacciTableWithLimit
argument_list|(
operator|-
literal|1L
argument_list|)
return|;
block|}
comment|/** A function that generates the Fibonacci sequence.    * Interesting because it has one column and no arguments. */
specifier|public
specifier|static
name|ScannableTable
name|fibonacciTableWithLimit
parameter_list|(
specifier|final
name|long
name|limit
parameter_list|)
block|{
return|return
operator|new
name|ScannableTable
argument_list|()
block|{
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"N"
argument_list|,
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
name|Enumerable
argument_list|<
name|Object
index|[]
argument_list|>
name|scan
parameter_list|(
name|DataContext
name|root
parameter_list|)
block|{
return|return
operator|new
name|AbstractEnumerable
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerator
argument_list|<
name|Object
index|[]
argument_list|>
name|enumerator
parameter_list|()
block|{
return|return
operator|new
name|Enumerator
argument_list|<
name|Object
index|[]
argument_list|>
argument_list|()
block|{
specifier|private
name|long
name|prev
init|=
literal|1
decl_stmt|;
specifier|private
name|long
name|current
init|=
literal|0
decl_stmt|;
specifier|public
name|Object
index|[]
name|current
parameter_list|()
block|{
return|return
operator|new
name|Object
index|[]
block|{
name|current
block|}
return|;
block|}
specifier|public
name|boolean
name|moveNext
parameter_list|()
block|{
specifier|final
name|long
name|next
init|=
name|current
operator|+
name|prev
decl_stmt|;
if|if
condition|(
name|limit
operator|>=
literal|0
operator|&&
name|next
operator|>
name|limit
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prev
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|next
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|prev
operator|=
literal|0
expr_stmt|;
name|current
operator|=
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
block|}
block|}
return|;
block|}
block|}
return|;
block|}
specifier|public
name|Statistic
name|getStatistic
parameter_list|()
block|{
return|return
name|Statistics
operator|.
name|UNKNOWN
return|;
block|}
specifier|public
name|Schema
operator|.
name|TableType
name|getJdbcTableType
parameter_list|()
block|{
return|return
name|Schema
operator|.
name|TableType
operator|.
name|TABLE
return|;
block|}
specifier|public
name|boolean
name|isRolledUp
parameter_list|(
name|String
name|column
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|rolledUpColumnValidInsideAgg
parameter_list|(
name|String
name|column
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|SqlNode
name|parent
parameter_list|,
name|CalciteConnectionConfig
name|config
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|;
block|}
comment|/**    * A function that adds a number to the first column of input cursor    */
specifier|public
specifier|static
name|QueryableTable
name|processCursor
parameter_list|(
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|Object
index|[]
argument_list|>
name|a
parameter_list|)
block|{
return|return
operator|new
name|AbstractQueryableTable
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
block|{
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"result"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Queryable
argument_list|<
name|T
argument_list|>
name|asQueryable
parameter_list|(
name|QueryProvider
name|queryProvider
parameter_list|,
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
specifier|final
name|Enumerable
argument_list|<
name|Integer
argument_list|>
name|enumerable
init|=
name|a
operator|.
name|select
argument_list|(
operator|new
name|Function1
argument_list|<
name|Object
index|[]
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|apply
parameter_list|(
name|Object
index|[]
name|a0
parameter_list|)
block|{
return|return
name|offset
operator|+
operator|(
operator|(
name|Integer
operator|)
name|a0
index|[
literal|0
index|]
operator|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|//noinspection unchecked
return|return
operator|(
name|Queryable
operator|)
name|enumerable
operator|.
name|asQueryable
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * A function that sums the second column of first input cursor, second    * column of first input and the given int.    */
specifier|public
specifier|static
name|QueryableTable
name|processCursors
parameter_list|(
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|Object
index|[]
argument_list|>
name|a
parameter_list|,
specifier|final
name|Enumerable
argument_list|<
name|IntString
argument_list|>
name|b
parameter_list|)
block|{
return|return
operator|new
name|AbstractQueryableTable
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
block|{
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"result"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Queryable
argument_list|<
name|T
argument_list|>
name|asQueryable
parameter_list|(
name|QueryProvider
name|queryProvider
parameter_list|,
name|SchemaPlus
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|)
block|{
specifier|final
name|Enumerable
argument_list|<
name|Integer
argument_list|>
name|enumerable
init|=
name|a
operator|.
name|zip
argument_list|(
name|b
argument_list|,
operator|new
name|Function2
argument_list|<
name|Object
index|[]
argument_list|,
name|IntString
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|apply
parameter_list|(
name|Object
index|[]
name|v0
parameter_list|,
name|IntString
name|v1
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Integer
operator|)
name|v0
index|[
literal|1
index|]
operator|)
operator|+
name|v1
operator|.
name|n
operator|+
name|offset
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|//noinspection unchecked
return|return
operator|(
name|Queryable
operator|)
name|enumerable
operator|.
name|asQueryable
argument_list|()
return|;
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|TranslatableTable
name|view
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
operator|new
name|ViewTable
argument_list|(
name|Object
operator|.
name|class
argument_list|,
operator|new
name|RelProtoDataType
argument_list|()
block|{
specifier|public
name|RelDataType
name|apply
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
argument_list|,
literal|"values (1), (3), "
operator|+
name|s
argument_list|,
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"view"
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|TranslatableTable
name|str
parameter_list|(
name|Object
name|o
parameter_list|,
name|Object
name|p
parameter_list|)
block|{
name|assertThat
argument_list|(
name|RexLiteral
operator|.
name|validConstant
argument_list|(
name|o
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexLiteral
operator|.
name|validConstant
argument_list|(
name|p
argument_list|,
name|Litmus
operator|.
name|THROW
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|ViewTable
argument_list|(
name|Object
operator|.
name|class
argument_list|,
operator|new
name|RelProtoDataType
argument_list|()
block|{
specifier|public
name|RelDataType
name|apply
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|100
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
argument_list|,
literal|"values "
operator|+
name|SqlDialect
operator|.
name|CALCITE
operator|.
name|quoteStringLiteral
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
operator|+
literal|", "
operator|+
name|SqlDialect
operator|.
name|CALCITE
operator|.
name|quoteStringLiteral
argument_list|(
name|p
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"view"
argument_list|)
argument_list|)
return|;
block|}
comment|/** Class with int and String fields. */
specifier|public
specifier|static
class|class
name|IntString
block|{
specifier|public
specifier|final
name|int
name|n
decl_stmt|;
specifier|public
specifier|final
name|String
name|s
decl_stmt|;
specifier|public
name|IntString
parameter_list|(
name|int
name|n
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|n
operator|=
name|n
expr_stmt|;
name|this
operator|.
name|s
operator|=
name|s
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{n="
operator|+
name|n
operator|+
literal|", s="
operator|+
name|s
operator|+
literal|"}"
return|;
block|}
block|}
comment|/** Example of a UDF with a non-static {@code eval} method,    * and named parameters. */
specifier|public
specifier|static
class|class
name|MyPlusFunction
block|{
specifier|public
specifier|static
specifier|final
name|AtomicInteger
name|INSTANCE_COUNT
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Note: Not marked @Deterministic
specifier|public
name|MyPlusFunction
parameter_list|()
block|{
name|INSTANCE_COUNT
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|eval
parameter_list|(
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"x"
argument_list|)
name|int
name|x
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"y"
argument_list|)
name|int
name|y
parameter_list|)
block|{
return|return
name|x
operator|+
name|y
return|;
block|}
block|}
comment|/** As {@link MyPlusFunction} but declared to be deterministic. */
specifier|public
specifier|static
class|class
name|MyDeterministicPlusFunction
block|{
specifier|public
specifier|static
specifier|final
name|AtomicInteger
name|INSTANCE_COUNT
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|Deterministic
specifier|public
name|MyDeterministicPlusFunction
parameter_list|()
block|{
name|INSTANCE_COUNT
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|eval
parameter_list|(
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"x"
argument_list|)
name|int
name|x
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"y"
argument_list|)
name|int
name|y
parameter_list|)
block|{
return|return
name|x
operator|+
name|y
return|;
block|}
block|}
comment|/** Example of a UDF with named parameters. */
specifier|public
specifier|static
class|class
name|MyLeftFunction
block|{
specifier|public
name|String
name|eval
parameter_list|(
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"s"
argument_list|)
name|String
name|s
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"n"
argument_list|)
name|int
name|n
parameter_list|)
block|{
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|n
argument_list|)
return|;
block|}
block|}
comment|/** Example of a UDF with named parameters, some of them optional. */
specifier|public
specifier|static
class|class
name|MyAbcdeFunction
block|{
specifier|public
name|String
name|eval
parameter_list|(
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"A"
argument_list|,
name|optional
operator|=
literal|false
argument_list|)
name|Integer
name|a
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"B"
argument_list|,
name|optional
operator|=
literal|true
argument_list|)
name|Integer
name|b
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"C"
argument_list|,
name|optional
operator|=
literal|false
argument_list|)
name|Integer
name|c
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"D"
argument_list|,
name|optional
operator|=
literal|true
argument_list|)
name|Integer
name|d
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"E"
argument_list|,
name|optional
operator|=
literal|true
argument_list|)
name|Integer
name|e
parameter_list|)
block|{
return|return
literal|"{a: "
operator|+
name|a
operator|+
literal|", b: "
operator|+
name|b
operator|+
literal|", c: "
operator|+
name|c
operator|+
literal|", d: "
operator|+
name|d
operator|+
literal|", e: "
operator|+
name|e
operator|+
literal|"}"
return|;
block|}
block|}
comment|/** Example of a non-strict UDF. (Does something useful when passed NULL.) */
specifier|public
specifier|static
class|class
name|MyToStringFunction
block|{
specifier|public
specifier|static
name|String
name|eval
parameter_list|(
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"o"
argument_list|)
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|"<null>"
return|;
block|}
return|return
literal|"<"
operator|+
name|o
operator|.
name|toString
argument_list|()
operator|+
literal|">"
return|;
block|}
block|}
comment|/** Example of a UDF with a static {@code eval} method. Class is abstract,    * but code-generator should not need to instantiate it. */
specifier|public
specifier|abstract
specifier|static
class|class
name|MyDoubleFunction
block|{
specifier|private
name|MyDoubleFunction
parameter_list|()
block|{
block|}
specifier|public
specifier|static
name|int
name|eval
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
name|x
operator|*
literal|2
return|;
block|}
block|}
comment|/** User-defined function with two arguments. */
specifier|public
specifier|static
class|class
name|MyIncrement
block|{
specifier|public
name|float
name|eval
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
name|x
operator|+
name|x
operator|*
name|y
operator|/
literal|100
return|;
block|}
block|}
comment|/** Example of a UDF that has overloaded UDFs (same name, different args). */
specifier|public
specifier|abstract
specifier|static
class|class
name|CountArgs0Function
block|{
specifier|private
name|CountArgs0Function
parameter_list|()
block|{
block|}
specifier|public
specifier|static
name|int
name|eval
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/** See {@link CountArgs0Function}. */
specifier|public
specifier|abstract
specifier|static
class|class
name|CountArgs1Function
block|{
specifier|private
name|CountArgs1Function
parameter_list|()
block|{
block|}
specifier|public
specifier|static
name|int
name|eval
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
block|}
comment|/** See {@link CountArgs0Function}. */
specifier|public
specifier|abstract
specifier|static
class|class
name|CountArgs1NullableFunction
block|{
specifier|private
name|CountArgs1NullableFunction
parameter_list|()
block|{
block|}
specifier|public
specifier|static
name|int
name|eval
parameter_list|(
name|Short
name|x
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/** See {@link CountArgs0Function}. */
specifier|public
specifier|abstract
specifier|static
class|class
name|CountArgs2Function
block|{
specifier|private
name|CountArgs2Function
parameter_list|()
block|{
block|}
specifier|public
specifier|static
name|int
name|eval
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
literal|2
return|;
block|}
block|}
comment|/** Example of a UDF class that needs to be instantiated but cannot be. */
specifier|public
specifier|abstract
specifier|static
class|class
name|AwkwardFunction
block|{
specifier|private
name|AwkwardFunction
parameter_list|()
block|{
block|}
specifier|public
name|int
name|eval
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/** UDF class that has multiple methods, some overloaded. */
specifier|public
specifier|static
class|class
name|MultipleFunction
block|{
specifier|private
name|MultipleFunction
parameter_list|()
block|{
block|}
comment|// Three overloads
specifier|public
specifier|static
name|String
name|fun1
parameter_list|(
name|String
name|x
parameter_list|)
block|{
return|return
name|x
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|fun1
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
name|x
operator|*
literal|2
return|;
block|}
specifier|public
specifier|static
name|int
name|fun1
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
return|return
name|x
operator|+
name|y
return|;
block|}
comment|// Another method
specifier|public
specifier|static
name|int
name|fun2
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
name|x
operator|*
literal|3
return|;
block|}
comment|// Non-static method cannot be used because constructor is private
specifier|public
name|int
name|nonStatic
parameter_list|(
name|int
name|x
parameter_list|)
block|{
return|return
name|x
operator|*
literal|3
return|;
block|}
block|}
comment|/** UDF class that provides user-defined functions for each data type. */
annotation|@
name|Deterministic
specifier|public
specifier|static
class|class
name|AllTypesFunction
block|{
specifier|private
name|AllTypesFunction
parameter_list|()
block|{
block|}
comment|// We use SqlFunctions.toLong(Date) ratter than Date.getTime(),
comment|// and SqlFunctions.internalToTimestamp(long) rather than new Date(long),
comment|// because the contract of JDBC (also used by UDFs) is to represent
comment|// date-time values in the LOCAL time zone.
specifier|public
specifier|static
name|long
name|dateFun
parameter_list|(
name|java
operator|.
name|sql
operator|.
name|Date
name|v
parameter_list|)
block|{
return|return
name|v
operator|==
literal|null
condition|?
operator|-
literal|1L
else|:
name|SqlFunctions
operator|.
name|toLong
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|timestampFun
parameter_list|(
name|java
operator|.
name|sql
operator|.
name|Timestamp
name|v
parameter_list|)
block|{
return|return
name|v
operator|==
literal|null
condition|?
operator|-
literal|1L
else|:
name|SqlFunctions
operator|.
name|toLong
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|timeFun
parameter_list|(
name|java
operator|.
name|sql
operator|.
name|Time
name|v
parameter_list|)
block|{
return|return
name|v
operator|==
literal|null
condition|?
operator|-
literal|1L
else|:
name|SqlFunctions
operator|.
name|toLong
argument_list|(
name|v
argument_list|)
return|;
block|}
comment|/** Overloaded, in a challenging way, with {@link #toDateFun(Long)}. */
specifier|public
specifier|static
name|java
operator|.
name|sql
operator|.
name|Date
name|toDateFun
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
name|SqlFunctions
operator|.
name|internalToDate
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|java
operator|.
name|sql
operator|.
name|Date
name|toDateFun
parameter_list|(
name|Long
name|v
parameter_list|)
block|{
return|return
name|v
operator|==
literal|null
condition|?
literal|null
else|:
name|SqlFunctions
operator|.
name|internalToDate
argument_list|(
name|v
operator|.
name|intValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|java
operator|.
name|sql
operator|.
name|Timestamp
name|toTimestampFun
parameter_list|(
name|Long
name|v
parameter_list|)
block|{
return|return
name|SqlFunctions
operator|.
name|internalToTimestamp
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|java
operator|.
name|sql
operator|.
name|Time
name|toTimeFun
parameter_list|(
name|Long
name|v
parameter_list|)
block|{
return|return
name|v
operator|==
literal|null
condition|?
literal|null
else|:
name|SqlFunctions
operator|.
name|internalToTime
argument_list|(
name|v
operator|.
name|intValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|List
name|arrayAppendFun
parameter_list|(
name|List
name|v
parameter_list|,
name|Integer
name|i
parameter_list|)
block|{
if|if
condition|(
name|v
operator|==
literal|null
operator|||
name|i
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|v
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
comment|/** Overloaded functions with DATE, TIMESTAMP and TIME arguments. */
specifier|public
specifier|static
name|long
name|toLong
parameter_list|(
name|Date
name|date
parameter_list|)
block|{
return|return
name|date
operator|==
literal|null
condition|?
literal|0
else|:
name|SqlFunctions
operator|.
name|toLong
argument_list|(
name|date
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|toLong
parameter_list|(
name|Timestamp
name|timestamp
parameter_list|)
block|{
return|return
name|timestamp
operator|==
literal|null
condition|?
literal|0
else|:
name|SqlFunctions
operator|.
name|toLong
argument_list|(
name|timestamp
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|toLong
parameter_list|(
name|Time
name|time
parameter_list|)
block|{
return|return
name|time
operator|==
literal|null
condition|?
literal|0
else|:
name|SqlFunctions
operator|.
name|toLong
argument_list|(
name|time
argument_list|)
return|;
block|}
block|}
comment|/** Example of a user-defined aggregate function (UDAF). */
specifier|public
specifier|static
class|class
name|MySumFunction
block|{
specifier|public
name|MySumFunction
parameter_list|()
block|{
block|}
specifier|public
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
name|long
name|add
parameter_list|(
name|long
name|accumulator
parameter_list|,
name|int
name|v
parameter_list|)
block|{
return|return
name|accumulator
operator|+
name|v
return|;
block|}
specifier|public
name|long
name|merge
parameter_list|(
name|long
name|accumulator0
parameter_list|,
name|long
name|accumulator1
parameter_list|)
block|{
return|return
name|accumulator0
operator|+
name|accumulator1
return|;
block|}
specifier|public
name|long
name|result
parameter_list|(
name|long
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
comment|/** A generic interface for defining user defined aggregate functions    *    * @param<A> accumulator type    * @param<V> value type    * @param<R> result type */
specifier|private
interface|interface
name|MyGenericAggFunction
parameter_list|<
name|A
parameter_list|,
name|V
parameter_list|,
name|R
parameter_list|>
block|{
name|A
name|init
parameter_list|()
function_decl|;
name|A
name|add
parameter_list|(
name|A
name|accumulator
parameter_list|,
name|V
name|val
parameter_list|)
function_decl|;
name|A
name|merge
parameter_list|(
name|A
name|accumulator1
parameter_list|,
name|A
name|accumulator2
parameter_list|)
function_decl|;
name|R
name|result
parameter_list|(
name|A
name|accumulator
parameter_list|)
function_decl|;
block|}
comment|/** Example of a user-defined aggregate function that implements a generic    * interface. */
specifier|public
specifier|static
class|class
name|MySum3
implements|implements
name|MyGenericAggFunction
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|,
name|Integer
argument_list|>
block|{
specifier|public
name|Integer
name|init
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|public
name|Integer
name|add
parameter_list|(
name|Integer
name|accumulator
parameter_list|,
name|Integer
name|val
parameter_list|)
block|{
return|return
name|accumulator
operator|+
name|val
return|;
block|}
specifier|public
name|Integer
name|merge
parameter_list|(
name|Integer
name|accumulator1
parameter_list|,
name|Integer
name|accumulator2
parameter_list|)
block|{
return|return
name|accumulator1
operator|+
name|accumulator2
return|;
block|}
specifier|public
name|Integer
name|result
parameter_list|(
name|Integer
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
comment|/** Example of a user-defined aggregate function (UDAF), whose methods are    * static. */
specifier|public
specifier|static
class|class
name|MyStaticSumFunction
block|{
specifier|public
specifier|static
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
specifier|static
name|long
name|add
parameter_list|(
name|long
name|accumulator
parameter_list|,
name|int
name|v
parameter_list|)
block|{
return|return
name|accumulator
operator|+
name|v
return|;
block|}
specifier|public
specifier|static
name|long
name|merge
parameter_list|(
name|long
name|accumulator0
parameter_list|,
name|long
name|accumulator1
parameter_list|)
block|{
return|return
name|accumulator0
operator|+
name|accumulator1
return|;
block|}
specifier|public
specifier|static
name|long
name|result
parameter_list|(
name|long
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
comment|/** Example of a user-defined aggregate function (UDAF). */
specifier|public
specifier|static
class|class
name|MyTwoParamsSumFunctionFilter1
block|{
specifier|public
name|MyTwoParamsSumFunctionFilter1
parameter_list|()
block|{
block|}
specifier|public
name|int
name|init
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|public
name|int
name|add
parameter_list|(
name|int
name|accumulator
parameter_list|,
name|int
name|v1
parameter_list|,
name|int
name|v2
parameter_list|)
block|{
if|if
condition|(
name|v1
operator|>
name|v2
condition|)
block|{
return|return
name|accumulator
operator|+
name|v1
return|;
block|}
return|return
name|accumulator
return|;
block|}
specifier|public
name|int
name|merge
parameter_list|(
name|int
name|accumulator0
parameter_list|,
name|int
name|accumulator1
parameter_list|)
block|{
return|return
name|accumulator0
operator|+
name|accumulator1
return|;
block|}
specifier|public
name|int
name|result
parameter_list|(
name|int
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
comment|/** Example of a user-defined aggregate function (UDAF). */
specifier|public
specifier|static
class|class
name|MyTwoParamsSumFunctionFilter2
block|{
specifier|public
name|MyTwoParamsSumFunctionFilter2
parameter_list|()
block|{
block|}
specifier|public
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
name|long
name|add
parameter_list|(
name|long
name|accumulator
parameter_list|,
name|int
name|v1
parameter_list|,
name|String
name|v2
parameter_list|)
block|{
if|if
condition|(
name|v2
operator|.
name|equals
argument_list|(
literal|"Eric"
argument_list|)
condition|)
block|{
return|return
name|accumulator
operator|+
name|v1
return|;
block|}
return|return
name|accumulator
return|;
block|}
specifier|public
name|long
name|merge
parameter_list|(
name|long
name|accumulator0
parameter_list|,
name|long
name|accumulator1
parameter_list|)
block|{
return|return
name|accumulator0
operator|+
name|accumulator1
return|;
block|}
specifier|public
name|long
name|result
parameter_list|(
name|long
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
comment|/** Example of a user-defined aggregate function (UDAF), whose methods are    * static. */
specifier|public
specifier|static
class|class
name|MyThreeParamsSumFunctionWithFilter1
block|{
specifier|public
specifier|static
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
specifier|static
name|long
name|add
parameter_list|(
name|long
name|accumulator
parameter_list|,
name|int
name|v1
parameter_list|,
name|String
name|v2
parameter_list|,
name|String
name|v3
parameter_list|)
block|{
if|if
condition|(
name|v2
operator|.
name|equals
argument_list|(
name|v3
argument_list|)
condition|)
block|{
return|return
name|accumulator
operator|+
name|v1
return|;
block|}
return|return
name|accumulator
return|;
block|}
specifier|public
specifier|static
name|long
name|merge
parameter_list|(
name|long
name|accumulator0
parameter_list|,
name|long
name|accumulator1
parameter_list|)
block|{
return|return
name|accumulator0
operator|+
name|accumulator1
return|;
block|}
specifier|public
specifier|static
name|long
name|result
parameter_list|(
name|long
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
comment|/** Example of a user-defined aggregate function (UDAF), whose methods are    * static. olny for validate to get exact function by calcite*/
specifier|public
specifier|static
class|class
name|MyThreeParamsSumFunctionWithFilter2
block|{
specifier|public
specifier|static
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
specifier|static
name|long
name|add
parameter_list|(
name|long
name|accumulator
parameter_list|,
name|int
name|v1
parameter_list|,
name|int
name|v2
parameter_list|,
name|int
name|v3
parameter_list|)
block|{
if|if
condition|(
name|v3
operator|>
literal|250
condition|)
block|{
return|return
name|accumulator
operator|+
name|v1
operator|+
name|v2
return|;
block|}
return|return
name|accumulator
return|;
block|}
specifier|public
specifier|static
name|long
name|merge
parameter_list|(
name|long
name|accumulator0
parameter_list|,
name|long
name|accumulator1
parameter_list|)
block|{
return|return
name|accumulator0
operator|+
name|accumulator1
return|;
block|}
specifier|public
specifier|static
name|long
name|result
parameter_list|(
name|long
name|accumulator
parameter_list|)
block|{
return|return
name|accumulator
return|;
block|}
block|}
comment|/** User-defined function. */
specifier|public
specifier|static
class|class
name|SumFunctionBadIAdd
block|{
specifier|public
name|long
name|init
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
specifier|public
name|long
name|add
parameter_list|(
name|short
name|accumulator
parameter_list|,
name|int
name|v
parameter_list|)
block|{
return|return
name|accumulator
operator|+
name|v
return|;
block|}
block|}
comment|/** User-defined table-macro function. */
specifier|public
specifier|static
class|class
name|TableMacroFunction
block|{
specifier|public
name|TranslatableTable
name|eval
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|view
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
comment|/** User-defined table-macro function whose eval method is static. */
specifier|public
specifier|static
class|class
name|StaticTableMacroFunction
block|{
specifier|public
specifier|static
name|TranslatableTable
name|eval
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|view
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
comment|/** User-defined table-macro function with named and optional parameters. */
specifier|public
specifier|static
class|class
name|TableMacroFunctionWithNamedParameters
block|{
specifier|public
name|TranslatableTable
name|eval
parameter_list|(
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"R"
argument_list|,
name|optional
operator|=
literal|true
argument_list|)
name|String
name|r
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"S"
argument_list|)
name|String
name|s
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"T"
argument_list|,
name|optional
operator|=
literal|true
argument_list|)
name|Integer
name|t
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|abc
argument_list|(
name|sb
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|abc
argument_list|(
name|sb
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|abc
argument_list|(
name|sb
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|view
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|abc
parameter_list|(
name|StringBuilder
name|sb
parameter_list|,
name|Object
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** A table function that returns a {@link QueryableTable}. */
specifier|public
specifier|static
class|class
name|MyTableFunction
block|{
specifier|public
name|QueryableTable
name|eval
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|oneThreePlus
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
comment|/** A table function that returns a {@link QueryableTable} via a    * static method. */
specifier|public
specifier|static
class|class
name|TestStaticTableFunction
block|{
specifier|public
specifier|static
name|QueryableTable
name|eval
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|oneThreePlus
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
comment|/** The real MazeTable may be found in example/function. This is a cut-down    * version to support a test. */
specifier|public
specifier|static
class|class
name|MazeTable
extends|extends
name|AbstractTable
implements|implements
name|ScannableTable
block|{
specifier|private
specifier|final
name|String
name|content
decl_stmt|;
specifier|public
name|MazeTable
parameter_list|(
name|String
name|content
parameter_list|)
block|{
name|this
operator|.
name|content
operator|=
name|content
expr_stmt|;
block|}
specifier|public
specifier|static
name|ScannableTable
name|generate
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|seed
parameter_list|)
block|{
return|return
operator|new
name|MazeTable
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"generate(w=%d, h=%d, s=%d)"
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|seed
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ScannableTable
name|generate2
parameter_list|(
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"WIDTH"
argument_list|)
name|int
name|width
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"HEIGHT"
argument_list|)
name|int
name|height
parameter_list|,
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"SEED"
argument_list|,
name|optional
operator|=
literal|true
argument_list|)
name|Integer
name|seed
parameter_list|)
block|{
return|return
operator|new
name|MazeTable
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"generate2(w=%d, h=%d, s=%d)"
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|seed
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ScannableTable
name|generate3
parameter_list|(
annotation|@
name|Parameter
argument_list|(
name|name
operator|=
literal|"FOO"
argument_list|)
name|String
name|foo
parameter_list|)
block|{
return|return
operator|new
name|MazeTable
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"generate3(foo=%s)"
argument_list|,
name|foo
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|getRowType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"S"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|12
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
name|Enumerable
argument_list|<
name|Object
index|[]
argument_list|>
name|scan
parameter_list|(
name|DataContext
name|root
parameter_list|)
block|{
name|Object
index|[]
index|[]
name|rows
init|=
block|{
block|{
literal|"abcde"
block|}
block|,
block|{
literal|"xyz"
block|}
block|,
block|{
name|content
block|}
block|}
decl_stmt|;
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|rows
argument_list|)
return|;
block|}
block|}
comment|/** Schema containing a {@code prod} table with a lot of columns. */
specifier|public
specifier|static
class|class
name|WideSaleSchema
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"WideSaleSchema"
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|public
specifier|final
name|WideProductSale
index|[]
name|prod
init|=
block|{
operator|new
name|WideProductSale
argument_list|(
literal|100
argument_list|,
literal|10
argument_list|)
block|}
decl_stmt|;
block|}
comment|/** Table with a lot of columns. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|public
specifier|static
class|class
name|WideProductSale
block|{
specifier|public
specifier|final
name|int
name|prodId
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale0
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale1
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale2
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale3
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale4
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale5
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale6
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale7
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale8
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale9
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale10
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale11
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale12
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale13
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale14
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale15
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale16
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale17
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale18
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale19
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale20
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale21
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale22
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale23
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale24
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale25
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale26
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale27
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale28
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale29
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale30
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale31
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale32
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale33
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale34
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale35
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale36
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale37
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale38
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale39
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale40
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale41
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale42
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale43
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale44
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale45
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale46
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale47
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale48
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale49
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale50
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale51
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale52
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale53
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale54
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale55
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale56
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale57
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale58
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale59
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale60
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale61
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale62
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale63
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale64
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale65
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale66
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale67
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale68
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale69
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale70
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale71
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale72
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale73
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale74
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale75
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale76
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale77
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale78
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale79
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale80
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale81
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale82
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale83
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale84
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale85
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale86
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale87
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale88
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale89
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale90
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale91
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale92
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale93
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale94
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale95
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale96
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale97
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale98
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale99
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale100
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale101
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale102
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale103
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale104
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale105
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale106
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale107
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale108
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale109
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale110
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale111
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale112
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale113
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale114
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale115
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale116
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale117
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale118
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale119
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale120
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale121
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale122
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale123
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale124
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale125
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale126
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale127
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale128
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale129
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale130
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale131
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale132
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale133
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale134
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale135
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale136
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale137
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale138
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale139
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale140
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale141
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale142
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale143
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale144
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale145
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale146
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale147
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale148
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale149
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale150
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale151
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale152
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale153
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale154
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale155
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale156
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale157
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale158
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale159
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale160
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale161
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale162
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale163
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale164
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale165
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale166
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale167
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale168
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale169
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale170
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale171
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale172
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale173
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale174
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale175
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale176
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale177
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale178
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale179
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale180
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale181
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale182
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale183
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale184
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale185
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale186
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale187
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale188
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale189
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale190
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale191
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale192
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale193
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale194
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale195
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale196
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale197
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale198
init|=
literal|10
decl_stmt|;
specifier|public
specifier|final
name|double
name|sale199
init|=
literal|10
decl_stmt|;
specifier|public
name|WideProductSale
parameter_list|(
name|int
name|prodId
parameter_list|,
name|double
name|sale
parameter_list|)
block|{
name|this
operator|.
name|prodId
operator|=
name|prodId
expr_stmt|;
name|this
operator|.
name|sale0
operator|=
name|sale
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Smalls.java
end_comment

end_unit

