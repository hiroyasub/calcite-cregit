begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
package|;
end_package

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * ReflectVisitorTest tests {@link ReflectUtil#invokeVisitor} and  * {@link ReflectiveVisitor} and provides a contrived example of how to use  * them.  */
end_comment

begin_class
class|class
name|ReflectVisitorTest
block|{
comment|/**    * Tests CarelessNumberNegater.    */
annotation|@
name|Test
name|void
name|testCarelessNegater
parameter_list|()
block|{
name|NumberNegater
name|negater
init|=
operator|new
name|CarelessNumberNegater
argument_list|()
decl_stmt|;
name|Number
name|result
decl_stmt|;
comment|// verify that negater is capable of handling integers
name|result
operator|=
name|negater
operator|.
name|negate
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|5
argument_list|,
name|result
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests CarefulNumberNegater.    */
annotation|@
name|Test
name|void
name|testCarefulNegater
parameter_list|()
block|{
name|NumberNegater
name|negater
init|=
operator|new
name|CarefulNumberNegater
argument_list|()
decl_stmt|;
name|Number
name|result
decl_stmt|;
comment|// verify that negater is capable of handling integers,
comment|// and that result comes back with same type
name|result
operator|=
name|negater
operator|.
name|negate
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|5
argument_list|,
name|result
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|Integer
argument_list|)
expr_stmt|;
comment|// verify that negater is capable of handling longs;
comment|// even though it doesn't provide an explicit implementation,
comment|// it should inherit the one from CarelessNumberNegater
name|result
operator|=
name|negater
operator|.
name|negate
argument_list|(
literal|5L
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|5L
argument_list|,
name|result
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests CluelessNumberNegater.    */
annotation|@
name|Test
name|void
name|testCluelessNegater
parameter_list|()
block|{
name|NumberNegater
name|negater
init|=
operator|new
name|CluelessNumberNegater
argument_list|()
decl_stmt|;
name|Number
name|result
decl_stmt|;
comment|// verify that negater is capable of handling shorts,
comment|// and that result comes back with same type
name|result
operator|=
name|negater
operator|.
name|negate
argument_list|(
operator|(
name|short
operator|)
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|5
argument_list|,
name|result
operator|.
name|shortValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|Short
argument_list|)
expr_stmt|;
comment|// verify that negater is NOT capable of handling integers
name|result
operator|=
name|negater
operator|.
name|negate
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|null
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests for ambiguity detection in method lookup.    */
annotation|@
name|Test
name|void
name|testAmbiguity
parameter_list|()
block|{
name|NumberNegater
name|negater
init|=
operator|new
name|IndecisiveNumberNegater
argument_list|()
decl_stmt|;
name|Number
name|result
decl_stmt|;
try|try
block|{
name|result
operator|=
name|negater
operator|.
name|negate
argument_list|(
operator|new
name|AmbiguousNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
comment|// expected
name|assertTrue
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"ambiguity"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fail
argument_list|(
literal|"Expected failure due to ambiguity"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that ambiguity detection in method lookup does not kick in when a    * better match is available.    */
annotation|@
name|Test
name|void
name|testNonAmbiguity
parameter_list|()
block|{
name|NumberNegater
name|negater
init|=
operator|new
name|SomewhatIndecisiveNumberNegater
argument_list|()
decl_stmt|;
name|Number
name|result
decl_stmt|;
name|result
operator|=
name|negater
operator|.
name|negate
argument_list|(
operator|new
name|SomewhatAmbiguousNumber
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0.0
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.001
argument_list|)
expr_stmt|;
block|}
comment|//~ Inner Interfaces -------------------------------------------------------
comment|/**    * An interface for introducing ambiguity into the class hierarchy.    */
specifier|public
interface|interface
name|CrunchableNumber
block|{   }
comment|/**    * An interface for introducing ambiguity into the class hierarchy.    */
specifier|public
interface|interface
name|FudgeableNumber
block|{   }
comment|/** Sub-interface of {@link FudgeableNumber}. */
specifier|public
interface|interface
name|DiceyNumber
extends|extends
name|FudgeableNumber
block|{   }
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * NumberNegater defines the abstract base for a computation object capable    * of negating an arbitrary number. Subclasses implement the computation by    * publishing methods with the signature "void visit(X x)" where X is a    * subclass of Number.    */
specifier|public
specifier|abstract
class|class
name|NumberNegater
implements|implements
name|ReflectiveVisitor
block|{
specifier|protected
name|Number
name|result
decl_stmt|;
specifier|private
specifier|final
name|ReflectiveVisitDispatcher
argument_list|<
name|NumberNegater
argument_list|,
name|Number
argument_list|>
name|dispatcher
init|=
name|ReflectUtil
operator|.
name|createDispatcher
argument_list|(
name|NumberNegater
operator|.
name|class
argument_list|,
name|Number
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Negates the given number.      *      * @param n the number to be negated      * @return the negated result; not guaranteed to be the same concrete      * type as n; null is returned if n's type wasn't handled      */
specifier|public
name|Number
name|negate
parameter_list|(
name|Number
name|n
parameter_list|)
block|{
comment|// we specify Number.class as the hierarchy root so
comment|// that extraneous visit methods are ignored
name|result
operator|=
literal|null
expr_stmt|;
name|dispatcher
operator|.
name|invokeVisitor
argument_list|(
name|this
argument_list|,
name|n
argument_list|,
literal|"visit"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Negates the given number without using a dispatcher object to cache      * applicable methods. The results should be the same as      * {@link #negate(Number)}.      *      * @param n the number to be negated      * @return the negated result; not guaranteed to be the same concrete      * type as n; null is returned if n's type wasn't handled      */
specifier|public
name|Number
name|negateWithoutDispatcher
parameter_list|(
name|Number
name|n
parameter_list|)
block|{
comment|// we specify Number.class as the hierarchy root so
comment|// that extraneous visit methods are ignored
name|result
operator|=
literal|null
expr_stmt|;
name|ReflectUtil
operator|.
name|invokeVisitor
argument_list|(
name|this
argument_list|,
name|n
argument_list|,
name|Number
operator|.
name|class
argument_list|,
literal|"visit"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/**    * CarelessNumberNegater implements NumberNegater in a careless fashion by    * converting its input to a double and then negating that. This can lose    * precision for types such as BigInteger.    */
specifier|public
class|class
name|CarelessNumberNegater
extends|extends
name|NumberNegater
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|Number
name|n
parameter_list|)
block|{
name|result
operator|=
operator|-
name|n
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * CarefulNumberNegater implements NumberNegater in a careful fashion by    * providing overloads for each known subclass of Number and returning the    * same subclass for the result. Extends CarelessNumberNegater so that it    * can still handle unknown types of Number.    */
specifier|public
class|class
name|CarefulNumberNegater
extends|extends
name|CarelessNumberNegater
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|Integer
name|i
parameter_list|)
block|{
name|result
operator|=
operator|-
name|i
expr_stmt|;
assert|assert
name|result
operator|instanceof
name|Integer
assert|;
block|}
specifier|public
name|void
name|visit
parameter_list|(
name|Short
name|s
parameter_list|)
block|{
name|result
operator|=
operator|-
name|s
expr_stmt|;
assert|assert
name|result
operator|instanceof
name|Short
assert|;
block|}
comment|// ... imagine implementations for other Number subclasses here ...
block|}
comment|/**    * CluelessNumberNegater implements NumberNegater in a very broken fashion;    * does the right thing for Shorts, but attempts to override visit(Object).    * This is just here for testing the hierarchyRoot parameter of    * invokeVisitor.    */
specifier|public
class|class
name|CluelessNumberNegater
extends|extends
name|NumberNegater
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
name|result
operator|=
literal|42
expr_stmt|;
block|}
specifier|public
name|void
name|visit
parameter_list|(
name|Short
name|s
parameter_list|)
block|{
name|result
operator|=
operator|(
name|short
operator|)
operator|-
name|s
expr_stmt|;
assert|assert
name|result
operator|instanceof
name|Short
assert|;
block|}
block|}
comment|/**    * IndecisiveNumberNegater implements NumberNegater in such a way that it    * doesn't know what to do when presented with an AmbiguousNumber.    */
specifier|public
class|class
name|IndecisiveNumberNegater
extends|extends
name|NumberNegater
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|CrunchableNumber
name|n
parameter_list|)
block|{
block|}
specifier|public
name|void
name|visit
parameter_list|(
name|FudgeableNumber
name|n
parameter_list|)
block|{
block|}
block|}
comment|/**    * SomewhatIndecisiveNumberNegater implements NumberNegater in such a way    * that it knows what to do when presented with a SomewhatAmbiguousNumber.    */
specifier|public
class|class
name|SomewhatIndecisiveNumberNegater
extends|extends
name|NumberNegater
block|{
specifier|public
name|void
name|visit
parameter_list|(
name|FudgeableNumber
name|n
parameter_list|)
block|{
block|}
specifier|public
name|void
name|visit
parameter_list|(
name|AmbiguousNumber
name|n
parameter_list|)
block|{
name|result
operator|=
operator|-
name|n
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
assert|assert
name|result
operator|instanceof
name|Double
assert|;
block|}
block|}
comment|/**    * A class inheriting two interfaces, leading to ambiguity.    */
specifier|public
class|class
name|AmbiguousNumber
extends|extends
name|BigDecimal
implements|implements
name|CrunchableNumber
implements|,
name|FudgeableNumber
block|{
name|AmbiguousNumber
parameter_list|()
block|{
name|super
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A class inheriting a root interface (FudgeableNumber) two different ways,    * which should not lead to ambiguity in some cases.    */
specifier|public
class|class
name|SomewhatAmbiguousNumber
extends|extends
name|AmbiguousNumber
implements|implements
name|DiceyNumber
block|{   }
block|}
end_class

end_unit

