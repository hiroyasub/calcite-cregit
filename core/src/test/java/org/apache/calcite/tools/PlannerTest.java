begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableTableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|ReflectiveSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcImplementor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|Lex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ConventionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|convert
operator|.
name|ConverterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectToWindowRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunctionCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|OperandTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|ChainedSqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|ListSqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|CalciteAssert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Optionality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Throwables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|operand
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|containsString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|notNullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|core
operator|.
name|Is
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Unit tests for {@link Planner}.  */
end_comment

begin_class
specifier|public
class|class
name|PlannerTest
block|{
specifier|private
name|void
name|checkParseAndConvert
parameter_list|(
name|String
name|query
parameter_list|,
name|String
name|queryFromParseTree
parameter_list|,
name|String
name|expectedRelExpr
parameter_list|)
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|parse
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|queryFromParseTree
argument_list|)
argument_list|)
expr_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|rel
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|rel
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|expectedRelExpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testParseAndConvert
parameter_list|()
throws|throws
name|Exception
block|{
name|checkParseAndConvert
argument_list|(
literal|"select * from \"emps\" where \"name\" like '%e%'"
argument_list|,
literal|"SELECT *\n"
operator|+
literal|"FROM `emps`\n"
operator|+
literal|"WHERE `name` LIKE '%e%'"
argument_list|,
literal|"LogicalProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  LogicalFilter(condition=[LIKE($2, '%e%')])\n"
operator|+
literal|"    EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|SqlParseException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testParseIdentiferMaxLengthWithDefault
parameter_list|()
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|SqlParser
operator|.
name|configBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|planner
operator|.
name|parse
argument_list|(
literal|"select name as "
operator|+
literal|"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa from \"emps\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testParseIdentiferMaxLengthWithIncreased
parameter_list|()
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|SqlParser
operator|.
name|configBuilder
argument_list|()
operator|.
name|setIdentifierMaxLength
argument_list|(
literal|512
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|planner
operator|.
name|parse
argument_list|(
literal|"select name as "
operator|+
literal|"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa from \"emps\""
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates and converts the query using    * order by and offset. */
annotation|@
name|Test
specifier|public
name|void
name|testParseAndConvertWithOrderByAndOffset
parameter_list|()
throws|throws
name|Exception
block|{
name|checkParseAndConvert
argument_list|(
literal|"select * from \"emps\" "
operator|+
literal|"order by \"emps\".\"deptno\" offset 10"
argument_list|,
literal|"SELECT *\n"
operator|+
literal|"FROM `emps`\n"
operator|+
literal|"ORDER BY `emps`.`deptno`\n"
operator|+
literal|"OFFSET 10 ROWS"
argument_list|,
literal|"LogicalSort(sort0=[$1], dir0=[ASC], offset=[10])\n"
operator|+
literal|"  LogicalProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"    EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|toString
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|Util
operator|.
name|toLinux
argument_list|(
name|RelOptUtil
operator|.
name|dumpPlan
argument_list|(
literal|""
argument_list|,
name|rel
argument_list|,
name|SqlExplainFormat
operator|.
name|TEXT
argument_list|,
name|SqlExplainLevel
operator|.
name|DIGEST_ATTRIBUTES
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testParseFails
parameter_list|()
throws|throws
name|SqlParseException
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * * from \"emps\""
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|parse
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"Encountered \"*\" at line 1, column 10."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValidateFails
parameter_list|()
throws|throws
name|SqlParseException
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\" where \"Xname\" like '%e%'"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|parse
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"SELECT *\n"
operator|+
literal|"FROM `emps`\n"
operator|+
literal|"WHERE `Xname` LIKE '%e%'"
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|validate
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ValidationException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|Throwables
operator|.
name|getStackTraceAsString
argument_list|(
name|e
argument_list|)
argument_list|,
name|containsString
argument_list|(
literal|"Column 'Xname' not found in any table"
argument_list|)
argument_list|)
expr_stmt|;
comment|// ok
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValidateUserDefinedAggregate
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|SqlStdOperatorTable
name|stdOpTab
init|=
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
decl_stmt|;
name|SqlOperatorTable
name|opTab
init|=
name|ChainedSqlOperatorTable
operator|.
name|of
argument_list|(
name|stdOpTab
argument_list|,
operator|new
name|ListSqlOperatorTable
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
operator|new
name|MyCountAggFunction
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|defaultSchema
argument_list|(
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|HR
argument_list|)
argument_list|)
operator|.
name|operatorTable
argument_list|(
name|opTab
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Planner
name|planner
init|=
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select \"deptno\", my_count(\"empid\") from \"emps\"\n"
operator|+
literal|"group by \"deptno\""
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|parse
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"SELECT `deptno`, `MY_COUNT`(`empid`)\n"
operator|+
literal|"FROM `emps`\n"
operator|+
literal|"GROUP BY `deptno`"
argument_list|)
argument_list|)
expr_stmt|;
comment|// MY_COUNT is recognized as an aggregate function, and therefore it is OK
comment|// that its argument empid is not in the GROUP BY clause.
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|validate
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// The presence of an aggregate function in the SELECT clause causes it
comment|// to become an aggregate query. Non-aggregate expressions become illegal.
name|planner
operator|.
name|close
argument_list|()
expr_stmt|;
name|planner
operator|.
name|reset
argument_list|()
expr_stmt|;
name|parse
operator|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select \"deptno\", count(1) from \"emps\""
argument_list|)
expr_stmt|;
try|try
block|{
name|validate
operator|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected exception, got "
operator|+
name|validate
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ValidationException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"Expression 'deptno' is not being grouped"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Planner
name|getPlanner
parameter_list|(
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
parameter_list|,
name|Program
modifier|...
name|programs
parameter_list|)
block|{
return|return
name|getPlanner
argument_list|(
name|traitDefs
argument_list|,
name|SqlParser
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|,
name|programs
argument_list|)
return|;
block|}
specifier|private
name|Planner
name|getPlanner
parameter_list|(
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
parameter_list|,
name|SqlParser
operator|.
name|Config
name|parserConfig
parameter_list|,
name|Program
modifier|...
name|programs
parameter_list|)
block|{
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|parserConfig
argument_list|(
name|parserConfig
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|HR
argument_list|)
argument_list|)
operator|.
name|traitDefs
argument_list|(
name|traitDefs
argument_list|)
operator|.
name|programs
argument_list|(
name|programs
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
return|;
block|}
comment|/** Tests that planner throws an error if you pass to    * {@link Planner#rel(org.apache.calcite.sql.SqlNode)}    * a {@link org.apache.calcite.sql.SqlNode} that has been parsed but not    * validated. */
annotation|@
name|Test
specifier|public
name|void
name|testConvertWithoutValidateFails
parameter_list|()
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
try|try
block|{
name|RelRoot
name|rel
init|=
name|planner
operator|.
name|rel
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|rel
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"cannot move from STATE_3_PARSED to STATE_4_VALIDATED"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Helper method for testing {@link RelMetadataQuery#getPulledUpPredicates}    * metadata. */
specifier|private
name|void
name|checkMetadataPredicates
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expectedPredicates
parameter_list|)
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|rel
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|String
name|buf
init|=
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|buf
argument_list|,
name|equalTo
argument_list|(
name|expectedPredicates
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests predicates that can be pulled-up from a UNION. */
annotation|@
name|Test
specifier|public
name|void
name|testMetadataUnionPredicates
parameter_list|()
throws|throws
name|Exception
block|{
name|checkMetadataPredicates
argument_list|(
literal|"select * from \"emps\" where \"deptno\"< 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from \"emps\" where \"empid\"> 2"
argument_list|,
literal|"[OR(<($1, 10),>($0, 2))]"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-443">[CALCITE-443]    * getPredicates from a union is not correct</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testMetadataUnionPredicates2
parameter_list|()
throws|throws
name|Exception
block|{
name|checkMetadataPredicates
argument_list|(
literal|"select * from \"emps\" where \"deptno\"< 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from \"emps\""
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMetadataUnionPredicates3
parameter_list|()
throws|throws
name|Exception
block|{
name|checkMetadataPredicates
argument_list|(
literal|"select * from \"emps\" where \"deptno\"< 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from \"emps\" where \"deptno\"< 10 and \"empid\"> 1"
argument_list|,
literal|"[<($1, 10)]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMetadataUnionPredicates4
parameter_list|()
throws|throws
name|Exception
block|{
name|checkMetadataPredicates
argument_list|(
literal|"select * from \"emps\" where \"deptno\"< 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from \"emps\" where \"deptno\"< 10 or \"empid\"> 1"
argument_list|,
literal|"[OR(<($1, 10),>($0, 1))]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMetadataUnionPredicates5
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from \"emps\" where \"deptno\"< 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from \"emps\" where \"deptno\"< 10 and false"
decl_stmt|;
name|checkMetadataPredicates
argument_list|(
name|sql
argument_list|,
literal|"[<($1, 10)]"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests predicates that can be pulled-up from an Aggregate with    * {@code GROUP BY ()}. This form of Aggregate can convert an empty relation    * to a single-row relation, so it is not valid to pull up the predicate    * {@code false}. */
annotation|@
name|Test
specifier|public
name|void
name|testMetadataAggregatePredicates
parameter_list|()
throws|throws
name|Exception
block|{
name|checkMetadataPredicates
argument_list|(
literal|"select count(*) from \"emps\" where false"
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests predicates that can be pulled-up from an Aggregate with a non-empty    * group key. The {@code false} predicate effectively means that the relation    * is empty, because no row can satisfy {@code false}. */
annotation|@
name|Test
specifier|public
name|void
name|testMetadataAggregatePredicates2
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select \"deptno\", count(\"deptno\")\n"
operator|+
literal|"from \"emps\" where false\n"
operator|+
literal|"group by \"deptno\""
decl_stmt|;
name|checkMetadataPredicates
argument_list|(
name|sql
argument_list|,
literal|"[false]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMetadataAggregatePredicates3
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select \"deptno\", count(\"deptno\")\n"
operator|+
literal|"from \"emps\" where \"deptno\"> 10\n"
operator|+
literal|"group by \"deptno\""
decl_stmt|;
name|checkMetadataPredicates
argument_list|(
name|sql
argument_list|,
literal|"[>($0, 10)]"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and plans. */
annotation|@
name|Test
specifier|public
name|void
name|testPlan
parameter_list|()
throws|throws
name|Exception
block|{
name|Program
name|program
init|=
name|Programs
operator|.
name|ofRules
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|program
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and    * plans for query using order by */
annotation|@
name|Test
specifier|public
name|void
name|testSortPlan
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|SortRemoveRule
operator|.
name|INSTANCE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\" "
operator|+
literal|"order by \"emps\".\"deptno\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"  EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"    EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and    * plans for query using two duplicate order by.    * The duplicate order by should be removed by SortRemoveRule. */
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateSortPlan
parameter_list|()
throws|throws
name|Exception
block|{
name|runDuplicateSortCheck
argument_list|(
literal|"select empid from ( "
operator|+
literal|"select * "
operator|+
literal|"from emps "
operator|+
literal|"order by emps.deptno) "
operator|+
literal|"order by deptno"
argument_list|,
literal|"EnumerableProject(empid=[$0], deptno=[$1])\n"
operator|+
literal|"  EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"    EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"      EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and    * plans for query using two duplicate order by.    * The duplicate order by should be removed by SortRemoveRule*/
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateSortPlanWithExpr
parameter_list|()
throws|throws
name|Exception
block|{
name|runDuplicateSortCheck
argument_list|(
literal|"select empid+deptno from ( "
operator|+
literal|"select empid, deptno "
operator|+
literal|"from emps "
operator|+
literal|"order by emps.deptno) "
operator|+
literal|"order by deptno"
argument_list|,
literal|"EnumerableProject(EXPR$0=[+($0, $1)], deptno=[$1])\n"
operator|+
literal|"  EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"    EnumerableProject(empid=[$0], deptno=[$1])\n"
operator|+
literal|"      EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTwoSortDontRemove
parameter_list|()
throws|throws
name|Exception
block|{
name|runDuplicateSortCheck
argument_list|(
literal|"select empid+deptno from ( "
operator|+
literal|"select empid, deptno "
operator|+
literal|"from emps "
operator|+
literal|"order by empid) "
operator|+
literal|"order by deptno"
argument_list|,
literal|"EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"  EnumerableProject(EXPR$0=[+($0, $1)], deptno=[$1])\n"
operator|+
literal|"    EnumerableSort(sort0=[$0], dir0=[ASC])\n"
operator|+
literal|"      EnumerableProject(empid=[$0], deptno=[$1])\n"
operator|+
literal|"        EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that outer order by is not removed since window function    * might reorder the rows in-between */
annotation|@
name|Ignore
argument_list|(
literal|"Node [rel#22:Subset#3.ENUMERABLE.[2]] could not be implemented; planner state:\n"
operator|+
literal|"\n"
operator|+
literal|"Root: rel#22:Subset#3.ENUMERABLE.[2]"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateSortPlanWithOver
parameter_list|()
throws|throws
name|Exception
block|{
name|runDuplicateSortCheck
argument_list|(
literal|"select emp_cnt, empid+deptno from ( "
operator|+
literal|"select empid, deptno, count(*) over (partition by deptno) emp_cnt from ( "
operator|+
literal|"  select empid, deptno "
operator|+
literal|"    from emps "
operator|+
literal|"   order by emps.deptno) "
operator|+
literal|")"
operator|+
literal|"order by deptno"
argument_list|,
literal|"EnumerableProject(EXPR$0=[$0])\n"
operator|+
literal|"  EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"    EnumerableProject(EXPR$0=[+($0, $1)], deptno=[$1])\n"
operator|+
literal|"      EnumerableProject(empid=[$0], deptno=[$1], $2=[$2])\n"
operator|+
literal|"        EnumerableWindow(window#0=[window(partition {1} order by [] range between UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING aggs [COUNT()])])\n"
operator|+
literal|"          EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"            EnumerableProject(empid=[$0], deptno=[$1])\n"
operator|+
literal|"              EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateSortPlanWithRemovedOver
parameter_list|()
throws|throws
name|Exception
block|{
name|runDuplicateSortCheck
argument_list|(
literal|"select empid+deptno from ( "
operator|+
literal|"select empid, deptno, count(*) over (partition by deptno) emp_cnt from ( "
operator|+
literal|"  select empid, deptno "
operator|+
literal|"    from emps "
operator|+
literal|"   order by emps.deptno) "
operator|+
literal|")"
operator|+
literal|"order by deptno"
argument_list|,
literal|"EnumerableProject(EXPR$0=[+($0, $1)], deptno=[$1])\n"
operator|+
literal|"  EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"    EnumerableProject(empid=[$0], deptno=[$1])\n"
operator|+
literal|"      EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
expr_stmt|;
block|}
comment|// If proper "SqlParseException, ValidationException, RelConversionException"
comment|// is used, then checkstyle fails with
comment|// "Redundant throws: 'ValidationException' listed more then one time"
comment|// "Redundant throws: 'RelConversionException' listed more then one time"
specifier|private
name|void
name|runDuplicateSortCheck
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|plan
parameter_list|)
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|SortRemoveRule
operator|.
name|INSTANCE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_WINDOW_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|,
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|SqlParser
operator|.
name|configBuilder
argument_list|()
operator|.
name|setLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|rel
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
if|if
condition|(
name|traitSet
operator|.
name|getTrait
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// SortRemoveRule can only work if collation trait is enabled.
return|return;
block|}
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|plan
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and    * plans for query using two duplicate order by.*/
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateSortPlanWORemoveSortRule
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select \"empid\" from ( "
operator|+
literal|"select * "
operator|+
literal|"from \"emps\" "
operator|+
literal|"order by \"emps\".\"deptno\") "
operator|+
literal|"order by \"deptno\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|rel
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"  EnumerableProject(empid=[$0], deptno=[$1])\n"
operator|+
literal|"    EnumerableSort(sort0=[$1], dir0=[ASC])\n"
operator|+
literal|"      EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"        EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that parses, validates, converts and plans. Planner is    * provided with a list of RelTraitDefs to register. */
annotation|@
name|Test
specifier|public
name|void
name|testPlanWithExplicitTraitDefs
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|traitDefs
operator|.
name|add
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|traitDefs
operator|.
name|add
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
name|traitDefs
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that calls {@link Planner#transform} twice. */
annotation|@
name|Test
specifier|public
name|void
name|testPlanTransformTwice
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|RelNode
name|transform2
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|transform
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform2
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that calls {@link Planner#transform} twice with    *  rule name conflicts */
annotation|@
name|Test
specifier|public
name|void
name|testPlanTransformWithRuleNameConflicts
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Create two dummy rules with identical rules.
name|RelOptRule
name|rule1
init|=
operator|new
name|RelOptRule
argument_list|(
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|,
name|RelOptRule
operator|.
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"MYRULE"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
block|}
block|}
decl_stmt|;
name|RelOptRule
name|rule2
init|=
operator|new
name|RelOptRule
argument_list|(
name|operand
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|RelOptRule
operator|.
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"MYRULE"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
block|}
block|}
decl_stmt|;
name|RuleSet
name|ruleSet1
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|rule1
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
name|RuleSet
name|ruleSet2
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|rule2
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet1
argument_list|)
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet2
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from \"emps\""
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|rel
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|RelNode
name|transform2
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|1
argument_list|,
name|traitSet
argument_list|,
name|transform
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform2
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4])\n"
operator|+
literal|"  EnumerableTableScan(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that Hive dialect does not generate "AS". */
annotation|@
name|Test
specifier|public
name|void
name|testHiveDialect
parameter_list|()
throws|throws
name|SqlParseException
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select * from (select * from \"emps\") as t\n"
operator|+
literal|"where \"name\" like '%e%'"
argument_list|)
decl_stmt|;
specifier|final
name|SqlDialect
name|hiveDialect
init|=
name|SqlDialect
operator|.
name|DatabaseProduct
operator|.
name|HIVE
operator|.
name|getDialect
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|parse
operator|.
name|toSqlString
argument_list|(
name|hiveDialect
argument_list|)
operator|.
name|getSql
argument_list|()
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"SELECT *\n"
operator|+
literal|"FROM (SELECT *\n"
operator|+
literal|"FROM emps) T\n"
operator|+
literal|"WHERE name LIKE '%e%'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that calls {@link Planner#transform} twice,    * with different rule sets, with different conventions.    *    *<p>{@link org.apache.calcite.adapter.jdbc.JdbcConvention} is different    * from the typical convention in that it is not a singleton. Switching to    * a different instance causes problems unless planner state is wiped clean    * between calls to {@link Planner#transform}. */
annotation|@
name|Test
specifier|public
name|void
name|testPlanTransformWithDiffRuleSetAndConvention
parameter_list|()
throws|throws
name|Exception
block|{
name|Program
name|program0
init|=
name|Programs
operator|.
name|ofRules
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
decl_stmt|;
name|JdbcConvention
name|out
init|=
operator|new
name|JdbcConvention
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"myjdbc"
argument_list|)
decl_stmt|;
name|Program
name|program1
init|=
name|Programs
operator|.
name|ofRules
argument_list|(
operator|new
name|MockJdbcProjectRule
argument_list|(
name|out
argument_list|)
argument_list|,
operator|new
name|MockJdbcTableRule
argument_list|(
name|out
argument_list|)
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|program0
argument_list|,
name|program1
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
literal|"select T1.\"name\" from \"emps\" as T1 "
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|RelTraitSet
name|traitSet0
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelTraitSet
name|traitSet1
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet0
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|RelNode
name|transform2
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|1
argument_list|,
name|traitSet1
argument_list|,
name|transform
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform2
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"JdbcProject(name=[$2])\n"
operator|+
literal|"  MockJdbcTableScan(table=[[hr, emps]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test that plans a query with a large number of joins. */
annotation|@
name|Test
specifier|public
name|void
name|testPlanNWayJoin
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Here the times before and after enabling LoptOptimizeJoinRule.
comment|//
comment|// Note the jump between N=6 and N=7; LoptOptimizeJoinRule is disabled if
comment|// there are fewer than 6 joins (7 relations).
comment|//
comment|//       N    Before     After
comment|//         time (ms) time (ms)
comment|// ======= ========= =========
comment|//       5                 382
comment|//       6                 790
comment|//       7                  26
comment|//       9    6,000         39
comment|//      10    9,000         47
comment|//      11   19,000         67
comment|//      12   40,000         63
comment|//      13 OOM              96
comment|//      35 OOM           1,716
comment|//      60 OOM          12,230
name|checkJoinNWay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|// LoptOptimizeJoinRule disabled; takes about .4s
name|checkJoinNWay
argument_list|(
literal|9
argument_list|)
expr_stmt|;
comment|// LoptOptimizeJoinRule enabled; takes about 0.04s
name|checkJoinNWay
argument_list|(
literal|35
argument_list|)
expr_stmt|;
comment|// takes about 2s
if|if
condition|(
name|CalciteAssert
operator|.
name|ENABLE_SLOW
condition|)
block|{
name|checkJoinNWay
argument_list|(
literal|60
argument_list|)
expr_stmt|;
comment|// takes about 15s
block|}
block|}
specifier|private
name|void
name|checkJoinNWay
parameter_list|(
name|int
name|n
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"select *"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|"\nfrom "
else|:
literal|",\n "
argument_list|)
operator|.
name|append
argument_list|(
literal|"\"depts\" as d"
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|i
operator|==
literal|1
condition|?
literal|"\nwhere"
else|:
literal|"\nand"
argument_list|)
operator|.
name|append
argument_list|(
literal|" d"
argument_list|)
operator|.
name|append
argument_list|(
name|i
argument_list|)
operator|.
name|append
argument_list|(
literal|".\"deptno\" = d"
argument_list|)
operator|.
name|append
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|append
argument_list|(
literal|".\"deptno\""
argument_list|)
expr_stmt|;
block|}
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|heuristicJoinOrder
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|,
literal|false
argument_list|,
literal|6
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|containsString
argument_list|(
literal|"EnumerableJoin(condition=[=($0, $5)], joinType=[inner])"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-435">[CALCITE-435]    * LoptOptimizeJoinRule incorrectly re-orders outer joins</a>.    *    *<p>Checks the    * {@link org.apache.calcite.rel.rules.LoptOptimizeJoinRule} on a query with a    * left outer join.    *    *<p>Specifically, tests that a relation (dependents) in an inner join    * cannot be pushed into an outer join (emps left join depts).    */
annotation|@
name|Test
specifier|public
name|void
name|testHeuristicLeftJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from \"emps\" as e\n"
operator|+
literal|"left join \"depts\" as d on e.\"deptno\" = d.\"deptno\"\n"
operator|+
literal|"join \"dependents\" as p on e.\"empid\" = p.\"empid\""
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7], location=[$8], location9=[$9], empid0=[$10], name1=[$11])\n"
operator|+
literal|"  EnumerableProject(empid=[$2], deptno=[$3], name=[$4], salary=[$5], commission=[$6], deptno0=[$7], name0=[$8], employees=[$9], x=[$10], y=[$11], empid0=[$0], name1=[$1])\n"
operator|+
literal|"    EnumerableJoin(condition=[=($0, $2)], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableScan(table=[[hr, dependents]])\n"
operator|+
literal|"      EnumerableJoin(condition=[=($1, $5)], joinType=[left])\n"
operator|+
literal|"        EnumerableTableScan(table=[[hr, emps]])\n"
operator|+
literal|"        EnumerableProject(deptno=[$0], name=[$1], employees=[$2], x=[$3.x], y=[$3.y])\n"
operator|+
literal|"          EnumerableTableScan(table=[[hr, depts]])"
decl_stmt|;
name|checkHeuristic
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** It would probably be OK to transform    * {@code (emps right join depts) join dependents}    * to    * {@code (emps  join dependents) right join depts}    * but we do not currently allow it.    */
annotation|@
name|Test
specifier|public
name|void
name|testHeuristicPushInnerJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from \"emps\" as e\n"
operator|+
literal|"right join \"depts\" as d on e.\"deptno\" = d.\"deptno\"\n"
operator|+
literal|"join \"dependents\" as p on e.\"empid\" = p.\"empid\""
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7], location=[$8], location9=[$9], empid0=[$10], name1=[$11])\n"
operator|+
literal|"  EnumerableProject(empid=[$2], deptno=[$3], name=[$4], salary=[$5], commission=[$6], deptno0=[$7], name0=[$8], employees=[$9], x=[$10], y=[$11], empid0=[$0], name1=[$1])\n"
operator|+
literal|"    EnumerableJoin(condition=[=($0, $2)], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableScan(table=[[hr, dependents]])\n"
operator|+
literal|"      EnumerableProject(empid=[$5], deptno=[$6], name=[$7], salary=[$8], commission=[$9], deptno0=[$0], name0=[$1], employees=[$2], x=[$3], y=[$4])\n"
operator|+
literal|"        EnumerableJoin(condition=[=($0, $6)], joinType=[left])\n"
operator|+
literal|"          EnumerableProject(deptno=[$0], name=[$1], employees=[$2], x=[$3.x], y=[$3.y])\n"
operator|+
literal|"            EnumerableTableScan(table=[[hr, depts]])\n"
operator|+
literal|"          EnumerableTableScan(table=[[hr, emps]])"
decl_stmt|;
name|checkHeuristic
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a relation (dependents) that is on the null-generating side of    * an outer join cannot be pushed into an inner join (emps join depts). */
annotation|@
name|Test
specifier|public
name|void
name|testHeuristicRightJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from \"emps\" as e\n"
operator|+
literal|"join \"depts\" as d on e.\"deptno\" = d.\"deptno\"\n"
operator|+
literal|"right join \"dependents\" as p on e.\"empid\" = p.\"empid\""
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"EnumerableProject(empid=[$0], deptno=[$1], name=[$2], salary=[$3], commission=[$4], deptno0=[$5], name0=[$6], employees=[$7], location=[$8], location9=[$9], empid0=[$10], name1=[$11])\n"
operator|+
literal|"  EnumerableProject(empid=[$2], deptno=[$3], name=[$4], salary=[$5], commission=[$6], deptno0=[$7], name0=[$8], employees=[$9], x=[$10], y=[$11], empid0=[$0], name1=[$1])\n"
operator|+
literal|"    EnumerableJoin(condition=[=($0, $2)], joinType=[left])\n"
operator|+
literal|"      EnumerableTableScan(table=[[hr, dependents]])\n"
operator|+
literal|"      EnumerableJoin(condition=[=($1, $5)], joinType=[inner])\n"
operator|+
literal|"        EnumerableTableScan(table=[[hr, emps]])\n"
operator|+
literal|"        EnumerableProject(deptno=[$0], name=[$1], employees=[$2], x=[$3.x], y=[$3.y])\n"
operator|+
literal|"          EnumerableTableScan(table=[[hr, depts]])"
decl_stmt|;
name|checkHeuristic
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkHeuristic
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|heuristicJoinOrder
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|rel
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|containsString
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Plans a 3-table join query on the FoodMart schema. The ideal plan is not    * bushy, but nevertheless exercises the bushy-join heuristic optimizer. */
annotation|@
name|Test
specifier|public
name|void
name|testAlmostBushy
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\" as s\n"
operator|+
literal|"join \"customer\" as c\n"
operator|+
literal|"  on s.\"customer_id\" = c.\"customer_id\"\n"
operator|+
literal|"join \"product\" as p\n"
operator|+
literal|"  on s.\"product_id\" = p.\"product_id\"\n"
operator|+
literal|"where c.\"city\" = 'San Francisco'\n"
operator|+
literal|"and p.\"brand_name\" = 'Washington'"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"EnumerableProject(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], product_class_id=[$37], product_id0=[$38], brand_name=[$39], product_name=[$40], SKU=[$41], SRP=[$42], gross_weight=[$43], net_weight=[$44], recyclable_package=[$45], low_fat=[$46], units_per_case=[$47], cases_per_pallet=[$48], shelf_width=[$49], shelf_height=[$50], shelf_depth=[$51])\n"
operator|+
literal|"  EnumerableProject(product_id0=[$44], time_id=[$45], customer_id0=[$46], promotion_id=[$47], store_id=[$48], store_sales=[$49], store_cost=[$50], unit_sales=[$51], customer_id=[$15], account_num=[$16], lname=[$17], fname=[$18], mi=[$19], address1=[$20], address2=[$21], address3=[$22], address4=[$23], city=[$24], state_province=[$25], postal_code=[$26], country=[$27], customer_region_id=[$28], phone1=[$29], phone2=[$30], birthdate=[$31], marital_status=[$32], yearly_income=[$33], gender=[$34], total_children=[$35], num_children_at_home=[$36], education=[$37], date_accnt_opened=[$38], member_card=[$39], occupation=[$40], houseowner=[$41], num_cars_owned=[$42], fullname=[$43], product_class_id=[$0], product_id=[$1], brand_name=[$2], product_name=[$3], SKU=[$4], SRP=[$5], gross_weight=[$6], net_weight=[$7], recyclable_package=[$8], low_fat=[$9], units_per_case=[$10], cases_per_pallet=[$11], shelf_width=[$12], shelf_height=[$13], shelf_depth=[$14])\n"
operator|+
literal|"    EnumerableJoin(condition=[=($1, $44)], joinType=[inner])\n"
operator|+
literal|"      EnumerableFilter(condition=[=($2, 'Washington')])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, product]])\n"
operator|+
literal|"      EnumerableJoin(condition=[=($0, $31)], joinType=[inner])\n"
operator|+
literal|"        EnumerableFilter(condition=[=($9, 'San Francisco')])\n"
operator|+
literal|"          EnumerableTableScan(table=[[foodmart2, customer]])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])\n"
decl_stmt|;
name|checkBushy
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** Plans a 4-table join query on the FoodMart schema.    *    *<p>The ideal plan is bushy:    *   customer x (product_class x  product x sales)    * which would be written    *   (customer x ((product_class x product) x sales))    * if you don't assume 'x' is left-associative. */
annotation|@
name|Test
specifier|public
name|void
name|testBushy
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\" as s\n"
operator|+
literal|"join \"customer\" as c\n"
operator|+
literal|"  on s.\"customer_id\" = c.\"customer_id\"\n"
operator|+
literal|"join \"product\" as p\n"
operator|+
literal|"  on s.\"product_id\" = p.\"product_id\"\n"
operator|+
literal|"join \"product_class\" as pc\n"
operator|+
literal|"  on p.\"product_class_id\" = pc.\"product_class_id\"\n"
operator|+
literal|"where c.\"city\" = 'San Francisco'\n"
operator|+
literal|"and p.\"brand_name\" = 'Washington'"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"EnumerableProject(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], product_class_id=[$37], product_id0=[$38], brand_name=[$39], product_name=[$40], SKU=[$41], SRP=[$42], gross_weight=[$43], net_weight=[$44], recyclable_package=[$45], low_fat=[$46], units_per_case=[$47], cases_per_pallet=[$48], shelf_width=[$49], shelf_height=[$50], shelf_depth=[$51], product_class_id0=[$52], product_subcategory=[$53], product_category=[$54], product_department=[$55], product_family=[$56])\n"
operator|+
literal|"  EnumerableProject(product_id0=[$49], time_id=[$50], customer_id0=[$51], promotion_id=[$52], store_id=[$53], store_sales=[$54], store_cost=[$55], unit_sales=[$56], customer_id=[$0], account_num=[$1], lname=[$2], fname=[$3], mi=[$4], address1=[$5], address2=[$6], address3=[$7], address4=[$8], city=[$9], state_province=[$10], postal_code=[$11], country=[$12], customer_region_id=[$13], phone1=[$14], phone2=[$15], birthdate=[$16], marital_status=[$17], yearly_income=[$18], gender=[$19], total_children=[$20], num_children_at_home=[$21], education=[$22], date_accnt_opened=[$23], member_card=[$24], occupation=[$25], houseowner=[$26], num_cars_owned=[$27], fullname=[$28], product_class_id0=[$34], product_id=[$35], brand_name=[$36], product_name=[$37], SKU=[$38], SRP=[$39], gross_weight=[$40], net_weight=[$41], recyclable_package=[$42], low_fat=[$43], units_per_case=[$44], cases_per_pallet=[$45], shelf_width=[$46], shelf_height=[$47], shelf_depth=[$48], product_class_id=[$29], product_subcategory=[$30], product_category=[$31], product_department=[$32], product_family=[$33])\n"
operator|+
literal|"    EnumerableJoin(condition=[=($0, $51)], joinType=[inner])\n"
operator|+
literal|"      EnumerableFilter(condition=[=($9, 'San Francisco')])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, customer]])\n"
operator|+
literal|"      EnumerableJoin(condition=[=($6, $20)], joinType=[inner])\n"
operator|+
literal|"        EnumerableJoin(condition=[=($0, $5)], joinType=[inner])\n"
operator|+
literal|"          EnumerableTableScan(table=[[foodmart2, product_class]])\n"
operator|+
literal|"          EnumerableFilter(condition=[=($2, 'Washington')])\n"
operator|+
literal|"            EnumerableTableScan(table=[[foodmart2, product]])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])\n"
decl_stmt|;
name|checkBushy
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** Plans a 5-table join query on the FoodMart schema. The ideal plan is    * bushy: store x (customer x (product_class x product x sales)). */
annotation|@
name|Test
specifier|public
name|void
name|testBushy5
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\" as s\n"
operator|+
literal|"join \"customer\" as c\n"
operator|+
literal|"  on s.\"customer_id\" = c.\"customer_id\"\n"
operator|+
literal|"join \"product\" as p\n"
operator|+
literal|"  on s.\"product_id\" = p.\"product_id\"\n"
operator|+
literal|"join \"product_class\" as pc\n"
operator|+
literal|"  on p.\"product_class_id\" = pc.\"product_class_id\"\n"
operator|+
literal|"join \"store\" as st\n"
operator|+
literal|"  on s.\"store_id\" = st.\"store_id\"\n"
operator|+
literal|"where c.\"city\" = 'San Francisco'\n"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"EnumerableProject(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], product_class_id=[$37], product_id0=[$38], brand_name=[$39], product_name=[$40], SKU=[$41], SRP=[$42], gross_weight=[$43], net_weight=[$44], recyclable_package=[$45], low_fat=[$46], units_per_case=[$47], cases_per_pallet=[$48], shelf_width=[$49], shelf_height=[$50], shelf_depth=[$51], product_class_id0=[$52], product_subcategory=[$53], product_category=[$54], product_department=[$55], product_family=[$56], store_id0=[$57], store_type=[$58], region_id=[$59], store_name=[$60], store_number=[$61], store_street_address=[$62], store_city=[$63], store_state=[$64], store_postal_code=[$65], store_country=[$66], store_manager=[$67], store_phone=[$68], store_fax=[$69], first_opened_date=[$70], last_remodel_date=[$71], store_sqft=[$72], grocery_sqft=[$73], frozen_sqft=[$74], meat_sqft=[$75], coffee_bar=[$76], video_store=[$77], salad_bar=[$78], prepared_food=[$79], florist=[$80])\n"
operator|+
literal|"  EnumerableProject(product_id0=[$73], time_id=[$74], customer_id0=[$75], promotion_id=[$76], store_id0=[$77], store_sales=[$78], store_cost=[$79], unit_sales=[$80], customer_id=[$24], account_num=[$25], lname=[$26], fname=[$27], mi=[$28], address1=[$29], address2=[$30], address3=[$31], address4=[$32], city=[$33], state_province=[$34], postal_code=[$35], country=[$36], customer_region_id=[$37], phone1=[$38], phone2=[$39], birthdate=[$40], marital_status=[$41], yearly_income=[$42], gender=[$43], total_children=[$44], num_children_at_home=[$45], education=[$46], date_accnt_opened=[$47], member_card=[$48], occupation=[$49], houseowner=[$50], num_cars_owned=[$51], fullname=[$52], product_class_id0=[$58], product_id=[$59], brand_name=[$60], product_name=[$61], SKU=[$62], SRP=[$63], gross_weight=[$64], net_weight=[$65], recyclable_package=[$66], low_fat=[$67], units_per_case=[$68], cases_per_pallet=[$69], shelf_width=[$70], shelf_height=[$71], shelf_depth=[$72], product_class_id=[$53], product_subcategory=[$54], product_category=[$55], product_department=[$56], product_family=[$57], store_id=[$0], store_type=[$1], region_id=[$2], store_name=[$3], store_number=[$4], store_street_address=[$5], store_city=[$6], store_state=[$7], store_postal_code=[$8], store_country=[$9], store_manager=[$10], store_phone=[$11], store_fax=[$12], first_opened_date=[$13], last_remodel_date=[$14], store_sqft=[$15], grocery_sqft=[$16], frozen_sqft=[$17], meat_sqft=[$18], coffee_bar=[$19], video_store=[$20], salad_bar=[$21], prepared_food=[$22], florist=[$23])\n"
operator|+
literal|"    EnumerableJoin(condition=[=($0, $77)], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableScan(table=[[foodmart2, store]])\n"
operator|+
literal|"      EnumerableJoin(condition=[=($0, $51)], joinType=[inner])\n"
operator|+
literal|"        EnumerableFilter(condition=[=($9, 'San Francisco')])\n"
operator|+
literal|"          EnumerableTableScan(table=[[foodmart2, customer]])\n"
operator|+
literal|"        EnumerableJoin(condition=[=($6, $20)], joinType=[inner])\n"
operator|+
literal|"          EnumerableJoin(condition=[=($0, $5)], joinType=[inner])\n"
operator|+
literal|"            EnumerableTableScan(table=[[foodmart2, product_class]])\n"
operator|+
literal|"            EnumerableTableScan(table=[[foodmart2, product]])\n"
operator|+
literal|"          EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])\n"
decl_stmt|;
name|checkBushy
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** Tests the bushy join algorithm where one table does not join to    * anything. */
annotation|@
name|Test
specifier|public
name|void
name|testBushyCrossJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from \"sales_fact_1997\" as s\n"
operator|+
literal|"join \"customer\" as c\n"
operator|+
literal|"  on s.\"customer_id\" = c.\"customer_id\"\n"
operator|+
literal|"cross join \"department\""
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"EnumerableProject(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], department_id=[$37], department_description=[$38])\n"
operator|+
literal|"  EnumerableProject(product_id=[$31], time_id=[$32], customer_id0=[$33], promotion_id=[$34], store_id=[$35], store_sales=[$36], store_cost=[$37], unit_sales=[$38], customer_id=[$2], account_num=[$3], lname=[$4], fname=[$5], mi=[$6], address1=[$7], address2=[$8], address3=[$9], address4=[$10], city=[$11], state_province=[$12], postal_code=[$13], country=[$14], customer_region_id=[$15], phone1=[$16], phone2=[$17], birthdate=[$18], marital_status=[$19], yearly_income=[$20], gender=[$21], total_children=[$22], num_children_at_home=[$23], education=[$24], date_accnt_opened=[$25], member_card=[$26], occupation=[$27], houseowner=[$28], num_cars_owned=[$29], fullname=[$30], department_id=[$0], department_description=[$1])\n"
operator|+
literal|"    EnumerableJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"      EnumerableTableScan(table=[[foodmart2, department]])\n"
operator|+
literal|"      EnumerableJoin(condition=[=($0, $31)], joinType=[inner])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, customer]])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])"
decl_stmt|;
name|checkBushy
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** Tests the bushy join algorithm against a query where not all tables have a    * join condition to the others. */
annotation|@
name|Test
specifier|public
name|void
name|testBushyCrossJoin2
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from \"sales_fact_1997\" as s\n"
operator|+
literal|"join \"customer\" as c\n"
operator|+
literal|"  on s.\"customer_id\" = c.\"customer_id\"\n"
operator|+
literal|"cross join \"department\" as d\n"
operator|+
literal|"join \"employee\" as e\n"
operator|+
literal|"  on d.\"department_id\" = e.\"department_id\""
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"EnumerableProject(product_id=[$0], time_id=[$1], customer_id=[$2], promotion_id=[$3], store_id=[$4], store_sales=[$5], store_cost=[$6], unit_sales=[$7], customer_id0=[$8], account_num=[$9], lname=[$10], fname=[$11], mi=[$12], address1=[$13], address2=[$14], address3=[$15], address4=[$16], city=[$17], state_province=[$18], postal_code=[$19], country=[$20], customer_region_id=[$21], phone1=[$22], phone2=[$23], birthdate=[$24], marital_status=[$25], yearly_income=[$26], gender=[$27], total_children=[$28], num_children_at_home=[$29], education=[$30], date_accnt_opened=[$31], member_card=[$32], occupation=[$33], houseowner=[$34], num_cars_owned=[$35], fullname=[$36], department_id=[$37], department_description=[$38], employee_id=[$39], full_name=[$40], first_name=[$41], last_name=[$42], position_id=[$43], position_title=[$44], store_id0=[$45], department_id0=[$46], birth_date=[$47], hire_date=[$48], end_date=[$49], salary=[$50], supervisor_id=[$51], education_level=[$52], marital_status0=[$53], gender0=[$54], management_role=[$55])\n"
operator|+
literal|"  EnumerableProject(product_id=[$48], time_id=[$49], customer_id0=[$50], promotion_id=[$51], store_id0=[$52], store_sales=[$53], store_cost=[$54], unit_sales=[$55], customer_id=[$19], account_num=[$20], lname=[$21], fname=[$22], mi=[$23], address1=[$24], address2=[$25], address3=[$26], address4=[$27], city=[$28], state_province=[$29], postal_code=[$30], country=[$31], customer_region_id=[$32], phone1=[$33], phone2=[$34], birthdate=[$35], marital_status0=[$36], yearly_income=[$37], gender0=[$38], total_children=[$39], num_children_at_home=[$40], education=[$41], date_accnt_opened=[$42], member_card=[$43], occupation=[$44], houseowner=[$45], num_cars_owned=[$46], fullname=[$47], department_id=[$0], department_description=[$1], employee_id=[$2], full_name=[$3], first_name=[$4], last_name=[$5], position_id=[$6], position_title=[$7], store_id=[$8], department_id0=[$9], birth_date=[$10], hire_date=[$11], end_date=[$12], salary=[$13], supervisor_id=[$14], education_level=[$15], marital_status=[$16], gender=[$17], management_role=[$18])\n"
operator|+
literal|"    EnumerableJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"      EnumerableJoin(condition=[=($0, $9)], joinType=[inner])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, department]])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, employee]])\n"
operator|+
literal|"      EnumerableJoin(condition=[=($0, $31)], joinType=[inner])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, customer]])\n"
operator|+
literal|"        EnumerableTableScan(table=[[foodmart2, sales_fact_1997]])\n"
decl_stmt|;
name|checkBushy
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that a query returns a particular plan, using a planner with    * MultiJoinOptimizeBushyRule enabled. */
specifier|private
name|void
name|checkBushy
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|parserConfig
argument_list|(
name|SqlParser
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|CLONE_FOODMART
argument_list|)
argument_list|)
operator|.
name|traitDefs
argument_list|(
operator|(
name|List
argument_list|<
name|RelTraitDef
argument_list|>
operator|)
literal|null
argument_list|)
operator|.
name|programs
argument_list|(
name|Programs
operator|.
name|heuristicJoinOrder
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|,
literal|true
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|Planner
name|planner
init|=
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
name|RelNode
name|convert
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|RelTraitSet
name|traitSet
init|=
name|convert
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|transform
init|=
name|planner
operator|.
name|transform
argument_list|(
literal|0
argument_list|,
name|traitSet
argument_list|,
name|convert
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|transform
argument_list|)
argument_list|,
name|containsString
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rule to convert a    * {@link org.apache.calcite.adapter.enumerable.EnumerableProject} to an    * {@link org.apache.calcite.adapter.jdbc.JdbcRules.JdbcProject}.    */
specifier|private
class|class
name|MockJdbcProjectRule
extends|extends
name|ConverterRule
block|{
specifier|private
name|MockJdbcProjectRule
parameter_list|(
name|JdbcConvention
name|out
parameter_list|)
block|{
name|super
argument_list|(
name|EnumerableProject
operator|.
name|class
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|,
name|out
argument_list|,
literal|"MockJdbcProjectRule"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelNode
name|convert
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|EnumerableProject
name|project
init|=
operator|(
name|EnumerableProject
operator|)
name|rel
decl_stmt|;
return|return
operator|new
name|JdbcRules
operator|.
name|JdbcProject
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|getOutConvention
argument_list|()
argument_list|)
argument_list|,
name|convert
argument_list|(
name|project
operator|.
name|getInput
argument_list|()
argument_list|,
name|project
operator|.
name|getInput
argument_list|()
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|getOutConvention
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Rule to convert a    * {@link org.apache.calcite.adapter.enumerable.EnumerableTableScan} to an    * {@link MockJdbcTableScan}.    */
specifier|private
class|class
name|MockJdbcTableRule
extends|extends
name|ConverterRule
block|{
specifier|private
name|MockJdbcTableRule
parameter_list|(
name|JdbcConvention
name|out
parameter_list|)
block|{
name|super
argument_list|(
name|EnumerableTableScan
operator|.
name|class
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|,
name|out
argument_list|,
literal|"MockJdbcTableRule"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelNode
name|convert
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|EnumerableTableScan
name|scan
init|=
operator|(
name|EnumerableTableScan
operator|)
name|rel
decl_stmt|;
return|return
operator|new
name|MockJdbcTableScan
argument_list|(
name|scan
operator|.
name|getCluster
argument_list|()
argument_list|,
name|scan
operator|.
name|getTable
argument_list|()
argument_list|,
operator|(
name|JdbcConvention
operator|)
name|getOutConvention
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Relational expression representing a "mock" scan of a table in a    * JDBC data source.    */
specifier|private
class|class
name|MockJdbcTableScan
extends|extends
name|TableScan
implements|implements
name|JdbcRel
block|{
name|MockJdbcTableScan
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|table
parameter_list|,
name|JdbcConvention
name|jdbcConvention
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|jdbcConvention
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|copy
parameter_list|(
name|RelTraitSet
name|traitSet
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|)
block|{
return|return
operator|new
name|MockJdbcTableScan
argument_list|(
name|getCluster
argument_list|()
argument_list|,
name|table
argument_list|,
operator|(
name|JdbcConvention
operator|)
name|getConvention
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|register
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|)
block|{
specifier|final
name|JdbcConvention
name|out
init|=
operator|(
name|JdbcConvention
operator|)
name|getConvention
argument_list|()
decl_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|JdbcRules
operator|.
name|rules
argument_list|(
name|out
argument_list|)
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|JdbcImplementor
operator|.
name|Result
name|implement
parameter_list|(
name|JdbcImplementor
name|implementor
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Test to determine whether de-correlation correctly removes Correlator.    */
annotation|@
name|Test
specifier|public
name|void
name|testOldJoinStyleDeCorrelation
parameter_list|()
throws|throws
name|Exception
block|{
name|assertFalse
argument_list|(
name|checkTpchQuery
argument_list|(
literal|"select\n p.`pPartkey`\n"
operator|+
literal|"from\n"
operator|+
literal|"  `tpch`.`part` p,\n"
operator|+
literal|"  `tpch`.`partsupp` ps1\n"
operator|+
literal|"where\n"
operator|+
literal|"  p.`pPartkey` = ps1.`psPartkey`\n"
operator|+
literal|"  and ps1.`psSupplyCost` = (\n"
operator|+
literal|"    select\n"
operator|+
literal|"      min(ps.`psSupplyCost`)\n"
operator|+
literal|"    from\n"
operator|+
literal|"      `tpch`.`partsupp` ps\n"
operator|+
literal|"    where\n"
operator|+
literal|"      p.`pPartkey` = ps.`psPartkey`\n"
operator|+
literal|"  )\n"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"Correlat"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|checkTpchQuery
parameter_list|(
name|String
name|tpchTestQuery
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|SchemaPlus
name|schema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
operator|.
name|add
argument_list|(
literal|"tpch"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|TpchSchema
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|parserConfig
argument_list|(
name|SqlParser
operator|.
name|configBuilder
argument_list|()
operator|.
name|setLex
argument_list|(
name|Lex
operator|.
name|MYSQL
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|schema
argument_list|)
operator|.
name|programs
argument_list|(
name|Programs
operator|.
name|ofRules
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|plan
decl_stmt|;
try|try
init|(
name|Planner
name|p
init|=
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
init|)
block|{
name|SqlNode
name|n
init|=
name|p
operator|.
name|parse
argument_list|(
name|tpchTestQuery
argument_list|)
decl_stmt|;
name|n
operator|=
name|p
operator|.
name|validate
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|RelNode
name|r
init|=
name|p
operator|.
name|rel
argument_list|(
name|n
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|plan
operator|=
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|plan
return|;
block|}
comment|/** User-defined aggregate function. */
specifier|public
specifier|static
class|class
name|MyCountAggFunction
extends|extends
name|SqlAggFunction
block|{
specifier|public
name|MyCountAggFunction
parameter_list|()
block|{
name|super
argument_list|(
literal|"MY_COUNT"
argument_list|,
literal|null
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|BIGINT
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|Optionality
operator|.
name|FORBIDDEN
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
name|List
argument_list|<
name|RelDataType
argument_list|>
name|getParameterTypes
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|ANY
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
name|RelDataType
name|getReturnType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|deriveType
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Check for COUNT(*) function.  If it is we don't
comment|// want to try and derive the "*"
if|if
condition|(
name|call
operator|.
name|isCountStar
argument_list|()
condition|)
block|{
return|return
name|validator
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|deriveType
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
return|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-569">[CALCITE-569]    * ArrayIndexOutOfBoundsException when deducing collation</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testOrderByNonSelectColumn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|SchemaPlus
name|schema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
operator|.
name|add
argument_list|(
literal|"tpch"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|TpchSchema
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|query
init|=
literal|"select t.psPartkey from \n"
operator|+
literal|"(select ps.psPartkey from `tpch`.`partsupp` ps \n"
operator|+
literal|"order by ps.psPartkey, ps.psSupplyCost) t \n"
operator|+
literal|"order by t.psPartkey"
decl_stmt|;
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|traitDefs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|traitDefs
operator|.
name|add
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|traitDefs
operator|.
name|add
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|SqlParser
operator|.
name|Config
name|parserConfig
init|=
name|SqlParser
operator|.
name|configBuilder
argument_list|()
operator|.
name|setLex
argument_list|(
name|Lex
operator|.
name|MYSQL
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|parserConfig
argument_list|(
name|parserConfig
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|schema
argument_list|)
operator|.
name|traitDefs
argument_list|(
name|traitDefs
argument_list|)
operator|.
name|programs
argument_list|(
name|Programs
operator|.
name|ofRules
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|plan
decl_stmt|;
try|try
init|(
name|Planner
name|p
init|=
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
init|)
block|{
name|SqlNode
name|n
init|=
name|p
operator|.
name|parse
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|n
operator|=
name|p
operator|.
name|validate
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|RelNode
name|r
init|=
name|p
operator|.
name|rel
argument_list|(
name|n
argument_list|)
operator|.
name|project
argument_list|()
decl_stmt|;
name|plan
operator|=
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|plan
operator|=
name|Util
operator|.
name|toLinux
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|plan
argument_list|,
name|equalTo
argument_list|(
literal|"LogicalSort(sort0=[$0], dir0=[ASC])\n"
operator|+
literal|"  LogicalProject(psPartkey=[$0])\n"
operator|+
literal|"    LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[ASC])\n"
operator|+
literal|"      LogicalProject(psPartkey=[$0], psSupplyCost=[$1])\n"
operator|+
literal|"        EnumerableTableScan(table=[[tpch, partsupp]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-648">[CALCITE-649]    * Update ProjectMergeRule description for new naming convention</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeProjectForceMode
parameter_list|()
throws|throws
name|Exception
block|{
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
operator|new
name|ProjectMergeRule
argument_list|(
literal|true
argument_list|,
name|RelBuilder
operator|.
name|proto
argument_list|(
name|RelFactories
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Planner
name|planner
init|=
name|getPlanner
argument_list|(
literal|null
argument_list|,
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testView
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * FROM dept"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(DEPTNO=[$0], DNAME=[$1])\n"
operator|+
literal|"  LogicalValues(type=[RecordType(INTEGER DEPTNO, CHAR(11) DNAME)], "
operator|+
literal|"tuples=[[{ 10, 'Sales      ' },"
operator|+
literal|" { 20, 'Marketing  ' },"
operator|+
literal|" { 30, 'Engineering' },"
operator|+
literal|" { 40, 'Empty      ' }]])\n"
decl_stmt|;
name|checkView
argument_list|(
name|sql
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testViewOnView
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * FROM dept30"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(DEPTNO=[$0], DNAME=[$1])\n"
operator|+
literal|"  LogicalFilter(condition=[=($0, 30)])\n"
operator|+
literal|"    LogicalProject(DEPTNO=[$0], DNAME=[$1])\n"
operator|+
literal|"      LogicalValues(type=[RecordType(INTEGER DEPTNO, CHAR(11) DNAME)], "
operator|+
literal|"tuples=[[{ 10, 'Sales      ' },"
operator|+
literal|" { 20, 'Marketing  ' },"
operator|+
literal|" { 30, 'Engineering' },"
operator|+
literal|" { 40, 'Empty      ' }]])\n"
decl_stmt|;
name|checkView
argument_list|(
name|sql
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkView
parameter_list|(
name|String
name|sql
parameter_list|,
name|Matcher
argument_list|<
name|String
argument_list|>
name|matcher
parameter_list|)
throws|throws
name|SqlParseException
throws|,
name|ValidationException
throws|,
name|RelConversionException
block|{
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|FrameworkConfig
name|config
init|=
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|defaultSchema
argument_list|(
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|POST
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Planner
name|planner
init|=
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|SqlNode
name|parse
init|=
name|planner
operator|.
name|parse
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|validate
init|=
name|planner
operator|.
name|validate
argument_list|(
name|parse
argument_list|)
decl_stmt|;
specifier|final
name|RelRoot
name|root
init|=
name|planner
operator|.
name|rel
argument_list|(
name|validate
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// End PlannerTest.java
end_comment

end_unit

