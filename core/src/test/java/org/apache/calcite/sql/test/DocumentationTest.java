begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibrary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibraryOperatorTableFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlOverlapsOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlAbstractParserImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|DiffTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Sources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|LineNumberReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|fail
import|;
end_import

begin_comment
comment|/** Various automated checks on the documentation. */
end_comment

begin_class
class|class
name|DocumentationTest
block|{
comment|/** Generates a copy of {@code reference.md} with the current set of key    * words. Fails if the copy is different from the original. */
annotation|@
name|Test
name|void
name|testGenerateKeyWords
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FileFixture
name|f
init|=
operator|new
name|FileFixture
argument_list|()
decl_stmt|;
name|f
operator|.
name|outFile
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
try|try
init|(
name|BufferedReader
name|r
init|=
name|Util
operator|.
name|reader
argument_list|(
name|f
operator|.
name|inFile
argument_list|)
init|;
name|FileOutputStream
name|fos
init|=
operator|new
name|FileOutputStream
argument_list|(
name|f
operator|.
name|outFile
argument_list|)
init|;
name|PrintWriter
name|w
init|=
name|Util
operator|.
name|printWriter
argument_list|(
name|f
operator|.
name|outFile
argument_list|)
init|)
block|{
name|String
name|line
decl_stmt|;
name|int
name|stage
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|r
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
literal|"{% comment %} end {% endcomment %}"
argument_list|)
condition|)
block|{
operator|++
name|stage
expr_stmt|;
block|}
if|if
condition|(
name|stage
operator|!=
literal|1
condition|)
block|{
name|w
operator|.
name|println
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
literal|"{% comment %} start {% endcomment %}"
argument_list|)
condition|)
block|{
operator|++
name|stage
expr_stmt|;
name|SqlAbstractParserImpl
operator|.
name|Metadata
name|metadata
init|=
operator|new
name|SqlParserTest
argument_list|()
operator|.
name|getSqlParser
argument_list|(
literal|""
argument_list|)
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|int
name|z
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|metadata
operator|.
name|getTokens
argument_list|()
control|)
block|{
if|if
condition|(
name|z
operator|++
operator|>
literal|0
condition|)
block|{
name|w
operator|.
name|println
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metadata
operator|.
name|isKeyword
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|w
operator|.
name|print
argument_list|(
name|metadata
operator|.
name|isReservedWord
argument_list|(
name|s
argument_list|)
condition|?
operator|(
literal|"**"
operator|+
name|s
operator|+
literal|"**"
operator|)
else|:
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|w
operator|.
name|println
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
name|w
operator|.
name|flush
argument_list|()
expr_stmt|;
name|fos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|fos
operator|.
name|getFD
argument_list|()
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
name|String
name|diff
init|=
name|DiffTestCase
operator|.
name|diff
argument_list|(
name|f
operator|.
name|outFile
argument_list|,
name|f
operator|.
name|inFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|diff
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Mismatch between "
operator|+
name|f
operator|.
name|outFile
operator|+
literal|" and "
operator|+
name|f
operator|.
name|inFile
operator|+
literal|":\n"
operator|+
name|diff
argument_list|)
throw|;
block|}
block|}
comment|/** Tests that every function in {@link SqlStdOperatorTable} is documented in    * reference.md. */
annotation|@
name|Test
name|void
name|testAllFunctionsAreDocumented
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FileFixture
name|f
init|=
operator|new
name|FileFixture
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|PatternOp
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|addOperators
argument_list|(
name|map
argument_list|,
literal|""
argument_list|,
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
operator|.
name|getOperatorList
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlLibrary
name|library
range|:
name|SqlLibrary
operator|.
name|values
argument_list|()
control|)
block|{
switch|switch
condition|(
name|library
condition|)
block|{
case|case
name|STANDARD
case|:
case|case
name|SPATIAL
case|:
continue|continue;
block|}
name|addOperators
argument_list|(
name|map
argument_list|,
literal|"\\| [^|]*"
operator|+
name|library
operator|.
name|abbrev
operator|+
literal|"[^|]* "
argument_list|,
name|SqlLibraryOperatorTableFactory
operator|.
name|INSTANCE
operator|.
name|getOperatorTable
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|library
argument_list|)
argument_list|)
operator|.
name|getOperatorList
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|regexSeen
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|LineNumberReader
name|r
init|=
operator|new
name|LineNumberReader
argument_list|(
name|Util
operator|.
name|reader
argument_list|(
name|f
operator|.
name|inFile
argument_list|)
argument_list|)
init|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|String
name|line
init|=
name|r
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|null
condition|)
block|{
break|break;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|PatternOp
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|pattern
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|regexSeen
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
comment|// function is documented
block|}
block|}
block|}
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|regexNotSeen
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|regexNotSeen
operator|.
name|removeAll
argument_list|(
name|regexSeen
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
literal|"some functions are not documented: "
operator|+
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|e
lambda|->
name|regexNotSeen
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|opName
operator|+
literal|"("
operator|+
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|")"
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|joining
argument_list|(
literal|", "
argument_list|)
argument_list|)
argument_list|,
name|regexNotSeen
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addOperators
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|PatternOp
argument_list|>
name|map
parameter_list|,
name|String
name|prefix
parameter_list|,
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|operatorList
parameter_list|)
block|{
for|for
control|(
name|SqlOperator
name|op
range|:
name|operatorList
control|)
block|{
specifier|final
name|String
name|name
init|=
name|op
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"TRANSLATE3"
argument_list|)
condition|?
literal|"TRANSLATE"
else|:
name|op
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|SqlSpecialOperator
operator|||
operator|!
name|name
operator|.
name|matches
argument_list|(
literal|"^[a-zA-Z][a-zA-Z0-9_]*$"
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|String
name|regex
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|SqlOverlapsOperator
condition|)
block|{
name|regex
operator|=
literal|"[ ]*<td>period1 "
operator|+
name|name
operator|+
literal|" period2</td>"
expr_stmt|;
block|}
if|else if
condition|(
name|op
operator|instanceof
name|SqlFunction
operator|&&
operator|(
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
operator|==
literal|null
operator|||
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
operator|.
name|getOperandCountRange
argument_list|()
operator|.
name|getMin
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
name|regex
operator|=
name|prefix
operator|+
literal|"\\| .*"
operator|+
name|name
operator|+
literal|"\\(.*"
expr_stmt|;
block|}
else|else
block|{
name|regex
operator|=
name|prefix
operator|+
literal|"\\| .*"
operator|+
name|name
operator|+
literal|".*"
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|regex
argument_list|,
operator|new
name|PatternOp
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** A compiled regex and an operator name. An item to be found in the    * documentation. */
specifier|private
specifier|static
class|class
name|PatternOp
block|{
specifier|final
name|Pattern
name|pattern
decl_stmt|;
specifier|final
name|String
name|opName
decl_stmt|;
specifier|private
name|PatternOp
parameter_list|(
name|Pattern
name|pattern
parameter_list|,
name|String
name|opName
parameter_list|)
block|{
name|this
operator|.
name|pattern
operator|=
name|pattern
expr_stmt|;
name|this
operator|.
name|opName
operator|=
name|opName
expr_stmt|;
block|}
block|}
comment|/** Defines paths needed by a couple of tests. */
specifier|private
specifier|static
class|class
name|FileFixture
block|{
specifier|final
name|File
name|base
decl_stmt|;
specifier|final
name|File
name|inFile
decl_stmt|;
specifier|final
name|File
name|outFile
decl_stmt|;
specifier|private
name|boolean
name|isProjectDir
parameter_list|(
name|File
name|dir
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"pom.xml"
argument_list|)
operator|.
name|isFile
argument_list|()
operator|||
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"build.gradle.kts"
argument_list|)
operator|.
name|isFile
argument_list|()
operator|||
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"gradle.properties"
argument_list|)
operator|.
name|isFile
argument_list|()
return|;
block|}
name|FileFixture
parameter_list|()
block|{
comment|// Algorithm:
comment|// 1) Find location of DocumentationTest.class
comment|// 2) Climb via getParentFile() until we detect pom.xml
comment|// 3) It means we've got core/pom.xml, and we need to get core/../site/
name|Class
argument_list|<
name|DocumentationTest
argument_list|>
name|klass
init|=
name|DocumentationTest
operator|.
name|class
decl_stmt|;
name|File
name|docTestClass
init|=
name|Sources
operator|.
name|of
argument_list|(
name|klass
operator|.
name|getResource
argument_list|(
name|klass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".class"
argument_list|)
argument_list|)
operator|.
name|file
argument_list|()
decl_stmt|;
name|File
name|core
init|=
name|docTestClass
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|42
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isProjectDir
argument_list|(
name|core
argument_list|)
condition|)
block|{
comment|// Ok, core == core/
break|break;
block|}
name|core
operator|=
name|core
operator|.
name|getParentFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isProjectDir
argument_list|(
name|core
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"Unable to find neither core/pom.xml nor core/build.gradle.kts. Started with "
operator|+
name|docTestClass
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|", the current path is "
operator|+
name|core
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|base
operator|=
name|core
operator|.
name|getParentFile
argument_list|()
expr_stmt|;
name|inFile
operator|=
operator|new
name|File
argument_list|(
name|base
argument_list|,
literal|"site/_docs/reference.md"
argument_list|)
expr_stmt|;
comment|// TODO: replace with core/build/ when Maven is migrated to Gradle
comment|// It does work in Gradle, however, we don't want to create "target" folder in Gradle
name|outFile
operator|=
operator|new
name|File
argument_list|(
name|base
argument_list|,
literal|"core/build/reports/documentationTest/reference.md"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

