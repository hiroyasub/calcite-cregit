begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|Lex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|advise
operator|.
name|SqlAdvisor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|advise
operator|.
name|SqlAdvisorValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|advise
operator|.
name|SqlSimpleParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|StringAndPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMoniker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonikerType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|SqlValidatorFixture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|SqlValidatorTestCase
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Disabled
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|UnaryOperator
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|fail
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Concrete child class of {@link SqlValidatorTestCase}, containing unit tests  * for SqlAdvisor.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"ArraysAsListWithZeroOrOneArgument"
block|}
argument_list|)
class|class
name|SqlAdvisorTest
extends|extends
name|SqlValidatorTestCase
block|{
specifier|public
specifier|static
specifier|final
name|SqlTestFactory
name|ADVISOR_NEW_TEST_FACTORY
init|=
name|SqlTestFactory
operator|.
name|INSTANCE
operator|.
name|withValidator
argument_list|(
name|SqlAdvisorValidator
operator|::
operator|new
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|Fixture
name|LOCAL_FIXTURE
init|=
operator|new
name|Fixture
argument_list|(
name|SqlValidatorTester
operator|.
name|DEFAULT
argument_list|,
name|ADVISOR_NEW_TEST_FACTORY
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
literal|"?"
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|STAR_KEYWORD
init|=
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"KEYWORD(*)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FROM_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(LATERAL)"
argument_list|,
literal|"KEYWORD(TABLE)"
argument_list|,
literal|"KEYWORD(UNNEST)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SALES_TABLES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"SCHEMA(CATALOG.SALES)"
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMPDEFAULTS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMPNULLABLES)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP_B)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP_20)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMPNULLABLES_20)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP_ADDRESS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.DEPT)"
argument_list|,
literal|"TABLE(CATALOG.SALES.DEPT_NESTED)"
argument_list|,
literal|"TABLE(CATALOG.SALES.DEPT_NESTED_EXPANDED)"
argument_list|,
literal|"TABLE(CATALOG.SALES.BONUS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.ORDERS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.SALGRADE)"
argument_list|,
literal|"TABLE(CATALOG.SALES.SHIPMENTS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.PRODUCTS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.PRODUCTS_TEMPORAL)"
argument_list|,
literal|"TABLE(CATALOG.SALES.SUPPLIERS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP_R)"
argument_list|,
literal|"TABLE(CATALOG.SALES.DEPT_R)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SCHEMAS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"CATALOG(CATALOG)"
argument_list|,
literal|"SCHEMA(CATALOG.SALES)"
argument_list|,
literal|"SCHEMA(CATALOG.STRUCT)"
argument_list|,
literal|"SCHEMA(CATALOG.CUSTOMER)"
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|AB_TABLES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(A)"
argument_list|,
literal|"TABLE(B)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_TABLE
init|=
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"TABLE(EMP)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FETCH_OFFSET
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EXPR_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(+)"
argument_list|,
literal|"KEYWORD(-)"
argument_list|,
literal|"KEYWORD(?)"
argument_list|,
literal|"KEYWORD(ABS)"
argument_list|,
literal|"KEYWORD(ARRAY)"
argument_list|,
literal|"KEYWORD(AVG)"
argument_list|,
literal|"KEYWORD(CARDINALITY)"
argument_list|,
literal|"KEYWORD(CASE)"
argument_list|,
literal|"KEYWORD(CAST)"
argument_list|,
literal|"KEYWORD(CEIL)"
argument_list|,
literal|"KEYWORD(CEILING)"
argument_list|,
literal|"KEYWORD(CHARACTER_LENGTH)"
argument_list|,
literal|"KEYWORD(CHAR_LENGTH)"
argument_list|,
literal|"KEYWORD(CLASSIFIER)"
argument_list|,
literal|"KEYWORD(COALESCE)"
argument_list|,
literal|"KEYWORD(COLLECT)"
argument_list|,
literal|"KEYWORD(CONVERT)"
argument_list|,
literal|"KEYWORD(COUNT)"
argument_list|,
literal|"KEYWORD(COVAR_POP)"
argument_list|,
literal|"KEYWORD(COVAR_SAMP)"
argument_list|,
literal|"KEYWORD(CUME_DIST)"
argument_list|,
literal|"KEYWORD(CURRENT)"
argument_list|,
literal|"KEYWORD(CURRENT_CATALOG)"
argument_list|,
literal|"KEYWORD(CURRENT_DATE)"
argument_list|,
literal|"KEYWORD(CURRENT_DEFAULT_TRANSFORM_GROUP)"
argument_list|,
literal|"KEYWORD(CURRENT_PATH)"
argument_list|,
literal|"KEYWORD(CURRENT_ROLE)"
argument_list|,
literal|"KEYWORD(CURRENT_SCHEMA)"
argument_list|,
literal|"KEYWORD(CURRENT_TIME)"
argument_list|,
literal|"KEYWORD(CURRENT_TIMESTAMP)"
argument_list|,
literal|"KEYWORD(CURRENT_USER)"
argument_list|,
literal|"KEYWORD(CURSOR)"
argument_list|,
literal|"KEYWORD(DATE)"
argument_list|,
literal|"KEYWORD(DENSE_RANK)"
argument_list|,
literal|"KEYWORD(ELEMENT)"
argument_list|,
literal|"KEYWORD(EVERY)"
argument_list|,
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"KEYWORD(EXP)"
argument_list|,
literal|"KEYWORD(EXTRACT)"
argument_list|,
literal|"KEYWORD(FALSE)"
argument_list|,
literal|"KEYWORD(FIRST_VALUE)"
argument_list|,
literal|"KEYWORD(FLOOR)"
argument_list|,
literal|"KEYWORD(FUSION)"
argument_list|,
literal|"KEYWORD(GROUPING)"
argument_list|,
literal|"KEYWORD(HOUR)"
argument_list|,
literal|"KEYWORD(INTERSECTION)"
argument_list|,
literal|"KEYWORD(INTERVAL)"
argument_list|,
literal|"KEYWORD(JSON_ARRAY)"
argument_list|,
literal|"KEYWORD(JSON_ARRAYAGG)"
argument_list|,
literal|"KEYWORD(JSON_EXISTS)"
argument_list|,
literal|"KEYWORD(JSON_OBJECT)"
argument_list|,
literal|"KEYWORD(JSON_OBJECTAGG)"
argument_list|,
literal|"KEYWORD(JSON_QUERY)"
argument_list|,
literal|"KEYWORD(JSON_VALUE)"
argument_list|,
literal|"KEYWORD(LAG)"
argument_list|,
literal|"KEYWORD(LAST_VALUE)"
argument_list|,
literal|"KEYWORD(LEAD)"
argument_list|,
literal|"KEYWORD(LEFT)"
argument_list|,
literal|"KEYWORD(LN)"
argument_list|,
literal|"KEYWORD(LOCALTIME)"
argument_list|,
literal|"KEYWORD(LOCALTIMESTAMP)"
argument_list|,
literal|"KEYWORD(LOWER)"
argument_list|,
literal|"KEYWORD(MATCH_NUMBER)"
argument_list|,
literal|"KEYWORD(MAX)"
argument_list|,
literal|"KEYWORD(MIN)"
argument_list|,
literal|"KEYWORD(MINUTE)"
argument_list|,
literal|"KEYWORD(MOD)"
argument_list|,
literal|"KEYWORD(MONTH)"
argument_list|,
literal|"KEYWORD(MULTISET)"
argument_list|,
literal|"KEYWORD(NEW)"
argument_list|,
literal|"KEYWORD(NEXT)"
argument_list|,
literal|"KEYWORD(NOT)"
argument_list|,
literal|"KEYWORD(NTH_VALUE)"
argument_list|,
literal|"KEYWORD(NTILE)"
argument_list|,
literal|"KEYWORD(NULL)"
argument_list|,
literal|"KEYWORD(NULLIF)"
argument_list|,
literal|"KEYWORD(OCTET_LENGTH)"
argument_list|,
literal|"KEYWORD(OVERLAY)"
argument_list|,
literal|"KEYWORD(PERCENTILE_CONT)"
argument_list|,
literal|"KEYWORD(PERCENTILE_DISC)"
argument_list|,
literal|"KEYWORD(PERCENT_RANK)"
argument_list|,
literal|"KEYWORD(PERIOD)"
argument_list|,
literal|"KEYWORD(POSITION)"
argument_list|,
literal|"KEYWORD(POWER)"
argument_list|,
literal|"KEYWORD(PREV)"
argument_list|,
literal|"KEYWORD(RANK)"
argument_list|,
literal|"KEYWORD(REGR_COUNT)"
argument_list|,
literal|"KEYWORD(REGR_SXX)"
argument_list|,
literal|"KEYWORD(REGR_SYY)"
argument_list|,
literal|"KEYWORD(RIGHT)"
argument_list|,
literal|"KEYWORD(ROW)"
argument_list|,
literal|"KEYWORD(ROW_NUMBER)"
argument_list|,
literal|"KEYWORD(RUNNING)"
argument_list|,
literal|"KEYWORD(SECOND)"
argument_list|,
literal|"KEYWORD(SESSION_USER)"
argument_list|,
literal|"KEYWORD(SOME)"
argument_list|,
literal|"KEYWORD(SPECIFIC)"
argument_list|,
literal|"KEYWORD(SQRT)"
argument_list|,
literal|"KEYWORD(SUBSTRING)"
argument_list|,
literal|"KEYWORD(STDDEV_POP)"
argument_list|,
literal|"KEYWORD(STDDEV_SAMP)"
argument_list|,
literal|"KEYWORD(SUM)"
argument_list|,
literal|"KEYWORD(SYSTEM_USER)"
argument_list|,
literal|"KEYWORD(TIME)"
argument_list|,
literal|"KEYWORD(TIMESTAMP)"
argument_list|,
literal|"KEYWORD(TRANSLATE)"
argument_list|,
literal|"KEYWORD(TRIM)"
argument_list|,
literal|"KEYWORD(TRUE)"
argument_list|,
literal|"KEYWORD(TRUNCATE)"
argument_list|,
literal|"KEYWORD(UNIQUE)"
argument_list|,
literal|"KEYWORD(UNKNOWN)"
argument_list|,
literal|"KEYWORD(UPPER)"
argument_list|,
literal|"KEYWORD(USER)"
argument_list|,
literal|"KEYWORD(VAR_POP)"
argument_list|,
literal|"KEYWORD(VAR_SAMP)"
argument_list|,
literal|"KEYWORD(YEAR)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|QUANTIFIERS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(ALL)"
argument_list|,
literal|"KEYWORD(ANY)"
argument_list|,
literal|"KEYWORD(SOME)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SELECT_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(ALL)"
argument_list|,
literal|"KEYWORD(DISTINCT)"
argument_list|,
literal|"KEYWORD(STREAM)"
argument_list|,
literal|"KEYWORD(*)"
argument_list|,
literal|"KEYWORD(/*+)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|ORDER_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(,)"
argument_list|,
literal|"KEYWORD(ASC)"
argument_list|,
literal|"KEYWORD(DESC)"
argument_list|,
literal|"KEYWORD(NULLS)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_COLUMNS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"COLUMN(ENAME)"
argument_list|,
literal|"COLUMN(JOB)"
argument_list|,
literal|"COLUMN(MGR)"
argument_list|,
literal|"COLUMN(HIREDATE)"
argument_list|,
literal|"COLUMN(SAL)"
argument_list|,
literal|"COLUMN(COMM)"
argument_list|,
literal|"COLUMN(DEPTNO)"
argument_list|,
literal|"COLUMN(SLACKER)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_COLUMNS_E
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"COLUMN(ENAME)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|DEPT_COLUMNS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(DEPTNO)"
argument_list|,
literal|"COLUMN(NAME)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|PREDICATE_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(*)"
argument_list|,
literal|"KEYWORD(+)"
argument_list|,
literal|"KEYWORD(-)"
argument_list|,
literal|"KEYWORD(.)"
argument_list|,
literal|"KEYWORD(/)"
argument_list|,
literal|"KEYWORD(%)"
argument_list|,
literal|"KEYWORD(<)"
argument_list|,
literal|"KEYWORD(<=)"
argument_list|,
literal|"KEYWORD(<>)"
argument_list|,
literal|"KEYWORD(!=)"
argument_list|,
literal|"KEYWORD(=)"
argument_list|,
literal|"KEYWORD(>)"
argument_list|,
literal|"KEYWORD(>=)"
argument_list|,
literal|"KEYWORD(AND)"
argument_list|,
literal|"KEYWORD(BETWEEN)"
argument_list|,
literal|"KEYWORD(CONTAINS)"
argument_list|,
literal|"KEYWORD(EQUALS)"
argument_list|,
literal|"KEYWORD(FORMAT)"
argument_list|,
literal|"KEYWORD(ILIKE)"
argument_list|,
literal|"KEYWORD(RLIKE)"
argument_list|,
literal|"KEYWORD(IMMEDIATELY)"
argument_list|,
literal|"KEYWORD(IN)"
argument_list|,
literal|"KEYWORD(IS)"
argument_list|,
literal|"KEYWORD(LIKE)"
argument_list|,
literal|"KEYWORD(MEMBER)"
argument_list|,
literal|"KEYWORD(MULTISET)"
argument_list|,
literal|"KEYWORD(NOT)"
argument_list|,
literal|"KEYWORD(OR)"
argument_list|,
literal|"KEYWORD(OVERLAPS)"
argument_list|,
literal|"KEYWORD(PRECEDES)"
argument_list|,
literal|"KEYWORD(SIMILAR)"
argument_list|,
literal|"KEYWORD(SUBMULTISET)"
argument_list|,
literal|"KEYWORD(SUCCEEDS)"
argument_list|,
literal|"KEYWORD([)"
argument_list|,
literal|"KEYWORD(||)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|WHERE_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(MINUS)"
argument_list|,
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(GROUP)"
argument_list|,
literal|"KEYWORD(HAVING)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|,
literal|"KEYWORD(WINDOW)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|A_TABLE
init|=
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"TABLE(A)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|JOIN_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(FOR)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|,
literal|"KEYWORD(FULL)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(EXTEND)"
argument_list|,
literal|"KEYWORD(/*+)"
argument_list|,
literal|"KEYWORD(AS)"
argument_list|,
literal|"KEYWORD(USING)"
argument_list|,
literal|"KEYWORD(OUTER)"
argument_list|,
literal|"KEYWORD(RIGHT)"
argument_list|,
literal|"KEYWORD(GROUP)"
argument_list|,
literal|"KEYWORD(CROSS)"
argument_list|,
literal|"KEYWORD(,)"
argument_list|,
literal|"KEYWORD(NATURAL)"
argument_list|,
literal|"KEYWORD(INNER)"
argument_list|,
literal|"KEYWORD(HAVING)"
argument_list|,
literal|"KEYWORD(LEFT)"
argument_list|,
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(MATCH_RECOGNIZE)"
argument_list|,
literal|"KEYWORD(MINUS)"
argument_list|,
literal|"KEYWORD(JOIN)"
argument_list|,
literal|"KEYWORD(WINDOW)"
argument_list|,
literal|"KEYWORD(.)"
argument_list|,
literal|"KEYWORD(TABLESAMPLE)"
argument_list|,
literal|"KEYWORD(ON)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(WHERE)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SETOPS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(MINUS)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|EMPNO_EMP
init|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"TABLE(EMP)\n"
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Fixture
name|fixture
parameter_list|()
block|{
return|return
name|LOCAL_FIXTURE
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getFromKeywords
parameter_list|()
block|{
return|return
name|FROM_KEYWORDS
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSelectKeywords
parameter_list|()
block|{
return|return
name|SELECT_KEYWORDS
return|;
block|}
comment|/**    * Returns a list of the tables in the SALES schema. Derived classes with    * extended SALES schemas may override.    *    * @return list of tables in the SALES schema    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSalesTables
parameter_list|()
block|{
return|return
name|SALES_TABLES
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getJoinKeywords
parameter_list|()
block|{
return|return
name|JOIN_KEYWORDS
return|;
block|}
annotation|@
name|Test
name|void
name|testFrom
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select a.empno, b.deptno from ^dummy a, sales.dummy b"
decl_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from ^, sales.dummy b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from ^a"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a, ^sales.dummy b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
block|}
annotation|@
name|Test
name|void
name|testFromComplete
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select a.empno, b.deptno from dummy a, sales.^"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testGroup
parameter_list|()
block|{
comment|// This test is hard because the statement is not valid if you replace
comment|// '^' with a dummy identifier.
name|String
name|sql
init|=
literal|"select a.empno, b.deptno from emp group ^"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(BY)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testJoin
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^dummy a join sales.dummy b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^ a join sales.dummy b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// REVIEW: because caret is before 'sales', should it ignore schema
comment|// name and present all schemas and all tables in the default schema?
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join ^sales.dummy b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ on"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
comment|// unfortunately cannot complete this case: syntax is too broken
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ on a.deptno="
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|QUANTIFIERS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// join
block|}
annotation|@
name|Test
name|void
name|testJoinKeywords
parameter_list|()
block|{
comment|// variety of keywords possible
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|getJoinKeywords
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select * from dummy join sales.emp ^"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT * FROM dummy JOIN sales.emp _suggest_"
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimplifyStarAlias
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select ax^ from (select * from dummy a)"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT ax _suggest_ FROM ( SELECT * FROM dummy a )"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimplifySubQueryStar
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select ax^ from (select (select * from dummy) axc from dummy a)"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT ax _suggest_ FROM ("
operator|+
literal|" SELECT ( SELECT * FROM dummy ) axc FROM dummy a )"
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"COLUMN(AXC)\n"
argument_list|,
literal|"ax"
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ax^ from (select a.x+0 axa, b.x axb,"
operator|+
literal|" (select * from dummy) axbc from dummy a, dummy b)"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT ax _suggest_ FROM ( SELECT a.x+0 axa , b.x axb ,"
operator|+
literal|" ( SELECT * FROM dummy ) axbc FROM dummy a , dummy b )"
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"COLUMN(AXA)\nCOLUMN(AXB)\nCOLUMN(AXBC)\n"
argument_list|,
literal|"ax"
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (select * from dummy)"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT _suggest_ FROM ( SELECT * FROM dummy )"
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (select x.* from dummy x)"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT _suggest_ FROM ( SELECT x.* FROM dummy x )"
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (select a.x + b.y from dummy a, dummy b)"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT _suggest_ FROM ( "
operator|+
literal|"SELECT a.x + b.y FROM dummy a , dummy b )"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimplifySubQueryMultipleFrom
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
comment|// "dummy b" should be removed
name|sql
operator|=
literal|"select axc\n"
operator|+
literal|"from (select (select ^ from dummy) axc from dummy a), dummy b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT * FROM ("
operator|+
literal|" SELECT ( SELECT _suggest_ FROM dummy ) axc FROM dummy a )"
argument_list|)
expr_stmt|;
comment|// "dummy b" should be removed
name|sql
operator|=
literal|"select axc\n"
operator|+
literal|"from dummy b, (select (select ^ from dummy) axc from dummy a)"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT * FROM ("
operator|+
literal|" SELECT ( SELECT _suggest_ FROM dummy ) axc FROM dummy a )"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimplifyMinus
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select ^ from dummy a minus select * from dummy b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT _suggest_ FROM dummy a"
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from dummy a minus select ^ from dummy b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
literal|"SELECT _suggest_ FROM dummy b"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testOnCondition
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on ^a.deptno=b.dummy where empno=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// on left
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
comment|// on left
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=^b.dummy where empno=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|QUANTIFIERS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// on right
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.^ where empno=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// on right
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// on right
block|}
annotation|@
name|Test
name|void
name|testFromWhere
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where b.deptno=^a.dummy"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|QUANTIFIERS
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b\n"
operator|+
literal|"where b.deptno=a.^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(COMM)"
argument_list|,
literal|"COMM"
argument_list|)
argument_list|,
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where b.deptno=a.e^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(ENAME)"
argument_list|,
literal|"ename"
argument_list|)
argument_list|,
name|EMP_COLUMNS_E
argument_list|)
expr_stmt|;
comment|// where list
comment|// hints contain no columns, only table aliases, because there are>1
comment|// aliases
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^dummy=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(CURRENT_TIMESTAMP)"
argument_list|,
literal|"CURRENT_TIMESTAMP"
argument_list|)
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// where list
comment|// If there's only one table alias, we allow both the alias and the
comment|// unqualified columns
name|sql
operator|=
literal|"select a.empno, a.deptno from sales.emp a "
operator|+
literal|"where ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|A_TABLE
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testWhereList
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^dummy=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^a.dummy=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where a.^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where a.empno ^ "
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|PREDICATE_KEYWORDS
argument_list|,
name|WHERE_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSelectList
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select ^dummy, b.dummy from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (values (1))"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EXPR$0)"
argument_list|,
literal|"COLUMN(EXPR$0)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (values (1)) as t(c)"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(T)"
argument_list|,
literal|"COLUMN(C)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^, b.dummy from sales.emp a join sales.dept b "
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, ^b.dummy from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|STAR_KEYWORD
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a join sales.dept b on true"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|STAR_KEYWORD
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// REVIEW: Since 'b' is not a valid alias, should it suggest anything?
comment|// We don't get through validation, so the only suggestion, '*', comes
comment|// from the parser.
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^emp.dummy from sales.emp"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EMP)"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Suggest columns for a table name or table alias in the SELECT clause.
specifier|final
name|Consumer
argument_list|<
name|String
argument_list|>
name|c
init|=
name|sql_
lambda|->
name|f
operator|.
name|withSql
argument_list|(
name|sql_
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMP_COLUMNS
argument_list|,
name|STAR_KEYWORD
argument_list|)
decl_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select emp.^ from sales.emp"
argument_list|)
expr_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select emp.^ from sales.emp as emp"
argument_list|)
expr_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select emp.^ from sales.emp emp"
argument_list|)
expr_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select e.^ from sales.emp as e"
argument_list|)
expr_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select e.^ from sales.emp e"
argument_list|)
expr_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select e.^ from sales.emp e, sales.dept d"
argument_list|)
expr_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select e.^ from sales.emp e cross join sales.dept d"
argument_list|)
expr_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select e.^ from sales.emp e where deptno = 20"
argument_list|)
expr_stmt|;
name|c
operator|.
name|accept
argument_list|(
literal|"select e.^ from sales.emp e order by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testOrderByList
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^dummy"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EMP_TABLE
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EMP_TABLE
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno\n"
operator|+
literal|"from sales.emp as e(\n"
operator|+
literal|"  mpno,name,ob,gr,iredate,al,omm,eptno,lacker)\n"
operator|+
literal|"where e.mpno=1 order by ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(MPNO)"
argument_list|,
literal|"COLUMN(NAME)"
argument_list|,
literal|"COLUMN(OB)"
argument_list|,
literal|"COLUMN(GR)"
argument_list|,
literal|"COLUMN(IREDATE)"
argument_list|,
literal|"COLUMN(AL)"
argument_list|,
literal|"COLUMN(OMM)"
argument_list|,
literal|"COLUMN(EPTNO)"
argument_list|,
literal|"COLUMN(LACKER)"
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(E)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by empno ^, deptno"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|PREDICATE_KEYWORDS
argument_list|,
name|ORDER_KEYWORDS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSubQuery
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|xyColumns
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(X)"
argument_list|,
literal|"COLUMN(Y)"
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tTable
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(T)"
argument_list|)
decl_stmt|;
name|sql
operator|=
literal|"select ^t.dummy from (\n"
operator|+
literal|"  select 1 as x, 2 as y from sales.emp) as t\n"
operator|+
literal|"where t.dummy=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|xyColumns
argument_list|,
name|tTable
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales.emp) as t"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|xyColumns
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.emp) as t "
operator|+
literal|"where ^t.dummy=1"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertHint
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x\n"
operator|+
literal|"from (select 1 as x, 2 as y from sales.emp) as t\n"
operator|+
literal|"where t.^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.emp) as t where ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
comment|// with extra from item, aliases are ambiguous, so columns are not
comment|// offered
name|sql
operator|=
literal|"select a.x\n"
operator|+
literal|"from (select 1 as x, 2 as y from sales.emp) as a,\n"
operator|+
literal|"  dept as b\n"
operator|+
literal|"where ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// note that we get hints even though there's a syntax error in
comment|// select clause ('t.')
name|sql
operator|=
literal|"select t.\n"
operator|+
literal|"from (select 1 as x, 2 as y from (select x from sales.emp)) as t\n"
operator|+
literal|"where ^"
expr_stmt|;
name|String
name|simplified
init|=
literal|"SELECT * "
operator|+
literal|"FROM ( SELECT 1 as x , 2 as y FROM ( SELECT x FROM sales.emp ) ) as t "
operator|+
literal|"WHERE _suggest_"
decl_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|simplified
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.^) as t"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// CALCITE-3474:SqlSimpleParser toke.s equals NullPointerException
name|sql
operator|=
literal|"select ^ from (select * from sales.emp) as t"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSelectKeywords
argument_list|()
argument_list|,
name|tTable
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSubQueryInWhere
parameter_list|()
block|{
comment|// Aliases from enclosing sub-queries are inherited: hence A from
comment|// enclosing, B from same scope.
comment|// The raw columns from dept are suggested (because they can
comment|// be used unqualified in the inner scope) but the raw
comment|// columns from emp are not (because they would need to be qualified
comment|// with A).
name|String
name|sql
init|=
literal|"select * from sales.emp a where deptno in ("
operator|+
literal|"select * from sales.dept b where ^)"
decl_stmt|;
name|String
name|simplifiedSql
init|=
literal|"SELECT * FROM sales.emp a WHERE deptno in ("
operator|+
literal|" SELECT * FROM sales.dept b WHERE _suggest_ )"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|simplifiedSql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|AB_TABLES
argument_list|,
name|DEPT_COLUMNS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimpleParserTokenizer
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select"
operator|+
literal|" 12"
operator|+
literal|" "
operator|+
literal|"*"
operator|+
literal|" 1.23e45"
operator|+
literal|" "
operator|+
literal|"("
operator|+
literal|"\"an id\""
operator|+
literal|","
operator|+
literal|" "
operator|+
literal|"\"an id with \"\"quotes' inside\""
operator|+
literal|","
operator|+
literal|" "
operator|+
literal|"/* a comment, with 'quotes', over\nmultiple lines\nand select keyword */"
operator|+
literal|"\n "
operator|+
literal|"("
operator|+
literal|" "
operator|+
literal|"a"
operator|+
literal|" "
operator|+
literal|"different"
operator|+
literal|" "
operator|+
literal|"// comment\n\r"
operator|+
literal|"//and a comment /* containing comment */ and then some more\r"
operator|+
literal|")"
operator|+
literal|" "
operator|+
literal|"from"
operator|+
literal|" "
operator|+
literal|"t"
operator|+
literal|")"
operator|+
literal|")"
operator|+
literal|"/* a comment after close paren */"
operator|+
literal|" "
operator|+
literal|"("
operator|+
literal|"'quoted'"
operator|+
literal|" "
operator|+
literal|"'string with ''single and \"double\"\" quote'"
operator|+
literal|")"
decl_stmt|;
name|String
name|expected
init|=
literal|"SELECT\n"
operator|+
literal|"ID(12)\n"
operator|+
literal|"ID(*)\n"
operator|+
literal|"ID(1.23e45)\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"DQID(\"an id\")\n"
operator|+
literal|"COMMA\n"
operator|+
literal|"DQID(\"an id with \"\"quotes' inside\")\n"
operator|+
literal|"COMMA\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"ID(a)\n"
operator|+
literal|"ID(different)\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"FROM\n"
operator|+
literal|"ID(t)\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"SQID('quoted')\n"
operator|+
literal|"SQID('string with ''single and \"double\"\" quote')\n"
operator|+
literal|"RPAREN\n"
decl_stmt|;
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertTokenizesTo
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// Tokenizer should be lenient if input ends mid-token
name|f
operator|.
name|withSql
argument_list|(
literal|"select /* unfinished comment"
argument_list|)
operator|.
name|assertTokenizesTo
argument_list|(
literal|"SELECT\nCOMMENT\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"select // unfinished comment"
argument_list|)
operator|.
name|assertTokenizesTo
argument_list|(
literal|"SELECT\nCOMMENT\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"'starts with string'"
argument_list|)
operator|.
name|assertTokenizesTo
argument_list|(
literal|"SQID('starts with string')\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"'unfinished string"
argument_list|)
operator|.
name|assertTokenizesTo
argument_list|(
literal|"SQID('unfinished string)\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"\"unfinished double-quoted id"
argument_list|)
operator|.
name|assertTokenizesTo
argument_list|(
literal|"DQID(\"unfinished double-quoted id)\n"
argument_list|)
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"123"
argument_list|)
operator|.
name|assertTokenizesTo
argument_list|(
literal|"ID(123)\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimpleParser
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|String
name|expected
decl_stmt|;
comment|// from
name|sql
operator|=
literal|"select * from ^where"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// select list
name|sql
operator|=
literal|"select ^ from (values (1))"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM ( values ( 1 ) )"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.^ from sales.emp"
expr_stmt|;
name|expected
operator|=
literal|"SELECT emp. _suggest_ FROM sales.emp"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^from sales.emp"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// remove other expressions in select clause
name|sql
operator|=
literal|"select a.empno ,^  from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^, a.empno from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT b. _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join ^on where empno=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM dummy a JOIN _suggest_ ON TRUE"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ where empno=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM dummy a JOIN sales. _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// on
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a JOIN sales.dept b "
operator|+
literal|"ON a.deptno= _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// where
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a , sales.dept b WHERE _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// order by
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT emp.empno FROM sales.emp ORDER BY _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// sub-query in from
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales.emp) as t "
operator|+
literal|"where t.dummy=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT t. _suggest_ "
operator|+
literal|"FROM ( SELECT 1 as x , 2 as y FROM sales.emp ) as t"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t. from (select 1 as x, 2 as y from "
operator|+
literal|"(select x from sales.emp)) as t where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT 1 as x , 2 as y FROM "
operator|+
literal|"( SELECT x FROM sales.emp ) ) as t WHERE _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^from (select 1 as x, 2 as y from sales.emp), "
operator|+
literal|"(select 2 as y from (select m from n where)) as t "
operator|+
literal|"where t.dummy=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM ( SELECT 1 as x , 2 as y FROM sales.emp ) "
operator|+
literal|", ( SELECT 2 as y FROM ( SELECT m FROM n ) ) as t"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// Note: completes the missing close paren; wipes out select clause of
comment|// both outer and inner queries since not relevant.
name|sql
operator|=
literal|"select t.x from ( select 1 as x, 2 as y from sales.^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT * FROM sales. _suggest_ )"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales)"
expr_stmt|;
name|expected
operator|=
literal|"SELECT t. _suggest_ FROM ( SELECT 1 as x , 2 as y FROM sales )"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// sub-query in where; note that:
comment|// 1. removes the SELECT clause of sub-query in WHERE clause;
comment|// 2. keeps SELECT clause of sub-query in FROM clause;
comment|// 3. removes GROUP BY clause of sub-query in FROM clause;
comment|// 4. removes SELECT clause of outer query.
name|sql
operator|=
literal|"select x + y + 32 from "
operator|+
literal|"(select 1 as x, 2 as y from sales group by invalid stuff) as t "
operator|+
literal|"where x in (select deptno from emp where foo + t.^< 10)"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT 1 as x , 2 as y FROM sales ) as t "
operator|+
literal|"WHERE x in ( SELECT * FROM emp WHERE foo + t. _suggest_< 10 )"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// if hint is in FROM, can remove other members of FROM clause
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a, sales.^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales. _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// function
name|sql
operator|=
literal|"select count(1) from sales.emp a where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a WHERE _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select count(1) from sales.emp a "
operator|+
literal|"where substring(a.^ FROM 3 for 6) = '1234'"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a "
operator|+
literal|"WHERE substring ( a. _suggest_ FROM 3 for 6 ) = '1234'"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// missing ')' following sub-query
name|sql
operator|=
literal|"select * from sales.emp a where deptno in ("
operator|+
literal|"select * from sales.dept b where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a WHERE deptno in ("
operator|+
literal|" SELECT * FROM sales.dept b WHERE _suggest_ )"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// keyword embedded in single and double quoted string should be
comment|// ignored
name|sql
operator|=
literal|"select 'a cat from a king' as foobar, 1 / 2 \"where\" from t "
operator|+
literal|"group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"select /* here is from */ 'cat' as foobar, 1 as x\n"
operator|+
literal|"from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"select // here is from clause\n"
operator|+
literal|" 'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"select -- here is from clause\n"
operator|+
literal|" 'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"-- test test\n"
operator|+
literal|"select -- here is from\n"
operator|+
literal|"'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimpleParserQuotedIdSqlServer
parameter_list|()
block|{
name|checkSimpleParserQuotedIdImpl
argument_list|(
name|fixture
argument_list|()
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|SQL_SERVER
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimpleParserQuotedIdMySql
parameter_list|()
block|{
name|checkSimpleParserQuotedIdImpl
argument_list|(
name|fixture
argument_list|()
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|MYSQL
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimpleParserQuotedIdJava
parameter_list|()
block|{
name|checkSimpleParserQuotedIdImpl
argument_list|(
name|fixture
argument_list|()
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSimpleParserQuotedIdDefault
parameter_list|()
block|{
name|checkSimpleParserQuotedIdImpl
argument_list|(
name|fixture
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|replaceQuotes
parameter_list|(
name|SqlParser
operator|.
name|Config
name|parserConfig
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|char
name|openQuote
init|=
name|parserConfig
operator|.
name|quoting
argument_list|()
operator|.
name|string
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
name|closeQuote
init|=
name|openQuote
operator|==
literal|'['
condition|?
literal|']'
else|:
name|openQuote
decl_stmt|;
return|return
name|sql
operator|.
name|replace
argument_list|(
literal|'['
argument_list|,
name|openQuote
argument_list|)
operator|.
name|replace
argument_list|(
literal|']'
argument_list|,
name|closeQuote
argument_list|)
return|;
block|}
specifier|private
name|void
name|checkSimpleParserQuotedIdImpl
parameter_list|(
name|Fixture
name|fixture
parameter_list|)
block|{
name|SqlParser
operator|.
name|Config
name|parserConfig
init|=
name|fixture
operator|.
name|parserConfig
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|String
name|expected
decl_stmt|;
comment|// unclosed double-quote
name|sql
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"select * from t where [^"
argument_list|)
expr_stmt|;
name|expected
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"SELECT * FROM t WHERE _suggest_"
argument_list|)
expr_stmt|;
name|fixture
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// closed double-quote
name|sql
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"select * from t where [^] and x = y"
argument_list|)
expr_stmt|;
name|expected
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"SELECT * FROM t WHERE _suggest_ and x = y"
argument_list|)
expr_stmt|;
name|fixture
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// closed double-quote containing extra stuff
name|sql
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"select * from t where [^foo] and x = y"
argument_list|)
expr_stmt|;
name|expected
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"SELECT * FROM t WHERE _suggest_ and x = y"
argument_list|)
expr_stmt|;
name|fixture
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
comment|// escaped double-quote containing extra stuff
name|sql
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"select * from t where [^f]]oo] and x = y"
argument_list|)
expr_stmt|;
name|expected
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"SELECT * FROM t WHERE _suggest_ and x = y"
argument_list|)
expr_stmt|;
name|fixture
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPartialIdentifier
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select * from emp where e^ and emp.deptno = 10"
decl_stmt|;
name|String
name|expected
init|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"COLUMN(ENAME)\n"
operator|+
literal|"KEYWORD(ELEMENT)\n"
operator|+
literal|"KEYWORD(EVERY)\n"
operator|+
literal|"KEYWORD(EXISTS)\n"
operator|+
literal|"KEYWORD(EXP)\n"
operator|+
literal|"KEYWORD(EXTRACT)\n"
operator|+
literal|"TABLE(EMP)\n"
decl_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|expected
argument_list|,
literal|"e"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"exists"
argument_list|,
literal|"TABLE(EMP)"
argument_list|,
literal|"emp"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from emp where \"e^ and emp.deptno = 10"
expr_stmt|;
name|expected
operator|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"COLUMN(ENAME)\n"
operator|+
literal|"KEYWORD(ELEMENT)\n"
operator|+
literal|"KEYWORD(EVERY)\n"
operator|+
literal|"KEYWORD(EXISTS)\n"
operator|+
literal|"KEYWORD(EXP)\n"
operator|+
literal|"KEYWORD(EXTRACT)\n"
operator|+
literal|"TABLE(EMP)\n"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|expected
argument_list|,
literal|"\"e"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"exists"
argument_list|,
literal|"TABLE(EMP)"
argument_list|,
literal|"\"EMP\""
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from emp where E^ and emp.deptno = 10"
expr_stmt|;
name|expected
operator|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"COLUMN(ENAME)\n"
operator|+
literal|"KEYWORD(ELEMENT)\n"
operator|+
literal|"KEYWORD(EVERY)\n"
operator|+
literal|"KEYWORD(EXISTS)\n"
operator|+
literal|"KEYWORD(EXP)\n"
operator|+
literal|"KEYWORD(EXTRACT)\n"
operator|+
literal|"TABLE(EMP)\n"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|expected
argument_list|,
literal|"E"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"EXISTS"
argument_list|,
literal|"TABLE(EMP)"
argument_list|,
literal|"EMP"
argument_list|)
argument_list|)
expr_stmt|;
comment|// cursor in middle of word and at end
name|sql
operator|=
literal|"select * from emp where e^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|expected
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// longer completion
name|sql
operator|=
literal|"select * from emp where em^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMPNO_EMP
argument_list|,
literal|null
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"empno"
argument_list|)
argument_list|)
expr_stmt|;
comment|// word after punctuation
name|sql
operator|=
literal|"select deptno,em^ from emp where 1+2<3+4"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMPNO_EMP
argument_list|,
literal|null
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"empno"
argument_list|)
argument_list|)
expr_stmt|;
comment|// inside double-quotes, no terminating double-quote.
comment|// Only identifiers should be suggested (no keywords),
comment|// and suggestion should include double-quotes
name|sql
operator|=
literal|"select deptno,\"EM^ from emp where 1+2<3+4"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"\"EMPNO\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// inside double-quotes, match is case-insensitive as well
name|sql
operator|=
literal|"select deptno,\"em^ from emp where 1+2<3+4"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMPNO_EMP
argument_list|,
literal|"\"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"\"EMPNO\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// when input strings has mixed casing, match should be case-sensitive
name|sql
operator|=
literal|"select deptno,eM^ from emp where 1+2<3+4"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|""
argument_list|,
literal|"eM"
argument_list|)
expr_stmt|;
comment|// when input strings has mixed casing, match should be case-sensitive
name|sql
operator|=
literal|"select deptno,\"eM^ from emp where 1+2<3+4"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|""
argument_list|,
literal|"\"eM"
argument_list|)
expr_stmt|;
comment|// eat up following double-quote
name|sql
operator|=
literal|"select deptno,\"EM^ps\" from emp where 1+2<3+4"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"\"EMPNO\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// closing double-quote is at very end of string
name|sql
operator|=
literal|"select * from emp where 5 = \"EM^xxx\""
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"\"EMPNO\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// just before dot
name|sql
operator|=
literal|"select emp.^name from emp"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EMP_COLUMNS
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testAdviceKeywordsJava
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select deptno, exi^ from emp where 1+2<3+4"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"KEYWORD(EXISTS)\n"
argument_list|,
literal|"exi"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"exists"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testAdviceMixedCase
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select is^ from (select 1 isOne from emp)"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"COLUMN(isOne)\n"
argument_list|,
literal|"is"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(isOne)"
argument_list|,
literal|"isOne"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testAdviceExpression
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select s.`count`+s.co^ from (select 1 `count` from emp) s"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"COLUMN(count)\n"
argument_list|,
literal|"co"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(count)"
argument_list|,
literal|"`count`"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testAdviceEmptyFrom
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select * from^"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"KEYWORD(FROM)\n"
argument_list|,
literal|"from"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(FROM)"
argument_list|,
literal|"from"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
argument_list|(
literal|"Inserts are not supported by SimpleParser yet"
argument_list|)
annotation|@
name|Test
name|void
name|testInsert
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"insert into emp(empno, mgr) select ^ from dept a"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|A_TABLE
argument_list|,
name|DEPT_COLUMNS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"insert into emp(empno, mgr) values (123, 3 + ^)"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// Wish we could do better here. Parser gives error 'Non-query
comment|// expression encountered in illegal context' and cannot suggest
comment|// possible tokens.
name|sql
operator|=
literal|"insert into emp(empno, mgr) ^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testNestSchema
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select * from sales.n^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"n"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"nest"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from sales.\"n^asfasdf"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"\"n"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"\"NEST\""
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from sales.n^est"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"n"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"nest"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from sales.nu^"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|""
argument_list|,
literal|"nu"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
argument_list|(
literal|"The set of completion results is empty"
argument_list|)
annotation|@
name|Test
name|void
name|testNestTable1
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
comment|// select scott.emp.deptno from scott.emp; # valid
name|sql
operator|=
literal|"select catalog.sales.emp.em^ from catalog.sales.emp"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"COLUMN(EMPNO)\n"
argument_list|,
literal|"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"empno"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select catalog.sales.em^ from catalog.sales.emp"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"TABLE(EMP)\n"
argument_list|,
literal|"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"TABLE(EMP)"
argument_list|,
literal|"emp"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testNestTable2
parameter_list|()
block|{
comment|// select scott.emp.deptno from scott.emp as e; # not valid
name|String
name|sql
init|=
literal|"select catalog.sales.emp.em^ from catalog.sales.emp as e"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|""
argument_list|,
literal|"em"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
argument_list|(
literal|"The set of completion results is empty"
argument_list|)
annotation|@
name|Test
name|void
name|testNestTable3
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
comment|// select scott.emp.deptno from emp; # valid
name|sql
operator|=
literal|"select catalog.sales.emp.em^ from emp"
expr_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"COLUMN(EMPNO)\n"
argument_list|,
literal|"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMP)"
argument_list|,
literal|"empno"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select catalog.sales.em^ from emp"
expr_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"TABLE(EMP)\n"
argument_list|,
literal|"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"TABLE(EMP)"
argument_list|,
literal|"emp"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testNestTable4
parameter_list|()
block|{
comment|// select scott.emp.deptno from emp as emp; # not valid
name|String
name|sql
init|=
literal|"select catalog.sales.emp.em^ from catalog.sales.emp as emp"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|""
argument_list|,
literal|"em"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testNestTableSchemaMustMatch
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
comment|// select foo.emp.deptno from emp; # not valid
name|sql
operator|=
literal|"select sales.nest.em^ from catalog.sales.emp_r"
expr_stmt|;
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|""
argument_list|,
literal|"em"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testNestSchemaSqlServer
parameter_list|()
block|{
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|SQL_SERVER
argument_list|)
decl_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"select * from SALES.N^"
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"N"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"NEST"
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"select * from SALES.[n^asfasdf"
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"[n"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"[NEST]"
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"select * from SALES.[N^est"
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"[N"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"[NEST]"
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
literal|"select * from SALES.NU^"
argument_list|)
operator|.
name|assertComplete
argument_list|(
literal|""
argument_list|,
literal|"NU"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testUnion
parameter_list|()
block|{
comment|// we simplify set ops such as UNION by removing other queries -
comment|// thereby avoiding validation errors due to mismatched select lists
name|String
name|sql
init|=
literal|"select 1 from emp union select 2 from dept a where ^ and deptno< 5"
decl_stmt|;
name|String
name|simplified
init|=
literal|"SELECT * FROM dept a WHERE _suggest_ and deptno< 5"
decl_stmt|;
specifier|final
name|Fixture
name|f
init|=
name|fixture
argument_list|()
decl_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|simplified
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|A_TABLE
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// UNION ALL
name|sql
operator|=
literal|"select 1 from emp\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 2 from dept a where ^ and deptno< 5"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|simplified
argument_list|)
expr_stmt|;
comment|// hint is in first query
name|sql
operator|=
literal|"select 1 from emp group by ^ except select 2 from dept a"
expr_stmt|;
name|simplified
operator|=
literal|"SELECT * FROM emp GROUP BY _suggest_"
expr_stmt|;
name|f
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|simplified
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testMssql
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select 1 from [emp]\n"
operator|+
literal|"union\n"
operator|+
literal|"select 2 from [DEPT] a where ^ and deptno< 5"
decl_stmt|;
name|String
name|simplified
init|=
literal|"SELECT * FROM [DEPT] a WHERE _suggest_ and deptno< 5"
decl_stmt|;
name|fixture
argument_list|()
operator|.
name|withLex
argument_list|(
name|Lex
operator|.
name|SQL_SERVER
argument_list|)
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertSimplify
argument_list|(
name|simplified
argument_list|)
operator|.
name|assertComplete
argument_list|(
name|EXPR_KEYWORDS
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"TABLE(a)"
argument_list|)
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testFilterComment
parameter_list|()
block|{
comment|// SqlSimpleParser.Tokenizer#nextToken() lines 401 - 423
comment|// is used to recognize the sql of TokenType.ID or some keywords
comment|// if a certain segment of characters is continuously composed of Token,
comment|// the function of this code may be wrong
comment|// E.g :
comment|// (1)select * from a where price> 10.0--comment
comment|// ã10.0--commentãshould be recognize as TokenType.ID("10.0") and TokenType.COMMENT
comment|// but it recognize as TokenType.ID("10.0--comment")
comment|// (2)select * from a where column_b='/* this is not comment */'
comment|// ã/* this is not comment */ãshould be recognize as
comment|// TokenType.SQID("/* this is not comment */"), but it was not
specifier|final
name|String
name|baseOriginSql
init|=
literal|"select * from a "
decl_stmt|;
specifier|final
name|String
name|baseResultSql
init|=
literal|"SELECT * FROM a "
decl_stmt|;
name|String
name|originSql
decl_stmt|;
comment|// when SqlSimpleParser.Tokenizer#nextToken() method parse sql,
comment|// ignore the  "--" after 10.0, this is a comment,
comment|// but Tokenizer#nextToken() does not recognize it
name|originSql
operator|=
name|baseOriginSql
operator|+
literal|"where price> 10.0-- this is comment "
operator|+
name|System
operator|.
name|lineSeparator
argument_list|()
operator|+
literal|" -- comment "
expr_stmt|;
name|assertSimplifySql
argument_list|(
name|originSql
argument_list|,
name|baseResultSql
operator|+
literal|"WHERE price> 10.0"
argument_list|)
expr_stmt|;
name|originSql
operator|=
name|baseOriginSql
operator|+
literal|"where column_b='/* this is not comment */'"
expr_stmt|;
name|assertSimplifySql
argument_list|(
name|originSql
argument_list|,
name|baseResultSql
operator|+
literal|"WHERE column_b= '/* this is not comment */'"
argument_list|)
expr_stmt|;
name|originSql
operator|=
name|baseOriginSql
operator|+
literal|"where column_b='2021 --this is not comment'"
expr_stmt|;
name|assertSimplifySql
argument_list|(
name|originSql
argument_list|,
name|baseResultSql
operator|+
literal|"WHERE column_b= '2021 --this is not comment'"
argument_list|)
expr_stmt|;
name|originSql
operator|=
name|baseOriginSql
operator|+
literal|"where column_b='2021--this is not comment'"
expr_stmt|;
name|assertSimplifySql
argument_list|(
name|originSql
argument_list|,
name|baseResultSql
operator|+
literal|"WHERE column_b= '2021--this is not comment'"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that the simplified originSql is consistent with expectedSql.    *    * @param originSql   a string sql to simplify.    * @param expectedSql Expected result after simplification.    */
specifier|private
name|void
name|assertSimplifySql
parameter_list|(
name|String
name|originSql
parameter_list|,
name|String
name|expectedSql
parameter_list|)
block|{
name|SqlSimpleParser
name|simpleParser
init|=
operator|new
name|SqlSimpleParser
argument_list|(
literal|"_suggest_"
argument_list|,
name|SqlParser
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|String
name|actualSql
init|=
name|simpleParser
operator|.
name|simplifySql
argument_list|(
name|originSql
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"simpleParser.simplifySql("
operator|+
name|originSql
operator|+
literal|")"
argument_list|,
name|actualSql
argument_list|,
name|equalTo
argument_list|(
name|expectedSql
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Fixture for the advisor test. */
specifier|static
class|class
name|Fixture
extends|extends
name|SqlValidatorFixture
block|{
specifier|protected
name|Fixture
parameter_list|(
name|SqlTester
name|tester
parameter_list|,
name|SqlTestFactory
name|factory
parameter_list|,
name|StringAndPos
name|sap
parameter_list|,
name|boolean
name|expression
parameter_list|,
name|boolean
name|whole
parameter_list|)
block|{
name|super
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|sap
argument_list|,
name|expression
argument_list|,
name|whole
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Override
specifier|public
name|Fixture
name|withTester
parameter_list|(
name|UnaryOperator
argument_list|<
name|SqlTester
argument_list|>
name|transform
parameter_list|)
block|{
specifier|final
name|SqlTester
name|tester
init|=
name|transform
operator|.
name|apply
argument_list|(
name|this
operator|.
name|tester
argument_list|)
decl_stmt|;
return|return
operator|new
name|Fixture
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|sap
argument_list|,
name|expression
argument_list|,
name|whole
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Fixture
name|withFactory
parameter_list|(
name|UnaryOperator
argument_list|<
name|SqlTestFactory
argument_list|>
name|transform
parameter_list|)
block|{
specifier|final
name|SqlTestFactory
name|factory
init|=
name|transform
operator|.
name|apply
argument_list|(
name|this
operator|.
name|factory
argument_list|)
decl_stmt|;
return|return
operator|new
name|Fixture
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|sap
argument_list|,
name|expression
argument_list|,
name|whole
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Fixture
name|withLex
parameter_list|(
name|Lex
name|lex
parameter_list|)
block|{
return|return
operator|(
name|Fixture
operator|)
name|super
operator|.
name|withLex
argument_list|(
name|lex
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Fixture
name|withSql
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
return|return
operator|new
name|Fixture
argument_list|(
name|tester
argument_list|,
name|factory
argument_list|,
name|StringAndPos
operator|.
name|of
argument_list|(
name|sql
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|void
name|assertTokenizesTo
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
name|SqlSimpleParser
operator|.
name|Tokenizer
name|tokenizer
init|=
operator|new
name|SqlSimpleParser
operator|.
name|Tokenizer
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
literal|"xxxxx"
argument_list|,
name|factory
operator|.
name|parserConfig
argument_list|()
operator|.
name|quoting
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|SqlSimpleParser
operator|.
name|Token
name|token
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|buf
operator|.
name|append
argument_list|(
name|token
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertHint
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedLists
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|plus
argument_list|(
name|expectedLists
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expected
init|=
name|toString
argument_list|(
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|expectedList
argument_list|)
argument_list|)
decl_stmt|;
name|assertHint
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/**      * Checks that a given SQL statement yields the expected set of completion      * hints.      *      * @param expectedResults Expected list of hints      */
specifier|protected
name|void
name|assertHint
parameter_list|(
name|String
name|expectedResults
parameter_list|)
block|{
name|SqlAdvisor
name|advisor
init|=
name|factory
operator|.
name|createAdvisor
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|results
init|=
name|advisor
operator|.
name|getCompletionHints
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|requireNonNull
argument_list|(
name|sap
operator|.
name|pos
argument_list|,
literal|"sap.pos"
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedResults
argument_list|,
name|convertCompletionHints
argument_list|(
name|results
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests that a given SQL statement simplifies to the salesTables result.      *      * @param expected Expected result after simplification.      */
specifier|protected
name|Fixture
name|assertSimplify
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
name|SqlAdvisor
name|advisor
init|=
name|factory
operator|.
name|createAdvisor
argument_list|()
decl_stmt|;
name|String
name|actual
init|=
name|advisor
operator|.
name|simplifySql
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|sap
operator|.
name|cursor
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedResults
parameter_list|)
block|{
name|assertComplete
argument_list|(
literal|null
argument_list|,
name|expectedResults
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|replacements
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedResults
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|plus
argument_list|(
name|expectedResults
argument_list|)
decl_stmt|;
name|String
name|expected
init|=
name|toString
argument_list|(
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|expectedList
argument_list|)
argument_list|)
decl_stmt|;
name|assertComplete
argument_list|(
name|expected
argument_list|,
literal|null
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|String
name|expectedResults
parameter_list|,
annotation|@
name|Nullable
name|String
name|expectedWord
parameter_list|)
block|{
name|assertComplete
argument_list|(
name|expectedResults
argument_list|,
name|expectedWord
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests that a given SQL which may be invalid or incomplete simplifies      * itself and yields the salesTables set of completion hints. This is an      * integration test of {@link #assertHint} and {@link #assertSimplify}.      *      * @param expectedResults Expected list of hints      * @param expectedWord    Word that we expect to be replaced, or null if we      *                        don't care      */
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|String
name|expectedResults
parameter_list|,
annotation|@
name|Nullable
name|String
name|expectedWord
parameter_list|,
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|replacements
parameter_list|)
block|{
name|SqlAdvisor
name|advisor
init|=
name|factory
operator|.
name|createAdvisor
argument_list|()
decl_stmt|;
specifier|final
name|String
index|[]
name|replaced
init|=
block|{
literal|null
block|}
decl_stmt|;
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|results
init|=
name|advisor
operator|.
name|getCompletionHints
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|sap
operator|.
name|cursor
argument_list|,
name|replaced
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedResults
argument_list|,
name|convertCompletionHints
argument_list|(
name|results
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"Completion hints for "
operator|+
name|sap
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedWord
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
name|expectedWord
argument_list|,
name|replaced
index|[
literal|0
index|]
argument_list|,
literal|"replaced[0] for "
operator|+
name|sap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNotNull
argument_list|(
name|replaced
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertReplacements
argument_list|(
name|replacements
argument_list|,
name|advisor
argument_list|,
name|replaced
index|[
literal|0
index|]
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assertReplacements
parameter_list|(
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|replacements
parameter_list|,
name|SqlAdvisor
name|advisor
parameter_list|,
name|String
name|word
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|results
parameter_list|)
block|{
if|if
condition|(
name|replacements
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|missingReplacemenets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|replacements
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlMoniker
name|result
range|:
name|results
control|)
block|{
name|String
name|id
init|=
name|result
operator|.
name|id
argument_list|()
decl_stmt|;
name|String
name|expectedReplacement
init|=
name|replacements
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedReplacement
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|missingReplacemenets
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|String
name|actualReplacement
init|=
name|advisor
operator|.
name|getReplacement
argument_list|(
name|result
argument_list|,
name|word
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedReplacement
argument_list|,
name|actualReplacement
argument_list|,
parameter_list|()
lambda|->
name|sap
operator|+
literal|", replacement of "
operator|+
name|word
operator|+
literal|" with "
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|missingReplacemenets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|fail
argument_list|(
literal|"Sql "
operator|+
name|sap
operator|+
literal|" did not produce replacement hints "
operator|+
name|missingReplacemenets
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|convertCompletionHints
parameter_list|(
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hints
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlMoniker
name|hint
range|:
name|hints
control|)
block|{
if|if
condition|(
name|hint
operator|.
name|getType
argument_list|()
operator|!=
name|SqlMonikerType
operator|.
name|FUNCTION
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|hint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|toString
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**      * Converts a list to a string, one item per line.      *      * @param list List      * @return String with one item of the list per line      */
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|toString
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|list
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|t
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Concatenates several lists of the same type into a single list.      *      * @param lists Lists to concatenate      * @return Sum list      */
specifier|protected
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|plus
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
modifier|...
name|lists
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|T
argument_list|>
name|list
range|:
name|lists
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
block|}
end_class

end_unit

