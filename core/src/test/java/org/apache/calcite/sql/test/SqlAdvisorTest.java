begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|Lex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|advise
operator|.
name|SqlAdvisor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|advise
operator|.
name|SqlAdvisorValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|advise
operator|.
name|SqlSimpleParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMoniker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonikerType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|SqlValidatorTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|WithLex
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|MethodRule
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Concrete child class of {@link SqlValidatorTestCase}, containing unit tests  * for SqlAdvisor.  */
end_comment

begin_class
specifier|public
class|class
name|SqlAdvisorTest
extends|extends
name|SqlValidatorTestCase
block|{
specifier|public
specifier|static
specifier|final
name|SqlTestFactory
name|ADVISOR_TEST_FACTORY
init|=
name|SqlTestFactory
operator|.
name|INSTANCE
operator|.
name|withValidator
argument_list|(
name|SqlAdvisorValidator
operator|::
operator|new
argument_list|)
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|MethodRule
name|configureTester
init|=
name|SqlValidatorTestCase
operator|.
name|TESTER_CONFIGURATION_RULE
decl_stmt|;
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|STAR_KEYWORD
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(*)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FROM_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(LATERAL)"
argument_list|,
literal|"KEYWORD(TABLE)"
argument_list|,
literal|"KEYWORD(UNNEST)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SALES_TABLES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"SCHEMA(CATALOG.SALES)"
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMPDEFAULTS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMPNULLABLES)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP_B)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP_20)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMPNULLABLES_20)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP_ADDRESS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.DEPT)"
argument_list|,
literal|"TABLE(CATALOG.SALES.DEPT_NESTED)"
argument_list|,
literal|"TABLE(CATALOG.SALES.BONUS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.ORDERS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.SALGRADE)"
argument_list|,
literal|"TABLE(CATALOG.SALES.SHIPMENTS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.PRODUCTS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.SUPPLIERS)"
argument_list|,
literal|"TABLE(CATALOG.SALES.EMP_R)"
argument_list|,
literal|"TABLE(CATALOG.SALES.DEPT_R)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SCHEMAS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"CATALOG(CATALOG)"
argument_list|,
literal|"SCHEMA(CATALOG.DYNAMIC)"
argument_list|,
literal|"SCHEMA(CATALOG.SALES)"
argument_list|,
literal|"SCHEMA(CATALOG.STRUCT)"
argument_list|,
literal|"SCHEMA(CATALOG.CUSTOMER)"
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|AB_TABLES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(A)"
argument_list|,
literal|"TABLE(B)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_TABLE
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EMP)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FETCH_OFFSET
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EXPR_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(+)"
argument_list|,
literal|"KEYWORD(-)"
argument_list|,
literal|"KEYWORD(?)"
argument_list|,
literal|"KEYWORD(ABS)"
argument_list|,
literal|"KEYWORD(ARRAY)"
argument_list|,
literal|"KEYWORD(AVG)"
argument_list|,
literal|"KEYWORD(CARDINALITY)"
argument_list|,
literal|"KEYWORD(CASE)"
argument_list|,
literal|"KEYWORD(CAST)"
argument_list|,
literal|"KEYWORD(CEIL)"
argument_list|,
literal|"KEYWORD(CEILING)"
argument_list|,
literal|"KEYWORD(CHARACTER_LENGTH)"
argument_list|,
literal|"KEYWORD(CHAR_LENGTH)"
argument_list|,
literal|"KEYWORD(CLASSIFIER)"
argument_list|,
literal|"KEYWORD(COALESCE)"
argument_list|,
literal|"KEYWORD(COLLECT)"
argument_list|,
literal|"KEYWORD(CONVERT)"
argument_list|,
literal|"KEYWORD(COUNT)"
argument_list|,
literal|"KEYWORD(COVAR_POP)"
argument_list|,
literal|"KEYWORD(COVAR_SAMP)"
argument_list|,
literal|"KEYWORD(CUME_DIST)"
argument_list|,
literal|"KEYWORD(CURRENT)"
argument_list|,
literal|"KEYWORD(CURRENT_CATALOG)"
argument_list|,
literal|"KEYWORD(CURRENT_DATE)"
argument_list|,
literal|"KEYWORD(CURRENT_DEFAULT_TRANSFORM_GROUP)"
argument_list|,
literal|"KEYWORD(CURRENT_PATH)"
argument_list|,
literal|"KEYWORD(CURRENT_ROLE)"
argument_list|,
literal|"KEYWORD(CURRENT_SCHEMA)"
argument_list|,
literal|"KEYWORD(CURRENT_TIME)"
argument_list|,
literal|"KEYWORD(CURRENT_TIMESTAMP)"
argument_list|,
literal|"KEYWORD(CURRENT_USER)"
argument_list|,
literal|"KEYWORD(CURSOR)"
argument_list|,
literal|"KEYWORD(DATE)"
argument_list|,
literal|"KEYWORD(DENSE_RANK)"
argument_list|,
literal|"KEYWORD(ELEMENT)"
argument_list|,
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"KEYWORD(EXP)"
argument_list|,
literal|"KEYWORD(EXTRACT)"
argument_list|,
literal|"KEYWORD(FALSE)"
argument_list|,
literal|"KEYWORD(FIRST_VALUE)"
argument_list|,
literal|"KEYWORD(FLOOR)"
argument_list|,
literal|"KEYWORD(FUSION)"
argument_list|,
literal|"KEYWORD(GROUPING)"
argument_list|,
literal|"KEYWORD(HOUR)"
argument_list|,
literal|"KEYWORD(INTERVAL)"
argument_list|,
literal|"KEYWORD(LAG)"
argument_list|,
literal|"KEYWORD(LAST_VALUE)"
argument_list|,
literal|"KEYWORD(LEAD)"
argument_list|,
literal|"KEYWORD(LN)"
argument_list|,
literal|"KEYWORD(LOCALTIME)"
argument_list|,
literal|"KEYWORD(LOCALTIMESTAMP)"
argument_list|,
literal|"KEYWORD(LOWER)"
argument_list|,
literal|"KEYWORD(MATCH_NUMBER)"
argument_list|,
literal|"KEYWORD(MAX)"
argument_list|,
literal|"KEYWORD(MIN)"
argument_list|,
literal|"KEYWORD(MINUTE)"
argument_list|,
literal|"KEYWORD(MOD)"
argument_list|,
literal|"KEYWORD(MONTH)"
argument_list|,
literal|"KEYWORD(MULTISET)"
argument_list|,
literal|"KEYWORD(NEW)"
argument_list|,
literal|"KEYWORD(NEXT)"
argument_list|,
literal|"KEYWORD(NOT)"
argument_list|,
literal|"KEYWORD(NTH_VALUE)"
argument_list|,
literal|"KEYWORD(NTILE)"
argument_list|,
literal|"KEYWORD(NULL)"
argument_list|,
literal|"KEYWORD(NULLIF)"
argument_list|,
literal|"KEYWORD(OCTET_LENGTH)"
argument_list|,
literal|"KEYWORD(OVERLAY)"
argument_list|,
literal|"KEYWORD(PERCENT_RANK)"
argument_list|,
literal|"KEYWORD(PERIOD)"
argument_list|,
literal|"KEYWORD(POSITION)"
argument_list|,
literal|"KEYWORD(POWER)"
argument_list|,
literal|"KEYWORD(PREV)"
argument_list|,
literal|"KEYWORD(RANK)"
argument_list|,
literal|"KEYWORD(REGR_COUNT)"
argument_list|,
literal|"KEYWORD(REGR_SXX)"
argument_list|,
literal|"KEYWORD(REGR_SYY)"
argument_list|,
literal|"KEYWORD(ROW)"
argument_list|,
literal|"KEYWORD(ROW_NUMBER)"
argument_list|,
literal|"KEYWORD(RUNNING)"
argument_list|,
literal|"KEYWORD(SECOND)"
argument_list|,
literal|"KEYWORD(SESSION_USER)"
argument_list|,
literal|"KEYWORD(SPECIFIC)"
argument_list|,
literal|"KEYWORD(SQRT)"
argument_list|,
literal|"KEYWORD(SUBSTRING)"
argument_list|,
literal|"KEYWORD(STDDEV_POP)"
argument_list|,
literal|"KEYWORD(STDDEV_SAMP)"
argument_list|,
literal|"KEYWORD(SUM)"
argument_list|,
literal|"KEYWORD(SYSTEM_USER)"
argument_list|,
literal|"KEYWORD(TIME)"
argument_list|,
literal|"KEYWORD(TIMESTAMP)"
argument_list|,
literal|"KEYWORD(TRANSLATE)"
argument_list|,
literal|"KEYWORD(TRIM)"
argument_list|,
literal|"KEYWORD(TRUE)"
argument_list|,
literal|"KEYWORD(TRUNCATE)"
argument_list|,
literal|"KEYWORD(UNKNOWN)"
argument_list|,
literal|"KEYWORD(UPPER)"
argument_list|,
literal|"KEYWORD(USER)"
argument_list|,
literal|"KEYWORD(VAR_POP)"
argument_list|,
literal|"KEYWORD(VAR_SAMP)"
argument_list|,
literal|"KEYWORD(YEAR)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|QUANTIFIERS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(ALL)"
argument_list|,
literal|"KEYWORD(ANY)"
argument_list|,
literal|"KEYWORD(SOME)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SELECT_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(ALL)"
argument_list|,
literal|"KEYWORD(DISTINCT)"
argument_list|,
literal|"KEYWORD(STREAM)"
argument_list|,
literal|"KEYWORD(*)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|ORDER_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(,)"
argument_list|,
literal|"KEYWORD(ASC)"
argument_list|,
literal|"KEYWORD(DESC)"
argument_list|,
literal|"KEYWORD(NULLS)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_COLUMNS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"COLUMN(ENAME)"
argument_list|,
literal|"COLUMN(JOB)"
argument_list|,
literal|"COLUMN(MGR)"
argument_list|,
literal|"COLUMN(HIREDATE)"
argument_list|,
literal|"COLUMN(SAL)"
argument_list|,
literal|"COLUMN(COMM)"
argument_list|,
literal|"COLUMN(DEPTNO)"
argument_list|,
literal|"COLUMN(SLACKER)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_COLUMNS_E
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"COLUMN(ENAME)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|DEPT_COLUMNS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(DEPTNO)"
argument_list|,
literal|"COLUMN(NAME)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|PREDICATE_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(*)"
argument_list|,
literal|"KEYWORD(+)"
argument_list|,
literal|"KEYWORD(-)"
argument_list|,
literal|"KEYWORD(.)"
argument_list|,
literal|"KEYWORD(/)"
argument_list|,
literal|"KEYWORD(%)"
argument_list|,
literal|"KEYWORD(<)"
argument_list|,
literal|"KEYWORD(<=)"
argument_list|,
literal|"KEYWORD(<>)"
argument_list|,
literal|"KEYWORD(!=)"
argument_list|,
literal|"KEYWORD(=)"
argument_list|,
literal|"KEYWORD(>)"
argument_list|,
literal|"KEYWORD(>=)"
argument_list|,
literal|"KEYWORD(AND)"
argument_list|,
literal|"KEYWORD(BETWEEN)"
argument_list|,
literal|"KEYWORD(CONTAINS)"
argument_list|,
literal|"KEYWORD(EQUALS)"
argument_list|,
literal|"KEYWORD(IMMEDIATELY)"
argument_list|,
literal|"KEYWORD(IN)"
argument_list|,
literal|"KEYWORD(IS)"
argument_list|,
literal|"KEYWORD(LIKE)"
argument_list|,
literal|"KEYWORD(MEMBER)"
argument_list|,
literal|"KEYWORD(MULTISET)"
argument_list|,
literal|"KEYWORD(NOT)"
argument_list|,
literal|"KEYWORD(OR)"
argument_list|,
literal|"KEYWORD(OVERLAPS)"
argument_list|,
literal|"KEYWORD(PRECEDES)"
argument_list|,
literal|"KEYWORD(SIMILAR)"
argument_list|,
literal|"KEYWORD(SUBMULTISET)"
argument_list|,
literal|"KEYWORD(SUCCEEDS)"
argument_list|,
literal|"KEYWORD([)"
argument_list|,
literal|"KEYWORD(||)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|WHERE_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(MINUS)"
argument_list|,
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(GROUP)"
argument_list|,
literal|"KEYWORD(HAVING)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|,
literal|"KEYWORD(WINDOW)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|A_TABLE
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(A)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|JOIN_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|,
literal|"KEYWORD(FULL)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(EXTEND)"
argument_list|,
literal|"KEYWORD(AS)"
argument_list|,
literal|"KEYWORD(USING)"
argument_list|,
literal|"KEYWORD(OUTER)"
argument_list|,
literal|"KEYWORD(RIGHT)"
argument_list|,
literal|"KEYWORD(GROUP)"
argument_list|,
literal|"KEYWORD(CROSS)"
argument_list|,
literal|"KEYWORD(,)"
argument_list|,
literal|"KEYWORD(NATURAL)"
argument_list|,
literal|"KEYWORD(INNER)"
argument_list|,
literal|"KEYWORD(HAVING)"
argument_list|,
literal|"KEYWORD(LEFT)"
argument_list|,
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(MATCH_RECOGNIZE)"
argument_list|,
literal|"KEYWORD(MINUS)"
argument_list|,
literal|"KEYWORD(JOIN)"
argument_list|,
literal|"KEYWORD(WINDOW)"
argument_list|,
literal|"KEYWORD(.)"
argument_list|,
literal|"KEYWORD(TABLESAMPLE)"
argument_list|,
literal|"KEYWORD(ON)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(WHERE)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SETOPS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(MINUS)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|EMPNO_EMP
init|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"TABLE(EMP)\n"
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|SqlAdvisorTest
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getFromKeywords
parameter_list|()
block|{
return|return
name|FROM_KEYWORDS
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSelectKeywords
parameter_list|()
block|{
return|return
name|SELECT_KEYWORDS
return|;
block|}
comment|/**    * Returns a list of the tables in the SALES schema. Derived classes with    * extended SALES schemas may override.    *    * @return list of tables in the SALES schema    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSalesTables
parameter_list|()
block|{
return|return
name|SALES_TABLES
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getJoinKeywords
parameter_list|()
block|{
return|return
name|JOIN_KEYWORDS
return|;
block|}
specifier|private
name|void
name|assertTokenizesTo
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|SqlSimpleParser
operator|.
name|Tokenizer
name|tokenizer
init|=
operator|new
name|SqlSimpleParser
operator|.
name|Tokenizer
argument_list|(
name|sql
argument_list|,
literal|"xxxxx"
argument_list|,
name|tester
operator|.
name|getFactory
argument_list|()
operator|.
name|getParserConfig
argument_list|()
operator|.
name|quoting
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|SqlSimpleParser
operator|.
name|Token
name|token
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|buf
operator|.
name|append
argument_list|(
name|token
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertHint
parameter_list|(
name|String
name|sql
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedLists
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|plus
argument_list|(
name|expectedLists
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expected
init|=
name|toString
argument_list|(
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|expectedList
argument_list|)
argument_list|)
decl_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks that a given SQL statement yields the expected set of completion    * hints.    *    * @param sql             SQL statement    * @param expectedResults Expected list of hints    * @throws Exception on error    */
specifier|protected
name|void
name|assertHint
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expectedResults
parameter_list|)
throws|throws
name|Exception
block|{
name|SqlAdvisor
name|advisor
init|=
name|tester
operator|.
name|getFactory
argument_list|()
operator|.
name|createAdvisor
argument_list|()
decl_stmt|;
name|SqlParserUtil
operator|.
name|StringAndPos
name|sap
init|=
name|SqlParserUtil
operator|.
name|findPos
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|results
init|=
name|advisor
operator|.
name|getCompletionHints
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|sap
operator|.
name|pos
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expectedResults
argument_list|,
name|convertCompletionHints
argument_list|(
name|results
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that a given SQL statement simplifies to the salesTables result.    *    * @param sql      SQL statement to simplify. The SQL statement must contain    *                 precisely one caret '^', which marks the location where    *                 completion is to occur.    * @param expected Expected result after simplification.    */
specifier|protected
name|void
name|assertSimplify
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|SqlAdvisor
name|advisor
init|=
name|tester
operator|.
name|getFactory
argument_list|()
operator|.
name|createAdvisor
argument_list|()
decl_stmt|;
name|SqlParserUtil
operator|.
name|StringAndPos
name|sap
init|=
name|SqlParserUtil
operator|.
name|findPos
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|String
name|actual
init|=
name|advisor
operator|.
name|simplifySql
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|sap
operator|.
name|cursor
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|String
name|sql
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedResults
parameter_list|)
block|{
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|null
argument_list|,
name|expectedResults
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|String
name|sql
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|replacements
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedResults
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|plus
argument_list|(
name|expectedResults
argument_list|)
decl_stmt|;
name|String
name|expected
init|=
name|toString
argument_list|(
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|expectedList
argument_list|)
argument_list|)
decl_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
literal|null
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expectedResults
parameter_list|,
name|String
name|expectedWord
parameter_list|)
block|{
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expectedResults
argument_list|,
name|expectedWord
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that a given SQL which may be invalid or incomplete simplifies    * itself and yields the salesTables set of completion hints. This is an    * integration test of {@link #assertHint} and {@link #assertSimplify}.    *    * @param sql             SQL statement    * @param expectedResults Expected list of hints    * @param expectedWord    Word that we expect to be replaced, or null if we    *                        don't care    */
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expectedResults
parameter_list|,
name|String
name|expectedWord
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|replacements
parameter_list|)
block|{
name|SqlAdvisor
name|advisor
init|=
name|tester
operator|.
name|getFactory
argument_list|()
operator|.
name|createAdvisor
argument_list|()
decl_stmt|;
name|SqlParserUtil
operator|.
name|StringAndPos
name|sap
init|=
name|SqlParserUtil
operator|.
name|findPos
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|String
index|[]
name|replaced
init|=
block|{
literal|null
block|}
decl_stmt|;
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|results
init|=
name|advisor
operator|.
name|getCompletionHints
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|sap
operator|.
name|cursor
argument_list|,
name|replaced
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Completion hints for "
operator|+
name|sql
argument_list|,
name|expectedResults
argument_list|,
name|convertCompletionHints
argument_list|(
name|results
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedWord
operator|!=
literal|null
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"replaced[0] for "
operator|+
name|sql
argument_list|,
name|expectedWord
argument_list|,
name|replaced
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNotNull
argument_list|(
name|replaced
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertReplacements
argument_list|(
name|sql
argument_list|,
name|replacements
argument_list|,
name|advisor
argument_list|,
name|replaced
index|[
literal|0
index|]
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assertReplacements
parameter_list|(
name|String
name|sql
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|replacements
parameter_list|,
name|SqlAdvisor
name|advisor
parameter_list|,
name|String
name|word
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|results
parameter_list|)
block|{
if|if
condition|(
name|replacements
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|missingReplacemenets
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|replacements
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlMoniker
name|result
range|:
name|results
control|)
block|{
name|String
name|id
init|=
name|result
operator|.
name|id
argument_list|()
decl_stmt|;
name|String
name|expectedReplacement
init|=
name|replacements
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedReplacement
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|missingReplacemenets
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|String
name|actualReplacement
init|=
name|advisor
operator|.
name|getReplacement
argument_list|(
name|result
argument_list|,
name|word
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|sql
operator|+
literal|", replacement of "
operator|+
name|word
operator|+
literal|" with "
operator|+
name|id
argument_list|,
name|expectedReplacement
argument_list|,
name|actualReplacement
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|missingReplacemenets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Assert
operator|.
name|fail
argument_list|(
literal|"Sql "
operator|+
name|sql
operator|+
literal|" did not produce replacement hints "
operator|+
name|missingReplacemenets
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertEquals
parameter_list|(
name|String
index|[]
name|actualResults
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedResults
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|plus
argument_list|(
name|expectedResults
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|uniqueResults
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|actualResult
range|:
name|actualResults
control|)
block|{
name|uniqueResults
operator|.
name|put
argument_list|(
name|actualResult
argument_list|,
name|actualResult
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|expectedList
operator|.
name|containsAll
argument_list|(
name|uniqueResults
operator|.
name|values
argument_list|()
argument_list|)
operator|&&
operator|(
name|expectedList
operator|.
name|size
argument_list|()
operator|==
name|uniqueResults
operator|.
name|values
argument_list|()
operator|.
name|size
argument_list|()
operator|)
operator|)
condition|)
block|{
name|fail
argument_list|(
literal|"SqlAdvisorTest: completion hints results not as salesTables:\n"
operator|+
name|uniqueResults
operator|.
name|values
argument_list|()
operator|+
literal|"\nExpected:\n"
operator|+
name|expectedList
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|convertCompletionHints
parameter_list|(
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hints
parameter_list|)
block|{
if|if
condition|(
name|hints
operator|==
literal|null
condition|)
block|{
return|return
literal|"<<NULL>>"
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlMoniker
name|hint
range|:
name|hints
control|)
block|{
if|if
condition|(
name|hint
operator|.
name|getType
argument_list|()
operator|!=
name|SqlMonikerType
operator|.
name|FUNCTION
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|hint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|toString
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**    * Converts a list to a string, one item per line.    *    * @param list List    * @return String with one item of the list per line    */
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|toString
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|list
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|t
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlTester
name|getTester
parameter_list|()
block|{
return|return
operator|new
name|SqlTesterImpl
argument_list|(
name|ADVISOR_TEST_FACTORY
argument_list|)
return|;
block|}
comment|/**    * Concatenates several lists of the same type into a single list.    *    * @param lists Lists to concatenate    * @return Sum list    */
specifier|protected
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|plus
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
modifier|...
name|lists
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|T
argument_list|>
name|list
range|:
name|lists
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFrom
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from ^dummy a, sales.dummy b"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from ^, sales.dummy b"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from ^a"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a, ^sales.dummy b"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFromComplete
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select a.empno, b.deptno from dummy a, sales.^"
decl_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGroup
parameter_list|()
block|{
comment|// This test is hard because the statement is not valid if you replace
comment|// '^' with a dummy identifier.
name|String
name|sql
init|=
literal|"select a.empno, b.deptno from emp group ^"
decl_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(BY)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^dummy a join sales.dummy b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^ a join sales.dummy b"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// REVIEW: because caret is before 'sales', should it ignore schema
comment|// name and present all schemas and all tables in the default schema?
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join ^sales.dummy b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ on"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
comment|// unfortunately cannot complete this case: syntax is too broken
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ on a.deptno="
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|QUANTIFIERS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// join
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoinKeywords
parameter_list|()
block|{
comment|// variety of keywords possible
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|getJoinKeywords
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select * from dummy join sales.emp ^"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
literal|"SELECT * FROM dummy JOIN sales.emp _suggest_"
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOnCondition
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on ^a.deptno=b.dummy where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// on left
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
comment|// on left
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=^b.dummy where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|QUANTIFIERS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// on right
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.^ where empno=1"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// on right
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// on right
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFromWhere
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where b.deptno=^a.dummy"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|QUANTIFIERS
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where b.deptno=a.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(COMM)"
argument_list|,
literal|"COMM"
argument_list|)
argument_list|,
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where b.deptno=a.e^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(ENAME)"
argument_list|,
literal|"ename"
argument_list|)
argument_list|,
name|EMP_COLUMNS_E
argument_list|)
expr_stmt|;
comment|// where list
comment|// hints contain no columns, only table aliases, because there are>1
comment|// aliases
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^dummy=1"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(CURRENT_TIMESTAMP)"
argument_list|,
literal|"CURRENT_TIMESTAMP"
argument_list|)
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// where list
comment|// If there's only one table alias, we allow both the alias and the
comment|// unqualified columns
name|assertComplete
argument_list|(
literal|"select a.empno, a.deptno from sales.emp a "
operator|+
literal|"where ^"
argument_list|,
name|A_TABLE
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWhereList
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^a.dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where a.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where a.empno ^ "
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|PREDICATE_KEYWORDS
argument_list|,
name|WHERE_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectList
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select ^dummy, b.dummy from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (values (1))"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EXPR$0)"
argument_list|,
literal|"COLUMN(EXPR$0)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (values (1)) as t(c)"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(T)"
argument_list|,
literal|"COLUMN(C)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^, b.dummy from sales.emp a join sales.dept b "
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|SETOPS
argument_list|,
name|AB_TABLES
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, ^b.dummy from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|STAR_KEYWORD
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a join sales.dept b on true"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|STAR_KEYWORD
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// REVIEW: Since 'b' is not a valid alias, should it suggest anything?
comment|// We don't get through validation, so the only suggestion, '*', comes
comment|// from the parser.
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^emp.dummy from sales.emp"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EMP)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.^ from sales.emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrderByList
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^dummy"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EMP_TABLE
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EMP_TABLE
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno\n"
operator|+
literal|"from sales.emp as e(\n"
operator|+
literal|"  mpno,name,ob,gr,iredate,al,omm,eptno,lacker)\n"
operator|+
literal|"where e.mpno=1 order by ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(MPNO)"
argument_list|,
literal|"COLUMN(NAME)"
argument_list|,
literal|"COLUMN(OB)"
argument_list|,
literal|"COLUMN(GR)"
argument_list|,
literal|"COLUMN(IREDATE)"
argument_list|,
literal|"COLUMN(AL)"
argument_list|,
literal|"COLUMN(OMM)"
argument_list|,
literal|"COLUMN(EPTNO)"
argument_list|,
literal|"COLUMN(LACKER)"
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(E)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by empno ^, deptno"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|PREDICATE_KEYWORDS
argument_list|,
name|ORDER_KEYWORDS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSubQuery
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|xyColumns
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(X)"
argument_list|,
literal|"COLUMN(Y)"
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tTable
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(T)"
argument_list|)
decl_stmt|;
name|sql
operator|=
literal|"select ^t.dummy from (select 1 as x, 2 as y from sales.emp) as t where t.dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|xyColumns
argument_list|,
name|tTable
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales.emp) as t"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|xyColumns
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.emp) as t where ^t.dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.emp) as t where t.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.emp) as t where ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
comment|// with extra from item, aliases are ambiguous, so columns are not
comment|// offered
name|sql
operator|=
literal|"select a.x from (select 1 as x, 2 as y from sales.emp) as a, dept as b where ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// note that we get hints even though there's a syntax error in
comment|// select clause ('t.')
name|sql
operator|=
literal|"select t. from (select 1 as x, 2 as y from (select x from sales.emp)) as t where ^"
expr_stmt|;
name|String
name|simplified
init|=
literal|"SELECT * FROM ( SELECT 0 AS x , 0 AS y FROM ( SELECT 0 AS x FROM sales.emp ) ) as t WHERE _suggest_"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.^) as t"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSubQueryInWhere
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
comment|// Aliases from enclosing sub-queries are inherited: hence A from
comment|// enclosing, B from same scope.
comment|// The raw columns from dept are suggested (because they can
comment|// be used unqualified in the inner scope) but the raw
comment|// columns from emp are not (because they would need to be qualified
comment|// with A).
name|sql
operator|=
literal|"select * from sales.emp a where deptno in ("
operator|+
literal|"select * from sales.dept b where ^)"
expr_stmt|;
name|String
name|simplifiedSql
init|=
literal|"SELECT * FROM sales.emp a WHERE deptno in ("
operator|+
literal|" SELECT * FROM sales.dept b WHERE _suggest_ )"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplifiedSql
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|DEPT_COLUMNS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParserTokenizer
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select"
operator|+
literal|" 12"
operator|+
literal|" "
operator|+
literal|"*"
operator|+
literal|" 1.23e45"
operator|+
literal|" "
operator|+
literal|"("
operator|+
literal|"\"an id\""
operator|+
literal|","
operator|+
literal|" "
operator|+
literal|"\"an id with \"\"quotes' inside\""
operator|+
literal|","
operator|+
literal|" "
operator|+
literal|"/* a comment, with 'quotes', over\nmultiple lines\nand select keyword */"
operator|+
literal|"\n "
operator|+
literal|"("
operator|+
literal|" "
operator|+
literal|"a"
operator|+
literal|" "
operator|+
literal|"different"
operator|+
literal|" "
operator|+
literal|"// comment\n\r"
operator|+
literal|"//and a comment /* containing comment */ and then some more\r"
operator|+
literal|")"
operator|+
literal|" "
operator|+
literal|"from"
operator|+
literal|" "
operator|+
literal|"t"
operator|+
literal|")"
operator|+
literal|")"
operator|+
literal|"/* a comment after close paren */"
operator|+
literal|" "
operator|+
literal|"("
operator|+
literal|"'quoted'"
operator|+
literal|" "
operator|+
literal|"'string with ''single and \"double\"\" quote'"
operator|+
literal|")"
decl_stmt|;
name|String
name|expected
init|=
literal|"SELECT\n"
operator|+
literal|"ID(12)\n"
operator|+
literal|"ID(*)\n"
operator|+
literal|"ID(1.23e45)\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"DQID(\"an id\")\n"
operator|+
literal|"COMMA\n"
operator|+
literal|"DQID(\"an id with \"\"quotes' inside\")\n"
operator|+
literal|"COMMA\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"ID(a)\n"
operator|+
literal|"ID(different)\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"FROM\n"
operator|+
literal|"ID(t)\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"SQID('quoted')\n"
operator|+
literal|"SQID('string with ''single and \"double\"\" quote')\n"
operator|+
literal|"RPAREN\n"
decl_stmt|;
name|assertTokenizesTo
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// Tokenizer should be lenient if input ends mid-token
name|assertTokenizesTo
argument_list|(
literal|"select /* unfinished comment"
argument_list|,
literal|"SELECT\nCOMMENT\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"select // unfinished comment"
argument_list|,
literal|"SELECT\nCOMMENT\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"'starts with string'"
argument_list|,
literal|"SQID('starts with string')\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"'unfinished string"
argument_list|,
literal|"SQID('unfinished string)\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"\"unfinished double-quoted id"
argument_list|,
literal|"DQID(\"unfinished double-quoted id)\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"123"
argument_list|,
literal|"ID(123)\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParser
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
name|String
name|expected
decl_stmt|;
comment|// from
name|sql
operator|=
literal|"select * from ^where"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// select list
name|sql
operator|=
literal|"select ^ from (values (1))"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM ( values ( 1 ) )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.^ from sales.emp"
expr_stmt|;
name|expected
operator|=
literal|"SELECT emp. _suggest_ FROM sales.emp"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^from sales.emp"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// remove other expressions in select clause
name|sql
operator|=
literal|"select a.empno ,^  from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^, a.empno from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT b. _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join ^on where empno=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM dummy a JOIN _suggest_ ON TRUE"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ where empno=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM dummy a JOIN sales. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// on
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a JOIN sales.dept b "
operator|+
literal|"ON a.deptno= _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// where
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a , sales.dept b WHERE _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// order by
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT emp.empno FROM sales.emp ORDER BY _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// sub-query in from
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales.emp) as t "
operator|+
literal|"where t.dummy=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT t. _suggest_ "
operator|+
literal|"FROM ( SELECT 0 AS x , 0 AS y FROM sales.emp ) as t"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t. from (select 1 as x, 2 as y from "
operator|+
literal|"(select x from sales.emp)) as t where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT 0 AS x , 0 AS y FROM "
operator|+
literal|"( SELECT 0 AS x FROM sales.emp ) ) as t WHERE _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^from (select 1 as x, 2 as y from sales.emp), "
operator|+
literal|"(select 2 as y from (select m from n where)) as t "
operator|+
literal|"where t.dummy=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM ( SELECT 0 AS x , 0 AS y FROM sales.emp ) "
operator|+
literal|", ( SELECT 0 AS y FROM ( SELECT 0 AS m FROM n ) ) as t"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// Note: completes the missing close paren; wipes out select clause of
comment|// both outer and inner queries since not relevant.
name|sql
operator|=
literal|"select t.x from ( select 1 as x, 2 as y from sales.^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT * FROM sales. _suggest_ )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales)"
expr_stmt|;
name|expected
operator|=
literal|"SELECT t. _suggest_ FROM ( SELECT 0 AS x , 0 AS y FROM sales )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// sub-query in where; note that:
comment|// 1. removes the SELECT clause of sub-query in WHERE clause;
comment|// 2. keeps SELECT clause of sub-query in FROM clause;
comment|// 3. removes GROUP BY clause of sub-query in FROM clause;
comment|// 4. removes SELECT clause of outer query.
name|sql
operator|=
literal|"select x + y + 32 from "
operator|+
literal|"(select 1 as x, 2 as y from sales group by invalid stuff) as t "
operator|+
literal|"where x in (select deptno from emp where foo + t.^< 10)"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT 0 AS x , 0 AS y FROM sales ) as t "
operator|+
literal|"WHERE x in ( SELECT * FROM emp WHERE foo + t. _suggest_< 10 )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// if hint is in FROM, can remove other members of FROM clause
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a, sales.^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// function
name|sql
operator|=
literal|"select count(1) from sales.emp a where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a WHERE _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select count(1) from sales.emp a "
operator|+
literal|"where substring(a.^ FROM 3 for 6) = '1234'"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a "
operator|+
literal|"WHERE substring ( a. _suggest_ FROM 3 for 6 ) = '1234'"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// missing ')' following sub-query
name|sql
operator|=
literal|"select * from sales.emp a where deptno in ("
operator|+
literal|"select * from sales.dept b where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a WHERE deptno in ("
operator|+
literal|" SELECT * FROM sales.dept b WHERE _suggest_ )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// keyword embedded in single and double quoted string should be
comment|// ignored
name|sql
operator|=
literal|"select 'a cat from a king' as foobar, 1 / 2 \"where\" from t "
operator|+
literal|"group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"select /* here is from */ 'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"select // here is from clause\n 'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"select -- here is from clause\n 'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"-- test test \nselect -- here is from \n 'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|WithLex
argument_list|(
name|Lex
operator|.
name|SQL_SERVER
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParserQuotedIdSqlServer
parameter_list|()
block|{
name|testSimpleParserQuotedIdImpl
argument_list|()
expr_stmt|;
block|}
annotation|@
name|WithLex
argument_list|(
name|Lex
operator|.
name|MYSQL
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParserQuotedIdMySql
parameter_list|()
block|{
name|testSimpleParserQuotedIdImpl
argument_list|()
expr_stmt|;
block|}
annotation|@
name|WithLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParserQuotedIdJava
parameter_list|()
block|{
name|testSimpleParserQuotedIdImpl
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParserQuotedIdDefault
parameter_list|()
block|{
name|testSimpleParserQuotedIdImpl
argument_list|()
expr_stmt|;
block|}
specifier|private
name|String
name|replaceQuotes
parameter_list|(
name|SqlParser
operator|.
name|Config
name|parserConfig
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|char
name|openQuote
init|=
name|parserConfig
operator|.
name|quoting
argument_list|()
operator|.
name|string
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
name|closeQuote
init|=
name|openQuote
operator|==
literal|'['
condition|?
literal|']'
else|:
name|openQuote
decl_stmt|;
return|return
name|sql
operator|.
name|replace
argument_list|(
literal|'['
argument_list|,
name|openQuote
argument_list|)
operator|.
name|replace
argument_list|(
literal|']'
argument_list|,
name|closeQuote
argument_list|)
return|;
block|}
specifier|private
name|void
name|testSimpleParserQuotedIdImpl
parameter_list|()
block|{
name|SqlParser
operator|.
name|Config
name|parserConfig
init|=
name|tester
operator|.
name|getFactory
argument_list|()
operator|.
name|getParserConfig
argument_list|()
decl_stmt|;
name|String
name|sql
decl_stmt|;
name|String
name|expected
decl_stmt|;
comment|// unclosed double-quote
name|sql
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"select * from t where [^"
argument_list|)
expr_stmt|;
name|expected
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"SELECT * FROM t WHERE _suggest_"
argument_list|)
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// closed double-quote
name|sql
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"select * from t where [^] and x = y"
argument_list|)
expr_stmt|;
name|expected
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"SELECT * FROM t WHERE _suggest_ and x = y"
argument_list|)
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// closed double-quote containing extra stuff
name|sql
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"select * from t where [^foo] and x = y"
argument_list|)
expr_stmt|;
name|expected
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"SELECT * FROM t WHERE _suggest_ and x = y"
argument_list|)
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// escaped double-quote containing extra stuff
name|sql
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"select * from t where [^f]]oo] and x = y"
argument_list|)
expr_stmt|;
name|expected
operator|=
name|replaceQuotes
argument_list|(
name|parserConfig
argument_list|,
literal|"SELECT * FROM t WHERE _suggest_ and x = y"
argument_list|)
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPartialIdentifier
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select * from emp where e^ and emp.deptno = 10"
decl_stmt|;
name|String
name|expected
init|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"COLUMN(ENAME)\n"
operator|+
literal|"KEYWORD(ELEMENT)\n"
operator|+
literal|"KEYWORD(EXISTS)\n"
operator|+
literal|"KEYWORD(EXP)\n"
operator|+
literal|"KEYWORD(EXTRACT)\n"
operator|+
literal|"TABLE(EMP)\n"
decl_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
literal|"e"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"exists"
argument_list|,
literal|"TABLE(EMP)"
argument_list|,
literal|"emp"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from emp where \"e^ and emp.deptno = 10"
expr_stmt|;
name|expected
operator|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"COLUMN(ENAME)\n"
operator|+
literal|"KEYWORD(ELEMENT)\n"
operator|+
literal|"KEYWORD(EXISTS)\n"
operator|+
literal|"KEYWORD(EXP)\n"
operator|+
literal|"KEYWORD(EXTRACT)\n"
operator|+
literal|"TABLE(EMP)\n"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
literal|"\"e"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"exists"
argument_list|,
literal|"TABLE(EMP)"
argument_list|,
literal|"\"EMP\""
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from emp where E^ and emp.deptno = 10"
expr_stmt|;
name|expected
operator|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"COLUMN(ENAME)\n"
operator|+
literal|"KEYWORD(ELEMENT)\n"
operator|+
literal|"KEYWORD(EXISTS)\n"
operator|+
literal|"KEYWORD(EXP)\n"
operator|+
literal|"KEYWORD(EXTRACT)\n"
operator|+
literal|"TABLE(EMP)\n"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
literal|"E"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"EXISTS"
argument_list|,
literal|"TABLE(EMP)"
argument_list|,
literal|"EMP"
argument_list|)
argument_list|)
expr_stmt|;
comment|// cursor in middle of word and at end
name|sql
operator|=
literal|"select * from emp where e^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// longer completion
name|sql
operator|=
literal|"select * from emp where em^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|null
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"empno"
argument_list|)
argument_list|)
expr_stmt|;
comment|// word after punctuation
name|sql
operator|=
literal|"select deptno,em^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|null
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"empno"
argument_list|)
argument_list|)
expr_stmt|;
comment|// inside double-quotes, no terminating double-quote.
comment|// Only identifiers should be suggested (no keywords),
comment|// and suggestion should include double-quotes
name|sql
operator|=
literal|"select deptno,\"EM^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"\"EMPNO\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// inside double-quotes, match is case-insensitive as well
name|sql
operator|=
literal|"select deptno,\"em^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|"\"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"\"EMPNO\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// when input strings has mixed casing, match should be case-sensitive
name|sql
operator|=
literal|"select deptno,eM^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|"eM"
argument_list|)
expr_stmt|;
comment|// when input strings has mixed casing, match should be case-sensitive
name|sql
operator|=
literal|"select deptno,\"eM^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|"\"eM"
argument_list|)
expr_stmt|;
comment|// eat up following double-quote
name|sql
operator|=
literal|"select deptno,\"EM^ps\" from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"\"EMPNO\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// closing double-quote is at very end of string
name|sql
operator|=
literal|"select * from emp where 5 = \"EM^xxx\""
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"\"EMPNO\""
argument_list|)
argument_list|)
expr_stmt|;
comment|// just before dot
name|sql
operator|=
literal|"select emp.^name from emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|WithLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
specifier|public
name|void
name|testAdviceKeywordsJava
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select deptno, exi^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"KEYWORD(EXISTS)\n"
argument_list|,
literal|"exi"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"exists"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|WithLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
specifier|public
name|void
name|testAdviceMixedCase
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select is^ from (select 1 isOne from emp)"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"COLUMN(isOne)\n"
argument_list|,
literal|"is"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(isOne)"
argument_list|,
literal|"isOne"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|WithLex
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
specifier|public
name|void
name|testAdviceEmptyFrom
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select * from^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"KEYWORD(FROM)\n"
argument_list|,
literal|"from"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"KEYWORD(FROM)"
argument_list|,
literal|"from"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInsert
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"insert into emp(empno, mgr) select ^ from dept a"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|A_TABLE
argument_list|,
name|DEPT_COLUMNS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"insert into emp(empno, mgr) values (123, 3 + ^)"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// Wish we could do better here. Parser gives error 'Non-query
comment|// expression encountered in illegal context' and cannot suggest
comment|// possible tokens.
name|sql
operator|=
literal|"insert into emp(empno, mgr) ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNestSchema
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select * from sales.n^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"n"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"nest"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from sales.\"n^asfasdf"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"\"n"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"\"NEST\""
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from sales.n^est"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"n"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"nest"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from sales.nu^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|"nu"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"The set of completion results is empty"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testNestTable1
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
comment|// select scott.emp.deptno from scott.emp; # valid
name|sql
operator|=
literal|"select catalog.sales.emp.em^ from catalog.sales.emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"COLUMN(EMPNO)\n"
argument_list|,
literal|"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"empno"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select catalog.sales.em^ from catalog.sales.emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"TABLE(EMP)\n"
argument_list|,
literal|"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"TABLE(EMP)"
argument_list|,
literal|"emp"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNestTable2
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
comment|// select scott.emp.deptno from scott.emp as e; # not valid
name|sql
operator|=
literal|"select catalog.sales.emp.em^ from catalog.sales.emp as e"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|"em"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"The set of completion results is empty"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testNestTable3
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
comment|// select scott.emp.deptno from emp; # valid
name|sql
operator|=
literal|"select catalog.sales.emp.em^ from emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"COLUMN(EMPNO)\n"
argument_list|,
literal|"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"COLUMN(EMP)"
argument_list|,
literal|"empno"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select catalog.sales.em^ from emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"TABLE(EMP)\n"
argument_list|,
literal|"em"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"TABLE(EMP)"
argument_list|,
literal|"emp"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNestTable4
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
comment|// select scott.emp.deptno from emp as emp; # not valid
name|sql
operator|=
literal|"select catalog.sales.emp.em^ from catalog.sales.emp as emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|"em"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNestTableSchemaMustMatch
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
comment|// select foo.emp.deptno from emp; # not valid
name|sql
operator|=
literal|"select sales.nest.em^ from catalog.sales.emp_r"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|"em"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|WithLex
argument_list|(
name|Lex
operator|.
name|SQL_SERVER
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testNestSchemaSqlServer
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select * from SALES.N^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"N"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"NEST"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from SALES.[n^asfasdf"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"[n"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"[NEST]"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from SALES.[N^est"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|"SCHEMA(CATALOG.SALES.NEST)\n"
argument_list|,
literal|"[N"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"SCHEMA(CATALOG.SALES.NEST)"
argument_list|,
literal|"[NEST]"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select * from SALES.NU^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|"NU"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnion
parameter_list|()
throws|throws
name|Exception
block|{
comment|// we simplify set ops such as UNION by removing other queries -
comment|// thereby avoiding validation errors due to mismatched select lists
name|String
name|sql
init|=
literal|"select 1 from emp union select 2 from dept a where ^ and deptno< 5"
decl_stmt|;
name|String
name|simplified
init|=
literal|"SELECT * FROM dept a WHERE _suggest_ and deptno< 5"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|A_TABLE
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// UNION ALL
name|sql
operator|=
literal|"select 1 from emp union all select 2 from dept a where ^ and deptno< 5"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
comment|// hint is in first query
name|sql
operator|=
literal|"select 1 from emp group by ^ except select 2 from dept a"
expr_stmt|;
name|simplified
operator|=
literal|"SELECT * FROM emp GROUP BY _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
block|}
annotation|@
name|WithLex
argument_list|(
name|Lex
operator|.
name|SQL_SERVER
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testMssql
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select 1 from [emp] union select 2 from [DEPT] a where ^ and deptno< 5"
decl_stmt|;
name|String
name|simplified
init|=
literal|"SELECT * FROM [DEPT] a WHERE _suggest_ and deptno< 5"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(a)"
argument_list|)
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// End SqlAdvisorTest.java
end_comment

end_unit

