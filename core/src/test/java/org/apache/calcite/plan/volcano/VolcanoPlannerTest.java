begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Convention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ConventionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|convert
operator|.
name|ConverterImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|convert
operator|.
name|ConverterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|externalize
operator|.
name|RelDotWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CoreRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Disabled
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|AssertOperandsDifferentRule
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|GoodSingleRule
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|NoneLeafRel
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|NoneSingleRel
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|PHYS_CALLING_CONVENTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|PHYS_CALLING_CONVENTION_2
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|PHYS_CALLING_CONVENTION_3
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|PhysBiRel
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|PhysLeafRel
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|PhysLeafRule
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|PhysSingleRel
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|TestSingleRel
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|PlannerTests
operator|.
name|newCluster
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|isLinux
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNotSame
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertSame
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertTrue
import|;
end_import

begin_comment
comment|/**  * Unit test for {@link VolcanoPlanner the optimizer}.  */
end_comment

begin_class
class|class
name|VolcanoPlannerTest
block|{
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Tests transformation of a leaf from NONE to PHYS.    */
annotation|@
name|Test
name|void
name|testTransformLeaf
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|leafRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysLeafRel
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests transformation of a single+leaf from NONE to PHYS.    */
annotation|@
name|Test
name|void
name|testTransformSingleGood
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|GoodSingleRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|NoneSingleRel
name|singleRel
init|=
operator|new
name|NoneSingleRel
argument_list|(
name|cluster
argument_list|,
name|leafRel
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|singleRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysSingleRel
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPlanToDot
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|NoneSingleRel
name|singleRel
init|=
operator|new
name|NoneSingleRel
argument_list|(
name|cluster
argument_list|,
name|leafRel
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|singleRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|StringWriter
name|sw
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|sw
argument_list|)
decl_stmt|;
name|RelDotWriter
name|planWriter
init|=
operator|new
name|RelDotWriter
argument_list|(
name|pw
argument_list|,
name|SqlExplainLevel
operator|.
name|NO_ATTRIBUTES
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|planner
operator|.
name|getRoot
argument_list|()
operator|.
name|explain
argument_list|(
name|planWriter
argument_list|)
expr_stmt|;
name|String
name|planStr
init|=
name|sw
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|planStr
argument_list|,
name|isLinux
argument_list|(
literal|"digraph {\n"
operator|+
literal|"\"NoneLeafRel\\n\" -> \"NoneSingleRel\\n\" [label=\"0\"]\n"
operator|+
literal|"}\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3118">[CALCITE-3118]    * VolcanoRuleCall should look at RelSubset rather than RelSet    * when checking child ordinal of a parent operand</a>. */
annotation|@
name|Test
name|void
name|testMatchedOperandsDifferent
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
comment|// The rule that triggers the assert rule
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// The rule asserting that the matched operands are different
name|planner
operator|.
name|addRule
argument_list|(
name|AssertOperandsDifferentRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// Construct two children in the same set and a parent RelNode
name|NoneLeafRel
name|leftRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|RelNode
name|leftPhy
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|leftRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|PhysLeafRel
name|rightPhy
init|=
operator|new
name|PhysLeafRel
argument_list|(
name|cluster
argument_list|,
name|PHYS_CALLING_CONVENTION_2
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|PhysBiRel
name|parent
init|=
operator|new
name|PhysBiRel
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|,
name|leftPhy
argument_list|,
name|rightPhy
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// Make sure both RelNodes are in the same set, but different subset
name|planner
operator|.
name|ensureRegistered
argument_list|(
name|leftPhy
argument_list|,
name|rightPhy
argument_list|)
expr_stmt|;
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
block|}
comment|/**    * A pattern that matches a three input union with third child matching for    * a PhysLeafRel node.    */
specifier|public
specifier|static
class|class
name|ThreeInputsUnionRule
extends|extends
name|RelRule
argument_list|<
name|ThreeInputsUnionRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
specifier|final
name|ThreeInputsUnionRule
name|INSTANCE
init|=
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|EnumerableUnion
operator|.
name|class
argument_list|)
operator|.
name|inputs
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|PhysBiRel
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|,
name|b2
lambda|->
name|b2
operator|.
name|operand
argument_list|(
name|PhysBiRel
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|,
name|b3
lambda|->
name|b3
operator|.
name|operand
argument_list|(
name|PhysLeafRel
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
name|ThreeInputsUnionRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|ThreeInputsUnionRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|ThreeInputsUnionRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|Test
name|void
name|testMultiInputsParentOpMatching
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
comment|// The trigger rule that generates PhysLeafRel from NoneLeafRel
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// The rule with third child op matching PhysLeafRel, which should not be
comment|// matched at all
name|planner
operator|.
name|addRule
argument_list|(
name|ThreeInputsUnionRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// Construct a union with only two children
name|NoneLeafRel
name|leftRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|RelNode
name|leftPhy
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|leftRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|PhysLeafRel
name|rightPhy
init|=
operator|new
name|PhysLeafRel
argument_list|(
name|cluster
argument_list|,
name|PHYS_CALLING_CONVENTION
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
operator|new
name|EnumerableUnion
argument_list|(
name|cluster
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|leftPhy
argument_list|,
name|rightPhy
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests a rule that is fired once per subset. (Whereas most rules are fired    * once per rel in a set or rel in a subset.)    */
annotation|@
name|Test
name|void
name|testSubsetRule
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|GoodSingleRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|SubsetRule
operator|.
name|config
argument_list|(
name|buf
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|NoneSingleRel
name|singleRel
init|=
operator|new
name|NoneSingleRel
argument_list|(
name|cluster
argument_list|,
name|leafRel
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|singleRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|changeTraits
argument_list|(
name|leafRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
operator|.
name|plus
argument_list|(
name|RelCollations
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysSingleRel
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|sort
argument_list|(
name|buf
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|sort
argument_list|(
literal|"NoneSingleRel:RelSubset#0.NONE.[]"
argument_list|,
literal|"PhysSingleRel:RelSubset#0.PHYS.[0]"
argument_list|,
literal|"PhysSingleRel:RelSubset#0.PHYS.[]"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|sort
parameter_list|(
name|List
argument_list|<
name|E
argument_list|>
name|list
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|E
argument_list|>
name|list2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|list2
argument_list|)
expr_stmt|;
return|return
name|list2
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|E
extends|extends
name|Comparable
parameter_list|>
name|List
argument_list|<
name|E
argument_list|>
name|sort
parameter_list|(
name|E
modifier|...
name|es
parameter_list|)
block|{
return|return
name|sort
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|es
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Tests that VolcanoPlanner should fire rule match from subsets after a    * RelSet merge. The rules matching for a RelSubset should be able to fire    * on the subsets that are merged into the RelSets.    */
annotation|@
name|Test
name|void
name|testSetMergeMatchSubsetRule
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|GoodSingleRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysSingleInputSetMergeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysSingleSubsetRule
operator|.
name|config
argument_list|(
name|buf
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|NoneSingleRel
name|singleRel
init|=
operator|new
name|NoneSingleRel
argument_list|(
name|cluster
argument_list|,
name|leafRel
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|singleRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysSingleRel
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|sort
argument_list|(
name|buf
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|sort
argument_list|(
literal|"PhysSingleRel:RelSubset#0.PHYS.[]"
argument_list|,
literal|"PhysSingleRel:RelSubset#0.PHYS_3.[]"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests transformation of a single+leaf from NONE to PHYS. In the past,    * this one didn't work due to the definition of ReformedSingleRule.    */
annotation|@
name|Disabled
comment|// broken, because ReformedSingleRule matches child traits strictly
annotation|@
name|Test
name|void
name|testTransformSingleReformed
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|ReformedSingleRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|NoneSingleRel
name|singleRel
init|=
operator|new
name|NoneSingleRel
argument_list|(
name|cluster
argument_list|,
name|leafRel
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|singleRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysSingleRel
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|removeTrivialProject
parameter_list|(
name|boolean
name|useRule
parameter_list|)
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|useRule
condition|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REMOVE
argument_list|)
expr_stmt|;
block|}
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|GoodSingleRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysProjectRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysToIteratorRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|PhysLeafRel
name|leafRel
init|=
operator|new
name|PhysLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|leafRel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|projectRel
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|leafRel
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|alias
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"this"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|NoneSingleRel
name|singleRel
init|=
operator|new
name|NoneSingleRel
argument_list|(
name|cluster
argument_list|,
name|projectRel
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|singleRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysToIteratorConverter
argument_list|)
expr_stmt|;
block|}
comment|// NOTE:  this used to fail but now works
annotation|@
name|Test
name|void
name|testWithRemoveTrivialProject
parameter_list|()
block|{
name|removeTrivialProject
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// NOTE:  this always worked; it's here as contrast to
comment|// testWithRemoveTrivialProject()
annotation|@
name|Test
name|void
name|testWithoutRemoveTrivialProject
parameter_list|()
block|{
name|removeTrivialProject
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Previously, this didn't work because ReformedRemoveSingleRule uses a    * pattern which spans calling conventions.    */
annotation|@
name|Disabled
comment|// broken, because ReformedSingleRule matches child traits strictly
annotation|@
name|Test
name|void
name|testRemoveSingleReformed
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|ReformedRemoveSingleRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|NoneSingleRel
name|singleRel
init|=
operator|new
name|NoneSingleRel
argument_list|(
name|cluster
argument_list|,
name|leafRel
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|singleRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysLeafRel
argument_list|)
expr_stmt|;
name|PhysLeafRel
name|resultLeaf
init|=
operator|(
name|PhysLeafRel
operator|)
name|result
decl_stmt|;
name|assertEquals
argument_list|(
literal|"c"
argument_list|,
name|resultLeaf
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
comment|/**    * This always worked (in contrast to testRemoveSingleReformed) because it    * uses a completely-physical pattern (requiring GoodSingleRule to fire    * first).    */
annotation|@
name|Test
name|void
name|testRemoveSingleGood
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|GoodSingleRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|GoodRemoveSingleRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|NoneSingleRel
name|singleRel
init|=
operator|new
name|NoneSingleRel
argument_list|(
name|cluster
argument_list|,
name|leafRel
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|singleRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysLeafRel
argument_list|)
expr_stmt|;
name|PhysLeafRel
name|resultLeaf
init|=
operator|(
name|PhysLeafRel
operator|)
name|result
decl_stmt|;
name|assertEquals
argument_list|(
literal|"c"
argument_list|,
name|resultLeaf
operator|.
name|label
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testMergeJoin
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
comment|// Below two lines are important for the planner to use collation trait and generate merge join
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|registerAbstractRelationalRules
argument_list|()
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_VALUES_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|RelBuilder
name|relBuilder
init|=
name|RelFactories
operator|.
name|LOGICAL_BUILDER
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|logicalPlan
init|=
name|relBuilder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"id"
block|,
literal|"name"
block|}
argument_list|,
literal|"2"
argument_list|,
literal|"a"
argument_list|,
literal|"1"
argument_list|,
literal|"b"
argument_list|)
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"id"
block|,
literal|"name"
block|}
argument_list|,
literal|"1"
argument_list|,
literal|"x"
argument_list|,
literal|"2"
argument_list|,
literal|"y"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
literal|"id"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelTraitSet
name|desiredTraits
init|=
name|cluster
operator|.
name|traitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newRoot
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|logicalPlan
argument_list|,
name|desiredTraits
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|newRoot
argument_list|)
expr_stmt|;
name|RelNode
name|bestExp
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|plan
init|=
literal|""
operator|+
literal|"EnumerableMergeJoin(condition=[=($0, $2)], joinType=[inner])\n"
operator|+
literal|"  EnumerableSort(sort0=[$0], dir0=[ASC])\n"
operator|+
literal|"    EnumerableValues(tuples=[[{ '2', 'a' }, { '1', 'b' }]])\n"
operator|+
literal|"  EnumerableValues(tuples=[[{ '1', 'x' }, { '2', 'y' }]])\n"
decl_stmt|;
name|assertThat
argument_list|(
literal|"Merge join + sort is expected"
argument_list|,
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|bestExp
argument_list|)
argument_list|,
name|isLinux
argument_list|(
name|plan
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPruneNode
parameter_list|()
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|leafRel
argument_list|)
expr_stmt|;
comment|// prune the node
name|planner
operator|.
name|prune
argument_list|(
name|leafRel
argument_list|)
expr_stmt|;
comment|// verify that the rule match cannot be popped,
comment|// as the related node has been pruned
name|RuleQueue
name|ruleQueue
init|=
name|planner
operator|.
name|ruleDriver
operator|.
name|getRuleQueue
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|VolcanoRuleMatch
name|ruleMatch
decl_stmt|;
if|if
condition|(
name|ruleQueue
operator|instanceof
name|IterativeRuleQueue
condition|)
block|{
name|ruleMatch
operator|=
operator|(
operator|(
name|IterativeRuleQueue
operator|)
name|ruleQueue
operator|)
operator|.
name|popMatch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ruleMatch
operator|=
operator|(
operator|(
name|TopDownRuleQueue
operator|)
name|ruleQueue
operator|)
operator|.
name|popMatch
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|leafRel
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ruleMatch
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|assertNotSame
argument_list|(
name|leafRel
argument_list|,
name|ruleMatch
operator|.
name|rels
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tests whether planner correctly notifies listeners of events.    */
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testListener
parameter_list|()
block|{
name|TestListener
name|listener
init|=
operator|new
name|TestListener
argument_list|()
decl_stmt|;
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|PhysLeafRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptCluster
name|cluster
init|=
name|newCluster
argument_list|(
name|planner
argument_list|)
decl_stmt|;
name|NoneLeafRel
name|leafRel
init|=
operator|new
name|NoneLeafRel
argument_list|(
name|cluster
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|RelNode
name|convertedRel
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|leafRel
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|convertedRel
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|instanceof
name|PhysLeafRel
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelOptListener
operator|.
name|RelEvent
argument_list|>
name|eventList
init|=
name|listener
operator|.
name|getEventList
argument_list|()
decl_stmt|;
comment|// add node
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|0
argument_list|,
name|RelOptListener
operator|.
name|RelEquivalenceEvent
operator|.
name|class
argument_list|,
name|leafRel
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// internal subset
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|1
argument_list|,
name|RelOptListener
operator|.
name|RelEquivalenceEvent
operator|.
name|class
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// before rule
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|2
argument_list|,
name|RelOptListener
operator|.
name|RuleAttemptedEvent
operator|.
name|class
argument_list|,
name|leafRel
argument_list|,
name|PhysLeafRule
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// before rule
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|3
argument_list|,
name|RelOptListener
operator|.
name|RuleProductionEvent
operator|.
name|class
argument_list|,
name|result
argument_list|,
name|PhysLeafRule
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// result of rule
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|4
argument_list|,
name|RelOptListener
operator|.
name|RelEquivalenceEvent
operator|.
name|class
argument_list|,
name|result
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// after rule
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|5
argument_list|,
name|RelOptListener
operator|.
name|RuleProductionEvent
operator|.
name|class
argument_list|,
name|result
argument_list|,
name|PhysLeafRule
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// after rule
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|6
argument_list|,
name|RelOptListener
operator|.
name|RuleAttemptedEvent
operator|.
name|class
argument_list|,
name|leafRel
argument_list|,
name|PhysLeafRule
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// choose plan
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|7
argument_list|,
name|RelOptListener
operator|.
name|RelChosenEvent
operator|.
name|class
argument_list|,
name|result
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// finish choosing plan
name|checkEvent
argument_list|(
name|eventList
argument_list|,
literal|8
argument_list|,
name|RelOptListener
operator|.
name|RelChosenEvent
operator|.
name|class
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkEvent
parameter_list|(
name|List
argument_list|<
name|RelOptListener
operator|.
name|RelEvent
argument_list|>
name|eventList
parameter_list|,
name|int
name|iEvent
parameter_list|,
name|Class
name|expectedEventClass
parameter_list|,
name|RelNode
name|expectedRel
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|RelOptRule
argument_list|>
name|expectedRuleClass
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|iEvent
operator|<
name|eventList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|RelOptListener
operator|.
name|RelEvent
name|event
init|=
name|eventList
operator|.
name|get
argument_list|(
name|iEvent
argument_list|)
decl_stmt|;
name|assertSame
argument_list|(
name|expectedEventClass
argument_list|,
name|event
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedRel
operator|!=
literal|null
condition|)
block|{
name|assertSame
argument_list|(
name|expectedRel
argument_list|,
name|event
operator|.
name|getRel
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expectedRuleClass
operator|!=
literal|null
condition|)
block|{
name|RelOptListener
operator|.
name|RuleEvent
name|ruleEvent
init|=
operator|(
name|RelOptListener
operator|.
name|RuleEvent
operator|)
name|event
decl_stmt|;
name|assertSame
argument_list|(
name|expectedRuleClass
argument_list|,
name|ruleEvent
operator|.
name|getRuleCall
argument_list|()
operator|.
name|getRule
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Converter from PHYS to ENUMERABLE convention. */
specifier|static
class|class
name|PhysToIteratorConverter
extends|extends
name|ConverterImpl
block|{
name|PhysToIteratorConverter
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelNode
name|child
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|,
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelNode
name|copy
parameter_list|(
name|RelTraitSet
name|traitSet
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
parameter_list|)
block|{
assert|assert
name|traitSet
operator|.
name|comprises
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
assert|;
return|return
operator|new
name|PhysToIteratorConverter
argument_list|(
name|getCluster
argument_list|()
argument_list|,
name|sole
argument_list|(
name|inputs
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Rule that matches a {@link RelSubset}. */
specifier|public
specifier|static
class|class
name|SubsetRule
extends|extends
name|RelRule
argument_list|<
name|SubsetRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
name|Config
name|config
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|buf
parameter_list|)
block|{
return|return
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|TestSingleRel
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|RelSubset
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|withBuf
argument_list|(
name|buf
argument_list|)
return|;
block|}
specifier|protected
name|SubsetRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Convention
name|getOutConvention
parameter_list|()
block|{
return|return
name|PHYS_CALLING_CONVENTION
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
comment|// Do not transform to anything; just log the calls.
name|TestSingleRel
name|singleRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelSubset
name|childRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|rels
operator|.
name|length
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
name|config
operator|.
name|buf
argument_list|()
decl_stmt|;
name|buf
operator|.
name|add
argument_list|(
name|singleRel
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|":"
operator|+
name|childRel
operator|.
name|getDigest
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|SubsetRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|SubsetRule
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|ImmutableBeans
operator|.
name|Property
argument_list|(
name|makeImmutable
operator|=
literal|false
argument_list|)
name|List
argument_list|<
name|String
argument_list|>
name|buf
parameter_list|()
function_decl|;
comment|/** Sets {@link #buf()}. */
name|Config
name|withBuf
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|buf
parameter_list|)
function_decl|;
block|}
block|}
comment|/** Rule that matches a PhysSingle on a RelSubset. */
specifier|public
specifier|static
class|class
name|PhysSingleSubsetRule
extends|extends
name|RelRule
argument_list|<
name|PhysSingleSubsetRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
name|Config
name|config
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|buf
parameter_list|)
block|{
return|return
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|PhysSingleRel
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|RelSubset
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|withBuf
argument_list|(
name|buf
argument_list|)
return|;
block|}
specifier|protected
name|PhysSingleSubsetRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Convention
name|getOutConvention
parameter_list|()
block|{
return|return
name|PHYS_CALLING_CONVENTION
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|PhysSingleRel
name|singleRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelSubset
name|subset
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
name|config
operator|.
name|buf
argument_list|()
decl_stmt|;
name|buf
operator|.
name|add
argument_list|(
name|singleRel
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|":"
operator|+
name|subset
operator|.
name|getDigest
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|PhysSingleSubsetRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|PhysSingleSubsetRule
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|ImmutableBeans
operator|.
name|Property
argument_list|(
name|makeImmutable
operator|=
literal|false
argument_list|)
name|List
argument_list|<
name|String
argument_list|>
name|buf
parameter_list|()
function_decl|;
comment|/** Sets {@link #buf()}. */
name|Config
name|withBuf
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|buf
parameter_list|)
function_decl|;
block|}
block|}
comment|/** Creates an artificial RelSet merge in the PhysSingleRel's input RelSet. */
specifier|public
specifier|static
class|class
name|PhysSingleInputSetMergeRule
extends|extends
name|RelRule
argument_list|<
name|PhysSingleInputSetMergeRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
specifier|final
name|PhysSingleInputSetMergeRule
name|INSTANCE
init|=
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|PhysSingleRel
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|PhysLeafRel
operator|.
name|class
argument_list|)
operator|.
name|trait
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|protected
name|PhysSingleInputSetMergeRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|PhysSingleRel
name|singleRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|PhysLeafRel
name|input
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RelNode
name|newInput
init|=
operator|new
name|PhysLeafRel
argument_list|(
name|input
operator|.
name|getCluster
argument_list|()
argument_list|,
name|PHYS_CALLING_CONVENTION_3
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|VolcanoPlanner
name|planner
init|=
operator|(
name|VolcanoPlanner
operator|)
name|call
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
comment|// Register into a new RelSet first
name|planner
operator|.
name|ensureRegistered
argument_list|(
name|newInput
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Merge into the old RelSet
name|planner
operator|.
name|ensureRegistered
argument_list|(
name|newInput
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|PhysSingleInputSetMergeRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|PhysSingleInputSetMergeRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|// NOTE: Previously, ReformedSingleRule didn't work because it explicitly
comment|// specifies PhysLeafRel rather than RelNode for the single input.  Since
comment|// the PhysLeafRel is in a different subset from the original NoneLeafRel,
comment|// ReformedSingleRule never saw it.  (GoodSingleRule saw the NoneLeafRel
comment|// instead and fires off of that; later the NoneLeafRel gets converted into
comment|// a PhysLeafRel).  Now Volcano supports rules which match across subsets.
comment|/** Planner rule that matches a {@link NoneSingleRel} whose input is    * a {@link PhysLeafRel} in a different subset. */
specifier|public
specifier|static
class|class
name|ReformedSingleRule
extends|extends
name|RelRule
argument_list|<
name|ReformedSingleRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
specifier|final
name|ReformedSingleRule
name|INSTANCE
init|=
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|NoneSingleRel
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|PhysLeafRel
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|protected
name|ReformedSingleRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Convention
name|getOutConvention
parameter_list|()
block|{
return|return
name|PHYS_CALLING_CONVENTION
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|NoneSingleRel
name|singleRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|childRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|RelNode
name|physInput
init|=
name|convert
argument_list|(
name|childRel
argument_list|,
name|singleRel
operator|.
name|getTraitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|PHYS_CALLING_CONVENTION
argument_list|)
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
operator|new
name|PhysSingleRel
argument_list|(
name|singleRel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|physInput
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|ReformedSingleRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|ReformedSingleRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Planner rule that converts a {@link LogicalProject} to PHYS convention. */
specifier|public
specifier|static
class|class
name|PhysProjectRule
extends|extends
name|RelRule
argument_list|<
name|PhysProjectRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
specifier|final
name|PhysProjectRule
name|INSTANCE
init|=
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b
lambda|->
name|b
operator|.
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
name|PhysProjectRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Convention
name|getOutConvention
parameter_list|()
block|{
return|return
name|PHYS_CALLING_CONVENTION
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|LogicalProject
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|childRel
init|=
name|project
operator|.
name|getInput
argument_list|()
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
operator|new
name|PhysLeafRel
argument_list|(
name|childRel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|PhysProjectRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|PhysProjectRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Planner rule that successfully removes a {@link PhysSingleRel}. */
specifier|public
specifier|static
class|class
name|GoodRemoveSingleRule
extends|extends
name|RelRule
argument_list|<
name|GoodRemoveSingleRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
specifier|final
name|GoodRemoveSingleRule
name|INSTANCE
init|=
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|PhysSingleRel
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|PhysLeafRel
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|protected
name|GoodRemoveSingleRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Convention
name|getOutConvention
parameter_list|()
block|{
return|return
name|PHYS_CALLING_CONVENTION
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|PhysSingleRel
name|singleRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|PhysLeafRel
name|leafRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
operator|new
name|PhysLeafRel
argument_list|(
name|singleRel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|GoodRemoveSingleRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|GoodRemoveSingleRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Planner rule that removes a {@link NoneSingleRel}. */
specifier|public
specifier|static
class|class
name|ReformedRemoveSingleRule
extends|extends
name|RelRule
argument_list|<
name|ReformedRemoveSingleRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
specifier|final
name|ReformedRemoveSingleRule
name|INSTANCE
init|=
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|NoneSingleRel
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|PhysLeafRel
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|protected
name|ReformedRemoveSingleRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Convention
name|getOutConvention
parameter_list|()
block|{
return|return
name|PHYS_CALLING_CONVENTION
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|NoneSingleRel
name|singleRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|PhysLeafRel
name|leafRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
operator|new
name|PhysLeafRel
argument_list|(
name|singleRel
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|ReformedRemoveSingleRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|ReformedRemoveSingleRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Implementation of {@link RelOptListener}. */
specifier|private
specifier|static
class|class
name|TestListener
implements|implements
name|RelOptListener
block|{
specifier|private
name|List
argument_list|<
name|RelEvent
argument_list|>
name|eventList
decl_stmt|;
name|TestListener
parameter_list|()
block|{
name|eventList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|RelEvent
argument_list|>
name|getEventList
parameter_list|()
block|{
return|return
name|eventList
return|;
block|}
specifier|private
name|void
name|recordEvent
parameter_list|(
name|RelEvent
name|event
parameter_list|)
block|{
name|eventList
operator|.
name|add
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|relChosen
parameter_list|(
name|RelChosenEvent
name|event
parameter_list|)
block|{
name|recordEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|relDiscarded
parameter_list|(
name|RelDiscardedEvent
name|event
parameter_list|)
block|{
comment|// Volcano is quite a pack rat--it never discards anything!
throw|throw
operator|new
name|AssertionError
argument_list|(
name|event
argument_list|)
throw|;
block|}
specifier|public
name|void
name|relEquivalenceFound
parameter_list|(
name|RelEquivalenceEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|.
name|isPhysical
argument_list|()
condition|)
block|{
return|return;
block|}
name|recordEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|ruleAttempted
parameter_list|(
name|RuleAttemptedEvent
name|event
parameter_list|)
block|{
name|recordEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|ruleProductionSucceeded
parameter_list|(
name|RuleProductionEvent
name|event
parameter_list|)
block|{
name|recordEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that converts a physical RelNode to an iterator. */
specifier|private
specifier|static
class|class
name|PhysToIteratorRule
extends|extends
name|ConverterRule
block|{
specifier|static
specifier|final
name|PhysToIteratorRule
name|INSTANCE
init|=
name|Config
operator|.
name|INSTANCE
operator|.
name|withConversion
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|PlannerTests
operator|.
name|PHYS_CALLING_CONVENTION
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|,
literal|"PhysToIteratorRule"
argument_list|)
operator|.
name|withRuleFactory
argument_list|(
name|PhysToIteratorRule
operator|::
operator|new
argument_list|)
operator|.
name|toRule
argument_list|(
name|PhysToIteratorRule
operator|.
name|class
argument_list|)
decl_stmt|;
name|PhysToIteratorRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|convert
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
operator|new
name|PhysToIteratorConverter
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
name|rel
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

