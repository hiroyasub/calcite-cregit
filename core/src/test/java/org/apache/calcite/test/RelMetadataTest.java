begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableMergeJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ConventionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|VolcanoPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistribution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistributions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|SingleRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sample
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|RelHint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|BuiltInMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ChainedRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|DefaultRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|JaninoRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|MetadataDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|MetadataHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|MetadataHandlerProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ReflectiveRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelColumnOrigin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdColumnUniqueness
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|UnboundMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CoreRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|test
operator|.
name|SqlTestFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|catalog
operator|.
name|MockCatalogReaderSimple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|FrameworkConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|NonNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Disabled
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|hasFieldNames
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|isAlmost
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|sortsAs
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|within
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|anyOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|endsWith
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|instanceOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|notNullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|nullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|startsWith
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|fail
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assumptions
operator|.
name|assumeTrue
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Unit test for {@link DefaultRelMetadataProvider}. See  * {@link SqlToRelTestBase} class comments for details on the schema used. Note  * that no optimizer rules are fired on the translation of the SQL into  * relational algebra (e.g. join conditions in the WHERE clause will look like  * filters), so it's necessary to phrase the SQL carefully.  */
end_comment

begin_class
specifier|public
class|class
name|RelMetadataTest
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_EQUAL_SELECTIVITY
init|=
literal|0.15
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_EQUAL_SELECTIVITY_SQUARED
init|=
name|DEFAULT_EQUAL_SELECTIVITY
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_COMP_SELECTIVITY
init|=
literal|0.5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_NOTNULL_SELECTIVITY
init|=
literal|0.9
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_SELECTIVITY
init|=
literal|0.25
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|EMP_SIZE
init|=
literal|14d
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEPT_SIZE
init|=
literal|4d
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_QNAME
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"CATALOG"
argument_list|,
literal|"SALES"
argument_list|,
literal|"EMP"
argument_list|)
decl_stmt|;
comment|/** Ensures that tests that use a lot of memory do not run at the same    * time. */
specifier|private
specifier|static
specifier|final
name|ReentrantLock
name|LOCK
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/** Creates a fixture. */
specifier|protected
name|RelMetadataFixture
name|fixture
parameter_list|()
block|{
return|return
name|RelMetadataFixture
operator|.
name|DEFAULT
return|;
block|}
specifier|final
name|RelMetadataFixture
name|sql
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
return|return
name|fixture
argument_list|()
operator|.
name|withSql
argument_list|(
name|sql
argument_list|)
return|;
block|}
comment|// ----------------------------------------------------------------------
comment|// Tests for getPercentageOriginalRows
comment|// ----------------------------------------------------------------------
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsTableOnly
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from dept"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsAgg
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select deptno from dept group by deptno"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsOneFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from dept where deptno = 20"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsTwoFilters
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from (\n"
operator|+
literal|"  select * from dept where name='X')\n"
operator|+
literal|"where deptno = 20"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY_SQUARED
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsRedundantFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from (\n"
operator|+
literal|"  select * from dept where deptno=20)\n"
operator|+
literal|"where deptno = 20"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsJoin
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp inner join dept on emp.deptno=dept.deptno"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsJoinTwoFilters
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from (\n"
operator|+
literal|"  select * from emp where deptno=10) e\n"
operator|+
literal|"inner join (select * from dept where deptno=10) d\n"
operator|+
literal|"on e.deptno=d.deptno"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY_SQUARED
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsUnionNoFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name from dept union all select ename from emp"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsUnionLittleFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name from dept where deptno=20"
operator|+
literal|" union all select ename from emp"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
operator|(
operator|(
name|DEPT_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
operator|)
operator|+
name|EMP_SIZE
operator|)
operator|/
operator|(
name|DEPT_SIZE
operator|+
name|EMP_SIZE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testPercentageOriginalRowsUnionBigFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name from dept"
operator|+
literal|" union all select ename from emp where deptno=20"
argument_list|)
operator|.
name|assertPercentageOriginalRows
argument_list|(
name|isAlmost
argument_list|(
operator|(
operator|(
name|EMP_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
operator|)
operator|+
name|DEPT_SIZE
operator|)
operator|/
operator|(
name|DEPT_SIZE
operator|+
name|EMP_SIZE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// ----------------------------------------------------------------------
comment|// Tests for getColumnOrigins
comment|// ----------------------------------------------------------------------
annotation|@
name|Test
name|void
name|testCalcColumnOriginsTable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name,deptno from dept where deptno> 10"
decl_stmt|;
specifier|final
name|RelNode
name|relNode
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|relNode
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|calc
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|calc
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelColumnOrigin
name|nameColumn
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|calc
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|nameColumn
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelColumnOrigin
name|deptnoColumn
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|calc
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|deptnoColumn
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDerivedColumnOrigins
parameter_list|()
block|{
specifier|final
name|String
name|sql1
init|=
literal|""
operator|+
literal|"select empno, sum(sal) as all_sal\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by empno"
decl_stmt|;
specifier|final
name|RelNode
name|relNode
init|=
name|sql
argument_list|(
name|sql1
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|relNode
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelColumnOrigin
name|allSal
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|rel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|allSal
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|,
name|is
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsTableOnly
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name as dname from dept"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsExpression
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select upper(name) as dname from dept"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsDyadicExpression
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name||ename from dept,emp"
argument_list|)
operator|.
name|assertColumnOriginDouble
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsConstant
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select 'Minstrelsy' as dname from dept"
argument_list|)
operator|.
name|assertColumnOriginIsEmpty
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name as dname from dept where deptno=10"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsJoinLeft
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select ename from emp,dept"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsJoinRight
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name as dname from emp,dept"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsJoinOuter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name as dname from emp left outer join dept"
operator|+
literal|" on emp.deptno = dept.deptno"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsJoinFullOuter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name as dname from emp full outer join dept"
operator|+
literal|" on emp.deptno = dept.deptno"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsSnapshot
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select productid from products_temporal\n"
operator|+
literal|"for system_time as of TIMESTAMP '2011-01-02 00:00:00'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"PRODUCTS_TEMPORAL"
argument_list|,
literal|"PRODUCTID"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsAggKey
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name,count(deptno) from dept group by name"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsAggReduced
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select count(deptno),name from dept group by name"
argument_list|)
operator|.
name|assertColumnOriginIsEmpty
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsAggCountNullable
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select count(mgr),ename from emp group by ename"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"EMP"
argument_list|,
literal|"MGR"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsAggCountStar
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select count(*),name from dept group by name"
argument_list|)
operator|.
name|assertColumnOriginIsEmpty
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsValues
parameter_list|()
block|{
name|sql
argument_list|(
literal|"values(1,2,3)"
argument_list|)
operator|.
name|assertColumnOriginIsEmpty
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsUnion
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select name from dept union all select ename from emp"
argument_list|)
operator|.
name|assertColumnOriginDouble
argument_list|(
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testColumnOriginsSelfUnion
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select ename from emp union all select ename from emp"
argument_list|)
operator|.
name|assertColumnOriginSingle
argument_list|(
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4192">[CALCITE-4192]    * RelMdColumnOrigins get the wrong index of group by columns after RelNode    * was optimized by AggregateProjectMergeRule rule</a>. */
annotation|@
name|Test
name|void
name|testColumnOriginAfterAggProjectMergeRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(ename), SAL from emp group by SAL"
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|fixture
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|HepProgramBuilder
name|programBuilder
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
decl_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
expr_stmt|;
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|programBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|optimizedRel
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataFixture
operator|.
name|MetadataConfig
name|metadataConfig
init|=
name|fixture
operator|.
name|metadataConfig
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
operator|new
name|RelMetadataQuery
argument_list|(
name|metadataConfig
operator|.
name|getDefaultHandlerProvider
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|origins
init|=
name|mq
operator|.
name|getColumnOrigins
argument_list|(
name|optimizedRel
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|origins
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|origins
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RelColumnOrigin
name|columnOrigin
init|=
name|origins
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|columnOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnOrigin
operator|.
name|getOriginTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
literal|5
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"SAL"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// ----------------------------------------------------------------------
comment|// Tests for getRowCount, getMinRowCount, getMaxRowCount
comment|// ----------------------------------------------------------------------
annotation|@
name|Test
name|void
name|testRowCountEmp
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountDept
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from dept"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|DEPT_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountValues
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1), (2)) as t(c)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|2d
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2d
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2d
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountCartesian
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp,dept"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
operator|*
name|DEPT_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp\n"
operator|+
literal|"inner join dept on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
operator|*
name|DEPT_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountJoinFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 14) as emp\n"
operator|+
literal|"inner join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|double
name|maxRowCount
init|=
literal|56D
decl_stmt|;
comment|// 4 * 14
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
operator|*
name|DEPT_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|maxRowCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"inner join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|double
name|rowCount
init|=
literal|1D
decl_stmt|;
comment|// 0, rounded up to row count's minimum 1
specifier|final
name|double
name|minRowCount
init|=
literal|0D
decl_stmt|;
comment|// 0 * 4
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|rowCount
argument_list|)
argument_list|,
name|is
argument_list|(
name|minRowCount
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountLeftJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"left join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|double
name|rowCount
init|=
literal|1D
decl_stmt|;
comment|// 0, rounded up to row count's minimum 1
specifier|final
name|double
name|minRowCount
init|=
literal|0D
decl_stmt|;
comment|// 0 * 4
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|rowCount
argument_list|)
argument_list|,
name|is
argument_list|(
name|minRowCount
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountRightJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"right join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|4D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|4D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountJoinFiniteEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 7) as emp\n"
operator|+
literal|"inner join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|double
name|rowCount
init|=
literal|1D
decl_stmt|;
comment|// 0, rounded up to row count's minimum 1
specifier|final
name|double
name|minRowCount
init|=
literal|0D
decl_stmt|;
comment|// 7 * 0
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|rowCount
argument_list|)
argument_list|,
name|is
argument_list|(
name|minRowCount
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountLeftJoinFiniteEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 4) as emp\n"
operator|+
literal|"left join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|4D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|4D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountRightJoinFiniteEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 4) as emp\n"
operator|+
literal|"right join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|double
name|rowCount
init|=
literal|1D
decl_stmt|;
comment|// 0, rounded up to row count's minimum 1
specifier|final
name|double
name|minRowCount
init|=
literal|0D
decl_stmt|;
comment|// 0 * 4
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|rowCount
argument_list|)
argument_list|,
name|is
argument_list|(
name|minRowCount
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountJoinEmptyEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"inner join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|double
name|rowCount
init|=
literal|1D
decl_stmt|;
comment|// 0, rounded up to row count's minimum 1
specifier|final
name|double
name|minRowCount
init|=
literal|0D
decl_stmt|;
comment|// 0 * 0
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|rowCount
argument_list|)
argument_list|,
name|is
argument_list|(
name|minRowCount
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from emp\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name from dept"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
operator|+
name|DEPT_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountUnionOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
operator|+
name|DEPT_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|140D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountUnionDistinct
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select x from (values 'a', 'b') as t(x)\n"
operator|+
literal|"union\n"
operator|+
literal|"select x from (values 'a', 'b') as t(x)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|2D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|4D
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select x from (values 'a', 'a') as t(x)\n"
operator|+
literal|"union\n"
operator|+
literal|"select x from (values 'a', 'a') as t(x)"
expr_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|2D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|4D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountIntersectOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|EMP_SIZE
argument_list|,
name|DEPT_SIZE
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|40D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountMinusOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"except\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|4D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|100D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where ename='Mathilda'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountFilterOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 10)\n"
operator|+
literal|"where ename='Mathilda'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|10D
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|10D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountFilterFalse
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values 'a', 'b') as t(x) where false"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRowCountExchange
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 123456"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRelTransform
argument_list|(
name|rel
lambda|->
name|LogicalExchange
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
block_content|<Integer>of(
argument_list|)
block_content|)
block|)
end_class

begin_expr_stmt
unit|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|123456D
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}    @
name|Test
name|void
name|testRowCountTableModify
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"insert into emp select * from emp order by ename limit 123456"
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|123456D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountSortHighLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 123456"
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|123456D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountSortHighOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename offset 123456"
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountSortHighOffsetLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 5 offset 123456"
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|5D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountSortLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10"
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|10d
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|10d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountSortLimit0
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 0"
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1d
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountSortLimitOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10 offset 5"
decl_stmt|;
comment|/* 14 - 5 */
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|fixture
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|9D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|10d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-5286">[CALCITE-5286]    * Join with parameterized LIMIT throws AssertionError "not a literal".</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testRowCountJoinWithDynamicParameters
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select r.ename, s.sal from\n"
operator|+
literal|"(select * from emp limit ?) r join bonus s\n"
operator|+
literal|"on r.ename=s.ename where r.sal+1=s.sal"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withCluster
argument_list|(
name|cluster
lambda|->
block|{
name|RelOptPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_TABLE_SCAN_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_LIMIT_SORT_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
return|;
block|}
argument_list|)
operator|.
name|withRelTransform
argument_list|(
name|rel
lambda|->
block|{
name|RelOptPlanner
name|planner
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|RelTraitSet
name|requiredOutputTraits
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSet
argument_list|()
operator|.
name|replace
argument_list|(
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rootRel2
init|=
name|planner
operator|.
name|changeTraits
argument_list|(
name|rel
argument_list|,
name|requiredOutputTraits
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|rootRel2
argument_list|)
expr_stmt|;
specifier|final
name|RelOptPlanner
name|planner2
init|=
name|planner
operator|.
name|chooseDelegate
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|rootRel3
init|=
name|planner2
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
return|return
name|rootRel3
return|;
block|}
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountSortLimitOffsetDynamic
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp order by ename limit ? offset ?"
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select * from emp order by ename limit 1 offset ?"
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select * from emp order by ename limit ? offset 1"
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|EMP_SIZE
operator|-
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountSortLimitOffsetOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 12)\n"
operator|+
literal|"order by ename limit 20 offset 5"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|7d
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|7d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1.4D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregateGroupingSets
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by grouping sets ((deptno), (ename, deptno))"
decl_stmt|;
specifier|final
name|double
name|rowCount
init|=
literal|2.8D
decl_stmt|;
comment|// EMP_SIZE / 10 * 2
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
name|rowCount
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregateGroupingSetsOneEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by grouping sets ((deptno), ())"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|2.8D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregateEmptyKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-5050">[CALCITE-5050]    * Aggregate with no GROUP BY always returns 1 row.</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregateEmptyGroupKey
parameter_list|()
block|{
name|fixture
argument_list|()
operator|.
name|withRelFn
argument_list|(
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|b
operator|.
name|groupKey
argument_list|()
argument_list|,
name|b
operator|.
name|count
argument_list|(
literal|false
argument_list|,
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-5050">[CALCITE-5050]    * Aggregate with no GROUP BY always returns 1 row (even on empty table).</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregateEmptyGroupKeyWithEmptyTable
parameter_list|()
block|{
name|fixture
argument_list|()
operator|.
name|withRelFn
argument_list|(
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|b
operator|.
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|b
operator|.
name|groupKey
argument_list|()
argument_list|,
name|b
operator|.
name|count
argument_list|(
literal|false
argument_list|,
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregateConstantKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from emp where deptno=2 and ename='emp1' "
operator|+
literal|"group by deptno, ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregateConstantKeys
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select distinct deptno from emp where deptno=4"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|0D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountFilterAggregateEmptyKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from emp where 1 = 0"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowCountAggregateEmptyKeyOnEmptyTable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from (select * from emp limit 0)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRowCount
argument_list|(
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ----------------------------------------------------------------------
end_comment

begin_comment
comment|// Tests for computeSelfCost.cpu
end_comment

begin_comment
comment|// ----------------------------------------------------------------------
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSortCpuCostOffsetLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, deptno from emp\n"
operator|+
literal|"order by ename limit 5 offset 5"
decl_stmt|;
comment|// inputRows = EMP_SIZE = 14
comment|// offset + fetch = 5 + 5 = 10
comment|// rowBytes = (2 real columns + 3 virtual columns) * 4 bytes per column
comment|//   = 5 * 4
comment|//   = 20
name|double
name|cpuCost
init|=
name|Util
operator|.
name|nLogM
argument_list|(
name|EMP_SIZE
argument_list|,
literal|10
argument_list|)
operator|*
literal|5
operator|*
literal|4
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertCpuCost
argument_list|(
name|is
argument_list|(
name|cpuCost
argument_list|)
argument_list|,
literal|"offset + fetch smaller than table size "
operator|+
literal|"=> cpu cost should be: inputRows * log(offset + fetch) * rowBytes"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortCpuCostLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, deptno from emp limit 10"
decl_stmt|;
specifier|final
name|double
name|cpuCost
init|=
literal|10
operator|*
literal|5
operator|*
literal|4
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertCpuCost
argument_list|(
name|is
argument_list|(
name|cpuCost
argument_list|)
argument_list|,
literal|"no order by clause "
operator|+
literal|"=> cpu cost should be min(fetch + offset, inputRows) * rowBytes"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortCpuCostOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from emp order by ename offset 10"
decl_stmt|;
name|double
name|cpuCost
init|=
name|Util
operator|.
name|nLogM
argument_list|(
name|EMP_SIZE
argument_list|,
name|EMP_SIZE
argument_list|)
operator|*
literal|4
operator|*
literal|4
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertCpuCost
argument_list|(
name|is
argument_list|(
name|cpuCost
argument_list|)
argument_list|,
literal|"offset smaller than table size "
operator|+
literal|"=> cpu cost should be: inputRows * log(inputRows) * rowBytes"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortCpuCostLargeOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from emp order by ename offset 100"
decl_stmt|;
name|double
name|cpuCost
init|=
name|Util
operator|.
name|nLogM
argument_list|(
name|EMP_SIZE
argument_list|,
name|EMP_SIZE
argument_list|)
operator|*
literal|4
operator|*
literal|4
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertCpuCost
argument_list|(
name|is
argument_list|(
name|cpuCost
argument_list|)
argument_list|,
literal|"offset larger than table size "
operator|+
literal|"=> cpu cost should be: inputRows * log(inputRows) * rowBytes"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortCpuCostLimit0
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from emp order by ename limit 0"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertCpuCost
argument_list|(
name|is
argument_list|(
literal|0d
argument_list|)
argument_list|,
literal|"fetch zero => cpu cost should be 0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortCpuCostLimit1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, deptno from emp\n"
operator|+
literal|"order by ename limit 1"
decl_stmt|;
name|double
name|cpuCost
init|=
name|EMP_SIZE
operator|*
literal|5
operator|*
literal|4
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertCpuCost
argument_list|(
name|is
argument_list|(
name|cpuCost
argument_list|)
argument_list|,
literal|"fetch 1 "
operator|+
literal|"=> cpu cost should be inputRows * rowBytes"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortCpuCostLargeLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, deptno from emp\n"
operator|+
literal|"order by ename limit 10000"
decl_stmt|;
name|double
name|cpuCost
init|=
name|Util
operator|.
name|nLogM
argument_list|(
name|EMP_SIZE
argument_list|,
name|EMP_SIZE
argument_list|)
operator|*
literal|5
operator|*
literal|4
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertCpuCost
argument_list|(
name|is
argument_list|(
name|cpuCost
argument_list|)
argument_list|,
literal|"sort limit exceeds table size "
operator|+
literal|"=> cpu cost should be dominated by table size"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ----------------------------------------------------------------------
end_comment

begin_comment
comment|// Tests for getSelectivity
end_comment

begin_comment
comment|// ----------------------------------------------------------------------
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSelectivityIsNotNullFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where mgr is not null"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_NOTNULL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivityIsNotNullFilterOnNotNullColumn
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where deptno is not null"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
literal|1.0d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivityComparisonFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where deptno> 10"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_COMP_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivityAndFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where ename = 'foo' and deptno = 10"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY_SQUARED
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivityOrFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where ename = 'foo' or deptno = 10"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivityJoin
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp join dept using (deptno) where ename = 'foo'"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivityRedundantFilter
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where deptno = 10"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivitySort
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"order by ename"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivityUnion
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from (\n"
operator|+
literal|"  select * from emp union all select * from emp)\n"
operator|+
literal|"where deptno = 10"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectivityAgg
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_COMP_SELECTIVITY
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Checks that we can cache a metadata request that includes a null    * argument. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSelectivityAggCached
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select deptno, count(*) from emp where deptno> 10\n"
operator|+
literal|"group by deptno having count(*) = 0"
argument_list|)
operator|.
name|assertThatSelectivity
argument_list|(
name|isAlmost
argument_list|(
name|DEFAULT_COMP_SELECTIVITY
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1808">[CALCITE-1808]    * JaninoRelMetadataProvider loading cache might cause    * OutOfMemoryError</a>.    *    *<p>Too slow to run every day, and it does not reproduce the issue. */
end_comment

begin_function
annotation|@
name|Tag
argument_list|(
literal|"slow"
argument_list|)
annotation|@
name|Test
name|void
name|testMetadataHandlerCacheLimit
parameter_list|()
block|{
name|assumeTrue
argument_list|(
name|CalciteSystemProperty
operator|.
name|METADATA_HANDLER_CACHE_MAXIMUM_SIZE
operator|.
name|value
argument_list|()
operator|<
literal|10_000
argument_list|,
literal|"If cache size is too large, this test may fail and the test won't be to blame"
argument_list|)
expr_stmt|;
specifier|final
name|int
name|iterationCount
init|=
literal|2_000
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataProvider
name|metadataProvider
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iterationCount
condition|;
name|i
operator|++
control|)
block|{
name|RelMetadataProvider
name|wrappedProvider
init|=
operator|new
name|RelMetadataProvider
argument_list|()
block|{
annotation|@
name|Deprecated
comment|// to be removed before 2.0
annotation|@
name|Override
specifier|public
expr|@
name|Nullable
operator|<
name|M
expr|extends @
name|Nullable
name|Metadata
operator|>
name|UnboundMetadata
argument_list|<
name|M
argument_list|>
name|apply
argument_list|(
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|relClass
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|M
argument_list|>
name|metadataClass
argument_list|)
block|{
return|return
name|metadataProvider
operator|.
name|apply
argument_list|(
name|relClass
argument_list|,
name|metadataClass
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
annotation|@
name|Override
specifier|public
parameter_list|<
name|M
extends|extends
name|Metadata
parameter_list|>
name|Multimap
argument_list|<
name|Method
argument_list|,
name|MetadataHandler
argument_list|<
name|M
argument_list|>
argument_list|>
name|handlers
parameter_list|(
name|MetadataDef
argument_list|<
name|M
argument_list|>
name|def
parameter_list|)
block|{
return|return
name|metadataProvider
operator|.
name|handlers
argument_list|(
name|def
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|MetadataHandler
argument_list|<
name|?
argument_list|>
argument_list|>
name|handlers
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|MetadataHandler
argument_list|<
name|?
argument_list|>
argument_list|>
name|handlerClass
parameter_list|)
block|{
return|return
name|metadataProvider
operator|.
name|handlers
argument_list|(
name|handlerClass
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|RelMetadataQuery
operator|.
name|THREAD_PROVIDERS
operator|.
name|set
argument_list|(
name|JaninoRelMetadataProvider
operator|.
name|of
argument_list|(
name|wrappedProvider
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Double
name|result
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|within
argument_list|(
literal|14d
argument_list|,
literal|0.1d
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDistinctRowCountTable
parameter_list|()
block|{
comment|// no unique key information is available so return null
specifier|final
name|String
name|sql
init|=
literal|"select * from (values "
operator|+
literal|"(1, 2, 3, null), "
operator|+
literal|"(3, 4, 5, 6), "
operator|+
literal|"(3, 4, null, 6), "
operator|+
literal|"(8, 4, 5, null) "
operator|+
literal|") t(c1, c2, c3, c4)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
comment|// all rows are different
operator|.
name|assertThatDistinctRowCount
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|is
argument_list|(
literal|4D
argument_list|)
argument_list|)
comment|// rows 2 and 4 are the same in the specified columns
operator|.
name|assertThatDistinctRowCount
argument_list|(
name|bitSetOf
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|3D
argument_list|)
argument_list|)
comment|// rows 2 and 3 are the same in the specified columns
operator|.
name|assertThatDistinctRowCount
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|3D
argument_list|)
argument_list|)
comment|// the last column has 2 distinct values: 6 and null
operator|.
name|assertThatDistinctRowCount
argument_list|(
name|bitSetOf
argument_list|(
literal|3
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDistinctRowCountValues
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where deptno = 10"
argument_list|)
operator|.
name|assertThatDistinctRowCount
argument_list|(
name|rel
lambda|->
name|bitSetOf
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|nullValue
argument_list|(
name|Double
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDistinctRowCountTableEmptyKey
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp where deptno = 10"
argument_list|)
operator|.
name|assertThatDistinctRowCount
argument_list|(
name|bitSetOf
argument_list|()
argument_list|,
comment|// empty key
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ----------------------------------------------------------------------
end_comment

begin_comment
comment|// Tests for getUniqueKeys
end_comment

begin_comment
comment|// ----------------------------------------------------------------------
end_comment

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-509">[CALCITE-509]    * "RelMdColumnUniqueness uses ImmutableBitSet.Builder twice, gets    * NullPointerException"</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testJoinUniqueKeys
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp join bonus using (ename)"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|()
expr_stmt|;
comment|// no unique keys
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testCorrelateUniqueKeys
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (select distinct deptno from emp) as e,\n"
operator|+
literal|"  lateral (\n"
operator|+
literal|"    select * from dept where dept.deptno = e.deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRel
argument_list|(
name|is
argument_list|(
name|instanceOf
argument_list|(
name|Project
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
operator|.
name|assertThatUniqueKeys
argument_list|(
name|sortsAs
argument_list|(
literal|"[{0}]"
argument_list|)
argument_list|)
operator|.
name|withRelTransform
argument_list|(
name|r
lambda|->
operator|(
operator|(
name|Project
operator|)
name|r
operator|)
operator|.
name|getInput
argument_list|()
argument_list|)
operator|.
name|assertThatRel
argument_list|(
name|is
argument_list|(
name|instanceOf
argument_list|(
name|Correlate
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
operator|.
name|assertThatUniqueKeys
argument_list|(
name|sortsAs
argument_list|(
literal|"[{0}]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testGroupByEmptyUniqueKeys
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select count(*) from emp"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testGroupByEmptyHavingUniqueKeys
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select count(*) from emp where 1 = 1"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-5162">[CALCITE-5162]    * RelMdUniqueKeys can return more precise unique keys for Aggregate</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testGroupByPreciseUniqueKeys
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select empno, ename from emp group by empno, ename"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testFullOuterJoinUniqueness1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.empno, d.deptno\n"
operator|+
literal|"from (select cast(null as int) empno from sales.emp "
operator|+
literal|" where empno = 10 group by cast(null as int)) as e\n"
operator|+
literal|"full outer join (select cast (null as int) deptno from sales.dept "
operator|+
literal|"group by cast(null as int)) as d on e.empno = d.deptno\n"
operator|+
literal|"group by e.empno, d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|r
lambda|->
name|ImmutableBitSet
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
name|r
lambda|->
name|r
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForFilterWithConstantColumns
parameter_list|()
block|{
name|checkColumnUniquenessForFilterWithConstantColumns
argument_list|(
literal|""
operator|+
literal|"select *\n"
operator|+
literal|"from (select distinct deptno, sal from emp)\n"
operator|+
literal|"where sal=1000"
argument_list|)
expr_stmt|;
name|checkColumnUniquenessForFilterWithConstantColumns
argument_list|(
literal|""
operator|+
literal|"select *\n"
operator|+
literal|"from (select distinct deptno, sal from emp)\n"
operator|+
literal|"where 1000=sal"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkColumnUniquenessForFilterWithConstantColumns
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRel
argument_list|(
name|hasFieldNames
argument_list|(
literal|"[DEPTNO, SAL]"
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForUnionWithConstantColumns
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|""
operator|+
literal|"select deptno, sal from emp where sal=1000\n"
operator|+
literal|"union\n"
operator|+
literal|"select deptno, sal from emp where sal=1000\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRel
argument_list|(
name|hasFieldNames
argument_list|(
literal|"[DEPTNO, SAL]"
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForIntersectWithConstantColumns
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|""
operator|+
literal|"select deptno, sal\n"
operator|+
literal|"from (select distinct deptno, sal from emp)\n"
operator|+
literal|"where sal=1000\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select deptno, sal from emp\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRel
argument_list|(
name|hasFieldNames
argument_list|(
literal|"[DEPTNO, SAL]"
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForMinusWithConstantColumns
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|""
operator|+
literal|"select deptno, sal\n"
operator|+
literal|"from (select distinct deptno, sal from emp)\n"
operator|+
literal|"where sal=1000\n"
operator|+
literal|"except all\n"
operator|+
literal|"select deptno, sal from emp\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRel
argument_list|(
name|hasFieldNames
argument_list|(
literal|"[DEPTNO, SAL]"
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForSortWithConstantColumns
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|""
operator|+
literal|"select *\n"
operator|+
literal|"from (select distinct deptno, sal from emp)\n"
operator|+
literal|"where sal=1000\n"
operator|+
literal|"order by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRel
argument_list|(
name|hasFieldNames
argument_list|(
literal|"[DEPTNO, SAL]"
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRowUniquenessForSortWithLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from emp\n"
operator|+
literal|"limit 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatAreRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForJoinWithConstantColumns
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|""
operator|+
literal|"select *\n"
operator|+
literal|"from (select distinct deptno, sal from emp) A\n"
operator|+
literal|"join (select distinct deptno, sal from emp) B\n"
operator|+
literal|"on A.deptno=B.deptno and A.sal=1000 and B.sal=1000"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatRel
argument_list|(
name|hasFieldNames
argument_list|(
literal|"[DEPTNO, SAL, DEPTNO0, SAL0]"
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForAggregateWithConstantColumns
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|""
operator|+
literal|"select deptno, ename, sum(sal)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where deptno=1010\n"
operator|+
literal|"group by deptno, ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForExchangeWithConstantColumns
parameter_list|()
block|{
name|fixture
argument_list|()
operator|.
name|withRelFn
argument_list|(
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|filter
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|exchange
argument_list|(
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForCorrelateWithConstantColumns
parameter_list|()
block|{
name|fixture
argument_list|()
operator|.
name|withRelFn
argument_list|(
name|b
lambda|->
block|{
name|RelNode
name|rel0
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|filter
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Holder
argument_list|<
annotation|@
name|Nullable
name|RexCorrelVariable
argument_list|>
name|v
init|=
name|Holder
operator|.
name|empty
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|rel1
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|variable
argument_list|(
name|v
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
name|v
operator|.
name|get
argument_list|()
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|rel0
argument_list|)
operator|.
name|variable
argument_list|(
name|v
argument_list|)
operator|.
name|push
argument_list|(
name|rel1
argument_list|)
operator|.
name|correlate
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|,
name|v
operator|.
name|get
argument_list|()
operator|.
name|id
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-5149">[CALCITE-5149]    * Refine RelMdColumnUniqueness for Aggregate by considering intersect keys    * between target keys and group keys</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForAggregate
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select empno, ename, count(1) as cnt from emp group by empno, ename"
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select empno, ename, count(1) as cnt from emp group by empno, ename"
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select ename, empno, count(1) as cnt from emp group by ename, empno"
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select empno, ename, count(1) as cnt from emp group by empno, ename"
argument_list|)
operator|.
name|assertThatAreColumnsUnique
argument_list|(
name|bitSetOf
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testGroupBy
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select deptno, count(*), sum(sal) from emp group by deptno"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testGroupingSets
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select deptno, sal, count(*) from emp\n"
operator|+
literal|"group by GROUPING SETS (deptno, sal)"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testUnion
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select deptno from emp\n"
operator|+
literal|"union\n"
operator|+
literal|"select deptno from dept"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testUniqueKeysMinus
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select distinct deptno from emp\n"
operator|+
literal|"except all\n"
operator|+
literal|"select deptno from dept"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testUniqueKeysIntersect
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select distinct deptno from emp\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select deptno from dept"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSingleKeyTableScanUniqueKeys
parameter_list|()
block|{
comment|// select key column
name|sql
argument_list|(
literal|"select empno, ename from emp"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// select non key column
name|sql
argument_list|(
literal|"select ename, deptno from emp"
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testCompositeKeysTableScanUniqueKeys
parameter_list|()
block|{
name|SqlTestFactory
operator|.
name|CatalogReaderFactory
name|factory
init|=
parameter_list|(
name|typeFactory
parameter_list|,
name|caseSensitive
parameter_list|)
lambda|->
block|{
name|CompositeKeysCatalogReader
name|catalogReader
init|=
operator|new
name|CompositeKeysCatalogReader
argument_list|(
name|typeFactory
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalogReader
operator|.
name|init
argument_list|()
expr_stmt|;
return|return
name|catalogReader
return|;
block|}
decl_stmt|;
comment|// all columns, contain composite keys
name|sql
argument_list|(
literal|"select * from s.composite_keys_table"
argument_list|)
operator|.
name|withCatalogReaderFactory
argument_list|(
name|factory
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// only contain composite keys
name|sql
argument_list|(
literal|"select key1, key2 from s.composite_keys_table"
argument_list|)
operator|.
name|withCatalogReaderFactory
argument_list|(
name|factory
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// partial column of composite keys
name|sql
argument_list|(
literal|"select key1, value1 from s.composite_keys_table"
argument_list|)
operator|.
name|withCatalogReaderFactory
argument_list|(
name|factory
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|()
expr_stmt|;
comment|// no column of composite keys
name|sql
argument_list|(
literal|"select value1 from s.composite_keys_table"
argument_list|)
operator|.
name|withCatalogReaderFactory
argument_list|(
name|factory
argument_list|)
operator|.
name|assertThatUniqueKeysAre
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|ImmutableBitSet
name|bitSetOf
parameter_list|(
name|int
modifier|...
name|bits
parameter_list|)
block|{
return|return
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|bits
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|calcColumnsAreUniqueSimpleCalc
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select empno, empno*0 from emp"
argument_list|)
operator|.
name|convertingProjectAsCalc
argument_list|()
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|calcColumnsAreUniqueCalcWithFirstConstant
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select 1, empno, empno*0 from emp"
argument_list|)
operator|.
name|convertingProjectAsCalc
argument_list|()
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|calcMultipleColumnsAreUniqueCalc
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select empno, empno from emp"
argument_list|)
operator|.
name|convertingProjectAsCalc
argument_list|()
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|calcMultipleColumnsAreUniqueCalc2
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select a1.empno, a2.empno\n"
operator|+
literal|"from emp a1 join emp a2 on (a1.empno=a2.empno)"
argument_list|)
operator|.
name|convertingProjectAsCalc
argument_list|()
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|calcMultipleColumnsAreUniqueCalc3
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select a1.empno, a2.empno, a2.empno\n"
operator|+
literal|" from emp a1 join emp a2\n"
operator|+
literal|" on (a1.empno=a2.empno)"
argument_list|)
operator|.
name|convertingProjectAsCalc
argument_list|()
operator|.
name|assertThatUniqueKeysAre
argument_list|(
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|bitSetOf
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|calcColumnsAreNonUniqueCalc
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select empno*0 from emp"
argument_list|)
operator|.
name|convertingProjectAsCalc
argument_list|()
operator|.
name|assertThatUniqueKeysAre
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMetadataQuery#areRowsUnique(RelNode)}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testRowsUnique
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"table has primary key"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select deptno from emp"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|false
argument_list|)
argument_list|,
literal|"table has primary key"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select empno from emp"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"primary key is unique"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select empno from emp, dept"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|false
argument_list|)
argument_list|,
literal|"cartesian product destroys uniqueness"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select empno from emp join dept using (deptno)"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"many-to-one join does not destroy uniqueness"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select empno, job from emp join dept using (deptno) order by job desc"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"project and sort does not destroy uniqueness"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select deptno from emp limit 1"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"1 row table is always unique"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select distinct deptno from emp"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"distinct table is always unique"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select count(*) from emp"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"grand total is always unique"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select count(*) from emp group by deptno"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|false
argument_list|)
argument_list|,
literal|"several depts may have same count"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select deptno, count(*) from emp group by deptno"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"group by keys are unique"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select deptno, count(*) from emp group by grouping sets ((), (deptno))"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
literal|true
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"group by keys are unique and not null"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select deptno, count(*) from emp group by grouping sets ((), (deptno))"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
literal|false
argument_list|,
name|nullValue
argument_list|(
name|Boolean
operator|.
name|class
argument_list|)
argument_list|,
literal|"is actually unique; TODO: deduce it"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select distinct deptno from emp join dept using (deptno)"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"distinct table is always unique"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select deptno from emp union select deptno from dept"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"set query is always unique"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select deptno from emp intersect select deptno from dept"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"set query is always unique"
argument_list|)
expr_stmt|;
name|sql
argument_list|(
literal|"select deptno from emp except select deptno from dept"
argument_list|)
operator|.
name|assertRowsUnique
argument_list|(
name|is
argument_list|(
literal|true
argument_list|)
argument_list|,
literal|"set query is always unique"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testBrokenCustomProviderWithMetadataFactory
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ColTypeImpl
operator|.
name|THREAD_LIST
operator|.
name|set
argument_list|(
name|buf
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
decl_stmt|;
specifier|final
name|RelMetadataFixture
operator|.
name|MetadataConfig
name|metadataConfig
init|=
name|fixture
argument_list|()
operator|.
name|metadataConfig
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withCluster
argument_list|(
name|cluster
lambda|->
block|{
name|metadataConfig
operator|.
name|applyMetadata
argument_list|(
name|cluster
argument_list|,
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|BrokenColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|requireNonNull
argument_list|(
name|cluster
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|"cluster.metadataProvider"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cluster
return|;
block|}
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|fixture
operator|.
name|toRel
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|rel
argument_list|,
name|instanceOf
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|MetadataHandlerProvider
name|defaultHandlerProvider
init|=
name|fixture
operator|.
name|metadataConfig
operator|.
name|getDefaultHandlerProvider
argument_list|()
decl_stmt|;
specifier|final
name|MyRelMetadataQuery
name|mq
init|=
operator|new
name|MyRelMetadataQuery
argument_list|(
name|defaultHandlerProvider
argument_list|)
decl_stmt|;
try|try
block|{
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-rel"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|value
init|=
literal|"No handler for method [public abstract "
operator|+
literal|"java.lang.String org.apache.calcite.test.RelMetadataTest$ColType$Handler.getColType("
operator|+
literal|"org.apache.calcite.rel.RelNode,org.apache.calcite.rel.metadata.RelMetadataQuery,int)] "
operator|+
literal|"applied to argument of type [class org.apache.calcite.rel.logical.LogicalFilter]; "
operator|+
literal|"we recommend you create a catch-all (RelNode) handler"
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testBrokenCustomProviderWithMetadataQuery
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ColTypeImpl
operator|.
name|THREAD_LIST
operator|.
name|set
argument_list|(
name|buf
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
decl_stmt|;
specifier|final
name|RelMetadataFixture
operator|.
name|MetadataConfig
name|metadataConfig
init|=
name|fixture
argument_list|()
operator|.
name|metadataConfig
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withMetadataConfig
argument_list|(
name|RelMetadataFixture
operator|.
name|MetadataConfig
operator|.
name|NOP
argument_list|)
operator|.
name|withCluster
argument_list|(
name|cluster
lambda|->
block|{
name|metadataConfig
operator|.
name|applyMetadata
argument_list|(
name|cluster
argument_list|,
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|BrokenColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|requireNonNull
argument_list|(
name|cluster
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|"cluster.metadataProvider"
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|MyRelMetadataQuery
operator|::
operator|new
argument_list|)
expr_stmt|;
return|return
name|cluster
return|;
block|}
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|fixture
operator|.
name|toRel
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|rel
argument_list|,
name|instanceOf
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
argument_list|,
name|instanceOf
argument_list|(
name|MyRelMetadataQuery
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|MyRelMetadataQuery
name|mq
init|=
operator|(
name|MyRelMetadataQuery
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
try|try
block|{
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-rel"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|value
init|=
literal|"No handler for method [public abstract java.lang.String "
operator|+
literal|"org.apache.calcite.test.RelMetadataTest$ColType$Handler.getColType("
operator|+
literal|"org.apache.calcite.rel.RelNode,org.apache.calcite.rel.metadata.RelMetadataQuery,int)]"
operator|+
literal|" applied to argument of type [class org.apache.calcite.rel.logical.LogicalFilter];"
operator|+
literal|" we recommend you create a catch-all (RelNode) handler"
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|String
name|colType
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|int
name|column
parameter_list|)
block|{
return|return
name|rel
operator|.
name|metadata
argument_list|(
name|ColType
operator|.
name|class
argument_list|,
name|mq
argument_list|)
operator|.
name|getColType
argument_list|(
name|column
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|String
name|colType
parameter_list|(
name|MyRelMetadataQuery
name|myRelMetadataQuery
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|int
name|column
parameter_list|)
block|{
return|return
name|myRelMetadataQuery
operator|.
name|colType
argument_list|(
name|rel
argument_list|,
name|column
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Deprecated
comment|// to be removed before 2.0
annotation|@
name|Test
name|void
name|testCustomProviderWithRelMetadataFactory
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ColTypeImpl
operator|.
name|THREAD_LIST
operator|.
name|set
argument_list|(
name|buf
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
decl_stmt|;
specifier|final
name|RelMetadataFixture
operator|.
name|MetadataConfig
name|metadataConfig
init|=
name|fixture
argument_list|()
operator|.
name|metadataConfig
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withMetadataConfig
argument_list|(
name|RelMetadataFixture
operator|.
name|MetadataConfig
operator|.
name|NOP
argument_list|)
operator|.
name|withCluster
argument_list|(
name|cluster
lambda|->
block|{
comment|// Create a custom provider that includes ColType.
comment|// Include the same provider twice just to be devious.
specifier|final
name|ImmutableList
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|ColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|ColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|DefaultRelMetadataProvider
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|metadataConfig
operator|.
name|applyMetadata
argument_list|(
name|cluster
argument_list|,
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cluster
return|;
block|}
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|fixture
operator|.
name|toRel
argument_list|()
decl_stmt|;
comment|// Top node is a filter. Its metadata uses getColType(RelNode, int).
name|assertThat
argument_list|(
name|rel
argument_list|,
name|instanceOf
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|rel
operator|.
name|getCluster
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|cluster
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-rel"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-rel"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Next node is an aggregate. Its metadata uses
comment|// getColType(LogicalAggregate, int).
specifier|final
name|RelNode
name|input
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|input
argument_list|,
name|instanceOf
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
comment|// There is no caching. Another request causes another call to the provider.
name|assertThat
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[DEPTNO-rel, EXPR$1-rel, DEPTNO-agg]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now add a cache. Only the first request for each piece of metadata
comment|// generates a new call to the provider.
specifier|final
name|RelOptPlanner
name|planner
init|=
name|cluster
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
name|metadataConfig
operator|.
name|applyMetadata
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|,
operator|new
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|CachingRelMetadataProvider
argument_list|(
name|requireNonNull
argument_list|(
name|cluster
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|"cluster.metadataProvider"
argument_list|)
argument_list|,
name|planner
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|// With a different timestamp, a metadata item is re-computed on first call.
name|long
name|timestamp
init|=
name|planner
operator|.
name|getRelMetadataTimestamp
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|equalTo
argument_list|(
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|MockRelOptPlanner
operator|)
name|planner
operator|)
operator|.
name|setRelMetadataTimestamp
argument_list|(
name|timestamp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testCustomProviderWithRelMetadataQuery
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ColTypeImpl
operator|.
name|THREAD_LIST
operator|.
name|set
argument_list|(
name|buf
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
decl_stmt|;
specifier|final
name|RelMetadataFixture
operator|.
name|MetadataConfig
name|metadataConfig
init|=
name|fixture
argument_list|()
operator|.
name|metadataConfig
decl_stmt|;
specifier|final
name|RelMetadataFixture
name|fixture
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withMetadataConfig
argument_list|(
name|RelMetadataFixture
operator|.
name|MetadataConfig
operator|.
name|NOP
argument_list|)
operator|.
name|withCluster
argument_list|(
name|cluster
lambda|->
block|{
comment|// Create a custom provider that includes ColType.
comment|// Include the same provider twice just to be devious.
specifier|final
name|ImmutableList
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|ColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|ColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|requireNonNull
argument_list|(
name|cluster
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
literal|"cluster.metadataProvider"
argument_list|)
argument_list|)
decl_stmt|;
name|metadataConfig
operator|.
name|applyMetadata
argument_list|(
name|cluster
argument_list|,
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
argument_list|,
name|MyRelMetadataQuery
operator|::
operator|new
argument_list|)
expr_stmt|;
return|return
name|cluster
return|;
block|}
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|fixture
operator|.
name|toRel
argument_list|()
decl_stmt|;
comment|// Top node is a filter. Its metadata uses getColType(RelNode, int).
name|assertThat
argument_list|(
name|rel
argument_list|,
name|instanceOf
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
argument_list|,
name|instanceOf
argument_list|(
name|MyRelMetadataQuery
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|MyRelMetadataQuery
name|mq
init|=
operator|(
name|MyRelMetadataQuery
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-rel"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-rel"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Next node is an aggregate. Its metadata uses
comment|// getColType(LogicalAggregate, int).
specifier|final
name|RelNode
name|input
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|input
argument_list|,
name|instanceOf
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadataConfig
operator|.
name|isCaching
argument_list|()
condition|)
block|{
comment|// The metadata query is caching, only the first request for each piece of metadata
comment|// generates a new call to the provider.
name|assertThat
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[DEPTNO-rel, EXPR$1-rel, DEPTNO-agg]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Invalidate the metadata query triggers clearing of all the metadata.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|invalidateMetadataQuery
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
argument_list|,
name|instanceOf
argument_list|(
name|MyRelMetadataQuery
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|MyRelMetadataQuery
name|mq1
init|=
operator|(
name|MyRelMetadataQuery
operator|)
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq1
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadataConfig
operator|.
name|isCaching
argument_list|()
condition|)
block|{
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq1
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadataConfig
operator|.
name|isCaching
argument_list|()
condition|)
block|{
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Resets the RelMetadataQuery to default.
name|metadataConfig
operator|.
name|applyMetadata
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMdCollation#project}    * and other helper functions for deducing collations. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testCollation
parameter_list|()
block|{
specifier|final
name|RelMetadataFixture
operator|.
name|MetadataConfig
name|metadataConfig
init|=
name|fixture
argument_list|()
operator|.
name|metadataConfig
decl_stmt|;
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|sql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
parameter_list|(
name|cluster
parameter_list|,
name|relOptSchema
parameter_list|,
name|rootSchema
parameter_list|)
lambda|->
block|{
name|metadataConfig
operator|.
name|applyMetadata
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
name|checkCollation
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkCollation
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelCollation
argument_list|>
name|collations
init|=
name|RelMdCollation
operator|.
name|table
argument_list|(
name|empScan
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// ORDER BY field#0 ASC, field#1 ASC
specifier|final
name|RelCollation
name|collation
init|=
name|RelCollations
operator|.
name|of
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|RelFieldCollation
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|sort
argument_list|(
name|collation
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Sort
name|empSort
init|=
name|LogicalSort
operator|.
name|create
argument_list|(
name|empScan
argument_list|,
name|collation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|empSort
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|empSort
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|empSort
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|empSort
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|cluster
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|project
argument_list|(
name|mq
argument_list|,
name|empSort
argument_list|,
name|projects
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldIndex
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getFieldIndex
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalProject
name|project
init|=
name|LogicalProject
operator|.
name|create
argument_list|(
name|empSort
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|projects
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"d"
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelCollation
name|deptCollation
init|=
name|RelCollations
operator|.
name|of
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|RelFieldCollation
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Sort
name|deptSort
init|=
name|LogicalSort
operator|.
name|create
argument_list|(
name|deptScan
argument_list|,
name|deptCollation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableIntList
name|leftKeys
init|=
name|ImmutableIntList
operator|.
name|of
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableIntList
name|rightKeys
init|=
name|ImmutableIntList
operator|.
name|of
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|EnumerableMergeJoin
name|join
decl_stmt|;
name|join
operator|=
name|EnumerableMergeJoin
operator|.
name|create
argument_list|(
name|project
argument_list|,
name|deptSort
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
expr_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|mergeJoin
argument_list|(
name|mq
argument_list|,
name|project
argument_list|,
name|deptSort
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
argument_list|,
name|equalTo
argument_list|(
name|join
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTraits
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|EnumerableMergeJoin
name|semiJoin
init|=
name|EnumerableMergeJoin
operator|.
name|create
argument_list|(
name|project
argument_list|,
name|deptSort
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|JoinRelType
operator|.
name|SEMI
argument_list|)
decl_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|mergeJoin
argument_list|(
name|mq
argument_list|,
name|project
argument_list|,
name|deptSort
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
argument_list|,
name|equalTo
argument_list|(
name|semiJoin
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTraits
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|EnumerableMergeJoin
name|antiJoin
init|=
name|EnumerableMergeJoin
operator|.
name|create
argument_list|(
name|project
argument_list|,
name|deptSort
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|JoinRelType
operator|.
name|ANTI
argument_list|)
decl_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|mergeJoin
argument_list|(
name|mq
argument_list|,
name|project
argument_list|,
name|deptSort
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
argument_list|,
name|equalTo
argument_list|(
name|antiJoin
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTraits
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Values (empty)
name|collations
operator|=
name|RelMdCollation
operator|.
name|values
argument_list|(
name|mq
argument_list|,
name|empTable
operator|.
name|getRowType
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[0, 1, 2, 3, 4, 5, 6, 7, 8], "
operator|+
literal|"[1, 2, 3, 4, 5, 6, 7, 8], "
operator|+
literal|"[2, 3, 4, 5, 6, 7, 8], "
operator|+
literal|"[3, 4, 5, 6, 7, 8], "
operator|+
literal|"[4, 5, 6, 7, 8], "
operator|+
literal|"[5, 6, 7, 8], "
operator|+
literal|"[6, 7, 8], "
operator|+
literal|"[7, 8], "
operator|+
literal|"[8]]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalValues
name|emptyValues
init|=
name|LogicalValues
operator|.
name|createEmpty
argument_list|(
name|cluster
argument_list|,
name|empTable
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|collations
argument_list|(
name|emptyValues
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|collations
argument_list|)
argument_list|)
expr_stmt|;
comment|// Values (non-empty)
specifier|final
name|RelDataType
name|rowType
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tuples
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// sort keys are [a], [a, b], [a, b, c], [a, b, c, d], [a, c], [b], [b, a],
comment|//   [b, d]
comment|// algorithm deduces [a, b, c, d], [b, d] which is a useful sub-set
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|values
argument_list|(
name|mq
argument_list|,
name|rowType
argument_list|,
name|tuples
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[0, 1, 2, 3], [1, 3]]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalValues
name|values
init|=
name|LogicalValues
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|tuples
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|collations
argument_list|(
name|values
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|collations
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMdColumnUniqueness#areColumnsUnique}    * applied to {@link Values}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testColumnUniquenessForValues
parameter_list|()
block|{
name|Frameworks
operator|.
name|withPlanner
argument_list|(
parameter_list|(
name|cluster
parameter_list|,
name|relOptSchema
parameter_list|,
name|rootSchema
parameter_list|)
lambda|->
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|cluster
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tuples
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|1
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|2
argument_list|,
literal|"Y"
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|3
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|4
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
specifier|final
name|LogicalValues
name|values
init|=
name|LogicalValues
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|tuples
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|colNone
init|=
name|bitSetOf
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|col0
init|=
name|bitSetOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|col1
init|=
name|bitSetOf
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|colAll
init|=
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|areColumnsUnique
argument_list|(
name|values
argument_list|,
name|col0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|areColumnsUnique
argument_list|(
name|values
argument_list|,
name|col1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|areColumnsUnique
argument_list|(
name|values
argument_list|,
name|colAll
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|areColumnsUnique
argument_list|(
name|values
argument_list|,
name|colNone
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Repeat the above tests directly against the handler.
specifier|final
name|RelMdColumnUniqueness
name|handler
init|=
operator|(
name|RelMdColumnUniqueness
operator|)
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|RelMdColumnUniqueness
operator|.
name|SOURCE
operator|.
name|handlers
argument_list|(
name|BuiltInMetadata
operator|.
name|ColumnUniqueness
operator|.
name|Handler
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|handler
operator|.
name|areColumnsUnique
argument_list|(
name|values
argument_list|,
name|mq
argument_list|,
name|col0
argument_list|,
literal|false
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|handler
operator|.
name|areColumnsUnique
argument_list|(
name|values
argument_list|,
name|mq
argument_list|,
name|col1
argument_list|,
literal|false
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|handler
operator|.
name|areColumnsUnique
argument_list|(
name|values
argument_list|,
name|mq
argument_list|,
name|colAll
argument_list|,
literal|false
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|handler
operator|.
name|areColumnsUnique
argument_list|(
name|values
argument_list|,
name|mq
argument_list|,
name|colNone
argument_list|,
literal|false
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|addRow
parameter_list|(
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|builder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexLiteral
argument_list|>
name|b
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|varcharType
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
specifier|final
name|RexLiteral
name|literal
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|literal
operator|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|varcharType
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|literal
operator|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|literal
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|add
argument_list|(
name|literal
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|b
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMetadataQuery#getAverageColumnSizes(org.apache.calcite.rel.RelNode)},    * {@link org.apache.calcite.rel.metadata.RelMetadataQuery#getAverageRowSize(org.apache.calcite.rel.RelNode)}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAverageRowSize
parameter_list|()
block|{
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|sql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
parameter_list|(
name|cluster
parameter_list|,
name|relOptSchema
parameter_list|,
name|rootSchema
parameter_list|)
lambda|->
block|{
name|checkAverageRowSize
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkAverageRowSize
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|cluster
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|Double
name|rowSize
init|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|empScan
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Double
argument_list|>
name|columnSizes
init|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|empScan
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|empScan
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|40.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|89.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Empty values
specifier|final
name|LogicalValues
name|emptyValues
init|=
name|LogicalValues
operator|.
name|createEmpty
argument_list|(
name|cluster
argument_list|,
name|empTable
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|emptyValues
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|emptyValues
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|emptyValues
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|40.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|89.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Values
specifier|final
name|RelDataType
name|rowType
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tuples
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|1
argument_list|,
literal|"1234567890"
argument_list|,
literal|"ABC"
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|2
argument_list|,
literal|"1"
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|3
argument_list|,
literal|"2"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|LogicalValues
name|values
init|=
name|LogicalValues
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|tuples
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|values
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|3.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|15.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Union
specifier|final
name|LogicalUnion
name|union
init|=
name|LogicalUnion
operator|.
name|create
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|empScan
argument_list|,
name|emptyValues
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|union
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|union
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|40.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|89.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Filter
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LogicalFilter
name|filter
init|=
name|LogicalFilter
operator|.
name|create
argument_list|(
name|deptScan
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|deptScan
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|TEN
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|20.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|24.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Project
specifier|final
name|LogicalProject
name|deptProject
init|=
name|LogicalProject
operator|.
name|create
argument_list|(
name|filter
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|filter
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|filter
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|filter
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHAR_LENGTH
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|filter
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
literal|null
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|deptProject
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|deptProject
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|32.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Join
specifier|final
name|LogicalJoin
name|join
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|empScan
argument_list|,
name|deptProject
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|join
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|join
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|13
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|40.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|1.0
argument_list|,
literal|4.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|121.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Aggregate
specifier|final
name|LogicalAggregate
name|aggregate
init|=
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|join
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|bitSetOf
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|AggregateCall
operator|.
name|create
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|ImmutableIntList
operator|.
name|of
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|RelCollations
operator|.
name|EMPTY
argument_list|,
literal|2
argument_list|,
name|join
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|aggregate
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|aggregate
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|20.0
argument_list|,
literal|8.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|32.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Smoke test Parallelism and Memory metadata providers
name|assertThat
argument_list|(
name|mq
operator|.
name|memory
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|cumulativeMemoryWithinPhase
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|cumulativeMemoryWithinPhaseSplit
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|isPhaseTransition
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|splitCount
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMdPredicates#getPredicates(Join, RelMetadataQuery)}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPredicates
parameter_list|()
block|{
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|sql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
parameter_list|(
name|cluster
parameter_list|,
name|relOptSchema
parameter_list|,
name|rootSchema
parameter_list|)
lambda|->
block|{
name|checkPredicates
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkPredicates
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|proto
argument_list|()
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|cluster
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|empScan
argument_list|)
expr_stmt|;
name|RelOptPredicateList
name|predicates
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|empScan
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|filter
argument_list|(
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|literal
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|filter
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1)]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|semiJoin
argument_list|(
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalJoin
name|semiJoin
init|=
operator|(
name|LogicalJoin
operator|)
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|semiJoin
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1)]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|leftInferredPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|rightInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create a Join similar to the previous SemiJoin
name|relBuilder
operator|.
name|push
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|project
argument_list|)
expr_stmt|;
comment|// No inferred predicates, because we already know DEPTNO is NOT NULL
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"RecordType(INTEGER NOT NULL DEPTNO) NOT NULL"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|leftInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|rightInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create a Join similar to the previous Join, but joining on MGR, which
comment|// is nullable. From the join condition "e.MGR = d.DEPTNO" we can deduce
comment|// the projected predicate "IS NOT NULL($0)".
name|relBuilder
operator|.
name|push
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"MGR"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"MGR"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project2
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|project2
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[IS NOT NULL($0)]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|leftInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|rightInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create another similar Join. From the join condition
comment|//   e.MGR - e.EMPNO = d.DEPTNO + e.MGR_COMM
comment|// we can deduce the projected predicate
comment|//   MGR IS NOT NULL OR MGR_COMM IS NOT NULL
comment|//
comment|// EMPNO is omitted because it is NOT NULL.
comment|// MGR_COMM is a made-up nullable field.
name|relBuilder
operator|.
name|push
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|Iterables
operator|.
name|concat
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|relBuilder
operator|.
name|alias
argument_list|(
name|relBuilder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"MGR"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
argument_list|,
literal|"MGR_COMM"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"MGR"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"MGR_COMM"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"MGR"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"NAME"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"MGR_COMM"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project3
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|project3
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[OR(IS NOT NULL($0), IS NOT NULL($2))]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|leftInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|rightInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Unit test for    * {@link org.apache.calcite.rel.metadata.RelMdPredicates#getPredicates(Aggregate, RelMetadataQuery)}.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromAggregation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a, max(b) from (\n"
operator|+
literal|"  select 1 as a, 2 as b from emp)subq\n"
operator|+
literal|"group by a"
decl_stmt|;
specifier|final
name|Aggregate
name|rel
init|=
operator|(
name|Aggregate
operator|)
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|pulledUpPredicates
init|=
name|inputSet
operator|.
name|pulledUpPredicates
decl_stmt|;
name|assertThat
argument_list|(
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1960">[CALCITE-1960]    * RelMdPredicates.getPredicates is slow if there are many equivalent    * columns</a>. There are much less duplicates after    *<a href="https://issues.apache.org/jira/browse/CALCITE-2205">[CALCITE-2205]</a>.    * Since this is a performance problem, the test result does not    * change, but takes over 15 minutes before the fix and 6 seconds after. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesForExprsItr
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.EMPNO, a.ENAME\n"
operator|+
literal|"from (select * from sales.emp ) a\n"
operator|+
literal|"join (select * from sales.emp  ) b\n"
operator|+
literal|"on a.empno = b.deptno\n"
operator|+
literal|"  and a.comm = b.comm\n"
operator|+
literal|"  and a.mgr=b.mgr\n"
operator|+
literal|"  and (a.empno< 10 or a.comm< 3 or a.deptno< 10\n"
operator|+
literal|"    or a.job ='abc' or a.ename='abc' or a.sal='30' or a.mgr>3\n"
operator|+
literal|"    or a.slacker is not null  or a.HIREDATE is not null\n"
operator|+
literal|"    or b.empno< 9 or b.comm< 3 or b.deptno< 10 or b.job ='abc'\n"
operator|+
literal|"    or b.ename='abc' or b.sal='30' or b.mgr>3 or b.slacker )\n"
operator|+
literal|"join emp c\n"
operator|+
literal|"on b.mgr =a.mgr and a.empno =b.deptno and a.comm=b.comm\n"
operator|+
literal|"  and a.deptno=b.deptno and a.job=b.job and a.ename=b.ename\n"
operator|+
literal|"  and a.mgr=b.deptno and a.slacker=b.slacker"
decl_stmt|;
comment|// Lock to ensure that only one test is using this method at a time.
try|try
init|(
name|JdbcAdapterTest
operator|.
name|LockWrapper
name|ignore
init|=
name|JdbcAdapterTest
operator|.
name|LockWrapper
operator|.
name|lock
argument_list|(
name|LOCK
argument_list|)
init|)
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|11
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesOnConstant
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, mgr, x, 'y' as y, z from (\n"
operator|+
literal|"  select deptno, mgr, cast(null as integer) as x, cast('1' as int) as z\n"
operator|+
literal|"  from emp\n"
operator|+
literal|"  where mgr is null and deptno< 10)"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|list
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|list
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[<($0, 10), =($3, 'y'), =($4, 1), IS NULL($1), IS NULL($2)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesOnNullableConstant
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select nullif(1, 1) as c\n"
operator|+
literal|"  from emp\n"
operator|+
literal|"  where mgr is null and deptno< 10"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|list
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
comment|// Uses "IS NOT DISTINCT FROM" rather than "=" because cannot guarantee not null.
name|assertThat
argument_list|(
name|list
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[IS NULL($0)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromUnion0
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|""
operator|+
literal|"select empno from emp where empno=1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select empno from emp where empno=1"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromUnion1
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|""
operator|+
literal|"select empno, deptno from emp where empno=1 or deptno=2\n"
operator|+
literal|"union all\n"
operator|+
literal|"select empno, deptno from emp where empno=3 or deptno=4"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[OR(SEARCH($0, Sarg[1, 3]), SEARCH($1, Sarg[2, 4]))]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromUnion2
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|""
operator|+
literal|"select empno, comm, deptno from emp where empno=1 and comm=2 and deptno=3\n"
operator|+
literal|"union all\n"
operator|+
literal|"select empno, comm, deptno from emp where empno=1 and comm=4"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
operator|.
name|pulledUpPredicates
argument_list|,
comment|// Because the hashCode for
comment|// OR(AND(=($1, 2), =($2, 3)) and
comment|// OR(AND(=($2, 3), =($1, 2)) are the same, the result is flipped and not stable,
comment|// but they both are correct.
name|anyOf
argument_list|(
name|sortsAs
argument_list|(
literal|"[=($0, 1), OR(AND(=($1, 2), =($2, 3)), =($1, 4))]"
argument_list|)
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1), OR(AND(=($2, 3), =($1, 2)), =($1, 4))]"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromIntersect0
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|""
operator|+
literal|"select empno from emp where empno=1\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select empno from emp where empno=1"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromIntersect1
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|""
operator|+
literal|"select empno, deptno, comm from emp where empno=1 and deptno=2\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select empno, deptno, comm from emp where empno=1 and comm=3"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1), =($1, 2), =($2, 3)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromIntersect2
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|""
operator|+
literal|"select empno, deptno, comm from emp where empno=1 and deptno=2\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select empno, deptno, comm from emp where 1=empno and (deptno=2 or comm=3)"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1), =($1, 2)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromIntersect3
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|""
operator|+
literal|"select empno, deptno, comm from emp where empno=1 or deptno=2\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select empno, deptno, comm from emp where deptno=2 or empno=1 or comm=3"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[OR(=($0, 1), =($1, 2))]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullUpPredicatesFromMinus
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|""
operator|+
literal|"select empno, deptno, comm from emp where empno=1 and deptno=2\n"
operator|+
literal|"except all\n"
operator|+
literal|"select empno, deptno, comm from emp where comm=3"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1), =($1, 2)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDistributionSimple
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select * from emp where deptno = 10"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelDistribution
name|d
init|=
name|mq
operator|.
name|getDistribution
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|d
argument_list|,
name|is
argument_list|(
name|RelDistributions
operator|.
name|BROADCAST_DISTRIBUTED
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDistributionHash
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelDistribution
name|dist
init|=
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|LogicalExchange
name|exchange
init|=
name|LogicalExchange
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|dist
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelDistribution
name|d
init|=
name|mq
operator|.
name|getDistribution
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|d
argument_list|,
name|is
argument_list|(
name|dist
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDistributionHashEmpty
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelDistribution
name|dist
init|=
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LogicalExchange
name|exchange
init|=
name|LogicalExchange
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|dist
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelDistribution
name|d
init|=
name|mq
operator|.
name|getDistribution
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|d
argument_list|,
name|is
argument_list|(
name|dist
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDistributionSingleton
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelDistribution
name|dist
init|=
name|RelDistributions
operator|.
name|SINGLETON
decl_stmt|;
specifier|final
name|LogicalExchange
name|exchange
init|=
name|LogicalExchange
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|dist
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelDistribution
name|d
init|=
name|mq
operator|.
name|getDistribution
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|d
argument_list|,
name|is
argument_list|(
name|dist
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Unit test for {@link RelMdUtil#linear(int, int, int, double, double)}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testLinear
parameter_list|()
block|{
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|100d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|150d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|160d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|200d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|100d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|12
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|200d
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ----------------------------------------------------------------------
end_comment

begin_comment
comment|// Tests for getExpressionLineage
end_comment

begin_comment
comment|// ----------------------------------------------------------------------
end_comment

begin_function
specifier|private
name|void
name|assertExpressionLineage
parameter_list|(
name|String
name|sql
parameter_list|,
name|int
name|columnIndex
parameter_list|,
name|String
name|expected
parameter_list|,
name|String
name|comment
parameter_list|)
block|{
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|columnIndex
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"Lineage for expr '"
operator|+
name|ref
operator|+
literal|"' in node '"
operator|+
name|rel
operator|+
literal|"'"
operator|+
literal|" for query '"
operator|+
name|sql
operator|+
literal|"': "
operator|+
name|comment
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|r
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-5392">[CALCITE-5392]    * Support Snapshot in RelMdExpressionLineage</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageSnapshot
parameter_list|()
block|{
name|String
name|expected
init|=
literal|"[[CATALOG, SALES, PRODUCTS_TEMPORAL].#0.$0]"
decl_stmt|;
name|String
name|comment
init|=
literal|"'productid' is column 0 in 'catalog.sales.products_temporal'"
decl_stmt|;
name|assertExpressionLineage
argument_list|(
literal|"select productid from products_temporal\n"
operator|+
literal|"for system_time as of TIMESTAMP '2011-01-02 00:00:00'"
argument_list|,
literal|0
argument_list|,
name|expected
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageStar
parameter_list|()
block|{
comment|// All columns in output
specifier|final
name|RelNode
name|tableRel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|tableRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|4
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|tableRel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|4
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|endsWith
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageTwoColumns
parameter_list|()
block|{
comment|// mgr is column 3 in catalog.sales.emp
comment|// deptno is column 7 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select mgr, deptno from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref1
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r1
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r1
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result1
init|=
operator|(
name|RexTableInputRef
operator|)
name|r1
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|ref2
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r2
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r2
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result2
init|=
operator|(
name|RexTableInputRef
operator|)
name|r2
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|is
argument_list|(
name|result2
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageTwoColumnsSwapped
parameter_list|()
block|{
comment|// deptno is column 7 in catalog.sales.emp
comment|// mgr is column 3 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select deptno, mgr from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref1
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r1
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r1
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result1
init|=
operator|(
name|RexTableInputRef
operator|)
name|r1
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|ref2
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r2
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r2
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result2
init|=
operator|(
name|RexTableInputRef
operator|)
name|r2
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|is
argument_list|(
name|result2
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageCombineTwoColumns
parameter_list|()
block|{
comment|// empno is column 0 in catalog.sales.emp
comment|// deptno is column 7 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select empno + deptno from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|result
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getKind
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlKind
operator|.
name|PLUS
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|result
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef2
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|is
argument_list|(
name|inputRef2
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageConjuntiveExpression
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select (empno = 1 or ename = 'abc') and deptno> 1 from emp"
decl_stmt|;
name|String
name|expected
init|=
literal|"[AND(OR(=([CATALOG, SALES, EMP].#0.$0, 1), "
operator|+
literal|"=([CATALOG, SALES, EMP].#0.$1, 'abc')), "
operator|+
literal|">([CATALOG, SALES, EMP].#0.$7, 1))]"
decl_stmt|;
name|String
name|comment
init|=
literal|"'empno' is column 0 in 'catalog.sales.emp', "
operator|+
literal|"'ename' is column 1 in 'catalog.sales.emp', and "
operator|+
literal|"'deptno' is column 7 in 'catalog.sales.emp'"
decl_stmt|;
name|assertExpressionLineage
argument_list|(
name|sql
argument_list|,
literal|0
argument_list|,
name|expected
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageBetweenExpressionWithJoin
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select dept.deptno + empno between 1 and 2"
operator|+
literal|" from emp join dept on emp.deptno = dept.deptno"
decl_stmt|;
name|String
name|expected
init|=
literal|"[AND(>=(+([CATALOG, SALES, DEPT].#0.$0, [CATALOG, SALES, EMP].#0.$0), 1),"
operator|+
literal|"<=(+([CATALOG, SALES, DEPT].#0.$0, [CATALOG, SALES, EMP].#0.$0), 2))]"
decl_stmt|;
name|String
name|comment
init|=
literal|"'empno' is column 0 in 'catalog.sales.emp', "
operator|+
literal|"'deptno' is column 0 in 'catalog.sales.dept', and "
operator|+
literal|"'dept.deptno + empno between 1 and 2' is translated into "
operator|+
literal|"'dept.deptno + empno>= 1 and dept.deptno + empno<= 2'"
decl_stmt|;
name|assertExpressionLineage
argument_list|(
name|sql
argument_list|,
literal|0
argument_list|,
name|expected
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageInnerJoinLeft
parameter_list|()
block|{
comment|// ename is column 1 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select ename from emp,dept"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result
init|=
operator|(
name|RexTableInputRef
operator|)
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageInnerJoinRight
parameter_list|()
block|{
comment|// ename is column 0 in catalog.sales.bonus
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select bonus.ename from emp join bonus using (ename)"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result
init|=
operator|(
name|RexTableInputRef
operator|)
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"CATALOG"
argument_list|,
literal|"SALES"
argument_list|,
literal|"BONUS"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageLeftJoinLeft
parameter_list|()
block|{
comment|// ename is column 1 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select ename from emp left join dept using (deptno)"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result
init|=
operator|(
name|RexTableInputRef
operator|)
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageRightJoinRight
parameter_list|()
block|{
comment|// ename is column 0 in catalog.sales.bonus
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select bonus.ename from emp right join bonus using (ename)"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result
init|=
operator|(
name|RexTableInputRef
operator|)
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"CATALOG"
argument_list|,
literal|"SALES"
argument_list|,
literal|"BONUS"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageSelfJoin
parameter_list|()
block|{
comment|// deptno is column 7 in catalog.sales.emp
comment|// sal is column 5 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select a.deptno, b.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"inner join (select * from emp limit 2) as b\n"
operator|+
literal|"on a.deptno = b.deptno"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|tableRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref1
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r1
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef1
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|7
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r1
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString1
init|=
name|r1
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString1
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString1
argument_list|,
name|endsWith
argument_list|(
name|inputRef1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|ref2
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r2
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref2
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef2
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|5
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r2
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString2
init|=
name|r2
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString2
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString2
argument_list|,
name|endsWith
argument_list|(
name|inputRef2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
operator|(
operator|(
name|RexTableInputRef
operator|)
name|r1
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|not
argument_list|(
operator|(
operator|(
name|RexTableInputRef
operator|)
name|r2
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageOuterJoin
parameter_list|()
block|{
comment|// lineage cannot be determined
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select name as dname from emp left outer join dept"
operator|+
literal|" on emp.deptno = dept.deptno"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageFilter
parameter_list|()
block|{
comment|// ename is column 1 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select ename from emp where deptno = 10"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|endsWith
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageAggregateGroupColumn
parameter_list|()
block|{
comment|// deptno is column 7 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|7
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|endsWith
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageAggregateAggColumn
parameter_list|()
block|{
comment|// lineage cannot be determined
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageUnion
parameter_list|()
block|{
comment|// sal is column 5 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select sal from (\n"
operator|+
literal|"  select * from emp union all select * from emp) "
operator|+
literal|"where deptno = 10"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
init|=
name|sql
argument_list|(
literal|"select * from emp"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|5
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|result
range|:
name|r
control|)
block|{
specifier|final
name|String
name|resultString
init|=
name|result
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|endsWith
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|RexNode
argument_list|>
name|it
init|=
name|r
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
operator|(
operator|(
name|RexTableInputRef
operator|)
name|it
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|not
argument_list|(
operator|(
operator|(
name|RexTableInputRef
operator|)
name|it
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageMultiUnion
parameter_list|()
block|{
comment|// empno is column 0 in catalog.sales.emp
comment|// sal is column 5 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select a.empno + b.sal from\n"
operator|+
literal|" (select empno, ename from emp,dept) a join "
operator|+
literal|" (select * from emp union all select * from emp) b\n"
operator|+
literal|" on a.empno = b.empno\n"
operator|+
literal|" where b.deptno = 10"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
comment|// With the union, we should get two origins
comment|// The first one should be the same one: join
comment|// The second should come from each union input
specifier|final
name|Set
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|result
range|:
name|r
control|)
block|{
name|assertThat
argument_list|(
name|result
operator|.
name|getKind
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlKind
operator|.
name|PLUS
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|result
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add join alpha to set
name|set
operator|.
name|add
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef2
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|not
argument_list|(
name|inputRef2
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|set
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageValues
parameter_list|()
block|{
comment|// lineage cannot be determined
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select * from (values (1), (2)) as t(c)"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpressionLineageCalc
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select sal from (\n"
operator|+
literal|" select deptno, empno, sal + 1 as sal, job from emp) "
operator|+
literal|"where deptno = 10"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|HepProgramBuilder
name|programBuilder
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
decl_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_TO_CALC
argument_list|)
expr_stmt|;
name|programBuilder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|CALC_MERGE
argument_list|)
expr_stmt|;
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|programBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|rel
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|optimizedRel
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|optimizedRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|optimizedRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|optimizedRel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|is
argument_list|(
literal|"+([CATALOG, SALES, EMP].#0.$5, 1)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicates
parameter_list|()
block|{
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|sql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
parameter_list|(
name|cluster
parameter_list|,
name|relOptSchema
parameter_list|,
name|rootSchema
parameter_list|)
lambda|->
block|{
name|checkAllPredicates
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkAllPredicates
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|proto
argument_list|()
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|cluster
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|empScan
argument_list|)
expr_stmt|;
name|RelOptPredicateList
name|predicates
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|empScan
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|filter
argument_list|(
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|literal
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|filter
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|project
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// From Filter
name|call
operator|=
operator|(
name|RexCall
operator|)
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|inputRef1
operator|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// From Join
name|call
operator|=
operator|(
name|RexCall
operator|)
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|inputRef1
operator|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|RexTableInputRef
name|inputRef2
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"CATALOG"
argument_list|,
literal|"SALES"
argument_list|,
literal|"DEPT"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesAggregate1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a, max(b) from (\n"
operator|+
literal|"  select empno as a, sal as b from emp where empno = 5)subq\n"
operator|+
literal|"group by a"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|pulledUpPredicates
init|=
name|inputSet
operator|.
name|pulledUpPredicates
decl_stmt|;
name|assertThat
argument_list|(
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|is
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexLiteral
name|constant
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|constant
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"5"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesAggregate2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select a, max(b) from (\n"
operator|+
literal|"  select empno as a, sal as b from emp)subq\n"
operator|+
literal|"group by a)\n"
operator|+
literal|"where a = 5"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|pulledUpPredicates
init|=
name|inputSet
operator|.
name|pulledUpPredicates
decl_stmt|;
name|assertThat
argument_list|(
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexLiteral
name|constant
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|constant
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"5"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesAggregate3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select a, max(b) as b from (\n"
operator|+
literal|"  select empno as a, sal as b from emp)subq\n"
operator|+
literal|"group by a)\n"
operator|+
literal|"where b = 5"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
comment|// Filter on aggregate, we cannot infer lineage
name|assertNull
argument_list|(
name|inputSet
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesAndTablesJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select x.sal, y.deptno from\n"
operator|+
literal|"(select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno) as x\n"
operator|+
literal|"inner join\n"
operator|+
literal|"(select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno) as y\n"
operator|+
literal|"on x.deptno = y.deptno"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=([CATALOG, SALES, EMP].#0.$7, [CATALOG, SALES, EMP].#1.$7), "
operator|+
literal|"=([CATALOG, SALES, EMP].#0.$7, [CATALOG, SALES, EMP].#2.$7), "
operator|+
literal|"=([CATALOG, SALES, EMP].#2.$7, [CATALOG, SALES, EMP].#3.$7), "
operator|+
literal|"true, "
operator|+
literal|"true]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[CATALOG, SALES, DEPT].#0, [CATALOG, SALES, DEPT].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#0, [CATALOG, SALES, EMP].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#2, [CATALOG, SALES, EMP].#3]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesAndTablesCalc
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno as a, sal as b from emp where empno> 5"
decl_stmt|;
specifier|final
name|RelNode
name|relNode
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|hepProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_TO_CALC
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|hepProgram
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|relNode
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[>([CATALOG, SALES, EMP].#0.$0, 5)]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[CATALOG, SALES, EMP].#0]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesAndTableUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno\n"
operator|+
literal|"union all\n"
operator|+
literal|"select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno"
decl_stmt|;
name|checkAllPredicatesAndTableSetOp
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesAndTableIntersect
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno"
decl_stmt|;
name|checkAllPredicatesAndTableSetOp
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesAndTableMinus
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno\n"
operator|+
literal|"except all\n"
operator|+
literal|"select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno"
decl_stmt|;
name|checkAllPredicatesAndTableSetOp
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|checkAllPredicatesAndTableSetOp
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=([CATALOG, SALES, EMP].#0.$7, [CATALOG, SALES, EMP].#1.$7),"
operator|+
literal|" =([CATALOG, SALES, EMP].#2.$7, [CATALOG, SALES, EMP].#3.$7), "
operator|+
literal|"true, "
operator|+
literal|"true]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[CATALOG, SALES, DEPT].#0, [CATALOG, SALES, DEPT].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#0, [CATALOG, SALES, EMP].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#2, [CATALOG, SALES, EMP].#3]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTableReferenceForIntersect
parameter_list|()
block|{
specifier|final
name|String
name|sql1
init|=
literal|"select a.deptno, a.sal from emp a\n"
operator|+
literal|"intersect all select b.deptno, b.sal from emp b where empno = 5"
decl_stmt|;
specifier|final
name|RelNode
name|rel1
init|=
name|sql
argument_list|(
name|sql1
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq1
init|=
name|rel1
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences1
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq1
operator|.
name|getTableReferences
argument_list|(
name|rel1
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences1
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[CATALOG, SALES, EMP].#0, [CATALOG, SALES, EMP].#1]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql2
init|=
literal|"select a.deptno from dept a intersect all select b.deptno from emp b"
decl_stmt|;
specifier|final
name|RelNode
name|rel2
init|=
name|sql
argument_list|(
name|sql2
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq2
init|=
name|rel2
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences2
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq2
operator|.
name|getTableReferences
argument_list|(
name|rel2
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences2
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[CATALOG, SALES, DEPT].#0, [CATALOG, SALES, EMP].#0]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTableReferenceForMinus
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select emp.deptno, emp.sal from emp\n"
operator|+
literal|"except all select emp.deptno, emp.sal from emp where empno = 5"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[CATALOG, SALES, EMP].#0, [CATALOG, SALES, EMP].#1]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesCrossJoinMultiTable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select x.sal from\n"
operator|+
literal|"(select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"cross join (select * from emp where empno = 5 limit 2) as c) as x"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences
argument_list|,
name|sortsAs
argument_list|(
literal|"[[CATALOG, SALES, DEPT].#0, "
operator|+
literal|"[CATALOG, SALES, EMP].#0, "
operator|+
literal|"[CATALOG, SALES, EMP].#1]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
comment|// Note that we reference [CATALOG, SALES, EMP].#1 rather than [CATALOG, SALES, EMP].#0
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=([CATALOG, SALES, EMP].#1.$0, 5), true, true]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTableReferencesJoinUnknownNode
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp limit 10"
decl_stmt|;
specifier|final
name|RelNode
name|node
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|nodeWithUnknown
init|=
operator|new
name|DummyRelNode
argument_list|(
name|node
operator|.
name|getCluster
argument_list|()
argument_list|,
name|node
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|node
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|node
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Join
specifier|final
name|LogicalJoin
name|join
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|nodeWithUnknown
argument_list|,
name|node
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|node
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|join
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|tableReferences
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAllPredicatesUnionMultiTable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select x.sal from\n"
operator|+
literal|"(select a.deptno, a.sal from (select * from emp) as a\n"
operator|+
literal|"union all select emp.deptno, emp.sal from emp\n"
operator|+
literal|"union all select emp.deptno, emp.sal from emp where empno = 5) as x"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences
argument_list|,
name|sortsAs
argument_list|(
literal|"[[CATALOG, SALES, EMP].#0, "
operator|+
literal|"[CATALOG, SALES, EMP].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#2]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Note that we reference [CATALOG, SALES, EMP].#2 rather than
comment|// [CATALOG, SALES, EMP].#0 or [CATALOG, SALES, EMP].#1
specifier|final
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=([CATALOG, SALES, EMP].#2.$0, 5)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTableReferencesUnionUnknownNode
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp limit 10"
decl_stmt|;
specifier|final
name|RelNode
name|node
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|nodeWithUnknown
init|=
operator|new
name|DummyRelNode
argument_list|(
name|node
operator|.
name|getCluster
argument_list|()
argument_list|,
name|node
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|node
argument_list|)
decl_stmt|;
comment|// Union
specifier|final
name|LogicalUnion
name|union
init|=
name|LogicalUnion
operator|.
name|create
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|nodeWithUnknown
argument_list|,
name|node
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|node
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|union
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|tableReferences
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountEmp
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountDept
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from dept"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountValues
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1), (2)) as t(c)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|Values
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountCartesian
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp,dept"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp\n"
operator|+
literal|"inner join dept on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountTableModify
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"insert into emp select * from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|TableModify
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountExchange
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRelTransform
argument_list|(
name|rel
lambda|->
name|LogicalExchange
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Exchange
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountSample
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp tablesample system(50) where empno> 5"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Filter
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Sample
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountJoinFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 14) as emp\n"
operator|+
literal|"inner join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"inner join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountLeftJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"left join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountRightJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"right join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountJoinFiniteEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 7) as emp\n"
operator|+
literal|"inner join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountJoinEmptyEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"inner join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from emp\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name from dept"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Union
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountUnionOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Union
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|4
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountMinusOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"except\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Minus
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|4
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where ename='Mathilda'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Filter
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountSortLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountSortLimitOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10 offset 5"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountSortLimitOffsetOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 12)\n"
operator|+
literal|"order by ename limit 20 offset 5"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountAggregate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountAggregateGroupingSets
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by grouping sets ((deptno), (ename, deptno))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountAggregateEmptyKeyOnEmptyTable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from (select * from emp limit 0)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|2
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Sort
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNodeTypeCountFilterAggregateEmptyKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from emp where 1 = 0"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|assertThatNodeTypeCountIs
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Filter
operator|.
name|class
argument_list|,
literal|1
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testConstColumnsNdv
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, 100, 200 from emp"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|rel
argument_list|,
name|instanceOf
argument_list|(
name|Project
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|rel
decl_stmt|;
name|assertThat
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
comment|// a non-const column, followed by two constant columns.
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLiteral
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLiteral
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLiteral
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// the distinct row count of const columns should be 1
name|assertThat
argument_list|(
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// the population size of const columns should be 1
name|assertThat
argument_list|(
name|mq
operator|.
name|getPopulationSize
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPopulationSize
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPopulationSize
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// the distinct row count of mixed columns depends on the distinct row
comment|// count of non-const columns
name|assertThat
argument_list|(
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|,
name|is
argument_list|(
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|,
name|is
argument_list|(
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// the population size of mixed columns depends on the population size of
comment|// non-const columns
name|assertThat
argument_list|(
name|mq
operator|.
name|getPopulationSize
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
name|mq
operator|.
name|getPopulationSize
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPopulationSize
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
name|mq
operator|.
name|getPopulationSize
argument_list|(
name|rel
argument_list|,
name|bitSetOf
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|private
specifier|static
specifier|final
name|SqlOperator
name|NONDETERMINISTIC_OP
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"NDC"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Tests calling {@link RelMetadataQuery#getTableOrigin} for    * an aggregate with no columns. Previously threw. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testEmptyAggregateTableOrigin
parameter_list|()
block|{
specifier|final
name|FrameworkConfig
name|config
init|=
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|RelMetadataQuery
name|mq
init|=
name|builder
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|RelNode
name|agg
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|tableOrigin
init|=
name|mq
operator|.
name|getTableOrigin
argument_list|(
name|agg
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableOrigin
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testGetPredicatesForJoin
parameter_list|()
block|{
specifier|final
name|FrameworkConfig
name|config
init|=
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|RelNode
name|join
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|NONDETERMINISTIC_OP
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelMetadataQuery
name|mq
init|=
name|join
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|join
argument_list|)
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|RelNode
name|join1
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|join1
argument_list|)
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"=($0, $8)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testGetPredicatesForFilter
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|FrameworkConfig
name|config
init|=
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|RelNode
name|filter
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|NONDETERMINISTIC_OP
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelMetadataQuery
name|mq
init|=
name|filter
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|filter
argument_list|)
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|RelNode
name|filter1
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|filter1
argument_list|)
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"=($0, $1)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4315">[CALCITE-4315]    * NPE in RelMdUtil#checkInputForCollationAndLimit</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testCheckInputForCollationAndLimit
parameter_list|()
block|{
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|sql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
parameter_list|(
name|cluster
parameter_list|,
name|relOptSchema
parameter_list|,
name|rootSchema
parameter_list|)
lambda|->
block|{
name|checkInputForCollationAndLimit
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMetadataQuery#getAverageColumnSizes(org.apache.calcite.rel.RelNode)}    * with a table that has its own implementation of {@link BuiltInMetadata.Size}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testCustomizedAverageColumnSizes
parameter_list|()
block|{
name|SqlTestFactory
operator|.
name|CatalogReaderFactory
name|factory
init|=
parameter_list|(
name|typeFactory
parameter_list|,
name|caseSensitive
parameter_list|)
lambda|->
block|{
name|CompositeKeysCatalogReader
name|catalogReader
init|=
operator|new
name|CompositeKeysCatalogReader
argument_list|(
name|typeFactory
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalogReader
operator|.
name|init
argument_list|()
expr_stmt|;
return|return
name|catalogReader
return|;
block|}
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select key1, key2 from s.composite_keys_table"
argument_list|)
operator|.
name|withCatalogReaderFactory
argument_list|(
name|factory
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Double
argument_list|>
name|columnSizes
init|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|3.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMetadataQuery#getDistinctRowCount(RelNode, ImmutableBitSet, RexNode)}    * with a table that has its own implementation of {@link BuiltInMetadata.Size}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testCustomizedDistinctRowcount
parameter_list|()
block|{
name|SqlTestFactory
operator|.
name|CatalogReaderFactory
name|factory
init|=
parameter_list|(
name|typeFactory
parameter_list|,
name|caseSensitive
parameter_list|)
lambda|->
block|{
name|CompositeKeysCatalogReader
name|catalogReader
init|=
operator|new
name|CompositeKeysCatalogReader
argument_list|(
name|typeFactory
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|catalogReader
operator|.
name|init
argument_list|()
expr_stmt|;
return|return
name|catalogReader
return|;
block|}
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|sql
argument_list|(
literal|"select key1, key2 from s.composite_keys_table"
argument_list|)
operator|.
name|withCatalogReaderFactory
argument_list|(
name|factory
argument_list|)
operator|.
name|toRel
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|Double
name|ndv
init|=
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|ndv
argument_list|,
name|is
argument_list|(
literal|100.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkInputForCollationAndLimit
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|cluster
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelHint
argument_list|>
name|hints
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|hints
argument_list|)
decl_stmt|;
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|,
name|hints
argument_list|)
decl_stmt|;
specifier|final
name|LogicalJoin
name|join
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|empScan
argument_list|,
name|deptScan
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|RelMdUtil
operator|.
name|checkInputForCollationAndLimit
argument_list|(
name|mq
argument_list|,
name|join
argument_list|,
name|join
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getCollation
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"we are checking a join against its own collation, fetch=null, "
operator|+
literal|"offset=null => checkInputForCollationAndLimit must be "
operator|+
literal|"true. join="
operator|+
name|join
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//~ Inner classes and interfaces -------------------------------------------
end_comment

begin_comment
comment|/** Custom metadata interface. */
end_comment

begin_interface
specifier|public
interface|interface
name|ColType
extends|extends
name|Metadata
block|{
name|Method
name|METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|ColType
operator|.
name|class
argument_list|,
literal|"getColType"
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
name|MetadataDef
argument_list|<
name|ColType
argument_list|>
name|DEF
init|=
name|MetadataDef
operator|.
name|of
argument_list|(
name|ColType
operator|.
name|class
argument_list|,
name|ColType
operator|.
name|Handler
operator|.
name|class
argument_list|,
name|METHOD
argument_list|)
decl_stmt|;
name|String
name|getColType
parameter_list|(
name|int
name|column
parameter_list|)
function_decl|;
comment|/** Handler API. */
interface|interface
name|Handler
extends|extends
name|MetadataHandler
argument_list|<
name|ColType
argument_list|>
block|{
name|String
name|getColType
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|int
name|column
parameter_list|)
function_decl|;
block|}
block|}
end_interface

begin_comment
comment|/** A provider for {@link org.apache.calcite.test.RelMetadataTest.ColType} via    * reflection. */
end_comment

begin_class
specifier|public
specifier|abstract
specifier|static
class|class
name|PartialColTypeImpl
implements|implements
name|MetadataHandler
argument_list|<
name|ColType
argument_list|>
block|{
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|THREAD_LIST
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Deprecated
specifier|public
name|MetadataDef
argument_list|<
name|ColType
argument_list|>
name|getDef
parameter_list|()
block|{
return|return
name|ColType
operator|.
name|DEF
return|;
block|}
comment|/** Implementation of {@link ColType#getColType(int)} for      * {@link org.apache.calcite.rel.logical.LogicalAggregate}, called via      * reflection. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedDeclaration"
argument_list|)
specifier|public
name|String
name|getColType
parameter_list|(
name|Aggregate
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|int
name|column
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|column
argument_list|)
operator|.
name|getName
argument_list|()
operator|+
literal|"-agg"
decl_stmt|;
name|THREAD_LIST
operator|.
name|get
argument_list|()
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
block|}
end_class

begin_comment
comment|/** A provider for {@link org.apache.calcite.test.RelMetadataTest.ColType} via    * reflection. */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|ColTypeImpl
extends|extends
name|PartialColTypeImpl
block|{
specifier|public
specifier|static
specifier|final
name|RelMetadataProvider
name|SOURCE
init|=
name|ReflectiveRelMetadataProvider
operator|.
name|reflectiveSource
argument_list|(
operator|new
name|ColTypeImpl
argument_list|()
argument_list|,
name|ColType
operator|.
name|Handler
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Implementation of {@link ColType#getColType(int)} for      * {@link RelNode}, called via reflection. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedDeclaration"
argument_list|)
specifier|public
name|String
name|getColType
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|int
name|column
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|column
argument_list|)
operator|.
name|getName
argument_list|()
operator|+
literal|"-rel"
decl_stmt|;
name|THREAD_LIST
operator|.
name|get
argument_list|()
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
block|}
end_class

begin_comment
comment|/** Implementation of {@link ColType} that has no fall-back for {@link RelNode}. */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|BrokenColTypeImpl
extends|extends
name|PartialColTypeImpl
block|{
specifier|public
specifier|static
specifier|final
name|RelMetadataProvider
name|SOURCE
init|=
name|ReflectiveRelMetadataProvider
operator|.
name|reflectiveSource
argument_list|(
operator|new
name|BrokenColTypeImpl
argument_list|()
argument_list|,
name|ColType
operator|.
name|Handler
operator|.
name|class
argument_list|)
decl_stmt|;
block|}
end_class

begin_comment
comment|/** Extension to {@link RelMetadataQuery} to support {@link ColType}.    *    *<p>Illustrates how you would package up a user-defined metadata type. */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|MyRelMetadataQuery
extends|extends
name|RelMetadataQuery
block|{
specifier|private
name|ColType
operator|.
name|Handler
name|colTypeHandler
decl_stmt|;
name|MyRelMetadataQuery
parameter_list|(
name|MetadataHandlerProvider
name|provider
parameter_list|)
block|{
name|super
argument_list|(
name|provider
argument_list|)
expr_stmt|;
name|colTypeHandler
operator|=
name|handler
argument_list|(
name|ColType
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|colType
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|column
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|colTypeHandler
operator|.
name|getColType
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|column
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MetadataHandlerProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|colTypeHandler
operator|=
name|revise
argument_list|(
name|ColType
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * Dummy rel node used for testing.    */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|DummyRelNode
extends|extends
name|SingleRel
block|{
comment|/**      * Creates a<code>DummyRelNode</code>.      */
name|DummyRelNode
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelTraitSet
name|traits
parameter_list|,
name|RelNode
name|input
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|traits
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/** Mock catalog reader for registering a table with composite keys. */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|CompositeKeysCatalogReader
extends|extends
name|MockCatalogReaderSimple
block|{
name|CompositeKeysCatalogReader
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
name|super
argument_list|(
name|typeFactory
argument_list|,
name|caseSensitive
argument_list|)
expr_stmt|;
block|}
comment|/** Creates and initializes a CompositeKeysCatalogReader. */
specifier|public
specifier|static
annotation|@
name|NonNull
name|CompositeKeysCatalogReader
name|create
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
return|return
operator|new
name|CompositeKeysCatalogReader
argument_list|(
name|typeFactory
argument_list|,
name|caseSensitive
argument_list|)
operator|.
name|init
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|CompositeKeysCatalogReader
name|init
parameter_list|()
block|{
name|super
operator|.
name|init
argument_list|()
expr_stmt|;
name|MockSchema
name|tSchema
init|=
operator|new
name|MockSchema
argument_list|(
literal|"s"
argument_list|)
decl_stmt|;
name|registerSchema
argument_list|(
name|tSchema
argument_list|)
expr_stmt|;
comment|// Register "T1" table.
specifier|final
name|MockTable
name|t1
init|=
name|MockTable
operator|.
name|create
argument_list|(
name|this
argument_list|,
name|tSchema
argument_list|,
literal|"composite_keys_table"
argument_list|,
literal|false
argument_list|,
literal|7.0
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|t1
operator|.
name|addColumn
argument_list|(
literal|"key1"
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|t1
operator|.
name|addColumn
argument_list|(
literal|"key2"
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|t1
operator|.
name|addColumn
argument_list|(
literal|"value1"
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|)
expr_stmt|;
name|addSizeHandler
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|addDistinctRowcountHandler
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|addUniqueKeyHandler
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|registerTable
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
name|void
name|addSizeHandler
parameter_list|(
name|MockTable
name|table
parameter_list|)
block|{
name|table
operator|.
name|addWrap
argument_list|(
operator|new
name|BuiltInMetadata
operator|.
name|Size
operator|.
name|Handler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|Double
name|averageRowSize
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|List
argument_list|<
annotation|@
name|Nullable
name|Double
argument_list|>
name|averageColumnSizes
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|List
argument_list|<
name|Double
argument_list|>
name|colSize
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|colSize
operator|.
name|add
argument_list|(
literal|2D
argument_list|)
expr_stmt|;
name|colSize
operator|.
name|add
argument_list|(
literal|3D
argument_list|)
expr_stmt|;
return|return
name|colSize
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addDistinctRowcountHandler
parameter_list|(
name|MockTable
name|table
parameter_list|)
block|{
name|table
operator|.
name|addWrap
argument_list|(
operator|new
name|BuiltInMetadata
operator|.
name|DistinctRowCount
operator|.
name|Handler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|Double
name|getDistinctRowCount
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|ImmutableBitSet
name|groupKey
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|predicate
parameter_list|)
block|{
return|return
literal|100D
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addUniqueKeyHandler
parameter_list|(
name|MockTable
name|table
parameter_list|)
block|{
name|table
operator|.
name|addWrap
argument_list|(
operator|new
name|BuiltInMetadata
operator|.
name|UniqueKeys
operator|.
name|Handler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|getUniqueKeys
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
end_class

unit|}
end_unit

