begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableMergeJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|InvalidRelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistribution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistributions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SemiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|CachingRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ChainedRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|DefaultRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|JaninoRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|MetadataDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|MetadataHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ReflectiveRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelColumnOrigin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|FrameworkConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|SaffronProperties
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|CustomTypeSafeMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|core
operator|.
name|Is
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|within
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|endsWith
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|instanceOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|isA
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|notNullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|nullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|startsWith
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Unit test for {@link DefaultRelMetadataProvider}. See  * {@link SqlToRelTestBase} class comments for details on the schema used. Note  * that no optimizer rules are fired on the translation of the SQL into  * relational algebra (e.g. join conditions in the WHERE clause will look like  * filters), so it's necessary to phrase the SQL carefully.  */
end_comment

begin_class
specifier|public
class|class
name|RelMetadataTest
extends|extends
name|SqlToRelTestBase
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|double
name|EPSILON
init|=
literal|1.0e-5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_EQUAL_SELECTIVITY
init|=
literal|0.15
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_EQUAL_SELECTIVITY_SQUARED
init|=
name|DEFAULT_EQUAL_SELECTIVITY
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_COMP_SELECTIVITY
init|=
literal|0.5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_NOTNULL_SELECTIVITY
init|=
literal|0.9
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_SELECTIVITY
init|=
literal|0.25
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|EMP_SIZE
init|=
literal|14d
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|DEPT_SIZE
init|=
literal|4d
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_QNAME
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"CATALOG"
argument_list|,
literal|"SALES"
argument_list|,
literal|"EMP"
argument_list|)
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|// ----------------------------------------------------------------------
comment|// Tests for getPercentageOriginalRows
comment|// ----------------------------------------------------------------------
specifier|private
name|RelNode
name|convertSql
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
specifier|final
name|RelRoot
name|root
init|=
name|tester
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|root
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|setMetadataProvider
argument_list|(
name|DefaultRelMetadataProvider
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
return|return
name|root
operator|.
name|rel
return|;
block|}
specifier|private
name|void
name|checkPercentageOriginalRows
parameter_list|(
name|String
name|sql
parameter_list|,
name|double
name|expected
parameter_list|)
block|{
name|checkPercentageOriginalRows
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
name|EPSILON
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkPercentageOriginalRows
parameter_list|(
name|String
name|sql
parameter_list|,
name|double
name|expected
parameter_list|,
name|double
name|epsilon
parameter_list|)
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|Double
name|result
init|=
name|mq
operator|.
name|getPercentageOriginalRows
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|result
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsTableOnly
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select * from dept"
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsAgg
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select deptno from dept group by deptno"
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsOneFilter
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select * from dept where deptno = 20"
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsTwoFilters
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select * from (\n"
operator|+
literal|"  select * from dept where name='X')\n"
operator|+
literal|"where deptno = 20"
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY_SQUARED
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsRedundantFilter
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select * from (\n"
operator|+
literal|"  select * from dept where deptno=20)\n"
operator|+
literal|"where deptno = 20"
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsJoin
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select * from emp inner join dept on emp.deptno=dept.deptno"
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsJoinTwoFilters
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select * from (\n"
operator|+
literal|"  select * from emp where deptno=10) e\n"
operator|+
literal|"inner join (select * from dept where deptno=10) d\n"
operator|+
literal|"on e.deptno=d.deptno"
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY_SQUARED
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsUnionNoFilter
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select name from dept union all select ename from emp"
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsUnionLittleFilter
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select name from dept where deptno=20"
operator|+
literal|" union all select ename from emp"
argument_list|,
operator|(
operator|(
name|DEPT_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
operator|)
operator|+
name|EMP_SIZE
operator|)
operator|/
operator|(
name|DEPT_SIZE
operator|+
name|EMP_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testPercentageOriginalRowsUnionBigFilter
parameter_list|()
block|{
name|checkPercentageOriginalRows
argument_list|(
literal|"select name from dept"
operator|+
literal|" union all select ename from emp where deptno=20"
argument_list|,
operator|(
operator|(
name|EMP_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
operator|)
operator|+
name|DEPT_SIZE
operator|)
operator|/
operator|(
name|DEPT_SIZE
operator|+
name|EMP_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|// ----------------------------------------------------------------------
comment|// Tests for getColumnOrigins
comment|// ----------------------------------------------------------------------
specifier|private
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|checkColumnOrigin
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
return|return
name|mq
operator|.
name|getColumnOrigins
argument_list|(
name|rel
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|private
name|void
name|checkNoColumnOrigin
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|result
init|=
name|checkColumnOrigin
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|checkColumnOrigin
parameter_list|(
name|RelColumnOrigin
name|rco
parameter_list|,
name|String
name|expectedTableName
parameter_list|,
name|String
name|expectedColumnName
parameter_list|,
name|boolean
name|expectedDerived
parameter_list|)
block|{
name|RelOptTable
name|actualTable
init|=
name|rco
operator|.
name|getOriginTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|actualTableName
init|=
name|actualTable
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Iterables
operator|.
name|getLast
argument_list|(
name|actualTableName
argument_list|)
argument_list|,
name|expectedTableName
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|actualTable
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|rco
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|expectedColumnName
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|rco
operator|.
name|isDerived
argument_list|()
argument_list|,
name|expectedDerived
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkSingleColumnOrigin
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expectedTableName
parameter_list|,
name|String
name|expectedColumnName
parameter_list|,
name|boolean
name|expectedDerived
parameter_list|)
block|{
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|result
init|=
name|checkColumnOrigin
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|RelColumnOrigin
name|rco
init|=
name|result
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|checkColumnOrigin
argument_list|(
name|rco
argument_list|,
name|expectedTableName
argument_list|,
name|expectedColumnName
argument_list|,
name|expectedDerived
argument_list|)
expr_stmt|;
block|}
comment|// WARNING:  this requires the two table names to be different
specifier|private
name|void
name|checkTwoColumnOrigin
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expectedTableName1
parameter_list|,
name|String
name|expectedColumnName1
parameter_list|,
name|String
name|expectedTableName2
parameter_list|,
name|String
name|expectedColumnName2
parameter_list|,
name|boolean
name|expectedDerived
parameter_list|)
block|{
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|result
init|=
name|checkColumnOrigin
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RelColumnOrigin
name|rco
range|:
name|result
control|)
block|{
name|RelOptTable
name|actualTable
init|=
name|rco
operator|.
name|getOriginTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|actualTableName
init|=
name|actualTable
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
name|String
name|actualUnqualifiedName
init|=
name|Iterables
operator|.
name|getLast
argument_list|(
name|actualTableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|actualUnqualifiedName
operator|.
name|equals
argument_list|(
name|expectedTableName1
argument_list|)
condition|)
block|{
name|checkColumnOrigin
argument_list|(
name|rco
argument_list|,
name|expectedTableName1
argument_list|,
name|expectedColumnName1
argument_list|,
name|expectedDerived
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkColumnOrigin
argument_list|(
name|rco
argument_list|,
name|expectedTableName2
argument_list|,
name|expectedColumnName2
argument_list|,
name|expectedDerived
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsTableOnly
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select name as dname from dept"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsExpression
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select upper(name) as dname from dept"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsDyadicExpression
parameter_list|()
block|{
name|checkTwoColumnOrigin
argument_list|(
literal|"select name||ename from dept,emp"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsConstant
parameter_list|()
block|{
name|checkNoColumnOrigin
argument_list|(
literal|"select 'Minstrelsy' as dname from dept"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsFilter
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select name as dname from dept where deptno=10"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsJoinLeft
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select ename from emp,dept"
argument_list|,
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsJoinRight
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select name as dname from emp,dept"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsJoinOuter
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select name as dname from emp left outer join dept"
operator|+
literal|" on emp.deptno = dept.deptno"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsJoinFullOuter
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select name as dname from emp full outer join dept"
operator|+
literal|" on emp.deptno = dept.deptno"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsAggKey
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select name,count(deptno) from dept group by name"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsAggReduced
parameter_list|()
block|{
name|checkNoColumnOrigin
argument_list|(
literal|"select count(deptno),name from dept group by name"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsAggCountNullable
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select count(mgr),ename from emp group by ename"
argument_list|,
literal|"EMP"
argument_list|,
literal|"MGR"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsAggCountStar
parameter_list|()
block|{
name|checkNoColumnOrigin
argument_list|(
literal|"select count(*),name from dept group by name"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsValues
parameter_list|()
block|{
name|checkNoColumnOrigin
argument_list|(
literal|"values(1,2,3)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsUnion
parameter_list|()
block|{
name|checkTwoColumnOrigin
argument_list|(
literal|"select name from dept union all select ename from emp"
argument_list|,
literal|"DEPT"
argument_list|,
literal|"NAME"
argument_list|,
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testColumnOriginsSelfUnion
parameter_list|()
block|{
name|checkSingleColumnOrigin
argument_list|(
literal|"select ename from emp union all select ename from emp"
argument_list|,
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkRowCount
parameter_list|(
name|String
name|sql
parameter_list|,
name|double
name|expected
parameter_list|,
name|double
name|expectedMin
parameter_list|,
name|double
name|expectedMax
parameter_list|)
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|Double
name|result
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|result
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
specifier|final
name|Double
name|max
init|=
name|mq
operator|.
name|getMaxRowCount
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|max
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedMax
argument_list|,
name|max
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
specifier|final
name|Double
name|min
init|=
name|mq
operator|.
name|getMinRowCount
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|max
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedMin
argument_list|,
name|min
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountEmp
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountDept
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from dept"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|DEPT_SIZE
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountValues
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1), (2)) as t(c)"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountCartesian
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp,dept"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
operator|*
name|DEPT_SIZE
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp\n"
operator|+
literal|"inner join dept on emp.deptno = dept.deptno"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
operator|*
name|DEPT_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountJoinFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 14) as emp\n"
operator|+
literal|"inner join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
operator|*
name|DEPT_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|,
literal|0D
argument_list|,
literal|56D
argument_list|)
expr_stmt|;
comment|// 4 * 14
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"inner join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
comment|// 0, rounded up to row count's minimum 1
literal|0D
argument_list|,
literal|0D
argument_list|)
expr_stmt|;
comment|// 0 * 4
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountLeftJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"left join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
comment|// 0, rounded up to row count's minimum 1
literal|0D
argument_list|,
literal|0D
argument_list|)
expr_stmt|;
comment|// 0 * 4
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountRightJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"right join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
comment|// 0, rounded up to row count's minimum 1
literal|0D
argument_list|,
literal|4D
argument_list|)
expr_stmt|;
comment|// 1 * 4
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountJoinFiniteEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 7) as emp\n"
operator|+
literal|"inner join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
comment|// 0, rounded up to row count's minimum 1
literal|0D
argument_list|,
literal|0D
argument_list|)
expr_stmt|;
comment|// 7 * 0
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountJoinEmptyEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"inner join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
comment|// 0, rounded up to row count's minimum 1
literal|0D
argument_list|,
literal|0D
argument_list|)
expr_stmt|;
comment|// 0 * 0
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from emp\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name from dept"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
operator|+
name|DEPT_SIZE
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountUnionOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
operator|+
name|DEPT_SIZE
argument_list|,
literal|0D
argument_list|,
literal|140D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountIntersectOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|EMP_SIZE
argument_list|,
name|DEPT_SIZE
argument_list|)
argument_list|,
literal|0D
argument_list|,
literal|40D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountMinusOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"except\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|4D
argument_list|,
literal|0D
argument_list|,
literal|100D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where ename='Mathilda'"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountFilterOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 10)\n"
operator|+
literal|"where ename='Mathilda'"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|10D
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|,
literal|0D
argument_list|,
literal|10D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountFilterFalse
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values 'a', 'b') as t(x) where false"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
literal|0D
argument_list|,
literal|0D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountSortHighLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 123456"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
name|EMP_SIZE
argument_list|,
literal|0D
argument_list|,
literal|123456D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountSortHighOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename offset 123456"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountSortHighOffsetLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 5 offset 123456"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
literal|0D
argument_list|,
literal|5D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountSortLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|10d
argument_list|,
literal|0D
argument_list|,
literal|10d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountSortLimit0
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|10d
argument_list|,
literal|0D
argument_list|,
literal|10d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountSortLimitOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10 offset 5"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|9D
comment|/* 14 - 5 */
argument_list|,
literal|0D
argument_list|,
literal|10d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountSortLimitOffsetOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 12)\n"
operator|+
literal|"order by ename limit 20 offset 5"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|7d
argument_list|,
literal|0D
argument_list|,
literal|7d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountAggregate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp group by deptno"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1.4D
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountAggregateGroupingSets
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by grouping sets ((deptno), (ename, deptno))"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|2.8D
argument_list|,
comment|// EMP_SIZE / 10 * 2
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountAggregateGroupingSetsOneEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by grouping sets ((deptno), ())"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|2.8D
argument_list|,
literal|0D
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountAggregateEmptyKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from emp"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
literal|1D
argument_list|,
literal|1D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountFilterAggregateEmptyKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from emp where 1 = 0"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
literal|1D
argument_list|,
literal|1D
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowCountAggregateEmptyKeyOnEmptyTable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from (select * from emp limit 0)"
decl_stmt|;
name|checkRowCount
argument_list|(
name|sql
argument_list|,
literal|1D
argument_list|,
literal|1D
argument_list|,
literal|1D
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkFilterSelectivity
parameter_list|(
name|String
name|sql
parameter_list|,
name|double
name|expected
parameter_list|)
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|Double
name|result
init|=
name|mq
operator|.
name|getSelectivity
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|result
argument_list|,
name|EPSILON
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityIsNotNullFilter
parameter_list|()
block|{
name|checkFilterSelectivity
argument_list|(
literal|"select * from emp where mgr is not null"
argument_list|,
name|DEFAULT_NOTNULL_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityIsNotNullFilterOnNotNullColumn
parameter_list|()
block|{
name|checkFilterSelectivity
argument_list|(
literal|"select * from emp where deptno is not null"
argument_list|,
literal|1.0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityComparisonFilter
parameter_list|()
block|{
name|checkFilterSelectivity
argument_list|(
literal|"select * from emp where deptno> 10"
argument_list|,
name|DEFAULT_COMP_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityAndFilter
parameter_list|()
block|{
name|checkFilterSelectivity
argument_list|(
literal|"select * from emp where ename = 'foo' and deptno = 10"
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY_SQUARED
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityOrFilter
parameter_list|()
block|{
name|checkFilterSelectivity
argument_list|(
literal|"select * from emp where ename = 'foo' or deptno = 10"
argument_list|,
name|DEFAULT_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityJoin
parameter_list|()
block|{
name|checkFilterSelectivity
argument_list|(
literal|"select * from emp join dept using (deptno) where ename = 'foo'"
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkRelSelectivity
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|double
name|expected
parameter_list|)
block|{
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|Double
name|result
init|=
name|mq
operator|.
name|getSelectivity
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|result
argument_list|,
name|EPSILON
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityRedundantFilter
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp where deptno = 10"
argument_list|)
decl_stmt|;
name|checkRelSelectivity
argument_list|(
name|rel
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivitySort
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp where deptno = 10"
operator|+
literal|"order by ename"
argument_list|)
decl_stmt|;
name|checkRelSelectivity
argument_list|(
name|rel
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityUnion
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from (\n"
operator|+
literal|"  select * from emp union all select * from emp) "
operator|+
literal|"where deptno = 10"
argument_list|)
decl_stmt|;
name|checkRelSelectivity
argument_list|(
name|rel
argument_list|,
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityAgg
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
argument_list|)
decl_stmt|;
name|checkRelSelectivity
argument_list|(
name|rel
argument_list|,
name|DEFAULT_COMP_SELECTIVITY
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that we can cache a metadata request that includes a null    * argument. */
annotation|@
name|Test
specifier|public
name|void
name|testSelectivityAggCached
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
argument_list|)
decl_stmt|;
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|Double
name|result
init|=
name|mq
operator|.
name|getSelectivity
argument_list|(
name|rel
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|within
argument_list|(
name|DEFAULT_COMP_SELECTIVITY
operator|*
name|DEFAULT_EQUAL_SELECTIVITY
argument_list|,
name|EPSILON
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1808">[CALCITE-1808]    * JaninoRelMetadataProvider loading cache might cause    * OutOfMemoryError</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testMetadataHandlerCacheLimit
parameter_list|()
block|{
name|Assume
operator|.
name|assumeTrue
argument_list|(
literal|"If cache size is too large, this test may fail and the "
operator|+
literal|"test won't be to blame"
argument_list|,
name|SaffronProperties
operator|.
name|INSTANCE
operator|.
name|metadataHandlerCacheMaximumSize
argument_list|()
operator|.
name|get
argument_list|()
operator|<
literal|10_000
argument_list|)
expr_stmt|;
specifier|final
name|int
name|iterationCount
init|=
literal|2_000
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataProvider
name|metadataProvider
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPlanner
name|planner
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iterationCount
condition|;
name|i
operator|++
control|)
block|{
name|RelMetadataQuery
operator|.
name|THREAD_PROVIDERS
operator|.
name|set
argument_list|(
name|JaninoRelMetadataProvider
operator|.
name|of
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|metadataProvider
argument_list|,
name|planner
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|Double
name|result
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|within
argument_list|(
literal|14d
argument_list|,
literal|0.1d
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctRowCountTable
parameter_list|()
block|{
comment|// no unique key information is available so return null
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp where deptno = 10"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|ImmutableBitSet
name|groupKey
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
decl_stmt|;
name|Double
name|result
init|=
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|groupKey
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctRowCountTableEmptyKey
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp where deptno = 10"
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|groupKey
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|()
decl_stmt|;
comment|// empty key
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|Double
name|result
init|=
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|groupKey
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|is
argument_list|(
literal|1D
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Asserts that {@link RelMetadataQuery#getUniqueKeys(RelNode)}    * and {@link RelMetadataQuery#areColumnsUnique(RelNode, ImmutableBitSet)}    * return consistent results. */
specifier|private
name|void
name|assertUniqueConsistent
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|uniqueKeys
init|=
name|mq
operator|.
name|getUniqueKeys
argument_list|(
name|rel
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|allCols
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ImmutableBitSet
name|key
range|:
name|allCols
operator|.
name|powerSet
argument_list|()
control|)
block|{
name|Boolean
name|result2
init|=
name|mq
operator|.
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result2
operator|==
literal|null
operator|||
name|result2
operator|==
name|isUnique
argument_list|(
name|uniqueKeys
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns whether {@code keys} is unique, that is, whether it or a superset    * is in {@code keySets}. */
specifier|private
name|boolean
name|isUnique
parameter_list|(
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|uniqueKeys
parameter_list|,
name|ImmutableBitSet
name|key
parameter_list|)
block|{
for|for
control|(
name|ImmutableBitSet
name|uniqueKey
range|:
name|uniqueKeys
control|)
block|{
if|if
condition|(
name|key
operator|.
name|contains
argument_list|(
name|uniqueKey
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-509">[CALCITE-509]    * "RelMdColumnUniqueness uses ImmutableBitSet.Builder twice, gets    * NullPointerException"</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinUniqueKeys
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp join bonus using (ename)"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|result
init|=
name|mq
operator|.
name|getUniqueKeys
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertUniqueConsistent
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCorrelateUniqueKeys
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (select distinct deptno from emp) as e,\n"
operator|+
literal|"  lateral (\n"
operator|+
literal|"    select * from dept where dept.deptno = e.deptno)"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|rel
argument_list|,
name|isA
argument_list|(
operator|(
name|Class
operator|)
name|Project
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|rel
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|result
init|=
name|mq
operator|.
name|getUniqueKeys
argument_list|(
name|project
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|sortsAs
argument_list|(
literal|"[{0}]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|assertUniqueConsistent
argument_list|(
name|project
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|project
operator|.
name|getInput
argument_list|()
argument_list|,
name|isA
argument_list|(
operator|(
name|Class
operator|)
name|Correlate
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Correlate
name|correlate
init|=
operator|(
name|Correlate
operator|)
name|project
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|result2
init|=
name|mq
operator|.
name|getUniqueKeys
argument_list|(
name|correlate
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result2
argument_list|,
name|sortsAs
argument_list|(
literal|"[{0}]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|assertUniqueConsistent
argument_list|(
name|correlate
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGroupByEmptyUniqueKeys
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select count(*) from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|result
init|=
name|mq
operator|.
name|getUniqueKeys
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|CoreMatchers
operator|.
expr|<
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
operator|>
name|equalTo
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertUniqueConsistent
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGroupByEmptyHavingUniqueKeys
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select count(*) from emp where 1 = 1"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|result
init|=
name|mq
operator|.
name|getUniqueKeys
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|CoreMatchers
operator|.
expr|<
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
operator|>
name|equalTo
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertUniqueConsistent
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGroupBy
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select deptno, count(*), sum(sal) from emp\n"
operator|+
literal|"group by deptno"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|result
init|=
name|mq
operator|.
name|getUniqueKeys
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|CoreMatchers
operator|.
expr|<
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
operator|>
name|equalTo
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertUniqueConsistent
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnion
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select deptno from emp\n"
operator|+
literal|"union\n"
operator|+
literal|"select deptno from dept"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|result
init|=
name|mq
operator|.
name|getUniqueKeys
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|CoreMatchers
operator|.
expr|<
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
operator|>
name|equalTo
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertUniqueConsistent
argument_list|(
name|rel
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBrokenCustomProvider
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|ColTypeImpl
operator|.
name|THREAD_LIST
operator|.
name|set
argument_list|(
name|buf
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
decl_stmt|;
specifier|final
name|RelRoot
name|root
init|=
name|tester
operator|.
name|withClusterFactory
argument_list|(
operator|new
name|Function
argument_list|<
name|RelOptCluster
argument_list|,
name|RelOptCluster
argument_list|>
argument_list|()
block|{
specifier|public
name|RelOptCluster
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|)
block|{
name|cluster
operator|.
name|setMetadataProvider
argument_list|(
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|BrokenColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|cluster
operator|.
name|getMetadataProvider
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cluster
return|;
block|}
block|}
argument_list|)
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|root
operator|.
name|rel
decl_stmt|;
name|assertThat
argument_list|(
name|rel
argument_list|,
name|instanceOf
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|MyRelMetadataQuery
name|mq
init|=
operator|new
name|MyRelMetadataQuery
argument_list|()
decl_stmt|;
try|try
block|{
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-rel"
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|value
init|=
literal|"No handler for method [public abstract java.lang.String "
operator|+
literal|"org.apache.calcite.test.RelMetadataTest$ColType.getColType(int)] "
operator|+
literal|"applied to argument of type [interface org.apache.calcite.rel.RelNode]; "
operator|+
literal|"we recommend you create a catch-all (RelNode) handler"
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|colType
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|int
name|column
parameter_list|)
block|{
if|if
condition|(
name|mq
operator|instanceof
name|MyRelMetadataQuery
condition|)
block|{
return|return
operator|(
operator|(
name|MyRelMetadataQuery
operator|)
name|mq
operator|)
operator|.
name|colType
argument_list|(
name|rel
argument_list|,
name|column
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rel
operator|.
name|metadata
argument_list|(
name|ColType
operator|.
name|class
argument_list|,
name|mq
argument_list|)
operator|.
name|getColType
argument_list|(
name|column
argument_list|)
return|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomProvider
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|buf
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|ColTypeImpl
operator|.
name|THREAD_LIST
operator|.
name|set
argument_list|(
name|buf
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
decl_stmt|;
specifier|final
name|RelRoot
name|root
init|=
name|tester
operator|.
name|withClusterFactory
argument_list|(
operator|new
name|Function
argument_list|<
name|RelOptCluster
argument_list|,
name|RelOptCluster
argument_list|>
argument_list|()
block|{
specifier|public
name|RelOptCluster
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|)
block|{
comment|// Create a custom provider that includes ColType.
comment|// Include the same provider twice just to be devious.
specifier|final
name|ImmutableList
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|ColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|ColTypeImpl
operator|.
name|SOURCE
argument_list|,
name|cluster
operator|.
name|getMetadataProvider
argument_list|()
argument_list|)
decl_stmt|;
name|cluster
operator|.
name|setMetadataProvider
argument_list|(
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cluster
return|;
block|}
block|}
argument_list|)
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|root
operator|.
name|rel
decl_stmt|;
comment|// Top node is a filter. Its metadata uses getColType(RelNode, int).
name|assertThat
argument_list|(
name|rel
argument_list|,
name|instanceOf
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-rel"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|rel
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-rel"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Next node is an aggregate. Its metadata uses
comment|// getColType(LogicalAggregate, int).
specifier|final
name|RelNode
name|input
init|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|input
argument_list|,
name|instanceOf
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
comment|// There is no caching. Another request causes another call to the provider.
name|assertThat
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[DEPTNO-rel, EXPR$1-rel, DEPTNO-agg]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now add a cache. Only the first request for each piece of metadata
comment|// generates a new call to the provider.
specifier|final
name|RelOptPlanner
name|planner
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataProvider
argument_list|()
argument_list|,
name|planner
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"EXPR$1-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|// With a different timestamp, a metadata item is re-computed on first call.
name|long
name|timestamp
init|=
name|planner
operator|.
name|getRelMetadataTimestamp
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestamp
argument_list|,
name|equalTo
argument_list|(
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|MockRelOptPlanner
operator|)
name|planner
operator|)
operator|.
name|setRelMetadataTimestamp
argument_list|(
name|timestamp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|colType
argument_list|(
name|mq
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"DEPTNO-agg"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|buf
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMdCollation#project}    * and other helper functions for deducing collations. */
annotation|@
name|Test
specifier|public
name|void
name|testCollation
parameter_list|()
block|{
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|convertSql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
operator|new
name|Frameworks
operator|.
name|PlannerAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|,
name|SchemaPlus
name|rootSchema
parameter_list|)
block|{
name|checkCollation
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCollation
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelCollation
argument_list|>
name|collations
init|=
name|RelMdCollation
operator|.
name|table
argument_list|(
name|empScan
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// ORDER BY field#0 ASC, field#1 ASC
specifier|final
name|RelCollation
name|collation
init|=
name|RelCollations
operator|.
name|of
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|RelFieldCollation
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|sort
argument_list|(
name|collation
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Sort
name|empSort
init|=
name|LogicalSort
operator|.
name|create
argument_list|(
name|empScan
argument_list|,
name|collation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|empSort
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"foo"
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|empSort
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|empSort
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|empSort
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|project
argument_list|(
name|mq
argument_list|,
name|empSort
argument_list|,
name|projects
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldIndex
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getFieldIndex
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalProject
name|project
init|=
name|LogicalProject
operator|.
name|create
argument_list|(
name|empSort
argument_list|,
name|projects
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
literal|"d"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|)
decl_stmt|;
specifier|final
name|RelCollation
name|deptCollation
init|=
name|RelCollations
operator|.
name|of
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|RelFieldCollation
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Sort
name|deptSort
init|=
name|LogicalSort
operator|.
name|create
argument_list|(
name|deptScan
argument_list|,
name|deptCollation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableIntList
name|leftKeys
init|=
name|ImmutableIntList
operator|.
name|of
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableIntList
name|rightKeys
init|=
name|ImmutableIntList
operator|.
name|of
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|EnumerableMergeJoin
name|join
decl_stmt|;
try|try
block|{
name|join
operator|=
name|EnumerableMergeJoin
operator|.
name|create
argument_list|(
name|project
argument_list|,
name|deptSort
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidRelException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|collations
operator|=
name|RelMdCollation
operator|.
name|mergeJoin
argument_list|(
name|mq
argument_list|,
name|project
argument_list|,
name|deptSort
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
argument_list|,
name|equalTo
argument_list|(
name|join
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTraits
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Values (empty)
name|collations
operator|=
name|RelMdCollation
operator|.
name|values
argument_list|(
name|mq
argument_list|,
name|empTable
operator|.
name|getRowType
argument_list|()
argument_list|,
name|ImmutableList
operator|.
expr|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
operator|>
name|of
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[0, 1, 2, 3, 4, 5, 6, 7, 8], "
operator|+
literal|"[1, 2, 3, 4, 5, 6, 7, 8], "
operator|+
literal|"[2, 3, 4, 5, 6, 7, 8], "
operator|+
literal|"[3, 4, 5, 6, 7, 8], "
operator|+
literal|"[4, 5, 6, 7, 8], "
operator|+
literal|"[5, 6, 7, 8], "
operator|+
literal|"[6, 7, 8], "
operator|+
literal|"[7, 8], "
operator|+
literal|"[8]]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalValues
name|emptyValues
init|=
name|LogicalValues
operator|.
name|createEmpty
argument_list|(
name|cluster
argument_list|,
name|empTable
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|collations
argument_list|(
name|emptyValues
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|collations
argument_list|)
argument_list|)
expr_stmt|;
comment|// Values (non-empty)
specifier|final
name|RelDataType
name|rowType
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tuples
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// sort keys are [a], [a, b], [a, b, c], [a, b, c, d], [a, c], [b], [b, a],
comment|//   [b, d]
comment|// algorithm deduces [a, b, c, d], [b, d] which is a useful sub-set
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|collations
operator|=
name|RelMdCollation
operator|.
name|values
argument_list|(
name|mq
argument_list|,
name|rowType
argument_list|,
name|tuples
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|collations
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[0, 1, 2, 3], [1, 3]]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalValues
name|values
init|=
name|LogicalValues
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|tuples
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|collations
argument_list|(
name|values
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|collations
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addRow
parameter_list|(
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|builder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexLiteral
argument_list|>
name|b
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|varcharType
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
specifier|final
name|RexLiteral
name|literal
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|literal
operator|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|varcharType
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|literal
operator|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|literal
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|add
argument_list|(
name|literal
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|add
argument_list|(
name|b
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMetadataQuery#getAverageColumnSizes(org.apache.calcite.rel.RelNode)},    * {@link org.apache.calcite.rel.metadata.RelMetadataQuery#getAverageRowSize(org.apache.calcite.rel.RelNode)}. */
annotation|@
name|Test
specifier|public
name|void
name|testAverageRowSize
parameter_list|()
block|{
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|convertSql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
operator|new
name|Frameworks
operator|.
name|PlannerAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|,
name|SchemaPlus
name|rootSchema
parameter_list|)
block|{
name|checkAverageRowSize
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkAverageRowSize
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|)
decl_stmt|;
name|Double
name|rowSize
init|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|empScan
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Double
argument_list|>
name|columnSizes
init|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|empScan
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|empScan
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|40.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|89.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Empty values
specifier|final
name|LogicalValues
name|emptyValues
init|=
name|LogicalValues
operator|.
name|createEmpty
argument_list|(
name|cluster
argument_list|,
name|empTable
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|emptyValues
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|emptyValues
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|emptyValues
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|40.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|89.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Values
specifier|final
name|RelDataType
name|rowType
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tuples
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|1
argument_list|,
literal|"1234567890"
argument_list|,
literal|"ABC"
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|2
argument_list|,
literal|"1"
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
name|addRow
argument_list|(
name|tuples
argument_list|,
name|rexBuilder
argument_list|,
literal|3
argument_list|,
literal|"2"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
specifier|final
name|LogicalValues
name|values
init|=
name|LogicalValues
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|tuples
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|values
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|3.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|15.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Union
specifier|final
name|LogicalUnion
name|union
init|=
name|LogicalUnion
operator|.
name|create
argument_list|(
name|ImmutableList
operator|.
expr|<
name|RelNode
operator|>
name|of
argument_list|(
name|empScan
argument_list|,
name|emptyValues
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|union
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|union
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|40.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|89.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Filter
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|)
decl_stmt|;
specifier|final
name|LogicalFilter
name|filter
init|=
name|LogicalFilter
operator|.
name|create
argument_list|(
name|deptScan
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|deptScan
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|TEN
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|20.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|24.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Project
specifier|final
name|LogicalProject
name|deptProject
init|=
name|LogicalProject
operator|.
name|create
argument_list|(
name|filter
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|filter
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|filter
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|filter
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHAR_LENGTH
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|filter
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
literal|null
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|deptProject
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|deptProject
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|32.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Join
specifier|final
name|LogicalJoin
name|join
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|empScan
argument_list|,
name|deptProject
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|join
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|join
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|13
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|40.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|8.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|,
literal|1.0
argument_list|,
literal|4.0
argument_list|,
literal|20.0
argument_list|,
literal|4.0
argument_list|,
literal|4.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|121.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Aggregate
specifier|final
name|LogicalAggregate
name|aggregate
init|=
name|LogicalAggregate
operator|.
name|create
argument_list|(
name|join
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ImmutableList
operator|.
expr|<
name|ImmutableBitSet
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|AggregateCall
operator|.
name|create
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|ImmutableIntList
operator|.
name|of
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
name|join
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rowSize
operator|=
name|mq
operator|.
name|getAverageRowSize
argument_list|(
name|aggregate
argument_list|)
expr_stmt|;
name|columnSizes
operator|=
name|mq
operator|.
name|getAverageColumnSizes
argument_list|(
name|aggregate
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|columnSizes
argument_list|,
name|equalTo
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|4.0
argument_list|,
literal|20.0
argument_list|,
literal|8.0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|rowSize
argument_list|,
name|equalTo
argument_list|(
literal|32.0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Smoke test Parallelism and Memory metadata providers
name|assertThat
argument_list|(
name|mq
operator|.
name|memory
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|cumulativeMemoryWithinPhase
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|cumulativeMemoryWithinPhaseSplit
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|isPhaseTransition
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|mq
operator|.
name|splitCount
argument_list|(
name|aggregate
argument_list|)
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    * {@link org.apache.calcite.rel.metadata.RelMdPredicates#getPredicates(SemiJoin, RelMetadataQuery)}. */
annotation|@
name|Test
specifier|public
name|void
name|testPredicates
parameter_list|()
block|{
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|convertSql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
operator|new
name|Frameworks
operator|.
name|PlannerAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|,
name|SchemaPlus
name|rootSchema
parameter_list|)
block|{
name|checkPredicates
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkPredicates
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|proto
argument_list|()
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|empScan
argument_list|)
expr_stmt|;
name|RelOptPredicateList
name|predicates
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|empScan
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|filter
argument_list|(
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|literal
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|filter
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"[=($0, 1)]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|semiJoin
argument_list|(
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SemiJoin
name|semiJoin
init|=
operator|(
name|SemiJoin
operator|)
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|semiJoin
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1)]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|leftInferredPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|rightInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create a Join similar to the previous SemiJoin
name|relBuilder
operator|.
name|push
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|project
argument_list|)
expr_stmt|;
comment|// No inferred predicates, because we already know DEPTNO is NOT NULL
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|project
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"RecordType(INTEGER NOT NULL DEPTNO) NOT NULL"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|leftInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|rightInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create a Join similar to the previous Join, but joining on MGR, which
comment|// is nullable. From the join condition "e.MGR = d.DEPTNO" we can deduce
comment|// the projected predicate "IS NOT NULL($0)".
name|relBuilder
operator|.
name|push
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"MGR"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"MGR"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project2
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|project2
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[IS NOT NULL($0)]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|leftInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|rightInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create another similar Join. From the join condition
comment|//   e.MGR - e.EMPNO = d.DEPTNO + e.MGR_COMM
comment|// we can deduce the projected predicate
comment|//   MGR IS NOT NULL OR MGR_COMM IS NOT NULL
comment|//
comment|// EMPNO is omitted because it is NOT NULL.
comment|// MGR_COMM is a made-up nullable field.
name|relBuilder
operator|.
name|push
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|Iterables
operator|.
name|concat
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|relBuilder
operator|.
name|alias
argument_list|(
name|relBuilder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"MGR"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
argument_list|,
literal|"MGR_COMM"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"MGR"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"MGR_COMM"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"MGR"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"NAME"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"MGR_COMM"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project3
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|project3
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[OR(IS NOT NULL($0), IS NOT NULL($2))]"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|leftInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|rightInferredPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unit test for    * {@link org.apache.calcite.rel.metadata.RelMdPredicates#getPredicates(Aggregate, RelMetadataQuery)}.    */
annotation|@
name|Test
specifier|public
name|void
name|testPullUpPredicatesFromAggregation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a, max(b) from (\n"
operator|+
literal|"  select 1 as a, 2 as b from emp)subq\n"
operator|+
literal|"group by a"
decl_stmt|;
specifier|final
name|Aggregate
name|rel
init|=
operator|(
name|Aggregate
operator|)
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|pulledUpPredicates
init|=
name|inputSet
operator|.
name|pulledUpPredicates
decl_stmt|;
name|assertThat
argument_list|(
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[=($0, 1)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1960">[CALCITE-1960]    * RelMdPredicates.getPredicates is slow if there are many equivalent    * columns</a>. Since this is a performance problem, the test result does not    * change, but takes over 15 minutes before the fix and 6 seconds after. */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|20_000
argument_list|)
specifier|public
name|void
name|testPullUpPredicatesForExprsItr
parameter_list|()
block|{
comment|// If we're running Windows, we are probably in a VM and the test may
comment|// exceed timeout by a small margin.
name|Assume
operator|.
name|assumeThat
argument_list|(
literal|"Too slow on Windows"
argument_list|,
name|File
operator|.
name|separatorChar
argument_list|,
name|Is
operator|.
name|is
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|testPullUpPredicatesForExprsItrNoTimeout
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testPullUpPredicatesForExprsItr} but no timeout; can run on    * all platforms, even slow VMs. */
annotation|@
name|Test
specifier|public
name|void
name|testPullUpPredicatesForExprsItrNoTimeout
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.EMPNO, a.ENAME\n"
operator|+
literal|"from (select * from sales.emp ) a\n"
operator|+
literal|"join (select * from sales.emp  ) b\n"
operator|+
literal|"on a.empno = b.deptno\n"
operator|+
literal|"  and a.comm = b.comm\n"
operator|+
literal|"  and a.mgr=b.mgr\n"
operator|+
literal|"  and (a.empno< 10 or a.comm< 3 or a.deptno< 10\n"
operator|+
literal|"    or a.job ='abc' or a.ename='abc' or a.sal='30' or a.mgr>3\n"
operator|+
literal|"    or a.slacker is not null  or a.HIREDATE is not null\n"
operator|+
literal|"    or b.empno< 9 or b.comm< 3 or b.deptno< 10 or b.job ='abc'\n"
operator|+
literal|"    or b.ename='abc' or b.sal='30' or b.mgr>3 or b.slacker )\n"
operator|+
literal|"join emp c\n"
operator|+
literal|"on b.mgr =a.mgr and a.empno =b.deptno and a.comm=b.comm\n"
operator|+
literal|"  and a.deptno=b.deptno and a.job=b.job and a.ename=b.ename\n"
operator|+
literal|"  and a.mgr=b.deptno and a.slacker=b.slacker"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|131089
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullUpPredicatesOnConstant
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, mgr, x, 'y' as y, z from (\n"
operator|+
literal|"  select deptno, mgr, cast(null as integer) as x, cast('1' as int) as z\n"
operator|+
literal|"  from emp\n"
operator|+
literal|"  where mgr is null and deptno< 10)"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|list
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|list
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[<($0, 10), =($3, 'y'), =($4, 1), IS NULL($1), IS NULL($2)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullUpPredicatesOnNullableConstant
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select nullif(1, 1) as c\n"
operator|+
literal|"  from emp\n"
operator|+
literal|"  where mgr is null and deptno< 10"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|list
init|=
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
comment|// Uses "IS NOT DISTINCT FROM" rather than "=" because cannot guarantee not null.
name|assertThat
argument_list|(
name|list
operator|.
name|pulledUpPredicates
argument_list|,
name|sortsAs
argument_list|(
literal|"[IS NOT DISTINCT FROM($0, CASE(=(1, 1), null, 1))]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistributionSimple
parameter_list|()
block|{
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp where deptno = 10"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelDistribution
name|d
init|=
name|mq
operator|.
name|getDistribution
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|d
argument_list|,
name|is
argument_list|(
name|RelDistributions
operator|.
name|BROADCAST_DISTRIBUTED
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistributionHash
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelDistribution
name|dist
init|=
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|LogicalExchange
name|exchange
init|=
name|LogicalExchange
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|dist
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelDistribution
name|d
init|=
name|mq
operator|.
name|getDistribution
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|d
argument_list|,
name|is
argument_list|(
name|dist
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistributionHashEmpty
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelDistribution
name|dist
init|=
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
expr|<
name|Integer
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|LogicalExchange
name|exchange
init|=
name|LogicalExchange
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|dist
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelDistribution
name|d
init|=
name|mq
operator|.
name|getDistribution
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|d
argument_list|,
name|is
argument_list|(
name|dist
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistributionSingleton
parameter_list|()
block|{
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelDistribution
name|dist
init|=
name|RelDistributions
operator|.
name|SINGLETON
decl_stmt|;
specifier|final
name|LogicalExchange
name|exchange
init|=
name|LogicalExchange
operator|.
name|create
argument_list|(
name|rel
argument_list|,
name|dist
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelDistribution
name|d
init|=
name|mq
operator|.
name|getDistribution
argument_list|(
name|exchange
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|d
argument_list|,
name|is
argument_list|(
name|dist
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for {@link RelMdUtil#linear(int, int, int, double, double)}. */
annotation|@
name|Test
specifier|public
name|void
name|testLinear
parameter_list|()
block|{
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|100d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|150d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|160d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|200d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|100d
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RelMdUtil
operator|.
name|linear
argument_list|(
literal|12
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|100
argument_list|,
literal|200
argument_list|)
argument_list|,
name|is
argument_list|(
literal|200d
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageStar
parameter_list|()
block|{
comment|// All columns in output
specifier|final
name|RelNode
name|tableRel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|4
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|tableRel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|4
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|endsWith
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageTwoColumns
parameter_list|()
block|{
comment|// mgr is column 3 in catalog.sales.emp
comment|// deptno is column 7 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select mgr, deptno from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref1
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r1
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r1
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result1
init|=
operator|(
name|RexTableInputRef
operator|)
name|r1
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|ref2
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r2
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r2
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result2
init|=
operator|(
name|RexTableInputRef
operator|)
name|r2
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result2
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|is
argument_list|(
name|result2
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageTwoColumnsSwapped
parameter_list|()
block|{
comment|// deptno is column 7 in catalog.sales.emp
comment|// mgr is column 3 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select deptno, mgr from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref1
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r1
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r1
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result1
init|=
operator|(
name|RexTableInputRef
operator|)
name|r1
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|ref2
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r2
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref2
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r2
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result2
init|=
operator|(
name|RexTableInputRef
operator|)
name|r2
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result2
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result1
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|is
argument_list|(
name|result2
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageCombineTwoColumns
parameter_list|()
block|{
comment|// empno is column 0 in catalog.sales.emp
comment|// deptno is column 7 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select empno + deptno from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|result
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getKind
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlKind
operator|.
name|PLUS
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|result
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef2
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef2
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|is
argument_list|(
name|inputRef2
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageInnerJoinLeft
parameter_list|()
block|{
comment|// ename is column 1 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select ename from emp,dept"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result
init|=
operator|(
name|RexTableInputRef
operator|)
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageInnerJoinRight
parameter_list|()
block|{
comment|// ename is column 0 in catalog.sales.bonus
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select bonus.ename from emp join bonus using (ename)"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|result
init|=
operator|(
name|RexTableInputRef
operator|)
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"CATALOG"
argument_list|,
literal|"SALES"
argument_list|,
literal|"BONUS"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageSelfJoin
parameter_list|()
block|{
comment|// deptno is column 7 in catalog.sales.emp
comment|// sal is column 5 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select a.deptno, b.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"inner join (select * from emp limit 2) as b\n"
operator|+
literal|"on a.deptno = b.deptno"
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref1
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r1
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef1
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|7
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r1
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString1
init|=
name|r1
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString1
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString1
argument_list|,
name|endsWith
argument_list|(
name|inputRef1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|ref2
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r2
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref2
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef2
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|5
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r2
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString2
init|=
name|r2
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString2
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString2
argument_list|,
name|endsWith
argument_list|(
name|inputRef2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
operator|(
operator|(
name|RexTableInputRef
operator|)
name|r1
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|not
argument_list|(
operator|(
operator|(
name|RexTableInputRef
operator|)
name|r2
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageOuterJoin
parameter_list|()
block|{
comment|// lineage cannot be determined
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select name as dname from emp left outer join dept"
operator|+
literal|" on emp.deptno = dept.deptno"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageFilter
parameter_list|()
block|{
comment|// ename is column 1 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select ename from emp where deptno = 10"
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|endsWith
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageAggregateGroupColumn
parameter_list|()
block|{
comment|// deptno is column 7 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|7
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|resultString
init|=
name|r
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|endsWith
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageAggregateAggColumn
parameter_list|()
block|{
comment|// lineage cannot be determined
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select deptno, count(*) from emp where deptno> 10 "
operator|+
literal|"group by deptno having count(*) = 0"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|1
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageUnion
parameter_list|()
block|{
comment|// sal is column 5 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select sal from (\n"
operator|+
literal|"  select * from emp union all select * from emp) "
operator|+
literal|"where deptno = 10"
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|tableRel
init|=
name|convertSql
argument_list|(
literal|"select * from emp"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
specifier|final
name|String
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|5
argument_list|,
name|tableRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|result
range|:
name|r
control|)
block|{
specifier|final
name|String
name|resultString
init|=
name|result
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|startsWith
argument_list|(
name|EMP_QNAME
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultString
argument_list|,
name|endsWith
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|RexNode
argument_list|>
name|it
init|=
name|r
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
operator|(
operator|(
name|RexTableInputRef
operator|)
name|it
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|not
argument_list|(
operator|(
operator|(
name|RexTableInputRef
operator|)
name|it
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageMultiUnion
parameter_list|()
block|{
comment|// empno is column 0 in catalog.sales.emp
comment|// sal is column 5 in catalog.sales.emp
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select a.empno + b.sal from \n"
operator|+
literal|" (select empno, ename from emp,dept) a join "
operator|+
literal|" (select * from emp union all select * from emp) b \n"
operator|+
literal|" on a.empno = b.empno \n"
operator|+
literal|" where b.deptno = 10"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
comment|// With the union, we should get two origins
comment|// The first one should be the same one: join
comment|// The second should come from each union input
specifier|final
name|Set
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|r
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|result
range|:
name|r
control|)
block|{
name|assertThat
argument_list|(
name|result
operator|.
name|getKind
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlKind
operator|.
name|PLUS
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|result
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add join alpha to set
name|set
operator|.
name|add
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef2
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef2
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIdentifier
argument_list|()
argument_list|,
name|not
argument_list|(
name|inputRef2
operator|.
name|getIdentifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|set
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionLineageValues
parameter_list|()
block|{
comment|// lineage cannot be determined
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
literal|"select * from (values (1), (2)) as t(c)"
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|r
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAllPredicates
parameter_list|()
block|{
specifier|final
name|Project
name|rel
init|=
operator|(
name|Project
operator|)
name|convertSql
argument_list|(
literal|"select * from emp, dept"
argument_list|)
decl_stmt|;
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|empTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|deptTable
init|=
name|join
operator|.
name|getInput
argument_list|(
literal|1
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Frameworks
operator|.
name|withPlanner
argument_list|(
operator|new
name|Frameworks
operator|.
name|PlannerAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|,
name|SchemaPlus
name|rootSchema
parameter_list|)
block|{
name|checkAllPredicates
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|,
name|deptTable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkAllPredicates
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptTable
name|empTable
parameter_list|,
name|RelOptTable
name|deptTable
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|proto
argument_list|()
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|LogicalTableScan
name|empScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|empTable
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|empScan
argument_list|)
expr_stmt|;
name|RelOptPredicateList
name|predicates
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|empScan
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|filter
argument_list|(
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|literal
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|filter
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|LogicalTableScan
name|deptScan
init|=
name|LogicalTableScan
operator|.
name|create
argument_list|(
name|cluster
argument_list|,
name|deptTable
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|deptScan
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|equals
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|project
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|predicates
operator|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|project
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// From Filter
name|call
operator|=
operator|(
name|RexCall
operator|)
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|inputRef1
operator|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// From Join
name|call
operator|=
operator|(
name|RexCall
operator|)
name|predicates
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|inputRef1
operator|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|RexTableInputRef
name|inputRef2
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef2
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"CATALOG"
argument_list|,
literal|"SALES"
argument_list|,
literal|"DEPT"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef2
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAllPredicatesAggregate1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a, max(b) from (\n"
operator|+
literal|"  select empno as a, sal as b from emp where empno = 5)subq\n"
operator|+
literal|"group by a"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|pulledUpPredicates
init|=
name|inputSet
operator|.
name|pulledUpPredicates
decl_stmt|;
name|assertThat
argument_list|(
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexLiteral
name|constant
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|constant
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"5"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAllPredicatesAggregate2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select a, max(b) from (\n"
operator|+
literal|"  select empno as a, sal as b from emp)subq\n"
operator|+
literal|"group by a) \n"
operator|+
literal|"where a = 5"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|pulledUpPredicates
init|=
name|inputSet
operator|.
name|pulledUpPredicates
decl_stmt|;
name|assertThat
argument_list|(
name|pulledUpPredicates
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexTableInputRef
name|inputRef1
init|=
operator|(
name|RexTableInputRef
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|inputRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|EMP_QNAME
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|inputRef1
operator|.
name|getIndex
argument_list|()
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexLiteral
name|constant
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|constant
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"5"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAllPredicatesAggregate3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select a, max(b) as b from (\n"
operator|+
literal|"  select empno as a, sal as b from emp)subq\n"
operator|+
literal|"group by a) \n"
operator|+
literal|"where b = 5"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
comment|// Filter on aggregate, we cannot infer lineage
name|assertNull
argument_list|(
name|inputSet
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAllPredicatesAndTablesJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select x.sal, y.deptno from\n"
operator|+
literal|"(select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno) as x\n"
operator|+
literal|"inner join\n"
operator|+
literal|"(select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno) as y\n"
operator|+
literal|"on x.deptno = y.deptno"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[true, "
operator|+
literal|"=([CATALOG, SALES, EMP].#0.$7, [CATALOG, SALES, EMP].#1.$7), "
operator|+
literal|"true, "
operator|+
literal|"=([CATALOG, SALES, EMP].#2.$7, [CATALOG, SALES, EMP].#3.$7), "
operator|+
literal|"=([CATALOG, SALES, EMP].#0.$7, [CATALOG, SALES, EMP].#2.$7)]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[CATALOG, SALES, DEPT].#0, [CATALOG, SALES, DEPT].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#0, [CATALOG, SALES, EMP].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#2, [CATALOG, SALES, EMP].#3]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAllPredicatesAndTableUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno\n"
operator|+
literal|"union all\n"
operator|+
literal|"select a.deptno, c.sal from (select * from emp limit 7) as a\n"
operator|+
literal|"cross join (select * from dept limit 1) as b\n"
operator|+
literal|"inner join (select * from emp limit 2) as c\n"
operator|+
literal|"on a.deptno = c.deptno"
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|inputSet
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|inputSet
operator|.
name|pulledUpPredicates
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[true, "
operator|+
literal|"=([CATALOG, SALES, EMP].#0.$7, [CATALOG, SALES, EMP].#1.$7), "
operator|+
literal|"true, "
operator|+
literal|"=([CATALOG, SALES, EMP].#2.$7, [CATALOG, SALES, EMP].#3.$7)]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableReferences
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableReferences
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"[[CATALOG, SALES, DEPT].#0, [CATALOG, SALES, DEPT].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#0, [CATALOG, SALES, EMP].#1, "
operator|+
literal|"[CATALOG, SALES, EMP].#2, [CATALOG, SALES, EMP].#3]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkNodeTypeCount
parameter_list|(
name|String
name|sql
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
parameter_list|)
block|{
specifier|final
name|RelNode
name|rel
init|=
name|convertSql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|result
init|=
name|mq
operator|.
name|getNodeTypes
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|resultCount
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|RelNode
argument_list|>
argument_list|>
name|e
range|:
name|result
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|resultCount
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|resultCount
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountEmp
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountDept
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from dept"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountValues
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1), (2)) as t(c)"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Values
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountCartesian
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp,dept"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp\n"
operator|+
literal|"inner join dept on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountJoinFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 14) as emp\n"
operator|+
literal|"inner join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"inner join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountLeftJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"left join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountRightJoinEmptyFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"right join (select * from dept limit 4) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountJoinFiniteEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 7) as emp\n"
operator|+
literal|"inner join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountJoinEmptyEmpty
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 0) as emp\n"
operator|+
literal|"inner join (select * from dept limit 0) as dept\n"
operator|+
literal|"on emp.deptno = dept.deptno"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from emp\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name from dept"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Union
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountUnionOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Union
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountMinusOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (select * from emp limit 100)\n"
operator|+
literal|"except\n"
operator|+
literal|"select name from (select * from dept limit 40)"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Minus
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where ename='Mathilda'"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountSortLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountSortLimitOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by ename limit 10 offset 5"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountSortLimitOffsetOnFinite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp limit 12)\n"
operator|+
literal|"order by ename limit 20 offset 5"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountAggregate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp group by deptno"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountAggregateGroupingSets
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by grouping sets ((deptno), (ename, deptno))"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountAggregateEmptyKeyOnEmptyTable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from (select * from emp limit 0)"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNodeTypeCountFilterAggregateEmptyKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from emp where 1 = 0"
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|expected
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected
operator|.
name|put
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkNodeTypeCount
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|SqlOperator
name|NONDETERMINISTIC_OP
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"NDC"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|Test
specifier|public
name|void
name|testGetPredicatesForJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|FrameworkConfig
name|config
init|=
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|RelNode
name|join
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|NONDETERMINISTIC_OP
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|join
argument_list|)
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|RelNode
name|join1
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"=($0, $8)"
argument_list|,
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|join1
argument_list|)
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetPredicatesForFilter
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|FrameworkConfig
name|config
init|=
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|RelNode
name|filter
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|NONDETERMINISTIC_OP
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|filter
argument_list|)
operator|.
name|pulledUpPredicates
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|RelNode
name|filter1
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"=($0, $1)"
argument_list|,
name|mq
operator|.
name|getPulledUpPredicates
argument_list|(
name|filter1
argument_list|)
operator|.
name|pulledUpPredicates
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Matcher that succeeds for any collection that, when converted to strings    * and sorted on those strings, matches the given reference string.    *    *<p>Use it as an alternative to {@link CoreMatchers#is} if items in your    * list might occur in any order.    *    *<p>For example:    *    *<blockquote><pre>List&lt;Integer&gt; ints = Arrays.asList(2, 500, 12);    * assertThat(ints, sortsAs("[12, 2, 500]");</pre></blockquote>    */
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Matcher
argument_list|<
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
name|sortsAs
parameter_list|(
specifier|final
name|String
name|value
parameter_list|)
block|{
return|return
operator|new
name|CustomTypeSafeMatcher
argument_list|<
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
argument_list|>
argument_list|(
name|value
argument_list|)
block|{
specifier|protected
name|boolean
name|matchesSafely
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|item
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|strings
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|item
control|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|strings
argument_list|)
expr_stmt|;
return|return
name|value
operator|.
name|equals
argument_list|(
name|strings
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Custom metadata interface. */
specifier|public
interface|interface
name|ColType
extends|extends
name|Metadata
block|{
name|Method
name|METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|ColType
operator|.
name|class
argument_list|,
literal|"getColType"
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
name|MetadataDef
argument_list|<
name|ColType
argument_list|>
name|DEF
init|=
name|MetadataDef
operator|.
name|of
argument_list|(
name|ColType
operator|.
name|class
argument_list|,
name|ColType
operator|.
name|Handler
operator|.
name|class
argument_list|,
name|METHOD
argument_list|)
decl_stmt|;
name|String
name|getColType
parameter_list|(
name|int
name|column
parameter_list|)
function_decl|;
comment|/** Handler API. */
interface|interface
name|Handler
extends|extends
name|MetadataHandler
argument_list|<
name|ColType
argument_list|>
block|{
name|String
name|getColType
parameter_list|(
name|RelNode
name|r
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|int
name|column
parameter_list|)
function_decl|;
block|}
block|}
comment|/** A provider for {@link org.apache.calcite.test.RelMetadataTest.ColType} via    * reflection. */
specifier|public
specifier|abstract
specifier|static
class|class
name|PartialColTypeImpl
implements|implements
name|MetadataHandler
argument_list|<
name|ColType
argument_list|>
block|{
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|THREAD_LIST
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|MetadataDef
argument_list|<
name|ColType
argument_list|>
name|getDef
parameter_list|()
block|{
return|return
name|ColType
operator|.
name|DEF
return|;
block|}
comment|/** Implementation of {@link ColType#getColType(int)} for      * {@link org.apache.calcite.rel.logical.LogicalAggregate}, called via      * reflection. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedDeclaration"
argument_list|)
specifier|public
name|String
name|getColType
parameter_list|(
name|Aggregate
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|int
name|column
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|column
argument_list|)
operator|.
name|getName
argument_list|()
operator|+
literal|"-agg"
decl_stmt|;
name|THREAD_LIST
operator|.
name|get
argument_list|()
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
block|}
comment|/** A provider for {@link org.apache.calcite.test.RelMetadataTest.ColType} via    * reflection. */
specifier|public
specifier|static
class|class
name|ColTypeImpl
extends|extends
name|PartialColTypeImpl
block|{
specifier|public
specifier|static
specifier|final
name|RelMetadataProvider
name|SOURCE
init|=
name|ReflectiveRelMetadataProvider
operator|.
name|reflectiveSource
argument_list|(
name|ColType
operator|.
name|METHOD
argument_list|,
operator|new
name|ColTypeImpl
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Implementation of {@link ColType#getColType(int)} for      * {@link RelNode}, called via reflection. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UnusedDeclaration"
argument_list|)
specifier|public
name|String
name|getColType
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|int
name|column
parameter_list|)
block|{
specifier|final
name|String
name|name
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|column
argument_list|)
operator|.
name|getName
argument_list|()
operator|+
literal|"-rel"
decl_stmt|;
name|THREAD_LIST
operator|.
name|get
argument_list|()
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
block|}
comment|/** Implementation of {@link ColType} that has no fall-back for {@link RelNode}. */
specifier|public
specifier|static
class|class
name|BrokenColTypeImpl
extends|extends
name|PartialColTypeImpl
block|{
specifier|public
specifier|static
specifier|final
name|RelMetadataProvider
name|SOURCE
init|=
name|ReflectiveRelMetadataProvider
operator|.
name|reflectiveSource
argument_list|(
name|ColType
operator|.
name|METHOD
argument_list|,
operator|new
name|BrokenColTypeImpl
argument_list|()
argument_list|)
decl_stmt|;
block|}
comment|/** Extension to {@link RelMetadataQuery} to support {@link ColType}.    *    *<p>Illustrates how you would package up a user-defined metadata type. */
specifier|private
specifier|static
class|class
name|MyRelMetadataQuery
extends|extends
name|RelMetadataQuery
block|{
specifier|private
name|ColType
operator|.
name|Handler
name|colTypeHandler
decl_stmt|;
name|MyRelMetadataQuery
parameter_list|()
block|{
name|super
argument_list|(
name|THREAD_PROVIDERS
operator|.
name|get
argument_list|()
argument_list|,
name|EMPTY
argument_list|)
expr_stmt|;
name|colTypeHandler
operator|=
name|initialHandler
argument_list|(
name|ColType
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|colType
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|column
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|colTypeHandler
operator|.
name|getColType
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|column
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|colTypeHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|ColType
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelMetadataTest.java
end_comment

end_unit

