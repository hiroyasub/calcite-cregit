begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableFunctionScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Window
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Programs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Unit test for {@link RelBuilder}.  *  *<p>Tasks:</p>  *<ol>  *<li>Add RelBuilder.scan(List&lt;String&gt;)</li>  *<li>Add RelBuilder.scan(Table)</li>  *<li>Test that {@link RelBuilder#filter} does not create a filter if the  *   predicates optimize to true</li>  *<li>Test that {@link RelBuilder#filter} DOES create a filter if the  *   predicates optimize to false. (Creating an empty Values seems too  *   devious.)</li>  *<li>Test that {@link RelBuilder#scan} throws good error if table not  *   found</li>  *<li>Test that {@link RelBuilder#scan} obeys case-sensitivity</li>  *<li>Test that {@link RelBuilder#join(JoinRelType, String...)} obeys  *   case-sensitivity</li>  *<li>Test RelBuilder with alternative factories</li>  *<li>Test that {@link RelBuilder#field(String)} obeys case-sensitivity</li>  *<li>Test case-insensitive unique field names</li>  *<li>Test that an alias created using  *      {@link RelBuilder#alias(RexNode, String)} is removed if not a top-level  *      project</li>  *<li>{@link RelBuilder#aggregate} with grouping sets</li>  *<li>{@link RelBuilder#aggregateCall} with filter</li>  *<li>Add call to create {@link TableFunctionScan}</li>  *<li>Add call to create {@link Window}</li>  *<li>Add call to create {@link TableModify}</li>  *<li>Add call to create {@link Exchange}</li>  *<li>Add call to create {@link Correlate}</li>  *<li>Add call to create {@link AggregateCall} with filter</li>  *</ol>  */
end_comment

begin_class
specifier|public
class|class
name|RelBuilderTest
block|{
comment|/** Creates a config based on the "scott" schema. */
specifier|public
specifier|static
name|Frameworks
operator|.
name|ConfigBuilder
name|config
parameter_list|()
block|{
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|parserConfig
argument_list|(
name|SqlParser
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|SCOTT
argument_list|)
argument_list|)
operator|.
name|traitDefs
argument_list|(
operator|(
name|List
argument_list|<
name|RelTraitDef
argument_list|>
operator|)
literal|null
argument_list|)
operator|.
name|programs
argument_list|(
name|Programs
operator|.
name|heuristicJoinOrder
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|,
literal|true
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScan
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
specifier|final
name|RelNode
name|root
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterTrue
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE TRUE
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterEquals
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE deptno = 20
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalFilter(condition=[=($7, 20)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterOr
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE (deptno = 20 OR comm IS NULL) AND mgr IS NOT NULL
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|isNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|isNotNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalFilter(condition=[AND(OR(=($7, 20), IS NULL($6)), IS NOT NULL($3))])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBadFieldName
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RexInputRef
name|ref
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|field
argument_list|(
literal|"deptno"
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"field [deptno] not found; input fields are: [EMPNO, ENAME, JOB, "
operator|+
literal|"MGR, HIREDATE, SAL, COMM, DEPTNO]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBadFieldOrdinal
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RexInputRef
name|ref
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|field
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"field ordinal [20] out of range; "
operator|+
literal|"input fields are: [DEPTNO, DNAME, LOC]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBadType
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
expr_stmt|;
name|RexNode
name|call
init|=
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|call
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"cannot derive type: +; "
operator|+
literal|"operands: [$1: VARCHAR(10), $3: SMALLINT]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProject
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno, CAST(comm AS SMALLINT) AS comm, 20 AS $f2,
comment|//     comm AS comm3, comm AS c
comment|//   FROM emp
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|cast
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Note: CAST(COMM) gets the COMM alias because it occurs first
comment|// Note: AS(COMM, C) becomes just $6
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalProject(DEPTNO=[$7], COMM=[CAST($6):SMALLINT NOT NULL], $f2=[20], COMM3=[$6], C=[$6])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests each method that creates a scalar expression. */
annotation|@
name|Test
specifier|public
name|void
name|testProject2
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|cast
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
argument_list|,
name|builder
operator|.
name|or
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|and
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|and
argument_list|(
name|builder
operator|.
name|isNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|not
argument_list|(
name|builder
operator|.
name|isNotNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|7
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|30
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|isNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
literal|"n2"
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|isNotNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
literal|"nn2"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalProject(DEPTNO=[$7], COMM=[CAST($6):SMALLINT NOT NULL],"
operator|+
literal|" $f2=[OR(=($7, 20), AND(false, =($7, 10), IS NULL($6),"
operator|+
literal|" NOT(IS NOT NULL($7))), =($7, 30))], n2=[IS NULL($2)],"
operator|+
literal|" nn2=[IS NOT NULL($3)], $f5=[20], COMM6=[$6], C=[$6])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregate
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT COUNT(DISTINCT deptno) AS c
comment|//   FROM emp
comment|//   GROUP BY ()
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|()
argument_list|,
name|builder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
literal|true
argument_list|,
literal|"C"
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalAggregate(group=[{}], C=[COUNT(DISTINCT $7)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregate2
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT COUNT(*) AS c, SUM(mgr + 1) AS s
comment|//   FROM emp
comment|//   GROUP BY ename, hiredate + mgr
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|4
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
literal|false
argument_list|,
literal|"C"
argument_list|)
argument_list|,
name|builder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
literal|false
argument_list|,
literal|"S"
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|""
operator|+
literal|"LogicalAggregate(group=[{1, 8}], C=[COUNT()], S=[SUM($9)])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], $f8=[+($4, $3)], $f9=[+($3, 1)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinct
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT DISTINCT *
comment|//   FROM emp
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalAggregate(group=[{}])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnion
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno FROM emp
comment|//   UNION ALL
comment|//   SELECT deptno FROM dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|union
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalUnion(all=[true])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"    LogicalFilter(condition=[=($7, 20)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIntersect
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT empno FROM emp
comment|//   WHERE deptno = 20
comment|//   INTERSECT
comment|//   SELECT deptno FROM dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|intersect
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalIntersect(all=[false])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"    LogicalFilter(condition=[=($7, 20)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExcept
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT empno FROM emp
comment|//   WHERE deptno = 20
comment|//   MINUS
comment|//   SELECT deptno FROM dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|minus
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"LogicalMinus(all=[false])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"    LogicalFilter(condition=[=($7, 20)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoin
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM (SELECT * FROM emp WHERE comm IS NULL)
comment|//   JOIN dept ON emp.deptno = dept.deptno
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalJoin(condition=[=($7, $0)], joinType=[inner])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalFilter(condition=[IS NULL($6)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// Using USING method
specifier|final
name|RelNode
name|root2
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
literal|"DEPTNO"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root2
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoinCartesian
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT * emp CROSS JOIN dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValues
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   VALUES (true, 1), (false, -50) AS t(a, b)
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
operator|-
literal|50
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[{ true, 1 }, { false, -50 }]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expectedType
init|=
literal|"RecordType(BOOLEAN NOT NULL a, INTEGER NOT NULL b) NOT NULL"
decl_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests creating Values with some field names and some values null. */
annotation|@
name|Test
specifier|public
name|void
name|testValuesNullable
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   VALUES (null, 1, 'abc'), (false, null, 'longer string')
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|null
block|,
literal|"c"
block|}
argument_list|,
literal|null
argument_list|,
literal|1
argument_list|,
literal|"abc"
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|"longer string"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[{ null, 1, 'abc' }, { false, null, 'longer string' }]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expectedType
init|=
literal|"RecordType(BOOLEAN a, INTEGER expr$1, CHAR(13) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL c) NOT NULL"
decl_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadNullFieldNames
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadNoFields
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadNoValues
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadOddMultiple
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadAllNull
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"All values of field 'b' are null; cannot deduce type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesAllNull
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
name|rowType
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[{ null, null }, { 1, null }]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expectedType
init|=
literal|"RecordType(BIGINT NOT NULL a, VARCHAR(10) CHARACTER SET \"ISO-8859-1\" COLLATE \"ISO-8859-1$en_US$primary\" NOT NULL a) NOT NULL"
decl_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSort
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   ORDER BY 3. 1 DESC
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|,
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSort(sort0=[$2], sort1=[$0], dir0=[ASC], dir1=[DESC])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// same result using ordinals
specifier|final
name|RelNode
name|root2
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root2
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortByExpression
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   ORDER BY ename ASC NULLS LAST, hiredate + mgr DESC NULLS FIRST
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
name|builder
operator|.
name|nullsLast
argument_list|(
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|nullsFirst
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|4
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7])\n"
operator|+
literal|"  LogicalSort(sort0=[$1], sort1=[$8], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first])\n"
operator|+
literal|"    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], $f8=[+($4, $3)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLimit
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   OFFSET 2 FETCH 10
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|limit
argument_list|(
literal|2
argument_list|,
literal|10
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSort(offset=[2], fetch=[10])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortLimit
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   ORDER BY deptno DESC FETCH 10
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
literal|10
argument_list|,
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSort(sort0=[$7], dir0=[DESC], fetch=[10])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// End RelBuilderTest.java
end_comment

end_unit

