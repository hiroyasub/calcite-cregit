begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Contexts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistributions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableFunctionScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Window
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|hint
operator|.
name|RelHint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|ViewTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|ViewTableMacro
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMatchRecognize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|FrameworkConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Programs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelRunners
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DriverManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|UnaryOperator
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|hasHints
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|Matchers
operator|.
name|hasTree
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|allOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|containsString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|nullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertThrows
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Unit test for {@link RelBuilder}.  *  *<p>Tasks:</p>  *<ol>  *<li>Add RelBuilder.scan(List&lt;String&gt;)</li>  *<li>Add RelBuilder.scan(Table)</li>  *<li>Test that {@link RelBuilder#filter} does not create a filter if the  *   predicates optimize to true</li>  *<li>Test that {@link RelBuilder#filter} DOES create a filter if the  *   predicates optimize to false. (Creating an empty Values seems too  *   devious.)</li>  *<li>Test that {@link RelBuilder#scan} throws good error if table not  *   found</li>  *<li>Test that {@link RelBuilder#scan} obeys case-sensitivity</li>  *<li>Test that {@link RelBuilder#join(JoinRelType, String...)} obeys  *   case-sensitivity</li>  *<li>Test RelBuilder with alternative factories</li>  *<li>Test that {@link RelBuilder#field(String)} obeys case-sensitivity</li>  *<li>Test case-insensitive unique field names</li>  *<li>Test that an alias created using  *      {@link RelBuilder#alias(RexNode, String)} is removed if not a top-level  *      project</li>  *<li>{@link RelBuilder#aggregate} with grouping sets</li>  *<li>Add call to create {@link TableFunctionScan}</li>  *<li>Add call to create {@link Window}</li>  *<li>Add call to create {@link TableModify}</li>  *<li>Add call to create {@link Exchange}</li>  *<li>Add call to create {@link Correlate}</li>  *<li>Add call to create {@link AggregateCall} with filter</li>  *</ol>  */
end_comment

begin_class
specifier|public
class|class
name|RelBuilderTest
block|{
comment|/** Creates a config based on the "scott" schema. */
specifier|public
specifier|static
name|Frameworks
operator|.
name|ConfigBuilder
name|config
parameter_list|()
block|{
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|parserConfig
argument_list|(
name|SqlParser
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
operator|.
name|defaultSchema
argument_list|(
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|SCOTT_WITH_TEMPORAL
argument_list|)
argument_list|)
operator|.
name|traitDefs
argument_list|(
operator|(
name|List
argument_list|<
name|RelTraitDef
argument_list|>
operator|)
literal|null
argument_list|)
operator|.
name|programs
argument_list|(
name|Programs
operator|.
name|heuristicJoinOrder
argument_list|(
name|Programs
operator|.
name|RULE_SET
argument_list|,
literal|true
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a config builder that will contain a view, "MYVIEW", and also    * the SCOTT JDBC schema, whose tables implement    * {@link org.apache.calcite.schema.TranslatableTable}. */
specifier|static
name|Frameworks
operator|.
name|ConfigBuilder
name|expandingConfig
parameter_list|(
name|Connection
name|connection
parameter_list|)
throws|throws
name|SQLException
block|{
specifier|final
name|CalciteConnection
name|calciteConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|SchemaPlus
name|root
init|=
name|calciteConnection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|CalciteAssert
operator|.
name|SchemaSpec
name|spec
init|=
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|SCOTT
decl_stmt|;
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|root
argument_list|,
name|spec
argument_list|)
expr_stmt|;
specifier|final
name|String
name|viewSql
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"select * from \"%s\".\"%s\" where 1=1"
argument_list|,
name|spec
operator|.
name|schemaName
argument_list|,
literal|"EMP"
argument_list|)
decl_stmt|;
comment|// create view
name|ViewTableMacro
name|macro
init|=
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|root
argument_list|,
name|viewSql
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"test"
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"test"
argument_list|,
literal|"view"
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// register view (in root schema)
name|root
operator|.
name|add
argument_list|(
literal|"MYVIEW"
argument_list|,
name|macro
argument_list|)
expr_stmt|;
return|return
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|defaultSchema
argument_list|(
name|root
argument_list|)
return|;
block|}
specifier|static
name|RelBuilder
name|createBuilder
parameter_list|(
name|UnaryOperator
argument_list|<
name|RelBuilder
operator|.
name|Config
argument_list|>
name|transform
parameter_list|)
block|{
specifier|final
name|Frameworks
operator|.
name|ConfigBuilder
name|configBuilder
init|=
name|config
argument_list|()
decl_stmt|;
name|configBuilder
operator|.
name|context
argument_list|(
name|Contexts
operator|.
name|of
argument_list|(
name|transform
operator|.
name|apply
argument_list|(
name|RelBuilder
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RelBuilder
operator|.
name|create
argument_list|(
name|configBuilder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScan
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
specifier|final
name|RelNode
name|root
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
literal|"LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanQualifiedTable
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM "scott"."emp"
specifier|final
name|RelNode
name|root
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|scan
argument_list|(
literal|"scott"
argument_list|,
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
literal|"LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanInvalidTable
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM zzz
try|try
block|{
specifier|final
name|RelNode
name|root
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|scan
argument_list|(
literal|"ZZZ"
argument_list|)
comment|// this relation does not exist
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Table 'ZZZ' not found"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanInvalidSchema
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM "zzz"."emp"
try|try
block|{
specifier|final
name|RelNode
name|root
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|scan
argument_list|(
literal|"ZZZ"
argument_list|,
literal|"EMP"
argument_list|)
comment|// the table exists, but the schema does not
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Table 'ZZZ.EMP' not found"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanInvalidQualifiedTable
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM "scott"."zzz"
try|try
block|{
specifier|final
name|RelNode
name|root
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|scan
argument_list|(
literal|"scott"
argument_list|,
literal|"ZZZ"
argument_list|)
comment|// the schema is valid, but the table does not exist
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Table 'scott.ZZZ' not found"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanValidTableWrongCase
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM "emp"
try|try
block|{
specifier|final
name|RelNode
name|root
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|scan
argument_list|(
literal|"emp"
argument_list|)
comment|// the table is named 'EMP', not 'emp'
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"Expected error (table names are case-sensitive), but got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Table 'emp' not found"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterTrue
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE TRUE
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
literal|"LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterTriviallyFalse
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE 1 = 2
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
literal|"LogicalValues(tuples=[[]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterEquals
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE deptno = 20
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalFilter(condition=[=($7, 20)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSnapshotTemporalTable
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM products_temporal FOR SYSTEM_TIME AS OF TIMESTAMP '2011-07-20 12:34:56'
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"products_temporal"
argument_list|)
operator|.
name|snapshot
argument_list|(
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeTimestampLiteral
argument_list|(
operator|new
name|TimestampString
argument_list|(
literal|"2011-07-20 12:34:56"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSnapshot(period=[2011-07-20 12:34:56])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, products_temporal]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTableFunctionScan
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM TABLE(
comment|//       DEDUP(CURSOR(select * from emp),
comment|//             CURSOR(select * from DEPT), 'NAME'))
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlOperator
name|dedupFunction
init|=
operator|new
name|MockSqlOperatorTable
operator|.
name|DedupFunction
argument_list|()
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|functionScan
argument_list|(
name|dedupFunction
argument_list|,
literal|2
argument_list|,
name|builder
operator|.
name|cursor
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|cursor
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalTableFunctionScan("
operator|+
literal|"invocation=[DEDUP(CURSOR($0), CURSOR($1))], "
operator|+
literal|"rowType=[RecordType(VARCHAR(1024) NAME)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure that the builder's stack is empty.
try|try
block|{
name|RelNode
name|node
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
name|assertNull
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTableFunctionScanZeroInputs
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM TABLE(RAMP(3))
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlOperator
name|rampFunction
init|=
operator|new
name|MockSqlOperatorTable
operator|.
name|RampFunction
argument_list|()
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|functionScan
argument_list|(
name|rampFunction
argument_list|,
literal|0
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalTableFunctionScan(invocation=[RAMP(3)], "
operator|+
literal|"rowType=[RecordType(INTEGER I)])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure that the builder's stack is empty.
try|try
block|{
name|RelNode
name|node
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
name|assertNull
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoinTemporalTable
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM orders
comment|//   JOIN products_temporal FOR SYSTEM_TIME AS OF TIMESTAMP '2011-07-20 12:34:56'
comment|//   ON orders.product = products_temporal.id
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"orders"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"products_temporal"
argument_list|)
operator|.
name|snapshot
argument_list|(
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeTimestampLiteral
argument_list|(
operator|new
name|TimestampString
argument_list|(
literal|"2011-07-20 12:34:56"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"PRODUCT"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"ID"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalJoin(condition=[=($2, $4)], joinType=[inner])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, orders]])\n"
operator|+
literal|"  LogicalSnapshot(period=[2011-07-20 12:34:56])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, products_temporal]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that {@link RelBuilder#project} simplifies expressions if and only if    * {@link RelBuilder.Config#simplify}. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplify
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withSimplify
argument_list|(
literal|true
argument_list|)
argument_list|,
name|hasTree
argument_list|(
literal|"LogicalProject($f0=[true])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|c
lambda|->
name|c
argument_list|,
name|hasTree
argument_list|(
literal|"LogicalProject($f0=[true])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withSimplify
argument_list|(
literal|false
argument_list|)
argument_list|,
name|hasTree
argument_list|(
literal|"LogicalProject($f0=[IS NOT NULL($0)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkSimplify
parameter_list|(
name|UnaryOperator
argument_list|<
name|RelBuilder
operator|.
name|Config
argument_list|>
name|transform
parameter_list|,
name|Matcher
argument_list|<
name|RelNode
argument_list|>
name|matcher
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|createBuilder
argument_list|(
name|transform
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|isNotNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterOr
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE (deptno = 20 OR comm IS NULL) AND mgr IS NOT NULL
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|isNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|isNotNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalFilter(condition=[AND(OR(=($7, 20), IS NULL($6)), IS NOT NULL($3))])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterOr2
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE deptno = 20 OR deptno = 20
comment|// simplifies to
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE deptno = 20
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalFilter(condition=[>($7, 20)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterAndFalse
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE deptno = 20 AND FALSE
comment|// simplifies to
comment|//   VALUES
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterAndTrue
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE deptno = 20 AND TRUE
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalFilter(condition=[>($7, 20)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2730">[CALCITE-2730]    * RelBuilder incorrectly simplifies a filter with duplicate conjunction to    * empty</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testScanFilterDuplicateAnd
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE deptno> 20 AND deptno> 20 AND deptno> 20
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|condition
init|=
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|condition2
init|=
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|30
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|filter
argument_list|(
name|condition
argument_list|,
name|condition
argument_list|,
name|condition
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalFilter(condition=[>($7, 20)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE deptno> 20 AND deptno< 30 AND deptno> 20
specifier|final
name|RelNode
name|root2
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|condition
argument_list|,
name|condition2
argument_list|,
name|condition
argument_list|,
name|condition
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected2
init|=
literal|""
operator|+
literal|"LogicalFilter(condition=[AND(>($7, 20),<($7, 30))])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root2
argument_list|,
name|hasTree
argument_list|(
name|expected2
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBadFieldName
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RexInputRef
name|ref
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|field
argument_list|(
literal|"deptno"
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"field [deptno] not found; input fields are: [EMPNO, ENAME, JOB, "
operator|+
literal|"MGR, HIREDATE, SAL, COMM, DEPTNO]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBadFieldOrdinal
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RexInputRef
name|ref
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|field
argument_list|(
literal|20
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|ref
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"field ordinal [20] out of range; "
operator|+
literal|"input fields are: [DEPTNO, DNAME, LOC]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBadType
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
expr_stmt|;
name|RexNode
name|call
init|=
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|call
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Cannot infer return type for +; "
operator|+
literal|"operand types: [VARCHAR(10), SMALLINT]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProject
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno, CAST(comm AS SMALLINT) AS comm, 20 AS $f2,
comment|//     comm AS comm3, comm AS c
comment|//   FROM emp
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|cast
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Note: CAST(COMM) gets the COMM alias because it occurs first
comment|// Note: AS(COMM, C) becomes just $6
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[$7], COMM=[CAST($6):SMALLINT NOT NULL], $f2=[20], COMM0=[$6], C=[$6])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests each method that creates a scalar expression. */
annotation|@
name|Test
specifier|public
name|void
name|testProject2
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|cast
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
argument_list|,
name|builder
operator|.
name|or
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|and
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|null
argument_list|)
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|and
argument_list|(
name|builder
operator|.
name|isNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|not
argument_list|(
name|builder
operator|.
name|isNotNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|7
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|30
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|isNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
literal|"n2"
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|isNotNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
literal|"nn2"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|6
argument_list|)
argument_list|,
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[$7], COMM=[CAST($6):SMALLINT NOT NULL],"
operator|+
literal|" $f2=[OR(=($7, 20), AND(null:NULL, =($7, 10), IS NULL($6),"
operator|+
literal|" IS NULL($7)), =($7, 30))], n2=[IS NULL($2)],"
operator|+
literal|" nn2=[IS NOT NULL($3)], $f5=[20], COMM0=[$6], C=[$6])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectIdentity
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|fields
argument_list|(
name|Mappings
operator|.
name|bijection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1297">[CALCITE-1297]    * RelBuilder does not translate identity projects even if they rename    * fields</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectIdentityWithFieldsRename
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"a"
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"b"
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"t1"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"a"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"t1"
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(a=[$0], c=[$2])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Variation on {@link #testProjectIdentityWithFieldsRename}: don't use a    * table alias, and make sure the field names propagate through a filter. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectIdentityWithFieldsRenameFilter
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"a"
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"b"
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"c"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"a"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|builder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"c"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"a"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(c=[$2], a=[$0])\n"
operator|+
literal|"  LogicalAggregate(group=[{0, 1, 2}], agg#0=[SUM($0)])\n"
operator|+
literal|"    LogicalFilter(condition=[=($0, 20)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectLeadingEdge
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|fields
argument_list|(
name|Mappings
operator|.
name|bijection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectWithAliasFromScan
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|"EMP"
argument_list|,
literal|"ENAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(ENAME=[$1])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3228">[CALCITE-3228]    * IllegalArgumentException in getMapping() for project containing same reference</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectMapping
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|root
operator|instanceof
name|Project
argument_list|)
expr_stmt|;
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|root
decl_stmt|;
name|Mappings
operator|.
name|TargetMapping
name|mapping
init|=
name|project
operator|.
name|getMapping
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|mapping
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|project1
parameter_list|(
name|int
name|value
parameter_list|,
name|SqlTypeName
name|sqlTypeName
parameter_list|,
name|String
name|message
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RexBuilder
name|rex
init|=
name|builder
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelNode
name|actual
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"x"
block|}
argument_list|,
literal|42
argument_list|)
operator|.
name|empty
argument_list|()
operator|.
name|project
argument_list|(
name|rex
operator|.
name|makeLiteral
argument_list|(
name|value
argument_list|,
name|rex
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|sqlTypeName
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|message
argument_list|,
name|actual
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProject1asInt
parameter_list|()
block|{
name|project1
argument_list|(
literal|1
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|,
literal|"project(1 as INT) might omit type of 1 in the output plan as"
operator|+
literal|" it is convention to omit INTEGER for integer literals"
argument_list|,
literal|"LogicalProject($f0=[1])\n"
operator|+
literal|"  LogicalValues(tuples=[[]])\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProject1asBigInt
parameter_list|()
block|{
name|project1
argument_list|(
literal|1
argument_list|,
name|SqlTypeName
operator|.
name|BIGINT
argument_list|,
literal|"project(1 as BIGINT) should contain"
operator|+
literal|" type of 1 in the output plan since the convention is to omit type of INTEGER"
argument_list|,
literal|"LogicalProject($f0=[1:BIGINT])\n"
operator|+
literal|"  LogicalValues(tuples=[[]])\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRename
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// No rename necessary (null name is ignored)
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|rename
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"DEPTNO"
argument_list|,
literal|null
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// No rename necessary (prefix matches)
name|root
operator|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|rename
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add project to rename fields
name|root
operator|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|rename
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"NAME"
argument_list|,
literal|null
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
specifier|final
name|String
name|expected2
init|=
literal|""
operator|+
literal|"LogicalProject(NAME=[$0], DNAME=[$1], DEPTNO=[$2])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected2
argument_list|)
argument_list|)
expr_stmt|;
comment|// If our requested list has non-unique names, we might get the same field
comment|// names we started with. Don't add a useless project.
name|root
operator|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|rename
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"DEPTNO"
argument_list|,
literal|null
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
specifier|final
name|String
name|expected3
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[$0], DNAME=[$1], DEPTNO0=[$2])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected3
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|rename
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"DEPTNO"
argument_list|,
literal|null
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|rename
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"DEPTNO"
argument_list|,
literal|null
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// No extra Project
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected3
argument_list|)
argument_list|)
expr_stmt|;
comment|// Name list too long
try|try
block|{
name|root
operator|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|rename
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"NAME"
argument_list|,
literal|"DEPTNO"
argument_list|,
literal|"Y"
argument_list|,
literal|"Z"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"More names than fields"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRenameValues
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
operator|-
literal|50
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[{ true, 1 }, { false, -50 }]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// When you rename Values, you get a Values with a new row type, no Project
name|root
operator|=
name|builder
operator|.
name|push
argument_list|(
name|root
argument_list|)
operator|.
name|rename
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"x"
argument_list|,
literal|"y z"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"[x, y z]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPermute
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|permute
argument_list|(
name|Mappings
operator|.
name|bijection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(JOB=[$2], EMPNO=[$0], ENAME=[$1])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvert
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|convert
argument_list|(
name|rowType
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[CAST($0):BIGINT NOT NULL], DNAME=[CAST($1):VARCHAR(10) NOT NULL], LOC=[CAST($2):VARCHAR(10) NOT NULL])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvertRename
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|convert
argument_list|(
name|rowType
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(a=[CAST($0):BIGINT NOT NULL], b=[CAST($1):VARCHAR(10) NOT NULL], c=[CAST($2):VARCHAR(10) NOT NULL])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregate
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT COUNT(DISTINCT deptno) AS c
comment|//   FROM emp
comment|//   GROUP BY ()
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|()
argument_list|,
name|builder
operator|.
name|count
argument_list|(
literal|true
argument_list|,
literal|"C"
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{}], C=[COUNT(DISTINCT $7)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregate2
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT COUNT(*) AS c, SUM(mgr + 1) AS s
comment|//   FROM emp
comment|//   GROUP BY ename, hiredate + mgr
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|4
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|countStar
argument_list|(
literal|"C"
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"S"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{1, 8}], C=[COUNT()], S=[SUM($9)])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], $f8=[+($4, $3)], $f9=[+($3, 1)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2192">[CALCITE-2192]    * RelBuilder wrongly skips creation of Aggregate that prunes columns if input    * is unique</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregate3
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT DISTINCT deptno FROM (
comment|//     SELECT deptno, COUNT(*)
comment|//     FROM emp
comment|//     GROUP BY deptno)
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|count
argument_list|()
operator|.
name|as
argument_list|(
literal|"C"
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(ENAME=[$0])\n"
operator|+
literal|"  LogicalAggregate(group=[{1}], C=[COUNT()])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** As {@link #testAggregate3()} but with Filter. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregate4
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT DISTINCT deptno FROM (
comment|//     SELECT deptno, COUNT(*)
comment|//     FROM emp
comment|//     GROUP BY deptno
comment|//     HAVING COUNT(*)> 3)
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|count
argument_list|()
operator|.
name|as
argument_list|(
literal|"C"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(ENAME=[$0])\n"
operator|+
literal|"  LogicalFilter(condition=[>($1, 3)])\n"
operator|+
literal|"    LogicalAggregate(group=[{1}], C=[COUNT()])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2946">[CALCITE-2946]    * RelBuilder wrongly skips creation of Aggregate that prunes columns if input    * produces one row at most</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregate5
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|()
argument_list|,
name|builder
operator|.
name|count
argument_list|()
operator|.
name|as
argument_list|(
literal|"C"
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|4
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject($f0=[4], $f1=[2])\n"
operator|+
literal|"  LogicalAggregate(group=[{}], C=[COUNT()])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that {@link RelBuilder#aggregate} eliminates duplicate aggregate    * calls and creates a {@code Project} to compensate. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateEliminatesDuplicateCalls
parameter_list|()
block|{
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(S1=[$0], C=[$1], S2=[$2], S1b=[$0])\n"
operator|+
literal|"  LogicalAggregate(group=[{}], S1=[SUM($1)], C=[COUNT()], S2=[SUM($2)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|buildRelWithDuplicateAggregates
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withDedupAggregateCalls
argument_list|(
literal|true
argument_list|)
argument_list|)
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now, disable the rewrite
specifier|final
name|String
name|expected2
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{}], S1=[SUM($1)], C=[COUNT()], S2=[SUM($2)], S1b=[SUM($1)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|buildRelWithDuplicateAggregates
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withDedupAggregateCalls
argument_list|(
literal|false
argument_list|)
argument_list|)
argument_list|,
name|hasTree
argument_list|(
name|expected2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** As {@link #testAggregateEliminatesDuplicateCalls()} but with a    * single-column GROUP BY clause. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateEliminatesDuplicateCalls2
parameter_list|()
block|{
name|RelNode
name|root
init|=
name|buildRelWithDuplicateAggregates
argument_list|(
name|c
lambda|->
name|c
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0], S1=[$1], C=[$2], S2=[$3], S1b=[$1])\n"
operator|+
literal|"  LogicalAggregate(group=[{0}], S1=[SUM($1)], C=[COUNT()], S2=[SUM($2)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** As {@link #testAggregateEliminatesDuplicateCalls()} but with a    * multi-column GROUP BY clause. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateEliminatesDuplicateCalls3
parameter_list|()
block|{
name|RelNode
name|root
init|=
name|buildRelWithDuplicateAggregates
argument_list|(
name|c
lambda|->
name|c
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0], JOB=[$1], MGR=[$2], HIREDATE=[$3], S1=[$4], C=[$5], S2=[$6], S1b=[$4])\n"
operator|+
literal|"  LogicalAggregate(group=[{0, 2, 3, 4}], S1=[SUM($1)], C=[COUNT()], S2=[SUM($2)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RelNode
name|buildRelWithDuplicateAggregates
parameter_list|(
name|UnaryOperator
argument_list|<
name|RelBuilder
operator|.
name|Config
argument_list|>
name|transform
parameter_list|,
name|int
modifier|...
name|groupFieldOrdinals
parameter_list|)
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|createBuilder
argument_list|(
name|transform
argument_list|)
decl_stmt|;
return|return
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|groupFieldOrdinals
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"S1"
argument_list|)
argument_list|,
name|builder
operator|.
name|count
argument_list|()
operator|.
name|as
argument_list|(
literal|"C"
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"S2"
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"S1b"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Tests eliminating duplicate aggregate calls, when some of them are only    * seen to be duplicates when a spurious "DISTINCT" has been eliminated.    *    *<p>Note that "M2" and "MD2" are based on the same field, because    * "MIN(DISTINCT $2)" is identical to "MIN($2)". The same is not true for    * "SUM". */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateEliminatesDuplicateDistinctCalls
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
literal|2
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"S1"
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|as
argument_list|(
literal|"SD1"
argument_list|)
argument_list|,
name|builder
operator|.
name|count
argument_list|()
operator|.
name|as
argument_list|(
literal|"C"
argument_list|)
argument_list|,
name|builder
operator|.
name|min
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|as
argument_list|(
literal|"MD2"
argument_list|)
argument_list|,
name|builder
operator|.
name|min
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"M2"
argument_list|)
argument_list|,
name|builder
operator|.
name|min
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|as
argument_list|(
literal|"MD2b"
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|as
argument_list|(
literal|"S1b"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(JOB=[$0], S1=[$1], SD1=[$2], C=[$3], MD2=[$4], "
operator|+
literal|"M2=[$4], MD2b=[$4], S1b=[$2])\n"
operator|+
literal|"  LogicalAggregate(group=[{2}], S1=[SUM($1)], "
operator|+
literal|"SD1=[SUM(DISTINCT $1)], C=[COUNT()], MD2=[MIN($2)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateFilter
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno, COUNT(*) FILTER (WHERE empno> 100) AS c
comment|//   FROM emp
comment|//   GROUP BY ROLLUP(deptno)
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|7
argument_list|)
argument_list|,
operator|(
name|Iterable
argument_list|<
name|ImmutableBitSet
argument_list|>
operator|)
name|ImmutableList
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|7
argument_list|)
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|count
argument_list|()
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|100
argument_list|)
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{7}], groups=[[{7}, {}]], C=[COUNT() FILTER $8])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], $f8=[>($0, 100)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateFilterFails
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno, SUM(sal) FILTER (WHERE comm) AS c
comment|//   FROM emp
comment|//   GROUP BY deptno
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CalciteException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"FILTER expression must be of type BOOLEAN"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateFilterNullable
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno, SUM(sal) FILTER (WHERE comm< 100) AS c
comment|//   FROM emp
comment|//   GROUP BY deptno
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|100
argument_list|)
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"C"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{7}], C=[SUM($5) FILTER $8])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], $f8=[IS TRUE(<($6, 100))])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1980">[CALCITE-1980]    * RelBuilder gives NPE if groupKey contains alias</a>.    *    *<p>Now, the alias does not cause a new expression to be added to the input,    * but causes the referenced fields to be renamed. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateProjectWithAliases
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
literal|"departmentNo"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{0}])\n"
operator|+
literal|"  LogicalProject(departmentNo=[$7])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateProjectWithExpression
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
literal|"d3"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{1}])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$7], d3=[+($7, 3)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateGroupingKeyOutOfRangeFails
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|17
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"out of bounds: {17}"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateGroupingSetNotSubsetFails
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|7
argument_list|)
argument_list|,
operator|(
name|Iterable
argument_list|<
name|ImmutableBitSet
argument_list|>
operator|)
name|ImmutableList
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|4
argument_list|)
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"group set element [$4] must be a subset of group key"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateGroupingSetDuplicateIgnored
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|7
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|(
name|Iterable
argument_list|<
name|ImmutableBitSet
argument_list|>
operator|)
name|ImmutableList
operator|.
name|of
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|7
argument_list|)
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|6
argument_list|)
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|7
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{6, 7}], groups=[[{6}, {7}]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateGrouping
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
literal|6
argument_list|,
literal|7
argument_list|)
argument_list|,
name|builder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GROUPING
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"g"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalAggregate(group=[{6, 7}], g=[GROUPING($7)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateGroupingWithDistinctFails
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
literal|6
argument_list|,
literal|7
argument_list|)
argument_list|,
name|builder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GROUPING
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|(
literal|true
argument_list|)
operator|.
name|as
argument_list|(
literal|"g"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"DISTINCT not allowed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateGroupingWithFilterFails
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
literal|6
argument_list|,
literal|7
argument_list|)
argument_list|,
name|builder
operator|.
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GROUPING
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"g"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"FILTER not allowed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinct
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT DISTINCT deptno
comment|//   FROM emp
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalAggregate(group=[{0}])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$7])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctAlready
parameter_list|()
block|{
comment|// DEPT is already distinct
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctEmpty
parameter_list|()
block|{
comment|// Is a relation with zero columns distinct?
comment|// What about if we know there are zero rows?
comment|// It is a matter of definition: there are no duplicate rows,
comment|// but applying "select ... group by ()" to it would change the result.
comment|// In theory, we could omit the distinct if we know there is precisely one
comment|// row, but we don't currently.
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|()
operator|.
name|distinct
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalAggregate(group=[{}])\n"
operator|+
literal|"  LogicalProject\n"
operator|+
literal|"    LogicalFilter(condition=[IS NULL($6)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnion
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno FROM emp
comment|//   UNION ALL
comment|//   SELECT deptno FROM dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|union
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalUnion(all=[true])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"    LogicalFilter(condition=[=($7, 20)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1522">[CALCITE-1522]    * Fix error message for SetOp with incompatible args</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testBadUnionArgsErrorMessage
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT EMPNO, SAL FROM emp
comment|//   UNION ALL
comment|//   SELECT DEPTNO FROM dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|)
operator|.
name|union
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|fail
argument_list|(
literal|"Expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|expected
init|=
literal|"Cannot compute compatible row type for "
operator|+
literal|"arguments to set op: RecordType(TINYINT DEPTNO), "
operator|+
literal|"RecordType(SMALLINT EMPNO, DECIMAL(7, 2) SAL)"
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnion3
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno FROM dept
comment|//   UNION ALL
comment|//   SELECT empno FROM emp
comment|//   UNION ALL
comment|//   SELECT deptno FROM emp
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|union
argument_list|(
literal|true
argument_list|,
literal|3
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalUnion(all=[true])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$7])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnion1
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno FROM dept
comment|//   UNION ALL
comment|//   SELECT empno FROM emp
comment|//   UNION ALL
comment|//   SELECT deptno FROM emp
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|union
argument_list|(
literal|true
argument_list|,
literal|1
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(DEPTNO=[$7])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRepeatUnion1
parameter_list|()
block|{
comment|// Generates the sequence 1,2,3,...10 using a repeat union. Equivalent SQL:
comment|//   WITH RECURSIVE delta(n) AS (
comment|//     VALUES (1)
comment|//     UNION ALL
comment|//     SELECT n+1 FROM delta WHERE n< 10
comment|//   )
comment|//   SELECT * FROM delta
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"i"
block|}
argument_list|,
literal|1
argument_list|)
operator|.
name|transientScan
argument_list|(
literal|"DELTA_TABLE"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|repeatUnion
argument_list|(
literal|"DELTA_TABLE"
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalRepeatUnion(all=[true])\n"
operator|+
literal|"  LogicalTableSpool(readType=[LAZY], writeType=[LAZY], table=[[DELTA_TABLE]])\n"
operator|+
literal|"    LogicalValues(tuples=[[{ 1 }]])\n"
operator|+
literal|"  LogicalTableSpool(readType=[LAZY], writeType=[LAZY], table=[[DELTA_TABLE]])\n"
operator|+
literal|"    LogicalProject($f0=[+($0, 1)])\n"
operator|+
literal|"      LogicalFilter(condition=[<($0, 10)])\n"
operator|+
literal|"        LogicalTableScan(table=[[DELTA_TABLE]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRepeatUnion2
parameter_list|()
block|{
comment|// Generates the factorial function from 0 to 7. Equivalent SQL:
comment|//   WITH RECURSIVE delta (n, fact) AS (
comment|//     VALUES (0, 1)
comment|//     UNION ALL
comment|//     SELECT n+1, (n+1)*fact FROM delta WHERE n< 7
comment|//   )
comment|//   SELECT * FROM delta
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"n"
block|,
literal|"fact"
block|}
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|.
name|transientScan
argument_list|(
literal|"AUX"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"n"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|7
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"n"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"n"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"fact"
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"n"
argument_list|,
literal|"fact"
argument_list|)
argument_list|)
operator|.
name|repeatUnion
argument_list|(
literal|"AUX"
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalRepeatUnion(all=[true])\n"
operator|+
literal|"  LogicalTableSpool(readType=[LAZY], writeType=[LAZY], table=[[AUX]])\n"
operator|+
literal|"    LogicalValues(tuples=[[{ 0, 1 }]])\n"
operator|+
literal|"  LogicalTableSpool(readType=[LAZY], writeType=[LAZY], table=[[AUX]])\n"
operator|+
literal|"    LogicalProject(n=[+($0, 1)], fact=[*(+($0, 1), $1)])\n"
operator|+
literal|"      LogicalFilter(condition=[<($0, 7)])\n"
operator|+
literal|"        LogicalTableScan(table=[[AUX]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIntersect
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT empno FROM emp
comment|//   WHERE deptno = 20
comment|//   INTERSECT
comment|//   SELECT deptno FROM dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|intersect
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalIntersect(all=[false])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"    LogicalFilter(condition=[=($7, 20)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIntersect3
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno FROM dept
comment|//   INTERSECT ALL
comment|//   SELECT empno FROM emp
comment|//   INTERSECT ALL
comment|//   SELECT deptno FROM emp
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|intersect
argument_list|(
literal|true
argument_list|,
literal|3
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalIntersect(all=[true])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$7])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExcept
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT empno FROM emp
comment|//   WHERE deptno = 20
comment|//   MINUS
comment|//   SELECT deptno FROM dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|minus
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalMinus(all=[false])\n"
operator|+
literal|"  LogicalProject(DEPTNO=[$0])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"    LogicalFilter(condition=[=($7, 20)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoin
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM (SELECT * FROM emp WHERE comm IS NULL)
comment|//   JOIN dept ON emp.deptno = dept.deptno
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalJoin(condition=[=($7, $8)], joinType=[inner])\n"
operator|+
literal|"  LogicalFilter(condition=[IS NULL($6)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Same as {@link #testJoin} using USING. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinUsing
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root2
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"COMM"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
literal|"DEPTNO"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalJoin(condition=[=($7, $8)], joinType=[inner])\n"
operator|+
literal|"  LogicalFilter(condition=[IS NULL($6)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root2
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoin2
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   LEFT JOIN dept ON emp.deptno = dept.deptno
comment|//     AND emp.empno = 123
comment|//     AND dept.deptno IS NOT NULL
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|LEFT
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|123
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Note that "dept.deptno IS NOT NULL" has been simplified away.
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalJoin(condition=[AND(=($7, $8), =($0, 123))], joinType=[left])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoinCartesian
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT * emp CROSS JOIN dept
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCorrelationFails
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Holder
argument_list|<
name|RexCorrelVariable
argument_list|>
name|v
init|=
name|Holder
operator|.
name|of
argument_list|(
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|variable
argument_list|(
name|v
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|v
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|v
operator|.
name|get
argument_list|()
operator|.
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected error"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"variable $cor0 must not be used by left input to correlation"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCorrelationWithCondition
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Holder
argument_list|<
name|RexCorrelVariable
argument_list|>
name|v
init|=
name|Holder
operator|.
name|of
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|variable
argument_list|(
name|v
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
name|v
operator|.
name|get
argument_list|()
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|LEFT
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"SAL"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1000
argument_list|)
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|v
operator|.
name|get
argument_list|()
operator|.
name|id
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Note that the join filter gets pushed to the right-hand input of
comment|// LogicalCorrelate
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{7}])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalFilter(condition=[=($cor0.SAL, 1000)])\n"
operator|+
literal|"    LogicalFilter(condition=[=($0, $cor0.DEPTNO)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAntiJoin
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT * FROM dept d
comment|//   WHERE NOT EXISTS (SELECT 1 FROM emp e WHERE e.deptno = d.deptno)
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|antiJoin
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalJoin(condition=[=($0, $10)], joinType=[anti])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAlias
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp AS e, dept
comment|//   WHERE e.deptno = dept.deptno
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|LEFT
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPT"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"ENAME"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPT"
argument_list|,
literal|"DNAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(ENAME=[$1], DNAME=[$9])\n"
operator|+
literal|"  LogicalFilter(condition=[=($7, $8)])\n"
operator|+
literal|"    LogicalJoin(condition=[true], joinType=[left])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"DNAME"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAlias2
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp AS e, emp as m, dept
comment|//   WHERE e.deptno = dept.deptno
comment|//   AND m.empno = e.mgr
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"m"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPT"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"m"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalFilter(condition=[AND(=($7, $16), =($8, $3))])\n"
operator|+
literal|"  LogicalJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"    LogicalJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAliasSort
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e"
argument_list|)
operator|.
name|sort
argument_list|(
literal|0
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"  LogicalSort(sort0=[$0], dir0=[ASC])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAliasLimit
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e"
argument_list|)
operator|.
name|sort
argument_list|(
literal|1
argument_list|)
operator|.
name|sortLimit
argument_list|(
literal|10
argument_list|,
literal|20
argument_list|)
comment|// aliases were lost here if preceded by sort()
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0])\n"
operator|+
literal|"  LogicalSort(sort0=[$1], dir0=[ASC], offset=[10], fetch=[20])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1551">[CALCITE-1551]    * RelBuilder's project() doesn't preserve alias</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testAliasProject
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"EMP_alias"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMP_alias"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[$7])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that table aliases are propagated even when there is a project on    * top of a project. (Aliases tend to get lost when projects are merged). */
annotation|@
name|Test
specifier|public
name|void
name|testAliasProjectProject
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"EMP_alias"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"sum"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMP_alias"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(sum=[10], DEPTNO=[$7])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that table aliases are propagated and are available to a filter,    * even when there is a project on top of a project. (Aliases tend to get lost    * when projects are merged). */
annotation|@
name|Test
specifier|public
name|void
name|testAliasFilter
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"EMP_alias"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
comment|// literal 20
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
comment|// DEPTNO
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMP_alias"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalFilter(condition=[>($1, $2)])\n"
operator|+
literal|"  LogicalProject($f1=[20], $f2=[10], DEPTNO=[$7])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that the {@link RelBuilder#alias(RexNode, String)} function is    * idempotent. */
annotation|@
name|Test
specifier|public
name|void
name|testScanAlias
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
expr_stmt|;
comment|// Simplify "emp.deptno as d as d" to "emp.deptno as d".
specifier|final
name|RexNode
name|e0
init|=
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
literal|"D"
argument_list|)
argument_list|,
literal|"D"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|e0
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"AS($7, 'D')"
argument_list|)
argument_list|)
expr_stmt|;
comment|// It would be nice if RelBuilder could simplify
comment|// "emp.deptno as deptno" to "emp.deptno", but there is not
comment|// enough information in RexInputRef.
specifier|final
name|RexNode
name|e1
init|=
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
literal|"DEPTNO"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|e1
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"AS($7, 'DEPTNO')"
argument_list|)
argument_list|)
expr_stmt|;
comment|// The intervening alias 'DEPTNO' is removed
specifier|final
name|RexNode
name|e2
init|=
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
literal|"D1"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|e2
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"AS($7, 'D1')"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Simplify "emp.deptno as d2 as d3" to "emp.deptno as d3"
comment|// because "d3" alias overrides "d2".
specifier|final
name|RexNode
name|e3
init|=
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
literal|"D2"
argument_list|)
argument_list|,
literal|"D3"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|e3
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"AS($7, 'D3')"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|project
argument_list|(
name|e0
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(D=[$7], DEPTNO=[$7], D1=[$7], D3=[$7])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that project field name aliases are suggested incrementally.    */
annotation|@
name|Test
specifier|public
name|void
name|testAliasSuggester
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0], EMPNO0=[$0], EMPNO1=[$0], "
operator|+
literal|"EMPNO2=[$0], EMPNO3=[$0], EMPNO4=[$0], EMPNO5=[$0], "
operator|+
literal|"EMPNO6=[$0], EMPNO7=[$0], EMPNO8=[$0], EMPNO9=[$0], EMPNO10=[$0])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAliasAggregate
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"EMP_alias"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|builder
operator|.
name|groupKey
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMP_alias"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|sum
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"sum"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMP_alias"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(sum=[$1], DEPTNO=[$0])\n"
operator|+
literal|"  LogicalAggregate(group=[{0}], agg#0=[SUM($1)])\n"
operator|+
literal|"    LogicalProject(DEPTNO=[$7], $f1=[20])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a projection retains field names after a join. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectJoin
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPT"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|)
comment|// essentially a no-op, was previously throwing exception due to
comment|// project() using join-renamed fields
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPT"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[$8], EMPNO=[$0], MGR=[$3])\n"
operator|+
literal|"  LogicalJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a projection after a projection. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectProject
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e"
argument_list|)
operator|.
name|projectPlus
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
literal|"x"
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|builder
operator|.
name|fields
argument_list|()
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[$7], EMPNO=[$0], MGR=[$3], x=[+($0, $3)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3462">[CALCITE-3462]    * Add projectExcept method in RelBuilder for projecting out expressions</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectExceptWithOrdinal
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|projectExcept
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0], ENAME=[$1], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3462">[CALCITE-3462]    * Add projectExcept method in RelBuilder for projecting out expressions</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectExceptWithName
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|projectExcept
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"MGR"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"JOB"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0], ENAME=[$1], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3462">[CALCITE-3462]    * Add projectExcept method in RelBuilder for projecting out expressions</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectExceptWithExplicitAliasAndName
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e"
argument_list|)
operator|.
name|projectExcept
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"JOB"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0], ENAME=[$1], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3462">[CALCITE-3462]    * Add projectExcept method in RelBuilder for projecting out expressions</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectExceptWithImplicitAliasAndName
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|projectExcept
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMP"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMP"
argument_list|,
literal|"JOB"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(EMPNO=[$0], ENAME=[$1], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3462">[CALCITE-3462]    * Add projectExcept method in RelBuilder for projecting out expressions</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectExceptWithDuplicateField
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|IllegalArgumentException
name|ex
init|=
name|assertThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|projectExcept
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMP"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMP"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|,
literal|"Project should fail since we are trying to remove the same field two times."
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"Input list contains duplicates."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3462">[CALCITE-3462]    * Add projectExcept method in RelBuilder for projecting out expressions</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testProjectExceptWithMissingField
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
expr_stmt|;
name|RexNode
name|deptnoField
init|=
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
decl_stmt|;
name|IllegalArgumentException
name|ex
init|=
name|assertThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|builder
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"ENAME"
argument_list|)
argument_list|)
operator|.
name|projectExcept
argument_list|(
name|deptnoField
argument_list|)
expr_stmt|;
block|}
argument_list|,
literal|"Project should fail since we are trying to remove a field that does not exist."
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
name|allOf
argument_list|(
name|containsString
argument_list|(
literal|"Expression"
argument_list|)
argument_list|,
name|containsString
argument_list|(
literal|"not found"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiLevelAlias
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"m"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPT"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|16
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"m"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"e"
argument_list|,
literal|"MGR"
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"all"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPT"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|100
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPT"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"all"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[$0], EMPNO=[$2])\n"
operator|+
literal|"  LogicalFilter(condition=[>($0, 100)])\n"
operator|+
literal|"    LogicalProject(DEPTNO=[$16], DEPTNO0=[$16], EMPNO=[$8], MGR=[$3])\n"
operator|+
literal|"      LogicalJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"        LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"        LogicalJoin(condition=[true], joinType=[inner])\n"
operator|+
literal|"          LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"          LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnionAlias
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e1"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CONCAT
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"ENAME"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|"-1"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"e2"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CONCAT
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"ENAME"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|"-2"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|union
argument_list|(
literal|false
argument_list|)
comment|// aliases lost here
operator|.
name|project
argument_list|(
name|builder
operator|.
name|fields
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject($f1=[$1], EMPNO=[$0])\n"
operator|+
literal|"  LogicalUnion(all=[false])\n"
operator|+
literal|"    LogicalProject(EMPNO=[$0], $f1=[||($1, '-1')])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"    LogicalProject(EMPNO=[$0], $f1=[||($1, '-2')])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1523">[CALCITE-1523]    * Add RelBuilder field() method to reference aliased relations not on top of    * stack</a>, accessing tables aliased that are not accessible in the top    * RelNode. */
annotation|@
name|Test
specifier|public
name|void
name|testAliasPastTop
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   LEFT JOIN dept ON emp.deptno = dept.deptno
comment|//     AND emp.empno = 123
comment|//     AND dept.deptno IS NOT NULL
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|LEFT
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"EMP"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"DEPT"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"EMP"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|123
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalJoin(condition=[AND(=($7, $8), =($0, 123))], joinType=[left])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** As {@link #testAliasPastTop()}. */
annotation|@
name|Test
specifier|public
name|void
name|testAliasPastTop2
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT t1.EMPNO, t2.EMPNO, t3.DEPTNO
comment|//   FROM emp t1
comment|//   INNER JOIN emp t2 ON t1.EMPNO = t2.EMPNO
comment|//   INNER JOIN dept t3 ON t1.DEPTNO = t3.DEPTNO
comment|//     AND t2.JOB != t3.LOC
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"t1"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|as
argument_list|(
literal|"t2"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"t1"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"t2"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|as
argument_list|(
literal|"t3"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"t1"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"t3"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|not
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"t2"
argument_list|,
literal|"JOB"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|"t3"
argument_list|,
literal|"LOC"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Cols:
comment|// 0-7   EMP as t1
comment|// 8-15  EMP as t2
comment|// 16-18 DEPT as t3
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalJoin(condition=[AND(=($7, $16),<>($10, $18))], joinType=[inner])\n"
operator|+
literal|"  LogicalJoin(condition=[=($0, $8)], joinType=[inner])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmpty
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT deptno, true FROM dept LIMIT 0
comment|// optimized to
comment|//   VALUES
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|.
name|empty
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expectedType
init|=
literal|"RecordType(TINYINT NOT NULL DEPTNO, BOOLEAN NOT NULL $f1) NOT NULL"
decl_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3172">[CALCITE-3172]    * RelBuilder#empty does not keep aliases</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testEmptyWithAlias
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(DEPTNO=[$0], DNAME=[$1])\n  LogicalValues(tuples=[[]])\n"
decl_stmt|;
specifier|final
name|String
name|expectedType
init|=
literal|"RecordType(TINYINT NOT NULL DEPTNO, VARCHAR(14) DNAME) NOT NULL"
decl_stmt|;
comment|// Scan + Empty + Project (without alias)
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|empty
argument_list|()
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DNAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
comment|// Scan + Empty + Project (with alias)
name|root
operator|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|as
argument_list|(
literal|"d"
argument_list|)
operator|.
name|empty
argument_list|()
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|"d"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|"d"
argument_list|,
literal|"DNAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
comment|// Scan + Filter false (implicitly converted into Empty) + Project (with alias)
name|root
operator|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|as
argument_list|(
literal|"d"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|"d"
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|"d"
argument_list|,
literal|"DNAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValues
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   VALUES (true, 1), (false, -50) AS t(a, b)
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
operator|-
literal|50
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[{ true, 1 }, { false, -50 }]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expectedType
init|=
literal|"RecordType(BOOLEAN NOT NULL a, INTEGER NOT NULL b) NOT NULL"
decl_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests creating Values with some field names and some values null. */
annotation|@
name|Test
specifier|public
name|void
name|testValuesNullable
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   VALUES (null, 1, 'abc'), (false, null, 'longer string')
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|null
block|,
literal|"c"
block|}
argument_list|,
literal|null
argument_list|,
literal|1
argument_list|,
literal|"abc"
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|"longer string"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[{ null, 1, 'abc' }, { false, null, 'longer string' }]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expectedType
init|=
literal|"RecordType(BOOLEAN a, INTEGER expr$1, CHAR(13) NOT NULL c) NOT NULL"
decl_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadNullFieldNames
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|,
literal|"a"
argument_list|,
literal|"b"
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadNoFields
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadNoValues
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadOddMultiple
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesBadAllNull
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelBuilder
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected error, got "
operator|+
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"All values of field 'b' are null; cannot deduce type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesAllNull
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
name|rowType
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[{ null, null }, { 1, null }]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expectedType
init|=
literal|"RecordType(BIGINT NOT NULL a, VARCHAR(10) NOT NULL a) NOT NULL"
decl_stmt|;
name|assertThat
argument_list|(
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFullTypeString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expectedType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSort
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   ORDER BY 3. 1 DESC
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|,
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSort(sort0=[$2], sort1=[$0], dir0=[ASC], dir1=[DESC])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// same result using ordinals
specifier|final
name|RelNode
name|root2
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root2
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1015">[CALCITE-1015]    * OFFSET 0 causes AssertionError</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testTrivialSort
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   OFFSET 0
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sortLimit
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortDuplicate
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   ORDER BY empno DESC, deptno, empno ASC, hiredate
comment|//
comment|// The sort key "empno ASC" is unnecessary and is ignored.
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"HIREDATE"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSort(sort0=[$0], sort1=[$7], sort2=[$4], "
operator|+
literal|"dir0=[DESC], dir1=[ASC], dir2=[ASC])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortByExpression
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   ORDER BY ename ASC NULLS LAST, hiredate + mgr DESC NULLS FIRST
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
name|builder
operator|.
name|nullsLast
argument_list|(
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|nullsFirst
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|4
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7])\n"
operator|+
literal|"  LogicalSort(sort0=[$1], sort1=[$8], dir0=[DESC-nulls-last], dir1=[ASC-nulls-first])\n"
operator|+
literal|"    LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], $f8=[+($4, $3)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLimit
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   OFFSET 2 FETCH 10
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|limit
argument_list|(
literal|2
argument_list|,
literal|10
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSort(offset=[2], fetch=[10])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortLimit
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   ORDER BY deptno DESC FETCH 10
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
literal|10
argument_list|,
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSort(sort0=[$7], dir0=[DESC], fetch=[10])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortLimit0
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   ORDER BY deptno DESC FETCH 0
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalValues(tuples=[[]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1610">[CALCITE-1610]    * RelBuilder sort-combining optimization treats aliases incorrectly</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortOverProjectSort
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
literal|0
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
comment|// was throwing exception here when attempting to apply to
comment|// inner sort node
operator|.
name|limit
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
literal|0
argument_list|)
operator|.
name|project
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"F1"
argument_list|)
argument_list|)
operator|.
name|limit
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
comment|// make sure we can still access the field by alias
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"F1"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|expected
init|=
literal|"LogicalProject(F1=[$1])\n"
operator|+
literal|"  LogicalSort(sort0=[$0], dir0=[ASC], fetch=[1])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a sort on a field followed by a limit gives the same    * effect as calling sortLimit.    *    *<p>In general a relational operator cannot rely on the order of its input,    * but it is reasonable to merge sort and limit if they were created by    * consecutive builder operations. And clients such as Piglet rely on it. */
annotation|@
name|Test
specifier|public
name|void
name|testSortThenLimit
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|limit
argument_list|(
operator|-
literal|1
argument_list|,
literal|10
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalSort(sort0=[$7], dir0=[DESC], fetch=[10])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|root2
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
literal|10
argument_list|,
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root2
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a sort on an expression followed by a limit gives the same    * effect as calling sortLimit. */
annotation|@
name|Test
specifier|public
name|void
name|testSortExpThenLimit
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|sort
argument_list|(
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|limit
argument_list|(
literal|3
argument_list|,
literal|10
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalProject(DEPTNO=[$0], DNAME=[$1], LOC=[$2])\n"
operator|+
literal|"  LogicalSort(sort0=[$3], dir0=[DESC], offset=[3], fetch=[10])\n"
operator|+
literal|"    LogicalProject(DEPTNO=[$0], DNAME=[$1], LOC=[$2], $f3=[+($0, 1)])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|root2
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|sortLimit
argument_list|(
literal|3
argument_list|,
literal|10
argument_list|,
name|builder
operator|.
name|desc
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root2
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests {@link org.apache.calcite.tools.RelRunner} for a VALUES query. */
annotation|@
name|Test
specifier|public
name|void
name|testRunValues
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Equivalent SQL:
comment|//   VALUES (true, 1), (false, -50) AS t(a, b)
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|,
literal|true
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
operator|-
literal|50
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|preparedStatement
init|=
name|RelRunners
operator|.
name|run
argument_list|(
name|root
argument_list|)
init|)
block|{
name|String
name|s
init|=
name|CalciteAssert
operator|.
name|toString
argument_list|(
name|preparedStatement
operator|.
name|executeQuery
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|result
init|=
literal|"a=true; b=1\n"
operator|+
literal|"a=false; b=-50\n"
decl_stmt|;
name|assertThat
argument_list|(
name|s
argument_list|,
name|is
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Tests {@link org.apache.calcite.tools.RelRunner} for a table scan + filter    * query. */
annotation|@
name|Test
specifier|public
name|void
name|testRun
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Equivalent SQL:
comment|//   SELECT * FROM EMP WHERE DEPTNO = 20
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Note that because the table has been resolved in the RelNode tree
comment|// we do not need to supply a "schema" as context to the runner.
try|try
init|(
name|PreparedStatement
name|preparedStatement
init|=
name|RelRunners
operator|.
name|run
argument_list|(
name|root
argument_list|)
init|)
block|{
name|String
name|s
init|=
name|CalciteAssert
operator|.
name|toString
argument_list|(
name|preparedStatement
operator|.
name|executeQuery
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|result
init|=
literal|""
operator|+
literal|"EMPNO=7369; ENAME=SMITH; JOB=CLERK; MGR=7902; HIREDATE=1980-12-17; SAL=800.00; COMM=null; DEPTNO=20\n"
operator|+
literal|"EMPNO=7566; ENAME=JONES; JOB=MANAGER; MGR=7839; HIREDATE=1981-02-04; SAL=2975.00; COMM=null; DEPTNO=20\n"
operator|+
literal|"EMPNO=7788; ENAME=SCOTT; JOB=ANALYST; MGR=7566; HIREDATE=1987-04-19; SAL=3000.00; COMM=null; DEPTNO=20\n"
operator|+
literal|"EMPNO=7876; ENAME=ADAMS; JOB=CLERK; MGR=7788; HIREDATE=1987-05-23; SAL=1100.00; COMM=null; DEPTNO=20\n"
operator|+
literal|"EMPNO=7902; ENAME=FORD; JOB=ANALYST; MGR=7566; HIREDATE=1981-12-03; SAL=3000.00; COMM=null; DEPTNO=20\n"
decl_stmt|;
name|assertThat
argument_list|(
name|s
argument_list|,
name|is
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1595">[CALCITE-1595]    * RelBuilder.call throws NullPointerException if argument types are    * invalid</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testTypeInferenceValidation
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// test for a) call(operator, Iterable<RexNode>)
specifier|final
name|RexNode
name|arg0
init|=
name|builder
operator|.
name|literal
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|arg1
init|=
name|builder
operator|.
name|literal
argument_list|(
literal|"xyz"
argument_list|)
decl_stmt|;
try|try
block|{
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Invalid combination of parameter types"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"Cannot infer return type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// test for b) call(operator, RexNode...)
try|try
block|{
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Invalid combination of parameter types"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"Cannot infer return type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMatchRecognize
parameter_list|()
block|{
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   MATCH_RECOGNIZE (
comment|//     PARTITION BY deptno
comment|//     ORDER BY empno asc
comment|//     MEASURES
comment|//       STRT.mgr as start_nw,
comment|//       LAST(DOWN.mgr) as bottom_nw,
comment|//     PATTERN (STRT DOWN+ UP+) WITHIN INTERVAL '5' SECOND
comment|//     DEFINE
comment|//       DOWN as DOWN.mgr< PREV(DOWN.mgr),
comment|//       UP as UP.mgr> PREV(UP.mgr)
comment|//   )
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
name|RexNode
name|pattern
init|=
name|builder
operator|.
name|patternConcat
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|"STRT"
argument_list|)
argument_list|,
name|builder
operator|.
name|patternQuantify
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|"DOWN"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|patternQuantify
argument_list|(
name|builder
operator|.
name|literal
argument_list|(
literal|"UP"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|pdBuilder
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<>
argument_list|()
decl_stmt|;
name|RexNode
name|downDefinition
init|=
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PREV
argument_list|,
name|builder
operator|.
name|patternField
argument_list|(
literal|"DOWN"
argument_list|,
name|intType
argument_list|,
literal|3
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PREV
argument_list|,
name|builder
operator|.
name|patternField
argument_list|(
literal|"DOWN"
argument_list|,
name|intType
argument_list|,
literal|3
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|pdBuilder
operator|.
name|put
argument_list|(
literal|"DOWN"
argument_list|,
name|downDefinition
argument_list|)
expr_stmt|;
name|RexNode
name|upDefinition
init|=
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PREV
argument_list|,
name|builder
operator|.
name|patternField
argument_list|(
literal|"UP"
argument_list|,
name|intType
argument_list|,
literal|3
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PREV
argument_list|,
name|builder
operator|.
name|patternField
argument_list|(
literal|"UP"
argument_list|,
name|intType
argument_list|,
literal|3
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|pdBuilder
operator|.
name|put
argument_list|(
literal|"UP"
argument_list|,
name|upDefinition
argument_list|)
expr_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|measuresBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<>
argument_list|()
decl_stmt|;
name|measuresBuilder
operator|.
name|add
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|patternField
argument_list|(
literal|"STRT"
argument_list|,
name|intType
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|"start_nw"
argument_list|)
argument_list|)
expr_stmt|;
name|measuresBuilder
operator|.
name|add
argument_list|(
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LAST
argument_list|,
name|builder
operator|.
name|patternField
argument_list|(
literal|"DOWN"
argument_list|,
name|intType
argument_list|,
literal|3
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|"bottom_nw"
argument_list|)
argument_list|)
expr_stmt|;
name|RexNode
name|after
init|=
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|SqlMatchRecognize
operator|.
name|AfterOption
operator|.
name|SKIP_TO_NEXT_ROW
argument_list|)
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|partitionKeysBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<>
argument_list|()
decl_stmt|;
name|partitionKeysBuilder
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
expr_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|orderKeysBuilder
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<>
argument_list|()
decl_stmt|;
name|orderKeysBuilder
operator|.
name|add
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
expr_stmt|;
name|RexNode
name|interval
init|=
name|builder
operator|.
name|literal
argument_list|(
literal|"INTERVAL '5' SECOND"
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|subsets
init|=
name|ImmutableMap
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|match
argument_list|(
name|pattern
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|pdBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|measuresBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|after
argument_list|,
name|subsets
argument_list|,
literal|false
argument_list|,
name|partitionKeysBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|orderKeysBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|interval
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalMatch(partition=[[7]], order=[[0]], "
operator|+
literal|"outputFields=[[$7, 'start_nw', 'bottom_nw']], allRows=[false], "
operator|+
literal|"after=[FLAG(SKIP TO NEXT ROW)], pattern=[(('STRT', "
operator|+
literal|"PATTERN_QUANTIFIER('DOWN', 1, -1, false)), "
operator|+
literal|"PATTERN_QUANTIFIER('UP', 1, -1, false))], "
operator|+
literal|"isStrictStarts=[false], isStrictEnds=[false], "
operator|+
literal|"interval=['INTERVAL ''5'' SECOND'], subsets=[[]], "
operator|+
literal|"patternDefinitions=[[<(PREV(DOWN.$3, 0), PREV(DOWN.$3, 1)), "
operator|+
literal|">(PREV(UP.$3, 0), PREV(UP.$3, 1))]], "
operator|+
literal|"inputFields=[[EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFilterCastAny
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|anyType
init|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|ANY
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|cast
argument_list|(
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|anyType
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalFilter(condition=[CAST($0):BOOLEAN NOT NULL])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFilterCastNull
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|builder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalFilter(condition=[=($7, 10)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Tests filter builder with correlation variables */
annotation|@
name|Test
specifier|public
name|void
name|testFilterWithCorrelationVariables
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Holder
argument_list|<
name|RexCorrelVariable
argument_list|>
name|v
init|=
name|Holder
operator|.
name|of
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|variable
argument_list|(
name|v
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|filter
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|v
operator|.
name|get
argument_list|()
operator|.
name|id
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
name|v
operator|.
name|get
argument_list|()
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|30
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
name|v
operator|.
name|get
argument_list|()
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|builder
operator|.
name|isNull
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|LEFT
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"SAL"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1000
argument_list|)
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|v
operator|.
name|get
argument_list|()
operator|.
name|id
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{7}])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalFilter(condition=[=($cor0.SAL, 1000)])\n"
operator|+
literal|"    LogicalFilter(condition=[OR(AND(<($cor0.DEPTNO, 30),>($cor0.DEPTNO, 20)), "
operator|+
literal|"IS NULL($2))], variablesSet=[[$cor0]])\n"
operator|+
literal|"      LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFilterEmpty
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
comment|// We intend to call
comment|//   filter(Iterable<CorrelationId>, RexNode...)
comment|// with zero varargs, not
comment|//   filter(Iterable<RexNode>)
comment|// Let's hope they're distinct after type erasure.
operator|.
name|filter
argument_list|(
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
literal|"LogicalTableScan(table=[[scott, EMP]])\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRelBuilderToString
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
expr_stmt|;
comment|// One entry on the stack, a single-node tree
specifier|final
name|String
name|expected1
init|=
literal|"LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected1
argument_list|)
argument_list|)
expr_stmt|;
comment|// One entry on the stack, a two-node tree
name|builder
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expected2
init|=
literal|"LogicalFilter(condition=[=($2, 3)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Two entries on the stack
name|builder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
expr_stmt|;
specifier|final
name|String
name|expected3
init|=
literal|"LogicalTableScan(table=[[scott, DEPT]])\n"
operator|+
literal|"LogicalFilter(condition=[=($2, 3)])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|Util
operator|.
name|toLinux
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected3
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Ensures that relational algebra ({@link RelBuilder}) works with SQL views.    *    *<p>This test currently fails (thus ignored).    */
annotation|@
name|Test
specifier|public
name|void
name|testExpandViewInRelBuilder
parameter_list|()
throws|throws
name|SQLException
block|{
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|)
init|)
block|{
specifier|final
name|Frameworks
operator|.
name|ConfigBuilder
name|configBuilder
init|=
name|expandingConfig
argument_list|(
name|connection
argument_list|)
decl_stmt|;
specifier|final
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
init|=
operator|(
name|RelOptTable
operator|.
name|ViewExpander
operator|)
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|configBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelFactories
operator|.
name|TableScanFactory
name|tableScanFactory
init|=
name|RelFactories
operator|.
name|expandingScanFactory
argument_list|(
name|viewExpander
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_TABLE_SCAN_FACTORY
argument_list|)
decl_stmt|;
name|configBuilder
operator|.
name|context
argument_list|(
name|Contexts
operator|.
name|of
argument_list|(
name|tableScanFactory
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|configBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|node
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"MYVIEW"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
try|try
init|(
name|PreparedStatement
name|statement
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|RelRunner
operator|.
name|class
argument_list|)
operator|.
name|prepare
argument_list|(
name|node
argument_list|)
init|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|()
init|)
block|{
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|count
operator|>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandViewShouldKeepAlias
parameter_list|()
throws|throws
name|SQLException
block|{
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|)
init|)
block|{
specifier|final
name|Frameworks
operator|.
name|ConfigBuilder
name|configBuilder
init|=
name|expandingConfig
argument_list|(
name|connection
argument_list|)
decl_stmt|;
specifier|final
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
init|=
operator|(
name|RelOptTable
operator|.
name|ViewExpander
operator|)
name|Frameworks
operator|.
name|getPlanner
argument_list|(
name|configBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelFactories
operator|.
name|TableScanFactory
name|tableScanFactory
init|=
name|RelFactories
operator|.
name|expandingScanFactory
argument_list|(
name|viewExpander
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_TABLE_SCAN_FACTORY
argument_list|)
decl_stmt|;
name|configBuilder
operator|.
name|context
argument_list|(
name|Contexts
operator|.
name|of
argument_list|(
name|tableScanFactory
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|configBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|node
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"MYVIEW"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|"MYVIEW"
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|"MYVIEW"
argument_list|,
literal|"ENAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|expected
init|=
literal|"LogicalProject(EMPNO=[$0], ENAME=[$1])\n"
operator|+
literal|"  LogicalFilter(condition=[=(1, 1)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|node
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandTable
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|RelOptTable
operator|.
name|ViewExpander
name|viewExpander
init|=
parameter_list|(
name|rowType
parameter_list|,
name|queryString
parameter_list|,
name|schemaPath
parameter_list|,
name|viewPath
parameter_list|)
lambda|->
literal|null
decl_stmt|;
specifier|final
name|RelFactories
operator|.
name|TableScanFactory
name|tableScanFactory
init|=
name|RelFactories
operator|.
name|expandingScanFactory
argument_list|(
name|viewExpander
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_TABLE_SCAN_FACTORY
argument_list|)
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|)
init|)
block|{
comment|// First, use a non-expanding RelBuilder. Plan contains LogicalTableScan.
specifier|final
name|Frameworks
operator|.
name|ConfigBuilder
name|configBuilder
init|=
name|expandingConfig
argument_list|(
name|connection
argument_list|)
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|configBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalFilter(condition=[>($2, 10)])\n"
operator|+
literal|"  LogicalTableScan(table=[[JDBC_SCOTT, EMP]])\n"
decl_stmt|;
name|checkExpandTable
argument_list|(
name|builder
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// Next, use an expanding RelBuilder. Plan contains JdbcTableScan,
comment|// because RelBuilder.scan has called RelOptTable.toRel.
specifier|final
name|FrameworkConfig
name|config
init|=
name|configBuilder
operator|.
name|context
argument_list|(
name|Contexts
operator|.
name|of
argument_list|(
name|tableScanFactory
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|builder2
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expected2
init|=
literal|"LogicalFilter(condition=[>($2, 10)])\n"
operator|+
literal|"  JdbcTableScan(table=[[JDBC_SCOTT, EMP]])\n"
decl_stmt|;
name|checkExpandTable
argument_list|(
name|builder2
argument_list|,
name|hasTree
argument_list|(
name|expected2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkExpandTable
parameter_list|(
name|RelBuilder
name|builder
parameter_list|,
name|Matcher
argument_list|<
name|RelNode
argument_list|>
name|matcher
parameter_list|)
block|{
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"JDBC_SCOTT"
argument_list|,
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExchange
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|exchange
argument_list|(
name|RelDistributions
operator|.
name|hash
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalExchange(distribution=[hash[0]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortExchange
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sortExchange
argument_list|(
name|RelDistributions
operator|.
name|hash
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"LogicalSortExchange(distribution=[hash[0]], collation=[[0]])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCorrelate
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Holder
argument_list|<
name|RexCorrelVariable
argument_list|>
name|v
init|=
name|Holder
operator|.
name|of
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|variable
argument_list|(
name|v
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
name|v
operator|.
name|get
argument_list|()
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|correlate
argument_list|(
name|JoinRelType
operator|.
name|LEFT
argument_list|,
name|v
operator|.
name|get
argument_list|()
operator|.
name|id
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{7}])\n"
operator|+
literal|"  LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalFilter(condition=[=($0, $cor0.DEPTNO)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCorrelateWithComplexFields
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Holder
argument_list|<
name|RexCorrelVariable
argument_list|>
name|v
init|=
name|Holder
operator|.
name|of
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|variable
argument_list|(
name|v
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
name|v
operator|.
name|get
argument_list|()
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|correlate
argument_list|(
name|JoinRelType
operator|.
name|LEFT
argument_list|,
name|v
operator|.
name|get
argument_list|()
operator|.
name|id
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|"RENAMED_EMPNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|""
operator|+
literal|"LogicalCorrelate(correlation=[$cor0], joinType=[left], requiredColumns=[{0, 7}])\n"
operator|+
literal|"  LogicalProject(RENAMED_EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, EMP]])\n"
operator|+
literal|"  LogicalFilter(condition=[=($0, $cor0.DEPTNO)])\n"
operator|+
literal|"    LogicalTableScan(table=[[scott, DEPT]])\n"
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasTree
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testHints
parameter_list|()
block|{
specifier|final
name|RelHint
name|indexHint
init|=
name|RelHint
operator|.
name|of
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
literal|"INDEX"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"_idx1"
argument_list|,
literal|"_idx2"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelHint
name|propsHint
init|=
name|RelHint
operator|.
name|of
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"PROPERTIES"
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
literal|"parallelism"
argument_list|,
literal|"3"
argument_list|,
literal|"mem"
argument_list|,
literal|"20Mb"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RelHint
name|noHashJoinHint
init|=
name|RelHint
operator|.
name|of
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"NO_HASH_JOIN"
argument_list|)
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp /*+ INDEX(_idx1, _idx2) */
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|hints
argument_list|(
name|indexHint
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root
argument_list|,
name|hasHints
argument_list|(
literal|"[[INDEX inheritPath:[] options:[_idx1, _idx2]]]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Equivalent SQL:
comment|//   SELECT /*+  PROPERTIES(parallelism='3', mem='20Mb') */
comment|//   *
comment|//   FROM emp /*+ INDEX(_idx1, _idx2) */
specifier|final
name|RelNode
name|root1
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|hints
argument_list|(
name|indexHint
argument_list|,
name|propsHint
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root1
argument_list|,
name|hasHints
argument_list|(
literal|"[[INDEX inheritPath:[] options:[_idx1, _idx2]], "
operator|+
literal|"[PROPERTIES inheritPath:[0] options:{parallelism=3, mem=20Mb}]]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Equivalent SQL:
comment|//   SELECT /*+ NO_HASH_JOIN */
comment|//   *
comment|//   FROM emp
comment|//     join dept
comment|//     on emp.deptno = dept.deptno
specifier|final
name|RelNode
name|root2
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|hints
argument_list|(
name|noHashJoinHint
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|root2
argument_list|,
name|hasHints
argument_list|(
literal|"[[NO_HASH_JOIN inheritPath:[0]]]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testHintsOnEmptyStack
parameter_list|()
block|{
specifier|final
name|RelHint
name|indexHint
init|=
name|RelHint
operator|.
name|of
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
literal|"INDEX"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"_idx1"
argument_list|,
literal|"_idx2"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Attach hints on empty stack.
specifier|final
name|AssertionError
name|error
init|=
name|assertThrows
argument_list|(
name|AssertionError
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|hints
argument_list|(
name|indexHint
argument_list|)
argument_list|,
literal|"hints() should fail on empty stack"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|error
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"There is no relational expression to attach the hints"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testHintsOnNonHintable
parameter_list|()
block|{
specifier|final
name|RelHint
name|indexHint
init|=
name|RelHint
operator|.
name|of
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
literal|"INDEX"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"_idx1"
argument_list|,
literal|"_idx2"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Attach hints on non hintable.
specifier|final
name|AssertionError
name|error1
init|=
name|assertThrows
argument_list|(
name|AssertionError
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// Equivalent SQL:
comment|//   SELECT *
comment|//   FROM emp
comment|//   WHERE EMPNO = 124
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|equals
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|124
argument_list|)
argument_list|)
argument_list|)
operator|.
name|hints
argument_list|(
name|indexHint
argument_list|)
expr_stmt|;
block|}
argument_list|,
literal|"hints() should fail on non Hintable relational expression"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|error1
operator|.
name|getMessage
argument_list|()
argument_list|,
name|containsString
argument_list|(
literal|"The top relational expression is not a Hintable"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3747">[CALCITE-3747]    * Constructing BETWEEN with RelBuilder throws class cast exception</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testCallBetweenOperator
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|call
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|BETWEEN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|call
operator|.
name|toStringRaw
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"BETWEEN ASYMMETRIC($0, 1, 5)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

