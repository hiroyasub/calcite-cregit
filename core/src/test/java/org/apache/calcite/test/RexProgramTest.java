begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Strong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|NullSentinel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInterpreter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUnknownAs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeAssignmentRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimeString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampWithTimeZoneString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|BeforeEach
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Disabled
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|nullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNotEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNotSame
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Unit tests for {@link RexProgram} and  * {@link org.apache.calcite.rex.RexProgramBuilder}.  */
end_comment

begin_class
specifier|public
class|class
name|RexProgramTest
extends|extends
name|RexProgramBuilderBase
block|{
comment|/**    * Creates a RexProgramTest.    */
specifier|public
name|RexProgramTest
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
annotation|@
name|BeforeEach
specifier|public
name|void
name|setUp
parameter_list|()
block|{
name|super
operator|.
name|setUp
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|checkCnf
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
literal|"RexUtil.toCnf(rexBuilder, "
operator|+
name|node
operator|+
literal|")"
argument_list|,
name|RexUtil
operator|.
name|toCnf
argument_list|(
name|rexBuilder
argument_list|,
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkThresholdCnf
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|int
name|threshold
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
literal|"RexUtil.toCnf(rexBuilder, threshold="
operator|+
name|threshold
operator|+
literal|" , "
operator|+
name|node
operator|+
literal|")"
argument_list|,
name|RexUtil
operator|.
name|toCnf
argument_list|(
name|rexBuilder
argument_list|,
name|threshold
argument_list|,
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkPullFactorsUnchanged
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
name|checkPullFactors
argument_list|(
name|node
argument_list|,
name|node
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkPullFactors
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
literal|"RexUtil.pullFactors(rexBuilder, "
operator|+
name|node
operator|+
literal|")"
argument_list|,
name|RexUtil
operator|.
name|pullFactors
argument_list|(
name|rexBuilder
argument_list|,
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Asserts that given node has expected string representation with account of node type    * @param message extra message that clarifies where the node came from    * @param expected expected string representation of the node    * @param node node to check    */
specifier|private
name|void
name|assertNode
parameter_list|(
name|String
name|message
parameter_list|,
name|String
name|expected
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
name|String
name|actual
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
operator|||
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|NEW_SPECIFICATION
argument_list|)
condition|)
block|{
comment|// toString contains type (see RexCall.toString)
name|actual
operator|=
name|node
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|actual
operator|=
name|node
operator|+
literal|":"
operator|+
name|node
operator|.
name|getType
argument_list|()
operator|+
operator|(
name|node
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|?
literal|""
else|:
literal|" NOT NULL"
operator|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/** Simplifies an expression and checks that the result is as expected. */
specifier|private
name|void
name|checkSimplify
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
specifier|final
name|String
name|nodeString
init|=
name|node
operator|.
name|toString
argument_list|()
decl_stmt|;
name|checkSimplify3_
argument_list|(
name|node
argument_list|,
name|expected
argument_list|,
name|expected
argument_list|,
name|expected
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|.
name|equals
argument_list|(
name|nodeString
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"expected == node.toString(); "
operator|+
literal|"use checkSimplifyUnchanged"
argument_list|)
throw|;
block|}
block|}
comment|/** Simplifies an expression and checks that the result is unchanged. */
specifier|private
name|void
name|checkSimplifyUnchanged
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
specifier|final
name|String
name|expected
init|=
name|node
operator|.
name|toString
argument_list|()
decl_stmt|;
name|checkSimplify3_
argument_list|(
name|node
argument_list|,
name|expected
argument_list|,
name|expected
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** Simplifies an expression and checks the result if unknowns remain    * unknown, or if unknown becomes false. If the result is the same, use    * {@link #checkSimplify(RexNode, String)}.    *    * @param node Expression to simplify    * @param expected Expected simplification    * @param expectedFalse Expected simplification, if unknown is to be treated    *     as false    */
specifier|private
name|void
name|checkSimplify2
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|,
name|String
name|expectedFalse
parameter_list|)
block|{
name|checkSimplify3_
argument_list|(
name|node
argument_list|,
name|expected
argument_list|,
name|expectedFalse
argument_list|,
name|expected
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|.
name|equals
argument_list|(
name|expectedFalse
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"expected == expectedFalse; use checkSimplify"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|checkSimplify3
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|,
name|String
name|expectedFalse
parameter_list|,
name|String
name|expectedTrue
parameter_list|)
block|{
name|checkSimplify3_
argument_list|(
name|node
argument_list|,
name|expected
argument_list|,
name|expectedFalse
argument_list|,
name|expectedTrue
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|.
name|equals
argument_list|(
name|expectedFalse
argument_list|)
operator|&&
name|expected
operator|.
name|equals
argument_list|(
name|expectedTrue
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"expected == expectedFalse == expectedTrue; "
operator|+
literal|"use checkSimplify"
argument_list|)
throw|;
block|}
if|if
condition|(
name|expected
operator|.
name|equals
argument_list|(
name|expectedTrue
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"expected == expectedTrue; use checkSimplify2"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|checkSimplify3_
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|,
name|String
name|expectedFalse
parameter_list|,
name|String
name|expectedTrue
parameter_list|)
block|{
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|node
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"simplify(unknown as unknown): "
operator|+
name|node
argument_list|,
name|simplified
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BOOLEAN
condition|)
block|{
specifier|final
name|RexNode
name|simplified2
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|node
argument_list|,
name|RexUnknownAs
operator|.
name|FALSE
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"simplify(unknown as false): "
operator|+
name|node
argument_list|,
name|simplified2
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expectedFalse
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RexNode
name|simplified3
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|node
argument_list|,
name|RexUnknownAs
operator|.
name|TRUE
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"simplify(unknown as true): "
operator|+
name|node
argument_list|,
name|simplified3
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expectedTrue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertThat
argument_list|(
literal|"node type is not BOOLEAN, so<<expectedFalse>> should match<<expected>>"
argument_list|,
name|expectedFalse
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
literal|"node type is not BOOLEAN, so<<expectedTrue>> should match<<expected>>"
argument_list|,
name|expectedTrue
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkSimplifyFilter
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
specifier|final
name|RexNode
name|simplified
init|=
name|this
operator|.
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|node
argument_list|,
name|RexUnknownAs
operator|.
name|FALSE
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|simplified
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkSimplifyFilter
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|RelOptPredicateList
name|predicates
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|withPredicates
argument_list|(
name|predicates
argument_list|)
operator|.
name|simplifyUnknownAs
argument_list|(
name|node
argument_list|,
name|RexUnknownAs
operator|.
name|FALSE
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|simplified
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the number of nodes (including leaves) in a Rex tree. */
specifier|private
specifier|static
name|int
name|nodeCount
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|n
operator|+=
name|nodeCount
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
comment|/**    * Tests construction of a RexProgram.    */
annotation|@
name|Test
specifier|public
name|void
name|testBuildProgram
parameter_list|()
block|{
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|createProg
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexProgram
name|program
init|=
name|builder
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|String
name|programString
init|=
name|program
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($0, 1)], expr#3=[77], "
operator|+
literal|"expr#4=[+($0, $1)], expr#5=[+($0, $0)], expr#6=[+($t4, $t2)], "
operator|+
literal|"a=[$t6], b=[$t5])"
argument_list|,
name|programString
argument_list|)
expr_stmt|;
comment|// Normalize the program using the RexProgramBuilder.normalize API.
comment|// Note that unused expression '77' is eliminated, input refs (e.g. $0)
comment|// become local refs (e.g. $t0), and constants are assigned to locals.
specifier|final
name|RexProgram
name|normalizedProgram
init|=
name|program
operator|.
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|String
name|normalizedProgramString
init|=
name|normalizedProgram
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t0)], a=[$t5], b=[$t6])"
argument_list|,
name|normalizedProgramString
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests construction and normalization of a RexProgram.    */
annotation|@
name|Test
specifier|public
name|void
name|testNormalize
parameter_list|()
block|{
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|createProg
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|program
init|=
name|builder
operator|.
name|getProgram
argument_list|(
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t0)], a=[$t5], b=[$t6])"
argument_list|,
name|program
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests construction and normalization of a RexProgram.    */
annotation|@
name|Test
specifier|public
name|void
name|testElimDups
parameter_list|()
block|{
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|createProg
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|unnormalizedProgram
init|=
name|builder
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($0, 1)], expr#3=[77], "
operator|+
literal|"expr#4=[+($0, $1)], expr#5=[+($0, 1)], expr#6=[+($0, $t5)], "
operator|+
literal|"expr#7=[+($t4, $t2)], a=[$t7], b=[$t6])"
argument_list|,
name|unnormalizedProgram
argument_list|)
expr_stmt|;
comment|// normalize eliminates duplicates (specifically "+($0, $1)")
specifier|final
name|RexProgramBuilder
name|builder2
init|=
name|createProg
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|program2
init|=
name|builder2
operator|.
name|getProgram
argument_list|(
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t4)], a=[$t5], b=[$t6])"
argument_list|,
name|program2
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests how the condition is simplified.    */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCondition
parameter_list|()
block|{
specifier|final
name|RexProgram
name|program
init|=
name|createProg
argument_list|(
literal|3
argument_list|)
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|program
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($0, 1)], expr#3=[77], "
operator|+
literal|"expr#4=[+($0, $1)], expr#5=[+($0, 1)], expr#6=[+($0, $t5)], "
operator|+
literal|"expr#7=[+($t4, $t2)], expr#8=[5], expr#9=[>($t2, $t8)], "
operator|+
literal|"expr#10=[true], expr#11=[IS NOT NULL($t5)], expr#12=[false], "
operator|+
literal|"expr#13=[null:BOOLEAN], expr#14=[CASE($t9, $t10, $t11, $t12, $t13)], "
operator|+
literal|"expr#15=[NOT($t14)], a=[$t7], b=[$t6], $condition=[$t15])"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|program
operator|.
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t4)], expr#7=[5], expr#8=[<=($t4, $t7)], "
operator|+
literal|"a=[$t5], b=[$t6], $condition=[$t8])"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests how the condition is simplified.    */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCondition2
parameter_list|()
block|{
specifier|final
name|RexProgram
name|program
init|=
name|createProg
argument_list|(
literal|4
argument_list|)
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|program
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($0, 1)], expr#3=[77], "
operator|+
literal|"expr#4=[+($0, $1)], expr#5=[+($0, 1)], expr#6=[+($0, $t5)], "
operator|+
literal|"expr#7=[+($t4, $t2)], expr#8=[5], expr#9=[>($t2, $t8)], "
operator|+
literal|"expr#10=[true], expr#11=[IS NOT NULL($t5)], expr#12=[false], "
operator|+
literal|"expr#13=[null:BOOLEAN], expr#14=[CASE($t9, $t10, $t11, $t12, $t13)], "
operator|+
literal|"expr#15=[NOT($t14)], expr#16=[IS TRUE($t15)], a=[$t7], b=[$t6], "
operator|+
literal|"$condition=[$t16])"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|program
operator|.
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t4)], expr#7=[5], expr#8=[<=($t4, $t7)], "
operator|+
literal|"a=[$t5], b=[$t6], $condition=[$t8])"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks translation of AND(x, x).    */
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateAnd
parameter_list|()
block|{
comment|// RexProgramBuilder used to translate AND(x, x) to x.
comment|// Now it translates it to AND(x, x).
comment|// The optimization of AND(x, x) => x occurs at a higher level.
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|createProg
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|String
name|program
init|=
name|builder
operator|.
name|getProgram
argument_list|(
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t0)], expr#7=[>($t2, $t0)], "
operator|+
literal|"a=[$t5], b=[$t6], $condition=[$t7])"
argument_list|,
name|program
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a program, depending on variant:    *    *<ol>    *<li><code>select (x + y) + (x + 1) as a, (x + x) as b from t(x, y)</code>    *<li><code>select (x + y) + (x + 1) as a, (x + (x + 1)) as b    * from t(x, y)</code>    *<li><code>select (x + y) + (x + 1) as a, (x + x) as b from t(x, y)    * where ((x + y)&gt; 1) and ((x + y)&gt; 1)</code>    *<li><code>select (x + y) + (x + 1) as a, (x + x) as b from t(x, y)    * where not case    *           when x + 1&gt; 5 then true    *           when y is null then null    *           else false    *           end</code>    *</ol>    */
specifier|private
name|RexProgramBuilder
name|createProg
parameter_list|(
name|int
name|variant
parameter_list|)
block|{
assert|assert
name|variant
operator|>=
literal|0
operator|&&
name|variant
operator|<=
literal|4
assert|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"x"
argument_list|,
literal|"y"
argument_list|)
decl_stmt|;
name|RelDataType
name|inputRowType
init|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|,
name|names
argument_list|)
decl_stmt|;
specifier|final
name|RexProgramBuilder
name|builder
init|=
operator|new
name|RexProgramBuilder
argument_list|(
name|inputRowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
comment|// $t0 = x
comment|// $t1 = y
comment|// $t2 = $t0 + 1 (i.e. x + 1)
specifier|final
name|RexNode
name|i0
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|types
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|c1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|c5
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|5L
argument_list|)
argument_list|)
decl_stmt|;
name|RexLocalRef
name|t2
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|c1
argument_list|)
argument_list|)
decl_stmt|;
comment|// $t3 = 77 (not used)
specifier|final
name|RexLiteral
name|c77
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|77
argument_list|)
argument_list|)
decl_stmt|;
name|RexLocalRef
name|t3
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|c77
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|t3
argument_list|)
expr_stmt|;
comment|// $t4 = $t0 + $t1 (i.e. x + y)
specifier|final
name|RexNode
name|i1
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|types
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|RexLocalRef
name|t4
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|)
decl_stmt|;
name|RexLocalRef
name|t5
decl_stmt|;
specifier|final
name|RexLocalRef
name|t1
decl_stmt|;
switch|switch
condition|(
name|variant
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
comment|// $t5 = $t0 + $t0 (i.e. x + x)
name|t5
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|i0
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
literal|null
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
comment|// $tx = $t0 + 1
name|t1
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|c1
argument_list|)
argument_list|)
expr_stmt|;
comment|// $t5 = $t0 + $tx (i.e. x + (x + 1))
name|t5
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected variant "
operator|+
name|variant
argument_list|)
throw|;
block|}
comment|// $t6 = $t4 + $t2 (i.e. (x + y) + (x + 1))
name|RexLocalRef
name|t6
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|t4
argument_list|,
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|builder
operator|.
name|addProject
argument_list|(
name|t6
operator|.
name|getIndex
argument_list|()
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addProject
argument_list|(
name|t5
operator|.
name|getIndex
argument_list|()
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
specifier|final
name|RexLocalRef
name|t7
decl_stmt|;
specifier|final
name|RexLocalRef
name|t8
decl_stmt|;
switch|switch
condition|(
name|variant
condition|)
block|{
case|case
literal|2
case|:
comment|// $t7 = $t4> $i0 (i.e. (x + y)> 0)
name|t7
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|t4
argument_list|,
name|i0
argument_list|)
argument_list|)
expr_stmt|;
comment|// $t8 = $t7 AND $t7
name|t8
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|and
argument_list|(
name|t7
argument_list|,
name|t7
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addCondition
argument_list|(
name|t8
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addCondition
argument_list|(
name|t7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
comment|// $t7 = 5
name|t7
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|c5
argument_list|)
expr_stmt|;
comment|// $t8 = $t2> $t7 (i.e. (x + 1)> 5)
name|t8
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|gt
argument_list|(
name|t2
argument_list|,
name|t7
argument_list|)
argument_list|)
expr_stmt|;
comment|// $t9 = true
specifier|final
name|RexLocalRef
name|t9
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|trueLiteral
argument_list|)
decl_stmt|;
comment|// $t10 = $t1 is not null (i.e. y is not null)
assert|assert
name|t1
operator|!=
literal|null
assert|;
specifier|final
name|RexLocalRef
name|t10
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|t1
argument_list|)
argument_list|)
decl_stmt|;
comment|// $t11 = false
specifier|final
name|RexLocalRef
name|t11
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|falseLiteral
argument_list|)
decl_stmt|;
comment|// $t12 = unknown
specifier|final
name|RexLocalRef
name|t12
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|nullBool
argument_list|)
decl_stmt|;
comment|// $t13 = case when $t8 then $t9 when $t10 then $t11 else $t12 end
specifier|final
name|RexLocalRef
name|t13
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|case_
argument_list|(
name|t8
argument_list|,
name|t9
argument_list|,
name|t10
argument_list|,
name|t11
argument_list|,
name|t12
argument_list|)
argument_list|)
decl_stmt|;
comment|// $t14 = not $t13 (i.e. not case ... end)
specifier|final
name|RexLocalRef
name|t14
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|not
argument_list|(
name|t13
argument_list|)
argument_list|)
decl_stmt|;
comment|// don't add 't14 is true' - that is implicit
if|if
condition|(
name|variant
operator|==
literal|3
condition|)
block|{
name|builder
operator|.
name|addCondition
argument_list|(
name|t14
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// $t15 = $14 is true
specifier|final
name|RexLocalRef
name|t15
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|isTrue
argument_list|(
name|t14
argument_list|)
argument_list|)
decl_stmt|;
name|builder
operator|.
name|addCondition
argument_list|(
name|t15
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
return|;
block|}
comment|/** Unit test for {@link org.apache.calcite.plan.Strong}. */
annotation|@
name|Test
specifier|public
name|void
name|testStrong
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c0
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c1
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c01
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c13
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|// input ref
specifier|final
name|RexInputRef
name|i0
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i1
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// literals are strong iff they are always null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|trueLiteral
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|trueLiteral
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|falseLiteral
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullInt
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullInt
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullBool
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// AND is strong if one of its arguments is strong
specifier|final
name|RexNode
name|andUnknownTrue
init|=
name|and
argument_list|(
name|nullBool
argument_list|,
name|trueLiteral
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|andTrueUnknown
init|=
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|nullBool
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|andFalseTrue
init|=
name|and
argument_list|(
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|andUnknownTrue
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|andTrueUnknown
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|andFalseTrue
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 is null, "i0 and i1 is null" is null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|isNull
argument_list|(
name|i1
argument_list|)
argument_list|)
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i1 is null, "i0 and i1" is false
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|isNull
argument_list|(
name|i1
argument_list|)
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 and i1 are both null, "i0 and i1" is null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 and i1 are both null, "i0 and isNull(i1) is false"
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|isNull
argument_list|(
name|i1
argument_list|)
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 and i1 are both null, "i0 or i1" is null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|or
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 is null, "i0 or i1" is not necessarily null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|or
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|or
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 is null, then "i0 is not null" is false
name|RexNode
name|i0NotNull
init|=
name|isNotNull
argument_list|(
name|i0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0NotNull
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNotTrue
argument_list|(
name|i0NotNull
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 is null, then "not(i0 is not null)" is true.
comment|// Join-strengthening relies on this.
name|RexNode
name|notI0NotNull
init|=
name|not
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|notI0NotNull
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNotTrue
argument_list|(
name|notI0NotNull
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// NULLIF(null, null): null
comment|// NULLIF(null, X): null
comment|// NULLIF(X, X/Y): null or X
comment|// NULLIF(X, null): X
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|nullInt
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|trueLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|trueLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// ISNULL(null) is true, ISNULL(not null value) is false
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|isNull
argument_list|(
name|nullInt
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|isNull
argument_list|(
name|trueLiteral
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// CASE (<predicate1><value1><predicate2><value2><predicate3><value3> ...)
comment|// only definitely null if all values are null.
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|i0
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|i0
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|i0
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|i0
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|i0
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|i0
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testItemStrong
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c0
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intArray
init|=
name|typeFactory
operator|.
name|createArrayType
argument_list|(
name|intType
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|RexInputRef
name|inputRef
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intArray
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|rexNode
init|=
name|item
argument_list|(
name|inputRef
argument_list|,
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isStrong
argument_list|(
name|rexNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|rexNode
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|varcharType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|mapType
init|=
name|typeFactory
operator|.
name|createMapType
argument_list|(
name|varcharType
argument_list|,
name|varcharType
argument_list|)
decl_stmt|;
name|inputRef
operator|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|mapType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rexNode
operator|=
name|item
argument_list|(
name|inputRef
argument_list|,
name|literal
argument_list|(
literal|"abc"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isStrong
argument_list|(
name|rexNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|rexNode
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|xAndNotX
parameter_list|()
block|{
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|not
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|,
name|not
argument_list|(
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(null, IS NULL(?0.bool0), IS NULL(?0.bool1))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|,
name|not
argument_list|(
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.bool0, null, IS NULL(?0.bool1))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|not
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|,
name|vBoolNotNull
argument_list|(
literal|1
argument_list|)
argument_list|,
name|not
argument_list|(
name|vBoolNotNull
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for {@link org.apache.calcite.rex.RexUtil#isLosslessCast(RexNode)}. */
annotation|@
name|Test
specifier|public
name|void
name|testLosslessCast
parameter_list|()
block|{
specifier|final
name|RelDataType
name|tinyIntType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TINYINT
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|smallIntType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|bigIntType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|floatType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|FLOAT
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|charType5
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|charType6
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
literal|6
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|varCharType10
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|varCharType11
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|11
argument_list|)
decl_stmt|;
comment|// Negative
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|tinyIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|smallIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|bigIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|bigIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|floatType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|booleanType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|bigIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|charType5
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|varCharType10
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType10
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|varCharType11
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|charType5
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|bigIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|charType5
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType10
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Positive
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|smallIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|tinyIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|bigIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|charType6
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType10
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType11
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType11
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|charType6
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType11
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|varCharType10
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|removeRedundantCast
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullable
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"?0.int0"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|nullable
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"?0.notNullInt0"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|,
literal|"?0.notNullInt0"
argument_list|)
expr_stmt|;
comment|// Nested int int cast is removed
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|cast
argument_list|(
name|vVarchar
argument_list|()
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|,
literal|"CAST(?0.varchar0):INTEGER NOT NULL"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|cast
argument_list|(
name|vVarchar
argument_list|()
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|,
name|tVarchar
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Disabled
argument_list|(
literal|"CALCITE-3457: AssertionError in RexSimplify.validateStrongPolicy:843"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|reproducerFor3457
parameter_list|()
block|{
comment|// Identified with RexProgramFuzzyTest#testFuzzy, seed=4887662474363391810L
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|unaryMinus
argument_list|(
name|abstractCast
argument_list|(
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tInt
argument_list|(
literal|true
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|unaryMinus
argument_list|(
name|abstractCast
argument_list|(
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tInt
argument_list|(
literal|true
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"I've no idea what I'm doing "
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNoCommonReturnTypeFails
parameter_list|()
block|{
try|try
block|{
specifier|final
name|RexNode
name|node
init|=
name|coalesce
argument_list|(
name|vVarchar
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected exception, got "
operator|+
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|expected
init|=
literal|"Cannot infer return type for COALESCE;"
operator|+
literal|" operand types: [VARCHAR, INTEGER]"
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Unit test for {@link org.apache.calcite.rex.RexUtil#toCnf}. */
annotation|@
name|Test
specifier|public
name|void
name|testCnf
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"f"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"g"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"h"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|gRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|6
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|7
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|sevenLiteral
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|7
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hEqSeven
init|=
name|eq
argument_list|(
name|hRef
argument_list|,
name|sevenLiteral
argument_list|)
decl_stmt|;
name|checkCnf
argument_list|(
name|aRef
argument_list|,
literal|"?0.a"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|trueLiteral
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|falseLiteral
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|nullBool
argument_list|,
literal|"null:BOOLEAN"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, ?0.c)"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|or
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(OR(?0.a, ?0.b), OR(?0.c, ?0.d))"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(OR(?0.a, ?0.c), OR(?0.a, ?0.d), OR(?0.b, ?0.c), OR(?0.b, ?0.d))"
argument_list|)
expr_stmt|;
comment|// Input has nested ORs, output ORs are flat
name|checkCnf
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|or
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(OR(?0.a, ?0.c, ?0.d), OR(?0.b, ?0.c, ?0.d))"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|and
argument_list|(
name|bRef
argument_list|,
name|not
argument_list|(
name|hEqSeven
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(?0.a, NOT(?0.b), =(?0.h, 7))"
argument_list|)
expr_stmt|;
comment|// apply de Morgan's theorem
name|checkCnf
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|bRef
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(NOT(?0.a), ?0.b)"
argument_list|)
expr_stmt|;
comment|// apply de Morgan's theorem,
comment|// filter out 'OR ... FALSE' and 'AND ... TRUE'
name|checkCnf
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|not
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"AND(NOT(?0.a), ?0.b)"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, OR(?0.b, ?0.c), OR(?0.b, ?0.d))"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|and
argument_list|(
name|eRef
argument_list|,
name|or
argument_list|(
name|fRef
argument_list|,
name|gRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, OR(?0.b, ?0.c), OR(?0.b, ?0.d, ?0.e), OR(?0.b, ?0.d, ?0.f, ?0.g))"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|and
argument_list|(
name|eRef
argument_list|,
name|or
argument_list|(
name|fRef
argument_list|,
name|and
argument_list|(
name|gRef
argument_list|,
name|or
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, OR(?0.b, ?0.c), OR(?0.b, ?0.d, ?0.e), OR(?0.b, ?0.d, ?0.f, ?0.g))"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-394">[CALCITE-394]    * Add RexUtil.toCnf, to convert expressions to conjunctive normal form    * (CNF)</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testCnf2
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"x"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"y"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"z"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|xRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|yRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|zRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal3
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|checkCnf
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|yRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|zRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|eq
argument_list|(
name|yRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal2
argument_list|)
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal3
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND("
operator|+
literal|"OR(=(?0.x, 1), =(?0.x, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.x, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.x, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.y, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.y, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.y, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.a, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.a, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.a, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.x, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.x, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.x, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.y, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.y, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.y, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.a, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.a, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.a, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.x, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.x, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.x, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.y, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.y, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.y, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.a, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.a, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.a, 2), =(?0.b, 3)))"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1290">[CALCITE-1290]    * When converting to CNF, fail if the expression exceeds a threshold</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testThresholdCnf
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"x"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"y"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|xRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|yRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal3
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal4
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
comment|// Expression
comment|//   OR(=(?0.x, 1), AND(=(?0.x, 2), =(?0.y, 3)))
comment|// transformation creates 7 nodes
comment|//   AND(OR(=(?0.x, 1), =(?0.x, 2)), OR(=(?0.x, 1), =(?0.y, 3)))
comment|// Thus, it is triggered.
name|checkThresholdCnf
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|eq
argument_list|(
name|yRef
argument_list|,
name|literal3
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|"AND(OR(=(?0.x, 1), =(?0.x, 2)), OR(=(?0.x, 1), =(?0.y, 3)))"
argument_list|)
expr_stmt|;
comment|// Expression
comment|//   OR(=(?0.x, 1), =(?0.x, 2), AND(=(?0.x, 3), =(?0.y, 4)))
comment|// transformation creates 9 nodes
comment|//   AND(OR(=(?0.x, 1), =(?0.x, 2), =(?0.x, 3)),
comment|//       OR(=(?0.x, 1), =(?0.x, 2), =(?0.y, 8)))
comment|// Thus, it is NOT triggered.
name|checkThresholdCnf
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|eq
argument_list|(
name|yRef
argument_list|,
name|literal4
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|"OR(=(?0.x, 1), =(?0.x, 2), AND(=(?0.x, 3), =(?0.y, 4)))"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests formulas of various sizes whose size is exponential when converted    * to CNF. */
annotation|@
name|Test
specifier|public
name|void
name|testCnfExponential
parameter_list|()
block|{
comment|// run out of memory if limit is higher than about 20
name|int
name|limit
init|=
literal|16
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|checkExponentialCnf
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkExponentialCnf
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
literal|"x"
operator|+
name|i
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"y"
operator|+
name|i
argument_list|,
name|booleanType
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|rowType3
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range3
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|and
argument_list|(
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range3
argument_list|,
name|i
operator|*
literal|2
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range3
argument_list|,
name|i
operator|*
literal|2
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|cnf
init|=
name|RexUtil
operator|.
name|toCnf
argument_list|(
name|rexBuilder
argument_list|,
name|or
argument_list|(
name|list
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nodeCount
init|=
name|nodeCount
argument_list|(
name|cnf
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
operator|(
name|int
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|n
argument_list|)
operator|+
literal|1
argument_list|,
name|equalTo
argument_list|(
name|nodeCount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|3
condition|)
block|{
name|assertThat
argument_list|(
name|cnf
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"AND(OR(?0.x0, ?0.x1, ?0.x2), OR(?0.x0, ?0.x1, ?0.y2),"
operator|+
literal|" OR(?0.x0, ?0.y1, ?0.x2), OR(?0.x0, ?0.y1, ?0.y2),"
operator|+
literal|" OR(?0.y0, ?0.x1, ?0.x2), OR(?0.y0, ?0.x1, ?0.y2),"
operator|+
literal|" OR(?0.y0, ?0.y1, ?0.x2), OR(?0.y0, ?0.y1, ?0.y2))"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Unit test for {@link org.apache.calcite.rex.RexUtil#pullFactors}. */
annotation|@
name|Test
specifier|public
name|void
name|testPullFactors
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"f"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"g"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"h"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|gRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|6
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|7
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|sevenLiteral
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|7
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hEqSeven
init|=
name|eq
argument_list|(
name|hRef
argument_list|,
name|sevenLiteral
argument_list|)
decl_stmt|;
comment|// Most of the expressions in testCnf are unaffected by pullFactors.
name|checkPullFactors
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|aRef
argument_list|,
name|dRef
argument_list|,
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, OR(?0.b, AND(?0.c, ?0.d)))"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|aRef
argument_list|,
literal|"?0.a"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|trueLiteral
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|falseLiteral
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|nullBool
argument_list|,
literal|"null:BOOLEAN"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, ?0.c)"
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|and
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|or
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Input has nested ORs, output ORs are flat; different from CNF
name|checkPullFactors
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|or
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|,
literal|"OR(AND(?0.a, ?0.b), ?0.c, ?0.d)"
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|and
argument_list|(
name|bRef
argument_list|,
name|not
argument_list|(
name|hEqSeven
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|bRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|not
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|and
argument_list|(
name|eRef
argument_list|,
name|or
argument_list|(
name|fRef
argument_list|,
name|gRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|and
argument_list|(
name|eRef
argument_list|,
name|or
argument_list|(
name|fRef
argument_list|,
name|and
argument_list|(
name|gRef
argument_list|,
name|or
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplify
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|intType
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"f"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"g"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"h"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"i"
argument_list|,
name|intNullableType
argument_list|)
operator|.
name|add
argument_list|(
literal|"j"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"k"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|7
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|iRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|8
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|jRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|9
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|kRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
comment|// and: remove duplicates
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|aRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
comment|// and: remove true
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
comment|// and: false falsifies
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// and: remove duplicate "not"s
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|not
argument_list|(
name|aRef
argument_list|)
argument_list|,
name|bRef
argument_list|,
name|not
argument_list|(
name|cRef
argument_list|)
argument_list|,
name|not
argument_list|(
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.b, NOT(?0.a), NOT(?0.c))"
argument_list|)
expr_stmt|;
comment|// and: "not true" falsifies
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|not
argument_list|(
name|aRef
argument_list|)
argument_list|,
name|bRef
argument_list|,
name|not
argument_list|(
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// and: flatten and remove duplicates
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|and
argument_list|(
name|and
argument_list|(
name|bRef
argument_list|,
name|not
argument_list|(
name|cRef
argument_list|)
argument_list|,
name|dRef
argument_list|,
name|not
argument_list|(
name|eRef
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|eRef
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, ?0.d, NOT(?0.c), NOT(?0.e))"
argument_list|)
expr_stmt|;
comment|// and: expand "... and not(or(x, y))" to "... and not(x) and not(y)"
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|not
argument_list|(
name|or
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|eRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, NOT(?0.c), NOT(?0.d), NOT(?0.e))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|not
argument_list|(
name|or
argument_list|(
name|not
argument_list|(
name|cRef
argument_list|)
argument_list|,
name|dRef
argument_list|,
name|not
argument_list|(
name|eRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, ?0.c, ?0.e, NOT(?0.d))"
argument_list|)
expr_stmt|;
comment|// or: remove duplicates
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|aRef
argument_list|)
argument_list|,
literal|"OR(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
comment|// or: remove false
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"OR(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
comment|// or: true makes everything true
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// case: remove false branches
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|bRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
name|dRef
argument_list|,
name|falseLiteral
argument_list|,
name|aRef
argument_list|,
name|eRef
argument_list|)
argument_list|,
literal|"OR(AND(=(?0.b, ?0.c), ?0.d), AND(?0.e,<>(?0.b, ?0.c)))"
argument_list|)
expr_stmt|;
comment|// case: true branches become the last branch
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|bRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
name|dRef
argument_list|,
name|trueLiteral
argument_list|,
name|aRef
argument_list|,
name|eq
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|,
name|eRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
literal|"OR(AND(=(?0.b, ?0.c), ?0.d), AND(?0.a,<>(?0.b, ?0.c)))"
argument_list|)
expr_stmt|;
comment|// case: singleton
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|trueLiteral
argument_list|,
name|aRef
argument_list|,
name|eq
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|,
name|eRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
literal|"?0.a"
argument_list|)
expr_stmt|;
comment|// case: always same value
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|,
name|bRef
argument_list|,
name|literal1
argument_list|,
name|cRef
argument_list|,
name|literal1
argument_list|,
name|dRef
argument_list|,
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
comment|// case: trailing false and null, no simplification
name|checkSimplify3
argument_list|(
name|case_
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|,
name|bRef
argument_list|,
name|trueLiteral
argument_list|,
name|cRef
argument_list|,
name|falseLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"OR(?0.a, ?0.b, AND(null, NOT(?0.a), NOT(?0.b), NOT(?0.c)))"
argument_list|,
literal|"OR(?0.a, ?0.b)"
argument_list|,
literal|"OR(?0.a, ?0.b, NOT(?0.c))"
argument_list|)
expr_stmt|;
comment|// case: form an AND of branches that return true
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|,
name|bRef
argument_list|,
name|falseLiteral
argument_list|,
name|cRef
argument_list|,
name|falseLiteral
argument_list|,
name|dRef
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"OR(?0.a, AND(?0.d, NOT(?0.b), NOT(?0.c)))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|,
name|bRef
argument_list|,
name|falseLiteral
argument_list|,
name|cRef
argument_list|,
name|falseLiteral
argument_list|,
name|dRef
argument_list|,
name|trueLiteral
argument_list|,
name|eRef
argument_list|,
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"OR(?0.a, AND(?0.d, NOT(?0.b), NOT(?0.c)), AND(NOT(?0.b), NOT(?0.c), NOT(?0.e)))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|falseLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
name|falseLiteral
argument_list|,
name|eq
argument_list|(
name|falseLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
name|trueLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// is null, applied to not-null value
name|checkSimplify
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|aRef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// is not null, applied to not-null value
name|checkSimplify
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|aRef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// condition, and the inverse - nothing to do due to null values
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|le
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(<=(?0.h, 1),>(?0.h, 1))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|le
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(<=(?0.h, 1),>=(?0.h, 1))"
argument_list|,
literal|"=(?0.h, 1)"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(<(?0.h, 1), =(?0.h, 1),>=(?0.h, 1))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|or
argument_list|(
name|falseLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|or
argument_list|(
name|falseLiteral
argument_list|,
name|gt
argument_list|(
name|jRef
argument_list|,
name|kRef
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(<(?0.h, 1),>(?0.j, ?0.k))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|or
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"<(?0.h, 1)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|or
argument_list|(
name|falseLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"<(?0.h, 1)"
argument_list|)
expr_stmt|;
comment|// "x = x" simplifies to "x is not null"
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|eq
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"OR(null, IS NOT NULL(?0.i))"
argument_list|,
literal|"IS NOT NULL(?0.i)"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|eq
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|)
expr_stmt|;
comment|// "x<= x" simplifies to "x is not null"
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|le
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"OR(null, IS NOT NULL(?0.i))"
argument_list|,
literal|"IS NOT NULL(?0.i)"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|le
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|)
expr_stmt|;
comment|// "x>= x" simplifies to "x is not null"
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|ge
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"OR(null, IS NOT NULL(?0.i))"
argument_list|,
literal|"IS NOT NULL(?0.i)"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ge
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|)
expr_stmt|;
comment|// "x != x" simplifies to "false"
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|ne
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"AND(null, IS NULL(?0.i))"
argument_list|,
literal|"false"
argument_list|,
literal|"IS NULL(?0.i)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ne
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|)
expr_stmt|;
comment|// "x< x" simplifies to "false"
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|lt
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"AND(null, IS NULL(?0.i))"
argument_list|,
literal|"false"
argument_list|,
literal|"IS NULL(?0.i)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|lt
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|)
expr_stmt|;
comment|// "x> x" simplifies to "false"
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|gt
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"AND(null, IS NULL(?0.i))"
argument_list|,
literal|"false"
argument_list|,
literal|"IS NULL(?0.i)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|gt
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|)
expr_stmt|;
comment|// "(not x) is null" to "x is null"
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|not
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS NULL(?0.bool0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|not
argument_list|(
name|vBoolNotNull
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// "(not x) is not null" to "x is not null"
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|not
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL(?0.bool0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|not
argument_list|(
name|vBoolNotNull
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "null is null" to "true"
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|nullBool
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "(x + y) is null" simplifies to "x is null or y is null"
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|plus
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(IS NULL(?0.int0), IS NULL(?0.int1))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|plus
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NULL(?0.int0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|plus
argument_list|(
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|plus
argument_list|(
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NULL(?0.int1)"
argument_list|)
expr_stmt|;
comment|// "(x + y) is not null" simplifies to "x is not null and y is not null"
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|plus
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(IS NOT NULL(?0.int0), IS NOT NULL(?0.int1))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|plus
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL(?0.int0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|plus
argument_list|(
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|plus
argument_list|(
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL(?0.int1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|simplifyStrong
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|ge
argument_list|(
name|trueLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|ge
argument_list|(
name|nullBool
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|gt
argument_list|(
name|trueLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|le
argument_list|(
name|trueLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|lt
argument_list|(
name|trueLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|not
argument_list|(
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|ne
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|eq
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|plus
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"null:INTEGER"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|sub
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"null:INTEGER"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|mul
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"null:INTEGER"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|div
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"null:INTEGER"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyFilter
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"f"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"g"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"h"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal5
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal10
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|TEN
argument_list|)
decl_stmt|;
comment|// condition, and the inverse
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// simplify equals boolean
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|args
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|args
argument_list|)
argument_list|,
literal|"AND(=(?0.a, 1), =(?0.b, 1))"
argument_list|)
expr_stmt|;
comment|// as previous, using simplifyFilterPredicates
name|assertThat
argument_list|(
name|simplify
operator|.
name|simplifyFilterPredicates
argument_list|(
name|args
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"AND(=(?0.a, 1), =(?0.b, 1))"
argument_list|)
argument_list|)
expr_stmt|;
comment|// "a = 1 and a = 10" is always false
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|args2
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|args2
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|simplify
operator|.
name|simplifyFilterPredicates
argument_list|(
name|args2
argument_list|)
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// equality on constants, can remove the equality on the variables
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(=(?0.a, 1), =(?0.b, 1))"
argument_list|)
expr_stmt|;
comment|// condition not satisfiable
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition not satisfiable
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|ge
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// one "and" containing three "or"s
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|gt
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|,
literal|"OR(>(?0.a, 10),>(?0.b, 1))"
argument_list|)
expr_stmt|;
comment|// case: trailing false and null, remove
name|checkSimplifyFilter
argument_list|(
name|case_
argument_list|(
name|cRef
argument_list|,
name|trueLiteral
argument_list|,
name|dRef
argument_list|,
name|trueLiteral
argument_list|,
name|eRef
argument_list|,
name|falseLiteral
argument_list|,
name|fRef
argument_list|,
name|falseLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"OR(?0.c, ?0.d)"
argument_list|)
expr_stmt|;
comment|// condition with null value for range
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|nullBool
argument_list|)
argument_list|,
name|ge
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "1< a&& 5< x" yields "5< x"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|literal1
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|lt
argument_list|(
name|literal5
argument_list|,
name|aRef
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|"<(5, ?0.a)"
argument_list|)
expr_stmt|;
comment|// condition "1< a&& a< 5" is unchanged
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|literal1
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|"AND(<(1, ?0.a),<(?0.a, 5))"
argument_list|)
expr_stmt|;
comment|// condition "1> a&& 5> x" yields "1> a"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|literal1
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|gt
argument_list|(
name|literal5
argument_list|,
name|aRef
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|">(1, ?0.a)"
argument_list|)
expr_stmt|;
comment|// condition "1> a&& a> 5" yields false
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|literal1
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// range with no predicates;
comment|// condition "a> 1&& a< 10&& a< 5" yields "a< 1&& a< 5"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|"AND(>(?0.a, 1),<(?0.a, 5))"
argument_list|)
expr_stmt|;
comment|// condition "a> 1&& a< 10&& a< 5"
comment|// with pre-condition "a> 5"
comment|// yields "false"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "a> 1&& a< 10&& a<= 5"
comment|// with pre-condition "a>= 5"
comment|// yields "a = 5"
comment|// "a<= 5" would also be correct, just a little less concise.
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|le
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 5)"
argument_list|)
expr_stmt|;
comment|// condition "a> 1&& a< 10&& a< 5"
comment|// with pre-condition "b< 10&& a> 5"
comment|// yields "a> 1 and a< 5"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|lt
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(>(?0.a, 1),<(?0.a, 5))"
argument_list|)
expr_stmt|;
comment|// condition "a> 1"
comment|// with pre-condition "b< 10&& a> 5"
comment|// yields "true"
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|lt
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// condition "a< 1"
comment|// with pre-condition "b< 10&& a> 5"
comment|// yields "false"
name|checkSimplifyFilter
argument_list|(
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|lt
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "a> 5"
comment|// with pre-condition "b< 10&& a>= 5"
comment|// yields "a> 5"
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|lt
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|">(?0.a, 5)"
argument_list|)
expr_stmt|;
comment|// condition "a> 5"
comment|// with pre-condition "a<= 5"
comment|// yields "false"
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "a> 5"
comment|// with pre-condition "a<= 5 and b<= 5"
comment|// yields "false"
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|le
argument_list|(
name|bRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "a> 5 or b> 5"
comment|// with pre-condition "a<= 5 and b<= 5"
comment|// should yield "false" but yields "a = 5 or b = 5"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|gt
argument_list|(
name|bRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|le
argument_list|(
name|bRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyOrNotEqualsNotNullable
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|ne
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|ne
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyOrNotEqualsNotNullable2
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|ne
argument_list|(
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|vIntNotNull
argument_list|(
literal|1
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|,
name|ne
argument_list|(
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyOrNotEqualsNullable
parameter_list|()
block|{
name|checkSimplify3
argument_list|(
name|or
argument_list|(
name|ne
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|ne
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(IS NOT NULL(?0.int0), null)"
argument_list|,
literal|"IS NOT NULL(?0.int0)"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyOrNotEqualsNullable2
parameter_list|()
block|{
name|checkSimplify3
argument_list|(
name|or
argument_list|(
name|ne
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|,
name|ne
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(IS NOT NULL(?0.int0), null, =(?0.int1, 10))"
argument_list|,
literal|"OR(IS NOT NULL(?0.int0), =(?0.int1, 10))"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyAndPush
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal5
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal10
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|TEN
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|">(?0.a, 10)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|,
literal|">(?0.a, 10)"
argument_list|)
expr_stmt|;
comment|// "null AND NOT(null OR x)" => "null AND NOT(x)"
name|checkSimplify3
argument_list|(
name|and
argument_list|(
name|nullBool
argument_list|,
name|not
argument_list|(
name|or
argument_list|(
name|nullBool
argument_list|,
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(null, NOT(?0.bool0))"
argument_list|,
literal|"false"
argument_list|,
literal|"NOT(?0.bool0)"
argument_list|)
expr_stmt|;
comment|// "x1 AND x2 AND x3 AND NOT(x1) AND NOT(x2) AND NOT(x0)" =>
comment|// "x3 AND null AND x1 IS NULL AND x2 IS NULL AND NOT(x0)"
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|2
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|3
argument_list|)
argument_list|,
name|not
argument_list|(
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|vBool
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.bool3, null, IS NULL(?0.bool1),"
operator|+
literal|" IS NULL(?0.bool2), NOT(?0.bool0))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyOrTerms
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|false
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|true
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|intType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal3
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal4
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
comment|// "a != 1 or a = 1" ==> "true"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|ne
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// TODO: make this simplify to "true"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ne
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"OR(=(?0.a, 1),<>(?0.a, 1))"
argument_list|)
expr_stmt|;
comment|// "b != 1 or b = 1" cannot be simplified, because b might be null
specifier|final
name|RexNode
name|neOrEq
init|=
name|or
argument_list|(
name|ne
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|neOrEq
argument_list|,
literal|"OR(<>(?0.b, 1), =(?0.b, 1))"
argument_list|)
expr_stmt|;
comment|// Careful of the excluded middle!
comment|// We cannot simplify "b != 1 or b = 1" to "true" because if b is null, the
comment|// result is unknown.
comment|// TODO: "b is not unknown" would be the best simplification.
specifier|final
name|RexNode
name|simplified
init|=
name|this
operator|.
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|neOrEq
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|simplified
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"OR(<>(?0.b, 1), =(?0.b, 1))"
argument_list|)
argument_list|)
expr_stmt|;
comment|// "a is null or a is not null" ==> "true"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNull
argument_list|(
name|aRef
argument_list|)
argument_list|,
name|isNotNull
argument_list|(
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "a is not null or a is null" ==> "true"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNotNull
argument_list|(
name|aRef
argument_list|)
argument_list|,
name|isNull
argument_list|(
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "b is not null or b is null" ==> "true" (valid even though b nullable)
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNotNull
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|isNull
argument_list|(
name|bRef
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "b is not null or c is null" unchanged
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNotNull
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|isNull
argument_list|(
name|cRef
argument_list|)
argument_list|)
argument_list|,
literal|"OR(IS NOT NULL(?0.b), IS NULL(?0.c))"
argument_list|)
expr_stmt|;
comment|// "b is null or b is not false" unchanged
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNull
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|isNotFalse
argument_list|(
name|bRef
argument_list|)
argument_list|)
argument_list|,
literal|"OR(IS NULL(?0.b), IS NOT FALSE(?0.b))"
argument_list|)
expr_stmt|;
comment|// multiple predicates are handled correctly
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal2
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal4
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(=(?0.b, 2), =(?0.a, 3))"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|ne
argument_list|(
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"OR(null,<>(0, ?0.int0))"
argument_list|,
literal|"<>(0, ?0.int0)"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyNotAnd
parameter_list|()
block|{
specifier|final
name|RexNode
name|e
init|=
name|or
argument_list|(
name|le
argument_list|(
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|,
name|eq
argument_list|(
name|literal
argument_list|(
literal|false
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|e
argument_list|,
literal|"OR(<=(?0.bool1, true), ?0.bool1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyUnknown
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"AND(=(?0.a, 1), null:INTEGER)"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|falseLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|and
argument_list|(
name|nullBool
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(null, =(?0.a, 1))"
argument_list|,
literal|"false"
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"OR(=(?0.a, 1), null)"
argument_list|,
literal|"=(?0.a, 1)"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|trueLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|or
argument_list|(
name|falseLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyAnd3
parameter_list|()
block|{
comment|// in the case of 3-valued logic, the result must be unknown if a is unknown
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|not
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"AND(null, IS NULL(?0.bool0))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2840">[CALCITE-2840]    * Simplification should use more specific UnknownAs modes during simplification</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testNestedAndSimplification
parameter_list|()
block|{
comment|// to have the correct mode for the AND at the bottom,
comment|// both the OR and AND parent should retain the UnknownAs mode
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
name|or
argument_list|(
name|eq
argument_list|(
name|vInt
argument_list|(
literal|3
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|and
argument_list|(
name|ge
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|le
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(=(?0.int2, 2), OR(=(?0.int3, 3), AND(>=(?0.int0, 1),<=(?0.int0, 1))))"
argument_list|,
literal|"AND(=(?0.int2, 2), OR(=(?0.int3, 3), =(?0.int0, 1)))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|fieldAccessEqualsHashCode
parameter_list|()
block|{
name|assertEquals
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|vBool
argument_list|()
argument_list|,
literal|"vBool() instances should be equal"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|vBool
argument_list|()
operator|.
name|hashCode
argument_list|()
argument_list|,
name|vBool
argument_list|()
operator|.
name|hashCode
argument_list|()
argument_list|,
literal|"vBool().hashCode()"
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|vBool
argument_list|()
argument_list|,
literal|"vBool() is expected to produce new RexFieldAccess"
argument_list|)
expr_stmt|;
name|assertNotEquals
argument_list|(
name|vBool
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"vBool(0) != vBool(1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyDynamicParam
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|vBool
argument_list|()
argument_list|)
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1289">[CALCITE-1289]    * RexUtil.simplifyCase() should account for nullability</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseNotNullableBoolean
parameter_list|()
block|{
name|RexNode
name|condition
init|=
name|eq
argument_list|(
name|vVarchar
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|"S"
argument_list|)
argument_list|)
decl_stmt|;
name|RexCall
name|caseNode
init|=
operator|(
name|RexCall
operator|)
name|case_
argument_list|(
name|condition
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|result
init|=
operator|(
name|RexCall
operator|)
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|caseNode
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"The case should be nonNullable"
argument_list|,
name|caseNode
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
literal|"Expected a nonNullable type"
argument_list|,
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperator
argument_list|()
argument_list|,
name|is
argument_list|(
operator|(
name|SqlOperator
operator|)
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseNullableBoolean
parameter_list|()
block|{
name|RexNode
name|condition
init|=
name|eq
argument_list|(
name|input
argument_list|(
name|tVarchar
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|"S"
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|condition
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
name|RexCall
name|result
init|=
operator|(
name|RexCall
operator|)
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|caseNode
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|is
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyRecurseIntoArithmetics
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|plus
argument_list|(
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|case_
argument_list|(
name|falseLiteral
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|trueLiteral
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"+(1, 2)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseBranchesCollapse
parameter_list|()
block|{
comment|// case when x is true then 1 when x is not true then 1 else 2 end
comment|// => case when x is true or x is not true then 1 else 2 end
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|isTrue
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|isNotTrue
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
literal|"CASE(OR(?0.bool0, IS NOT TRUE(?0.bool0)), 1, 2)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseBranchesCollapse2
parameter_list|()
block|{
comment|// case when x is true then 1 when true then 1 else 2 end
comment|// => 1
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|isTrue
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|trueLiteral
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseNullableVarChar
parameter_list|()
block|{
name|RexNode
name|condition
init|=
name|eq
argument_list|(
name|input
argument_list|(
name|tVarchar
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|"S"
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|condition
argument_list|,
name|literal
argument_list|(
literal|"A"
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|"B"
argument_list|)
argument_list|)
decl_stmt|;
name|RexCall
name|result
init|=
operator|(
name|RexCall
operator|)
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|caseNode
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|is
argument_list|(
name|caseNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseCasting
parameter_list|()
block|{
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|eq
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|nullBool
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
name|checkSimplify3
argument_list|(
name|caseNode
argument_list|,
literal|"AND(=(?0.notNullInt0, 3), null)"
argument_list|,
literal|"false"
argument_list|,
literal|"=(?0.notNullInt0, 3)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseAndNotSimplicationIsInAction
parameter_list|()
block|{
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|eq
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|falseLiteral
argument_list|,
name|eq
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|caseNode
argument_list|,
literal|"=(?0.notNullInt0, 1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseBranchRemovalStrengthensType
parameter_list|()
block|{
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|falseLiteral
argument_list|,
name|nullBool
argument_list|,
name|eq
argument_list|(
name|div
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"Expected to have a nullable type for "
operator|+
name|caseNode
operator|+
literal|"."
argument_list|,
name|caseNode
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|RexNode
name|res
init|=
name|simplify
operator|.
name|simplify
argument_list|(
name|caseNode
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
literal|"Expected to have a nonNullable type for "
operator|+
name|res
operator|+
literal|"."
argument_list|,
name|res
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseCompaction
parameter_list|()
block|{
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|vBool
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|caseNode
argument_list|,
literal|"CASE(OR(?0.bool0, ?0.bool1), ?0.int0, ?0.int1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseCompaction2
parameter_list|()
block|{
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|vBool
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|caseNode
argument_list|,
literal|"CASE(?0.bool0, ?0.int0, ?0.int1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseCompactionDiv
parameter_list|()
block|{
comment|// FIXME: RexInterpreter currently evaluates children beforehand.
name|simplify
operator|=
name|simplify
operator|.
name|withParanoid
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|vBool
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|eq
argument_list|(
name|div
argument_list|(
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|()
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|11
argument_list|)
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// expectation here is that the 2 branches are not merged.
name|checkSimplifyUnchanged
argument_list|(
name|caseNode
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a CASE value branch that contains division. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseDiv1
parameter_list|()
block|{
comment|// FIXME: RexInterpreter currently evaluates children beforehand.
name|simplify
operator|=
name|simplify
operator|.
name|withParanoid
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|ne
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|div
argument_list|(
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|()
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|11
argument_list|)
argument_list|)
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|caseNode
argument_list|)
expr_stmt|;
block|}
comment|/** Tests a CASE condition that contains division, */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseDiv2
parameter_list|()
block|{
comment|// FIXME: RexInterpreter currently evaluates children beforehand.
name|simplify
operator|=
name|simplify
operator|.
name|withParanoid
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|eq
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|trueLiteral
argument_list|,
name|gt
argument_list|(
name|div
argument_list|(
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|()
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|caseNode
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseFirstBranchIsSafe
parameter_list|()
block|{
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|gt
argument_list|(
name|div
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|caseNode
argument_list|,
literal|"<=(/(?0.notNullInt0, 1), 1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushNotIntoCase
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|case_
argument_list|(
name|isTrue
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|div
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|2
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"CASE(?0.bool0, NOT(?0.bool1),>(/(?0.notNullInt0, 2), 1), NOT(?0.bool2), NOT(?0.bool3))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNotRecursion
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|coalesce
argument_list|(
name|nullBool
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyAnd
parameter_list|()
block|{
name|RelDataType
name|booleanNotNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RelDataType
name|booleanNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|RexNode
name|andCondition
init|=
name|and
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|booleanNotNullableType
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|booleanNullableType
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|booleanNotNullableType
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|result
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|andCondition
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyIsNotNull
parameter_list|()
block|{
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RelDataType
name|intNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i0
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intNullableType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i1
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intNullableType
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i2
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i3
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|one
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|null_
init|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|intType
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(IS NOT NULL($0), IS NOT NULL($1))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i0
argument_list|,
name|i2
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL($0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i2
argument_list|,
name|i3
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i0
argument_list|,
name|one
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL($0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i0
argument_list|,
name|null_
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// test simplify operand of case when expression
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|case_
argument_list|(
name|falseLiteral
argument_list|,
name|unaryPlus
argument_list|(
name|i0
argument_list|)
argument_list|,
name|literal
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|case_
argument_list|(
name|trueLiteral
argument_list|,
name|unaryPlus
argument_list|(
name|i0
argument_list|)
argument_list|,
name|literal
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NULL($0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|case_
argument_list|(
name|falseLiteral
argument_list|,
name|unaryPlus
argument_list|(
name|i0
argument_list|)
argument_list|,
name|literal
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|case_
argument_list|(
name|trueLiteral
argument_list|,
name|unaryPlus
argument_list|(
name|i0
argument_list|)
argument_list|,
name|literal
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL($0)"
argument_list|)
expr_stmt|;
comment|// test simplify operand of redundant cast
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|cast
argument_list|(
name|i2
argument_list|,
name|intType
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|cast
argument_list|(
name|i2
argument_list|,
name|intType
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2929">[CALCITE-2929]    * Simplification of IS NULL checks are incorrectly assuming that CAST-s are possible</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastIsNull
parameter_list|()
block|{
name|checkSimplifyUnchanged
argument_list|(
name|isNull
argument_list|(
name|cast
argument_list|(
name|vVarchar
argument_list|()
argument_list|,
name|tInt
argument_list|(
literal|true
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2929">[CALCITE-2929]    * Simplification of IS NULL checks are incorrectly assuming that CAST-s are possible</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastIsNull2
parameter_list|()
block|{
name|checkSimplifyUnchanged
argument_list|(
name|isNull
argument_list|(
name|cast
argument_list|(
name|vVarcharNotNull
argument_list|()
argument_list|,
name|tInt
argument_list|(
literal|false
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|checkSimplifyDynamicParam
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(IS NOT NULL(?0.int0), IS NOT NULL(?0.int1))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL(?0.int0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vIntNotNull
argument_list|(
literal|2
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL(?0.int0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|null_
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastLiteral
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|literals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TINYINT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"1234"
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"123.45"
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"3.1415"
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|REAL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|E
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|FLOAT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|PI
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"hello world"
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"1969-07-20 12:34:56"
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"1969-07-20"
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"12:34:45"
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
operator|(
name|RexLiteral
operator|)
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|new
name|ByteString
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|1
block|,
literal|2
block|,
operator|-
literal|34
block|,
literal|0
block|,
operator|-
literal|128
block|}
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BINARY
argument_list|,
literal|5
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeDateLiteral
argument_list|(
operator|new
name|DateString
argument_list|(
literal|1974
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeTimeLiteral
argument_list|(
operator|new
name|TimeString
argument_list|(
literal|1
argument_list|,
literal|23
argument_list|,
literal|45
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeTimestampLiteral
argument_list|(
operator|new
name|TimestampString
argument_list|(
literal|1974
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|,
literal|23
argument_list|,
literal|45
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Multimap
argument_list|<
name|SqlTypeName
argument_list|,
name|RexLiteral
argument_list|>
name|map
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|RexLiteral
name|literal
range|:
name|literals
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|literal
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TINYINT
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|REAL
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|FLOAT
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARBINARY
argument_list|,
literal|60
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BINARY
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RelDataType
name|fromType
range|:
name|types
control|)
block|{
for|for
control|(
name|RelDataType
name|toType
range|:
name|types
control|)
block|{
if|if
condition|(
name|SqlTypeAssignmentRule
operator|.
name|instance
argument_list|()
operator|.
name|canApplyFrom
argument_list|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|RexLiteral
name|literal
range|:
name|map
operator|.
name|get
argument_list|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|RexNode
name|cast
init|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|toType
argument_list|,
name|literal
argument_list|)
decl_stmt|;
if|if
condition|(
name|cast
operator|instanceof
name|RexLiteral
condition|)
block|{
name|assertThat
argument_list|(
name|cast
operator|.
name|getType
argument_list|()
argument_list|,
name|is
argument_list|(
name|toType
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|// makeCast already simplified
block|}
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|cast
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|boolean
name|expectedSimplify
init|=
name|literal
operator|.
name|getTypeName
argument_list|()
operator|!=
name|toType
operator|.
name|getSqlTypeName
argument_list|()
operator|||
operator|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
operator|&&
operator|(
operator|(
name|NlsString
operator|)
name|literal
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
operator|>
name|toType
operator|.
name|getPrecision
argument_list|()
operator|)
operator|||
operator|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BINARY
operator|&&
operator|(
operator|(
name|ByteString
operator|)
name|literal
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|length
argument_list|()
operator|>
name|toType
operator|.
name|getPrecision
argument_list|()
operator|)
decl_stmt|;
name|boolean
name|couldSimplify
init|=
operator|!
name|cast
operator|.
name|equals
argument_list|(
name|simplified
argument_list|)
decl_stmt|;
specifier|final
name|String
name|reason
init|=
operator|(
name|expectedSimplify
condition|?
literal|"expected to simplify, but could not: "
else|:
literal|"simplified, but did not expect to: "
operator|)
operator|+
name|cast
operator|+
literal|" --> "
operator|+
name|simplified
decl_stmt|;
name|assertThat
argument_list|(
name|reason
argument_list|,
name|couldSimplify
argument_list|,
name|is
argument_list|(
name|expectedSimplify
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastLiteral
parameter_list|()
block|{
name|assertNode
argument_list|(
literal|"cast(literal int not null)"
argument_list|,
literal|"42:INTEGER NOT NULL"
argument_list|,
name|cast
argument_list|(
name|literal
argument_list|(
literal|42
argument_list|)
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertNode
argument_list|(
literal|"cast(literal int)"
argument_list|,
literal|"42:INTEGER NOT NULL"
argument_list|,
name|cast
argument_list|(
name|literal
argument_list|(
literal|42
argument_list|)
argument_list|,
name|nullable
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertNode
argument_list|(
literal|"abstractCast(literal int not null)"
argument_list|,
literal|"CAST(42):INTEGER NOT NULL"
argument_list|,
name|abstractCast
argument_list|(
name|literal
argument_list|(
literal|42
argument_list|)
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertNode
argument_list|(
literal|"abstractCast(literal int)"
argument_list|,
literal|"CAST(42):INTEGER"
argument_list|,
name|abstractCast
argument_list|(
name|literal
argument_list|(
literal|42
argument_list|)
argument_list|,
name|nullable
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastLiteral2
parameter_list|()
block|{
specifier|final
name|RexLiteral
name|literalAbc
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"abc"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalOne
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|varcharType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|dateType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timestampType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|intType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|intType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|varcharType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|varcharType
argument_list|)
argument_list|,
literal|"'1':VARCHAR(10)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|booleanType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|booleanType
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// different from Hive
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|dateType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|dateType
argument_list|)
argument_list|,
literal|"1970-01-02"
argument_list|)
expr_stmt|;
comment|// different from Hive
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|timestampType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|timestampType
argument_list|)
argument_list|,
literal|"1970-01-01 00:00:00"
argument_list|)
expr_stmt|;
comment|// different from Hive
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastLiteral3
parameter_list|()
block|{
comment|// Default TimeZone is "America/Los_Angeles" (DummyDataContext)
specifier|final
name|RexLiteral
name|literalDate
init|=
name|rexBuilder
operator|.
name|makeDateLiteral
argument_list|(
operator|new
name|DateString
argument_list|(
literal|"2011-07-20"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalTime
init|=
name|rexBuilder
operator|.
name|makeTimeLiteral
argument_list|(
operator|new
name|TimeString
argument_list|(
literal|"12:34:56"
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalTimestamp
init|=
name|rexBuilder
operator|.
name|makeTimestampLiteral
argument_list|(
operator|new
name|TimestampString
argument_list|(
literal|"2011-07-20 12:34:56"
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalTimeLTZ
init|=
name|rexBuilder
operator|.
name|makeTimeWithLocalTimeZoneLiteral
argument_list|(
operator|new
name|TimeString
argument_list|(
literal|1
argument_list|,
literal|23
argument_list|,
literal|45
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timeLTZChar1
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"12:34:45 America/Los_Angeles"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timeLTZChar2
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"12:34:45 UTC"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timeLTZChar3
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"12:34:45 GMT+01"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timestampLTZChar1
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"2011-07-20 12:34:56 Asia/Tokyo"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timestampLTZChar2
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"2011-07-20 12:34:56 GMT+01"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timestampLTZChar3
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"2011-07-20 12:34:56 UTC"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalTimestampLTZ
init|=
name|rexBuilder
operator|.
name|makeTimestampWithLocalTimeZoneLiteral
argument_list|(
operator|new
name|TimestampString
argument_list|(
literal|2011
argument_list|,
literal|7
argument_list|,
literal|20
argument_list|,
literal|8
argument_list|,
literal|23
argument_list|,
literal|45
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|dateType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timeType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timestampType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timeLTZType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIME_WITH_LOCAL_TIME_ZONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timestampLTZType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|varCharType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|40
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timeLTZChar1
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"20:34:45:TIME_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timeLTZChar2
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"12:34:45:TIME_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timeLTZChar3
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"11:34:45:TIME_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|timeLTZType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timestampLTZChar1
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 03:34:56:TIMESTAMP_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timestampLTZChar2
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 11:34:56:TIMESTAMP_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timestampLTZChar3
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 12:34:56:TIMESTAMP_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalDate
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 07:00:00:TIMESTAMP_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTime
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 19:34:56:TIMESTAMP_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestamp
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 19:34:56:TIMESTAMP_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestamp
argument_list|,
name|dateType
argument_list|)
argument_list|,
literal|"2011-07-20"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|dateType
argument_list|)
argument_list|,
literal|"2011-07-20"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|timeType
argument_list|)
argument_list|,
literal|"01:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|timestampType
argument_list|)
argument_list|,
literal|"2011-07-20 01:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|timeType
argument_list|)
argument_list|,
literal|"17:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTime
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"20:34:56:TIME_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"08:23:45:TIME_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|varCharType
argument_list|)
argument_list|,
literal|"'17:23:45 America/Los_Angeles':VARCHAR(40)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|varCharType
argument_list|)
argument_list|,
literal|"'2011-07-20 01:23:45 America/Los_Angeles':VARCHAR(40)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|timestampType
argument_list|)
argument_list|,
literal|"2011-07-19 18:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 01:23:45:TIMESTAMP_WITH_LOCAL_TIME_ZONE(0)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemovalOfNullabilityWideningCast
parameter_list|()
block|{
name|RexNode
name|expr
init|=
name|cast
argument_list|(
name|isTrue
argument_list|(
name|vBoolNotNull
argument_list|()
argument_list|)
argument_list|,
name|tBool
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|expr
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|RexNode
name|result
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|expr
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCompareTimestampWithTimeZone
parameter_list|()
block|{
specifier|final
name|TimestampWithTimeZoneString
name|timestampLTZChar1
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
literal|"2011-07-20 10:34:56 America/Los_Angeles"
argument_list|)
decl_stmt|;
specifier|final
name|TimestampWithTimeZoneString
name|timestampLTZChar2
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
literal|"2011-07-20 19:34:56 Europe/Rome"
argument_list|)
decl_stmt|;
specifier|final
name|TimestampWithTimeZoneString
name|timestampLTZChar3
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
literal|"2011-07-20 01:34:56 Asia/Tokyo"
argument_list|)
decl_stmt|;
specifier|final
name|TimestampWithTimeZoneString
name|timestampLTZChar4
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
literal|"2011-07-20 10:34:56 America/Los_Angeles"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestampLTZChar1
operator|.
name|equals
argument_list|(
name|timestampLTZChar2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|timestampLTZChar1
operator|.
name|equals
argument_list|(
name|timestampLTZChar3
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|timestampLTZChar1
operator|.
name|equals
argument_list|(
name|timestampLTZChar4
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyLiterals
parameter_list|()
block|{
specifier|final
name|RexLiteral
name|literalAbc
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"abc"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalDef
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"def"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalZero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalOne
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalOneDotZero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|1.0
argument_list|)
argument_list|)
decl_stmt|;
comment|// Check string comparison
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalAbc
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalAbc
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalDef
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalDef
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalDef
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalDef
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalDef
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalDef
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalDef
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// Check whole number comparison
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalOne
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalOne
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalOne
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalOne
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// Check decimal equality comparison
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalOne
argument_list|,
name|literalOneDotZero
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalOneDotZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalOne
argument_list|,
name|literalOneDotZero
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalOneDotZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// Check different types shouldn't change simplification
name|checkSimplifyUnchanged
argument_list|(
name|eq
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|eq
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ne
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ne
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|gt
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|gt
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ge
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ge
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|lt
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|lt
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|le
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|le
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2421">[CALCITE-2421]    * to-be-filled</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSelfComparisions
parameter_list|()
block|{
name|checkSimplify3
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|vInt
argument_list|()
argument_list|)
argument_list|,
name|eq
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(OR(null, IS NOT NULL(?0.int0)), OR(null, IS NOT NULL(?0.int1)))"
argument_list|,
literal|"AND(IS NOT NULL(?0.int0), IS NOT NULL(?0.int1))"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify3
argument_list|(
name|and
argument_list|(
name|ne
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|vInt
argument_list|()
argument_list|)
argument_list|,
name|ne
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(null, IS NULL(?0.int0), IS NULL(?0.int1))"
argument_list|,
literal|"false"
argument_list|,
literal|"AND(IS NULL(?0.int0), IS NULL(?0.int1))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBooleanComparisions
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"NOT(?0.bool0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"NOT(?0.bool0)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|gt
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|le
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|vBoolNotNull
argument_list|()
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|vBoolNotNull
argument_list|()
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"NOT(?0.bool0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"NOT(?0.bool0)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ge
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|lt
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|vBoolNotNull
argument_list|()
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|vBoolNotNull
argument_list|()
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleDynamicVars
parameter_list|()
block|{
name|assertTypeAndToString
argument_list|(
name|vBool
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"?0.bool2"
argument_list|,
literal|"BOOLEAN"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vBoolNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"?0.notNullBool0"
argument_list|,
literal|"BOOLEAN NOT NULL"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"?0.int2"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"?0.notNullInt0"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vVarchar
argument_list|()
argument_list|,
literal|"?0.varchar0"
argument_list|,
literal|"VARCHAR"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vVarcharNotNull
argument_list|(
literal|9
argument_list|)
argument_list|,
literal|"?0.notNullVarchar9"
argument_list|,
literal|"VARCHAR NOT NULL"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assertTypeAndToString
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|String
name|representation
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|representation
argument_list|,
name|rexNode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|type
argument_list|,
name|rexNode
operator|.
name|getType
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
operator|(
name|rexNode
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|?
literal|""
else|:
literal|" NOT NULL"
operator|)
argument_list|,
literal|"type of "
operator|+
name|rexNode
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsDeterministic
parameter_list|()
block|{
name|SqlOperator
name|ndc
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"NDC"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
name|RexNode
name|n
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|ndc
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|RexUtil
operator|.
name|isDeterministic
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|RexUtil
operator|.
name|retainDeterministic
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|n
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConstantMap
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map
init|=
name|RexUtil
operator|.
name|predicateConstants
argument_list|(
name|RexNode
operator|.
name|class
argument_list|,
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|eq
argument_list|(
name|cRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|cRef
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|eq
argument_list|(
name|dRef
argument_list|,
name|eRef
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getString
argument_list|(
name|map
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"{1=?0.c, ?0.a=?0.b, ?0.b=?0.a, ?0.c=1, ?0.d=?0.e, ?0.e=?0.d}"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Contradictory constraints yield no constants
specifier|final
name|RexNode
name|ref0
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map2
init|=
name|RexUtil
operator|.
name|predicateConstants
argument_list|(
name|RexNode
operator|.
name|class
argument_list|,
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|ref0
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|ref0
argument_list|,
name|literal2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getString
argument_list|(
name|map2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"{}"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Contradictory constraints on field accesses SHOULD yield no constants
comment|// but currently there's a bug
specifier|final
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map3
init|=
name|RexUtil
operator|.
name|predicateConstants
argument_list|(
name|RexNode
operator|.
name|class
argument_list|,
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getString
argument_list|(
name|map3
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"{1=?0.a, 2=?0.a}"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|notDistinct
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|isFalse
argument_list|(
name|isNotDistinctFrom
argument_list|(
name|vBool
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS DISTINCT FROM(?0.bool0, ?0.bool1)"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2505">[CALCITE-2505]    * RexSimplify wrongly simplifies "COALESCE(+(NULL), x)" to "NULL"</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCoalesce
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|vInt
argument_list|()
argument_list|)
argument_list|,
comment|// first arg not null
literal|"?0.notNullInt0"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|coalesce
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|vIntNotNull
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|vInt
argument_list|()
argument_list|)
argument_list|,
comment|// repeated arg
literal|"?0.int0"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|vIntNotNull
argument_list|()
argument_list|)
argument_list|,
comment|// repeated arg
literal|"?0.notNullInt0"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|"?0.notNullInt0"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|coalesce
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|plus
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|vIntNotNull
argument_list|()
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|()
argument_list|)
argument_list|,
literal|"COALESCE(?0.int0, +(?0.int0, ?0.notNullInt0), 1)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|gt
argument_list|(
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|unaryPlus
argument_list|(
name|nullInt
argument_list|)
argument_list|,
name|unaryPlus
argument_list|(
name|vInt
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"+(?0.int0)"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|coalesce
argument_list|(
name|unaryPlus
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|unaryPlus
argument_list|(
name|vInt
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|nullInt
argument_list|,
name|vInt
argument_list|()
argument_list|)
argument_list|,
literal|"?0.int0"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|nullInt
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|"COALESCE(?0.int0, ?0.int1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|simplifyNull
parameter_list|()
block|{
name|checkSimplify3
argument_list|(
name|nullBool
argument_list|,
literal|"null:BOOLEAN"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// null int must not be simplified to false
name|checkSimplifyUnchanged
argument_list|(
name|nullInt
argument_list|)
expr_stmt|;
block|}
comment|/** Converts a map to a string, sorting on the string representation of its    * keys. */
specifier|private
specifier|static
name|String
name|getString
parameter_list|(
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map
parameter_list|)
block|{
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|map2
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|map2
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|map2
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyFalse
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|booleanInput
init|=
name|input
argument_list|(
name|booleanNullableType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|isFalse
init|=
name|isFalse
argument_list|(
name|booleanInput
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|result
init|=
operator|(
name|RexCall
operator|)
name|simplify
argument_list|(
name|isFalse
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperator
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
name|booleanInput
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure that IS_FALSE(IS_FALSE(nullable boolean)) != IS_TRUE(nullable boolean)
comment|// IS_FALSE(IS_FALSE(null)) = IS_FALSE(false) = true
comment|// IS_TRUE(null) = false
specifier|final
name|RexNode
name|isFalseIsFalse
init|=
name|isFalse
argument_list|(
name|isFalse
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|result2
init|=
operator|(
name|RexCall
operator|)
name|simplify
argument_list|(
name|isFalseIsFalse
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getOperator
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
name|booleanInput
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyNot
parameter_list|()
block|{
comment|// "NOT(NOT(x))" => "x"
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|not
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
comment|// "NOT(true)"  => "false"
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|trueLiteral
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// "NOT(false)" => "true"
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|falseLiteral
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "NOT(IS FALSE(x))" => "IS NOT FALSE(x)"
name|checkSimplify3
argument_list|(
name|not
argument_list|(
name|isFalse
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT FALSE(?0.bool0)"
argument_list|,
literal|"IS NOT FALSE(?0.bool0)"
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
comment|// "NOT(IS TRUE(x))" => "IS NOT TRUE(x)"
name|checkSimplify3
argument_list|(
name|not
argument_list|(
name|isTrue
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT TRUE(?0.bool0)"
argument_list|,
literal|"IS NOT TRUE(?0.bool0)"
argument_list|,
literal|"NOT(?0.bool0)"
argument_list|)
expr_stmt|;
comment|// "NOT(IS NULL(x))" => "IS NOT NULL(x)"
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL(?0.bool0)"
argument_list|)
expr_stmt|;
comment|// "NOT(IS NOT NULL(x)) => "IS NULL(x)"
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|isNotNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS NULL(?0.bool0)"
argument_list|)
expr_stmt|;
comment|// "NOT(AND(x0,x1))" => "OR(NOT(x0),NOT(x1))"
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|and
argument_list|(
name|vBool
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(NOT(?0.bool0), NOT(?0.bool1))"
argument_list|)
expr_stmt|;
comment|// "NOT(OR(x0,x1))" => "AND(NOT(x0),NOT(x1))"
name|checkSimplify
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|vBool
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vBool
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(NOT(?0.bool0), NOT(?0.bool1))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyAndNot
parameter_list|()
block|{
comment|// "x> 1 AND NOT (y> 2)" -> "x> 1 AND y<= 2"
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|gt
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(>(?0.int1, 1),<=(?0.int2, 2))"
argument_list|)
expr_stmt|;
comment|// "x = x AND NOT (y>= y)"
comment|//    -> "x = x AND y< y" (treating unknown as unknown)
comment|//    -> false (treating unknown as false)
name|checkSimplify3
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|ge
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(OR(null, IS NOT NULL(?0.int1)), null, IS NULL(?0.int2))"
argument_list|,
literal|"false"
argument_list|,
literal|"IS NULL(?0.int2)"
argument_list|)
expr_stmt|;
comment|// "NOT(x = x AND NOT (y = y))"
comment|//   -> "OR(x<> x, y>= y)" (treating unknown as unknown)
comment|//   -> "y IS NOT NULL" (treating unknown as false)
name|checkSimplify3
argument_list|(
name|not
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|ge
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(AND(null, IS NULL(?0.int1)), null, IS NOT NULL(?0.int2))"
argument_list|,
literal|"IS NOT NULL(?0.int2)"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyOrNot
parameter_list|()
block|{
comment|// "x> 1 OR NOT (y> 2)" -> "x> 1 OR y<= 2"
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|gt
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|gt
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(>(?0.int1, 1),<=(?0.int2, 2))"
argument_list|)
expr_stmt|;
comment|// "x = x OR NOT (y>= y)"
comment|//    -> "x = x OR y< y" (treating unknown as unknown)
comment|//    -> "x IS NOT NULL" (treating unknown as false)
name|checkSimplify3
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|ge
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(null, IS NOT NULL(?0.int1), AND(null, IS NULL(?0.int2)))"
argument_list|,
literal|"IS NOT NULL(?0.int1)"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "NOT(x = x OR NOT (y = y))"
comment|//   -> "AND(x<> x, y>= y)" (treating unknown as unknown)
comment|//   -> "FALSE" (treating unknown as false)
name|checkSimplify3
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|ge
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(null, IS NULL(?0.int1), OR(null, IS NOT NULL(?0.int2)))"
argument_list|,
literal|"false"
argument_list|,
literal|"IS NULL(?0.int1)"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RexNode
name|simplify
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
operator|.
name|withParanoid
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|e
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInterpreter
parameter_list|()
block|{
name|assertThat
argument_list|(
name|eval
argument_list|(
name|trueLiteral
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|nullInt
argument_list|)
argument_list|,
name|is
argument_list|(
name|NullSentinel
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|eq
argument_list|(
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
name|NullSentinel
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|eq
argument_list|(
name|this
operator|.
name|trueLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
name|NullSentinel
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|eq
argument_list|(
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|ne
argument_list|(
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|ne
argument_list|(
name|falseLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
name|NullSentinel
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|and
argument_list|(
name|this
operator|.
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNullRecursion
parameter_list|()
block|{
comment|// make sure that simplifcation is visiting below isX expressions
name|checkSimplify
argument_list|(
name|isNull
argument_list|(
name|or
argument_list|(
name|coalesce
argument_list|(
name|nullBool
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRedundantIsTrue
parameter_list|()
block|{
name|checkSimplify2
argument_list|(
name|isTrue
argument_list|(
name|isTrue
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS TRUE(?0.bool0)"
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRedundantIsFalse
parameter_list|()
block|{
name|checkSimplify2
argument_list|(
name|isTrue
argument_list|(
name|isFalse
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS FALSE(?0.bool0)"
argument_list|,
literal|"NOT(?0.bool0)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRedundantIsNotTrue
parameter_list|()
block|{
name|checkSimplify3
argument_list|(
name|isNotFalse
argument_list|(
name|isNotTrue
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT TRUE(?0.bool0)"
argument_list|,
literal|"IS NOT TRUE(?0.bool0)"
argument_list|,
literal|"NOT(?0.bool0)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRedundantIsNotFalse
parameter_list|()
block|{
name|checkSimplify3
argument_list|(
name|isNotFalse
argument_list|(
name|isNotFalse
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT FALSE(?0.bool0)"
argument_list|,
literal|"IS NOT FALSE(?0.bool0)"
argument_list|,
literal|"?0.bool0"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit tests for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2438">[CALCITE-2438]    * RexCall#isAlwaysTrue returns incorrect result</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseXisNullisNotNullisFalse
parameter_list|()
block|{
comment|// "((x IS NULL) IS NOT NULL) IS FALSE" -> false
name|checkIs
argument_list|(
name|isFalse
argument_list|(
name|isNotNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseNotXisNullisNotNullisFalse
parameter_list|()
block|{
comment|// "(NOT ((x IS NULL) IS NOT NULL)) IS FALSE" -> true
name|checkIs
argument_list|(
name|isFalse
argument_list|(
name|not
argument_list|(
name|isNotNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseXisNullisNotNullisTrue
parameter_list|()
block|{
comment|// "((x IS NULL) IS NOT NULL) IS TRUE" -> true
name|checkIs
argument_list|(
name|isTrue
argument_list|(
name|isNotNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseNotXisNullisNotNullisTrue
parameter_list|()
block|{
comment|// "(NOT ((x IS NULL) IS NOT NULL)) IS TRUE" -> false
name|checkIs
argument_list|(
name|isTrue
argument_list|(
name|not
argument_list|(
name|isNotNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseNotXisNullisNotNullisNotTrue
parameter_list|()
block|{
comment|// "(NOT ((x IS NULL) IS NOT NULL)) IS NOT TRUE" -> true
name|checkIs
argument_list|(
name|isNotTrue
argument_list|(
name|not
argument_list|(
name|isNotNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseXisNullisNotNull
parameter_list|()
block|{
comment|// "(x IS NULL) IS NOT NULL" -> true
name|checkIs
argument_list|(
name|isNotNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseXisNotNullisNotNull
parameter_list|()
block|{
comment|// "(x IS NOT NULL) IS NOT NULL" -> true
name|checkIs
argument_list|(
name|isNotNull
argument_list|(
name|isNotNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseXisNullisNull
parameter_list|()
block|{
comment|// "(x IS NULL) IS NULL" -> false
name|checkIs
argument_list|(
name|isNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseXisNotNullisNull
parameter_list|()
block|{
comment|// "(x IS NOT NULL) IS NULL" -> false
name|checkIs
argument_list|(
name|isNull
argument_list|(
name|isNotNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseXisNullisNotNullisNotFalse
parameter_list|()
block|{
comment|// "((x IS NULL) IS NOT NULL) IS NOT FALSE" -> true
name|checkIs
argument_list|(
name|isNotFalse
argument_list|(
name|isNotNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsAlwaysTrueAndFalseXisNullisNotNullisNotTrue
parameter_list|()
block|{
comment|// "((x IS NULL) IS NOT NULL) IS NOT TRUE" -> false
name|checkIs
argument_list|(
name|isNotTrue
argument_list|(
name|isNotNull
argument_list|(
name|isNull
argument_list|(
name|vBool
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Checks that {@link RexNode#isAlwaysTrue()},    * {@link RexNode#isAlwaysTrue()} and {@link RexSimplify} agree that    * an expression reduces to true or false. */
specifier|private
name|void
name|checkIs
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|boolean
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
literal|"isAlwaysTrue() of expression: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
operator|.
name|isAlwaysTrue
argument_list|()
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
literal|"isAlwaysFalse() of expression: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
operator|.
name|isAlwaysFalse
argument_list|()
argument_list|,
name|is
argument_list|(
operator|!
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
literal|"Simplification is not using isAlwaysX informations"
argument_list|,
name|simplify
argument_list|(
name|e
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expected
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Comparable
name|eval
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
return|return
name|RexInterpreter
operator|.
name|evaluate
argument_list|(
name|e
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2842">[CALCITE-2842]    * Computing digest of IN expressions leads to Exceptions</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testInDigest
parameter_list|()
block|{
name|RexNode
name|e
init|=
name|in
argument_list|(
name|vInt
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"IN(?0.int0, 1, 2)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3192">[CALCITE-3192]    * Simplify OR incorrectly weaks condition</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testOrSimplificationNotWeakensCondition
parameter_list|()
block|{
comment|// "1< a or (a< 3 and b = 2)" can't be simplified
name|checkSimplifyUnchanged
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|()
argument_list|)
argument_list|,
name|and
argument_list|(
name|lt
argument_list|(
name|vIntNotNull
argument_list|()
argument_list|,
name|literal
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|vBoolNotNull
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNullSimplificationWithUnaryPlus
parameter_list|()
block|{
name|RexNode
name|expr
init|=
name|isNotNull
argument_list|(
name|coalesce
argument_list|(
name|unaryPlus
argument_list|(
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|s
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|expr
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|expr
operator|.
name|isAlwaysTrue
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|s
argument_list|,
name|is
argument_list|(
name|trueLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNullSimplificationWithIsDistinctFrom
parameter_list|()
block|{
name|RexNode
name|expr
init|=
name|isNotNull
argument_list|(
name|case_
argument_list|(
name|vBool
argument_list|()
argument_list|,
name|isDistinctFrom
argument_list|(
name|falseLiteral
argument_list|,
name|vBoolNotNull
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|vBoolNotNull
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|s
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|expr
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|expr
operator|.
name|isAlwaysTrue
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|s
argument_list|,
name|is
argument_list|(
name|trueLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastUnaryMinus
parameter_list|()
block|{
name|RexNode
name|expr
init|=
name|isNull
argument_list|(
name|ne
argument_list|(
name|unaryMinus
argument_list|(
name|cast
argument_list|(
name|unaryMinus
argument_list|(
name|vIntNotNull
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|nullable
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|s
init|=
name|simplify
operator|.
name|simplifyUnknownAs
argument_list|(
name|expr
argument_list|,
name|RexUnknownAs
operator|.
name|UNKNOWN
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|s
argument_list|,
name|is
argument_list|(
name|falseLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyRangeWithMultiPredicates
parameter_list|()
block|{
specifier|final
name|RexNode
name|ref
init|=
name|input
argument_list|(
name|tInt
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|RelOptPredicateList
name|relOptPredicateList
init|=
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|gt
argument_list|(
name|ref
argument_list|,
name|literal
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|le
argument_list|(
name|ref
argument_list|,
name|literal
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|ref
argument_list|,
name|literal
argument_list|(
literal|9
argument_list|)
argument_list|)
argument_list|,
name|relOptPredicateList
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

