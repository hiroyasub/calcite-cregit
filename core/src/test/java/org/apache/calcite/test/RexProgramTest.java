begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Strong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|NullSentinel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInterpreter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeAssignmentRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimeString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampWithTimeZoneString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|nullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_comment
comment|/**  * Unit tests for {@link RexProgram} and  * {@link org.apache.calcite.rex.RexProgramBuilder}.  */
end_comment

begin_class
specifier|public
class|class
name|RexProgramTest
extends|extends
name|RexProgramBuilderBase
block|{
comment|/**    * Creates a RexProgramTest.    */
specifier|public
name|RexProgramTest
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
block|{
name|super
operator|.
name|setUp
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|checkCnf
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|toCnf
argument_list|(
name|rexBuilder
argument_list|,
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkThresholdCnf
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|int
name|threshold
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|toCnf
argument_list|(
name|rexBuilder
argument_list|,
name|threshold
argument_list|,
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkPullFactorsUnchanged
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
name|checkPullFactors
argument_list|(
name|node
argument_list|,
name|node
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkPullFactors
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|pullFactors
argument_list|(
name|rexBuilder
argument_list|,
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Asserts that given node has expected string representation with account of node type    * @param message extra message that clarifies where the node came from    * @param expected expected string representation of the node    * @param node node to check    */
specifier|private
name|void
name|assertNode
parameter_list|(
name|String
name|message
parameter_list|,
name|String
name|expected
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
name|String
name|actual
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|CAST
argument_list|)
operator|||
name|node
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|NEW_SPECIFICATION
argument_list|)
condition|)
block|{
comment|// toString contains type (see RexCall.toString)
name|actual
operator|=
name|node
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|actual
operator|=
name|node
operator|+
literal|":"
operator|+
name|node
operator|.
name|getType
argument_list|()
operator|+
operator|(
name|node
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|?
literal|""
else|:
literal|" NOT NULL"
operator|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|message
argument_list|,
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
comment|/** Simplifies an expression and checks that the result is as expected. */
specifier|private
name|void
name|checkSimplify
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|checkSimplify2
argument_list|(
name|node
argument_list|,
name|expected
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
comment|/** Simplifies an expression and checks that the result is unchanged. */
specifier|private
name|void
name|checkSimplifyUnchanged
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
name|checkSimplify
argument_list|(
name|node
argument_list|,
name|node
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Simplifies an expression and checks the result if unknowns remain    * unknown, or if unknown becomes false. If the result is the same, use    * {@link #checkSimplify(RexNode, String)}.    *    * @param node Expression to simplify    * @param expected Expected simplification    * @param expectedFalse Expected simplification, if unknown is to be treated    *     as false    */
specifier|private
name|void
name|checkSimplify2
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|,
name|String
name|expectedFalse
parameter_list|)
block|{
name|assertThat
argument_list|(
name|simplify
operator|.
name|simplify
argument_list|(
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BOOLEAN
condition|)
block|{
name|assertThat
argument_list|(
name|simplify
operator|.
name|withUnknownAsFalse
argument_list|(
literal|true
argument_list|)
operator|.
name|simplify
argument_list|(
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expectedFalse
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkSimplifyFilter
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|simplify
operator|.
name|withUnknownAsFalse
argument_list|(
literal|true
argument_list|)
operator|.
name|simplify
argument_list|(
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkSimplifyFilter
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|RelOptPredicateList
name|predicates
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|assertThat
argument_list|(
name|simplify
operator|.
name|withUnknownAsFalse
argument_list|(
literal|true
argument_list|)
operator|.
name|withPredicates
argument_list|(
name|predicates
argument_list|)
operator|.
name|simplify
argument_list|(
name|node
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the number of nodes (including leaves) in a Rex tree. */
specifier|private
specifier|static
name|int
name|nodeCount
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|RexCall
condition|)
block|{
for|for
control|(
name|RexNode
name|operand
range|:
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|n
operator|+=
name|nodeCount
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
comment|/**    * Tests construction of a RexProgram.    */
annotation|@
name|Test
specifier|public
name|void
name|testBuildProgram
parameter_list|()
block|{
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|createProg
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexProgram
name|program
init|=
name|builder
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|String
name|programString
init|=
name|program
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($0, 1)], expr#3=[77], "
operator|+
literal|"expr#4=[+($0, $1)], expr#5=[+($0, $0)], expr#6=[+($t4, $t2)], "
operator|+
literal|"a=[$t6], b=[$t5])"
argument_list|,
name|programString
argument_list|)
expr_stmt|;
comment|// Normalize the program using the RexProgramBuilder.normalize API.
comment|// Note that unused expression '77' is eliminated, input refs (e.g. $0)
comment|// become local refs (e.g. $t0), and constants are assigned to locals.
specifier|final
name|RexProgram
name|normalizedProgram
init|=
name|program
operator|.
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|String
name|normalizedProgramString
init|=
name|normalizedProgram
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t0)], a=[$t5], b=[$t6])"
argument_list|,
name|normalizedProgramString
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests construction and normalization of a RexProgram.    */
annotation|@
name|Test
specifier|public
name|void
name|testNormalize
parameter_list|()
block|{
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|createProg
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|String
name|program
init|=
name|builder
operator|.
name|getProgram
argument_list|(
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t0)], a=[$t5], b=[$t6])"
argument_list|,
name|program
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests construction and normalization of a RexProgram.    */
annotation|@
name|Test
specifier|public
name|void
name|testElimDups
parameter_list|()
block|{
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|createProg
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|unnormalizedProgram
init|=
name|builder
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($0, 1)], expr#3=[77], "
operator|+
literal|"expr#4=[+($0, $1)], expr#5=[+($0, 1)], expr#6=[+($0, $t5)], "
operator|+
literal|"expr#7=[+($t4, $t2)], a=[$t7], b=[$t6])"
argument_list|,
name|unnormalizedProgram
argument_list|)
expr_stmt|;
comment|// normalize eliminates duplicates (specifically "+($0, $1)")
specifier|final
name|RexProgramBuilder
name|builder2
init|=
name|createProg
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|program2
init|=
name|builder2
operator|.
name|getProgram
argument_list|(
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t4)], a=[$t5], b=[$t6])"
argument_list|,
name|program2
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests how the condition is simplified.    */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCondition
parameter_list|()
block|{
specifier|final
name|RexProgram
name|program
init|=
name|createProg
argument_list|(
literal|3
argument_list|)
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|program
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($0, 1)], expr#3=[77], "
operator|+
literal|"expr#4=[+($0, $1)], expr#5=[+($0, 1)], expr#6=[+($0, $t5)], "
operator|+
literal|"expr#7=[+($t4, $t2)], expr#8=[5], expr#9=[>($t2, $t8)], "
operator|+
literal|"expr#10=[true], expr#11=[IS NOT NULL($t5)], expr#12=[false], "
operator|+
literal|"expr#13=[null], expr#14=[CASE($t9, $t10, $t11, $t12, $t13)], "
operator|+
literal|"expr#15=[NOT($t14)], a=[$t7], b=[$t6], $condition=[$t15])"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|program
operator|.
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t4)], expr#7=[5], expr#8=[>($t4, $t7)], "
operator|+
literal|"expr#9=[CAST($t8):BOOLEAN], expr#10=[IS FALSE($t9)], "
operator|+
literal|"a=[$t5], b=[$t6], $condition=[$t10])"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests how the condition is simplified.    */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCondition2
parameter_list|()
block|{
specifier|final
name|RexProgram
name|program
init|=
name|createProg
argument_list|(
literal|4
argument_list|)
operator|.
name|getProgram
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|program
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($0, 1)], expr#3=[77], "
operator|+
literal|"expr#4=[+($0, $1)], expr#5=[+($0, 1)], expr#6=[+($0, $t5)], "
operator|+
literal|"expr#7=[+($t4, $t2)], expr#8=[5], expr#9=[>($t2, $t8)], "
operator|+
literal|"expr#10=[true], expr#11=[IS NOT NULL($t5)], expr#12=[false], "
operator|+
literal|"expr#13=[null], expr#14=[CASE($t9, $t10, $t11, $t12, $t13)], "
operator|+
literal|"expr#15=[NOT($t14)], expr#16=[IS TRUE($t15)], a=[$t7], b=[$t6], "
operator|+
literal|"$condition=[$t16])"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|program
operator|.
name|normalize
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t4)], expr#7=[5], expr#8=[>($t4, $t7)], "
operator|+
literal|"expr#9=[CAST($t8):BOOLEAN], expr#10=[IS FALSE($t9)], "
operator|+
literal|"a=[$t5], b=[$t6], $condition=[$t10])"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks translation of AND(x, x).    */
annotation|@
name|Test
specifier|public
name|void
name|testDuplicateAnd
parameter_list|()
block|{
comment|// RexProgramBuilder used to translate AND(x, x) to x.
comment|// Now it translates it to AND(x, x).
comment|// The optimization of AND(x, x) => x occurs at a higher level.
specifier|final
name|RexProgramBuilder
name|builder
init|=
name|createProg
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|String
name|program
init|=
name|builder
operator|.
name|getProgram
argument_list|(
literal|true
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TestUtil
operator|.
name|assertEqualsVerbose
argument_list|(
literal|"(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], expr#3=[1], "
operator|+
literal|"expr#4=[+($t0, $t3)], expr#5=[+($t2, $t4)], "
operator|+
literal|"expr#6=[+($t0, $t0)], expr#7=[>($t2, $t0)], "
operator|+
literal|"a=[$t5], b=[$t6], $condition=[$t7])"
argument_list|,
name|program
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a program, depending on variant:    *    *<ol>    *<li><code>select (x + y) + (x + 1) as a, (x + x) as b from t(x, y)</code>    *<li><code>select (x + y) + (x + 1) as a, (x + (x + 1)) as b    * from t(x, y)</code>    *<li><code>select (x + y) + (x + 1) as a, (x + x) as b from t(x, y)    * where ((x + y)&gt; 1) and ((x + y)&gt; 1)</code>    *<li><code>select (x + y) + (x + 1) as a, (x + x) as b from t(x, y)    * where not case    *           when x + 1&gt; 5 then true    *           when y is null then null    *           else false    *           end</code>    *</ol>    */
specifier|private
name|RexProgramBuilder
name|createProg
parameter_list|(
name|int
name|variant
parameter_list|)
block|{
assert|assert
name|variant
operator|>=
literal|0
operator|&&
name|variant
operator|<=
literal|4
assert|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"x"
argument_list|,
literal|"y"
argument_list|)
decl_stmt|;
name|RelDataType
name|inputRowType
init|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|,
name|names
argument_list|)
decl_stmt|;
specifier|final
name|RexProgramBuilder
name|builder
init|=
operator|new
name|RexProgramBuilder
argument_list|(
name|inputRowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
comment|// $t0 = x
comment|// $t1 = y
comment|// $t2 = $t0 + 1 (i.e. x + 1)
specifier|final
name|RexNode
name|i0
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|types
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|c1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|c5
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|5L
argument_list|)
argument_list|)
decl_stmt|;
name|RexLocalRef
name|t2
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|c1
argument_list|)
argument_list|)
decl_stmt|;
comment|// $t3 = 77 (not used)
specifier|final
name|RexLiteral
name|c77
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|77
argument_list|)
argument_list|)
decl_stmt|;
name|RexLocalRef
name|t3
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|c77
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|t3
argument_list|)
expr_stmt|;
comment|// $t4 = $t0 + $t1 (i.e. x + y)
specifier|final
name|RexNode
name|i1
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|types
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|RexLocalRef
name|t4
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|)
decl_stmt|;
name|RexLocalRef
name|t5
decl_stmt|;
specifier|final
name|RexLocalRef
name|t1
decl_stmt|;
switch|switch
condition|(
name|variant
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
comment|// $t5 = $t0 + $t0 (i.e. x + x)
name|t5
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|i0
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
literal|null
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
comment|// $tx = $t0 + 1
name|t1
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|c1
argument_list|)
argument_list|)
expr_stmt|;
comment|// $t5 = $t0 + $tx (i.e. x + (x + 1))
name|t5
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|i0
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected variant "
operator|+
name|variant
argument_list|)
throw|;
block|}
comment|// $t6 = $t4 + $t2 (i.e. (x + y) + (x + 1))
name|RexLocalRef
name|t6
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|,
name|t4
argument_list|,
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|builder
operator|.
name|addProject
argument_list|(
name|t6
operator|.
name|getIndex
argument_list|()
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addProject
argument_list|(
name|t5
operator|.
name|getIndex
argument_list|()
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
specifier|final
name|RexLocalRef
name|t7
decl_stmt|;
specifier|final
name|RexLocalRef
name|t8
decl_stmt|;
switch|switch
condition|(
name|variant
condition|)
block|{
case|case
literal|2
case|:
comment|// $t7 = $t4> $i0 (i.e. (x + y)> 0)
name|t7
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|t4
argument_list|,
name|i0
argument_list|)
argument_list|)
expr_stmt|;
comment|// $t8 = $t7 AND $t7
name|t8
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|and
argument_list|(
name|t7
argument_list|,
name|t7
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addCondition
argument_list|(
name|t8
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addCondition
argument_list|(
name|t7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
comment|// $t7 = 5
name|t7
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|c5
argument_list|)
expr_stmt|;
comment|// $t8 = $t2> $t7 (i.e. (x + 1)> 5)
name|t8
operator|=
name|builder
operator|.
name|addExpr
argument_list|(
name|gt
argument_list|(
name|t2
argument_list|,
name|t7
argument_list|)
argument_list|)
expr_stmt|;
comment|// $t9 = true
specifier|final
name|RexLocalRef
name|t9
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|trueLiteral
argument_list|)
decl_stmt|;
comment|// $t10 = $t1 is not null (i.e. y is not null)
assert|assert
name|t1
operator|!=
literal|null
assert|;
specifier|final
name|RexLocalRef
name|t10
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|t1
argument_list|)
argument_list|)
decl_stmt|;
comment|// $t11 = false
specifier|final
name|RexLocalRef
name|t11
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|falseLiteral
argument_list|)
decl_stmt|;
comment|// $t12 = unknown
specifier|final
name|RexLocalRef
name|t12
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|nullBool
argument_list|)
decl_stmt|;
comment|// $t13 = case when $t8 then $t9 when $t10 then $t11 else $t12 end
specifier|final
name|RexLocalRef
name|t13
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|case_
argument_list|(
name|t8
argument_list|,
name|t9
argument_list|,
name|t10
argument_list|,
name|t11
argument_list|,
name|t12
argument_list|)
argument_list|)
decl_stmt|;
comment|// $t14 = not $t13 (i.e. not case ... end)
specifier|final
name|RexLocalRef
name|t14
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|not
argument_list|(
name|t13
argument_list|)
argument_list|)
decl_stmt|;
comment|// don't add 't14 is true' - that is implicit
if|if
condition|(
name|variant
operator|==
literal|3
condition|)
block|{
name|builder
operator|.
name|addCondition
argument_list|(
name|t14
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// $t15 = $14 is true
specifier|final
name|RexLocalRef
name|t15
init|=
name|builder
operator|.
name|addExpr
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|t14
argument_list|)
argument_list|)
decl_stmt|;
name|builder
operator|.
name|addCondition
argument_list|(
name|t15
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
return|;
block|}
comment|/** Unit test for {@link org.apache.calcite.plan.Strong}. */
annotation|@
name|Test
specifier|public
name|void
name|testStrong
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c0
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c1
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c01
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|c13
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|// input ref
specifier|final
name|RexInputRef
name|i0
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i1
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// literals are strong iff they are always null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|trueLiteral
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|trueLiteral
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|falseLiteral
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullInt
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullInt
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullBool
argument_list|,
name|c13
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// AND is strong if one of its arguments is strong
specifier|final
name|RexNode
name|andUnknownTrue
init|=
name|and
argument_list|(
name|nullBool
argument_list|,
name|trueLiteral
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|andTrueUnknown
init|=
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|nullBool
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|andFalseTrue
init|=
name|and
argument_list|(
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|andUnknownTrue
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|andTrueUnknown
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|andFalseTrue
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 is null, "i0 and i1 is null" is null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|isNull
argument_list|(
name|i1
argument_list|)
argument_list|)
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i1 is null, "i0 and i1" is false
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|isNull
argument_list|(
name|i1
argument_list|)
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 and i1 are both null, "i0 and i1" is null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 and i1 are both null, "i0 and isNull(i1) is false"
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|and
argument_list|(
name|i0
argument_list|,
name|isNull
argument_list|(
name|i1
argument_list|)
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 and i1 are both null, "i0 or i1" is null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|or
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 is null, "i0 or i1" is not necessarily null
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|or
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|or
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 is null, then "i0 is not null" is false
name|RexNode
name|i0NotNull
init|=
name|isNotNull
argument_list|(
name|i0
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|i0NotNull
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNotTrue
argument_list|(
name|i0NotNull
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// If i0 is null, then "not(i0 is not null)" is true.
comment|// Join-strengthening relies on this.
name|RexNode
name|notI0NotNull
init|=
name|not
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|notI0NotNull
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNotTrue
argument_list|(
name|notI0NotNull
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// NULLIF(null, null): null
comment|// NULLIF(null, X): null
comment|// NULLIF(X, X/Y): null or X
comment|// NULLIF(X, null): X
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|nullInt
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|trueLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|nullIf
argument_list|(
name|trueLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// ISNULL(null) is true, ISNULL(not null value) is false
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|isNull
argument_list|(
name|nullInt
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|isNull
argument_list|(
name|trueLiteral
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// CASE (<predicate1><value1><predicate2><value2><predicate3><value3> ...)
comment|// only definitely null if all values are null.
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|i0
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|i0
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|i0
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|i0
argument_list|,
name|nullInt
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|i0
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|ge
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|nullInt
argument_list|,
name|i0
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c0
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Strong
operator|.
name|isNull
argument_list|(
name|case_
argument_list|(
name|isNotNull
argument_list|(
name|i0
argument_list|)
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|,
name|c01
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for {@link org.apache.calcite.rex.RexUtil#isLosslessCast(RexNode)}. */
annotation|@
name|Test
specifier|public
name|void
name|testLosslessCast
parameter_list|()
block|{
specifier|final
name|RelDataType
name|tinyIntType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TINYINT
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|smallIntType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|bigIntType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|floatType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|FLOAT
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|charType5
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|charType6
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
literal|6
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|varCharType10
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|varCharType11
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|11
argument_list|)
decl_stmt|;
comment|// Negative
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|tinyIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|smallIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|bigIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|bigIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|floatType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|booleanType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|bigIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|charType5
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|varCharType10
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType10
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|varCharType11
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|charType5
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|bigIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|charType5
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType10
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Positive
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|smallIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|tinyIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|bigIntType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|intType
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|charType6
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType10
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|smallIntType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType11
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType11
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|charType6
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|varCharType11
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|varCharType10
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for {@link org.apache.calcite.rex.RexUtil#toCnf}. */
annotation|@
name|Test
specifier|public
name|void
name|testCnf
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"f"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"g"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"h"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|gRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|6
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|7
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|sevenLiteral
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|7
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hEqSeven
init|=
name|eq
argument_list|(
name|hRef
argument_list|,
name|sevenLiteral
argument_list|)
decl_stmt|;
name|checkCnf
argument_list|(
name|aRef
argument_list|,
literal|"?0.a"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|trueLiteral
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|falseLiteral
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|nullBool
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, ?0.c)"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|or
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(OR(?0.a, ?0.b), OR(?0.c, ?0.d))"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(OR(?0.a, ?0.c), OR(?0.a, ?0.d), OR(?0.b, ?0.c), OR(?0.b, ?0.d))"
argument_list|)
expr_stmt|;
comment|// Input has nested ORs, output ORs are flat
name|checkCnf
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|or
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(OR(?0.a, ?0.c, ?0.d), OR(?0.b, ?0.c, ?0.d))"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|and
argument_list|(
name|bRef
argument_list|,
name|not
argument_list|(
name|hEqSeven
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"OR(?0.a, NOT(?0.b), =(?0.h, 7))"
argument_list|)
expr_stmt|;
comment|// apply de Morgan's theorem
name|checkCnf
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|bRef
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(NOT(?0.a), ?0.b)"
argument_list|)
expr_stmt|;
comment|// apply de Morgan's theorem,
comment|// filter out 'OR ... FALSE' and 'AND ... TRUE'
name|checkCnf
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|not
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"AND(NOT(?0.a), ?0.b)"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, OR(?0.b, ?0.c), OR(?0.b, ?0.d))"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|and
argument_list|(
name|eRef
argument_list|,
name|or
argument_list|(
name|fRef
argument_list|,
name|gRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, OR(?0.b, ?0.c), OR(?0.b, ?0.d, ?0.e), OR(?0.b, ?0.d, ?0.f, ?0.g))"
argument_list|)
expr_stmt|;
name|checkCnf
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|and
argument_list|(
name|eRef
argument_list|,
name|or
argument_list|(
name|fRef
argument_list|,
name|and
argument_list|(
name|gRef
argument_list|,
name|or
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, OR(?0.b, ?0.c), OR(?0.b, ?0.d, ?0.e), OR(?0.b, ?0.d, ?0.f, ?0.g))"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-394">[CALCITE-394]    * Add RexUtil.toCnf, to convert expressions to conjunctive normal form    * (CNF)</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testCnf2
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"x"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"y"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"z"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|xRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|yRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|zRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal3
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|checkCnf
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|yRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|zRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|eq
argument_list|(
name|yRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal2
argument_list|)
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal3
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND("
operator|+
literal|"OR(=(?0.x, 1), =(?0.x, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.x, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.x, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.y, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.y, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.y, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.a, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.a, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.x, 1), =(?0.a, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.x, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.x, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.x, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.y, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.y, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.y, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.a, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.a, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.y, 1), =(?0.a, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.x, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.x, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.x, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.y, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.y, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.y, 2), =(?0.b, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.a, 2), =(?0.x, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.a, 2), =(?0.a, 3)), "
operator|+
literal|"OR(=(?0.z, 1), =(?0.a, 2), =(?0.b, 3)))"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1290">[CALCITE-1290]    * When converting to CNF, fail if the expression exceeds a threshold</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testThresholdCnf
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"x"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"y"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|xRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|yRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal3
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal4
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
comment|// Expression
comment|//   OR(=(?0.x, 1), AND(=(?0.x, 2), =(?0.y, 3)))
comment|// transformation creates 7 nodes
comment|//   AND(OR(=(?0.x, 1), =(?0.x, 2)), OR(=(?0.x, 1), =(?0.y, 3)))
comment|// Thus, it is triggered.
name|checkThresholdCnf
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|eq
argument_list|(
name|yRef
argument_list|,
name|literal3
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|"AND(OR(=(?0.x, 1), =(?0.x, 2)), OR(=(?0.x, 1), =(?0.y, 3)))"
argument_list|)
expr_stmt|;
comment|// Expression
comment|//   OR(=(?0.x, 1), =(?0.x, 2), AND(=(?0.x, 3), =(?0.y, 4)))
comment|// transformation creates 9 nodes
comment|//   AND(OR(=(?0.x, 1), =(?0.x, 2), =(?0.x, 3)),
comment|//       OR(=(?0.x, 1), =(?0.x, 2), =(?0.y, 8)))
comment|// Thus, it is NOT triggered.
name|checkThresholdCnf
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|xRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|eq
argument_list|(
name|yRef
argument_list|,
name|literal4
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|"OR(=(?0.x, 1), =(?0.x, 2), AND(=(?0.x, 3), =(?0.y, 4)))"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests formulas of various sizes whose size is exponential when converted    * to CNF. */
annotation|@
name|Test
specifier|public
name|void
name|testCnfExponential
parameter_list|()
block|{
comment|// run out of memory if limit is higher than about 20
specifier|final
name|int
name|limit
init|=
name|CalciteAssert
operator|.
name|ENABLE_SLOW
condition|?
literal|16
else|:
literal|6
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|checkExponentialCnf
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkExponentialCnf
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
literal|"x"
operator|+
name|i
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"y"
operator|+
name|i
argument_list|,
name|booleanType
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|rowType3
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range3
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|and
argument_list|(
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range3
argument_list|,
name|i
operator|*
literal|2
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range3
argument_list|,
name|i
operator|*
literal|2
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|cnf
init|=
name|RexUtil
operator|.
name|toCnf
argument_list|(
name|rexBuilder
argument_list|,
name|or
argument_list|(
name|list
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nodeCount
init|=
name|nodeCount
argument_list|(
name|cnf
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
operator|(
name|int
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|n
argument_list|)
operator|+
literal|1
argument_list|,
name|equalTo
argument_list|(
name|nodeCount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|3
condition|)
block|{
name|assertThat
argument_list|(
name|cnf
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"AND(OR(?0.x0, ?0.x1, ?0.x2), OR(?0.x0, ?0.x1, ?0.y2),"
operator|+
literal|" OR(?0.x0, ?0.y1, ?0.x2), OR(?0.x0, ?0.y1, ?0.y2),"
operator|+
literal|" OR(?0.y0, ?0.x1, ?0.x2), OR(?0.y0, ?0.x1, ?0.y2),"
operator|+
literal|" OR(?0.y0, ?0.y1, ?0.x2), OR(?0.y0, ?0.y1, ?0.y2))"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Unit test for {@link org.apache.calcite.rex.RexUtil#pullFactors}. */
annotation|@
name|Test
specifier|public
name|void
name|testPullFactors
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"f"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"g"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"h"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|gRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|6
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|7
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|sevenLiteral
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|7
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hEqSeven
init|=
name|eq
argument_list|(
name|hRef
argument_list|,
name|sevenLiteral
argument_list|)
decl_stmt|;
comment|// Most of the expressions in testCnf are unaffected by pullFactors.
name|checkPullFactors
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|aRef
argument_list|,
name|dRef
argument_list|,
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, OR(?0.b, AND(?0.c, ?0.d)))"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|aRef
argument_list|,
literal|"?0.a"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|trueLiteral
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|falseLiteral
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|nullBool
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
name|checkPullFactors
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, ?0.c)"
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|and
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|or
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Input has nested ORs, output ORs are flat; different from CNF
name|checkPullFactors
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|or
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|,
literal|"OR(AND(?0.a, ?0.b), ?0.c, ?0.d)"
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|and
argument_list|(
name|bRef
argument_list|,
name|not
argument_list|(
name|hEqSeven
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|bRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|not
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|not
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|and
argument_list|(
name|eRef
argument_list|,
name|or
argument_list|(
name|fRef
argument_list|,
name|gRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|checkPullFactorsUnchanged
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|or
argument_list|(
name|bRef
argument_list|,
name|and
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|and
argument_list|(
name|eRef
argument_list|,
name|or
argument_list|(
name|fRef
argument_list|,
name|and
argument_list|(
name|gRef
argument_list|,
name|or
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplify
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|intType
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"f"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"g"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"h"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"i"
argument_list|,
name|intNullableType
argument_list|)
operator|.
name|add
argument_list|(
literal|"j"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"k"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|hRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|7
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|iRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|8
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|jRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|9
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|kRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
comment|// and: remove duplicates
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|aRef
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
comment|// and: remove true
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
comment|// and: false falsifies
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// and: remove duplicate "not"s
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|not
argument_list|(
name|aRef
argument_list|)
argument_list|,
name|bRef
argument_list|,
name|not
argument_list|(
name|cRef
argument_list|)
argument_list|,
name|not
argument_list|(
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.b, NOT(?0.a), NOT(?0.c))"
argument_list|)
expr_stmt|;
comment|// and: "not true" falsifies
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|not
argument_list|(
name|aRef
argument_list|)
argument_list|,
name|bRef
argument_list|,
name|not
argument_list|(
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// and: flatten and remove duplicates
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|and
argument_list|(
name|and
argument_list|(
name|bRef
argument_list|,
name|not
argument_list|(
name|cRef
argument_list|)
argument_list|,
name|dRef
argument_list|,
name|not
argument_list|(
name|eRef
argument_list|)
argument_list|)
argument_list|,
name|not
argument_list|(
name|eRef
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, ?0.d, NOT(?0.c), NOT(?0.e))"
argument_list|)
expr_stmt|;
comment|// and: expand "... and not(or(x, y))" to "... and not(x) and not(y)"
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|not
argument_list|(
name|or
argument_list|(
name|cRef
argument_list|,
name|or
argument_list|(
name|dRef
argument_list|,
name|eRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, NOT(?0.c), NOT(?0.d), NOT(?0.e))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|not
argument_list|(
name|or
argument_list|(
name|not
argument_list|(
name|cRef
argument_list|)
argument_list|,
name|dRef
argument_list|,
name|not
argument_list|(
name|eRef
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(?0.a, ?0.b, ?0.c, ?0.e, NOT(?0.d))"
argument_list|)
expr_stmt|;
comment|// or: remove duplicates
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|aRef
argument_list|)
argument_list|,
literal|"OR(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
comment|// or: remove false
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"OR(?0.a, ?0.b)"
argument_list|)
expr_stmt|;
comment|// or: true makes everything true
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// case: remove false branches
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|bRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
name|dRef
argument_list|,
name|falseLiteral
argument_list|,
name|aRef
argument_list|,
name|eRef
argument_list|)
argument_list|,
literal|"CASE(=(?0.b, ?0.c), ?0.d, ?0.e)"
argument_list|)
expr_stmt|;
comment|// case: true branches become the last branch
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|eq
argument_list|(
name|bRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
name|dRef
argument_list|,
name|trueLiteral
argument_list|,
name|aRef
argument_list|,
name|eq
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|,
name|eRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
literal|"CASE(=(?0.b, ?0.c), ?0.d, ?0.a)"
argument_list|)
expr_stmt|;
comment|// case: singleton
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|trueLiteral
argument_list|,
name|aRef
argument_list|,
name|eq
argument_list|(
name|cRef
argument_list|,
name|dRef
argument_list|)
argument_list|,
name|eRef
argument_list|,
name|cRef
argument_list|)
argument_list|,
literal|"?0.a"
argument_list|)
expr_stmt|;
comment|// case: always same value
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|,
name|bRef
argument_list|,
name|literal1
argument_list|,
name|cRef
argument_list|,
name|literal1
argument_list|,
name|dRef
argument_list|,
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
comment|// case: trailing false and null, no simplification
name|checkSimplify2
argument_list|(
name|case_
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|,
name|bRef
argument_list|,
name|trueLiteral
argument_list|,
name|cRef
argument_list|,
name|falseLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"CASE(?0.a, true, ?0.b, true, ?0.c, false, null)"
argument_list|,
literal|"CAST(OR(?0.a, ?0.b)):BOOLEAN"
argument_list|)
expr_stmt|;
comment|// case: form an AND of branches that return true
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|,
name|bRef
argument_list|,
name|falseLiteral
argument_list|,
name|cRef
argument_list|,
name|falseLiteral
argument_list|,
name|dRef
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|,
literal|"OR(?0.a, AND(?0.d, NOT(?0.b), NOT(?0.c)))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|case_
argument_list|(
name|aRef
argument_list|,
name|trueLiteral
argument_list|,
name|bRef
argument_list|,
name|falseLiteral
argument_list|,
name|cRef
argument_list|,
name|falseLiteral
argument_list|,
name|dRef
argument_list|,
name|trueLiteral
argument_list|,
name|eRef
argument_list|,
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
literal|"OR(?0.a, AND(?0.d, NOT(?0.b), NOT(?0.c)), AND(NOT(?0.b), NOT(?0.c), NOT(?0.e)))"
argument_list|)
expr_stmt|;
comment|// is null, applied to not-null value
name|checkSimplify
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|aRef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// is not null, applied to not-null value
name|checkSimplify
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|aRef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// condition, and the inverse - nothing to do due to null values
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|le
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(<=(?0.h, 1),>(?0.h, 1))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|le
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(<=(?0.h, 1),>=(?0.h, 1))"
argument_list|,
literal|"=(?0.h, 1)"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(<(?0.h, 1), =(?0.h, 1),>=(?0.h, 1))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|or
argument_list|(
name|falseLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|or
argument_list|(
name|falseLiteral
argument_list|,
name|gt
argument_list|(
name|jRef
argument_list|,
name|kRef
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(<(?0.h, 1),>(?0.j, ?0.k))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|or
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"<(?0.h, 1)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|or
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|or
argument_list|(
name|falseLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"<(?0.h, 1)"
argument_list|)
expr_stmt|;
comment|// "x = x" simplifies to "x is not null"
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|eq
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"=(?0.i, ?0.i)"
argument_list|,
literal|"IS NOT NULL(?0.i)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"=(?0.i, ?0.h)"
argument_list|)
expr_stmt|;
comment|// "x<= x" simplifies to "x is not null"
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|le
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"<=(?0.i, ?0.i)"
argument_list|,
literal|"IS NOT NULL(?0.i)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"<=(?0.i, ?0.h)"
argument_list|)
expr_stmt|;
comment|// "x>= x" simplifies to "x is not null"
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|ge
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|">=(?0.i, ?0.i)"
argument_list|,
literal|"IS NOT NULL(?0.i)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|">=(?0.i, ?0.h)"
argument_list|)
expr_stmt|;
comment|// "x != x" simplifies to "false"
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|ne
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"<>(?0.i, ?0.i)"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"<>(?0.i, ?0.h)"
argument_list|)
expr_stmt|;
comment|// "x< x" simplifies to "false"
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|lt
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"<(?0.i, ?0.i)"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"<(?0.i, ?0.h)"
argument_list|)
expr_stmt|;
comment|// "x> x" simplifies to "false"
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literal1
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|gt
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|">(?0.i, ?0.i)"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|">(?0.i, ?0.h)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|hRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"?0.h"
argument_list|)
expr_stmt|;
comment|// first arg not null
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"COALESCE(?0.i, ?0.h)"
argument_list|)
expr_stmt|;
comment|// a0 nullable
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|iRef
argument_list|,
name|iRef
argument_list|)
argument_list|,
literal|"?0.i"
argument_list|)
expr_stmt|;
comment|// repeated arg
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|hRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"?0.h"
argument_list|)
expr_stmt|;
comment|// repeated arg
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|hRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"?0.h"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|iRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
literal|"COALESCE(?0.i, 1)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|coalesce
argument_list|(
name|iRef
argument_list|,
name|plus
argument_list|(
name|iRef
argument_list|,
name|hRef
argument_list|)
argument_list|,
name|literal1
argument_list|,
name|hRef
argument_list|)
argument_list|,
literal|"COALESCE(?0.i, +(?0.i, ?0.h), 1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyFilter
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"f"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"g"
argument_list|,
name|booleanType
argument_list|)
operator|.
name|add
argument_list|(
literal|"h"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal5
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal10
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|TEN
argument_list|)
decl_stmt|;
comment|// condition, and the inverse
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// simplify equals boolean
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|args
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|trueLiteral
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|args
argument_list|)
argument_list|,
literal|"AND(=(?0.a, 1), =(?0.b, 1))"
argument_list|)
expr_stmt|;
comment|// as previous, using simplifyFilterPredicates
name|assertThat
argument_list|(
name|simplify
operator|.
name|withUnknownAsFalse
argument_list|(
literal|true
argument_list|)
operator|.
name|simplifyFilterPredicates
argument_list|(
name|args
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"AND(=(?0.a, 1), =(?0.b, 1))"
argument_list|)
argument_list|)
expr_stmt|;
comment|// "a = 1 and a = 10" is always false
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|args2
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|args2
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|simplify
operator|.
name|withUnknownAsFalse
argument_list|(
literal|true
argument_list|)
operator|.
name|simplifyFilterPredicates
argument_list|(
name|args2
argument_list|)
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// equality on constants, can remove the equality on the variables
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|)
argument_list|,
literal|"AND(=(?0.a, 1), =(?0.b, 1))"
argument_list|)
expr_stmt|;
comment|// condition not satisfiable
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition not satisfiable
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|ge
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// one "and" containing three "or"s
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|gt
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|,
literal|"OR(>(?0.a, 10),>(?0.b, 1))"
argument_list|)
expr_stmt|;
comment|// case: trailing false and null, remove
name|checkSimplifyFilter
argument_list|(
name|case_
argument_list|(
name|cRef
argument_list|,
name|trueLiteral
argument_list|,
name|dRef
argument_list|,
name|trueLiteral
argument_list|,
name|eRef
argument_list|,
name|falseLiteral
argument_list|,
name|fRef
argument_list|,
name|falseLiteral
argument_list|,
name|nullBool
argument_list|)
argument_list|,
literal|"CAST(OR(?0.c, ?0.d)):BOOLEAN"
argument_list|)
expr_stmt|;
comment|// condition with null value for range
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|nullBool
argument_list|)
argument_list|,
name|ge
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "1< a&& 5< x" yields "5< x"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|literal1
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|lt
argument_list|(
name|literal5
argument_list|,
name|aRef
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|"<(5, ?0.a)"
argument_list|)
expr_stmt|;
comment|// condition "1< a&& a< 5" is unchanged
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|lt
argument_list|(
name|literal1
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|"AND(<(1, ?0.a),<(?0.a, 5))"
argument_list|)
expr_stmt|;
comment|// condition "1> a&& 5> x" yields "1> a"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|literal1
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|gt
argument_list|(
name|literal5
argument_list|,
name|aRef
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|">(1, ?0.a)"
argument_list|)
expr_stmt|;
comment|// condition "1> a&& a> 5" yields false
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|literal1
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// range with no predicates;
comment|// condition "a> 1&& a< 10&& a< 5" yields "a< 1&& a< 5"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|"AND(>(?0.a, 1),<(?0.a, 5))"
argument_list|)
expr_stmt|;
comment|// condition "a> 1&& a< 10&& a< 5"
comment|// with pre-condition "a> 5"
comment|// yields "false"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "a> 1&& a< 10&& a<= 5"
comment|// with pre-condition "a>= 5"
comment|// yields "a = 5"
comment|// "a<= 5" would also be correct, just a little less concise.
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|le
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 5)"
argument_list|)
expr_stmt|;
comment|// condition "a> 1&& a< 10&& a< 5"
comment|// with pre-condition "b< 10&& a> 5"
comment|// yields "a> 1 and a< 5"
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|lt
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(>(?0.a, 1),<(?0.a, 5))"
argument_list|)
expr_stmt|;
comment|// condition "a> 1"
comment|// with pre-condition "b< 10&& a> 5"
comment|// yields "true"
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|lt
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// condition "a< 1"
comment|// with pre-condition "b< 10&& a> 5"
comment|// yields "false"
name|checkSimplifyFilter
argument_list|(
name|lt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|lt
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "a> 5"
comment|// with pre-condition "b< 10&& a>= 5"
comment|// yields "a> 5"
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|lt
argument_list|(
name|bRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|ge
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|">(?0.a, 5)"
argument_list|)
expr_stmt|;
comment|// condition "a> 5"
comment|// with pre-condition "a<= 5"
comment|// yields "false"
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "a> 5"
comment|// with pre-condition "a<= 5 and b<= 5"
comment|// yields "false"
name|checkSimplifyFilter
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|le
argument_list|(
name|bRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// condition "a> 5 or b> 5"
comment|// with pre-condition "a<= 5 and b<= 5"
comment|// should yield "false" but yields "a = 5 or b = 5"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|gt
argument_list|(
name|bRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|,
name|RelOptPredicateList
operator|.
name|of
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|le
argument_list|(
name|aRef
argument_list|,
name|literal5
argument_list|)
argument_list|,
name|le
argument_list|(
name|bRef
argument_list|,
name|literal5
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyAndPush
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal5
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal10
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|TEN
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|">(?0.a, 10)"
argument_list|)
expr_stmt|;
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|gt
argument_list|(
name|aRef
argument_list|,
name|literal10
argument_list|)
argument_list|)
argument_list|,
literal|">(?0.a, 10)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyOrTerms
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|false
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|true
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|intType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal3
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal4
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
comment|// "a != 1 or a = 1" ==> "true"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|ne
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// TODO: make this simplify to "true"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|ne
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"OR(=(?0.a, 1),<>(?0.a, 1))"
argument_list|)
expr_stmt|;
comment|// "b != 1 or b = 1" cannot be simplified, because b might be null
specifier|final
name|RexNode
name|neOrEq
init|=
name|or
argument_list|(
name|ne
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
decl_stmt|;
name|checkSimplifyFilter
argument_list|(
name|neOrEq
argument_list|,
literal|"OR(<>(?0.b, 1), IS NOT NULL(?0.b))"
argument_list|)
expr_stmt|;
comment|// Careful of the excluded middle!
comment|// We cannot simplify "b != 1 or b = 1" to "true" because if b is null, the
comment|// result is unknown.
comment|// TODO: "b is not unknown" would be the best simplification.
name|assertThat
argument_list|(
name|simplify
operator|.
name|withUnknownAsFalse
argument_list|(
literal|false
argument_list|)
operator|.
name|simplify
argument_list|(
name|neOrEq
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"OR(<>(?0.b, 1), IS NOT NULL(?0.b))"
argument_list|)
argument_list|)
expr_stmt|;
comment|// "a is null or a is not null" ==> "true"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNull
argument_list|(
name|aRef
argument_list|)
argument_list|,
name|isNotNull
argument_list|(
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "a is not null or a is null" ==> "true"
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNotNull
argument_list|(
name|aRef
argument_list|)
argument_list|,
name|isNull
argument_list|(
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "b is not null or b is null" ==> "true" (valid even though b nullable)
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNotNull
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|isNull
argument_list|(
name|bRef
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// "b is not null or c is null" unchanged
name|checkSimplifyFilter
argument_list|(
name|or
argument_list|(
name|isNotNull
argument_list|(
name|bRef
argument_list|)
argument_list|,
name|isNull
argument_list|(
name|cRef
argument_list|)
argument_list|)
argument_list|,
literal|"OR(IS NOT NULL(?0.b), IS NULL(?0.c))"
argument_list|)
expr_stmt|;
comment|// multiple predicates are handled correctly
name|checkSimplifyFilter
argument_list|(
name|and
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal2
argument_list|)
argument_list|)
argument_list|,
name|eq
argument_list|(
name|bRef
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal4
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(=(?0.b, 2), =(?0.a, 3))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyUnknown
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"AND(=(?0.a, 1), null)"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|trueLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"null"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|falseLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"false"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|nullInt
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(null, =(?0.a, 1))"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|or
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"OR(=(?0.a, 1), null)"
argument_list|,
literal|"=(?0.a, 1)"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|or
argument_list|(
name|trueLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"true"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify2
argument_list|(
name|or
argument_list|(
name|falseLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|,
literal|"null"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyAnd3
parameter_list|()
block|{
specifier|final
name|RelDataType
name|boolType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|boolType
argument_list|)
operator|.
name|nullable
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// in the case of 3-valued logic, the result must be unknown if a is unknown
name|checkSimplify2
argument_list|(
name|and
argument_list|(
name|aRef
argument_list|,
name|not
argument_list|(
name|aRef
argument_list|)
argument_list|)
argument_list|,
literal|"a is null and null"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
comment|/** Unit test for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1289">[CALCITE-1289]    * RexUtil.simplifyCase() should account for nullability</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseNotNullableBoolean
parameter_list|()
block|{
name|RexNode
name|condition
init|=
name|eq
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"S"
argument_list|)
argument_list|)
decl_stmt|;
name|RexCall
name|caseNode
init|=
operator|(
name|RexCall
operator|)
name|case_
argument_list|(
name|condition
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
name|RexCall
name|result
init|=
operator|(
name|RexCall
operator|)
name|simplify
operator|.
name|simplify
argument_list|(
name|caseNode
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperator
argument_list|()
argument_list|,
name|is
argument_list|(
operator|(
name|SqlOperator
operator|)
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
operator|(
name|Object
operator|)
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
operator|(
name|RexNode
operator|)
name|trueLiteral
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
operator|(
name|RexNode
operator|)
name|falseLiteral
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseNullableBoolean
parameter_list|()
block|{
name|RexNode
name|condition
init|=
name|eq
argument_list|(
name|input
argument_list|(
name|tVarchar
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|"S"
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|condition
argument_list|,
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
decl_stmt|;
name|RexCall
name|result
init|=
operator|(
name|RexCall
operator|)
name|simplify
operator|.
name|simplify
argument_list|(
name|caseNode
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|is
argument_list|(
name|condition
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCaseNullableVarChar
parameter_list|()
block|{
name|RexNode
name|condition
init|=
name|eq
argument_list|(
name|input
argument_list|(
name|tVarchar
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|"S"
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|caseNode
init|=
name|case_
argument_list|(
name|condition
argument_list|,
name|literal
argument_list|(
literal|"A"
argument_list|)
argument_list|,
name|literal
argument_list|(
literal|"B"
argument_list|)
argument_list|)
decl_stmt|;
name|RexCall
name|result
init|=
operator|(
name|RexCall
operator|)
name|simplify
operator|.
name|simplify
argument_list|(
name|caseNode
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
argument_list|,
name|is
argument_list|(
name|caseNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyAnd
parameter_list|()
block|{
name|RelDataType
name|booleanNotNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RelDataType
name|booleanNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|RexNode
name|andCondition
init|=
name|and
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|booleanNotNullableType
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|booleanNullableType
argument_list|,
literal|1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|booleanNotNullableType
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|result
init|=
name|simplify
operator|.
name|simplify
argument_list|(
name|andCondition
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|is
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyIsNotNull
parameter_list|()
block|{
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|RelDataType
name|intNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i0
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intNullableType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i1
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intNullableType
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i2
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|i3
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|intType
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|one
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|null_
init|=
name|rexBuilder
operator|.
name|makeNullLiteral
argument_list|(
name|intType
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i0
argument_list|,
name|i1
argument_list|)
argument_list|)
argument_list|,
literal|"AND(IS NOT NULL($0), IS NOT NULL($1))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i0
argument_list|,
name|i2
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL($0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i2
argument_list|,
name|i3
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i0
argument_list|,
name|one
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL($0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|i0
argument_list|,
name|null_
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|checkSimplifyDynamicParam
parameter_list|()
block|{
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vInt
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"AND(IS NOT NULL(?0.int0), IS NOT NULL(?0.int1))"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL(?0.int0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vIntNotNull
argument_list|(
literal|2
argument_list|)
argument_list|,
name|vIntNotNull
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|literal
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"IS NOT NULL(?0.int0)"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|isNotNull
argument_list|(
name|lt
argument_list|(
name|vInt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|null_
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastLiteral
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|literals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|3
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TINYINT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"1234"
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"123.45"
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|"3.1415"
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|REAL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|E
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|FLOAT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|PI
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"hello world"
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"1969-07-20 12:34:56"
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"1969-07-20"
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"12:34:45"
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
operator|(
name|RexLiteral
operator|)
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|new
name|ByteString
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|1
block|,
literal|2
block|,
operator|-
literal|34
block|,
literal|0
block|,
operator|-
literal|128
block|}
argument_list|)
argument_list|,
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BINARY
argument_list|,
literal|5
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeDateLiteral
argument_list|(
operator|new
name|DateString
argument_list|(
literal|1974
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeTimeLiteral
argument_list|(
operator|new
name|TimeString
argument_list|(
literal|1
argument_list|,
literal|23
argument_list|,
literal|45
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|literals
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeTimestampLiteral
argument_list|(
operator|new
name|TimestampString
argument_list|(
literal|1974
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|,
literal|23
argument_list|,
literal|45
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Multimap
argument_list|<
name|SqlTypeName
argument_list|,
name|RexLiteral
argument_list|>
name|map
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|RexLiteral
name|literal
range|:
name|literals
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|literal
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SMALLINT
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TINYINT
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|REAL
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|FLOAT
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DOUBLE
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARBINARY
argument_list|,
literal|60
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BINARY
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RelDataType
name|fromType
range|:
name|types
control|)
block|{
for|for
control|(
name|RelDataType
name|toType
range|:
name|types
control|)
block|{
if|if
condition|(
name|SqlTypeAssignmentRules
operator|.
name|instance
argument_list|(
literal|false
argument_list|)
operator|.
name|canCastFrom
argument_list|(
name|toType
operator|.
name|getSqlTypeName
argument_list|()
argument_list|,
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|RexLiteral
name|literal
range|:
name|map
operator|.
name|get
argument_list|(
name|fromType
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|RexNode
name|cast
init|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|toType
argument_list|,
name|literal
argument_list|)
decl_stmt|;
if|if
condition|(
name|cast
operator|instanceof
name|RexLiteral
condition|)
block|{
name|assertThat
argument_list|(
name|cast
operator|.
name|getType
argument_list|()
argument_list|,
name|is
argument_list|(
name|toType
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|// makeCast already simplified
block|}
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplify
argument_list|(
name|cast
argument_list|)
decl_stmt|;
name|boolean
name|expectedSimplify
init|=
name|literal
operator|.
name|getTypeName
argument_list|()
operator|!=
name|toType
operator|.
name|getSqlTypeName
argument_list|()
operator|||
operator|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
operator|&&
operator|(
operator|(
name|NlsString
operator|)
name|literal
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
operator|>
name|toType
operator|.
name|getPrecision
argument_list|()
operator|)
operator|||
operator|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BINARY
operator|&&
operator|(
operator|(
name|ByteString
operator|)
name|literal
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|length
argument_list|()
operator|>
name|toType
operator|.
name|getPrecision
argument_list|()
operator|)
decl_stmt|;
name|boolean
name|couldSimplify
init|=
operator|!
name|cast
operator|.
name|equals
argument_list|(
name|simplified
argument_list|)
decl_stmt|;
specifier|final
name|String
name|reason
init|=
operator|(
name|expectedSimplify
condition|?
literal|"expected to simplify, but could not: "
else|:
literal|"simplified, but did not expect to: "
operator|)
operator|+
name|cast
operator|+
literal|" --> "
operator|+
name|simplified
decl_stmt|;
name|assertThat
argument_list|(
name|reason
argument_list|,
name|couldSimplify
argument_list|,
name|is
argument_list|(
name|expectedSimplify
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastLiteral
parameter_list|()
block|{
name|assertNode
argument_list|(
literal|"cast(literal int not null)"
argument_list|,
literal|"42:INTEGER NOT NULL"
argument_list|,
name|cast
argument_list|(
name|literal
argument_list|(
literal|42
argument_list|)
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertNode
argument_list|(
literal|"cast(literal int)"
argument_list|,
literal|"42:INTEGER NOT NULL"
argument_list|,
name|cast
argument_list|(
name|literal
argument_list|(
literal|42
argument_list|)
argument_list|,
name|nullable
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertNode
argument_list|(
literal|"abstractCast(literal int not null)"
argument_list|,
literal|"CAST(42):INTEGER NOT NULL"
argument_list|,
name|abstractCast
argument_list|(
name|literal
argument_list|(
literal|42
argument_list|)
argument_list|,
name|tInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertNode
argument_list|(
literal|"abstractCast(literal int)"
argument_list|,
literal|"CAST(42):INTEGER"
argument_list|,
name|abstractCast
argument_list|(
name|literal
argument_list|(
literal|42
argument_list|)
argument_list|,
name|nullable
argument_list|(
name|tInt
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastLiteral2
parameter_list|()
block|{
specifier|final
name|RexLiteral
name|literalAbc
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"abc"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalOne
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|varcharType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|10
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|booleanType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|dateType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timestampType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|intType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|intType
argument_list|)
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|varcharType
argument_list|)
argument_list|,
literal|"'abc'"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|varcharType
argument_list|)
argument_list|,
literal|"'1'"
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|booleanType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|booleanType
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// different from Hive
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|dateType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|dateType
argument_list|)
argument_list|,
literal|"1970-01-02"
argument_list|)
expr_stmt|;
comment|// different from Hive
name|checkSimplifyUnchanged
argument_list|(
name|cast
argument_list|(
name|literalAbc
argument_list|,
name|timestampType
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalOne
argument_list|,
name|timestampType
argument_list|)
argument_list|,
literal|"1970-01-01 00:00:00"
argument_list|)
expr_stmt|;
comment|// different from Hive
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyCastLiteral3
parameter_list|()
block|{
comment|// Default TimeZone is "America/Los_Angeles" (DummyDataContext)
specifier|final
name|RexLiteral
name|literalDate
init|=
name|rexBuilder
operator|.
name|makeDateLiteral
argument_list|(
operator|new
name|DateString
argument_list|(
literal|"2011-07-20"
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalTime
init|=
name|rexBuilder
operator|.
name|makeTimeLiteral
argument_list|(
operator|new
name|TimeString
argument_list|(
literal|"12:34:56"
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalTimestamp
init|=
name|rexBuilder
operator|.
name|makeTimestampLiteral
argument_list|(
operator|new
name|TimestampString
argument_list|(
literal|"2011-07-20 12:34:56"
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalTimeLTZ
init|=
name|rexBuilder
operator|.
name|makeTimeWithLocalTimeZoneLiteral
argument_list|(
operator|new
name|TimeString
argument_list|(
literal|1
argument_list|,
literal|23
argument_list|,
literal|45
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timeLTZChar1
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"12:34:45 America/Los_Angeles"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timeLTZChar2
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"12:34:45 UTC"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timeLTZChar3
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"12:34:45 GMT+01"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timestampLTZChar1
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"2011-07-20 12:34:56 Asia/Tokyo"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timestampLTZChar2
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"2011-07-20 12:34:56 GMT+01"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|timestampLTZChar3
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"2011-07-20 12:34:56 UTC"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalTimestampLTZ
init|=
name|rexBuilder
operator|.
name|makeTimestampWithLocalTimeZoneLiteral
argument_list|(
operator|new
name|TimestampString
argument_list|(
literal|2011
argument_list|,
literal|7
argument_list|,
literal|20
argument_list|,
literal|8
argument_list|,
literal|23
argument_list|,
literal|45
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|dateType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DATE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timeType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIME
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timestampType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timeLTZType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIME_WITH_LOCAL_TIME_ZONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|timestampLTZType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|varCharType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|VARCHAR
argument_list|,
literal|40
argument_list|)
decl_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timeLTZChar1
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"20:34:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timeLTZChar2
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"12:34:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timeLTZChar3
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"11:34:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"01:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timestampLTZChar1
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 03:34:56"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timestampLTZChar2
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 11:34:56"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|timestampLTZChar3
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 12:34:56"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 08:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalDate
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 07:00:00"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTime
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 19:34:56"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestamp
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 19:34:56"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestamp
argument_list|,
name|dateType
argument_list|)
argument_list|,
literal|"2011-07-20"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|dateType
argument_list|)
argument_list|,
literal|"2011-07-20"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|timeType
argument_list|)
argument_list|,
literal|"01:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|timestampType
argument_list|)
argument_list|,
literal|"2011-07-20 01:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|timeType
argument_list|)
argument_list|,
literal|"17:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTime
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"20:34:56"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|timeLTZType
argument_list|)
argument_list|,
literal|"08:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|varCharType
argument_list|)
argument_list|,
literal|"'17:23:45 America/Los_Angeles'"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimestampLTZ
argument_list|,
name|varCharType
argument_list|)
argument_list|,
literal|"'2011-07-20 01:23:45 America/Los_Angeles'"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|timestampType
argument_list|)
argument_list|,
literal|"2011-07-19 18:23:45"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|cast
argument_list|(
name|literalTimeLTZ
argument_list|,
name|timestampLTZType
argument_list|)
argument_list|,
literal|"2011-07-20 01:23:45"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCompareTimestampWithTimeZone
parameter_list|()
block|{
specifier|final
name|TimestampWithTimeZoneString
name|timestampLTZChar1
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
literal|"2011-07-20 10:34:56 America/Los_Angeles"
argument_list|)
decl_stmt|;
specifier|final
name|TimestampWithTimeZoneString
name|timestampLTZChar2
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
literal|"2011-07-20 19:34:56 Europe/Rome"
argument_list|)
decl_stmt|;
specifier|final
name|TimestampWithTimeZoneString
name|timestampLTZChar3
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
literal|"2011-07-20 01:34:56 Asia/Tokyo"
argument_list|)
decl_stmt|;
specifier|final
name|TimestampWithTimeZoneString
name|timestampLTZChar4
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
literal|"2011-07-20 10:34:56 America/Los_Angeles"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|timestampLTZChar1
operator|.
name|equals
argument_list|(
name|timestampLTZChar2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|timestampLTZChar1
operator|.
name|equals
argument_list|(
name|timestampLTZChar3
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|timestampLTZChar1
operator|.
name|equals
argument_list|(
name|timestampLTZChar4
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyLiterals
parameter_list|()
block|{
specifier|final
name|RexLiteral
name|literalAbc
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"abc"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalDef
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|"def"
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalZero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalOne
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literalOneDotZero
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|1.0
argument_list|)
argument_list|)
decl_stmt|;
comment|// Check string comparison
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalAbc
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalAbc
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalDef
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalDef
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalDef
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalDef
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalDef
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalAbc
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalDef
argument_list|,
name|literalAbc
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalDef
argument_list|,
name|literalDef
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// Check whole number comparison
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|gt
argument_list|(
name|literalOne
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ge
argument_list|(
name|literalOne
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|lt
argument_list|(
name|literalOne
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalOne
argument_list|,
name|literalZero
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|le
argument_list|(
name|literalOne
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
comment|// Check decimal equality comparison
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalOne
argument_list|,
name|literalOneDotZero
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|eq
argument_list|(
name|literalOneDotZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalOne
argument_list|,
name|literalOneDotZero
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|checkSimplify
argument_list|(
name|ne
argument_list|(
name|literalOneDotZero
argument_list|,
name|literalOne
argument_list|)
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
comment|// Check different types shouldn't change simplification
name|checkSimplifyUnchanged
argument_list|(
name|eq
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|eq
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ne
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ne
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|gt
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|gt
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ge
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|ge
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|lt
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|lt
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|le
argument_list|(
name|literalZero
argument_list|,
name|literalAbc
argument_list|)
argument_list|)
expr_stmt|;
name|checkSimplifyUnchanged
argument_list|(
name|le
argument_list|(
name|literalAbc
argument_list|,
name|literalZero
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleDynamicVars
parameter_list|()
block|{
name|assertTypeAndToString
argument_list|(
name|vBool
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"?0.bool2"
argument_list|,
literal|"BOOLEAN"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vBoolNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"?0.notNullBool0"
argument_list|,
literal|"BOOLEAN NOT NULL"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vInt
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"?0.int2"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vIntNotNull
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"?0.notNullInt0"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vVarchar
argument_list|()
argument_list|,
literal|"?0.varchar0"
argument_list|,
literal|"VARCHAR"
argument_list|)
expr_stmt|;
name|assertTypeAndToString
argument_list|(
name|vVarcharNotNull
argument_list|(
literal|9
argument_list|)
argument_list|,
literal|"?0.notNullVarchar9"
argument_list|,
literal|"VARCHAR NOT NULL"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|assertTypeAndToString
parameter_list|(
name|RexNode
name|rexNode
parameter_list|,
name|String
name|representation
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|representation
argument_list|,
name|rexNode
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"type of "
operator|+
name|rexNode
argument_list|,
name|type
argument_list|,
name|rexNode
operator|.
name|getType
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
operator|(
name|rexNode
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|?
literal|""
else|:
literal|" NOT NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsDeterministic
parameter_list|()
block|{
name|SqlOperator
name|ndc
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"NDC"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
name|RexNode
name|n
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|ndc
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|RexUtil
operator|.
name|isDeterministic
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|RexUtil
operator|.
name|retainDeterministic
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|n
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConstantMap
parameter_list|()
block|{
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"a"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"b"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"c"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"d"
argument_list|,
name|intType
argument_list|)
operator|.
name|add
argument_list|(
literal|"e"
argument_list|,
name|intType
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RexDynamicParam
name|range
init|=
name|rexBuilder
operator|.
name|makeDynamicParam
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|aRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|bRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|cRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|dRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|eRef
init|=
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|range
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map
init|=
name|RexUtil
operator|.
name|predicateConstants
argument_list|(
name|RexNode
operator|.
name|class
argument_list|,
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|bRef
argument_list|)
argument_list|,
name|eq
argument_list|(
name|cRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|cRef
argument_list|,
name|aRef
argument_list|)
argument_list|,
name|eq
argument_list|(
name|dRef
argument_list|,
name|eRef
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getString
argument_list|(
name|map
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"{1=?0.c, ?0.a=?0.b, ?0.b=?0.a, ?0.c=1, ?0.d=?0.e, ?0.e=?0.d}"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Contradictory constraints yield no constants
specifier|final
name|RexNode
name|ref0
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rowType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map2
init|=
name|RexUtil
operator|.
name|predicateConstants
argument_list|(
name|RexNode
operator|.
name|class
argument_list|,
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|ref0
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|ref0
argument_list|,
name|literal2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getString
argument_list|(
name|map2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"{}"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Contradictory constraints on field accesses SHOULD yield no constants
comment|// but currently there's a bug
specifier|final
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map3
init|=
name|RexUtil
operator|.
name|predicateConstants
argument_list|(
name|RexNode
operator|.
name|class
argument_list|,
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|eq
argument_list|(
name|aRef
argument_list|,
name|literal2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|getString
argument_list|(
name|map3
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"{1=?0.a, 2=?0.a}"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Converts a map to a string, sorting on the string representation of its    * keys. */
specifier|private
specifier|static
name|String
name|getString
parameter_list|(
name|ImmutableMap
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|map
parameter_list|)
block|{
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|map2
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|map2
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|map2
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyNot
parameter_list|()
block|{
specifier|final
name|RelDataType
name|booleanNullableType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|booleanInput
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|booleanNullableType
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|isFalse
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_FALSE
argument_list|,
name|booleanInput
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|result
init|=
operator|(
name|RexCall
operator|)
name|simplify
argument_list|(
name|isFalse
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperator
argument_list|()
argument_list|,
name|is
argument_list|(
operator|(
name|SqlOperator
operator|)
name|SqlStdOperatorTable
operator|.
name|IS_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
name|booleanInput
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure that IS_FALSE(IS_FALSE(nullable boolean)) != IS_TRUE(nullable boolean)
comment|// IS_FALSE(IS_FALSE(null)) = IS_FALSE(false) = true
comment|// IS_TRUE(null) = false
specifier|final
name|RexNode
name|isFalseIsFalse
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_FALSE
argument_list|,
name|isFalse
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|result2
init|=
operator|(
name|RexCall
operator|)
name|simplify
argument_list|(
name|isFalseIsFalse
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getOperator
argument_list|()
argument_list|,
name|is
argument_list|(
operator|(
name|SqlOperator
operator|)
name|SqlStdOperatorTable
operator|.
name|IS_NOT_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|result2
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|is
argument_list|(
name|booleanInput
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RexNode
name|simplify
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|RelOptPredicateList
operator|.
name|EMPTY
argument_list|,
literal|false
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
operator|.
name|withParanoid
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|simplify
operator|.
name|simplify
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInterpreter
parameter_list|()
block|{
name|assertThat
argument_list|(
name|eval
argument_list|(
name|trueLiteral
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|nullInt
argument_list|)
argument_list|,
name|is
argument_list|(
name|NullSentinel
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|eq
argument_list|(
name|nullInt
argument_list|,
name|nullInt
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
name|NullSentinel
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|eq
argument_list|(
name|this
operator|.
name|trueLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
name|NullSentinel
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|eq
argument_list|(
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|ne
argument_list|(
name|falseLiteral
argument_list|,
name|trueLiteral
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|ne
argument_list|(
name|falseLiteral
argument_list|,
name|nullInt
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
name|NullSentinel
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|eval
argument_list|(
name|and
argument_list|(
name|this
operator|.
name|trueLiteral
argument_list|,
name|falseLiteral
argument_list|)
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Comparable
name|eval
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
return|return
name|RexInterpreter
operator|.
name|evaluate
argument_list|(
name|e
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|// End RexProgramTest.java
end_comment

end_unit

