begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|ReflectiveSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|Lex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|Driver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Enumerable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|QueryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ParameterExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Primitive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|AbstractSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|TableMacroImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|ViewTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Smalls
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Disabled
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DriverManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|JdbcTest
operator|.
name|Employee
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Unit tests for {@link ReflectiveSchema}.  */
end_comment

begin_class
specifier|public
class|class
name|ReflectiveSchemaTest
block|{
specifier|public
specifier|static
specifier|final
name|Method
name|LINQ4J_AS_ENUMERABLE_METHOD
init|=
name|Types
operator|.
name|lookupMethod
argument_list|(
name|Linq4j
operator|.
name|class
argument_list|,
literal|"asEnumerable"
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ReflectiveSchema
name|CATCHALL
init|=
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|CatchallSchema
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Test that uses a JDBC connection as a linq4j    * {@link org.apache.calcite.linq4j.QueryProvider}.    *    * @throws Exception on error    */
annotation|@
name|Test
name|void
name|testQueryProvider
parameter_list|()
throws|throws
name|Exception
block|{
name|Connection
name|connection
init|=
name|CalciteAssert
operator|.
name|that
argument_list|(
name|CalciteAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|connect
argument_list|()
decl_stmt|;
name|QueryProvider
name|queryProvider
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|QueryProvider
operator|.
name|class
argument_list|)
decl_stmt|;
name|ParameterExpression
name|e
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|Employee
operator|.
name|class
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
comment|// "Enumerable<T> asEnumerable(final T[] ts)"
name|List
argument_list|<
name|Object
index|[]
argument_list|>
name|list
init|=
name|queryProvider
operator|.
name|createQuery
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|Types
operator|.
name|of
argument_list|(
name|Enumerable
operator|.
name|class
argument_list|,
name|Employee
operator|.
name|class
argument_list|)
argument_list|,
literal|null
argument_list|,
name|LINQ4J_AS_ENUMERABLE_METHOD
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
operator|.
name|emps
argument_list|)
argument_list|)
argument_list|,
literal|"asQueryable"
argument_list|)
argument_list|,
name|Employee
operator|.
name|class
argument_list|)
operator|.
name|where
argument_list|(
name|Expressions
operator|.
name|lambda
argument_list|(
name|Expressions
operator|.
name|lessThan
argument_list|(
name|Expressions
operator|.
name|field
argument_list|(
name|e
argument_list|,
literal|"empid"
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|160
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
operator|.
name|where
argument_list|(
name|Expressions
operator|.
name|lambda
argument_list|(
name|Expressions
operator|.
name|greaterThan
argument_list|(
name|Expressions
operator|.
name|field
argument_list|(
name|e
argument_list|,
literal|"empid"
argument_list|)
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
literal|140
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
operator|.
name|select
argument_list|(
name|Expressions
operator|.
expr|<
name|Function1
argument_list|<
name|Employee
argument_list|,
name|Object
index|[]
argument_list|>
operator|>
name|lambda
argument_list|(
name|Expressions
operator|.
name|new_
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|,
name|Expressions
operator|.
name|field
argument_list|(
name|e
argument_list|,
literal|"empid"
argument_list|)
argument_list|,
name|Expressions
operator|.
name|call
argument_list|(
name|Expressions
operator|.
name|field
argument_list|(
name|e
argument_list|,
literal|"name"
argument_list|)
argument_list|,
literal|"toUpperCase"
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
operator|.
name|toList
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|150
argument_list|,
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"SEBASTIAN"
argument_list|,
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testQueryProviderSingleColumn
parameter_list|()
throws|throws
name|Exception
block|{
name|Connection
name|connection
init|=
name|CalciteAssert
operator|.
name|that
argument_list|(
name|CalciteAssert
operator|.
name|Config
operator|.
name|REGULAR
argument_list|)
operator|.
name|connect
argument_list|()
decl_stmt|;
name|QueryProvider
name|queryProvider
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|QueryProvider
operator|.
name|class
argument_list|)
decl_stmt|;
name|ParameterExpression
name|e
init|=
name|Expressions
operator|.
name|parameter
argument_list|(
name|Employee
operator|.
name|class
argument_list|,
literal|"e"
argument_list|)
decl_stmt|;
comment|// "Enumerable<T> asEnumerable(final T[] ts)"
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|queryProvider
operator|.
name|createQuery
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|Expressions
operator|.
name|call
argument_list|(
name|Types
operator|.
name|of
argument_list|(
name|Enumerable
operator|.
name|class
argument_list|,
name|Employee
operator|.
name|class
argument_list|)
argument_list|,
literal|null
argument_list|,
name|LINQ4J_AS_ENUMERABLE_METHOD
argument_list|,
name|Expressions
operator|.
name|constant
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
operator|.
name|emps
argument_list|)
argument_list|)
argument_list|,
literal|"asQueryable"
argument_list|)
argument_list|,
name|Employee
operator|.
name|class
argument_list|)
operator|.
name|select
argument_list|(
name|Expressions
operator|.
expr|<
name|Function1
argument_list|<
name|Employee
argument_list|,
name|Integer
argument_list|>
operator|>
name|lambda
argument_list|(
name|Expressions
operator|.
name|field
argument_list|(
name|e
argument_list|,
literal|"empid"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
operator|.
name|toList
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|100
argument_list|,
literal|200
argument_list|,
literal|150
argument_list|,
literal|110
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a relation that is accessed via method syntax.    * The function returns a {@link org.apache.calcite.linq4j.Queryable}.    */
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testOperator
parameter_list|()
throws|throws
name|SQLException
throws|,
name|ClassNotFoundException
block|{
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|)
decl_stmt|;
name|CalciteConnection
name|calciteConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|calciteConnection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|SchemaPlus
name|schema
init|=
name|rootSchema
operator|.
name|add
argument_list|(
literal|"s"
argument_list|,
operator|new
name|AbstractSchema
argument_list|()
argument_list|)
decl_stmt|;
name|schema
operator|.
name|add
argument_list|(
literal|"GenerateStrings"
argument_list|,
name|TableMacroImpl
operator|.
name|create
argument_list|(
name|Smalls
operator|.
name|GENERATE_STRINGS_METHOD
argument_list|)
argument_list|)
expr_stmt|;
name|schema
operator|.
name|add
argument_list|(
literal|"StringUnion"
argument_list|,
name|TableMacroImpl
operator|.
name|create
argument_list|(
name|Smalls
operator|.
name|STRING_UNION_METHOD
argument_list|)
argument_list|)
expr_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|connection
operator|.
name|createStatement
argument_list|()
operator|.
name|executeQuery
argument_list|(
literal|"select *\n"
operator|+
literal|"from table(s.StringUnion(\n"
operator|+
literal|"  GenerateStrings(5),\n"
operator|+
literal|"  cursor (select name from emps)))\n"
operator|+
literal|"where char_length(s)> 3"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a view.    */
annotation|@
name|Test
name|void
name|testView
parameter_list|()
throws|throws
name|SQLException
throws|,
name|ClassNotFoundException
block|{
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|)
decl_stmt|;
name|CalciteConnection
name|calciteConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|calciteConnection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|SchemaPlus
name|schema
init|=
name|rootSchema
operator|.
name|add
argument_list|(
literal|"s"
argument_list|,
operator|new
name|AbstractSchema
argument_list|()
argument_list|)
decl_stmt|;
name|schema
operator|.
name|add
argument_list|(
literal|"emps_view"
argument_list|,
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|schema
argument_list|,
literal|"select * from \"hr\".\"emps\" where \"deptno\" = 10"
argument_list|,
literal|null
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"s"
argument_list|,
literal|"emps_view"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|connection
operator|.
name|createStatement
argument_list|()
operator|.
name|executeQuery
argument_list|(
literal|"select *\n"
operator|+
literal|"from \"s\".\"emps_view\"\n"
operator|+
literal|"where \"empid\"< 120"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"empid=100; deptno=10; name=Bill; salary=10000.0; commission=1000\n"
operator|+
literal|"empid=110; deptno=10; name=Theodore; salary=11500.0; commission=250\n"
argument_list|,
name|CalciteAssert
operator|.
name|toString
argument_list|(
name|resultSet
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests a view with a path.    */
annotation|@
name|Test
name|void
name|testViewPath
parameter_list|()
throws|throws
name|SQLException
throws|,
name|ClassNotFoundException
block|{
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|)
decl_stmt|;
name|CalciteConnection
name|calciteConnection
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|calciteConnection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|SchemaPlus
name|schema
init|=
name|rootSchema
operator|.
name|add
argument_list|(
literal|"s"
argument_list|,
operator|new
name|AbstractSchema
argument_list|()
argument_list|)
decl_stmt|;
comment|// create a view s.emps based on hr.emps. uses explicit schema path "hr".
name|schema
operator|.
name|add
argument_list|(
literal|"emps"
argument_list|,
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|schema
argument_list|,
literal|"select * from \"emps\" where \"deptno\" = 10"
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"hr"
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"s"
argument_list|,
literal|"emps"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|schema
operator|.
name|add
argument_list|(
literal|"hr_emps"
argument_list|,
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|schema
argument_list|,
literal|"select * from \"emps\""
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"hr"
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"s"
argument_list|,
literal|"hr_emps"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|schema
operator|.
name|add
argument_list|(
literal|"s_emps"
argument_list|,
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|schema
argument_list|,
literal|"select * from \"emps\""
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"s"
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"s"
argument_list|,
literal|"s_emps"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|schema
operator|.
name|add
argument_list|(
literal|"null_emps"
argument_list|,
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|schema
argument_list|,
literal|"select * from \"emps\""
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"s"
argument_list|,
literal|"null_emps"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|ResultSet
name|resultSet
decl_stmt|;
name|resultSet
operator|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"s\".\"hr_emps\""
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|count
argument_list|(
name|resultSet
argument_list|)
argument_list|)
expr_stmt|;
comment|// "hr_emps" -> "hr"."emps", 4 rows
name|resultSet
operator|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"s\".\"s_emps\""
argument_list|)
expr_stmt|;
comment|// "s_emps" -> "s"."emps", 3 rows
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|count
argument_list|(
name|resultSet
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"s\".\"null_emps\""
argument_list|)
expr_stmt|;
comment|// "null_emps" -> "s"."emps", 3
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|count
argument_list|(
name|resultSet
argument_list|)
argument_list|)
expr_stmt|;
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|private
name|int
name|count
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/** Tests column based on java.sql.Date field. */
annotation|@
name|Test
name|void
name|testDateColumn
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|DateColumnSchema
argument_list|()
argument_list|)
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"emps\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|""
operator|+
literal|"hireDate=1970-01-01; empid=10; deptno=20; name=fred; salary=0.0; commission=null\n"
operator|+
literal|"hireDate=1970-04-11; empid=10; deptno=20; name=bill; salary=0.0; commission=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests querying an object that has no public fields. */
annotation|@
name|Test
name|void
name|testNoPublicFields
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select 1 from \"s\".\"allPrivates\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"EXPR$0=1\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"x\" from \"s\".\"allPrivates\""
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Column 'x' not found in any table"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests columns based on types such as java.sql.Date and java.util.Date.    *    * @see CatchallSchema#everyTypes */
annotation|@
name|Test
name|void
name|testColumnTypes
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"primitiveBoolean\" from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"primitiveBoolean=false\n"
operator|+
literal|"primitiveBoolean=true\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|""
operator|+
literal|"primitiveBoolean=false; primitiveByte=0; primitiveChar=\u0000; primitiveShort=0; primitiveInt=0; primitiveLong=0; primitiveFloat=0.0; primitiveDouble=0.0; wrapperBoolean=false; wrapperByte=0; wrapperCharacter=\u0000; wrapperShort=0; wrapperInteger=0; wrapperLong=0; wrapperFloat=0.0; wrapperDouble=0.0; sqlDate=1970-01-01; sqlTime=00:00:00; sqlTimestamp=1970-01-01 00:00:00; utilDate=1970-01-01 00:00:00; string=1; bigDecimal=0\n"
operator|+
literal|"primitiveBoolean=true; primitiveByte=127; primitiveChar=\uffff; primitiveShort=32767; primitiveInt=2147483647; primitiveLong=9223372036854775807; primitiveFloat=3.4028235E38; primitiveDouble=1.7976931348623157E308; wrapperBoolean=null; wrapperByte=null; wrapperCharacter=null; wrapperShort=null; wrapperInteger=null; wrapperLong=null; wrapperFloat=null; wrapperDouble=null; sqlDate=null; sqlTime=null; sqlTimestamp=null; utilDate=null; string=null; bigDecimal=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests NOT for nullable columns.    *    * @see CatchallSchema#everyTypes */
annotation|@
name|Test
name|void
name|testWhereNOT
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"wrapperByte\" from \"s\".\"everyTypes\" where NOT (\"wrapperByte\" is null)"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"wrapperByte=0"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests NOT for nullable columns.    *    * @see CatchallSchema#everyTypes */
annotation|@
name|Test
name|void
name|testSelectNOT
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select NOT \"wrapperBoolean\" \"value\" from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"value=null"
argument_list|,
literal|"value=true"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2404">[CALCITE-2404]    * Accessing structured-types is not implemented by the runtime</a>. */
annotation|@
name|Test
name|void
name|testSelectWithFieldAccessOnFirstLevelRecordType
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|BOOKSTORE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select au.\"birthPlace\".\"city\" as city from \"bookstore\".\"authors\" au\n"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"CITY=Heraklion"
argument_list|,
literal|"CITY=BesanÃ§on"
argument_list|,
literal|"CITY=Ionia"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2404">[CALCITE-2404]    * Accessing structured-types is not implemented by the runtime</a>. */
annotation|@
name|Test
name|void
name|testSelectWithFieldAccessOnSecondLevelRecordType
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|BOOKSTORE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select au.\"birthPlace\".\"coords\".\"latitude\" as lat\n"
operator|+
literal|"from \"bookstore\".\"authors\" au\n"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"LAT=47.24"
argument_list|,
literal|"LAT=35.3387"
argument_list|,
literal|"LAT=null"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2404">[CALCITE-2404]    * Accessing structured-types is not implemented by the runtime</a>. */
annotation|@
name|Test
name|void
name|testWhereWithFieldAccessOnFirstLevelRecordType
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|BOOKSTORE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select au.\"aid\" as aid from \"bookstore\".\"authors\" au\n"
operator|+
literal|"where au.\"birthPlace\".\"city\"='Heraklion'"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"AID=2"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2404">[CALCITE-2404]    * Accessing structured-types is not implemented by the runtime</a>. */
annotation|@
name|Test
name|void
name|testWhereWithFieldAccessOnSecondLevelRecordType
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|BOOKSTORE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select au.\"aid\" as aid from \"bookstore\".\"authors\" au\n"
operator|+
literal|"where au.\"birthPlace\".\"coords\".\"latitude\"=35.3387"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"AID=2"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2404">[CALCITE-2404]    * Accessing structured-types is not implemented by the runtime</a>. */
annotation|@
name|Test
name|void
name|testSelectWithFieldAccessOnFirstLevelRecordTypeArray
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|BOOKSTORE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select au.\"books\"[1].\"title\" as title from \"bookstore\".\"authors\" au\n"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"TITLE=Les MisÃ©rables"
argument_list|,
literal|"TITLE=Zorba the Greek"
argument_list|,
literal|"TITLE=null"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2404">[CALCITE-2404]    * Accessing structured-types is not implemented by the runtime</a>. */
annotation|@
name|Test
name|void
name|testSelectWithFieldAccessOnSecondLevelRecordTypeArray
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|BOOKSTORE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select au.\"books\"[1].\"pages\"[1].\"pageNo\" as pno\n"
operator|+
literal|"from \"bookstore\".\"authors\" au\n"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"PNO=1"
argument_list|,
literal|"PNO=1"
argument_list|,
literal|"PNO=null"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2404">[CALCITE-2404]    * Accessing structured-types is not implemented by the runtime</a>. */
annotation|@
name|Test
name|void
name|testWhereWithFieldAccessOnFirstLevelRecordTypeArray
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|BOOKSTORE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select au.\"aid\" as aid from \"bookstore\".\"authors\" au\n"
operator|+
literal|"where au.\"books\"[1].\"title\"='Les MisÃ©rables'"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"AID=1"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2404">[CALCITE-2404]    * Accessing structured-types is not implemented by the runtime</a>. */
annotation|@
name|Test
name|void
name|testWhereWithFieldAccessOnSecondLevelRecordTypeArray
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|BOOKSTORE
argument_list|)
operator|.
name|query
argument_list|(
literal|"select au.\"aid\" as aid from \"bookstore\".\"authors\" au\n"
operator|+
literal|"where au.\"books\"[1].\"pages\"[2].\"contentType\"='Acknowledgements'"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"AID=2"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests columns based on types such as java.sql.Date and java.util.Date.    *    * @see CatchallSchema#everyTypes */
annotation|@
name|Test
name|void
name|testAggregateFunctions
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|checkAgg
argument_list|(
name|with
argument_list|,
literal|"min"
argument_list|)
expr_stmt|;
name|checkAgg
argument_list|(
name|with
argument_list|,
literal|"max"
argument_list|)
expr_stmt|;
name|checkAgg
argument_list|(
name|with
argument_list|,
literal|"avg"
argument_list|)
expr_stmt|;
name|checkAgg
argument_list|(
name|with
argument_list|,
literal|"count"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkAgg
parameter_list|(
name|CalciteAssert
operator|.
name|AssertThat
name|with
parameter_list|,
name|String
name|fn
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Field
name|field
range|:
name|fn
operator|.
name|equals
argument_list|(
literal|"avg"
argument_list|)
condition|?
name|EveryType
operator|.
name|numericFields
argument_list|()
else|:
name|EveryType
operator|.
name|fields
argument_list|()
control|)
block|{
name|with
operator|.
name|query
argument_list|(
literal|"select "
operator|+
name|fn
operator|+
literal|"(\""
operator|+
name|field
operator|.
name|getName
argument_list|()
operator|+
literal|"\") as c\n"
operator|+
literal|"from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|returns
argument_list|(
name|input
lambda|->
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
try|try
block|{
while|while
condition|(
name|input
operator|.
name|next
argument_list|()
condition|)
block|{
specifier|final
name|Object
name|o
init|=
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|o
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|assertThat
argument_list|(
name|n
argument_list|,
name|equalTo
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Object
name|get
parameter_list|(
name|ResultSet
name|input
parameter_list|)
throws|throws
name|SQLException
block|{
specifier|final
name|int
name|type
init|=
name|input
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumnType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|BOOLEAN
case|:
return|return
name|input
operator|.
name|getBoolean
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TINYINT
case|:
return|return
name|input
operator|.
name|getByte
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|SMALLINT
case|:
return|return
name|input
operator|.
name|getShort
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|INTEGER
case|:
return|return
name|input
operator|.
name|getInt
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|BIGINT
case|:
return|return
name|input
operator|.
name|getLong
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|REAL
case|:
return|return
name|input
operator|.
name|getFloat
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DOUBLE
case|:
return|return
name|input
operator|.
name|getDouble
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|CHAR
case|:
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|VARCHAR
case|:
return|return
name|input
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DATE
case|:
return|return
name|input
operator|.
name|getDate
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIME
case|:
return|return
name|input
operator|.
name|getTime
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|TIMESTAMP
case|:
return|return
name|input
operator|.
name|getTimestamp
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|java
operator|.
name|sql
operator|.
name|Types
operator|.
name|DECIMAL
case|:
return|return
name|input
operator|.
name|getBigDecimal
argument_list|(
literal|1
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|type
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Test
name|void
name|testClassNames
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|returns
argument_list|(
name|resultSet
lambda|->
block|{
try|try
block|{
specifier|final
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"primitiveBoolean"
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"primitiveByte"
argument_list|,
name|Byte
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"primitiveChar"
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"primitiveShort"
argument_list|,
name|Short
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"primitiveInt"
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"primitiveLong"
argument_list|,
name|Long
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"primitiveFloat"
argument_list|,
name|Float
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"primitiveDouble"
argument_list|,
name|Double
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"wrapperBoolean"
argument_list|,
name|Boolean
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"wrapperByte"
argument_list|,
name|Byte
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"wrapperCharacter"
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"wrapperShort"
argument_list|,
name|Short
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"wrapperInteger"
argument_list|,
name|Integer
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"wrapperLong"
argument_list|,
name|Long
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"wrapperFloat"
argument_list|,
name|Float
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"wrapperDouble"
argument_list|,
name|Double
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"sqlDate"
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"sqlTime"
argument_list|,
name|Time
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"sqlTimestamp"
argument_list|,
name|Timestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"utilDate"
argument_list|,
name|Timestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|metaData
argument_list|,
literal|"string"
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|check
parameter_list|(
name|ResultSetMetaData
name|metaData
parameter_list|,
name|String
name|columnName
parameter_list|,
name|Class
name|expectedType
parameter_list|)
throws|throws
name|SQLException
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|metaData
operator|.
name|getColumnCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|metaData
operator|.
name|getColumnName
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnClassName
argument_list|(
name|i
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|expectedType
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fail
argument_list|(
literal|"column not found: "
operator|+
name|columnName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testJavaBoolean
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"primitiveBoolean\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=1\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"wrapperBoolean\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=0\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"wrapperBoolean\" is true"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=0\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"wrapperBoolean\" is not true"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=2\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"wrapperBoolean\" is false"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=1\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"wrapperBoolean\" is not false"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=1\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"wrapperBoolean\" is null"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=1\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"wrapperBoolean\" is not null"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=1\n"
argument_list|)
expr_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select count(*) as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"primitiveInt\"> 0"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=1\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-119">[CALCITE-119]    * Comparing a Java type long with a SQL type INTEGER gives wrong    * answer</a>. */
annotation|@
name|Test
name|void
name|testCompareJavaAndSqlTypes
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
comment|// With CALCITE-119, returned 0 rows. The problem was that when comparing
comment|// a Java type (long) and a SQL type (INTEGER), the SQL type was deemed
comment|// "less restrictive". So, the long value got truncated to an int value.
name|with
operator|.
name|query
argument_list|(
literal|"select \"primitiveLong\" as c from \"s\".\"everyTypes\"\n"
operator|+
literal|"where \"primitiveLong\"> 0"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=9223372036854775807\n"
argument_list|)
expr_stmt|;
comment|// count(nullif(b, false)) counts how many times b is true
name|with
operator|.
name|query
argument_list|(
literal|"select count(\"primitiveBoolean\") as p,\n"
operator|+
literal|"  count(\"wrapperBoolean\") as w,\n"
operator|+
literal|"  count(nullif(\"primitiveShort\">= 0, false)) as sp,\n"
operator|+
literal|"  count(nullif(\"wrapperShort\">= 0, false)) as sw,\n"
operator|+
literal|"  count(nullif(\"primitiveInt\">= 0, false)) as ip,\n"
operator|+
literal|"  count(nullif(\"wrapperInteger\">= 0, false)) as iw,\n"
operator|+
literal|"  count(nullif(\"primitiveLong\">= 0, false)) as lp,\n"
operator|+
literal|"  count(nullif(\"wrapperLong\">= 0, false)) as lw\n"
operator|+
literal|"from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"P=2; W=1; SP=2; SW=1; IP=2; IW=1; LP=2; LW=1\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDivideWraperPrimitive
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"wrapperLong\" / \"primitiveLong\" as c\n"
operator|+
literal|" from \"s\".\"everyTypes\" where \"primitiveLong\"<> 0"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"final Long input_value = current.wrapperLong;"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"return input_value == null ? (Long) null : Long.valueOf(input_value.longValue() / current.primitiveLong);"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=null\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDivideDoubleBigDecimal
parameter_list|()
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"wrapperDouble\" / \"bigDecimal\" as c\n"
operator|+
literal|" from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|runs
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDivideWraperWrapper
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"wrapperLong\" / \"wrapperLong\" as c\n"
operator|+
literal|" from \"s\".\"everyTypes\" where \"primitiveLong\"<> 0"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"final Long input_value = ((org.apache.calcite.test.ReflectiveSchemaTest.EveryType) inputEnumerator.current()).wrapperLong;"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"return input_value == null ? (Long) null : Long.valueOf(input_value.longValue() / input_value.longValue());"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=null\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDivideWraperWrapperMultipleTimes
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select \"wrapperLong\" / \"wrapperLong\"\n"
operator|+
literal|"+ \"wrapperLong\" / \"wrapperLong\" as c\n"
operator|+
literal|" from \"s\".\"everyTypes\" where \"primitiveLong\"<> 0"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"final Long input_value = ((org.apache.calcite.test.ReflectiveSchemaTest.EveryType) inputEnumerator.current()).wrapperLong;"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"final Long binary_call_value = input_value == null ? (Long) null : Long.valueOf(input_value.longValue() / input_value.longValue());"
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"return binary_call_value == null ? (Long) null : Long.valueOf(binary_call_value.longValue() + binary_call_value.longValue());"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=null\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testOp
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|checkOp
argument_list|(
name|with
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|checkOp
argument_list|(
name|with
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|checkOp
argument_list|(
name|with
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|checkOp
argument_list|(
name|with
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkOp
parameter_list|(
name|CalciteAssert
operator|.
name|AssertThat
name|with
parameter_list|,
name|String
name|fn
parameter_list|)
block|{
for|for
control|(
name|Field
name|field
range|:
name|EveryType
operator|.
name|numericFields
argument_list|()
control|)
block|{
for|for
control|(
name|Field
name|field2
range|:
name|EveryType
operator|.
name|numericFields
argument_list|()
control|)
block|{
specifier|final
name|String
name|name
init|=
literal|"\""
operator|+
name|field
operator|.
name|getName
argument_list|()
operator|+
literal|"\""
decl_stmt|;
specifier|final
name|String
name|name2
init|=
literal|"\""
operator|+
name|field2
operator|.
name|getName
argument_list|()
operator|+
literal|"\""
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select "
operator|+
name|name
operator|+
literal|"\n"
operator|+
literal|" "
operator|+
name|fn
operator|+
literal|" "
operator|+
name|name2
operator|+
literal|" as c\n"
operator|+
literal|"from \"s\".\"everyTypes\"\n"
operator|+
literal|"where "
operator|+
name|name
operator|+
literal|"<> 0"
argument_list|)
operator|.
name|returns
argument_list|(
name|resultSet
lambda|->
block|{
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
name|void
name|testCastFromString
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select cast(\"string\" as int) as c from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"C=1\n"
operator|+
literal|"C=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-580">[CALCITE-580]    * Average aggregation on an Integer column throws ClassCastException</a>. */
annotation|@
name|Test
name|void
name|testAvgInt
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|with
argument_list|(
name|Lex
operator|.
name|JAVA
argument_list|)
operator|.
name|query
argument_list|(
literal|"select primitiveLong, avg(primitiveInt)\n"
operator|+
literal|"from s.everyTypes\n"
operator|+
literal|"group by primitiveLong order by primitiveLong"
argument_list|)
operator|.
name|returns
argument_list|(
name|input
lambda|->
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|input
operator|.
name|next
argument_list|()
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|input
operator|.
name|getInt
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|assertThat
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|"0\n2147483647\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isNumeric
parameter_list|(
name|Class
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|Primitive
operator|.
name|flavor
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|BOX
case|:
return|return
name|Primitive
operator|.
name|ofBox
argument_list|(
name|type
argument_list|)
operator|.
name|isNumeric
argument_list|()
return|;
case|case
name|PRIMITIVE
case|:
return|return
name|Primitive
operator|.
name|of
argument_list|(
name|type
argument_list|)
operator|.
name|isNumeric
argument_list|()
return|;
default|default:
return|return
name|Number
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
return|;
comment|// e.g. BigDecimal
block|}
block|}
comment|/** Tests that if a field of a relation has an unrecognized type (in this    * case a {@link BitSet}) then it is treated as an object.    *    * @see CatchallSchema#badTypes */
annotation|@
name|Test
name|void
name|testTableFieldHasBadType
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"badTypes\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"integer=0; bitSet={}\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a schema with a field whose type cannot be recognized    * throws an informative exception.    *    * @see CatchallSchema#enumerable    * @see CatchallSchema#list */
annotation|@
name|Test
name|void
name|testSchemaFieldHasBadType
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
comment|// BitSet is not a valid relation type. It's as if "bitSet" field does
comment|// not exist.
name|with
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"bitSet\""
argument_list|)
operator|.
name|throws_
argument_list|(
literal|"Object 'bitSet' not found within 's'"
argument_list|)
expr_stmt|;
comment|// Enumerable field returns 3 records with 0 fields
name|with
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"enumerable\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
comment|// List is implicitly converted to Enumerable
name|with
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"list\""
argument_list|)
operator|.
name|returns
argument_list|(
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for a bug where a Java string 'Abc' compared to a char 'Ab'    * would be truncated to the char precision and falsely match. */
annotation|@
name|Test
name|void
name|testPrefix
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"prefixEmps\" where \"name\" in ('Ab', 'Abd')"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=2; deptno=10; name=Ab; salary=0.0; commission=null\n"
operator|+
literal|"empid=4; deptno=10; name=Abd; salary=0.0; commission=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** If a method returns a    * {@link ViewTable}.{@code ViewTableMacro}, then it    * should be expanded. */
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testTableMacroIsView
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from table(\"s\".\"view\"('abc'))"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=2; deptno=10; name=Ab; salary=0.0; commission=null\n"
operator|+
literal|"empid=4; deptno=10; name=Abd; salary=0.0; commission=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Finds a table-macro using reflection. */
annotation|@
name|Disabled
annotation|@
name|Test
name|void
name|testTableMacro
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from table(\"s\".\"foo\"(3))"
argument_list|)
operator|.
name|returns
argument_list|(
literal|"empid=2; deptno=10; name=Ab; salary=0.0; commission=null\n"
operator|+
literal|"empid=4; deptno=10; name=Abd; salary=0.0; commission=null\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Table with single field as Integer[]. */
annotation|@
name|Disabled
argument_list|(
literal|"java.lang.AssertionError RelDataTypeImpl.getFieldList(RelDataTypeImpl.java:99)"
argument_list|)
annotation|@
name|Test
name|void
name|testArrayOfBoxedPrimitives
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"primesBoxed\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"value=1"
argument_list|,
literal|"value=3"
argument_list|,
literal|"value=7"
argument_list|)
expr_stmt|;
block|}
comment|/** Table with single field as int[]. */
annotation|@
name|Disabled
argument_list|(
literal|"java.lang.AssertionError RelDataTypeImpl.getFieldList(RelDataTypeImpl.java:99)"
argument_list|)
annotation|@
name|Test
name|void
name|testArrayOfPrimitives
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select * from \"s\".\"primes\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"value=1"
argument_list|,
literal|"value=3"
argument_list|,
literal|"value=7"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testCustomBoxedScalar
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"value\" from \"s\".\"primesCustomBoxed\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"value=1"
argument_list|,
literal|"value=3"
argument_list|,
literal|"value=5"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testCustomBoxedSalarCalc
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select \"value\"*2 \"value\" from \"s\".\"primesCustomBoxed\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"value=2"
argument_list|,
literal|"value=6"
argument_list|,
literal|"value=10"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1569">[CALCITE-1569]    * Date condition can generates Integer == Integer, which is always    * false</a>. */
annotation|@
name|Test
name|void
name|testDateCanCompare
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.v\n"
operator|+
literal|"from (select \"sqlDate\" v\n"
operator|+
literal|"  from \"s\".\"everyTypes\" "
operator|+
literal|"  group by \"sqlDate\") a,"
operator|+
literal|"    (select \"sqlDate\" v\n"
operator|+
literal|"  from \"s\".\"everyTypes\"\n"
operator|+
literal|"  group by \"sqlDate\") b\n"
operator|+
literal|"where a.v>= b.v\n"
operator|+
literal|"group by a.v"
decl_stmt|;
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
name|sql
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"V=1970-01-01"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3512">[CALCITE-3512]    * Query fails when comparing Time/TimeStamp types</a>. */
annotation|@
name|Test
name|void
name|testTimeCanCompare
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.v\n"
operator|+
literal|"from (select \"sqlTime\" v\n"
operator|+
literal|"  from \"s\".\"everyTypes\" "
operator|+
literal|"  group by \"sqlTime\") a,"
operator|+
literal|"    (select \"sqlTime\" v\n"
operator|+
literal|"  from \"s\".\"everyTypes\"\n"
operator|+
literal|"  group by \"sqlTime\") b\n"
operator|+
literal|"where a.v>= b.v\n"
operator|+
literal|"group by a.v"
decl_stmt|;
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
name|sql
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"V=00:00:00"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testTimestampCanCompare
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.v\n"
operator|+
literal|"from (select \"sqlTimestamp\" v\n"
operator|+
literal|"  from \"s\".\"everyTypes\" "
operator|+
literal|"  group by \"sqlTimestamp\") a,"
operator|+
literal|"    (select \"sqlTimestamp\" v\n"
operator|+
literal|"  from \"s\".\"everyTypes\"\n"
operator|+
literal|"  group by \"sqlTimestamp\") b\n"
operator|+
literal|"where a.v>= b.v\n"
operator|+
literal|"group by a.v"
decl_stmt|;
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
name|sql
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"V=1970-01-01 00:00:00"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1919">[CALCITE-1919]    * NPE when target in ReflectiveSchema belongs to the unnamed package</a>. */
annotation|@
name|Test
name|void
name|testReflectiveSchemaInUnnamedPackage
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Driver
name|driver
init|=
operator|new
name|Driver
argument_list|()
decl_stmt|;
try|try
init|(
name|CalciteConnection
name|connection
init|=
operator|(
name|CalciteConnection
operator|)
name|driver
operator|.
name|connect
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
operator|new
name|Properties
argument_list|()
argument_list|)
init|)
block|{
name|SchemaPlus
name|rootSchema
init|=
name|connection
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|Class
operator|.
name|forName
argument_list|(
literal|"RootHr"
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|o
init|=
name|c
operator|.
name|getDeclaredConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|setSchema
argument_list|(
literal|"hr"
argument_list|)
expr_stmt|;
specifier|final
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from \"emps\""
decl_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"empid=100; name=Bill\n"
operator|+
literal|"empid=200; name=Eric\n"
operator|+
literal|"empid=150; name=Sebastian\n"
decl_stmt|;
name|assertThat
argument_list|(
name|CalciteAssert
operator|.
name|toString
argument_list|(
name|resultSet
argument_list|)
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Extension to {@link Employee} with a {@code hireDate} column. */
specifier|public
specifier|static
class|class
name|EmployeeWithHireDate
extends|extends
name|Employee
block|{
specifier|public
specifier|final
name|java
operator|.
name|sql
operator|.
name|Date
name|hireDate
decl_stmt|;
specifier|public
name|EmployeeWithHireDate
parameter_list|(
name|int
name|empid
parameter_list|,
name|int
name|deptno
parameter_list|,
name|String
name|name
parameter_list|,
name|float
name|salary
parameter_list|,
name|Integer
name|commission
parameter_list|,
name|java
operator|.
name|sql
operator|.
name|Date
name|hireDate
parameter_list|)
block|{
name|super
argument_list|(
name|empid
argument_list|,
name|deptno
argument_list|,
name|name
argument_list|,
name|salary
argument_list|,
name|commission
argument_list|)
expr_stmt|;
name|this
operator|.
name|hireDate
operator|=
name|hireDate
expr_stmt|;
block|}
block|}
comment|/** Record that has a field of every interesting type. */
specifier|public
specifier|static
class|class
name|EveryType
block|{
specifier|public
specifier|final
name|boolean
name|primitiveBoolean
decl_stmt|;
specifier|public
specifier|final
name|byte
name|primitiveByte
decl_stmt|;
specifier|public
specifier|final
name|char
name|primitiveChar
decl_stmt|;
specifier|public
specifier|final
name|short
name|primitiveShort
decl_stmt|;
specifier|public
specifier|final
name|int
name|primitiveInt
decl_stmt|;
specifier|public
specifier|final
name|long
name|primitiveLong
decl_stmt|;
specifier|public
specifier|final
name|float
name|primitiveFloat
decl_stmt|;
specifier|public
specifier|final
name|double
name|primitiveDouble
decl_stmt|;
specifier|public
specifier|final
name|Boolean
name|wrapperBoolean
decl_stmt|;
specifier|public
specifier|final
name|Byte
name|wrapperByte
decl_stmt|;
specifier|public
specifier|final
name|Character
name|wrapperCharacter
decl_stmt|;
specifier|public
specifier|final
name|Short
name|wrapperShort
decl_stmt|;
specifier|public
specifier|final
name|Integer
name|wrapperInteger
decl_stmt|;
specifier|public
specifier|final
name|Long
name|wrapperLong
decl_stmt|;
specifier|public
specifier|final
name|Float
name|wrapperFloat
decl_stmt|;
specifier|public
specifier|final
name|Double
name|wrapperDouble
decl_stmt|;
specifier|public
specifier|final
name|java
operator|.
name|sql
operator|.
name|Date
name|sqlDate
decl_stmt|;
specifier|public
specifier|final
name|Time
name|sqlTime
decl_stmt|;
specifier|public
specifier|final
name|Timestamp
name|sqlTimestamp
decl_stmt|;
specifier|public
specifier|final
name|Date
name|utilDate
decl_stmt|;
specifier|public
specifier|final
name|String
name|string
decl_stmt|;
specifier|public
specifier|final
name|BigDecimal
name|bigDecimal
decl_stmt|;
specifier|public
name|EveryType
parameter_list|(
name|boolean
name|primitiveBoolean
parameter_list|,
name|byte
name|primitiveByte
parameter_list|,
name|char
name|primitiveChar
parameter_list|,
name|short
name|primitiveShort
parameter_list|,
name|int
name|primitiveInt
parameter_list|,
name|long
name|primitiveLong
parameter_list|,
name|float
name|primitiveFloat
parameter_list|,
name|double
name|primitiveDouble
parameter_list|,
name|Boolean
name|wrapperBoolean
parameter_list|,
name|Byte
name|wrapperByte
parameter_list|,
name|Character
name|wrapperCharacter
parameter_list|,
name|Short
name|wrapperShort
parameter_list|,
name|Integer
name|wrapperInteger
parameter_list|,
name|Long
name|wrapperLong
parameter_list|,
name|Float
name|wrapperFloat
parameter_list|,
name|Double
name|wrapperDouble
parameter_list|,
name|java
operator|.
name|sql
operator|.
name|Date
name|sqlDate
parameter_list|,
name|Time
name|sqlTime
parameter_list|,
name|Timestamp
name|sqlTimestamp
parameter_list|,
name|Date
name|utilDate
parameter_list|,
name|String
name|string
parameter_list|,
name|BigDecimal
name|bigDecimal
parameter_list|)
block|{
name|this
operator|.
name|primitiveBoolean
operator|=
name|primitiveBoolean
expr_stmt|;
name|this
operator|.
name|primitiveByte
operator|=
name|primitiveByte
expr_stmt|;
name|this
operator|.
name|primitiveChar
operator|=
name|primitiveChar
expr_stmt|;
name|this
operator|.
name|primitiveShort
operator|=
name|primitiveShort
expr_stmt|;
name|this
operator|.
name|primitiveInt
operator|=
name|primitiveInt
expr_stmt|;
name|this
operator|.
name|primitiveLong
operator|=
name|primitiveLong
expr_stmt|;
name|this
operator|.
name|primitiveFloat
operator|=
name|primitiveFloat
expr_stmt|;
name|this
operator|.
name|primitiveDouble
operator|=
name|primitiveDouble
expr_stmt|;
name|this
operator|.
name|wrapperBoolean
operator|=
name|wrapperBoolean
expr_stmt|;
name|this
operator|.
name|wrapperByte
operator|=
name|wrapperByte
expr_stmt|;
name|this
operator|.
name|wrapperCharacter
operator|=
name|wrapperCharacter
expr_stmt|;
name|this
operator|.
name|wrapperShort
operator|=
name|wrapperShort
expr_stmt|;
name|this
operator|.
name|wrapperInteger
operator|=
name|wrapperInteger
expr_stmt|;
name|this
operator|.
name|wrapperLong
operator|=
name|wrapperLong
expr_stmt|;
name|this
operator|.
name|wrapperFloat
operator|=
name|wrapperFloat
expr_stmt|;
name|this
operator|.
name|wrapperDouble
operator|=
name|wrapperDouble
expr_stmt|;
name|this
operator|.
name|sqlDate
operator|=
name|sqlDate
expr_stmt|;
name|this
operator|.
name|sqlTime
operator|=
name|sqlTime
expr_stmt|;
name|this
operator|.
name|sqlTimestamp
operator|=
name|sqlTimestamp
expr_stmt|;
name|this
operator|.
name|utilDate
operator|=
name|utilDate
expr_stmt|;
name|this
operator|.
name|string
operator|=
name|string
expr_stmt|;
name|this
operator|.
name|bigDecimal
operator|=
name|bigDecimal
expr_stmt|;
block|}
specifier|static
name|Enumerable
argument_list|<
name|Field
argument_list|>
name|fields
parameter_list|()
block|{
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|EveryType
operator|.
name|class
operator|.
name|getFields
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|Enumerable
argument_list|<
name|Field
argument_list|>
name|numericFields
parameter_list|()
block|{
return|return
name|fields
argument_list|()
operator|.
name|where
argument_list|(
name|v1
lambda|->
name|isNumeric
argument_list|(
name|v1
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** All field are private, therefore the resulting record has no fields. */
specifier|public
specifier|static
class|class
name|AllPrivate
block|{
specifier|private
specifier|final
name|int
name|x
init|=
literal|0
decl_stmt|;
block|}
comment|/** Table that has a field that cannot be recognized as a SQL type. */
specifier|public
specifier|static
class|class
name|BadType
block|{
specifier|public
specifier|final
name|int
name|integer
init|=
literal|0
decl_stmt|;
specifier|public
specifier|final
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|(
literal|0
argument_list|)
decl_stmt|;
block|}
comment|/** Table that has integer and string fields. */
specifier|public
specifier|static
class|class
name|IntAndString
block|{
specifier|public
specifier|final
name|int
name|id
decl_stmt|;
specifier|public
specifier|final
name|String
name|value
decl_stmt|;
specifier|public
name|IntAndString
parameter_list|(
name|int
name|id
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|/** Object whose fields are relations. Called "catch-all" because it's OK    * if tests add new fields. */
specifier|public
specifier|static
class|class
name|CatchallSchema
block|{
specifier|public
specifier|final
name|Enumerable
argument_list|<
name|Employee
argument_list|>
name|enumerable
init|=
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
operator|.
name|emps
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|final
name|List
argument_list|<
name|Employee
argument_list|>
name|list
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
operator|.
name|emps
argument_list|)
decl_stmt|;
specifier|public
specifier|final
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|public
specifier|final
name|EveryType
index|[]
name|everyTypes
init|=
block|{
operator|new
name|EveryType
argument_list|(
literal|false
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0L
argument_list|,
literal|0F
argument_list|,
literal|0D
argument_list|,
literal|false
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0L
argument_list|,
literal|0F
argument_list|,
literal|0D
argument_list|,
operator|new
name|java
operator|.
name|sql
operator|.
name|Date
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|Time
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|Timestamp
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|Date
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"1"
argument_list|,
name|BigDecimal
operator|.
name|ZERO
argument_list|)
block|,
operator|new
name|EveryType
argument_list|(
literal|true
argument_list|,
name|Byte
operator|.
name|MAX_VALUE
argument_list|,
name|Character
operator|.
name|MAX_VALUE
argument_list|,
name|Short
operator|.
name|MAX_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|,
name|Float
operator|.
name|MAX_VALUE
argument_list|,
name|Double
operator|.
name|MAX_VALUE
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|,     }
decl_stmt|;
specifier|public
specifier|final
name|AllPrivate
index|[]
name|allPrivates
init|=
block|{
operator|new
name|AllPrivate
argument_list|()
block|}
decl_stmt|;
specifier|public
specifier|final
name|BadType
index|[]
name|badTypes
init|=
block|{
operator|new
name|BadType
argument_list|()
block|}
decl_stmt|;
specifier|public
specifier|final
name|Employee
index|[]
name|prefixEmps
init|=
block|{
operator|new
name|Employee
argument_list|(
literal|1
argument_list|,
literal|10
argument_list|,
literal|"A"
argument_list|,
literal|0f
argument_list|,
literal|null
argument_list|)
block|,
operator|new
name|Employee
argument_list|(
literal|2
argument_list|,
literal|10
argument_list|,
literal|"Ab"
argument_list|,
literal|0f
argument_list|,
literal|null
argument_list|)
block|,
operator|new
name|Employee
argument_list|(
literal|3
argument_list|,
literal|10
argument_list|,
literal|"Abc"
argument_list|,
literal|0f
argument_list|,
literal|null
argument_list|)
block|,
operator|new
name|Employee
argument_list|(
literal|4
argument_list|,
literal|10
argument_list|,
literal|"Abd"
argument_list|,
literal|0f
argument_list|,
literal|null
argument_list|)
block|,     }
decl_stmt|;
specifier|public
specifier|final
name|Integer
index|[]
name|primesBoxed
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|}
decl_stmt|;
specifier|public
specifier|final
name|int
index|[]
name|primes
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|}
decl_stmt|;
specifier|public
specifier|final
name|IntHolder
index|[]
name|primesCustomBoxed
init|=
block|{
operator|new
name|IntHolder
argument_list|(
literal|1
argument_list|)
block|,
operator|new
name|IntHolder
argument_list|(
literal|3
argument_list|)
block|,
operator|new
name|IntHolder
argument_list|(
literal|5
argument_list|)
block|}
decl_stmt|;
specifier|public
specifier|final
name|IntAndString
index|[]
name|nullables
init|=
block|{
operator|new
name|IntAndString
argument_list|(
literal|1
argument_list|,
literal|"A"
argument_list|)
block|,
operator|new
name|IntAndString
argument_list|(
literal|2
argument_list|,
literal|"B"
argument_list|)
block|,
operator|new
name|IntAndString
argument_list|(
literal|2
argument_list|,
literal|"C"
argument_list|)
block|,
operator|new
name|IntAndString
argument_list|(
literal|3
argument_list|,
literal|null
argument_list|)
block|}
decl_stmt|;
specifier|public
specifier|final
name|IntAndString
index|[]
name|bools
init|=
block|{
operator|new
name|IntAndString
argument_list|(
literal|1
argument_list|,
literal|"T"
argument_list|)
block|,
operator|new
name|IntAndString
argument_list|(
literal|2
argument_list|,
literal|"F"
argument_list|)
block|,
operator|new
name|IntAndString
argument_list|(
literal|3
argument_list|,
literal|null
argument_list|)
block|}
decl_stmt|;
block|}
comment|/**    * Custom java class that holds just a single field.    */
specifier|public
specifier|static
class|class
name|IntHolder
block|{
specifier|public
specifier|final
name|int
name|value
decl_stmt|;
specifier|public
name|IntHolder
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|/** Schema that contains a table with a date column. */
specifier|public
specifier|static
class|class
name|DateColumnSchema
block|{
specifier|public
specifier|final
name|EmployeeWithHireDate
index|[]
name|emps
init|=
block|{
operator|new
name|EmployeeWithHireDate
argument_list|(
literal|10
argument_list|,
literal|20
argument_list|,
literal|"fred"
argument_list|,
literal|0f
argument_list|,
literal|null
argument_list|,
operator|new
name|java
operator|.
name|sql
operator|.
name|Date
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
comment|// 1970-1-1
operator|new
name|EmployeeWithHireDate
argument_list|(
literal|10
argument_list|,
literal|20
argument_list|,
literal|"bill"
argument_list|,
literal|0f
argument_list|,
literal|null
argument_list|,
operator|new
name|java
operator|.
name|sql
operator|.
name|Date
argument_list|(
literal|100
operator|*
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
argument_list|)
argument_list|)
comment|// 1970-04-11
block|}
decl_stmt|;
block|}
comment|/** Tests    *<a href="https://issues.apache.org/jira/browse/CALCITE-2611">[CALCITE-2611]    * UNKNOWN on one side of an OR may lead to uncompilable code</a>. */
annotation|@
name|Test
name|void
name|testUnknownInOr
parameter_list|()
block|{
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
operator|.
name|query
argument_list|(
literal|"select (\"value\" = 3 and unknown) or ( \"value\"  = 3 ) "
operator|+
literal|"from \"s\".\"primesCustomBoxed\""
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"EXPR$0=false\nEXPR$0=false\nEXPR$0=true"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDecimalNegate
parameter_list|()
block|{
specifier|final
name|CalciteAssert
operator|.
name|AssertThat
name|with
init|=
name|CalciteAssert
operator|.
name|that
argument_list|()
operator|.
name|withSchema
argument_list|(
literal|"s"
argument_list|,
name|CATCHALL
argument_list|)
decl_stmt|;
name|with
operator|.
name|query
argument_list|(
literal|"select - \"bigDecimal\" from \"s\".\"everyTypes\""
argument_list|)
operator|.
name|planContains
argument_list|(
literal|"negate()"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"EXPR$0=0"
argument_list|,
literal|"EXPR$0=null"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

