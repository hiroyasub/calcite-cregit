begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|DataContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|clone
operator|.
name|CloneSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|ReflectiveSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|Lex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteMetaImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|materialize
operator|.
name|Lattice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|FlatLists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|AbstractSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|ViewTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Closer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|JsonBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Functions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultiset
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|UncheckedExecutionException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|foodmart
operator|.
name|data
operator|.
name|hsqldb
operator|.
name|FoodmartHsqldb
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|scott
operator|.
name|data
operator|.
name|hsqldb
operator|.
name|ScottHsqldb
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DriverManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|sql
operator|.
name|DataSource
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|containsString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Fluid DSL for testing Calcite connections and queries.  */
end_comment

begin_class
specifier|public
class|class
name|CalciteAssert
block|{
specifier|private
name|CalciteAssert
parameter_list|()
block|{
block|}
comment|/** Which database to use for tests that require a JDBC data source. By    * default the test suite runs against the embedded hsqldb database.    *    *<p>We recommend that casual users use hsqldb, and frequent Calcite    * developers use MySQL. The test suite runs faster against the MySQL database    * (mainly because of the 0.1s versus 6s startup time). You have to populate    * MySQL manually with the foodmart data set, otherwise there will be test    * failures.  To run against MySQL, specify '-Dcalcite.test.db=mysql' on the    * java command line. */
specifier|public
specifier|static
specifier|final
name|DatabaseInstance
name|DB
init|=
name|DatabaseInstance
operator|.
name|valueOf
argument_list|(
name|Util
operator|.
name|first
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"calcite.test.db"
argument_list|)
argument_list|,
literal|"HSQLDB"
argument_list|)
operator|.
name|toUpperCase
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Whether to enable slow tests. Default is false. */
specifier|public
specifier|static
specifier|final
name|boolean
name|ENABLE_SLOW
init|=
name|Util
operator|.
name|getBooleanProperty
argument_list|(
literal|"calcite.test.slow"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|DateFormat
name|UTC_DATE_FORMAT
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|DateFormat
name|UTC_TIME_FORMAT
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|DateFormat
name|UTC_TIMESTAMP_FORMAT
decl_stmt|;
static|static
block|{
specifier|final
name|TimeZone
name|utc
init|=
name|DateTimeUtils
operator|.
name|GMT_ZONE
decl_stmt|;
name|UTC_DATE_FORMAT
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd"
argument_list|)
expr_stmt|;
name|UTC_DATE_FORMAT
operator|.
name|setTimeZone
argument_list|(
name|utc
argument_list|)
expr_stmt|;
name|UTC_TIME_FORMAT
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"HH:mm:ss"
argument_list|)
expr_stmt|;
name|UTC_TIME_FORMAT
operator|.
name|setTimeZone
argument_list|(
name|utc
argument_list|)
expr_stmt|;
name|UTC_TIMESTAMP_FORMAT
operator|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd'T'HH:mm:ss'Z'"
argument_list|)
expr_stmt|;
name|UTC_TIMESTAMP_FORMAT
operator|.
name|setTimeZone
argument_list|(
name|utc
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
specifier|final
name|ConnectionFactory
name|EMPTY_CONNECTION_FACTORY
init|=
operator|new
name|MapConnectionFactory
argument_list|(
name|ImmutableMap
operator|.
expr|<
name|String
argument_list|,
name|String
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
expr|<
name|ConnectionPostProcessor
operator|>
name|of
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Implementation of {@link AssertThat} that does nothing. */
specifier|private
specifier|static
specifier|final
name|AssertThat
name|DISABLED
init|=
operator|new
name|AssertThat
argument_list|(
name|EMPTY_CONNECTION_FACTORY
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|AssertThat
name|with
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|with
parameter_list|(
name|ConnectionFactory
name|connectionFactory
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|with
parameter_list|(
name|String
name|property
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|withSchema
parameter_list|(
name|String
name|name
parameter_list|,
name|Schema
name|schema
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|query
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
return|return
name|NopAssertQuery
operator|.
name|of
argument_list|(
name|sql
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|connectThrows
parameter_list|(
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Void
argument_list|>
name|exceptionChecker
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|AssertThat
name|doWithConnection
parameter_list|(
name|Function
argument_list|<
name|CalciteConnection
argument_list|,
name|T
argument_list|>
name|fn
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|withDefaultSchema
parameter_list|(
name|String
name|schema
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|with
parameter_list|(
name|SchemaSpec
modifier|...
name|specs
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|with
parameter_list|(
name|Lex
name|lex
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|with
parameter_list|(
name|ConnectionPostProcessor
name|postProcessor
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|enable
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertThat
name|pooled
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
decl_stmt|;
comment|/** Creates an instance of {@code CalciteAssert} with the empty    * configuration. */
specifier|public
specifier|static
name|AssertThat
name|that
parameter_list|()
block|{
return|return
name|AssertThat
operator|.
name|EMPTY
return|;
block|}
comment|/** Creates an instance of {@code CalciteAssert} with a given    * configuration. */
specifier|public
specifier|static
name|AssertThat
name|that
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
return|return
name|that
argument_list|()
operator|.
name|with
argument_list|(
name|config
argument_list|)
return|;
block|}
comment|/** Short-hand for    *  {@code CalciteAssert.that().with(Config.EMPTY).withModel(model)}. */
specifier|public
specifier|static
name|AssertThat
name|model
parameter_list|(
name|String
name|model
parameter_list|)
block|{
return|return
name|that
argument_list|()
operator|.
name|withModel
argument_list|(
name|model
argument_list|)
return|;
block|}
comment|/** Short-hand for {@code CalciteAssert.that().with(Config.REGULAR)}. */
specifier|public
specifier|static
name|AssertThat
name|hr
parameter_list|()
block|{
return|return
name|that
argument_list|(
name|Config
operator|.
name|REGULAR
argument_list|)
return|;
block|}
specifier|static
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
name|checkRel
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|,
specifier|final
name|AtomicInteger
name|counter
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelNode
name|relNode
parameter_list|)
block|{
if|if
condition|(
name|counter
operator|!=
literal|null
condition|)
block|{
name|counter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|String
name|s
init|=
name|Util
operator|.
name|toLinux
argument_list|(
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relNode
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|s
argument_list|,
name|containsString
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
specifier|static
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Void
argument_list|>
name|checkException
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|Throwable
name|p0
parameter_list|)
block|{
name|assertNotNull
argument_list|(
literal|"expected exception but none was thrown"
argument_list|,
name|p0
argument_list|)
expr_stmt|;
name|StringWriter
name|stringWriter
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|printWriter
init|=
operator|new
name|PrintWriter
argument_list|(
name|stringWriter
argument_list|)
decl_stmt|;
name|p0
operator|.
name|printStackTrace
argument_list|(
name|printWriter
argument_list|)
expr_stmt|;
name|printWriter
operator|.
name|flush
argument_list|()
expr_stmt|;
name|String
name|stack
init|=
name|stringWriter
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|stack
argument_list|,
name|stack
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkResult
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|)
block|{
return|return
name|checkResult
argument_list|(
name|expected
argument_list|,
operator|new
name|ResultSetFormatter
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkResult
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|,
specifier|final
name|ResultSetFormatter
name|resultSetFormatter
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
block|{
try|try
block|{
name|resultSetFormatter
operator|.
name|resultSet
argument_list|(
name|resultSet
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|Util
operator|.
name|toLinux
argument_list|(
name|resultSetFormatter
operator|.
name|string
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkResultValue
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"too few rows"
argument_list|)
throw|;
block|}
if|if
condition|(
name|resultSet
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumnCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"expected 1 column"
argument_list|)
throw|;
block|}
specifier|final
name|String
name|resultString
init|=
name|resultSet
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|resultString
operator|==
literal|null
condition|?
literal|null
else|:
name|Util
operator|.
name|toLinux
argument_list|(
name|resultString
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkResultCount
parameter_list|(
specifier|final
name|Matcher
argument_list|<
name|Integer
argument_list|>
name|expected
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
block|{
try|try
block|{
specifier|final
name|int
name|count
init|=
name|CalciteAssert
operator|.
name|countRows
argument_list|(
name|resultSet
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|count
argument_list|,
name|expected
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|Function
argument_list|<
name|Integer
argument_list|,
name|Void
argument_list|>
name|checkUpdateCount
parameter_list|(
specifier|final
name|int
name|expected
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|Integer
name|updateCount
parameter_list|)
block|{
name|assertThat
argument_list|(
name|updateCount
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
return|;
block|}
comment|/** Checks that the result of the second and subsequent executions is the same    * as the first.    *    * @param ordered Whether order should be the same both times    */
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|consistentResult
parameter_list|(
specifier|final
name|boolean
name|ordered
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
name|int
name|executeCount
init|=
literal|0
decl_stmt|;
name|Collection
name|expected
decl_stmt|;
specifier|public
name|Void
name|apply
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
block|{
operator|++
name|executeCount
expr_stmt|;
try|try
block|{
specifier|final
name|Collection
name|result
init|=
name|CalciteAssert
operator|.
name|toStringList
argument_list|(
name|resultSet
argument_list|,
name|ordered
condition|?
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|executeCount
operator|==
literal|1
condition|)
block|{
name|expected
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|expected
operator|.
name|equals
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|// compare strings to get better error message
name|assertThat
argument_list|(
name|newlineList
argument_list|(
name|result
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|newlineList
argument_list|(
name|expected
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"oops"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
specifier|static
name|String
name|newlineList
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|collection
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|o
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** @see Matchers#returnsUnordered(String...) */
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkResultUnordered
parameter_list|(
specifier|final
name|String
modifier|...
name|lines
parameter_list|)
block|{
return|return
name|checkResult
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
name|lines
argument_list|)
return|;
block|}
comment|/** @see Matchers#returnsUnordered(String...) */
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkResult
parameter_list|(
specifier|final
name|boolean
name|sort
parameter_list|,
specifier|final
name|boolean
name|head
parameter_list|,
specifier|final
name|String
modifier|...
name|lines
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
block|{
try|try
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|lines
argument_list|)
decl_stmt|;
if|if
condition|(
name|sort
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|expectedList
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|actualList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|CalciteAssert
operator|.
name|toStringList
argument_list|(
name|resultSet
argument_list|,
name|actualList
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|actualList
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|trimmedActualList
decl_stmt|;
if|if
condition|(
name|head
operator|&&
name|actualList
operator|.
name|size
argument_list|()
operator|>
name|expectedList
operator|.
name|size
argument_list|()
condition|)
block|{
name|trimmedActualList
operator|=
name|actualList
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|expectedList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trimmedActualList
operator|=
name|actualList
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|trimmedActualList
operator|.
name|equals
argument_list|(
name|expectedList
argument_list|)
condition|)
block|{
name|assertThat
argument_list|(
name|Util
operator|.
name|lines
argument_list|(
name|trimmedActualList
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|Util
operator|.
name|lines
argument_list|(
name|expectedList
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkResultContains
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|ResultSet
name|s
parameter_list|)
block|{
try|try
block|{
specifier|final
name|String
name|actual
init|=
name|Util
operator|.
name|toLinux
argument_list|(
name|CalciteAssert
operator|.
name|toString
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|actual
argument_list|,
name|containsString
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkMaskedResultContains
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|ResultSet
name|s
parameter_list|)
block|{
try|try
block|{
specifier|final
name|String
name|actual
init|=
name|Util
operator|.
name|toLinux
argument_list|(
name|CalciteAssert
operator|.
name|toString
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|String
name|maskedActual
init|=
name|actual
operator|.
name|replaceAll
argument_list|(
literal|", id = [0-9]+"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|maskedActual
argument_list|,
name|containsString
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checkResultType
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|)
block|{
return|return
operator|new
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|ResultSet
name|s
parameter_list|)
block|{
try|try
block|{
specifier|final
name|String
name|actual
init|=
name|typeString
argument_list|(
name|s
operator|.
name|getMetaData
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|;
block|}
specifier|private
specifier|static
name|String
name|typeString
parameter_list|(
name|ResultSetMetaData
name|metaData
parameter_list|)
throws|throws
name|SQLException
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|metaData
operator|.
name|getColumnCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|metaData
operator|.
name|getColumnName
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|+
literal|" "
operator|+
name|metaData
operator|.
name|getColumnTypeName
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|+
operator|(
name|metaData
operator|.
name|isNullable
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|ResultSetMetaData
operator|.
name|columnNoNulls
condition|?
literal|" NOT NULL"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|static
name|void
name|assertQuery
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|sql
parameter_list|,
name|int
name|limit
parameter_list|,
name|boolean
name|materializationsEnabled
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|Hook
argument_list|,
name|Function
argument_list|>
argument_list|>
name|hooks
parameter_list|,
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|resultChecker
parameter_list|,
name|Function
argument_list|<
name|Integer
argument_list|,
name|Void
argument_list|>
name|updateChecker
parameter_list|,
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Void
argument_list|>
name|exceptionChecker
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
name|message
init|=
literal|"With materializationsEnabled="
operator|+
name|materializationsEnabled
operator|+
literal|", limit="
operator|+
name|limit
decl_stmt|;
try|try
init|(
specifier|final
name|Closer
name|closer
init|=
operator|new
name|Closer
argument_list|()
init|)
block|{
if|if
condition|(
name|connection
operator|instanceof
name|CalciteConnection
condition|)
block|{
name|CalciteConnection
name|calciteConnection
init|=
operator|(
name|CalciteConnection
operator|)
name|connection
decl_stmt|;
name|calciteConnection
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|CalciteConnectionProperty
operator|.
name|MATERIALIZATIONS_ENABLED
operator|.
name|camelName
argument_list|()
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|materializationsEnabled
argument_list|)
argument_list|)
expr_stmt|;
name|calciteConnection
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|CalciteConnectionProperty
operator|.
name|CREATE_MATERIALIZATIONS
operator|.
name|camelName
argument_list|()
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|materializationsEnabled
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|Hook
argument_list|,
name|Function
argument_list|>
name|hook
range|:
name|hooks
control|)
block|{
name|closer
operator|.
name|add
argument_list|(
name|hook
operator|.
name|left
operator|.
name|addThread
argument_list|(
name|hook
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|statement
operator|.
name|setMaxRows
argument_list|(
name|limit
operator|<=
literal|0
condition|?
name|limit
else|:
name|Math
operator|.
name|max
argument_list|(
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
literal|null
decl_stmt|;
name|Integer
name|updateCount
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|updateChecker
operator|==
literal|null
condition|)
block|{
name|resultSet
operator|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateCount
operator|=
name|statement
operator|.
name|executeUpdate
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exceptionChecker
operator|!=
literal|null
condition|)
block|{
name|exceptionChecker
operator|.
name|apply
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
decl||
name|Error
name|e
parameter_list|)
block|{
if|if
condition|(
name|exceptionChecker
operator|!=
literal|null
condition|)
block|{
name|exceptionChecker
operator|.
name|apply
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|resultChecker
operator|!=
literal|null
condition|)
block|{
name|resultChecker
operator|.
name|apply
argument_list|(
name|resultSet
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|updateChecker
operator|!=
literal|null
condition|)
block|{
name|updateChecker
operator|.
name|apply
argument_list|(
name|updateCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resultSet
operator|!=
literal|null
condition|)
block|{
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Error
decl||
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// We ignore extended message for non-runtime exception, however
comment|// it does not matter much since it is better to have AssertionError
comment|// at the very top level of the exception stack.
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|message
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|static
name|void
name|assertPrepare
parameter_list|(
name|Connection
name|connection
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|materializationsEnabled
parameter_list|,
specifier|final
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
name|convertChecker
parameter_list|,
specifier|final
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
name|substitutionChecker
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
name|message
init|=
literal|"With materializationsEnabled="
operator|+
name|materializationsEnabled
decl_stmt|;
try|try
init|(
name|Closer
name|closer
init|=
operator|new
name|Closer
argument_list|()
init|)
block|{
if|if
condition|(
name|convertChecker
operator|!=
literal|null
condition|)
block|{
name|closer
operator|.
name|add
argument_list|(
name|Hook
operator|.
name|TRIMMED
operator|.
name|addThread
argument_list|(
operator|new
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|convertChecker
operator|.
name|apply
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|substitutionChecker
operator|!=
literal|null
condition|)
block|{
name|closer
operator|.
name|add
argument_list|(
name|Hook
operator|.
name|SUB
operator|.
name|addThread
argument_list|(
operator|new
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|substitutionChecker
operator|.
name|apply
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|CalciteConnection
operator|)
name|connection
operator|)
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|CalciteConnectionProperty
operator|.
name|MATERIALIZATIONS_ENABLED
operator|.
name|camelName
argument_list|()
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|materializationsEnabled
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|CalciteConnection
operator|)
name|connection
operator|)
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|CalciteConnectionProperty
operator|.
name|CREATE_MATERIALIZATIONS
operator|.
name|camelName
argument_list|()
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|materializationsEnabled
argument_list|)
argument_list|)
expr_stmt|;
name|PreparedStatement
name|statement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|message
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Converts a {@link ResultSet} to a string. */
specifier|static
name|String
name|toString
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
throws|throws
name|SQLException
block|{
return|return
operator|new
name|ResultSetFormatter
argument_list|()
operator|.
name|resultSet
argument_list|(
name|resultSet
argument_list|)
operator|.
name|string
argument_list|()
return|;
block|}
specifier|static
name|int
name|countRows
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
specifier|static
name|Collection
argument_list|<
name|String
argument_list|>
name|toStringList
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|list
parameter_list|)
throws|throws
name|SQLException
block|{
return|return
operator|new
name|ResultSetFormatter
argument_list|()
operator|.
name|toStringList
argument_list|(
name|resultSet
argument_list|,
name|list
argument_list|)
return|;
block|}
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|toList
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
throws|throws
name|SQLException
block|{
return|return
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
name|toStringList
argument_list|(
name|resultSet
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|ImmutableMultiset
argument_list|<
name|String
argument_list|>
name|toSet
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
throws|throws
name|SQLException
block|{
return|return
name|ImmutableMultiset
operator|.
name|copyOf
argument_list|(
name|toList
argument_list|(
name|resultSet
argument_list|)
argument_list|)
return|;
block|}
comment|/** Calls a non-static method via reflection. Useful for testing methods that    * don't exist in certain versions of the JDK. */
specifier|static
name|Object
name|call
parameter_list|(
name|Object
name|o
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|NoSuchMethodException
throws|,
name|InvocationTargetException
throws|,
name|IllegalAccessException
block|{
return|return
name|method
argument_list|(
name|o
argument_list|,
name|methodName
argument_list|,
name|args
argument_list|)
operator|.
name|invoke
argument_list|(
name|o
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/** Finds a non-static method based on its target, name and arguments.    * Throws if not found. */
specifier|static
name|Method
name|method
parameter_list|(
name|Object
name|o
parameter_list|,
name|String
name|methodName
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
block|{
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|aClass
init|=
name|o
operator|.
name|getClass
argument_list|()
init|;
condition|;
control|)
block|{
name|loop
label|:
for|for
control|(
name|Method
name|method1
range|:
name|aClass
operator|.
name|getMethods
argument_list|()
control|)
block|{
if|if
condition|(
name|method1
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|methodName
argument_list|)
operator|&&
name|method1
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|==
name|args
operator|.
name|length
operator|&&
name|Modifier
operator|.
name|isPublic
argument_list|(
name|method1
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
name|Pair
argument_list|<
name|Object
argument_list|,
name|Class
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|args
argument_list|,
operator|(
name|Class
index|[]
operator|)
name|method1
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|pair
operator|.
name|right
operator|.
name|isInstance
argument_list|(
name|pair
operator|.
name|left
argument_list|)
condition|)
block|{
continue|continue
name|loop
continue|;
block|}
block|}
return|return
name|method1
return|;
block|}
block|}
if|if
condition|(
name|aClass
operator|.
name|getSuperclass
argument_list|()
operator|!=
literal|null
operator|&&
name|aClass
operator|.
name|getSuperclass
argument_list|()
operator|!=
name|Object
operator|.
name|class
condition|)
block|{
name|aClass
operator|=
name|aClass
operator|.
name|getSuperclass
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|interfaces
init|=
name|aClass
operator|.
name|getInterfaces
argument_list|()
decl_stmt|;
if|if
condition|(
name|interfaces
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|aClass
operator|=
name|interfaces
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"method "
operator|+
name|methodName
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
specifier|public
specifier|static
name|SchemaPlus
name|addSchema
parameter_list|(
name|SchemaPlus
name|rootSchema
parameter_list|,
name|SchemaSpec
name|schema
parameter_list|)
block|{
name|SchemaPlus
name|foodmart
decl_stmt|;
name|SchemaPlus
name|jdbcScott
decl_stmt|;
specifier|final
name|ConnectionSpec
name|cs
decl_stmt|;
specifier|final
name|DataSource
name|dataSource
decl_stmt|;
switch|switch
condition|(
name|schema
condition|)
block|{
case|case
name|REFLECTIVE_FOODMART
case|:
return|return
name|rootSchema
operator|.
name|add
argument_list|(
literal|"foodmart"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|JdbcTest
operator|.
name|FoodmartSchema
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|JDBC_SCOTT
case|:
name|cs
operator|=
name|DatabaseInstance
operator|.
name|HSQLDB
operator|.
name|scott
expr_stmt|;
name|dataSource
operator|=
name|JdbcSchema
operator|.
name|dataSource
argument_list|(
name|cs
operator|.
name|url
argument_list|,
name|cs
operator|.
name|driver
argument_list|,
name|cs
operator|.
name|username
argument_list|,
name|cs
operator|.
name|password
argument_list|)
expr_stmt|;
return|return
name|rootSchema
operator|.
name|add
argument_list|(
literal|"JDBC_SCOTT"
argument_list|,
name|JdbcSchema
operator|.
name|create
argument_list|(
name|rootSchema
argument_list|,
literal|"JDBC_SCOTT"
argument_list|,
name|dataSource
argument_list|,
name|cs
operator|.
name|catalog
argument_list|,
name|cs
operator|.
name|schema
argument_list|)
argument_list|)
return|;
case|case
name|JDBC_FOODMART
case|:
name|cs
operator|=
name|DB
operator|.
name|foodmart
expr_stmt|;
name|dataSource
operator|=
name|JdbcSchema
operator|.
name|dataSource
argument_list|(
name|cs
operator|.
name|url
argument_list|,
name|cs
operator|.
name|driver
argument_list|,
name|cs
operator|.
name|username
argument_list|,
name|cs
operator|.
name|password
argument_list|)
expr_stmt|;
return|return
name|rootSchema
operator|.
name|add
argument_list|(
literal|"foodmart"
argument_list|,
name|JdbcSchema
operator|.
name|create
argument_list|(
name|rootSchema
argument_list|,
literal|"foodmart"
argument_list|,
name|dataSource
argument_list|,
name|cs
operator|.
name|catalog
argument_list|,
name|cs
operator|.
name|schema
argument_list|)
argument_list|)
return|;
case|case
name|JDBC_FOODMART_WITH_LATTICE
case|:
name|foodmart
operator|=
name|rootSchema
operator|.
name|getSubSchema
argument_list|(
literal|"foodmart"
argument_list|)
expr_stmt|;
if|if
condition|(
name|foodmart
operator|==
literal|null
condition|)
block|{
name|foodmart
operator|=
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|SchemaSpec
operator|.
name|JDBC_FOODMART
argument_list|)
expr_stmt|;
block|}
name|foodmart
operator|.
name|add
argument_list|(
literal|"lattice"
argument_list|,
name|Lattice
operator|.
name|create
argument_list|(
name|foodmart
operator|.
name|unwrap
argument_list|(
name|CalciteSchema
operator|.
name|class
argument_list|)
argument_list|,
literal|"select 1 from \"foodmart\".\"sales_fact_1997\" as s\n"
operator|+
literal|"join \"foodmart\".\"time_by_day\" as t using (\"time_id\")\n"
operator|+
literal|"join \"foodmart\".\"customer\" as c using (\"customer_id\")\n"
operator|+
literal|"join \"foodmart\".\"product\" as p using (\"product_id\")\n"
operator|+
literal|"join \"foodmart\".\"product_class\" as pc on p.\"product_class_id\" = pc.\"product_class_id\""
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|foodmart
return|;
case|case
name|SCOTT
case|:
name|jdbcScott
operator|=
name|rootSchema
operator|.
name|getSubSchema
argument_list|(
literal|"jdbc_scott"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jdbcScott
operator|==
literal|null
condition|)
block|{
name|jdbcScott
operator|=
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|SchemaSpec
operator|.
name|JDBC_SCOTT
argument_list|)
expr_stmt|;
block|}
return|return
name|rootSchema
operator|.
name|add
argument_list|(
literal|"scott"
argument_list|,
operator|new
name|CloneSchema
argument_list|(
name|jdbcScott
argument_list|)
argument_list|)
return|;
case|case
name|CLONE_FOODMART
case|:
name|foodmart
operator|=
name|rootSchema
operator|.
name|getSubSchema
argument_list|(
literal|"foodmart"
argument_list|)
expr_stmt|;
if|if
condition|(
name|foodmart
operator|==
literal|null
condition|)
block|{
name|foodmart
operator|=
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|SchemaSpec
operator|.
name|JDBC_FOODMART
argument_list|)
expr_stmt|;
block|}
return|return
name|rootSchema
operator|.
name|add
argument_list|(
literal|"foodmart2"
argument_list|,
operator|new
name|CloneSchema
argument_list|(
name|foodmart
argument_list|)
argument_list|)
return|;
case|case
name|HR
case|:
return|return
name|rootSchema
operator|.
name|add
argument_list|(
literal|"hr"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|JdbcTest
operator|.
name|HrSchema
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|LINGUAL
case|:
return|return
name|rootSchema
operator|.
name|add
argument_list|(
literal|"SALES"
argument_list|,
operator|new
name|ReflectiveSchema
argument_list|(
operator|new
name|JdbcTest
operator|.
name|LingualSchema
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|BLANK
case|:
return|return
name|rootSchema
operator|.
name|add
argument_list|(
literal|"BLANK"
argument_list|,
operator|new
name|AbstractSchema
argument_list|()
argument_list|)
return|;
case|case
name|ORINOCO
case|:
specifier|final
name|SchemaPlus
name|orinoco
init|=
name|rootSchema
operator|.
name|add
argument_list|(
literal|"ORINOCO"
argument_list|,
operator|new
name|AbstractSchema
argument_list|()
argument_list|)
decl_stmt|;
name|orinoco
operator|.
name|add
argument_list|(
literal|"ORDERS"
argument_list|,
operator|new
name|StreamTest
operator|.
name|OrdersHistoryTable
argument_list|(
name|StreamTest
operator|.
name|OrdersStreamTableFactory
operator|.
name|getRowList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|orinoco
return|;
case|case
name|POST
case|:
specifier|final
name|SchemaPlus
name|post
init|=
name|rootSchema
operator|.
name|add
argument_list|(
literal|"POST"
argument_list|,
operator|new
name|AbstractSchema
argument_list|()
argument_list|)
decl_stmt|;
name|post
operator|.
name|add
argument_list|(
literal|"EMP"
argument_list|,
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|post
argument_list|,
literal|"select * from (values\n"
operator|+
literal|"    ('Jane', 10, 'F'),\n"
operator|+
literal|"    ('Bob', 10, 'M'),\n"
operator|+
literal|"    ('Eric', 20, 'M'),\n"
operator|+
literal|"    ('Susan', 30, 'F'),\n"
operator|+
literal|"    ('Alice', 30, 'F'),\n"
operator|+
literal|"    ('Adam', 50, 'M'),\n"
operator|+
literal|"    ('Eve', 50, 'F'),\n"
operator|+
literal|"    ('Grace', 60, 'F'),\n"
operator|+
literal|"    ('Wilma', cast(null as integer), 'F'))\n"
operator|+
literal|"  as t(ename, deptno, gender)"
argument_list|,
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"POST"
argument_list|,
literal|"EMP"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|post
operator|.
name|add
argument_list|(
literal|"DEPT"
argument_list|,
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|post
argument_list|,
literal|"select * from (values\n"
operator|+
literal|"    (10, 'Sales'),\n"
operator|+
literal|"    (20, 'Marketing'),\n"
operator|+
literal|"    (30, 'Engineering'),\n"
operator|+
literal|"    (40, 'Empty')) as t(deptno, dname)"
argument_list|,
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"POST"
argument_list|,
literal|"DEPT"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|post
operator|.
name|add
argument_list|(
literal|"EMPS"
argument_list|,
name|ViewTable
operator|.
name|viewMacro
argument_list|(
name|post
argument_list|,
literal|"select * from (values\n"
operator|+
literal|"    (100, 'Fred',  10, CAST(NULL AS CHAR(1)), CAST(NULL AS VARCHAR(20)), 40,               25, TRUE,    FALSE, DATE '1996-08-03'),\n"
operator|+
literal|"    (110, 'Eric',  20, 'M',                   'San Francisco',           3,                80, UNKNOWN, FALSE, DATE '2001-01-01'),\n"
operator|+
literal|"    (110, 'John',  40, 'M',                   'Vancouver',               2, CAST(NULL AS INT), FALSE,   TRUE,  DATE '2002-05-03'),\n"
operator|+
literal|"    (120, 'Wilma', 20, 'F',                   CAST(NULL AS VARCHAR(20)), 1,                 5, UNKNOWN, TRUE,  DATE '2005-09-07'),\n"
operator|+
literal|"    (130, 'Alice', 40, 'F',                   'Vancouver',               2, CAST(NULL AS INT), FALSE,   TRUE,  DATE '2007-01-01'))\n"
operator|+
literal|" as t(empno, name, deptno, gender, city, empid, age, slacker, manager, joinedat)"
argument_list|,
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"POST"
argument_list|,
literal|"EMPS"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|post
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unknown schema "
operator|+
name|schema
argument_list|)
throw|;
block|}
block|}
comment|/**    * Asserts that two objects are equal. If they are not, an    * {@link AssertionError} is thrown with the given message. If    *<code>expected</code> and<code>actual</code> are<code>null</code>,    * they are considered equal.    *    *<p>This method produces more user-friendly error messages than    * {@link org.junit.Assert#assertArrayEquals(String, Object[], Object[])}    *    * @param message the identifying message for the {@link AssertionError} (<code>null</code>    * okay)    * @param expected expected value    * @param actual actual value    */
specifier|public
specifier|static
name|void
name|assertArrayEqual
parameter_list|(
name|String
name|message
parameter_list|,
name|Object
index|[]
name|expected
parameter_list|,
name|Object
index|[]
name|actual
parameter_list|)
block|{
name|Joiner
name|joiner
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
name|String
name|strExpected
init|=
name|expected
operator|==
literal|null
condition|?
literal|null
else|:
name|joiner
operator|.
name|join
argument_list|(
name|expected
argument_list|)
decl_stmt|;
name|String
name|strActual
init|=
name|actual
operator|==
literal|null
condition|?
literal|null
else|:
name|joiner
operator|.
name|join
argument_list|(
name|actual
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|message
argument_list|,
name|strExpected
argument_list|,
name|strActual
argument_list|)
expr_stmt|;
block|}
specifier|static
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
name|Function
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
name|constantNull
parameter_list|()
block|{
comment|//noinspection unchecked
return|return
operator|(
name|Function
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
operator|)
operator|(
name|Function
operator|)
name|Functions
operator|.
expr|<
name|T
operator|>
name|constant
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**    * Result of calling {@link CalciteAssert#that}.    */
specifier|public
specifier|static
class|class
name|AssertThat
block|{
specifier|private
specifier|final
name|ConnectionFactory
name|connectionFactory
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|AssertThat
name|EMPTY
init|=
operator|new
name|AssertThat
argument_list|(
name|EMPTY_CONNECTION_FACTORY
argument_list|)
decl_stmt|;
specifier|private
name|AssertThat
parameter_list|(
name|ConnectionFactory
name|connectionFactory
parameter_list|)
block|{
name|this
operator|.
name|connectionFactory
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|connectionFactory
argument_list|)
expr_stmt|;
block|}
specifier|public
name|AssertThat
name|with
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
if|if
condition|(
name|config
operator|==
name|Config
operator|.
name|SPARK
condition|)
block|{
return|return
name|with
argument_list|(
literal|"spark"
argument_list|,
literal|"true"
argument_list|)
return|;
block|}
switch|switch
condition|(
name|config
condition|)
block|{
case|case
name|EMPTY
case|:
return|return
name|EMPTY
return|;
case|case
name|REGULAR
case|:
return|return
name|with
argument_list|(
name|SchemaSpec
operator|.
name|HR
argument_list|,
name|SchemaSpec
operator|.
name|REFLECTIVE_FOODMART
argument_list|,
name|SchemaSpec
operator|.
name|POST
argument_list|)
return|;
case|case
name|REGULAR_PLUS_METADATA
case|:
return|return
name|with
argument_list|(
name|SchemaSpec
operator|.
name|HR
argument_list|,
name|SchemaSpec
operator|.
name|REFLECTIVE_FOODMART
argument_list|)
return|;
case|case
name|LINGUAL
case|:
return|return
name|with
argument_list|(
name|SchemaSpec
operator|.
name|LINGUAL
argument_list|)
return|;
case|case
name|JDBC_FOODMART
case|:
return|return
name|with
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|JDBC_FOODMART
argument_list|)
return|;
case|case
name|FOODMART_CLONE
case|:
return|return
name|with
argument_list|(
name|SchemaSpec
operator|.
name|CLONE_FOODMART
argument_list|)
return|;
case|case
name|JDBC_FOODMART_WITH_LATTICE
case|:
return|return
name|with
argument_list|(
name|SchemaSpec
operator|.
name|JDBC_FOODMART_WITH_LATTICE
argument_list|)
return|;
case|case
name|JDBC_SCOTT
case|:
return|return
name|with
argument_list|(
name|SchemaSpec
operator|.
name|JDBC_SCOTT
argument_list|)
return|;
case|case
name|SCOTT
case|:
return|return
name|with
argument_list|(
name|SchemaSpec
operator|.
name|SCOTT
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|config
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a copy of this AssertThat, adding more schemas */
specifier|public
name|AssertThat
name|with
parameter_list|(
name|SchemaSpec
modifier|...
name|specs
parameter_list|)
block|{
name|AssertThat
name|next
init|=
name|this
decl_stmt|;
for|for
control|(
name|SchemaSpec
name|spec
range|:
name|specs
control|)
block|{
name|next
operator|=
name|next
operator|.
name|with
argument_list|(
operator|new
name|AddSchemaSpecPostProcessor
argument_list|(
name|spec
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
comment|/** Creates a copy of this AssertThat, overriding the connection factory. */
specifier|public
name|AssertThat
name|with
parameter_list|(
name|ConnectionFactory
name|connectionFactory
parameter_list|)
block|{
return|return
operator|new
name|AssertThat
argument_list|(
name|connectionFactory
argument_list|)
return|;
block|}
specifier|public
specifier|final
name|AssertThat
name|with
parameter_list|(
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
parameter_list|)
block|{
name|AssertThat
name|x
init|=
name|this
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|x
operator|=
name|with
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
specifier|public
name|AssertThat
name|with
parameter_list|(
name|String
name|property
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|AssertThat
argument_list|(
name|connectionFactory
operator|.
name|with
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/** Sets Lex property **/
specifier|public
name|AssertThat
name|with
parameter_list|(
name|Lex
name|lex
parameter_list|)
block|{
return|return
name|with
argument_list|(
name|CalciteConnectionProperty
operator|.
name|LEX
operator|.
name|name
argument_list|()
argument_list|,
name|lex
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/** Sets the default schema to a given schema. */
specifier|public
name|AssertThat
name|withSchema
parameter_list|(
name|String
name|name
parameter_list|,
name|Schema
name|schema
parameter_list|)
block|{
return|return
operator|new
name|AssertThat
argument_list|(
name|connectionFactory
operator|.
name|with
argument_list|(
operator|new
name|AddSchemaPostProcessor
argument_list|(
name|name
argument_list|,
name|schema
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|AssertThat
name|with
parameter_list|(
name|ConnectionPostProcessor
name|postProcessor
parameter_list|)
block|{
return|return
operator|new
name|AssertThat
argument_list|(
name|connectionFactory
operator|.
name|with
argument_list|(
name|postProcessor
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|final
name|AssertThat
name|withModel
parameter_list|(
name|String
name|model
parameter_list|)
block|{
return|return
name|with
argument_list|(
literal|"model"
argument_list|,
literal|"inline:"
operator|+
name|model
argument_list|)
return|;
block|}
comment|/** Adds materializations to the schema. */
specifier|public
specifier|final
name|AssertThat
name|withMaterializations
parameter_list|(
name|String
name|model
parameter_list|,
specifier|final
name|String
modifier|...
name|materializations
parameter_list|)
block|{
return|return
name|withMaterializations
argument_list|(
name|model
argument_list|,
operator|new
name|Function
argument_list|<
name|JsonBuilder
argument_list|,
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|apply
parameter_list|(
name|JsonBuilder
name|builder
parameter_list|)
block|{
assert|assert
name|materializations
operator|.
name|length
operator|%
literal|2
operator|==
literal|0
assert|;
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
name|builder
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|materializations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|table
init|=
name|materializations
index|[
name|i
operator|++
index|]
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
name|builder
operator|.
name|map
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"table"
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"view"
argument_list|,
name|table
operator|+
literal|"v"
argument_list|)
expr_stmt|;
name|String
name|sql
init|=
name|materializations
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|String
name|sql2
init|=
name|sql
operator|.
name|replaceAll
argument_list|(
literal|"`"
argument_list|,
literal|"\""
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"sql"
argument_list|,
name|sql2
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/** Adds materializations to the schema. */
specifier|public
specifier|final
name|AssertThat
name|withMaterializations
parameter_list|(
name|String
name|model
parameter_list|,
name|Function
argument_list|<
name|JsonBuilder
argument_list|,
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|materializations
parameter_list|)
block|{
specifier|final
name|JsonBuilder
name|builder
init|=
operator|new
name|JsonBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
name|materializations
operator|.
name|apply
argument_list|(
name|builder
argument_list|)
decl_stmt|;
specifier|final
name|String
name|buf
init|=
literal|"materializations: "
operator|+
name|builder
operator|.
name|toJsonString
argument_list|(
name|list
argument_list|)
decl_stmt|;
specifier|final
name|String
name|model2
decl_stmt|;
if|if
condition|(
name|model
operator|.
name|contains
argument_list|(
literal|"defaultSchema: 'foodmart'"
argument_list|)
condition|)
block|{
name|model2
operator|=
name|model
operator|.
name|replace
argument_list|(
literal|"]"
argument_list|,
literal|", { name: 'mat', "
operator|+
name|buf
operator|+
literal|"}\n"
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|model
operator|.
name|contains
argument_list|(
literal|"type: "
argument_list|)
condition|)
block|{
name|model2
operator|=
name|model
operator|.
name|replace
argument_list|(
literal|"type: "
argument_list|,
name|buf
operator|+
literal|",\n"
operator|+
literal|"type: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"do not know where to splice"
argument_list|)
throw|;
block|}
return|return
name|withModel
argument_list|(
name|model2
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|query
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
return|return
operator|new
name|AssertQuery
argument_list|(
name|connectionFactory
argument_list|,
name|sql
argument_list|)
return|;
block|}
comment|/** Asserts that there is an exception with the given message while      * creating a connection. */
specifier|public
name|AssertThat
name|connectThrows
parameter_list|(
name|String
name|message
parameter_list|)
block|{
return|return
name|connectThrows
argument_list|(
name|checkException
argument_list|(
name|message
argument_list|)
argument_list|)
return|;
block|}
comment|/** Asserts that there is an exception that matches the given predicate      * while creating a connection. */
specifier|public
name|AssertThat
name|connectThrows
parameter_list|(
name|Function
argument_list|<
name|Throwable
argument_list|,
name|Void
argument_list|>
name|exceptionChecker
parameter_list|)
block|{
name|Throwable
name|throwable
decl_stmt|;
try|try
block|{
name|Connection
name|x
init|=
name|connectionFactory
operator|.
name|createConnection
argument_list|()
decl_stmt|;
try|try
block|{
name|x
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
name|throwable
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|throwable
operator|=
name|e
expr_stmt|;
block|}
name|exceptionChecker
operator|.
name|apply
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.jdbc.CalciteConnection}      * and executes a callback. */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|AssertThat
name|doWithConnection
parameter_list|(
name|Function
argument_list|<
name|CalciteConnection
argument_list|,
name|T
argument_list|>
name|fn
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|connection
init|=
name|connectionFactory
operator|.
name|createConnection
argument_list|()
init|)
block|{
name|T
name|t
init|=
name|fn
operator|.
name|apply
argument_list|(
operator|(
name|CalciteConnection
operator|)
name|connection
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|AssertThat
operator|.
name|this
return|;
block|}
block|}
comment|/** Creates a {@link DataContext} and executes a callback. */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|AssertThat
name|doWithDataContext
parameter_list|(
name|Function
argument_list|<
name|DataContext
argument_list|,
name|T
argument_list|>
name|fn
parameter_list|)
throws|throws
name|Exception
block|{
name|CalciteConnection
name|connection
init|=
operator|(
name|CalciteConnection
operator|)
name|connectionFactory
operator|.
name|createConnection
argument_list|()
decl_stmt|;
specifier|final
name|DataContext
name|dataContext
init|=
name|CalciteMetaImpl
operator|.
name|createDataContext
argument_list|(
name|connection
argument_list|)
decl_stmt|;
try|try
block|{
name|T
name|t
init|=
name|fn
operator|.
name|apply
argument_list|(
name|dataContext
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|AssertThat
operator|.
name|this
return|;
block|}
finally|finally
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|AssertThat
name|withDefaultSchema
parameter_list|(
name|String
name|schema
parameter_list|)
block|{
return|return
operator|new
name|AssertThat
argument_list|(
name|connectionFactory
operator|.
name|with
argument_list|(
operator|new
name|AddSchemaPostProcessor
argument_list|(
name|schema
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Use sparingly. Does not close the connection. */
specifier|public
name|Connection
name|connect
parameter_list|()
throws|throws
name|SQLException
block|{
return|return
name|connectionFactory
operator|.
name|createConnection
argument_list|()
return|;
block|}
specifier|public
name|AssertThat
name|enable
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
return|return
name|enabled
condition|?
name|this
else|:
name|DISABLED
return|;
block|}
comment|/** Returns a version that uses a single connection, as opposed to creating      * a new one each time a test method is invoked. */
specifier|public
name|AssertThat
name|pooled
parameter_list|()
block|{
if|if
condition|(
name|connectionFactory
operator|instanceof
name|PoolingConnectionFactory
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
return|return
operator|new
name|AssertThat
argument_list|(
operator|new
name|PoolingConnectionFactory
argument_list|(
name|connectionFactory
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
name|AssertMetaData
name|metaData
parameter_list|(
name|Function
argument_list|<
name|Connection
argument_list|,
name|ResultSet
argument_list|>
name|function
parameter_list|)
block|{
return|return
operator|new
name|AssertMetaData
argument_list|(
name|connectionFactory
argument_list|,
name|function
argument_list|)
return|;
block|}
block|}
comment|/**    * Abstract implementation of connection factory whose {@code with}    * methods throw.    *    *<p>Avoid creating new sub-classes otherwise it would be hard to support    * {@code .with(property, value).with(...)} kind of chains.    *    *<p>If you want augment the connection, use {@link ConnectionPostProcessor}.    **/
specifier|public
specifier|abstract
specifier|static
class|class
name|ConnectionFactory
block|{
specifier|public
specifier|abstract
name|Connection
name|createConnection
parameter_list|()
throws|throws
name|SQLException
function_decl|;
specifier|public
name|ConnectionFactory
name|with
parameter_list|(
name|String
name|property
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|ConnectionFactory
name|with
parameter_list|(
name|ConnectionPostProcessor
name|postProcessor
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|/** Connection post processor */
specifier|public
interface|interface
name|ConnectionPostProcessor
block|{
name|Connection
name|apply
parameter_list|(
name|Connection
name|connection
parameter_list|)
throws|throws
name|SQLException
function_decl|;
block|}
comment|/** Adds {@link Schema} and sets it as default. */
specifier|public
specifier|static
class|class
name|AddSchemaPostProcessor
implements|implements
name|ConnectionPostProcessor
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|Schema
name|schema
decl_stmt|;
specifier|public
name|AddSchemaPostProcessor
parameter_list|(
name|String
name|name
parameter_list|,
name|Schema
name|schema
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
block|}
specifier|public
name|Connection
name|apply
parameter_list|(
name|Connection
name|connection
parameter_list|)
throws|throws
name|SQLException
block|{
if|if
condition|(
name|schema
operator|!=
literal|null
condition|)
block|{
name|CalciteConnection
name|con
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|con
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|rootSchema
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|schema
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|setSchema
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|connection
return|;
block|}
block|}
comment|/** Adds {@link SchemaSpec} (set of schemes) to a connection. */
specifier|public
specifier|static
class|class
name|AddSchemaSpecPostProcessor
implements|implements
name|ConnectionPostProcessor
block|{
specifier|private
specifier|final
name|SchemaSpec
name|schemaSpec
decl_stmt|;
specifier|public
name|AddSchemaSpecPostProcessor
parameter_list|(
name|SchemaSpec
name|schemaSpec
parameter_list|)
block|{
name|this
operator|.
name|schemaSpec
operator|=
name|schemaSpec
expr_stmt|;
block|}
specifier|public
name|Connection
name|apply
parameter_list|(
name|Connection
name|connection
parameter_list|)
throws|throws
name|SQLException
block|{
name|CalciteConnection
name|con
init|=
name|connection
operator|.
name|unwrap
argument_list|(
name|CalciteConnection
operator|.
name|class
argument_list|)
decl_stmt|;
name|SchemaPlus
name|rootSchema
init|=
name|con
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|schemaSpec
condition|)
block|{
case|case
name|CLONE_FOODMART
case|:
case|case
name|JDBC_FOODMART_WITH_LATTICE
case|:
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|SchemaSpec
operator|.
name|JDBC_FOODMART
argument_list|)
expr_stmt|;
comment|/* fall through */
default|default:
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|schemaSpec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|schemaSpec
operator|==
name|SchemaSpec
operator|.
name|CLONE_FOODMART
condition|)
block|{
name|con
operator|.
name|setSchema
argument_list|(
literal|"foodmart2"
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
block|}
comment|/** Connection factory that uses the same instance of connections. */
specifier|private
specifier|static
class|class
name|PoolingConnectionFactory
extends|extends
name|ConnectionFactory
block|{
comment|/** Connection pool. */
specifier|private
specifier|static
class|class
name|Pool
block|{
specifier|private
specifier|static
specifier|final
name|LoadingCache
argument_list|<
name|ConnectionFactory
argument_list|,
name|Connection
argument_list|>
name|POOL
init|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|(
operator|new
name|CacheLoader
argument_list|<
name|ConnectionFactory
argument_list|,
name|Connection
argument_list|>
argument_list|()
block|{
specifier|public
name|Connection
name|load
parameter_list|(
annotation|@
name|Nonnull
name|ConnectionFactory
name|key
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|key
operator|.
name|createConnection
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
block|}
specifier|private
specifier|final
name|ConnectionFactory
name|factory
decl_stmt|;
specifier|public
name|PoolingConnectionFactory
parameter_list|(
specifier|final
name|ConnectionFactory
name|factory
parameter_list|)
block|{
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
block|}
specifier|public
name|Connection
name|createConnection
parameter_list|()
throws|throws
name|SQLException
block|{
try|try
block|{
return|return
name|Pool
operator|.
name|POOL
operator|.
name|get
argument_list|(
name|factory
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UncheckedExecutionException
decl||
name|ExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SQLException
argument_list|(
literal|"Unable to get pooled connection for "
operator|+
name|factory
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Connection factory that uses a given map of (name, value) pairs and    * optionally an initial schema. */
specifier|private
specifier|static
class|class
name|MapConnectionFactory
extends|extends
name|ConnectionFactory
block|{
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|ConnectionPostProcessor
argument_list|>
name|postProcessors
decl_stmt|;
specifier|private
name|MapConnectionFactory
parameter_list|(
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
parameter_list|,
name|ImmutableList
argument_list|<
name|ConnectionPostProcessor
argument_list|>
name|postProcessors
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|postProcessors
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|postProcessors
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|this
operator|==
name|obj
operator|||
name|obj
operator|.
name|getClass
argument_list|()
operator|==
name|MapConnectionFactory
operator|.
name|class
operator|&&
operator|(
operator|(
name|MapConnectionFactory
operator|)
name|obj
operator|)
operator|.
name|map
operator|.
name|equals
argument_list|(
name|map
argument_list|)
operator|&&
operator|(
operator|(
name|MapConnectionFactory
operator|)
name|obj
operator|)
operator|.
name|postProcessors
operator|.
name|equals
argument_list|(
name|postProcessors
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|map
argument_list|,
name|postProcessors
argument_list|)
return|;
block|}
specifier|public
name|Connection
name|createConnection
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|Properties
name|info
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|info
operator|.
name|setProperty
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:calcite:"
argument_list|,
name|info
argument_list|)
decl_stmt|;
for|for
control|(
name|ConnectionPostProcessor
name|postProcessor
range|:
name|postProcessors
control|)
block|{
name|connection
operator|=
name|postProcessor
operator|.
name|apply
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
return|return
name|connection
return|;
block|}
specifier|public
name|ConnectionFactory
name|with
parameter_list|(
name|String
name|property
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
operator|new
name|MapConnectionFactory
argument_list|(
name|FlatLists
operator|.
name|append
argument_list|(
name|this
operator|.
name|map
argument_list|,
name|property
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|postProcessors
argument_list|)
return|;
block|}
specifier|public
name|ConnectionFactory
name|with
parameter_list|(
name|ConnectionPostProcessor
name|postProcessor
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ConnectionPostProcessor
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addAll
argument_list|(
name|postProcessors
argument_list|)
expr_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|postProcessor
argument_list|)
expr_stmt|;
return|return
operator|new
name|MapConnectionFactory
argument_list|(
name|map
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Fluent interface for building a query to be tested. */
specifier|public
specifier|static
class|class
name|AssertQuery
block|{
specifier|private
specifier|final
name|String
name|sql
decl_stmt|;
specifier|private
name|ConnectionFactory
name|connectionFactory
decl_stmt|;
specifier|private
name|String
name|plan
decl_stmt|;
specifier|private
name|int
name|limit
decl_stmt|;
specifier|private
name|boolean
name|materializationsEnabled
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|Hook
argument_list|,
name|Function
argument_list|>
argument_list|>
name|hooks
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|private
name|AssertQuery
parameter_list|(
name|ConnectionFactory
name|connectionFactory
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
name|this
operator|.
name|connectionFactory
operator|=
name|connectionFactory
expr_stmt|;
block|}
specifier|protected
name|Connection
name|createConnection
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|connectionFactory
operator|.
name|createConnection
argument_list|()
return|;
block|}
comment|/** Performs an action using a connection, and closes the connection      * afterwards. */
specifier|public
specifier|final
name|AssertQuery
name|withConnection
parameter_list|(
name|Function
argument_list|<
name|Connection
argument_list|,
name|Void
argument_list|>
name|f
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|c
init|=
name|createConnection
argument_list|()
init|)
block|{
name|f
operator|.
name|apply
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
specifier|public
name|AssertQuery
name|enable
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
return|return
name|enabled
condition|?
name|this
else|:
name|NopAssertQuery
operator|.
name|of
argument_list|(
name|sql
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|returns
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|checkResult
argument_list|(
name|expected
argument_list|)
argument_list|)
return|;
block|}
comment|/** Simlar to {@link #returns}, but trims a few values before comparing. */
specifier|public
name|AssertQuery
name|returns2
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|checkResult
argument_list|(
name|expected
argument_list|,
operator|new
name|ResultSetFormatter
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|String
name|adjustValue
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|contains
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
while|while
condition|(
name|s
operator|.
name|endsWith
argument_list|(
literal|"0"
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|endsWith
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|.
name|endsWith
argument_list|(
literal|" 00:00:00"
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|" 00:00:00"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
block|}
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|returnsValue
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|checkResultValue
argument_list|(
name|expected
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|returnsCount
parameter_list|(
name|int
name|expectedCount
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|checkResultCount
argument_list|(
name|is
argument_list|(
name|expectedCount
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|final
name|AssertQuery
name|returns
parameter_list|(
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|sql
argument_list|,
name|checker
argument_list|)
return|;
block|}
specifier|public
specifier|final
name|AssertQuery
name|updates
parameter_list|(
name|int
name|count
parameter_list|)
block|{
try|try
block|{
name|assertQuery
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|limit
argument_list|,
name|materializationsEnabled
argument_list|,
name|hooks
argument_list|,
literal|null
argument_list|,
name|checkUpdateCount
argument_list|(
name|count
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while executing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|AssertQuery
name|returns
parameter_list|(
name|String
name|sql
parameter_list|,
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
try|try
block|{
name|assertQuery
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|limit
argument_list|,
name|materializationsEnabled
argument_list|,
name|hooks
argument_list|,
name|checker
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while executing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|AssertQuery
name|returnsUnordered
parameter_list|(
name|String
modifier|...
name|lines
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|checkResult
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
name|lines
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|returnsOrdered
parameter_list|(
name|String
modifier|...
name|lines
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|checkResult
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
name|lines
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|returnsStartingWith
parameter_list|(
name|String
modifier|...
name|lines
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|checkResult
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|lines
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|throws_
parameter_list|(
name|String
name|message
parameter_list|)
block|{
try|try
block|{
name|assertQuery
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|limit
argument_list|,
name|materializationsEnabled
argument_list|,
name|hooks
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|checkException
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while executing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|AssertQuery
name|runs
parameter_list|()
block|{
try|try
block|{
name|assertQuery
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|limit
argument_list|,
name|materializationsEnabled
argument_list|,
name|hooks
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while executing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|AssertQuery
name|typeIs
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
try|try
block|{
name|assertQuery
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|limit
argument_list|,
literal|false
argument_list|,
name|hooks
argument_list|,
name|checkResultType
argument_list|(
name|expected
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while executing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Checks that when the query (which was set using      * {@link AssertThat#query(String)}) is converted to a relational algebra      * expression matching the given string. */
specifier|public
specifier|final
name|AssertQuery
name|convertContains
parameter_list|(
specifier|final
name|String
name|expected
parameter_list|)
block|{
return|return
name|convertMatches
argument_list|(
name|checkRel
argument_list|(
name|expected
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|convertMatches
parameter_list|(
specifier|final
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
try|try
block|{
name|assertPrepare
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|this
operator|.
name|materializationsEnabled
argument_list|,
name|checker
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while preparing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|AssertQuery
name|substitutionMatches
parameter_list|(
specifier|final
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
try|try
block|{
name|assertPrepare
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|materializationsEnabled
argument_list|,
literal|null
argument_list|,
name|checker
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while preparing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|AssertQuery
name|explainContains
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
return|return
name|explainMatches
argument_list|(
literal|""
argument_list|,
name|checkResultContains
argument_list|(
name|expected
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|final
name|AssertQuery
name|explainMatches
parameter_list|(
name|String
name|extra
parameter_list|,
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
return|return
name|returns
argument_list|(
literal|"explain plan "
operator|+
name|extra
operator|+
literal|"for "
operator|+
name|sql
argument_list|,
name|checker
argument_list|)
return|;
block|}
specifier|public
name|AssertQuery
name|planContains
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
name|ensurePlan
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Plan ["
operator|+
name|plan
operator|+
literal|"] contains ["
operator|+
name|expected
operator|+
literal|"]"
argument_list|,
name|Util
operator|.
name|toLinux
argument_list|(
name|plan
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\\\r\\\\n"
argument_list|,
literal|"\\\\n"
argument_list|)
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|AssertQuery
name|planUpdateHasSql
parameter_list|(
name|String
name|expected
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ensurePlan
argument_list|(
name|checkUpdateCount
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|=
literal|"getDataSource(), \""
operator|+
name|expected
operator|.
name|replace
argument_list|(
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\n"
argument_list|,
literal|"\\\\n"
argument_list|)
operator|+
literal|"\""
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Plan ["
operator|+
name|plan
operator|+
literal|"] contains ["
operator|+
name|expected
operator|+
literal|"]"
argument_list|,
name|Util
operator|.
name|toLinux
argument_list|(
name|plan
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\\\r\\\\n"
argument_list|,
literal|"\\\\n"
argument_list|)
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|AssertQuery
name|planHasSql
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
return|return
name|planContains
argument_list|(
literal|"getDataSource(), \""
operator|+
name|expected
operator|.
name|replace
argument_list|(
literal|"\\"
argument_list|,
literal|"\\\\"
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\""
argument_list|,
literal|"\\\""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\n"
argument_list|,
literal|"\\\\n"
argument_list|)
operator|+
literal|"\""
argument_list|)
return|;
block|}
specifier|private
name|void
name|ensurePlan
parameter_list|(
name|Function
argument_list|<
name|Integer
argument_list|,
name|Void
argument_list|>
name|checkUpdate
parameter_list|)
block|{
if|if
condition|(
name|plan
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|addHook
argument_list|(
name|Hook
operator|.
name|JAVA_PLAN
argument_list|,
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|String
name|a0
parameter_list|)
block|{
name|plan
operator|=
name|a0
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
try|try
block|{
name|assertQuery
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|limit
argument_list|,
name|materializationsEnabled
argument_list|,
name|hooks
argument_list|,
literal|null
argument_list|,
name|checkUpdate
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while executing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Runs the query and applies a checker to the generated third-party      * queries. The checker should throw to fail the test if it does not see      * what it wants. This method can be used to check whether a particular      * MongoDB or SQL query is generated, for instance. */
specifier|public
name|AssertQuery
name|queryContains
parameter_list|(
name|Function
argument_list|<
name|List
argument_list|,
name|Void
argument_list|>
name|predicate1
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|addHook
argument_list|(
name|Hook
operator|.
name|QUERY_PLAN
argument_list|,
operator|new
name|Function
argument_list|<
name|Object
argument_list|,
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|Object
name|a0
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
name|a0
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
try|try
block|{
name|assertQuery
argument_list|(
name|createConnection
argument_list|()
argument_list|,
name|sql
argument_list|,
name|limit
argument_list|,
name|materializationsEnabled
argument_list|,
name|hooks
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|predicate1
operator|.
name|apply
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"exception while executing ["
operator|+
name|sql
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Sets a limit on the number of rows returned. -1 means no limit. */
specifier|public
name|AssertQuery
name|limit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|void
name|sameResultWithMaterializationsDisabled
parameter_list|()
block|{
name|boolean
name|save
init|=
name|materializationsEnabled
decl_stmt|;
try|try
block|{
name|materializationsEnabled
operator|=
literal|false
expr_stmt|;
specifier|final
name|boolean
name|ordered
init|=
name|sql
operator|.
name|toUpperCase
argument_list|()
operator|.
name|contains
argument_list|(
literal|"ORDER BY"
argument_list|)
decl_stmt|;
specifier|final
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checker
init|=
name|consistentResult
argument_list|(
name|ordered
argument_list|)
decl_stmt|;
name|returns
argument_list|(
name|checker
argument_list|)
expr_stmt|;
name|materializationsEnabled
operator|=
literal|true
expr_stmt|;
name|returns
argument_list|(
name|checker
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|materializationsEnabled
operator|=
name|save
expr_stmt|;
block|}
block|}
specifier|public
name|AssertQuery
name|enableMaterializations
parameter_list|(
name|boolean
name|enable
parameter_list|)
block|{
name|this
operator|.
name|materializationsEnabled
operator|=
name|enable
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Adds a hook and a handler for that hook. Calcite will create a thread      * hook (by calling {@link Hook#addThread(com.google.common.base.Function)})      * just before running the query, and remove the hook afterwards. */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|AssertQuery
name|withHook
parameter_list|(
name|Hook
name|hook
parameter_list|,
name|Function
argument_list|<
name|T
argument_list|,
name|Void
argument_list|>
name|handler
parameter_list|)
block|{
name|addHook
argument_list|(
name|hook
argument_list|,
name|handler
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|addHook
parameter_list|(
name|Hook
name|hook
parameter_list|,
name|Function
argument_list|<
name|T
argument_list|,
name|Void
argument_list|>
name|handler
parameter_list|)
block|{
name|hooks
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|hook
argument_list|,
operator|(
name|Function
operator|)
name|handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Adds a property hook. */
specifier|public
parameter_list|<
name|V
parameter_list|>
name|AssertQuery
name|withProperty
parameter_list|(
name|Hook
name|hook
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|withHook
argument_list|(
name|hook
argument_list|,
name|Hook
operator|.
name|property
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Fluent interface for building a metadata query to be tested. */
specifier|public
specifier|static
class|class
name|AssertMetaData
block|{
specifier|private
specifier|final
name|ConnectionFactory
name|connectionFactory
decl_stmt|;
specifier|private
specifier|final
name|Function
argument_list|<
name|Connection
argument_list|,
name|ResultSet
argument_list|>
name|function
decl_stmt|;
name|AssertMetaData
parameter_list|(
name|ConnectionFactory
name|connectionFactory
parameter_list|,
name|Function
argument_list|<
name|Connection
argument_list|,
name|ResultSet
argument_list|>
name|function
parameter_list|)
block|{
name|this
operator|.
name|connectionFactory
operator|=
name|connectionFactory
expr_stmt|;
name|this
operator|.
name|function
operator|=
name|function
expr_stmt|;
block|}
specifier|public
specifier|final
name|AssertMetaData
name|returns
parameter_list|(
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
try|try
block|{
name|Connection
name|c
init|=
name|connectionFactory
operator|.
name|createConnection
argument_list|()
decl_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|function
operator|.
name|apply
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|checker
operator|.
name|apply
argument_list|(
name|resultSet
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|AssertMetaData
name|returns
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
return|return
name|returns
argument_list|(
name|checkResult
argument_list|(
name|expected
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Connection configuration. Basically, a set of schemas that should be    * instantiated in the connection. */
specifier|public
enum|enum
name|Config
block|{
comment|/** Configuration that creates an empty connection. */
name|EMPTY
block|,
comment|/**      * Configuration that creates a connection with two in-memory data sets:      * {@link org.apache.calcite.test.JdbcTest.HrSchema} and      * {@link org.apache.calcite.test.JdbcTest.FoodmartSchema}.      */
name|REGULAR
block|,
comment|/**      * Configuration that creates a connection with an in-memory data set      * similar to the smoke test in Cascading Lingual.      */
name|LINGUAL
block|,
comment|/**      * Configuration that creates a connection to a MySQL server. Tables      * such as "customer" and "sales_fact_1997" are available. Queries      * are processed by generating Java that calls linq4j operators      * such as      * {@link org.apache.calcite.linq4j.Enumerable#where(org.apache.calcite.linq4j.function.Predicate1)}.      */
name|JDBC_FOODMART
block|,
comment|/**      * Configuration that creates a connection to hsqldb containing the      * Scott schema via the JDBC adapter.      */
name|JDBC_SCOTT
block|,
comment|/** Configuration that contains an in-memory clone of the FoodMart      * database. */
name|FOODMART_CLONE
block|,
comment|/** Configuration that contains an in-memory clone of the FoodMart      * database, plus a lattice to enable on-the-fly materializations. */
name|JDBC_FOODMART_WITH_LATTICE
block|,
comment|/** Configuration that includes the metadata schema. */
name|REGULAR_PLUS_METADATA
block|,
comment|/** Configuration that loads the "scott/tiger" database. */
name|SCOTT
block|,
comment|/** Configuration that loads Spark. */
name|SPARK
block|,   }
comment|/** Implementation of {@link AssertQuery} that does nothing. */
specifier|private
specifier|static
class|class
name|NopAssertQuery
extends|extends
name|AssertQuery
block|{
specifier|private
name|NopAssertQuery
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|super
argument_list|(
literal|null
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Returns an implementation of {@link AssertQuery} that does nothing. */
specifier|static
name|AssertQuery
name|of
parameter_list|(
specifier|final
name|String
name|sql
parameter_list|)
block|{
return|return
operator|new
name|NopAssertQuery
argument_list|(
name|sql
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Connection
name|createConnection
parameter_list|()
throws|throws
name|Exception
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"disabled"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|returns
parameter_list|(
name|String
name|sql
parameter_list|,
name|Function
argument_list|<
name|ResultSet
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|throws_
parameter_list|(
name|String
name|message
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|runs
parameter_list|()
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|convertMatches
parameter_list|(
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|substitutionMatches
parameter_list|(
name|Function
argument_list|<
name|RelNode
argument_list|,
name|Void
argument_list|>
name|checker
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|planContains
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|planHasSql
parameter_list|(
name|String
name|expected
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|planUpdateHasSql
parameter_list|(
name|String
name|expected
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssertQuery
name|queryContains
parameter_list|(
name|Function
argument_list|<
name|List
argument_list|,
name|Void
argument_list|>
name|predicate1
parameter_list|)
block|{
return|return
name|this
return|;
block|}
block|}
comment|/** Information necessary to create a JDBC connection. Specify one to run    * tests against a different database. (hsqldb is the default.) */
specifier|public
enum|enum
name|DatabaseInstance
block|{
name|HSQLDB
argument_list|(
operator|new
name|ConnectionSpec
argument_list|(
name|FoodmartHsqldb
operator|.
name|URI
argument_list|,
literal|"FOODMART"
argument_list|,
literal|"FOODMART"
argument_list|,
literal|"org.hsqldb.jdbcDriver"
argument_list|,
literal|"foodmart"
argument_list|)
argument_list|,
operator|new
name|ConnectionSpec
argument_list|(
name|ScottHsqldb
operator|.
name|URI
argument_list|,
name|ScottHsqldb
operator|.
name|USER
argument_list|,
name|ScottHsqldb
operator|.
name|PASSWORD
argument_list|,
literal|"org.hsqldb.jdbcDriver"
argument_list|,
literal|"SCOTT"
argument_list|)
argument_list|)
block|,
name|H2
argument_list|(
operator|new
name|ConnectionSpec
argument_list|(
literal|"jdbc:h2:"
operator|+
name|getDataSetPath
argument_list|()
operator|+
literal|"/h2/target/foodmart;user=foodmart;password=foodmart"
argument_list|,
literal|"foodmart"
argument_list|,
literal|"foodmart"
argument_list|,
literal|"org.h2.Driver"
argument_list|,
literal|"foodmart"
argument_list|)
argument_list|,
literal|null
argument_list|)
block|,
name|MYSQL
argument_list|(
operator|new
name|ConnectionSpec
argument_list|(
literal|"jdbc:mysql://localhost/foodmart"
argument_list|,
literal|"foodmart"
argument_list|,
literal|"foodmart"
argument_list|,
literal|"com.mysql.jdbc.Driver"
argument_list|,
literal|"foodmart"
argument_list|)
argument_list|,
literal|null
argument_list|)
block|,
name|ORACLE
argument_list|(
operator|new
name|ConnectionSpec
argument_list|(
literal|"jdbc:oracle:thin:@localhost:1521:XE"
argument_list|,
literal|"foodmart"
argument_list|,
literal|"foodmart"
argument_list|,
literal|"oracle.jdbc.OracleDriver"
argument_list|,
literal|"FOODMART"
argument_list|)
argument_list|,
literal|null
argument_list|)
block|,
name|POSTGRESQL
argument_list|(
operator|new
name|ConnectionSpec
argument_list|(
literal|"jdbc:postgresql://localhost/foodmart?user=foodmart&password=foodmart&searchpath=foodmart"
argument_list|,
literal|"foodmart"
argument_list|,
literal|"foodmart"
argument_list|,
literal|"org.postgresql.Driver"
argument_list|,
literal|"foodmart"
argument_list|)
argument_list|,
literal|null
argument_list|)
block|;
specifier|public
specifier|final
name|ConnectionSpec
name|foodmart
decl_stmt|;
specifier|public
specifier|final
name|ConnectionSpec
name|scott
decl_stmt|;
specifier|private
specifier|static
name|String
name|getDataSetPath
parameter_list|()
block|{
name|String
name|path
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"calcite.test.dataset"
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
return|return
name|path
return|;
block|}
specifier|final
name|String
index|[]
name|dirs
init|=
block|{
literal|"../calcite-test-dataset"
block|,
literal|"../../calcite-test-dataset"
block|}
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|dirs
control|)
block|{
if|if
condition|(
operator|new
name|File
argument_list|(
name|s
argument_list|)
operator|.
name|exists
argument_list|()
operator|&&
operator|new
name|File
argument_list|(
name|s
argument_list|,
literal|"vm"
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
return|return
literal|"."
return|;
block|}
name|DatabaseInstance
parameter_list|(
name|ConnectionSpec
name|foodmart
parameter_list|,
name|ConnectionSpec
name|scott
parameter_list|)
block|{
name|this
operator|.
name|foodmart
operator|=
name|foodmart
expr_stmt|;
name|this
operator|.
name|scott
operator|=
name|scott
expr_stmt|;
block|}
block|}
comment|/** Specification for common test schemas. */
specifier|public
enum|enum
name|SchemaSpec
block|{
name|REFLECTIVE_FOODMART
block|,
name|JDBC_FOODMART
block|,
name|CLONE_FOODMART
block|,
name|JDBC_FOODMART_WITH_LATTICE
block|,
name|HR
block|,
name|JDBC_SCOTT
block|,
name|SCOTT
block|,
name|BLANK
block|,
name|LINGUAL
block|,
name|POST
block|,
name|ORINOCO
block|}
comment|/** Converts a {@link ResultSet} to string. */
specifier|static
class|class
name|ResultSetFormatter
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|public
name|ResultSetFormatter
name|resultSet
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|)
throws|throws
name|SQLException
block|{
specifier|final
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
name|rowToString
argument_list|(
name|resultSet
argument_list|,
name|metaData
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Converts one row to a string. */
name|ResultSetFormatter
name|rowToString
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|,
name|ResultSetMetaData
name|metaData
parameter_list|)
throws|throws
name|SQLException
block|{
name|int
name|n
init|=
name|metaData
operator|.
name|getColumnCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|metaData
operator|.
name|getColumnLabel
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|adjustValue
argument_list|(
name|resultSet
operator|.
name|getString
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
break|break;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|this
return|;
block|}
specifier|protected
name|String
name|adjustValue
parameter_list|(
name|String
name|string
parameter_list|)
block|{
return|return
name|string
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|toStringList
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|list
parameter_list|)
throws|throws
name|SQLException
block|{
specifier|final
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
name|rowToString
argument_list|(
name|resultSet
argument_list|,
name|metaData
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/** Flushes the buffer and returns its previous contents. */
specifier|public
name|String
name|string
parameter_list|()
block|{
name|String
name|s
init|=
name|buf
operator|.
name|toString
argument_list|()
decl_stmt|;
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End CalciteAssert.java
end_comment

end_unit

