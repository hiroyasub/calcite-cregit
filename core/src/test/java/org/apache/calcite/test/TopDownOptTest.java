begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ConventionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|VolcanoPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CoreRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinPushThroughJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|AfterAll
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_comment
comment|/**  * Unit test for top-down optimization.  *  *<p>As input, the test supplies a SQL statement and rules; the SQL is  * translated into relational algebra and then fed into a  * {@link VolcanoPlanner}. The plan before and after "optimization" is  * diffed against a reference file using {@link DiffRepository}.  *  *<p>Procedure for adding a new test case:  *  *<ol>  *<li>Add a new public test method for your rule, following the existing  * examples. You'll have to come up with an SQL statement to which your rule  * will apply in a meaningful way. See  * {@link org.apache.calcite.test.catalog.MockCatalogReaderSimple} class  * for details on the schema.  *  *<li>Run the test. It should fail. Inspect the output in  * {@code build/resources/test/.../TopDownOptTest_actual.xml}.  *  *<li>Verify that the "planBefore" is the correct  * translation of your SQL, and that it contains the pattern on which your rule  * is supposed to fire. If all is well, replace  * {@code src/test/resources/.../TopDownOptTest.xml} with  * the new {@code build/resources/test/.../TopDownOptTest_actual.xml}.  *  *<li>Run the test again. It should fail again, but this time it should contain  * a "planAfter" entry for your rule. Verify that your rule applied its  * transformation correctly, and then update the  * {@code src/test/resources/.../TopDownOptTest.xml} file again.  *  *<li>Run the test one last time; this time it should pass.  *</ol>  */
end_comment

begin_class
class|class
name|TopDownOptTest
block|{
annotation|@
name|Nullable
specifier|private
specifier|static
name|DiffRepository
name|diffRepos
init|=
literal|null
decl_stmt|;
annotation|@
name|AfterAll
specifier|public
specifier|static
name|void
name|checkActualAndReferenceFiles
parameter_list|()
block|{
if|if
condition|(
name|diffRepos
operator|!=
literal|null
condition|)
block|{
name|diffRepos
operator|.
name|checkActualAndReferenceFiles
argument_list|()
expr_stmt|;
block|}
block|}
name|RelOptFixture
name|fixture
parameter_list|()
block|{
name|RelOptFixture
name|fixture
init|=
name|RelOptFixture
operator|.
name|DEFAULT
operator|.
name|withDiffRepos
argument_list|(
name|DiffRepository
operator|.
name|lookup
argument_list|(
name|TopDownOptTest
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
name|diffRepos
operator|=
name|fixture
operator|.
name|diffRepos
argument_list|()
expr_stmt|;
return|return
name|fixture
return|;
block|}
name|RelOptFixture
name|sql
parameter_list|(
name|String
name|sql
parameter_list|,
name|Consumer
argument_list|<
name|VolcanoPlanner
argument_list|>
name|init
parameter_list|)
block|{
return|return
name|fixture
argument_list|()
operator|.
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withVolcanoPlanner
argument_list|(
literal|true
argument_list|,
name|init
argument_list|)
return|;
block|}
annotation|@
name|Test
name|void
name|testValuesTraitRequest
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT * from (values (1, 1), (2, 1), (1, 2), (2, 2))\n"
operator|+
literal|"as t(a, b) order by b, a"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testValuesTraitRequestNeg
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT * from (values (1, 1), (2, 1), (3, 2), (2, 2))\n"
operator|+
literal|"as t(a, b) order by b, a"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortAgg
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select mgr, count(*) from sales.emp\n"
operator|+
literal|"group by mgr order by mgr desc nulls last limit 5"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortAggPartialKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select mgr,deptno,comm,count(*) from sales.emp\n"
operator|+
literal|"group by mgr,deptno,comm\n"
operator|+
literal|"order by comm desc nulls last, deptno nulls first"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortMergeJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by r.job desc nulls last, r.ename nulls first"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortMergeJoinSubsetKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by r.job desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortMergeJoinSubsetKey2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job and r.sal = s.sal\n"
operator|+
literal|"order by r.sal, r.ename desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortMergeJoinSupersetKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by r.job desc nulls last, r.ename, r.sal desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortMergeJoinRight
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by s.job desc nulls last, s.ename nulls first"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortMergeJoinRightSubsetKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by s.job desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortMergeJoinRightSubsetKey2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job and r.sal = s.sal\n"
operator|+
literal|"order by s.sal, s.ename desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortMergeJoinRightSupersetKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by s.job desc nulls last, s.ename, s.sal desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|this
operator|::
name|initPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testMergeJoinDeriveLeft1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, max(sal) from sales.emp group by ename, job) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testMergeJoinDeriveLeft2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, mgr, max(sal) from sales.emp group by ename, job, mgr) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testMergeJoinDeriveRight1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.bonus s join\n"
operator|+
literal|"(select ename, job, max(sal) from sales.emp group by ename, job) r\n"
operator|+
literal|"on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testMergeJoinDeriveRight2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.bonus s join\n"
operator|+
literal|"(select ename, job, mgr, max(sal) from sales.emp group by ename, job, mgr) r\n"
operator|+
literal|"on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Order by left field(s): push down sort to left input.
annotation|@
name|Test
name|void
name|testCorrelateInnerJoinDeriveLeft
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e\n"
operator|+
literal|"join dept d on e.deptno=d.deptno\n"
operator|+
literal|"order by e.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_CORRELATE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Order by contains right field: sort cannot be pushed down.
annotation|@
name|Test
name|void
name|testCorrelateInnerJoinNoDerive
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e\n"
operator|+
literal|"join dept d on e.deptno=d.deptno\n"
operator|+
literal|"order by e.ename, d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_CORRELATE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Order by left field(s): push down sort to left input.
annotation|@
name|Test
name|void
name|testCorrelateLeftJoinDeriveLeft
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e\n"
operator|+
literal|"left join dept d on e.deptno=d.deptno\n"
operator|+
literal|"order by e.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_CORRELATE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Order by contains right field: sort cannot be pushed down.
annotation|@
name|Test
name|void
name|testCorrelateLeftJoinNoDerive
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e\n"
operator|+
literal|"left join dept d on e.deptno=d.deptno\n"
operator|+
literal|"order by e.ename, d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_CORRELATE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Order by left field(s): push down sort to left input.
annotation|@
name|Test
name|void
name|testCorrelateSemiJoinDeriveLeft
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from dept d\n"
operator|+
literal|"where exists (select 1 from emp e where e.deptno=d.deptno)\n"
operator|+
literal|"order by d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_CORRELATE
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_SEMI_JOIN
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test if "order by mgr desc nulls last" can be pushed through the projection ("select mgr").
annotation|@
name|Test
name|void
name|testSortProject
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select mgr from sales.emp order by mgr desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test that Sort cannot push through projection because of non-trival call
comment|// (e.g. RexCall(sal * -1)). In this example, the reason is that "sal * -1"
comment|// creates opposite ordering if Sort is pushed down.
annotation|@
name|Test
name|void
name|testSortProjectOnRexCall
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal * -1 as sal, mgr from\n"
operator|+
literal|"sales.emp order by ename desc, sal desc, mgr desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test that Sort can push through projection when cast is monotonic.
annotation|@
name|Test
name|void
name|testSortProjectWhenCastLeadingToMonotonic
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from sales.emp order by cast(deptno as float) desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test that Sort cannot push through projection when cast is not monotonic.
annotation|@
name|Test
name|void
name|testSortProjectWhenCastLeadingToNonMonotonic
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from sales.emp order by cast(deptno as varchar) desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// No sort on left join input.
annotation|@
name|Test
name|void
name|testSortProjectDeriveWhenCastLeadingToMonotonic
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, cast(job as varchar) as job, max_sal + 1 from\n"
operator|+
literal|"(select ename, job, max(sal) as max_sal from sales.emp group by ename, job) t) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// need sort on left join input.
annotation|@
name|Test
name|void
name|testSortProjectDeriveOnRexCall
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, sal * -1 as sal, max_job from\n"
operator|+
literal|"(select ename, sal, max(job) as max_job from sales.emp group by ename, sal) t) r\n"
operator|+
literal|"join sales.bonus s on r.sal=s.sal and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// need sort on left join input.
annotation|@
name|Test
name|void
name|testSortProjectDeriveWhenCastLeadingToNonMonotonic
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, cast(job as numeric) as job, max_sal + 1 from\n"
operator|+
literal|"(select ename, job, max(sal) as max_sal from sales.emp group by ename, job) t) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// no Sort need for left join input.
annotation|@
name|Test
name|void
name|testSortProjectDerive3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, cast(job as varchar) as job, sal + 1 from\n"
operator|+
literal|"(select ename, job, sal from sales.emp limit 100) t) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// need Sort on left join input.
annotation|@
name|Test
name|void
name|testSortProjectDerive4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, cast(job as bigint) as job, sal + 1 from\n"
operator|+
literal|"(select ename, job, sal from sales.emp limit 100) t) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test if top projection can enforce sort when inner sort cannot produce satisfying ordering.
annotation|@
name|Test
name|void
name|testSortProjectDerive5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, empno*-1, job from\n"
operator|+
literal|"(select * from sales.emp order by ename, empno, job limit 10) order by ename, job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortProjectDerive
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, max_sal + 1 from\n"
operator|+
literal|"(select ename, job, max(sal) as max_sal from sales.emp group by ename, job) t) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// need Sort on projection.
annotation|@
name|Test
name|void
name|testSortProjectDerive2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select distinct ename, sal*-2, mgr\n"
operator|+
literal|"from (select ename, mgr, sal from sales.emp order by ename, mgr, sal limit 100) t"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortProjectDerive6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select comm, deptno, slacker from\n"
operator|+
literal|"(select * from sales.emp order by comm, deptno, slacker limit 10) t\n"
operator|+
literal|"order by comm, slacker"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test traits push through filter.
annotation|@
name|Test
name|void
name|testSortFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, job, mgr, max_sal from\n"
operator|+
literal|"(select ename, job, mgr, max(sal) as max_sal from sales.emp group by ename, job, mgr) as t\n"
operator|+
literal|"where max_sal> 1000\n"
operator|+
literal|"order by mgr desc, ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test traits derivation in filter.
annotation|@
name|Test
name|void
name|testSortFilterDerive
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, max_sal from\n"
operator|+
literal|"(select ename, job, max(sal) as max_sal from sales.emp group by ename, job) t where job> 1000) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Not push down sort for hash join in full outer join case.
annotation|@
name|Test
name|void
name|testHashJoinFullOuterJoinNotPushDownSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"sales.emp r full outer join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by r.job desc nulls last, r.ename nulls first"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Push down sort to left input.
annotation|@
name|Test
name|void
name|testHashJoinLeftOuterJoinPushDownSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select contactno, email from customer.contact_peek) r left outer join\n"
operator|+
literal|"(select acctno, type from customer.account) s\n"
operator|+
literal|"on r.contactno=s.acctno and r.email=s.type\n"
operator|+
literal|"order by r.contactno desc, r.email desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Push down sort to left input.
annotation|@
name|Test
name|void
name|testHashJoinLeftOuterJoinPushDownSort2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"customer.contact_peek r left outer join\n"
operator|+
literal|"customer.account s\n"
operator|+
literal|"on r.contactno=s.acctno and r.email=s.type\n"
operator|+
literal|"order by r.fname desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Push down sort to left input.
annotation|@
name|Test
name|void
name|testHashJoinInnerJoinPushDownSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select contactno, email from customer.contact_peek) r inner join\n"
operator|+
literal|"(select acctno, type from customer.account) s\n"
operator|+
literal|"on r.contactno=s.acctno and r.email=s.type\n"
operator|+
literal|"order by r.contactno desc, r.email desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// do not push down sort.
annotation|@
name|Test
name|void
name|testHashJoinRightOuterJoinPushDownSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select contactno, email from customer.contact_peek) r right outer join\n"
operator|+
literal|"(select acctno, type from customer.account) s\n"
operator|+
literal|"on r.contactno=s.acctno and r.email=s.type\n"
operator|+
literal|"order by s.acctno desc, s.type desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// push sort to left input
annotation|@
name|Test
name|void
name|testNestedLoopJoinLeftOuterJoinPushDownSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|" customer.contact_peek r left outer join\n"
operator|+
literal|"customer.account s\n"
operator|+
literal|"on r.contactno>s.acctno and r.email<s.type\n"
operator|+
literal|"order by r.contactno desc, r.email desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// push sort to left input
annotation|@
name|Test
name|void
name|testNestedLoopJoinLeftOuterJoinPushDownSort2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|" customer.contact_peek r left outer join\n"
operator|+
literal|"customer.account s\n"
operator|+
literal|"on r.contactno>s.acctno and r.email<s.type\n"
operator|+
literal|"order by r.fname desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// do not push sort to left input cause sort keys are on right input.
annotation|@
name|Test
name|void
name|testNestedLoopJoinLeftOuterJoinSortKeyOnRightInput
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|" customer.contact_peek r left outer join\n"
operator|+
literal|"customer.account s\n"
operator|+
literal|"on r.contactno>s.acctno and r.email<s.type\n"
operator|+
literal|"order by s.acctno desc, s.type desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// do not push down sort to right input because traits propagation does not work
comment|// for right/full outer join.
annotation|@
name|Test
name|void
name|testNestedLoopJoinRightOuterJoinSortPushDown
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select r.contactno, r.email, s.acctno, s.type from\n"
operator|+
literal|" customer.contact_peek r right outer join\n"
operator|+
literal|"customer.account s\n"
operator|+
literal|"on r.contactno>s.acctno and r.email<s.type\n"
operator|+
literal|"order by s.acctno desc, s.type desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Collation can be derived from left input so that top Sort is removed.
annotation|@
name|Test
name|void
name|testHashJoinTraitDerivation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, mgr from sales.emp order by ename desc, job desc, mgr limit 10) r\n"
operator|+
literal|"join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by r.ename desc, r.job desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Collation can be derived from left input so that top Sort is removed.
annotation|@
name|Test
name|void
name|testHashJoinTraitDerivation2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, mgr from sales.emp order by mgr desc limit 10) r\n"
operator|+
literal|"join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by r.mgr desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Collation derived from left input is not what the top Sort needs.
annotation|@
name|Test
name|void
name|testHashJoinTraitDerivationNegativeCase
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, mgr from sales.emp order by mgr desc limit 10) r\n"
operator|+
literal|"join sales.bonus s on r.ename=s.ename and r.job=s.job\n"
operator|+
literal|"order by r.mgr"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Collation can be derived from left input so that top Sort is removed.
annotation|@
name|Test
name|void
name|testNestedLoopJoinTraitDerivation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, mgr from sales.emp order by ename desc, job desc, mgr limit 10) r\n"
operator|+
literal|"join sales.bonus s on r.ename>s.ename and r.job<s.job\n"
operator|+
literal|"order by r.ename desc, r.job desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Collation can be derived from left input so that top Sort is removed.
annotation|@
name|Test
name|void
name|testNestedLoopJoinTraitDerivation2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, mgr from sales.emp order by mgr limit 10) r\n"
operator|+
literal|"join sales.bonus s on r.ename>s.ename and r.job<s.job\n"
operator|+
literal|"order by r.mgr"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Collation derived from left input is not what the top Sort needs.
annotation|@
name|Test
name|void
name|testNestedLoopJoinTraitDerivationNegativeCase
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, mgr from sales.emp order by mgr limit 10) r\n"
operator|+
literal|"join sales.bonus s on r.ename>s.ename and r.job<s.job\n"
operator|+
literal|"order by r.mgr desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test if "order by mgr desc nulls last" can be pushed through the calc ("select mgr").
annotation|@
name|Test
name|void
name|testSortCalc
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select mgr from sales.emp order by mgr desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test that Sort cannot push through calc because of non-trival call
comment|// (e.g. RexCall(sal * -1)). In this example, the reason is that "sal * -1"
comment|// creates opposite ordering if Sort is pushed down.
annotation|@
name|Test
name|void
name|testSortCalcOnRexCall
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal * -1 as sal, mgr from\n"
operator|+
literal|"sales.emp order by ename desc, sal desc, mgr desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test that Sort can push through calc when cast is monotonic.
annotation|@
name|Test
name|void
name|testSortCalcWhenCastLeadingToMonotonic
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select cast(deptno as float) from sales.emp order by deptno desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test that Sort cannot push through calc when cast is not monotonic.
annotation|@
name|Test
name|void
name|testSortCalcWhenCastLeadingToNonMonotonic
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from sales.emp order by cast(deptno as varchar) desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// test traits push through calc with filter.
annotation|@
name|Test
name|void
name|testSortCalcWithFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, job, mgr, max_sal from\n"
operator|+
literal|"(select ename, job, mgr, max(sal) as max_sal from sales.emp group by ename, job, mgr) as t\n"
operator|+
literal|"where max_sal> 1000\n"
operator|+
literal|"order by mgr desc, ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Do not need Sort for calc.
annotation|@
name|Test
name|void
name|testSortCalcDerive1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, max_sal + 1 from\n"
operator|+
literal|"(select ename, job, max(sal) as max_sal from sales.emp "
operator|+
literal|"group by ename, job) t) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Need Sort for calc.
annotation|@
name|Test
name|void
name|testSortCalcDerive2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select distinct ename, sal*-2, mgr\n"
operator|+
literal|"from (select ename, mgr, sal from sales.emp order by ename, mgr, sal limit 100) t"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Do not need Sort for left join input.
annotation|@
name|Test
name|void
name|testSortCalcDerive3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, cast(job as varchar) as job, sal + 1 from\n"
operator|+
literal|"(select ename, job, sal from sales.emp limit 100) t) r\n"
operator|+
literal|"join sales.bonus s on r.job=s.job and r.ename=s.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// push sort to left input
annotation|@
name|Test
name|void
name|testBatchNestedLoopJoinLeftOuterJoinPushDownSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|" customer.contact_peek r left outer join\n"
operator|+
literal|"customer.account s\n"
operator|+
literal|"on r.contactno>s.acctno and r.email<s.type\n"
operator|+
literal|"order by r.contactno desc, r.email desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_BATCH_NESTED_LOOP_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|// Collation can be derived from left input so that top Sort is removed.
annotation|@
name|Test
name|void
name|testBatchNestedLoopJoinTraitDerivation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from\n"
operator|+
literal|"(select ename, job, mgr from sales.emp order by ename desc, job desc, mgr limit 10) r\n"
operator|+
literal|"join sales.bonus s on r.ename>s.ename and r.job<s.job\n"
operator|+
literal|"order by r.ename desc, r.job desc"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
name|p
lambda|->
block|{
name|initPlanner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|)
expr_stmt|;
name|p
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_BATCH_NESTED_LOOP_JOIN_RULE
argument_list|)
expr_stmt|;
block|}
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
name|void
name|initPlanner
parameter_list|(
name|VolcanoPlanner
name|planner
parameter_list|)
block|{
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptUtil
operator|.
name|registerDefaultRules
argument_list|(
name|planner
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Remove to Keep deterministic join order.
name|planner
operator|.
name|removeRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_COMMUTE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|removeRule
argument_list|(
name|JoinPushThroughJoinRule
operator|.
name|LEFT
argument_list|)
expr_stmt|;
name|planner
operator|.
name|removeRule
argument_list|(
name|JoinPushThroughJoinRule
operator|.
name|RIGHT
argument_list|)
expr_stmt|;
comment|// Always use sorted agg.
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORTED_AGGREGATE_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|removeRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_AGGREGATE_RULE
argument_list|)
expr_stmt|;
comment|// pushing down sort should be handled by top-down optimization.
name|planner
operator|.
name|removeRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
expr_stmt|;
comment|// Sort will only be pushed down by traits propagation.
name|planner
operator|.
name|removeRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|removeRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_COPY
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

