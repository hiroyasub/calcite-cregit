begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfigImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Contexts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepMatchOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistributions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCorrelate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|CachingRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ChainedRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|DefaultRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateExpandDistinctAggregatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateExtractProjectRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateReduceFunctionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateUnionAggregateRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateUnionTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateValuesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CalcMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CoerceInputsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|DateRangeRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ExchangeRemoveConstantKeysRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterAggregateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterMultiJoinMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterRemoveIsNotDistinctFromRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterSetOpTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterToCalcRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|IntersectToDistinctRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinAddRedundantSemiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinCommuteRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinExtractFilterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinPushExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinPushTransitivePredicatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinToMultiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinUnionTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectCorrelateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMultiJoinMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectSetOpTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectToCalcRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectToWindowRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectWindowTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|PruneEmptyRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|PushProjector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ReduceExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortRemoveConstantKeysRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortUnionTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SubQueryRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|TableScanRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionToDistinctRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ValuesReduceRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SemiJoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlToRelConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|catalog
operator|.
name|MockCatalogReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|none
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|operand
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|operandJ
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|notNullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_comment
comment|/**  * Unit test for rules in {@code org.apache.calcite.rel} and subpackages.  *  *<p>As input, the test supplies a SQL statement and a single rule; the SQL is  * translated into relational algebra and then fed into a  * {@link org.apache.calcite.plan.hep.HepPlanner}. The planner fires the rule on  * every  * pattern match in a depth-first left-to-right pre-order traversal of the tree  * for as long as the rule continues to succeed in applying its transform. (For  * rules which call transformTo more than once, only the last result is used.)  * The plan before and after "optimization" is diffed against a .ref file using  * {@link DiffRepository}.  *  *<p>Procedure for adding a new test case:  *  *<ol>  *<li>Add a new public test method for your rule, following the existing  * examples. You'll have to come up with an SQL statement to which your rule  * will apply in a meaningful way. See {@link SqlToRelTestBase} class comments  * for details on the schema.  *  *<li>Run the test. It should fail. Inspect the output in  * {@code target/surefire/.../RelOptRulesTest.xml}.  * (If you are running using maven and this file does not exist, add a  * {@code -X} flag to the maven command line.)  *  *<li>Verify that the "planBefore" is the correct  * translation of your SQL, and that it contains the pattern on which your rule  * is supposed to fire. If all is well, replace  * {@code src/test/resources/.../RelOptRulesTest.xml} and  * with the new {@code target/surefire/.../RelOptRulesTest.xml}.  *  *<li>Run the test again. It should fail again, but this time it should contain  * a "planAfter" entry for your rule. Verify that your rule applied its  * transformation correctly, and then update the  * {@code src/test/resources/.../RelOptRulesTest.xml} file again.  *  *<li>Run the test one last time; this time it should pass.  *</ol>  */
end_comment

begin_class
specifier|public
class|class
name|RelOptRulesTest
extends|extends
name|RelOptTestBase
block|{
comment|//~ Methods ----------------------------------------------------------------
specifier|private
specifier|final
name|PushProjector
operator|.
name|ExprCondition
name|skipItem
init|=
name|expr
lambda|->
name|expr
operator|instanceof
name|RexCall
operator|&&
literal|"item"
operator|.
name|equalsIgnoreCase
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|DiffRepository
name|getDiffRepos
parameter_list|()
block|{
return|return
name|DiffRepository
operator|.
name|lookup
argument_list|(
name|RelOptRulesTest
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceNot
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (select (case when sal> 1000 then null else false end) as caseCol from emp)\n"
operator|+
literal|"where NOT(caseCol)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
name|hepPlanner
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceNestedCaseWhen
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when (sal = 1000) then\n"
operator|+
literal|"(case when sal = 1000 then null else 1 end is null) else\n"
operator|+
literal|"(case when sal = 2000 then null else 1 end is null) end is true"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
name|hepPlanner
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1479">[CALCITE-1479]    * AssertionError in ReduceExpressionsRule on multi-column IN    * sub-query</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceCompositeInSubQuery
parameter_list|()
block|{
specifier|final
name|HepProgram
name|hepProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where (empno, deptno) in (\n"
operator|+
literal|"  select empno, deptno from (\n"
operator|+
literal|"    select empno, deptno\n"
operator|+
literal|"    from emp\n"
operator|+
literal|"    group by empno, deptno))\n"
operator|+
literal|"or deptno< 40 + 60"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepProgram
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2865">[CALCITE-2865]    * FilterProjectTransposeRule generates wrong traitSet when copyFilter/Project is true</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testFilterProjectTransposeRule
parameter_list|()
block|{
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|rules
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|,
comment|// default: copyFilter=true, copyProject=true
operator|new
name|FilterProjectTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|rules
control|)
block|{
name|RelBuilder
name|b
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|in
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
operator|-
literal|4
argument_list|)
comment|// salary desc
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
comment|// salary
operator|.
name|filter
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|11500
argument_list|)
argument_list|)
argument_list|)
comment|// salary = 11500
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|rule
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
comment|// Verify LogicalFilter traitSet (must be [3 DESC])
name|RelNode
name|filter
init|=
name|result
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelCollation
name|collation
init|=
name|filter
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|collation
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|collation
operator|.
name|getFieldCollations
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fieldCollations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|RelFieldCollation
name|fieldCollation
init|=
name|fieldCollations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
argument_list|,
name|fieldCollation
operator|.
name|getDirection
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceOrCaseWhen
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when sal = 1000 then null else 1 end is null\n"
operator|+
literal|"OR case when sal = 2000 then null else 1 end is null"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
name|hepPlanner
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceNullableCase
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT CASE WHEN 1=2 "
operator|+
literal|"THEN cast((values(1)) as integer) "
operator|+
literal|"ELSE 2 end from (values(1))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceNullableCase2
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, ename, CASE WHEN 1=2 "
operator|+
literal|"THEN substring(ename, 1, cast(2 as int)) ELSE NULL end from emp"
operator|+
literal|" group by deptno, ename, case when 1=2 then substring(ename,1, cast(2 as int))  else null end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectToWindowRuleForMultipleWindows
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|" count(*) over(partition by empno order by sal) as count1,\n"
operator|+
literal|" count(*) over(partition by deptno order by sal) as count2,\n"
operator|+
literal|" sum(deptno) over(partition by empno order by sal) as sum1,\n"
operator|+
literal|" sum(deptno) over(partition by deptno order by sal) as sum2\n"
operator|+
literal|"from emp"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
name|hepPlanner
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnionToDistinctRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|UnionToDistinctRule
operator|.
name|INSTANCE
argument_list|,
literal|"select * from dept union select * from dept"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExtractJoinFilterRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|JoinExtractFilterRule
operator|.
name|INSTANCE
argument_list|,
literal|"select 1 from emp inner join dept on emp.deptno=dept.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAddRedundantSemiJoinRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|,
literal|"select 1 from emp inner join dept on emp.deptno = dept.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStrengthenJoinType
parameter_list|()
block|{
comment|// The "Filter(... , right.c IS NOT NULL)" above a left join is pushed into
comment|// the join, makes it an inner join, and then disappears because c is NOT
comment|// NULL.
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept left join emp on dept.deptno = emp.deptno\n"
operator|+
literal|"where emp.deptno is not null and emp.sal> 100"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFullOuterJoinSimplificationToLeftOuter
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d full outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where d.name = 'Charlie'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFullOuterJoinSimplificationToRightOuter
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d full outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where e.sal> 100"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFullOuterJoinSimplificationToInner
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d full outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where d.name = 'Charlie' and e.sal> 100"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLeftOuterJoinSimplificationToInner
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d left outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where e.sal> 100"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRightOuterJoinSimplificationToInner
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d right outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where d.name = 'Charlie'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAgg
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select dname, c from"
operator|+
literal|" (select name dname, count(*) as c from dept group by name) t"
operator|+
literal|" where dname = 'Charlie'"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|basePushFilterPastAggWithGroupingSets
parameter_list|(
name|boolean
name|unchanged
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"${sql}"
argument_list|,
name|unchanged
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggWithGroupingSets1
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushFilterPastAggWithGroupingSets
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggWithGroupingSets2
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushFilterPastAggWithGroupingSets
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-434">[CALCITE-434]    * FilterAggregateTransposeRule loses conditions that cannot be pushed</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggTwo
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select dept1.c1 from (\n"
operator|+
literal|"  select dept.name as c1, count(*) as c2\n"
operator|+
literal|"  from dept where dept.name> 'b' group by dept.name) dept1\n"
operator|+
literal|"where dept1.c1> 'c' and (dept1.c2> 30 or dept1.c1< 'z')"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-799">[CALCITE-799]    * Incorrect result for {@code HAVING count(*)> 1}</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggThree
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by deptno having count(*)> 1"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1109">[CALCITE-1109]    * FilterAggregateTransposeRule pushes down incorrect condition</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggFour
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"select emp.deptno, count(*) from emp where emp.sal> '12' "
operator|+
literal|"group by emp.deptno\n"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-448">[CALCITE-448]    * FilterIntoJoinRule creates filters containing invalid RexInputRef</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastProject
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FilterJoinRule
operator|.
name|Predicate
name|predicate
init|=
parameter_list|(
name|join
parameter_list|,
name|joinType
parameter_list|,
name|exp
parameter_list|)
lambda|->
name|joinType
operator|!=
name|JoinRelType
operator|.
name|INNER
decl_stmt|;
specifier|final
name|FilterJoinRule
name|join
init|=
operator|new
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
argument_list|(
name|RelBuilder
operator|.
name|proto
argument_list|()
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
specifier|final
name|FilterJoinRule
name|filterOnJoin
init|=
operator|new
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
argument_list|(
literal|true
argument_list|,
name|RelBuilder
operator|.
name|proto
argument_list|()
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addGroupBegin
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|join
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|filterOnJoin
argument_list|)
operator|.
name|addGroupEnd
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join dept b on b.deptno> 10\n"
operator|+
literal|"right join dept c on b.deptno> 10\n"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|LEFT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|LEFT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join dept b on b.deptno> 10\n"
operator|+
literal|"right join dept c on b.deptno> 10\n"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1338">[CALCITE-1338]    * JoinProjectTransposeRule should not pull a literal above the    * null-generating side of a join</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (select name, 1 from dept) as b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should not transpose since the left project of right join has literal. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (select name, 1 from dept) as a\n"
operator|+
literal|"right join dept b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|LEFT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should not transpose since the right project of left join has not-strong    * expression {@code y is not null}. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (select x name, y is not null from\n"
operator|+
literal|"(values (2, cast(null as integer)), (2, 1)) as t(x, y)) b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should not transpose since the right project of left join has not-strong    * expression {@code 1 + 1}. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (select name, 1 + 1 from dept) as b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should not transpose since both the left project and right project have    * literal. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (select name, 1 from dept) a\n"
operator|+
literal|"full join (select name, 1 from dept) as b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * Should transpose since all expressions in the right project of left join    * are strong. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose7
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (select name from dept) as b\n"
operator|+
literal|" on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should transpose since all expressions including    * {@code deptno> 10 and cast(null as boolean)} in the right project of left    * join are strong. */
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose8
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (\n"
operator|+
literal|"  select name, deptno> 10 and cast(null as boolean)\n"
operator|+
literal|"  from dept) as b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-889">[CALCITE-889]    * Implement SortUnionTransposeRule</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortUnionTranspose
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortUnionTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name limit 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-889">[CALCITE-889]    * Implement SortUnionTransposeRule</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortUnionTranspose2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortUnionTransposeRule
operator|.
name|MATCH_NULL_FETCH
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-987">[CALCITE-987]    * Push limit 0 will result in an infinite loop</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortUnionTranspose3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortUnionTransposeRule
operator|.
name|MATCH_NULL_FETCH
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name limit 0"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortRemovalAllKeysConstant
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortRemoveConstantKeysRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno, sal\n"
operator|+
literal|"order by deptno desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortRemovalOneKeyConstant
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortRemoveConstantKeysRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno, sal\n"
operator|+
literal|"order by deptno, sal desc nulls first"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRuleExists
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from dept where exists (\n"
operator|+
literal|"  select * from emp\n"
operator|+
literal|"  where emp.deptno = dept.deptno\n"
operator|+
literal|"  and emp.sal> 100)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRule
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1495">[CALCITE-1495]    * SemiJoinRule should not apply to RIGHT and FULL JOIN</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRuleRight
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept right join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Similar to {@link #testSemiJoinRuleRight()} but FULL. */
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRuleFull
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept full join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Similar to {@link #testSemiJoinRule()} but LEFT. */
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRuleLeft
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name from dept left join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-438">[CALCITE-438]    * Push predicates through SemiJoin</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterThroughSemiJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select * from dept where dept.deptno in (\n"
operator|+
literal|"    select emp.deptno from emp))R\n"
operator|+
literal|"where R.deptno<=10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|false
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-571">[CALCITE-571]    * ReduceExpressionsRule tries to reduce SemiJoin condition to non-equi    * condition</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinReduceConstants
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e1.sal\n"
operator|+
literal|"from (select * from emp where deptno = 200) as e1\n"
operator|+
literal|"where e1.deptno in (\n"
operator|+
literal|"  select e2.deptno from emp e2 where e2.sal = 100)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinTrim
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
name|diffRepos
operator|.
name|expand
argument_list|(
literal|null
argument_list|,
literal|"${sql}"
argument_list|)
decl_stmt|;
name|TesterImpl
name|t
init|=
operator|(
name|TesterImpl
operator|)
name|tester
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|t
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
init|=
name|t
operator|.
name|createCatalogReader
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidator
name|validator
init|=
name|t
operator|.
name|createValidator
argument_list|(
name|catalogReader
argument_list|,
name|typeFactory
argument_list|)
decl_stmt|;
name|SqlToRelConverter
name|converter
init|=
name|t
operator|.
name|createSqlToRelConverter
argument_list|(
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlToRelConverter
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sqlQuery
init|=
name|t
operator|.
name|parseQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|validatedQuery
init|=
name|validator
operator|.
name|validate
argument_list|(
name|sqlQuery
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|converter
operator|.
name|convertQuery
argument_list|(
name|validatedQuery
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|decorrelate
argument_list|(
name|sqlQuery
argument_list|,
name|root
operator|.
name|rel
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|root
operator|.
name|rel
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|planner
operator|.
name|findBestExp
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|converter
operator|=
name|t
operator|.
name|createSqlToRelConverter
argument_list|(
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlToRelConverter
operator|.
name|configBuilder
argument_list|()
operator|.
name|withTrimUnusedFields
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|trimUnusedFields
argument_list|(
literal|false
argument_list|,
name|root
operator|.
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceAverage
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|AggregateReduceFunctionsRule
operator|.
name|INSTANCE
argument_list|,
literal|"select name, max(name), avg(deptno), min(name)"
operator|+
literal|" from sales.dept group by name"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1621">[CALCITE-1621]    * Adding a cast around the null literal in aggregate rules</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testCastInAggregateReduceFunctions
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateReduceFunctionsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),"
operator|+
literal|" stddev_samp(deptno),var_pop(deptno), var_samp(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountWithoutGroupBy
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select max(deptno), count(distinct ename)\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCount1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename)"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCount2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename), sum(sal)"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1293">[CALCITE-1293]    * Bad code generated when argument to COUNT(DISTINCT) is a # GROUP BY    * column</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCount3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(distinct deptno), sum(sal)"
operator|+
literal|" from sales.emp group by deptno"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests implementing multiple distinct count the old way, using a join. */
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMultipleViaJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename), count(distinct job, ename),\n"
operator|+
literal|"  count(distinct deptno, job), sum(sal)\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests implementing multiple distinct count the new way, using GROUPING    *  SETS. */
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMultiple
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename), count(distinct job)\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMultipleNoGroup
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(distinct ename), count(distinct job)\n"
operator|+
literal|" from sales.emp"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMixedJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename), count(distinct job, ename),\n"
operator|+
literal|"  count(distinct deptno, job), sum(sal)\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMixed
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct deptno, job) as cddj, sum(sal) as s\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMixed2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename) as cde,\n"
operator|+
literal|"  count(distinct job, ename) as cdje,\n"
operator|+
literal|"  count(distinct deptno, job) as cddj,\n"
operator|+
literal|"  sum(sal) as s\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountGroupingSets1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, job, count(distinct ename)"
operator|+
literal|" from sales.emp group by rollup(deptno,job)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountGroupingSets2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, job, count(distinct ename), sum(sal)"
operator|+
literal|" from sales.emp group by rollup(deptno,job)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctNonDistinctAggregates
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select emp.empno, count(*), avg(distinct dept.deptno)\n"
operator|+
literal|"from sales.emp emp inner join sales.dept dept\n"
operator|+
literal|"on emp.deptno = dept.deptno\n"
operator|+
literal|"group by emp.empno"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1621">[CALCITE-1621]    * Adding a cast around the null literal in aggregate rules</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testCastInAggregateExpandDistinctAggregatesRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name, sum(distinct cn), sum(distinct sm)\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select name, count(dept.deptno) as cn,sum(dept.deptno) as sm\n"
operator|+
literal|"  from sales.dept group by name)\n"
operator|+
literal|"group by name"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1558">[CALCITE-1558]    * AggregateExpandDistinctAggregatesRule gets field mapping wrong if groupKey    * is used in aggregate function</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testDistinctNonDistinctAggregatesWithGrouping1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|"  SUM(deptno), SUM(DISTINCT sal), MAX(deptno), MAX(comm)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctNonDistinctAggregatesWithGrouping2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, COUNT(deptno), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctNonDistinctTwoAggregatesWithGrouping
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(comm), MIN(comm), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctWithGrouping
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT sal, SUM(comm), MIN(comm), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY sal"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultipleDistinctWithGrouping
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT sal, SUM(comm), MIN(DISTINCT comm), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY sal"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctWithMultipleInputs
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(comm), MIN(comm), COUNT(DISTINCT sal, comm)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctWithMultipleInputsAndGroupby
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(comm), MIN(comm), COUNT(DISTINCT sal, deptno, comm)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFilter
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select empno + deptno from emp where sal = 10 * comm "
operator|+
literal|"and upper(ename) = 'FOO'"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1778">[CALCITE-1778]    * Query with "WHERE CASE" throws AssertionError "Cast for just nullability    * not allowed"</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFilter2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when mgr< 10 then true else false end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastJoin
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select e.sal + b.comm from emp e inner join bonus b "
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectCorrelateTransposeDynamic
parameter_list|()
block|{
name|ProjectCorrelateTransposeRule
name|customPCTrans
init|=
operator|new
name|ProjectCorrelateTransposeRule
argument_list|(
name|skipItem
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|HepProgramBuilder
name|programBuilder
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|customPCTrans
argument_list|)
decl_stmt|;
name|String
name|query
init|=
literal|"select t1.c_nationkey, t2.a as fake_col2 "
operator|+
literal|"from SALES.CUSTOMER as t1, "
operator|+
literal|"unnest(t1.fake_col) as t2(a)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|createDynamicTester
argument_list|()
argument_list|,
literal|null
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|programBuilder
operator|.
name|build
argument_list|()
argument_list|)
argument_list|,
name|query
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectCorrelateTransposeRuleLeftCorrelate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e1.empno\n"
operator|+
literal|"FROM emp e1 "
operator|+
literal|"where exists (select empno, deptno from dept d2 where e1.deptno = d2.deptno)"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectCorrelateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|expand
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectCorrelateTransposeRuleSemiCorrelate
parameter_list|()
block|{
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|left
init|=
name|relBuilder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"f"
block|,
literal|"f2"
block|}
argument_list|,
literal|"1"
argument_list|,
literal|"2"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|CorrelationId
name|correlationId
init|=
operator|new
name|CorrelationId
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|rexCorrel
init|=
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCorrel
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
argument_list|,
name|correlationId
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|relBuilder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"f3"
block|,
literal|"f4"
block|}
argument_list|,
literal|"1"
argument_list|,
literal|"2"
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|rexCorrel
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|LogicalCorrelate
name|correlate
init|=
operator|new
name|LogicalCorrelate
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
argument_list|,
name|left
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|correlationId
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SemiJoinType
operator|.
name|SEMI
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|correlate
argument_list|)
expr_stmt|;
name|RelNode
name|relNode
init|=
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectCorrelateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|relNode
argument_list|)
expr_stmt|;
name|RelNode
name|output
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|output
argument_list|)
decl_stmt|;
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
name|SqlToRelTestBase
operator|.
name|assertValid
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectCorrelateTransposeRuleAntiCorrelate
parameter_list|()
block|{
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|left
init|=
name|relBuilder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"f"
block|,
literal|"f2"
block|}
argument_list|,
literal|"1"
argument_list|,
literal|"2"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|CorrelationId
name|correlationId
init|=
operator|new
name|CorrelationId
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|rexCorrel
init|=
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCorrel
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
argument_list|,
name|correlationId
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|relBuilder
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"f3"
block|,
literal|"f4"
block|}
argument_list|,
literal|"1"
argument_list|,
literal|"2"
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|rexCorrel
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|LogicalCorrelate
name|correlate
init|=
operator|new
name|LogicalCorrelate
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
argument_list|,
name|left
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|correlationId
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SemiJoinType
operator|.
name|ANTI
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|correlate
argument_list|)
expr_stmt|;
name|RelNode
name|relNode
init|=
name|relBuilder
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectCorrelateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|relNode
argument_list|)
expr_stmt|;
name|RelNode
name|output
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|output
argument_list|)
decl_stmt|;
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
name|SqlToRelTestBase
operator|.
name|assertValid
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectCorrelateTransposeWithExprCond
parameter_list|()
block|{
name|ProjectCorrelateTransposeRule
name|customPCTrans
init|=
operator|new
name|ProjectCorrelateTransposeRule
argument_list|(
name|skipItem
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|checkPlanning
argument_list|(
name|customPCTrans
argument_list|,
literal|"select t1.name, t2.ename "
operator|+
literal|"from DEPT_NESTED as t1, "
operator|+
literal|"unnest(t1.employees) as t2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectCorrelateTranspose
parameter_list|()
block|{
name|ProjectCorrelateTransposeRule
name|customPCTrans
init|=
operator|new
name|ProjectCorrelateTransposeRule
argument_list|(
name|expr
lambda|->
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|checkPlanning
argument_list|(
name|customPCTrans
argument_list|,
literal|"select t1.name, t2.ename "
operator|+
literal|"from DEPT_NESTED as t1, "
operator|+
literal|"unnest(t1.employees) as t2"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that the default instance of {@link FilterProjectTransposeRule}    * does not push a Filter that contains a correlating variable.    *    * @see #testFilterProjectTranspose() */
annotation|@
name|Test
specifier|public
name|void
name|testFilterProjectTransposePreventedByCorrelation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.empno\n"
operator|+
literal|"FROM emp as e\n"
operator|+
literal|"WHERE exists (\n"
operator|+
literal|"  SELECT *\n"
operator|+
literal|"  FROM (\n"
operator|+
literal|"    SELECT deptno * 2 AS twiceDeptno\n"
operator|+
literal|"    FROM dept) AS d\n"
operator|+
literal|"  WHERE e.deptno = d.twiceDeptno)"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|expand
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Tests a variant of {@link FilterProjectTransposeRule}    * that pushes a Filter that contains a correlating variable. */
annotation|@
name|Test
specifier|public
name|void
name|testFilterProjectTranspose
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.empno\n"
operator|+
literal|"FROM emp as e\n"
operator|+
literal|"WHERE exists (\n"
operator|+
literal|"  SELECT *\n"
operator|+
literal|"  FROM (\n"
operator|+
literal|"    SELECT deptno * 2 AS twiceDeptno\n"
operator|+
literal|"    FROM dept) AS d\n"
operator|+
literal|"  WHERE e.deptno = d.twiceDeptno)"
decl_stmt|;
specifier|final
name|FilterProjectTransposeRule
name|filterProjectTransposeRule
init|=
operator|new
name|FilterProjectTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|filter
lambda|->
literal|true
argument_list|,
name|Project
operator|.
name|class
argument_list|,
name|project
lambda|->
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|filterProjectTransposeRule
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|expand
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|NOT_STRONG_EXPR
init|=
literal|"case when e.sal< 11 then 11 else -1 * e.sal end"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|STRONG_EXPR
init|=
literal|"case when e.sal< 11 then -1 * e.sal else e.sal end"
decl_stmt|;
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1753">[CALCITE-1753]    * PushProjector should only preserve expressions if the expression is strong    * when pushing into the nullable-side of outer join</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastInnerJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e inner join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastInnerJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e inner join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastLeftJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e left outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by case when e.sal< 11 then 11 else -1 * e.sal end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastLeftJoinSwap
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b left outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastLeftJoinSwapStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b left outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastRightJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e right outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastRightJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*),\n"
operator|+
literal|" case when e.sal< 11 then -1 * e.sal else e.sal end\n"
operator|+
literal|"from emp e right outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by case when e.sal< 11 then -1 * e.sal else e.sal end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastRightJoinSwap
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b right outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastRightJoinSwapStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b right outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFullJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e full outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFullJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e full outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2343">[CALCITE-2343]    * Should not push over whose columns are all from left child past join since    * join will affect row count.</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectWithOverPastJoin1
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select e.sal + b.comm,\n"
operator|+
literal|"count(e.empno) over (partition by e.deptno)\n"
operator|+
literal|"from emp e join bonus b\n"
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
argument_list|)
expr_stmt|;
block|}
comment|/** As {@link #testPushProjectWithOverPastJoin1()};    * should not push over whose columns are all from right child past join since    * join will affect row count. */
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectWithOverPastJoin2
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select e.sal + b.comm,\n"
operator|+
literal|"count(b.sal) over (partition by b.job)\n"
operator|+
literal|"from emp e join bonus b\n"
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
argument_list|)
expr_stmt|;
block|}
comment|/** As {@link #testPushProjectWithOverPastJoin2()};    * should not push over past join but should push the operands of over past    * join. */
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectWithOverPastJoin3
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select e.sal + b.comm,\n"
operator|+
literal|"sum(b.sal + b.sal + 100) over (partition by b.job)\n"
operator|+
literal|"from emp e join bonus b\n"
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastSetOp
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select sal from "
operator|+
literal|"(select * from emp e1 union all select * from emp e2)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushJoinThroughUnionOnLeft
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|JoinUnionTransposeRule
operator|.
name|LEFT_UNION
argument_list|,
literal|"select r1.sal from "
operator|+
literal|"(select * from emp e1 union all select * from emp e2) r1, "
operator|+
literal|"emp r2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushJoinThroughUnionOnRight
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|JoinUnionTransposeRule
operator|.
name|RIGHT_UNION
argument_list|,
literal|"select r1.sal from "
operator|+
literal|"emp r1, "
operator|+
literal|"(select * from emp e1 union all select * from emp e2) r2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"cycles"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testMergeFilterWithJoinCondition
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|TableScanRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinExtractFilterRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CalcMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select d.name as dname,e.ename as ename"
operator|+
literal|" from emp e inner join dept d"
operator|+
literal|" on e.deptno=d.deptno"
operator|+
literal|" where d.name='Propane'"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that filters are combined if they are identical. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select name from (\n"
operator|+
literal|"  select *\n"
operator|+
literal|"  from dept\n"
operator|+
literal|"  where deptno = 10)\n"
operator|+
literal|"where deptno = 10\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests to see if the final branch of union is missed */
annotation|@
name|Test
specifier|public
name|void
name|testUnionMergeRule
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from (\n"
operator|+
literal|"  select name, deptno from dept\n"
operator|+
literal|"  union all\n"
operator|+
literal|"  select name, deptno from\n"
operator|+
literal|"  (\n"
operator|+
literal|"    select name, deptno, count(1) from dept group by name, deptno\n"
operator|+
literal|"    union all\n"
operator|+
literal|"    select name, deptno, count(1) from dept group by name, deptno\n"
operator|+
literal|"  ) subq\n"
operator|+
literal|") a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name, deptno from dept\n"
operator|+
literal|") aa\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMinusMergeRule
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from (\n"
operator|+
literal|"  select name, deptno from\n"
operator|+
literal|"  (\n"
operator|+
literal|"    select name, deptno, count(1) from dept group by name, deptno\n"
operator|+
literal|"    except all\n"
operator|+
literal|"    select name, deptno, 1 from dept\n"
operator|+
literal|"  ) subq\n"
operator|+
literal|"  except all\n"
operator|+
literal|"  select name, deptno from\n"
operator|+
literal|"  (\n"
operator|+
literal|"    select name, deptno, 1 from dept\n"
operator|+
literal|"    except all\n"
operator|+
literal|"    select name, deptno, count(1) from dept group by name, deptno\n"
operator|+
literal|"  ) subq2\n"
operator|+
literal|") a\n"
operator|+
literal|"except all\n"
operator|+
literal|"select name, deptno from dept\n"
operator|+
literal|") aa\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a filters is combined are combined if they are identical,    * even if one of them originates in an ON clause of a JOIN. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeJoinFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"  select d.deptno, e.ename\n"
operator|+
literal|"  from emp as e\n"
operator|+
literal|"  join dept as d\n"
operator|+
literal|"  on e.deptno = d.deptno\n"
operator|+
literal|"  and d.deptno = 10)\n"
operator|+
literal|"where deptno = 10\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule}, which merges 2 {@link Union} operators into    * a single {@code Union} with 3 inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeUnionAll
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule}, which merges 2 {@link Union}    * {@code DISTINCT} (not {@code ALL}) operators into a single    * {@code Union} with 3 inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeUnionDistinct
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union distinct\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union\n"
comment|// same as 'union distinct'
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link UnionMergeRule} does nothing if its arguments have    * different {@code ALL} settings. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeUnionMixed
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link UnionMergeRule} converts all inputs to DISTINCT    * if the top one is DISTINCT.    * (Since UNION is left-associative, the "top one" is the rightmost.) */
annotation|@
name|Test
specifier|public
name|void
name|testMergeUnionMixed2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link UnionMergeRule} does nothing if its arguments have    * are different set operators, {@link Union} and {@link Intersect}. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeSetOpMixed
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule#INTERSECT_INSTANCE}, which merges 2    * {@link Intersect} operators into a single {@code Intersect} with 3    * inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeIntersect
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link org.apache.calcite.rel.rules.IntersectToDistinctRule},    * which rewrites an {@link Intersect} operator with 3 inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testIntersectToDistinct
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|IntersectToDistinctRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link org.apache.calcite.rel.rules.IntersectToDistinctRule}    * correctly ignores an {@code INTERSECT ALL}. It can only handle    * {@code INTERSECT DISTINCT}. */
annotation|@
name|Test
specifier|public
name|void
name|testIntersectToDistinctAll
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|IntersectToDistinctRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule#MINUS_INSTANCE}, which merges 2    * {@link Minus} operators into a single {@code Minus} with 3    * inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeMinus
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule#MINUS_INSTANCE}    * does not merge {@code Minus(a, Minus(b, c))}    * into {@code Minus(a, b, c)}, which would be incorrect. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeMinusRightDeep
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (\n"
operator|+
literal|"  select * from emp where deptno = 20\n"
operator|+
literal|"  except\n"
operator|+
literal|"  select * from emp where deptno = 30)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"cycles"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testHeterogeneousConversion
parameter_list|()
throws|throws
name|Exception
block|{
comment|// This one tests the planner's ability to correctly
comment|// apply different converters on top of a common
comment|// sub-expression.  The common sub-expression is the
comment|// reference to the table sales.emps.  On top of that
comment|// are two projections, unioned at the top.  For one
comment|// of the projections, we force a Fennel implementation.
comment|// For the other, we force a Java implementation.
comment|// Then, we request conversion from Fennel to Java,
comment|// and verify that it only applies to one usage of the
comment|// table, not both (which would be incorrect).
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|TableScanRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
comment|// Control the calc conversion.
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
comment|// Let the converter rule fire to its heart's content.
operator|.
name|addMatchLimit
argument_list|(
name|HepProgram
operator|.
name|MATCH_UNTIL_FIXPOINT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select upper(ename) from emp union all"
operator|+
literal|" select lower(ename) from emp"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastJoinRuleLeft
parameter_list|()
throws|throws
name|Exception
block|{
comment|// tests the case where the semijoin is pushed to the left
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and e1.empno = e2.empno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastJoinRuleRight
parameter_list|()
throws|throws
name|Exception
block|{
comment|// tests the case where the semijoin is pushed to the right
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.ename from emp e, dept d "
operator|+
literal|"where e.deptno = d.deptno and e.ename = 'foo'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRule
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinToMultiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testManyFiltersOnTopOfMultiJoinShouldCollapse
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinToMultiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleCollection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|FilterMultiJoinMergeRule
operator|.
name|INSTANCE
argument_list|,
name|ProjectMultiJoinMergeRule
operator|.
name|INSTANCE
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (select * from emp e1 left outer join dept d on e1.deptno = d.deptno "
operator|+
literal|"where d.deptno> 3) where ename LIKE 'bar'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstants
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// NOTE jvs 27-May-2006: among other things, this verifies
comment|// intentionally different treatment for identical coalesce expression
comment|// in select and where.
comment|// There is "CAST(2 AS INTEGER)" in the plan because 2 has type "INTEGER NOT
comment|// NULL" and we need "INTEGER".
specifier|final
name|String
name|sql
init|=
literal|"select"
operator|+
literal|" 1+2, d.deptno+(3+4), (5+6)+d.deptno, cast(null as integer),"
operator|+
literal|" coalesce(2,null), row(7+8)"
operator|+
literal|" from dept d inner join emp e"
operator|+
literal|" on d.deptno = e.deptno + (5-5)"
operator|+
literal|" where d.deptno=(7+8) and d.deptno=(8+7) and d.deptno=coalesce(2,null)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-570">[CALCITE-570]    * ReduceExpressionsRule throws "duplicate key" exception</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsDup
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno"
operator|+
literal|" from dept d"
operator|+
literal|" where d.deptno=7 and d.deptno=8"
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-935">[CALCITE-935]    * Improve how ReduceExpressionsRule handles duplicate constraints</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsDup2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where deptno=7 and deptno=8\n"
operator|+
literal|"and empno = 10 and mgr is null and empno = 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullNull
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where deptno=7\n"
operator|+
literal|"and empno = 10 and mgr is null and empno = 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrAlwaysTrue
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from EMPNULLABLES_20\n"
operator|+
literal|"where sal is null or sal is not null"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrAlwaysTrue2
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from EMPNULLABLES_20\n"
operator|+
literal|"where sal is not null or sal is null"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstants2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"select p1 is not distinct from p0 from (values (2, cast(null as integer))) as t(p0, p1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstants3
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.mgr is not distinct from f.mgr "
operator|+
literal|"from emp e join emp f on (e.mgr=f.mgr) where e.mgr is null"
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-902">[CALCITE-902]    * Match nullability when reducing expressions in a Project</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsProjectNullable
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select mgr from emp where mgr=10"
argument_list|)
expr_stmt|;
block|}
comment|// see HIVE-9645
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsNullEqualsOne
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(1) from emp where cast(null as integer) = 1"
argument_list|)
expr_stmt|;
block|}
comment|// see HIVE-9644
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCaseEquals
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Equivalent to 'deptno = 10'
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  else 3 end = 1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCaseEquals2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Equivalent to 'case when deptno = 20 then false
comment|//                     when deptno = 10 then true
comment|//                     else null end'
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  else cast(null as integer) end = 1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCaseEquals3
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Equivalent to 'deptno = 30 or deptno = 10'
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 30 then 1\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  when 30 then 111\n"
operator|+
literal|"  else 0 end = 1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSkipReduceConstantsCaseEquals
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp e1, emp e2\n"
operator|+
literal|"where coalesce(e1.mgr, -1) = coalesce(e2.mgr, -1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsEliminatesFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// WHERE NULL is the same as WHERE FALSE, so get empty result
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (values (1,2)) where 1 + 2> 3 + CAST(NULL AS INTEGER)"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1860">[CALCITE-1860]    * Duplicate null predicates cause NullPointerException in RexUtil</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsNull
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select *\n"
operator|+
literal|"  from (\n"
operator|+
literal|"    select cast(null as integer) as n\n"
operator|+
literal|"    from emp)\n"
operator|+
literal|"  where n is null and n is null)\n"
operator|+
literal|"where n is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-566">[CALCITE-566]    * ReduceExpressionsRule requires planner to have an Executor</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsRequiresExecutor
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Remove the executor
name|tester
operator|.
name|convertSqlToRel
argument_list|(
literal|"values 1"
argument_list|)
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|setExecutor
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Rule should not fire, but there should be no NPE
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1,2)) where 1 + 2> 3 + CAST(NULL AS INTEGER)"
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAlreadyFalseEliminatesFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (values (1,2)) where false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCalc
parameter_list|()
throws|throws
name|Exception
block|{
comment|// This reduction does not work using
comment|// ReduceExpressionsRule.PROJECT_INSTANCE or FILTER_INSTANCE,
comment|// only CALC_INSTANCE, because we need to pull the project expression
comment|//    upper('table')
comment|// into the condition
comment|//    upper('table') = 'TABLE'
comment|// and reduce it to TRUE. Only in the Calc are projects and conditions
comment|// combined.
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CalcMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
comment|// the hard part is done... a few more rule calls to clean up
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CalcMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Result should be same as typing
comment|//  SELECT * FROM (VALUES ('TABLE        ', 'T')) AS T(U, S)
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"  select upper(substring(x FROM 1 FOR 2) || substring(x FROM 3)) as u,\n"
operator|+
literal|"      substring(x FROM 1 FOR 1) as s\n"
operator|+
literal|"  from (\n"
operator|+
literal|"    select 'table' as x from (values (true))\n"
operator|+
literal|"    union\n"
operator|+
literal|"    select 'view' from (values (true))\n"
operator|+
literal|"    union\n"
operator|+
literal|"    select 'foreign table' from (values (true))\n"
operator|+
literal|"  )\n"
operator|+
literal|") where u = 'TABLE'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.ename from emp e, dept d "
operator|+
literal|"where e.deptno = d.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinWithFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.ename from emp e, dept d "
operator|+
literal|"where e.deptno = d.deptno and e.ename = 'foo'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinRight
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinRightWithFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno "
operator|+
literal|"and d.name = 'foo'"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkPlanning
parameter_list|(
name|String
name|query
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|tester1
init|=
name|tester
operator|.
name|withCatalogReaderFactory
argument_list|(
parameter_list|(
name|typeFactory
parameter_list|,
name|caseSensitive
parameter_list|)
lambda|->
operator|new
name|MockCatalogReader
argument_list|(
name|typeFactory
argument_list|,
name|caseSensitive
argument_list|)
block|{
block_content|@Override public MockCatalogReader init(
argument_list|)
block|{
comment|// CREATE SCHEMA abc;
comment|// CREATE TABLE a(a INT);
comment|// ...
comment|// CREATE TABLE j(j INT);
name|MockSchema
name|schema
operator|=
operator|new
name|MockSchema
argument_list|(
literal|"SALES"
argument_list|)
block|;
name|registerSchema
argument_list|(
name|schema
argument_list|)
block|;
name|final
name|RelDataType
name|intType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|String
name|t
init|=
name|String
operator|.
name|valueOf
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'A'
operator|+
name|i
operator|)
argument_list|)
decl_stmt|;
name|MockTable
name|table
init|=
name|MockTable
operator|.
name|create
argument_list|(
name|this
argument_list|,
name|schema
argument_list|,
name|t
argument_list|,
literal|false
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|table
operator|.
name|addColumn
argument_list|(
name|t
argument_list|,
name|intType
argument_list|)
expr_stmt|;
name|registerTable
argument_list|(
name|table
argument_list|)
expr_stmt|;
block_content|}
block|return this
empty_stmt|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
block|)
class|;
end_class

begin_decl_stmt
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinToMultiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|checkPlanning
argument_list|(
name|tester1
argument_list|,
literal|null
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|query
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}    @
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins
parameter_list|()
throws|throws
name|Exception
block|{
name|checkPlanning
argument_list|(
literal|"select * from "
operator|+
literal|"    (select * from "
operator|+
literal|"        (select * from "
operator|+
literal|"            (select * from A right outer join B on a = b) "
operator|+
literal|"            left outer join "
operator|+
literal|"            (select * from C full outer join D on c = d)"
operator|+
literal|"            on a = c and b = d) "
operator|+
literal|"        right outer join "
operator|+
literal|"        (select * from "
operator|+
literal|"            (select * from E full outer join F on e = f) "
operator|+
literal|"            right outer join "
operator|+
literal|"            (select * from G left outer join H on g = h) "
operator|+
literal|"            on e = g and f = h) "
operator|+
literal|"        on a = e and b = f and c = g and d = h) "
operator|+
literal|"    inner join "
operator|+
literal|"    (select * from I inner join J on i = j) "
operator|+
literal|"    on a = i and h = j"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins2
parameter_list|()
throws|throws
name|Exception
block|{
comment|// in (A right join B) join C, pushing C is not allowed;
comment|// therefore there should be 2 MultiJoin
name|checkPlanning
argument_list|(
literal|"select * from A right join B on a = b join C on b = c"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins3
parameter_list|()
throws|throws
name|Exception
block|{
comment|// in (A join B) left join C, pushing C is allowed;
comment|// therefore there should be 1 MultiJoin
name|checkPlanning
argument_list|(
literal|"select * from A join B on a = b left join C on b = c"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins4
parameter_list|()
throws|throws
name|Exception
block|{
comment|// in (A join B) right join C, pushing C is not allowed;
comment|// therefore there should be 2 MultiJoin
name|checkPlanning
argument_list|(
literal|"select * from A join B on a = b right join C on b = c"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastProject
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.* from "
operator|+
literal|"(select ename, trim(job), sal * 2, deptno from emp) e, dept d "
operator|+
literal|"where e.deptno = d.deptno"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select a, b from (values (10,'x')) as t(a, b)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a, b from (values (10, 'x'), (20, 'y')) as t(a, b) where a< 15"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderProject
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select a, b as x from (values (11), (23)) as t(x)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b from (values (10, 1), (20, 3)) as t(a, b)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderProjectFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (11, 1, 10), (23, 3, 20)) as t(x, b, a)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b as x, b, a from (values (10, 1), (30, 7), (20, 3)) as t(a, b)"
operator|+
literal|" where a - b< 21"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1439">[CALCITE-1439]    * Handling errors during constant reduction</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceCase
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|"  case when false then cast(2.1 as float)\n"
operator|+
literal|"   else cast(1 as integer) end as newcol\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkReduceNullableToNotNull
parameter_list|(
name|ReduceExpressionsRule
name|rule
parameter_list|)
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|rule
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|"  empno + case when 'a' = 'a' then 1 else null end as newcol\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case that reduces a nullable expression to a NOT NULL literal that    *  is cast to nullable. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceNullableToNotNull
parameter_list|()
throws|throws
name|Exception
block|{
name|checkReduceNullableToNotNull
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case that reduces a nullable expression to a NOT NULL literal. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceNullableToNotNull2
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|ReduceExpressionsRule
operator|.
name|ProjectReduceExpressionsRule
name|rule
init|=
operator|new
name|ReduceExpressionsRule
operator|.
name|ProjectReduceExpressionsRule
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
literal|false
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|checkReduceNullableToNotNull
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsIsNull
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select empno from emp where empno=10 and empno is null"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsIsNotNull
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp\n"
operator|+
literal|"where empno=10 and empno is not null"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsNegated
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp\n"
operator|+
literal|"where empno=10 and not(empno=10)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsNegatedInverted
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp where empno>10 and empno<=10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2638">[CALCITE-2638]    * Constant reducer must not duplicate calls to non-deterministic    * functions</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsNonDeterministicFunction
parameter_list|()
block|{
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
specifier|final
name|SqlOperator
name|nonDeterministicOp
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"NDC"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|INTEGER
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
comment|// Build a tree equivalent to the SQL
comment|//  SELECT sal, n
comment|//  FROM (SELECT sal, NDC() AS n FROM emp)
comment|//  WHERE n> 10
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|nonDeterministicOp
argument_list|)
argument_list|,
literal|"N"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"N"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|prePlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|preProgram
argument_list|)
decl_stmt|;
name|prePlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|relBefore
init|=
name|prePlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relBefore
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|relAfter
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Checks that constant reducer duplicates calls to dynamic functions, if    * appropriate. CURRENT_TIMESTAMP is a dynamic function. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsDynamicFunction
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sal, t\n"
operator|+
literal|"from (select sal, current_timestamp t from emp)\n"
operator|+
literal|"where t> TIMESTAMP '2018-01-01 00:00:00'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testCasePushIsAlwaysWorking
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp"
operator|+
literal|" where case when sal> 1000 then empno else sal end = 1"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Ignore
comment|// Calcite does not support INSERT yet
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesNull
parameter_list|()
throws|throws
name|Exception
block|{
comment|// The NULL literal presents pitfalls for value-reduction. Only
comment|// an INSERT statement contains un-CASTed NULL values.
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"insert into sales.depts(deptno,name) values (NULL, 'null')"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesToEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (11, 1, 10), (23, 3, 20)) as t(x, b, a)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b as x, b, a from (values (10, 1), (30, 7)) as t(a, b)"
operator|+
literal|" where a - b< 0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsWindow
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectWindowTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|WINDOW_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select col1, col2, col3\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select empno,\n"
operator|+
literal|"    sum(100) over (partition by deptno, sal order by sal) as col1,\n"
operator|+
literal|"    sum(100) over (partition by sal order by deptno) as col2,\n"
operator|+
literal|"    sum(sal) over (partition by deptno order by sal) as col3\n"
operator|+
literal|"  from emp where sal = 5000)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyFilterProjectUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (30, 3)) as t(x, y)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from (values (20, 2))\n"
operator|+
literal|")\n"
operator|+
literal|"where x + y> 30"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1488">[CALCITE-1488]    * ValuesReduceRule should ignore empty Values</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyProject
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select z + x from (\n"
operator|+
literal|"  select x + y as z, x from (\n"
operator|+
literal|"    select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"    where x + y> 50))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Same query as {@link #testEmptyProject()}, and {@link PruneEmptyRules}    * is able to do the job that {@link ValuesReduceRule} cannot do. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyProject2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select z + x from (\n"
operator|+
literal|"  select x + y as z, x from (\n"
operator|+
literal|"    select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"    where x + y> 50))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyIntersect
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3))"
operator|+
literal|"intersect\n"
operator|+
literal|"select *\nfrom (values (10, 1), (30, 3)) as t (x, y) where x> 50\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from (values (30, 3))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyMinus
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// First input is empty; therefore whole expression is empty
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3)) as t (x, y)\n"
operator|+
literal|"where x> 30\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (20, 2))\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (40, 4))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyMinus2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Second and fourth inputs are empty; they are removed
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3)) as t (x, y)\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (20, 2)) as t (x, y) where x> 30\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (40, 4))\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (50, 5)) as t (x, y) where x> 50"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoin
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be empty
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"select * from emp where false) as e\n"
operator|+
literal|"join dept as d on e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoinLeft
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be empty
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select * from emp where false) e\n"
operator|+
literal|"left join dept d on e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoinRight
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be equivalent to "select * from emp join dept".
comment|// Cannot optimize away the join because of RIGHT.
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select * from emp where false) e\n"
operator|+
literal|"right join dept d on e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptySort
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|SORT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp where false order by deptno"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptySortLimitZero
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|SORT_FETCH_ZERO_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp order by deptno limit 0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyAggregate
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|AGGREGATE_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(empno) from emp where false group by deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyAggregateEmptyKey
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|AGGREGATE_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(empno) from emp where false"
decl_stmt|;
specifier|final
name|boolean
name|unchanged
init|=
literal|true
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|,
name|unchanged
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testEmptyAggregateEmptyKeyWithAggregateValuesRule
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateValuesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*), sum(empno) from emp where false"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceCasts
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// The resulting plan should have no cast expressions
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"select cast(d.name as varchar(128)), cast(e.empno as integer) "
operator|+
literal|"from dept as d inner join emp as e "
operator|+
literal|"on cast(d.deptno as integer) = cast(e.deptno as integer) "
operator|+
literal|"where cast(e.job as varchar(1)) = 'Manager'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that a cast from a TIME to a TIMESTAMP is not reduced. It is not    * constant because the result depends upon the current date. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceCastTimeUnchanged
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
literal|"select cast(time '12:34:56' as timestamp) from emp as e"
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceCastAndConsts
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Make sure constant expressions inside the cast can be reduced
comment|// in addition to the casts.
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp "
operator|+
literal|"where cast((empno + (10/2)) as int) = 13"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
parameter_list|<
name|T
parameter_list|>
name|void
name|testReduceCaseNullabilityChange
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
try|try
init|(
name|Hook
operator|.
name|Closeable
name|a
init|=
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
operator|.
name|add
argument_list|(
name|Hook
operator|.
name|propertyJ
argument_list|(
literal|false
argument_list|)
argument_list|)
init|)
block|{
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select case when empno = 1 then 1 when 1 IS NOT NULL then 2 else null end as qx "
operator|+
literal|"from emp"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Ignore
comment|// Calcite does not support INSERT yet
annotation|@
name|Test
specifier|public
name|void
name|testReduceCastsNullable
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
comment|// Simulate the way INSERT will insert casts to the target types
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|CoerceInputsRule
argument_list|(
name|LogicalTableModify
operator|.
name|class
argument_list|,
literal|false
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
argument_list|)
comment|// Convert projects to calcs, merge two calcs, and then
comment|// reduce redundant casts in merged calc.
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CalcMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"insert into sales.depts(name) "
operator|+
literal|"select cast(gender as varchar(128)) from sales.emps"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|basePushAggThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateUnionTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"${sql}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumConstantThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullConstantThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullableNOGBYThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushCountStarThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushCountNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushMaxNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushMinThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAvgThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumCountStarThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumConstantGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullConstantGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullableGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushCountStarGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushCountNullableGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushMaxNullableGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushMinGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAvgGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushSumCountStarGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushCountFilterThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullFilterThroughAggregate
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal, deptno from ("
operator|+
literal|"  select ename, sal, deptno"
operator|+
literal|"  from emp"
operator|+
literal|"  where sal> 5000)"
operator|+
literal|"group by ename, sal, deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullFilterThroughAggregateGroupingSets
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal, deptno from ("
operator|+
literal|"  select ename, sal, deptno"
operator|+
literal|"  from emp"
operator|+
literal|"  where sal> 5000)"
operator|+
literal|"group by rollup(ename, sal, deptno)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|basePullConstantTroughAggregate
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"${sql}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughConstLast
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateSimpleNonNullable
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermuted
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermutedConstFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermutedConstGroupBy
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateConstGroupBy
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateAllConst
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateAllLiterals
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select 2, deptno, job from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 2, deptno, job from emp as e2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughUnion2
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Negative test: constants should not be pulled up
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select 2, deptno, job from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 1, deptno, job from emp as e2"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughUnion3
parameter_list|()
throws|throws
name|Exception
block|{
comment|// We should leave at least a single column in each Union input
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select 2, 3 from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 2, 3 from emp as e2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateProjectMerge
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select x, sum(z), y from (\n"
operator|+
literal|"  select deptno as x, empno as y, sal as z, sal * 2 as zz\n"
operator|+
literal|"  from emp)\n"
operator|+
literal|"group by x, y"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateGroupingSetsProjectMerge
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select x, sum(z), y from (\n"
operator|+
literal|"  select deptno as x, empno as y, sal as z, sal * 2 as zz\n"
operator|+
literal|"  from emp)\n"
operator|+
literal|"group by rollup(x, y)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateExtractProjectRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(sal)\n"
operator|+
literal|"from emp"
decl_stmt|;
name|HepProgram
name|pre
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|AggregateExtractProjectRule
name|rule
init|=
operator|new
name|AggregateExtractProjectRule
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|LogicalTableScan
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|pre
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateExtractProjectRuleWithGroupingSets
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, sum(sal)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by grouping sets ((empno, deptno),(deptno),(empno))"
decl_stmt|;
name|HepProgram
name|pre
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|AggregateExtractProjectRule
name|rule
init|=
operator|new
name|AggregateExtractProjectRule
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|LogicalTableScan
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|pre
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test with column used in both grouping set and argument to aggregate    * function. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateExtractProjectRuleWithGroupingSets2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, sum(empno)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by grouping sets ((empno, deptno),(deptno),(empno))"
decl_stmt|;
name|HepProgram
name|pre
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|AggregateExtractProjectRule
name|rule
init|=
operator|new
name|AggregateExtractProjectRule
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|LogicalTableScan
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|pre
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateExtractProjectRuleWithFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(sal) filter (where empno = 40)\n"
operator|+
literal|"from emp"
decl_stmt|;
name|HepProgram
name|pre
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// AggregateProjectMergeRule does not merges Project with Filter.
comment|// Force match Aggregate on top of Project once explicitly in unit test.
specifier|final
name|AggregateExtractProjectRule
name|rule
init|=
operator|new
name|AggregateExtractProjectRule
argument_list|(
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|operandJ
argument_list|(
name|Project
operator|.
name|class
argument_list|,
literal|null
argument_list|,
operator|new
name|Predicate
argument_list|<
name|Project
argument_list|>
argument_list|()
block|{
name|int
name|matchCount
init|=
literal|0
decl_stmt|;
specifier|public
name|boolean
name|test
parameter_list|(
name|Project
name|project
parameter_list|)
block|{
return|return
name|matchCount
operator|++
operator|==
literal|0
return|;
block|}
block|}
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|pre
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullAggregateThroughUnion
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateUnionAggregateRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, job from"
operator|+
literal|" (select deptno, job from emp as e1"
operator|+
literal|" group by deptno,job"
operator|+
literal|"  union all"
operator|+
literal|" select deptno, job from emp as e2"
operator|+
literal|" group by deptno,job)"
operator|+
literal|" group by deptno,job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullAggregateThroughUnion2
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateUnionAggregateRule
operator|.
name|AGG_ON_SECOND_INPUT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateUnionAggregateRule
operator|.
name|AGG_ON_FIRST_INPUT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, job from"
operator|+
literal|" (select deptno, job from emp as e1"
operator|+
literal|" group by deptno,job"
operator|+
literal|"  union all"
operator|+
literal|" select deptno, job from emp as e2"
operator|+
literal|" group by deptno,job)"
operator|+
literal|" group by deptno,job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|transitiveInference
parameter_list|(
name|RelOptRule
modifier|...
name|extraRules
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
name|diffRepos
operator|.
name|expand
argument_list|(
literal|null
argument_list|,
literal|"${sql}"
argument_list|)
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|DUMB_FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
specifier|final
name|RelRoot
name|root
init|=
name|tester
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|relInitial
init|=
name|root
operator|.
name|rel
decl_stmt|;
name|assertThat
argument_list|(
name|relInitial
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|DefaultRelMetadataProvider
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|RelMetadataProvider
name|plannerChain
init|=
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|relInitial
operator|.
name|getCluster
argument_list|()
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|plannerChain
argument_list|,
name|planner
argument_list|)
argument_list|)
expr_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|relInitial
argument_list|)
expr_stmt|;
name|RelNode
name|relBefore
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relBefore
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|HepProgram
name|program2
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|DUMB_FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinPushTransitivePredicatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleCollection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|extraRules
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|planner2
init|=
operator|new
name|HepPlanner
argument_list|(
name|program2
argument_list|)
decl_stmt|;
name|planner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|planner2
operator|.
name|setRoot
argument_list|(
name|relBefore
argument_list|)
expr_stmt|;
name|RelNode
name|relAfter
init|=
name|planner2
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceProject
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceAggregate
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceJoin3way
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceJoin3wayAgg
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceLeftOuterJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceRightOuterJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceFullOuterJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferencePreventProjectPullUp
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferencePullUpThruAlias
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceConjunctInPullUp
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceNoPullUpExprs
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceUnion3way
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Ignore
argument_list|(
literal|"not working"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceUnion3wayOr
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-443">[CALCITE-443]    * getPredicates from a union is not correct</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceUnionAlwaysTrue
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceConstantEquiPredicate
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceComplexPredicate
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantIntoProject
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantIntoFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1995">[CALCITE-1995]    * Remove predicates from Filter if they can be proved to be always true or    * false</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSimplifyFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantIntoJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantIntoJoin2
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2110">[CALCITE-2110]    * ArrayIndexOutOfBoundsException in RexSimplify when using    * ReduceExpressionsRule.JOIN_INSTANCE</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testCorrelationScalarAggAndFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e1.empno\n"
operator|+
literal|"FROM emp e1, dept d1 where e1.deptno = d1.deptno\n"
operator|+
literal|"and e1.deptno< 10 and d1.deptno< 15\n"
operator|+
literal|"and e1.sal> (select avg(sal) from emp e2 where e1.empno = e2.empno)"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|program
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testProjectWindowTransposeRule
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectWindowTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(empno) over(), deptno from emp"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testProjectWindowTransposeRuleWithConstants
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectWindowTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select col1, col2\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select empno,\n"
operator|+
literal|"    sum(100) over (partition by  deptno order by sal) as col1,\n"
operator|+
literal|"  sum(1000) over(partition by deptno order by sal) as col2\n"
operator|+
literal|"  from emp)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateProjectPullUpConstants
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select job, empno, sal, sum(sal) as s\n"
operator|+
literal|"from emp where empno = 10\n"
operator|+
literal|"group by job, empno, sal"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateProjectPullUpConstants2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal\n"
operator|+
literal|"from (select '1', ename, sal from emp where ename = 'John') subq\n"
operator|+
literal|"group by ename, sal"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterWithRank
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename, r\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select ename, "
operator|+
literal|"  rank() over(partition by  deptno order by sal) as r "
operator|+
literal|"  from emp) e1\n"
operator|+
literal|"where r< 2"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterWithRankExpr
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename, r\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select ename,\n"
operator|+
literal|"  rank() over(partition by  deptno order by sal) + 1 as r "
operator|+
literal|"  from emp) e1\n"
operator|+
literal|"where r< 2"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-841">[CALCITE-841]    * Redundant windows when window function arguments are expressions</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpressionInWindowFunction
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|" sum(deptno) over(partition by deptno order by sal) as sum1,\n"
operator|+
literal|"sum(deptno + sal) over(partition by deptno order by sal) as sum2\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-888">[CALCITE-888]    * Overlay window loses PARTITION BY list</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWindowInParenthesis
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) over (w), count(*) over w\n"
operator|+
literal|"from emp\n"
operator|+
literal|"window w as (partition by empno order by empno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for DX-11490    * Make sure the planner doesn't fail over wrong push down    * of is null */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testIsNullPushDown
parameter_list|()
block|{
name|HepProgramBuilder
name|preBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|preBuilder
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, w_count from (\n"
operator|+
literal|"  select empno, deptno, count(empno) over (w) w_count\n"
operator|+
literal|"  from emp\n"
operator|+
literal|"  window w as (partition by deptno order by empno)\n"
operator|+
literal|") sub_query where w_count is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preBuilder
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testIsNullPushDown2
parameter_list|()
block|{
name|HepProgramBuilder
name|preBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|preBuilder
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, w_count from (\n"
operator|+
literal|"  select empno, deptno, count(empno) over (ROWS BETWEEN 10 PRECEDING AND 1 PRECEDING) w_count\n"
operator|+
literal|"  from emp\n"
operator|+
literal|") sub_query where w_count is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preBuilder
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-750">[CALCITE-750]    * Allow windowed aggregate on top of regular aggregate</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testNestedAggregates
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT\n"
operator|+
literal|"  avg(sum(sal) + 2 * min(empno) + 3 * avg(empno))\n"
operator|+
literal|"  over (partition by deptno)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2078">[CALCITE-2078]    * Aggregate functions in OVER clause</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWindowFunctionOnAggregations
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT\n"
operator|+
literal|"  min(empno),\n"
operator|+
literal|"  sum(sal),\n"
operator|+
literal|"  sum(sum(sal))\n"
operator|+
literal|"    over (partition by min(empno) order by sum(sal))\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.job,d.name\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.job,d.name\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"and e.deptno + e.empno = d.deptno + 5\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.empno,d.deptno\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.empno< d.deptno\n"
operator|+
literal|"group by e.empno,d.deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1544">[CALCITE-1544]    * AggregateJoinTransposeRule fails to preserve row type</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin4
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno\n"
operator|+
literal|"from sales.emp as e join sales.dept as d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin5
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno, d.deptno\n"
operator|+
literal|"from sales.emp as e join sales.dept as d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno, d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2200">[CALCITE-2200]    * Infinite loop for JoinPushTransitivePredicatesRule</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testJoinPushTransitivePredicatesRule
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinPushTransitivePredicatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|emptyProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.emp d where d.deptno\n"
operator|+
literal|"IN (select e.deptno from sales.emp e "
operator|+
literal|"where e.deptno = d.deptno or e.deptno = 4)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|emptyProgram
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2205">[CALCITE-2205]    * One more infinite loop for JoinPushTransitivePredicatesRule</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testJoinPushTransitivePredicatesRule2
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinPushTransitivePredicatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select n1.SAL\n"
operator|+
literal|"from EMPNULLABLES_20 n1\n"
operator|+
literal|"where n1.SAL IN (\n"
operator|+
literal|"  select n2.SAL\n"
operator|+
literal|"  from EMPNULLABLES_20 n2\n"
operator|+
literal|"  where n1.SAL = n2.SAL or n1.SAL = 4)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2275">[CALCITE-2275]    * JoinPushTransitivePredicatesRule wrongly pushes down NOT condition</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testInferringPredicatesWithNotOperatorInJoinCondition
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinPushTransitivePredicatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp d\n"
operator|+
literal|"join sales.emp e on e.deptno = d.deptno and d.deptno not in (4, 6)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2195">[CALCITE-2195]    * AggregateJoinTransposeRule fails to aggregate over unique column</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin6
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(B.sal)\n"
operator|+
literal|"from sales.emp as A\n"
operator|+
literal|"join (select distinct sal from sales.emp) as B\n"
operator|+
literal|"on A.sal=B.sal\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2278">[CALCITE-2278]    * AggregateJoinTransposeRule fails to split aggregate call if input contains    * an aggregate call and has distinct rows</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoinWithUniqueInput
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select A.job, B.mgr, A.deptno,\n"
operator|+
literal|"max(B.hiredate1) as hiredate1, sum(B.comm1) as comm1\n"
operator|+
literal|"from sales.emp as A\n"
operator|+
literal|"join (select mgr, sal, max(hiredate) as hiredate1,\n"
operator|+
literal|"    sum(comm) as comm1 from sales.emp group by mgr, sal) as B\n"
operator|+
literal|"on A.sal=B.sal\n"
operator|+
literal|"group by A.job, B.mgr, A.deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** SUM is the easiest aggregate function to split. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateSumThroughJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.job,sum(sal)\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2105">[CALCITE-2105]    * AggregateJoinTransposeRule incorrectly makes a SUM NOT NULL when Aggregate    * has no group keys</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateSumWithoutGroupKeyThroughJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(sal)\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2108">[CALCITE-2108]    * AggregateJoinTransposeRule incorrectly splits a SUM0 call when Aggregate    * has no group keys</a>.    *    *<p>Similar to {@link #testPushAggregateSumThroughJoin()},    * but also uses {@link AggregateReduceFunctionsRule}. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateSumThroughJoinAfterAggregateReduce
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateReduceFunctionsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(sal)\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Push a variety of aggregate functions. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateFunctionsThroughJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.job,\n"
operator|+
literal|"  min(sal) as min_sal, min(e.deptno) as min_deptno,\n"
operator|+
literal|"  sum(sal) + 1 as sum_sal_plus, max(sal) as max_sal,\n"
operator|+
literal|"  sum(sal) as sum_sal_2, count(sal) as count_sal,\n"
operator|+
literal|"  count(mgr) as count_mgr\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Push a aggregate functions into a relation that is unique on the join    * key. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoinDistinct
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select d.name,\n"
operator|+
literal|"  sum(sal) as sum_sal, count(*) as c\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"join (select distinct name from sales.dept) as d\n"
operator|+
literal|"  on e.job = d.name\n"
operator|+
literal|"group by d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Push count(*) through join, no GROUP BY. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateSumNoGroup
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from sales.emp join sales.dept on job = name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2249">[CALCITE-2249]    * AggregateJoinTransposeRule generates inequivalent nodes if Aggregate relNode contains    * distinct aggregate function.</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushDistinctAggregateIntoJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(distinct sal) from sales.emp join sales.dept on job = name"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should merge 2 aggregates    * into a single aggregate.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateMerge1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno c, min(y), max(z) z,\n"
operator|+
literal|"sum(r), sum(m) n, sum(x) sal from (\n"
operator|+
literal|"   select deptno, ename, sum(sal) x, max(sal) z,\n"
operator|+
literal|"      min(sal) y, count(hiredate) m, count(mgr) r\n"
operator|+
literal|"   from sales.emp group by deptno, ename) t\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should merge 2 aggregates    * into a single aggregate, top aggregate is not simple aggregate.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateMerge2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, empno, sum(x), sum(y)\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select ename, empno, deptno, sum(sal) x, count(mgr) y\n"
operator|+
literal|"    from sales.emp\n"
operator|+
literal|"  group by deptno, ename, empno) t\n"
operator|+
literal|"group by grouping sets(deptno, empno)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since lower aggregate is not simple aggregate.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateMerge3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, sum(x) from (\n"
operator|+
literal|" select ename, deptno, sum(sal) x from\n"
operator|+
literal|"   sales.emp group by cube(deptno, ename)) t\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since it contains distinct aggregate    * function.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateMerge4
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, sum(x) from (\n"
operator|+
literal|"  select ename, deptno, count(distinct sal) x\n"
operator|+
literal|"    from sales.emp group by deptno, ename) t\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since AVG doesn't support splitting.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateMerge5
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, avg(x) from (\n"
operator|+
literal|"  select mgr, deptno, avg(sal) x from\n"
operator|+
literal|"    sales.emp group by deptno, mgr) t\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since top agg has no group key, and    * lower agg function is COUNT.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateMerge6
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(x) from (\n"
operator|+
literal|"select mgr, deptno, count(sal) x from\n"
operator|+
literal|"sales.emp group by deptno, mgr) t"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since top agg contains empty grouping set,    * and lower agg function is COUNT.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateMerge7
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select mgr, deptno, sum(x) from (\n"
operator|+
literal|"  select mgr, deptno, count(sal) x from\n"
operator|+
literal|"    sales.emp group by deptno, mgr) t\n"
operator|+
literal|"group by cube(mgr, deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should merge 2 aggregates    * into a single aggregate, since both top and bottom aggregates    * contains empty grouping set and they are mergable.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateMerge8
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(x) x, min(y) z from (\n"
operator|+
literal|"  select sum(sal) x, min(sal) y from sales.emp)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateRemoveRule, should remove aggregates since    * empno is unique and all aggregate functions are splittable.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateRemove1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno, sum(sal), min(sal), max(sal), "
operator|+
literal|"bit_and(distinct sal), bit_or(sal), count(distinct sal) "
operator|+
literal|"from sales.emp group by empno, deptno\n"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateRemoveRule, should remove aggregates since    * empno is unique and there are no aggregate functions.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateRemove2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select distinct empno, deptno from sales.emp\n"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateRemoveRule, should remove aggregates since    * empno is unique and all aggregate functions are splittable. Count    * aggregate function should be transformed to CASE function call    * because mgr is nullable.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateRemove3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno, count(mgr) "
operator|+
literal|"from sales.emp group by empno, deptno\n"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Negative test case for AggregateRemoveRule, should not    * remove aggregate because avg is not splittable.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateRemove4
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno, max(sal), avg(sal) "
operator|+
literal|"from sales.emp group by empno, deptno\n"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Negative test case for AggregateRemoveRule, should not    * remove non-simple aggregates.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateRemove5
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, sum(sal) "
operator|+
literal|"from sales.emp group by cube(empno, deptno)\n"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Negative test case for AggregateRemoveRule, should not    * remove aggregate because deptno is not unique.    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateRemove6
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno, max(sal) "
operator|+
literal|"from sales.emp group by deptno\n"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSwapOuterJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinCommuteRule
operator|.
name|SWAP_OUTER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select 1 from sales.dept d left outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testPushJoinCondDownToProject
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinPushExpressionsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select d.deptno, e.deptno from sales.dept d, sales.emp e"
operator|+
literal|" where d.deptno + 10 = e.deptno * 2"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e left join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"order by sal limit 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"order by name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e left join (\n"
operator|+
literal|"  select * from sales.dept) d on e.deptno = d.deptno\n"
operator|+
literal|"order by sal, name limit 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-931">[CALCITE-931]    * Wrong collation trait in SortJoinTransposeRule for right joins</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose4
parameter_list|()
block|{
comment|// Create a customized test with RelCollation trait in the test cluster.
name|Tester
name|tester
init|=
operator|new
name|TesterImpl
argument_list|(
name|getDiffRepos
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RelOptPlanner
name|createPlanner
parameter_list|()
block|{
return|return
operator|new
name|MockRelOptPlanner
argument_list|(
name|Contexts
operator|.
name|empty
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|getRelTraitDefs
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelTraitSet
name|emptyTraitSet
parameter_list|()
block|{
return|return
name|RelTraitSet
operator|.
name|createEmpty
argument_list|()
operator|.
name|plus
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
operator|.
name|getDefault
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"order by name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1498">[CALCITE-1498]    * Avoid LIMIT with trivial ORDER BY being pushed through JOIN endlessly</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose5
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// SortJoinTransposeRule should not be fired again.
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"limit 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1507">[CALCITE-1507]    * OFFSET cannot be pushed through a JOIN if the non-preserved side of outer    * join is not count-preserving</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose6
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one can be pushed down even if it has an OFFSET, since the dept
comment|// table is count-preserving against the join condition.
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, empno from sales.dept d\n"
operator|+
literal|"right join sales.emp e using (deptno) limit 10 offset 2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1507">[CALCITE-1507]    * OFFSET cannot be pushed through a JOIN if the non-preserved side of outer    * join is not count-preserving</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose7
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, empno from sales.dept d\n"
operator|+
literal|"left join sales.emp e using (deptno) order by d.deptno offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortProjectTranspose1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one can be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as integer) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortProjectTranspose2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one can be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as double) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSortProjectTranspose3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as varchar(10)) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1023">[CALCITE-1023]    * Planner rule that removes Aggregate keys that are constant</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateConstantKeyRule
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno, sal"
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link AggregateProjectPullUpConstantsRule} where reduction is not    * possible because "deptno" is the only key. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateConstantKeyRule2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link AggregateProjectPullUpConstantsRule} where both keys are    * constants but only one can be removed. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAggregateConstantKeyRule3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select job\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where sal is null and job = 'Clerk'\n"
operator|+
literal|"group by sal, job\n"
operator|+
literal|"having count(*)> 3"
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceExpressionsNot
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"select * from (values (false),(true)) as q (col1) where not(col1)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|Sql
name|checkSubQuery
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|FILTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Tests expanding a sub-query, specifically an uncorrelated scalar    * sub-query in a project (SELECT clause). */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectScalar
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSelectNotInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal,\n"
operator|+
literal|" empno NOT IN (\n"
operator|+
literal|" select deptno from dept\n"
operator|+
literal|"   where emp.job=dept.name)\n"
operator|+
literal|" from emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1493">[CALCITE-1493]    * Wrong plan for NOT IN correlated queries</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWhereNotInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal from emp\n"
operator|+
literal|"where empno NOT IN (\n"
operator|+
literal|"  select deptno from dept\n"
operator|+
literal|"  where emp.job = dept.name)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWhereNotInCorrelated2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.empno NOT IN\n"
operator|+
literal|"   (select empno from (select ename, empno, sal as r from emp) e2\n"
operator|+
literal|"    where r> 2 and e1.ename= e2.ename)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAll
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.empno> ALL (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSome
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.empno> SOME (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    * testing type created by SubQueryRemoveRule    * ANY subquery is non-nullable therefore plan should have cast    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAnyInProjectNonNullable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name, \n"
operator|+
literal|" deptno> ANY (\n"
operator|+
literal|" select deptno from emp) \n"
operator|+
literal|" from dept"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    * testing type created by SubQueryRemoveRule    * ANY subquery is nullable therefore plan should not have cast    */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testAnyInProjectNullable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, \n"
operator|+
literal|" name = ANY (\n"
operator|+
literal|" select mgr from emp) \n"
operator|+
literal|" from dept"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSomeWithEquality
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.deptno = SOME (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testSomeWithEquality2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.ename= SOME (select name from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1546">[CALCITE-1546]    * Sub-queries connected by OR</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWhereOrSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp\n"
operator|+
literal|"where sal = 4\n"
operator|+
literal|"or empno NOT IN (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectIn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  deptno in (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectInNullable
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"with e2 as (\n"
operator|+
literal|"  select empno, case when true then deptno else null end as deptno\n"
operator|+
literal|"  from sales.emp)\n"
operator|+
literal|"select empno,\n"
operator|+
literal|"  deptno in (select deptno from e2 where empno< 20) as d\n"
operator|+
literal|"from e2"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectInComposite
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, (empno, deptno) in (\n"
operator|+
literal|"    select empno, deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  exists (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterScalar
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"< (select deptno from sales.emp where empno> 100)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterIn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno in (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterInComposite
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where (empno, deptno) in (\n"
operator|+
literal|"  select empno, deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** An IN filter that requires full 3-value logic (true, false, unknown). */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterIn3Value
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where empno\n"
operator|+
literal|"< case deptno in (select case when true then deptno else null end\n"
operator|+
literal|"                   from sales.emp where empno< 20)\n"
operator|+
literal|"   when true then 10\n"
operator|+
literal|"   when false then 20\n"
operator|+
literal|"   else 30\n"
operator|+
literal|"   end"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** An EXISTS filter that can be converted into true/false. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** An EXISTS filter that can be converted into a semi-join. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterExistsSimple
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** An EXISTS filter that can be converted into a semi-join. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterExistsSimpleAnd
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"and emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandJoinScalar
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"< (select deptno from sales.emp where empno> 100)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Ignore
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testExpandJoinIn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on emp.deptno in (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Ignore
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testExpandJoinInComposite
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on (emp.empno, dept.deptno) in (\n"
operator|+
literal|"  select empno, deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandJoinExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on exists (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp\n"
operator|+
literal|"where EXISTS (\n"
operator|+
literal|"  select * from emp e where emp.deptno = e.deptno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1511">[CALCITE-1511]    * AssertionError while decorrelating query with two EXISTS    * sub-queries</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateTwoExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp\n"
operator|+
literal|"where EXISTS (\n"
operator|+
literal|"  select * from emp e where emp.deptno = e.deptno)\n"
operator|+
literal|"AND NOT EXISTS (\n"
operator|+
literal|"  select * from emp ee where ee.job = emp.job AND ee.sal=34)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2028">[CALCITE-2028]    * Un-correlated IN sub-query should be converted into a Join,    * rather than a Correlate without correlation variables</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateUncorrelatedInAndCorrelatedExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp\n"
operator|+
literal|"WHERE job in (\n"
operator|+
literal|"  select job from emp ee where ee.sal=34)"
operator|+
literal|"AND EXISTS (\n"
operator|+
literal|"  select * from emp e where emp.deptno = e.deptno)\n"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1537">[CALCITE-1537]    * Unnecessary project expression in multi-sub-query plan</a>. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateTwoIn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where empno IN (\n"
operator|+
literal|"  select deptno from dept where emp.job = dept.name)\n"
operator|+
literal|"AND empno IN (\n"
operator|+
literal|"  select empno from emp e where emp.ename = e.ename)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1045">[CALCITE-1045]    * Decorrelate sub-queries in Project and Join</a>, with the added    * complication that there are two sub-queries. */
end_comment

begin_function
annotation|@
name|Ignore
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateTwoScalar
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno,\n"
operator|+
literal|"  (select min(1) from emp where empno> d.deptno) as i0,\n"
operator|+
literal|"  (select min(0) from emp\n"
operator|+
literal|"    where deptno = d.deptno and ename = 'SMITH') as i1\n"
operator|+
literal|"from dept as d"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWhereInJoinCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp as e\n"
operator|+
literal|"join dept as d using (deptno)\n"
operator|+
literal|"where e.sal in (\n"
operator|+
literal|"  select e2.sal from emp as e2 where e2.deptno> e.deptno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1494">[CALCITE-1494]    * Inefficient plan for correlated sub-queries</a>. In "planAfter", there    * must be only one scan each of emp and dept. We don't need a separate    * value-generator for emp.job. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWhereInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal from emp where empno IN (\n"
operator|+
literal|"  select deptno from dept where emp.job = dept.name)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWhereExpressionInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (\n"
operator|+
literal|"  select ename, deptno, sal + 1 as salPlus from emp) as e\n"
operator|+
literal|"where deptno in (\n"
operator|+
literal|"  select deptno from emp where sal + 1 = e.salPlus)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testWhereExpressionInCorrelated2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name from (\n"
operator|+
literal|"  select name, deptno, deptno - 10 as deptnoMinus from dept) as d\n"
operator|+
literal|"where deptno in (\n"
operator|+
literal|"  select deptno from emp where sal + 1 = d.deptnoMinus)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExpandWhereComparisonCorrelated
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"where sal = (\n"
operator|+
literal|"  select max(sal) from sales.emp e2 where e2.empno = e.empno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testCustomColumnResolvingInNonCorrelatedSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 in (\n"
operator|+
literal|"  select f1.c0 from struct.t t2)"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|FILTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testCustomColumnResolvingInCorrelatedSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 = (\n"
operator|+
literal|"  select max(f1.c0) from struct.t t2 where t1.k0 = t2.k0)"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|FILTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testCustomColumnResolvingInCorrelatedSubQuery2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 in (\n"
operator|+
literal|"  select f1.c0 from struct.t t2 where t1.c2 = t2.c2)"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|FILTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-434">[CALCITE-434]    * Converting predicates on date dimension columns into date ranges</a>,    * specifically a rule that converts {@code EXTRACT(YEAR FROM ...) = constant}    * to a range. */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExtractYearToRange
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from sales.emp_b as e\n"
operator|+
literal|"where extract(year from birthdate) = 2014"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|DateRangeRules
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|context
init|=
name|Contexts
operator|.
name|of
argument_list|(
operator|new
name|CalciteConnectionConfigImpl
argument_list|(
operator|new
name|Properties
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withContext
argument_list|(
name|context
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExtractYearMonthToRange
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from sales.emp_b as e\n"
operator|+
literal|"where extract(year from birthdate) = 2014"
operator|+
literal|"and extract(month from birthdate) = 4"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|DateRangeRules
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|context
init|=
name|Contexts
operator|.
name|of
argument_list|(
operator|new
name|CalciteConnectionConfigImpl
argument_list|(
operator|new
name|Properties
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withContext
argument_list|(
name|context
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testFilterRemoveIsNotDistinctFromRule
parameter_list|()
block|{
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|prePlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|preProgram
argument_list|)
decl_stmt|;
name|prePlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|relBefore
init|=
name|prePlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relBefore
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|HepProgram
name|hepProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterRemoveIsNotDistinctFromRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|hepProgram
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|relAfter
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testOversimplifiedCaseStatement
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select * from emp "
operator|+
literal|"where MGR> 0 and "
operator|+
literal|"case when MGR> 0 then deptno / MGR else null end> 1"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for   *<a href="https://issues.apache.org/jira/browse/CALCITE-2726">[CALCITE-2726]   * ReduceExpressionRule may oversimplify filter conditions containing nulls</a>.   */
end_comment

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testNoOversimplificationBelowIsNull
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select * from emp where ( (empno=1 and mgr=1) or (empno=null and mgr=1) ) is null"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testExchangeRemoveConstantKeysRule
parameter_list|()
block|{
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|builder
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|)
operator|.
name|exchange
argument_list|(
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|builder
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|sortExchange
argument_list|(
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|RelFieldCollation
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|prePlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|preProgram
argument_list|)
decl_stmt|;
name|prePlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|relBefore
init|=
name|prePlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relBefore
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|HepProgram
name|hepProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ExchangeRemoveConstantKeysRule
operator|.
name|EXCHANGE_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ExchangeRemoveConstantKeysRule
operator|.
name|SORT_EXCHANGE_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|hepProgram
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|relAfter
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceAverageWithNoReduceSum
parameter_list|()
block|{
specifier|final
name|EnumSet
argument_list|<
name|SqlKind
argument_list|>
name|functionsToReduce
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|)
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|AggregateReduceFunctionsRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|functionsToReduce
argument_list|)
argument_list|,
literal|"select name, max(name), avg(deptno), min(name)"
operator|+
literal|" from sales.dept group by name"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testNoReduceAverage
parameter_list|()
block|{
specifier|final
name|EnumSet
argument_list|<
name|SqlKind
argument_list|>
name|functionsToReduce
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SqlKind
operator|.
name|class
argument_list|)
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AggregateReduceFunctionsRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|functionsToReduce
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select name, max(name), avg(deptno), min(name)"
operator|+
literal|" from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testNoReduceSum
parameter_list|()
block|{
specifier|final
name|EnumSet
argument_list|<
name|SqlKind
argument_list|>
name|functionsToReduce
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SqlKind
operator|.
name|class
argument_list|)
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AggregateReduceFunctionsRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|functionsToReduce
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select name, sum(deptno)"
operator|+
literal|" from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceAverageAndVarWithNoReduceStddev
parameter_list|()
block|{
comment|// configure rule to reduce AVG and VAR_POP functions
comment|// other functions like SUM, STDDEV won't be reduced
specifier|final
name|EnumSet
argument_list|<
name|SqlKind
argument_list|>
name|functionsToReduce
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|,
name|SqlKind
operator|.
name|VAR_POP
argument_list|)
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AggregateReduceFunctionsRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|functionsToReduce
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),"
operator|+
literal|" var_pop(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceAverageAndSumWithNoReduceStddevAndVar
parameter_list|()
block|{
comment|// configure rule to reduce AVG and SUM functions
comment|// other functions like VAR_POP, STDDEV_POP won't be reduced
specifier|final
name|EnumSet
argument_list|<
name|SqlKind
argument_list|>
name|functionsToReduce
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|,
name|SqlKind
operator|.
name|SUM
argument_list|)
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AggregateReduceFunctionsRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|functionsToReduce
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),"
operator|+
literal|" var_pop(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
specifier|public
name|void
name|testReduceAllAggregateFunctions
parameter_list|()
block|{
comment|// configure rule to reduce all used functions
specifier|final
name|EnumSet
argument_list|<
name|SqlKind
argument_list|>
name|functionsToReduce
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|,
name|SqlKind
operator|.
name|SUM
argument_list|,
name|SqlKind
operator|.
name|STDDEV_POP
argument_list|,
name|SqlKind
operator|.
name|STDDEV_SAMP
argument_list|,
name|SqlKind
operator|.
name|VAR_POP
argument_list|,
name|SqlKind
operator|.
name|VAR_SAMP
argument_list|)
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|AggregateReduceFunctionsRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|functionsToReduce
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),"
operator|+
literal|" stddev_samp(deptno), var_pop(deptno), var_samp(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
unit|}
comment|// End RelOptRulesTest.java
end_comment

end_unit

