begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepMatchOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|CachingRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ChainedRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|DefaultRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateExpandDistinctAggregatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateReduceFunctionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateUnionAggregateRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateUnionTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateValuesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CalcMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CoerceInputsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|DateRangeRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterAggregateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterSetOpTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterToCalcRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|IntersectToDistinctRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinAddRedundantSemiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinCommuteRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinExtractFilterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinPushExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinPushTransitivePredicatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinToMultiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinUnionTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectSetOpTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectToCalcRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectToWindowRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectWindowTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|PruneEmptyRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ReduceExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SemiJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortUnionTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SubQueryRemoveRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|TableScanRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionToDistinctRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ValuesReduceRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlToRelConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_comment
comment|/**  * Unit test for rules in {@code org.apache.calcite.rel} and subpackages.  *  *<p>As input, the test supplies a SQL statement and a single rule; the SQL is  * translated into relational algebra and then fed into a  * {@link org.apache.calcite.plan.hep.HepPlanner}. The planner fires the rule on  * every  * pattern match in a depth-first left-to-right pre-order traversal of the tree  * for as long as the rule continues to succeed in applying its transform. (For  * rules which call transformTo more than once, only the last result is used.)  * The plan before and after "optimization" is diffed against a .ref file using  * {@link DiffRepository}.  *  *<p>Procedure for adding a new test case:  *  *<ol>  *<li>Add a new public test method for your rule, following the existing  * examples. You'll have to come up with an SQL statement to which your rule  * will apply in a meaningful way. See {@link SqlToRelTestBase} class comments  * for details on the schema.  *  *<li>Run the test. It should fail. Inspect the output in  * {@code target/surefire/.../RelOptRulesTest.xml}.  * (If you are running using maven and this file does not exist, add a  * {@code -X} flag to the maven command line.)  *  *<li>Verify that the "planBefore" is the correct  * translation of your SQL, and that it contains the pattern on which your rule  * is supposed to fire. If all is well, replace  * {@code src/test/resources/.../RelOptRulesTest.xml} and  * with the new {@code target/surefire/.../RelOptRulesTest.xml}.  *  *<li>Run the test again. It should fail again, but this time it should contain  * a "planAfter" entry for your rule. Verify that your rule applied its  * transformation correctly, and then update the  * {@code src/test/resources/.../RelOptRulesTest.xml} file again.  *  *<li>Run the test one last time; this time it should pass.  *</ol>  */
end_comment

begin_class
specifier|public
class|class
name|RelOptRulesTest
extends|extends
name|RelOptTestBase
block|{
comment|//~ Methods ----------------------------------------------------------------
specifier|protected
name|DiffRepository
name|getDiffRepos
parameter_list|()
block|{
return|return
name|DiffRepository
operator|.
name|lookup
argument_list|(
name|RelOptRulesTest
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceNestedCaseWhen
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when (sal = 1000) then\n"
operator|+
literal|"(case when sal = 1000 then null else 1 end is null) else\n"
operator|+
literal|"(case when sal = 2000 then null else 1 end is null) end is true"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
name|hepPlanner
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1479">[CALCITE-1479]    * AssertionError in ReduceExpressionsRule on multi-column IN    * sub-query</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceCompositeInSubQuery
parameter_list|()
block|{
specifier|final
name|HepProgram
name|hepProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where (empno, deptno) in (\n"
operator|+
literal|"  select empno, deptno from (\n"
operator|+
literal|"    select empno, deptno\n"
operator|+
literal|"    from emp\n"
operator|+
literal|"    group by empno, deptno))\n"
operator|+
literal|"or deptno< 40 + 60"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepProgram
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceOrCaseWhen
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when sal = 1000 then null else 1 end is null\n"
operator|+
literal|"OR case when sal = 2000 then null else 1 end is null"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
name|hepPlanner
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceNullableCase
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT CASE WHEN 1=2 "
operator|+
literal|"THEN cast((values(1)) as integer) "
operator|+
literal|"ELSE 2 end from (values(1))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceNullableCase2
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, ename, CASE WHEN 1=2 "
operator|+
literal|"THEN substring(ename, 1, cast(2 as int)) ELSE NULL end from emp"
operator|+
literal|" group by deptno, ename, case when 1=2 then substring(ename,1, cast(2 as int))  else null end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectToWindowRuleForMultipleWindows
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|" count(*) over(partition by empno order by sal) as count1,\n"
operator|+
literal|" count(*) over(partition by deptno order by sal) as count2,\n"
operator|+
literal|" sum(deptno) over(partition by empno order by sal) as sum1,\n"
operator|+
literal|" sum(deptno) over(partition by deptno order by sal) as sum2\n"
operator|+
literal|"from emp"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
name|hepPlanner
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnionToDistinctRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|UnionToDistinctRule
operator|.
name|INSTANCE
argument_list|,
literal|"select * from dept union select * from dept"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExtractJoinFilterRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|JoinExtractFilterRule
operator|.
name|INSTANCE
argument_list|,
literal|"select 1 from emp inner join dept on emp.deptno=dept.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAddRedundantSemiJoinRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|,
literal|"select 1 from emp inner join dept on emp.deptno = dept.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStrengthenJoinType
parameter_list|()
block|{
comment|// The "Filter(... , right.c IS NOT NULL)" above a left join is pushed into
comment|// the join, makes it an inner join, and then disappears because c is NOT
comment|// NULL.
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept left join emp using (deptno)\n"
operator|+
literal|"where emp.deptno is not null and emp.sal> 100"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFullOuterJoinSimplificationToLeftOuter
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d full outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where d.name = 'Charlie'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFullOuterJoinSimplificationToRightOuter
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d full outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where e.sal> 100"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFullOuterJoinSimplificationToInner
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d full outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where d.name = 'Charlie' and e.sal> 100"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLeftOuterJoinSimplificationToInner
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d left outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where e.sal> 100"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRightOuterJoinSimplificationToInner
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d right outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where d.name = 'Charlie'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAgg
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select dname, c from"
operator|+
literal|" (select name dname, count(*) as c from dept group by name) t"
operator|+
literal|" where dname = 'Charlie'"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|basePushFilterPastAggWithGroupingSets
parameter_list|(
name|boolean
name|unchanged
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"${sql}"
argument_list|,
name|unchanged
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggWithGroupingSets1
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushFilterPastAggWithGroupingSets
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggWithGroupingSets2
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushFilterPastAggWithGroupingSets
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-434">[CALCITE-434]    * FilterAggregateTransposeRule loses conditions that cannot be pushed</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggTwo
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select dept1.c1 from (\n"
operator|+
literal|"  select dept.name as c1, count(*) as c2\n"
operator|+
literal|"  from dept where dept.name> 'b' group by dept.name) dept1\n"
operator|+
literal|"where dept1.c1> 'c' and (dept1.c2> 30 or dept1.c1< 'z')"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-799">[CALCITE-799]    * Incorrect result for {@code HAVING count(*)> 1}</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggThree
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by deptno having count(*)> 1"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1109">[CALCITE-1109]    * FilterAggregateTransposeRule pushes down incorrect condition</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastAggFour
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"select emp.deptno, count(*) from emp where emp.sal> '12' "
operator|+
literal|"group by emp.deptno\n"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-448">[CALCITE-448]    * FilterIntoJoinRule creates filters containing invalid RexInputRef</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterPastProject
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FilterJoinRule
operator|.
name|Predicate
name|predicate
init|=
operator|new
name|FilterJoinRule
operator|.
name|Predicate
argument_list|()
block|{
specifier|public
name|boolean
name|apply
parameter_list|(
name|Join
name|join
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|exp
parameter_list|)
block|{
return|return
name|joinType
operator|!=
name|JoinRelType
operator|.
name|INNER
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|FilterJoinRule
name|join
init|=
operator|new
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
argument_list|(
name|RelBuilder
operator|.
name|proto
argument_list|()
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
specifier|final
name|FilterJoinRule
name|filterOnJoin
init|=
operator|new
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
argument_list|(
literal|true
argument_list|,
name|RelBuilder
operator|.
name|proto
argument_list|()
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addGroupBegin
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|join
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|filterOnJoin
argument_list|)
operator|.
name|addGroupEnd
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join dept b on b.deptno> 10\n"
operator|+
literal|"right join dept c on b.deptno> 10\n"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoinProjectTranspose
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|LEFT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|RIGHT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinProjectTransposeRule
operator|.
name|LEFT_PROJECT_INCLUDE_OUTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join dept b on b.deptno> 10\n"
operator|+
literal|"right join dept c on b.deptno> 10\n"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-889">[CALCITE-889]    * Implement SortUnionTransposeRule</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortUnionTranspose
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortUnionTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name limit 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-889">[CALCITE-889]    * Implement SortUnionTransposeRule</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortUnionTranspose2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortUnionTransposeRule
operator|.
name|MATCH_NULL_FETCH
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-987">[CALCITE-987]    * Push limit 0 will result in an infinite loop</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortUnionTranspose3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortUnionTransposeRule
operator|.
name|MATCH_NULL_FETCH
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name limit 0"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRuleExists
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from dept where exists (\n"
operator|+
literal|"  select * from emp\n"
operator|+
literal|"  where emp.deptno = dept.deptno\n"
operator|+
literal|"  and emp.sal> 100)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRule
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1495">[CALCITE-1495]    * SemiJoinRule should not apply to RIGHT and FULL JOIN</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRuleRight
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept right join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Similar to {@link #testSemiJoinRuleRight()} but FULL. */
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRuleFull
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept full join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Similar to {@link #testSemiJoinRule()} but LEFT. */
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinRuleLeft
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name from dept left join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-438">[CALCITE-438]    * Push predicates through SemiJoin</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterThroughSemiJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select * from dept where dept.deptno in (\n"
operator|+
literal|"    select emp.deptno from emp))R\n"
operator|+
literal|"where R.deptno<=10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|false
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-571">[CALCITE-571]    * ReduceExpressionsRule tries to reduce SemiJoin condition to non-equi    * condition</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinReduceConstants
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e1.sal\n"
operator|+
literal|"from (select * from emp where deptno = 200) as e1\n"
operator|+
literal|"where e1.deptno in (\n"
operator|+
literal|"  select e2.deptno from emp e2 where e2.sal = 100)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSemiJoinTrim
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
name|diffRepos
operator|.
name|expand
argument_list|(
literal|null
argument_list|,
literal|"${sql}"
argument_list|)
decl_stmt|;
name|TesterImpl
name|t
init|=
operator|(
name|TesterImpl
operator|)
name|tester
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|t
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
init|=
name|t
operator|.
name|createCatalogReader
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidator
name|validator
init|=
name|t
operator|.
name|createValidator
argument_list|(
name|catalogReader
argument_list|,
name|typeFactory
argument_list|)
decl_stmt|;
name|SqlToRelConverter
name|converter
init|=
name|t
operator|.
name|createSqlToRelConverter
argument_list|(
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlToRelConverter
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sqlQuery
init|=
name|t
operator|.
name|parseQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|validatedQuery
init|=
name|validator
operator|.
name|validate
argument_list|(
name|sqlQuery
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|converter
operator|.
name|convertQuery
argument_list|(
name|validatedQuery
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|decorrelate
argument_list|(
name|sqlQuery
argument_list|,
name|root
operator|.
name|rel
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|root
operator|.
name|rel
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|planner
operator|.
name|findBestExp
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|converter
operator|=
name|t
operator|.
name|createSqlToRelConverter
argument_list|(
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlToRelConverter
operator|.
name|configBuilder
argument_list|()
operator|.
name|withTrimUnusedFields
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|trimUnusedFields
argument_list|(
literal|false
argument_list|,
name|root
operator|.
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceAverage
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|AggregateReduceFunctionsRule
operator|.
name|INSTANCE
argument_list|,
literal|"select name, max(name), avg(deptno), min(name)"
operator|+
literal|" from sales.dept group by name"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1621">[CALCITE-1621]    * Adding a cast around the null literal in aggregate rules</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testCastInAggregateReduceFunctions
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateReduceFunctionsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),"
operator|+
literal|" stddev_samp(deptno),var_pop(deptno), var_samp(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCount1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename)"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCount2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename), sum(sal)"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1293">[CALCITE-1293]    * Bad code generated when argument to COUNT(DISTINCT) is a # GROUP BY    * column</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCount3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(distinct deptno), sum(sal)"
operator|+
literal|" from sales.emp group by deptno"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests implementing multiple distinct count the old way, using a join. */
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMultipleViaJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename), count(distinct job, ename),\n"
operator|+
literal|"  count(distinct deptno, job), sum(sal)\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests implementing multiple distinct count the new way, using GROUPING    *  SETS. */
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMultiple
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename), count(distinct job)\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMultipleNoGroup
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(distinct ename), count(distinct job)\n"
operator|+
literal|" from sales.emp"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMixedJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename), count(distinct job, ename),\n"
operator|+
literal|"  count(distinct deptno, job), sum(sal)\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMixed
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct deptno, job) as cddj, sum(sal) as s\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountMixed2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, count(distinct ename) as cde,\n"
operator|+
literal|"  count(distinct job, ename) as cdje,\n"
operator|+
literal|"  count(distinct deptno, job) as cddj,\n"
operator|+
literal|"  sum(sal) as s\n"
operator|+
literal|" from sales.emp group by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountGroupingSets1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, job, count(distinct ename)"
operator|+
literal|" from sales.emp group by rollup(deptno,job)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctCountGroupingSets2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, job, count(distinct ename), sum(sal)"
operator|+
literal|" from sales.emp group by rollup(deptno,job)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctNonDistinctAggregates
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select emp.empno, count(*), avg(distinct dept.deptno)\n"
operator|+
literal|"from sales.emp emp inner join sales.dept dept\n"
operator|+
literal|"on emp.deptno = dept.deptno\n"
operator|+
literal|"group by emp.empno"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1621">[CALCITE-1621]    * Adding a cast around the null literal in aggregate rules</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testCastInAggregateExpandDistinctAggregatesRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name, sum(distinct cn), sum(distinct sm)\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select name, count(dept.deptno) as cn,sum(dept.deptno) as sm\n"
operator|+
literal|"  from sales.dept group by name)\n"
operator|+
literal|"group by name"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1558">[CALCITE-1558]    * AggregateExpandDistinctAggregatesRule gets field mapping wrong if groupKey    * is used in aggregate function</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testDistinctNonDistinctAggregatesWithGrouping1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|"  SUM(deptno), SUM(DISTINCT sal), MAX(deptno), MAX(comm)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDistinctNonDistinctAggregatesWithGrouping2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, COUNT(deptno), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateExpandDistinctAggregatesRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFilter
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select empno + deptno from emp where sal = 10 * comm "
operator|+
literal|"and upper(ename) = 'FOO'"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1778">[CALCITE-1778]    * Query with "WHERE CASE" throws AssertionError "Cast for just nullability    * not allowed"</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFilter2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when mgr< 10 then true else false end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastJoin
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select e.sal + b.comm from emp e inner join bonus b "
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|NOT_STRONG_EXPR
init|=
literal|"case when e.sal< 11 then 11 else -1 * e.sal end"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|STRONG_EXPR
init|=
literal|"case when e.sal< 11 then -1 * e.sal else e.sal end"
decl_stmt|;
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1753">[CALCITE-1753]    * PushProjector should only preserve expressions if the expression is strong    * when pushing into the nullable-side of outer join</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastInnerJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e inner join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastInnerJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e inner join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastLeftJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e left outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by case when e.sal< 11 then 11 else -1 * e.sal end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastLeftJoinSwap
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b left outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastLeftJoinSwapStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b left outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastRightJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e right outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastRightJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*),\n"
operator|+
literal|" case when e.sal< 11 then -1 * e.sal else e.sal end\n"
operator|+
literal|"from emp e right outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by case when e.sal< 11 then -1 * e.sal else e.sal end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastRightJoinSwap
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b right outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastRightJoinSwapStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b right outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFullJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e full outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFullJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e full outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|ProjectJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastSetOp
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|,
literal|"select sal from "
operator|+
literal|"(select * from emp e1 union all select * from emp e2)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushJoinThroughUnionOnLeft
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|JoinUnionTransposeRule
operator|.
name|LEFT_UNION
argument_list|,
literal|"select r1.sal from "
operator|+
literal|"(select * from emp e1 union all select * from emp e2) r1, "
operator|+
literal|"emp r2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushJoinThroughUnionOnRight
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|JoinUnionTransposeRule
operator|.
name|RIGHT_UNION
argument_list|,
literal|"select r1.sal from "
operator|+
literal|"emp r1, "
operator|+
literal|"(select * from emp e1 union all select * from emp e2) r2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"cycles"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testMergeFilterWithJoinCondition
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|TableScanRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinExtractFilterRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CalcMergeRule
operator|.
name|INSTANCE
argument_list|)
comment|//.addRuleInstance(FennelCalcRule.instance);
comment|//.addRuleInstance(FennelCartesianJoinRule.instance);
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select d.name as dname,e.ename as ename"
operator|+
literal|" from emp e inner join dept d"
operator|+
literal|" on e.deptno=d.deptno"
operator|+
literal|" where d.name='Propane'"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that filters are combined if they are identical. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select name from (\n"
operator|+
literal|"  select *\n"
operator|+
literal|"  from dept\n"
operator|+
literal|"  where deptno = 10)\n"
operator|+
literal|"where deptno = 10\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a filters is combined are combined if they are identical,    * even if one of them originates in an ON clause of a JOIN. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeJoinFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"  select d.deptno, e.ename\n"
operator|+
literal|"  from emp as e\n"
operator|+
literal|"  join dept as d\n"
operator|+
literal|"  on e.deptno = d.deptno\n"
operator|+
literal|"  and d.deptno = 10)\n"
operator|+
literal|"where deptno = 10\n"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule}, which merges 2 {@link Union} operators into    * a single {@code Union} with 3 inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeUnionAll
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule}, which merges 2 {@link Union}    * {@code DISTINCT} (not {@code ALL}) operators into a single    * {@code Union} with 3 inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeUnionDistinct
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union distinct\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union\n"
comment|// same as 'union distinct'
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link UnionMergeRule} does nothing if its arguments have    * different {@code ALL} settings. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeUnionMixed
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link UnionMergeRule} converts all inputs to DISTINCT    * if the top one is DISTINCT.    * (Since UNION is left-associative, the "top one" is the rightmost.) */
annotation|@
name|Test
specifier|public
name|void
name|testMergeUnionMixed2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link UnionMergeRule} does nothing if its arguments have    * are different set operators, {@link Union} and {@link Intersect}. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeSetOpMixed
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule#INTERSECT_INSTANCE}, which merges 2    * {@link Intersect} operators into a single {@code Intersect} with 3    * inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeIntersect
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link org.apache.calcite.rel.rules.IntersectToDistinctRule},    * which rewrites an {@link Intersect} operator with 3 inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testIntersectToDistinct
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|IntersectToDistinctRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link org.apache.calcite.rel.rules.IntersectToDistinctRule}    * correctly ignores an {@code INTERSECT ALL}. It can only handle    * {@code INTERSECT DISTINCT}. */
annotation|@
name|Test
specifier|public
name|void
name|testIntersectToDistinctAll
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|IntersectToDistinctRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule#MINUS_INSTANCE}, which merges 2    * {@link Minus} operators into a single {@code Minus} with 3    * inputs. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeMinus
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link UnionMergeRule#MINUS_INSTANCE}    * does not merge {@code Minus(a, Minus(b, c))}    * into {@code Minus(a, b, c)}, which would be incorrect. */
annotation|@
name|Test
specifier|public
name|void
name|testMergeMinusRightDeep
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionMergeRule
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (\n"
operator|+
literal|"  select * from emp where deptno = 20\n"
operator|+
literal|"  except\n"
operator|+
literal|"  select * from emp where deptno = 30)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"cycles"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testHeterogeneousConversion
parameter_list|()
throws|throws
name|Exception
block|{
comment|// This one tests the planner's ability to correctly
comment|// apply different converters on top of a common
comment|// sub-expression.  The common sub-expression is the
comment|// reference to the table sales.emps.  On top of that
comment|// are two projections, unioned at the top.  For one
comment|// of the projections, we force a Fennel implementation.
comment|// For the other, we force a Java implementation.
comment|// Then, we request conversion from Fennel to Java,
comment|// and verify that it only applies to one usage of the
comment|// table, not both (which would be incorrect).
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|TableScanRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
comment|// Control the calc conversion.
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
comment|// Let the converter rule fire to its heart's content.
operator|.
name|addMatchLimit
argument_list|(
name|HepProgram
operator|.
name|MATCH_UNTIL_FIXPOINT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select upper(ename) from emp union all"
operator|+
literal|" select lower(ename) from emp"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastJoinRuleLeft
parameter_list|()
throws|throws
name|Exception
block|{
comment|// tests the case where the semijoin is pushed to the left
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and e1.empno = e2.empno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastJoinRuleRight
parameter_list|()
throws|throws
name|Exception
block|{
comment|// tests the case where the semijoin is pushed to the right
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.ename from emp e, dept d "
operator|+
literal|"where e.deptno = d.deptno and e.ename = 'foo'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRule
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinToMultiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstants
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// NOTE jvs 27-May-2006: among other things, this verifies
comment|// intentionally different treatment for identical coalesce expression
comment|// in select and where.
comment|// There is "CAST(2 AS INTEGER)" in the plan because 2 has type "INTEGER NOT
comment|// NULL" and we need "INTEGER".
specifier|final
name|String
name|sql
init|=
literal|"select"
operator|+
literal|" 1+2, d.deptno+(3+4), (5+6)+d.deptno, cast(null as integer),"
operator|+
literal|" coalesce(2,null), row(7+8)"
operator|+
literal|" from dept d inner join emp e"
operator|+
literal|" on d.deptno = e.deptno + (5-5)"
operator|+
literal|" where d.deptno=(7+8) and d.deptno=(8+7) and d.deptno=coalesce(2,null)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-570">[CALCITE-570]    * ReduceExpressionsRule throws "duplicate key" exception</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsDup
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno"
operator|+
literal|" from dept d"
operator|+
literal|" where d.deptno=7 and d.deptno=8"
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-935">[CALCITE-935]    * Improve how ReduceExpressionsRule handles duplicate constraints</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsDup2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where deptno=7 and deptno=8\n"
operator|+
literal|"and empno = 10 and mgr is null and empno = 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullNull
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where deptno=7\n"
operator|+
literal|"and empno = 10 and mgr is null and empno = 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstants2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select p1 is not distinct from p0 from (values (2, cast(null as integer))) as t(p0, p1)"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-902">[CALCITE-902]    * Match nullability when reducing expressions in a Project</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsProjectNullable
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select mgr from emp where mgr=10"
argument_list|)
expr_stmt|;
block|}
comment|// see HIVE-9645
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsNullEqualsOne
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(1) from emp where cast(null as integer) = 1"
argument_list|)
expr_stmt|;
block|}
comment|// see HIVE-9644
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCaseEquals
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Equivalent to 'deptno = 10'
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  else 3 end = 1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCaseEquals2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Equivalent to 'case when deptno = 20 then false
comment|//                     when deptno = 10 then true
comment|//                     else null end'
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  else cast(null as integer) end = 1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCaseEquals3
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Equivalent to 'deptno = 30 or deptno = 10'
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 30 then 1\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  when 30 then 111\n"
operator|+
literal|"  else 0 end = 1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsEliminatesFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// WHERE NULL is the same as WHERE FALSE, so get empty result
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (values (1,2)) where 1 + 2> 3 + CAST(NULL AS INTEGER)"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-566">[CALCITE-566]    * ReduceExpressionsRule requires planner to have an Executor</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsRequiresExecutor
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Remove the executor
name|tester
operator|.
name|convertSqlToRel
argument_list|(
literal|"values 1"
argument_list|)
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|setExecutor
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Rule should not fire, but there should be no NPE
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1,2)) where 1 + 2> 3 + CAST(NULL AS INTEGER)"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAlreadyFalseEliminatesFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (values (1,2)) where false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCalc
parameter_list|()
throws|throws
name|Exception
block|{
comment|// This reduction does not work using
comment|// ReduceExpressionsRule.PROJECT_INSTANCE or FILTER_INSTANCE,
comment|// only CALC_INSTANCE, because we need to pull the project expression
comment|//    upper('table')
comment|// into the condition
comment|//    upper('table') = 'TABLE'
comment|// and reduce it to TRUE. Only in the Calc are projects and conditions
comment|// combined.
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CalcMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
comment|// the hard part is done... a few more rule calls to clean up
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CalcMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Result should be same as typing
comment|//  SELECT * FROM (VALUES ('TABLE        ', 'T')) AS T(U, S)
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"  select upper(substring(x FROM 1 FOR 2) || substring(x FROM 3)) as u,\n"
operator|+
literal|"      substring(x FROM 1 FOR 1) as s\n"
operator|+
literal|"  from (\n"
operator|+
literal|"    select 'table' as x from (values (true))\n"
operator|+
literal|"    union\n"
operator|+
literal|"    select 'view' from (values (true))\n"
operator|+
literal|"    union\n"
operator|+
literal|"    select 'foreign table' from (values (true))\n"
operator|+
literal|"  )\n"
operator|+
literal|") where u = 'TABLE'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.ename from emp e, dept d "
operator|+
literal|"where e.deptno = d.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinWithFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.ename from emp e, dept d "
operator|+
literal|"where e.deptno = d.deptno and e.ename = 'foo'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinRight
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinRightWithFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.ename from emp e1, dept d, emp e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno "
operator|+
literal|"and d.name = 'foo'"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkPlanning
parameter_list|(
name|String
name|query
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|tester1
init|=
name|tester
operator|.
name|withCatalogReaderFactory
argument_list|(
operator|new
name|Function
argument_list|<
name|RelDataTypeFactory
argument_list|,
name|Prepare
operator|.
name|CatalogReader
argument_list|>
argument_list|()
block|{
specifier|public
name|Prepare
operator|.
name|CatalogReader
name|apply
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
return|return
operator|new
name|MockCatalogReader
argument_list|(
name|typeFactory
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|MockCatalogReader
name|init
parameter_list|()
block|{
comment|// CREATE SCHEMA abc;
comment|// CREATE TABLE a(a INT);
comment|// ...
comment|// CREATE TABLE j(j INT);
name|MockSchema
name|schema
init|=
operator|new
name|MockSchema
argument_list|(
literal|"SALES"
argument_list|)
decl_stmt|;
name|registerSchema
argument_list|(
name|schema
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|intType
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|String
name|t
init|=
name|String
operator|.
name|valueOf
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'A'
operator|+
name|i
operator|)
argument_list|)
decl_stmt|;
name|MockTable
name|table
init|=
name|MockTable
operator|.
name|create
argument_list|(
name|this
argument_list|,
name|schema
argument_list|,
name|t
argument_list|,
literal|false
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|table
operator|.
name|addColumn
argument_list|(
name|t
argument_list|,
name|intType
argument_list|)
expr_stmt|;
name|registerTable
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
block|}
operator|.
name|init
argument_list|()
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectRemoveRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinToMultiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester1
argument_list|,
literal|null
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|query
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins
parameter_list|()
throws|throws
name|Exception
block|{
name|checkPlanning
argument_list|(
literal|"select * from "
operator|+
literal|"    (select * from "
operator|+
literal|"        (select * from "
operator|+
literal|"            (select * from A right outer join B on a = b) "
operator|+
literal|"            left outer join "
operator|+
literal|"            (select * from C full outer join D on c = d)"
operator|+
literal|"            on a = c and b = d) "
operator|+
literal|"        right outer join "
operator|+
literal|"        (select * from "
operator|+
literal|"            (select * from E full outer join F on e = f) "
operator|+
literal|"            right outer join "
operator|+
literal|"            (select * from G left outer join H on g = h) "
operator|+
literal|"            on e = g and f = h) "
operator|+
literal|"        on a = e and b = f and c = g and d = h) "
operator|+
literal|"    inner join "
operator|+
literal|"    (select * from I inner join J on i = j) "
operator|+
literal|"    on a = i and h = j"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins2
parameter_list|()
throws|throws
name|Exception
block|{
comment|// in (A right join B) join C, pushing C is not allowed;
comment|// therefore there should be 2 MultiJoin
name|checkPlanning
argument_list|(
literal|"select * from A right join B on a = b join C on b = c"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins3
parameter_list|()
throws|throws
name|Exception
block|{
comment|// in (A join B) left join C, pushing C is allowed;
comment|// therefore there should be 1 MultiJoin
name|checkPlanning
argument_list|(
literal|"select * from A join B on a = b left join C on b = c"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins4
parameter_list|()
throws|throws
name|Exception
block|{
comment|// in (A join B) right join C, pushing C is not allowed;
comment|// therefore there should be 2 MultiJoin
name|checkPlanning
argument_list|(
literal|"select * from A join B on a = b right join C on b = c"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastProject
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinAddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SemiJoinProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.* from "
operator|+
literal|"(select ename, trim(job), sal * 2, deptno from emp) e, dept d "
operator|+
literal|"where e.deptno = d.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select a, b from (values (10,'x')) as t(a, b)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a, b from (values (10, 'x'), (20, 'y')) as t(a, b) where a< 15"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderProject
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select a, b as x from (values (11), (23)) as t(x)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b from (values (10, 1), (20, 3)) as t(a, b)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderProjectFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (11, 1, 10), (23, 3, 20)) as t(x, b, a)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b as x, b, a from (values (10, 1), (30, 7), (20, 3)) as t(a, b)"
operator|+
literal|" where a - b< 21"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testReduceCase
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|"  case when false then cast(2.1 as float)\n"
operator|+
literal|"   else cast(1 as integer) end as newcol\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsIsNull
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select empno from emp where empno=10 and empno is null"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsIsNotNull
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp\n"
operator|+
literal|"where empno=10 and empno is not null"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsNegated
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp\n"
operator|+
literal|"where empno=10 and not(empno=10)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsNegatedInverted
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp where empno>10 and empno<=10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// Calcite does not support INSERT yet
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesNull
parameter_list|()
throws|throws
name|Exception
block|{
comment|// The NULL literal presents pitfalls for value-reduction. Only
comment|// an INSERT statement contains un-CASTed NULL values.
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"insert into sales.depts(deptno,name) values (NULL, 'null')"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesToEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (11, 1, 10), (23, 3, 20)) as t(x, b, a)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b as x, b, a from (values (10, 1), (30, 7)) as t(a, b)"
operator|+
literal|" where a - b< 0"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyFilterProjectUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (30, 3)) as t(x, y)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from (values (20, 2))\n"
operator|+
literal|")\n"
operator|+
literal|"where x + y> 30"
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1488">[CALCITE-1488]    * ValuesReduceRule should ignore empty Values</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testEmptyProject
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select z + x from (\n"
operator|+
literal|"  select x + y as z, x from (\n"
operator|+
literal|"    select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"    where x + y> 50))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Same query as {@link #testEmptyProject()}, and {@link PruneEmptyRules}    * is able to do the job that {@link ValuesReduceRule} cannot do. */
annotation|@
name|Test
specifier|public
name|void
name|testEmptyProject2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select z + x from (\n"
operator|+
literal|"  select x + y as z, x from (\n"
operator|+
literal|"    select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"    where x + y> 50))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyIntersect
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3))"
operator|+
literal|"intersect\n"
operator|+
literal|"select *\nfrom (values (10, 1), (30, 3)) as t (x, y) where x> 50\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from (values (30, 3))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyMinus
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// First input is empty; therefore whole expression is empty
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3)) as t (x, y)\n"
operator|+
literal|"where x> 30\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (20, 2))\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (40, 4))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyMinus2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Second and fourth inputs are empty; they are removed
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3)) as t (x, y)\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (20, 2)) as t (x, y) where x> 30\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (40, 4))\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (50, 5)) as t (x, y) where x> 50"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoin
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be empty
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from emp where false)\n"
operator|+
literal|"join dept using (deptno)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoinLeft
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be empty
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from emp where false)\n"
operator|+
literal|"left join dept using (deptno)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoinRight
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be equivalent to "select * from emp join dept".
comment|// Cannot optimize away the join because of RIGHT.
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from emp where false)\n"
operator|+
literal|"right join dept using (deptno)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptySort
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|SORT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp where false order by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptySortLimitZero
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|SORT_FETCH_ZERO_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp order by deptno limit 0"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyAggregate
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|AGGREGATE_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(empno) from emp where false group by deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyAggregateEmptyKey
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|AGGREGATE_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sum(empno) from emp where false"
decl_stmt|;
specifier|final
name|boolean
name|unchanged
init|=
literal|true
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|,
name|unchanged
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyAggregateEmptyKeyWithAggregateValuesRule
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateValuesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*), sum(empno) from emp where false"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceCasts
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// The resulting plan should have no cast expressions
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select cast(d.name as varchar(128)), cast(e.empno as integer) "
operator|+
literal|"from dept as d inner join emp as e "
operator|+
literal|"on cast(d.deptno as integer) = cast(e.deptno as integer) "
operator|+
literal|"where cast(e.job as varchar(1)) = 'Manager'"
argument_list|)
expr_stmt|;
block|}
comment|/** Tests that a cast from a TIME to a TIMESTAMP is not reduced. It is not    * constant because the result depends upon the current date. */
annotation|@
name|Test
specifier|public
name|void
name|testReduceCastTimeUnchanged
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
literal|"select cast(time '12:34:56' as timestamp) from emp as e"
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceCastAndConsts
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Make sure constant expressions inside the cast can be reduced
comment|// in addition to the casts.
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp "
operator|+
literal|"where cast((empno + (10/2)) as int) = 13"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// Calcite does not support INSERT yet
annotation|@
name|Test
specifier|public
name|void
name|testReduceCastsNullable
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
comment|// Simulate the way INSERT will insert casts to the target types
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|CoerceInputsRule
argument_list|(
name|LogicalTableModify
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
comment|// Convert projects to calcs, merge two calcs, and then
comment|// reduce redundant casts in merged calc.
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CalcMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"insert into sales.depts(name) "
operator|+
literal|"select cast(gender as varchar(128)) from sales.emps"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|basePushAggThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateUnionTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"${sql}"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumConstantThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullConstantThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullableNOGBYThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushCountStarThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushCountNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushMaxNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushMinThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushAvgThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumCountStarThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumConstantGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullConstantGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullableGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushCountStarGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushCountNullableGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushMaxNullableGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushMinGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushAvgGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumCountStarGroupingSetsThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushCountFilterThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullFilterThroughAggregate
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal, deptno from ("
operator|+
literal|"  select ename, sal, deptno"
operator|+
literal|"  from emp"
operator|+
literal|"  where sal> 5000)"
operator|+
literal|"group by ename, sal, deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullFilterThroughAggregateGroupingSets
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|preProgram
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateFilterTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal, deptno from ("
operator|+
literal|"  select ename, sal, deptno"
operator|+
literal|"  from emp"
operator|+
literal|"  where sal> 5000)"
operator|+
literal|"group by rollup(ename, sal, deptno)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|basePullConstantTroughAggregate
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"${sql}"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughConstLast
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateSimpleNonNullable
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermuted
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermutedConstFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermutedConstGroupBy
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateConstGroupBy
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateAllConst
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateAllLiterals
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select 2, deptno, job from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 2, deptno, job from emp as e2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughUnion2
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Negative test: constants should not be pulled up
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select 2, deptno, job from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 1, deptno, job from emp as e2"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughUnion3
parameter_list|()
throws|throws
name|Exception
block|{
comment|// We should leave at least a single column in each Union input
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|UnionPullUpConstantsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select 2, 3 from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 2, 3 from emp as e2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateProjectMerge
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select x, sum(z), y from (\n"
operator|+
literal|"  select deptno as x, empno as y, sal as z, sal * 2 as zz\n"
operator|+
literal|"  from emp)\n"
operator|+
literal|"group by x, y"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateGroupingSetsProjectMerge
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select x, sum(z), y from (\n"
operator|+
literal|"  select deptno as x, empno as y, sal as z, sal * 2 as zz\n"
operator|+
literal|"  from emp)\n"
operator|+
literal|"group by rollup(x, y)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullAggregateThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateUnionAggregateRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select deptno, job from"
operator|+
literal|" (select deptno, job from emp as e1"
operator|+
literal|" group by deptno,job"
operator|+
literal|"  union all"
operator|+
literal|" select deptno, job from emp as e2"
operator|+
literal|" group by deptno,job)"
operator|+
literal|" group by deptno,job"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|transitiveInference
parameter_list|(
name|RelOptRule
modifier|...
name|extraRules
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
name|diffRepos
operator|.
name|expand
argument_list|(
literal|null
argument_list|,
literal|"${sql}"
argument_list|)
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|DUMB_FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
specifier|final
name|RelRoot
name|root
init|=
name|tester
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|relInitial
init|=
name|root
operator|.
name|rel
decl_stmt|;
name|assertTrue
argument_list|(
name|relInitial
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelMetadataProvider
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|DefaultRelMetadataProvider
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|RelMetadataProvider
name|plannerChain
init|=
name|ChainedRelMetadataProvider
operator|.
name|of
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|relInitial
operator|.
name|getCluster
argument_list|()
operator|.
name|setMetadataProvider
argument_list|(
operator|new
name|CachingRelMetadataProvider
argument_list|(
name|plannerChain
argument_list|,
name|planner
argument_list|)
argument_list|)
expr_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|relInitial
argument_list|)
expr_stmt|;
name|RelNode
name|relBefore
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relBefore
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|HepProgram
name|program2
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|DUMB_FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterSetOpTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinPushTransitivePredicatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleCollection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|extraRules
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepPlanner
name|planner2
init|=
operator|new
name|HepPlanner
argument_list|(
name|program2
argument_list|)
decl_stmt|;
name|planner
operator|.
name|registerMetadataProviders
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|planner2
operator|.
name|setRoot
argument_list|(
name|relBefore
argument_list|)
expr_stmt|;
name|RelNode
name|relAfter
init|=
name|planner2
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceProject
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceAggregate
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceJoin3way
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceJoin3wayAgg
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceLeftOuterJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceRightOuterJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceFullOuterJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferencePreventProjectPullUp
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferencePullUpThruAlias
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceConjunctInPullUp
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceNoPullUpExprs
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceUnion3way
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"not working"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceUnion3wayOr
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-443">[CALCITE-443]    * getPredicates from a union is not correct</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceUnionAlwaysTrue
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceConstantEquiPredicate
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTransitiveInferenceComplexPredicate
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantIntoProject
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantIntoFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantIntoJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantIntoJoin2
parameter_list|()
throws|throws
name|Exception
block|{
name|transitiveInference
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectWindowTransposeRule
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectWindowTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(empno) over(), deptno from emp"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testProjectWindowTransposeRuleWithConstants
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectWindowTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select col1, col2\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select empno,\n"
operator|+
literal|"    sum(100) over (partition by  deptno order by sal) as col1,\n"
operator|+
literal|"  sum(1000) over(partition by deptno order by sal) as col2\n"
operator|+
literal|"  from emp)"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateProjectPullUpConstants
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select job, empno, sal, sum(sal) as s\n"
operator|+
literal|"from emp where empno = 10\n"
operator|+
literal|"group by job, empno, sal"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterWithRank
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename, r\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select ename, "
operator|+
literal|"  rank() over(partition by  deptno order by sal) as r "
operator|+
literal|"  from emp) e1\n"
operator|+
literal|"where r< 2"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterWithRankExpr
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename, r\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select ename,\n"
operator|+
literal|"  rank() over(partition by  deptno order by sal) + 1 as r "
operator|+
literal|"  from emp) e1\n"
operator|+
literal|"where r< 2"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-841">[CALCITE-841]    * Redundant windows when window function arguments are expressions</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testExpressionInWindowFunction
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|" sum(deptno) over(partition by deptno order by sal) as sum1,\n"
operator|+
literal|"sum(deptno + sal) over(partition by deptno order by sal) as sum2\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-888">[CALCITE-888]    * Overlay window loses PARTITION BY list</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testWindowInParenthesis
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) over (w), count(*) over w\n"
operator|+
literal|"from emp\n"
operator|+
literal|"window w as (partition by empno order by empno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-750">[CALCITE-750]    * Allow windowed aggregate on top of regular aggregate</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testNestedAggregates
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToWindowRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT\n"
operator|+
literal|"  avg(sum(sal) + 2 * min(empno) + 3 * avg(empno))\n"
operator|+
literal|"  over (partition by deptno)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin1
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.job,d.name\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin2
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.job,d.name\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"and e.deptno + e.empno = d.deptno + 5\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin3
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.empno,d.deptno\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.empno< d.deptno\n"
operator|+
literal|"group by e.empno,d.deptno"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1544">[CALCITE-1544]    * AggregateJoinTransposeRule fails to preserve row type</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin4
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno\n"
operator|+
literal|"from sales.emp as e join sales.dept as d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoin5
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno, d.deptno\n"
operator|+
literal|"from sales.emp as e join sales.dept as d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno, d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** SUM is the easiest aggregate function to split. */
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateSumThroughJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.job,sum(sal)\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Push a variety of aggregate functions. */
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateFunctionsThroughJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select e.job,\n"
operator|+
literal|"  min(sal) as min_sal, min(e.deptno) as min_deptno,\n"
operator|+
literal|"  sum(sal) + 1 as sum_sal_plus, max(sal) as max_sal,\n"
operator|+
literal|"  sum(sal) as sum_sal_2, count(sal) as count_sal,\n"
operator|+
literal|"  count(mgr) as count_mgr\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Push a aggregate functions into a relation that is unique on the join    * key. */
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateThroughJoinDistinct
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select d.name,\n"
operator|+
literal|"  sum(sal) as sum_sal, count(*) as c\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"join (select distinct name from sales.dept) as d\n"
operator|+
literal|"  on e.job = d.name\n"
operator|+
literal|"group by d.name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Push count(*) through join, no GROUP BY. */
annotation|@
name|Test
specifier|public
name|void
name|testPushAggregateSumNoGroup
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateJoinTransposeRule
operator|.
name|EXTENDED
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from sales.emp join sales.dept on job = name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSwapOuterJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinCommuteRule
operator|.
name|SWAP_OUTER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select 1 from sales.dept d left outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushJoinCondDownToProject
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|JoinPushExpressionsRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select d.deptno, e.deptno from sales.dept d, sales.emp e"
operator|+
literal|" where d.deptno + 10 = e.deptno * 2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e left join (\n"
operator|+
literal|"select * from sales.dept d) using (deptno)\n"
operator|+
literal|"order by sal limit 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"select * from sales.dept d) using (deptno)\n"
operator|+
literal|"order by name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp left join (\n"
operator|+
literal|"select * from sales.dept) using (deptno)\n"
operator|+
literal|"order by sal, name limit 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-931">[CALCITE-931]    * Wrong collation trait in SortJoinTransposeRule for right joins</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose4
parameter_list|()
block|{
comment|// Create a customized test with RelCollation trait in the test cluster.
name|Tester
name|tester
init|=
operator|new
name|TesterImpl
argument_list|(
name|getDiffRepos
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RelOptPlanner
name|createPlanner
parameter_list|()
block|{
return|return
operator|new
name|MockRelOptPlanner
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|RelTraitDef
argument_list|>
name|getRelTraitDefs
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
expr|<
name|RelTraitDef
operator|>
name|of
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelTraitSet
name|emptyTraitSet
parameter_list|()
block|{
return|return
name|RelTraitSet
operator|.
name|createEmpty
argument_list|()
operator|.
name|plus
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
operator|.
name|getDefault
argument_list|()
argument_list|)
return|;
block|}
block|}
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"select * from sales.dept d) using (deptno)\n"
operator|+
literal|"order by name"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1498">[CALCITE-1498]    * Avoid LIMIT with trivial ORDER BY being pushed through JOIN endlessly</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose5
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// SortJoinTransposeRule should not be fired again.
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"select * from sales.dept d) using (deptno)\n"
operator|+
literal|"limit 10"
decl_stmt|;
name|checkPlanning
argument_list|(
name|tester
argument_list|,
name|preProgram
argument_list|,
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1507">[CALCITE-1507]    * OFFSET cannot be pushed through a JOIN if the non-preserved side of outer    * join is not count-preserving</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose6
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one can be pushed down even if it has an OFFSET, since the dept
comment|// table is count-preserving against the join condition.
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, empno from sales.dept d\n"
operator|+
literal|"right join sales.emp e using (deptno) limit 10 offset 2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1507">[CALCITE-1507]    * OFFSET cannot be pushed through a JOIN if the non-preserved side of outer    * join is not count-preserving</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testSortJoinTranspose7
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, empno from sales.dept d\n"
operator|+
literal|"left join sales.emp e using (deptno) order by d.deptno offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortProjectTranspose1
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one can be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as integer) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortProjectTranspose2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one can be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as double) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSortProjectTranspose3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as varchar(10)) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1023">[CALCITE-1023]    * Planner rule that removes Aggregate keys that are constant</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateConstantKeyRule
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno, sal"
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Tests {@link AggregateProjectPullUpConstantsRule} where reduction is not    * possible because "deptno" is the only key. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateConstantKeyRule2
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
comment|/** Tests {@link AggregateProjectPullUpConstantsRule} where both keys are    * constants but only one can be removed. */
annotation|@
name|Test
specifier|public
name|void
name|testAggregateConstantKeyRule3
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectPullUpConstantsRule
operator|.
name|INSTANCE2
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select job\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where sal is null and job = 'Clerk'\n"
operator|+
literal|"group by sal, job\n"
operator|+
literal|"having count(*)> 3"
decl_stmt|;
name|checkPlanning
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
name|sql
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceExpressionsNot
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanUnchanged
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"select * from (values (false),(true)) as q (col1) where not(col1)"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Sql
name|checkSubQuery
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|FILTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/** Tests expanding a sub-query, specifically an uncorrelated scalar    * sub-query in a project (SELECT clause). */
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectScalar
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1493">[CALCITE-1493]    * Wrong plan for NOT IN correlated queries</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testWhereNotInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal from emp\n"
operator|+
literal|"where empno NOT IN (\n"
operator|+
literal|"  select deptno from dept\n"
operator|+
literal|"  where emp.job = dept.name)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWhereNotInCorrelated2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.empno NOT IN\n"
operator|+
literal|"   (select empno from (select ename, empno, sal as r from emp) e2\n"
operator|+
literal|"    where r> 2 and e1.ename= e2.ename)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1546">[CALCITE-1546]    * Sub-queries connected by OR</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testWhereOrSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp\n"
operator|+
literal|"where sal = 4\n"
operator|+
literal|"or empno NOT IN (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectIn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  deptno in (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectInNullable
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"with e2 as (\n"
operator|+
literal|"  select empno, case when true then deptno else null end as deptno\n"
operator|+
literal|"  from sales.emp)\n"
operator|+
literal|"select empno,\n"
operator|+
literal|"  deptno in (select deptno from e2 where empno< 20) as d\n"
operator|+
literal|"from e2"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectInComposite
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, (empno, deptno) in (\n"
operator|+
literal|"    select empno, deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandProjectExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  exists (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterScalar
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"< (select deptno from sales.emp where empno> 100)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterIn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno in (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterInComposite
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where (empno, deptno) in (\n"
operator|+
literal|"  select empno, deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** An IN filter that requires full 3-value logic (true, false, unknown). */
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterIn3Value
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where empno\n"
operator|+
literal|"< case deptno in (select case when true then deptno else null end\n"
operator|+
literal|"                   from sales.emp where empno< 20)\n"
operator|+
literal|"   when true then 10\n"
operator|+
literal|"   when false then 20\n"
operator|+
literal|"   else 30\n"
operator|+
literal|"   end"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** An EXISTS filter that can be converted into true/false. */
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** An EXISTS filter that can be converted into a semi-join. */
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterExistsSimple
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** An EXISTS filter that can be converted into a semi-join. */
annotation|@
name|Test
specifier|public
name|void
name|testExpandFilterExistsSimpleAnd
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"and emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandJoinScalar
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"< (select deptno from sales.emp where empno> 100)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testExpandJoinIn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on emp.deptno in (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testExpandJoinInComposite
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on (emp.empno, dept.deptno) in (\n"
operator|+
literal|"  select empno, deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandJoinExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on exists (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp\n"
operator|+
literal|"where EXISTS (\n"
operator|+
literal|"  select * from emp e where emp.deptno = e.deptno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1511">[CALCITE-1511]    * AssertionError while decorrelating query with two EXISTS    * sub-queries</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateTwoExists
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp\n"
operator|+
literal|"where EXISTS (\n"
operator|+
literal|"  select * from emp e where emp.deptno = e.deptno)\n"
operator|+
literal|"AND NOT EXISTS (\n"
operator|+
literal|"  select * from emp ee where ee.job = emp.job AND ee.sal=34)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1537">[CALCITE-1537]    * Unnecessary project expression in multi-sub-query plan</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateTwoIn
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where empno IN (\n"
operator|+
literal|"  select deptno from dept where emp.job = dept.name)\n"
operator|+
literal|"AND empno IN (\n"
operator|+
literal|"  select empno from emp e where emp.ename = e.ename)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1045">[CALCITE-1045]    * Decorrelate sub-queries in Project and Join</a>, with the added    * complication that there are two sub-queries. */
annotation|@
name|Ignore
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testDecorrelateTwoScalar
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno,\n"
operator|+
literal|"  (select min(1) from emp where empno> d.deptno) as i0,\n"
operator|+
literal|"  (select min(0) from emp\n"
operator|+
literal|"    where deptno = d.deptno and ename = 'SMITH') as i1\n"
operator|+
literal|"from dept as d"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWhereInJoinCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp as e\n"
operator|+
literal|"join dept as d using (deptno)\n"
operator|+
literal|"where e.sal in (\n"
operator|+
literal|"  select e2.sal from emp as e2 where e2.deptno> e.deptno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1494">[CALCITE-1494]    * Inefficient plan for correlated sub-queries</a>. In "planAfter", there    * must be only one scan each of emp and dept. We don't need a separate    * value-generator for emp.job. */
annotation|@
name|Test
specifier|public
name|void
name|testWhereInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal from emp where empno IN (\n"
operator|+
literal|"  select deptno from dept where emp.job = dept.name)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWhereExpressionInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (\n"
operator|+
literal|"  select ename, deptno, sal + 1 as salPlus from emp) as e\n"
operator|+
literal|"where deptno in (\n"
operator|+
literal|"  select deptno from emp where sal + 1 = e.salPlus)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWhereExpressionInCorrelated2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name from (\n"
operator|+
literal|"  select name, deptno, deptno - 10 as deptnoMinus from dept) as d\n"
operator|+
literal|"where deptno in (\n"
operator|+
literal|"  select deptno from emp where sal + 1 = d.deptnoMinus)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpandWhereComparisonCorrelated
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"where sal = (\n"
operator|+
literal|"  select max(sal) from sales.emp e2 where e2.empno = e.empno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomColumnResolvingInNonCorrelatedSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 in (\n"
operator|+
literal|"  select f1.c0 from struct.t t2)"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|FILTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomColumnResolvingInCorrelatedSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 = (\n"
operator|+
literal|"  select max(f1.c0) from struct.t t2 where t1.k0 = t2.k0)"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|FILTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCustomColumnResolvingInCorrelatedSubQuery2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 in (\n"
operator|+
literal|"  select f1.c0 from struct.t t2 where t1.c2 = t2.c2)"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|PROJECT
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|FILTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SubQueryRemoveRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-434">[CALCITE-434]    * Converting predicates on date dimension columns into date ranges</a>,    * specifically a rule that converts {@code EXTRACT(YEAR FROM ...) = constant}    * to a range. */
annotation|@
name|Test
specifier|public
name|void
name|testExtractYearToRange
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from sales.emp_b as e\n"
operator|+
literal|"where extract(year from birthdate) = 2014"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|DateRangeRules
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExtractYearMonthToRange
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from sales.emp_b as e\n"
operator|+
literal|"where extract(year from birthdate) = 2014"
operator|+
literal|"and extract(month from birthdate) = 4"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|DateRangeRules
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// End RelOptRulesTest.java
end_comment

end_unit

