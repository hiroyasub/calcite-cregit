begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableLimit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableLimitSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Contexts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ConventionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepMatchOrder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|VolcanoPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistributionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistributions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCorrelate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateExpandWithinDistinctRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateExtractProjectRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateReduceFunctionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CoerceInputsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|CoreRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|DateRangeRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterFlattenCorrelatedConditionRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterMultiJoinMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinAssociateRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinCommuteRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|MultiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectCorrelateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMultiJoinMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectToWindowRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|PruneEmptyRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|PushProjector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ReduceExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ReduceExpressionsRule
operator|.
name|ProjectReduceExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SpatialRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|UnionMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ValuesReduceRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeSystemImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunctionCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLibrary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|OperandTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFactoryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlConformanceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonotonicity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|RelDecorrelator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlToRelConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|catalog
operator|.
name|MockCatalogReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|catalog
operator|.
name|MockCatalogReaderExtended
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Program
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Programs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RuleSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RuleSets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Disabled
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertNotNull
import|;
end_import

begin_comment
comment|/**  * Unit test for rules in {@code org.apache.calcite.rel} and subpackages.  *  *<p>As input, the test supplies a SQL statement and a single rule; the SQL is  * translated into relational algebra and then fed into a  * {@link org.apache.calcite.plan.hep.HepPlanner}. The planner fires the rule on  * every  * pattern match in a depth-first left-to-right pre-order traversal of the tree  * for as long as the rule continues to succeed in applying its transform. (For  * rules which call transformTo more than once, only the last result is used.)  * The plan before and after "optimization" is diffed against a .ref file using  * {@link DiffRepository}.  *  *<p>Procedure for adding a new test case:  *  *<ol>  *<li>Add a new public test method for your rule, following the existing  * examples. You'll have to come up with an SQL statement to which your rule  * will apply in a meaningful way. See {@link SqlToRelTestBase} class comments  * for details on the schema.  *  *<li>Run the test. It should fail. Inspect the output in  * {@code target/surefire/.../RelOptRulesTest.xml}.  * (If you are running using maven and this file does not exist, add a  * {@code -X} flag to the maven command line.)  *  *<li>Verify that the "planBefore" is the correct  * translation of your SQL, and that it contains the pattern on which your rule  * is supposed to fire. If all is well, replace  * {@code src/test/resources/.../RelOptRulesTest.xml} and  * with the new {@code target/surefire/.../RelOptRulesTest.xml}.  *  *<li>Run the test again. It should fail again, but this time it should contain  * a "planAfter" entry for your rule. Verify that your rule applied its  * transformation correctly, and then update the  * {@code src/test/resources/.../RelOptRulesTest.xml} file again.  *  *<li>Run the test one last time; this time it should pass.  *</ol>  */
end_comment

begin_class
class|class
name|RelOptRulesTest
extends|extends
name|RelOptTestBase
block|{
comment|//~ Methods ----------------------------------------------------------------
specifier|private
specifier|static
name|boolean
name|skipItem
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|expr
operator|instanceof
name|RexCall
operator|&&
literal|"item"
operator|.
name|equalsIgnoreCase
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|DiffRepository
name|getDiffRepos
parameter_list|()
block|{
return|return
name|DiffRepository
operator|.
name|lookup
argument_list|(
name|RelOptRulesTest
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Test
name|void
name|testReduceNot
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (select (case when sal> 1000 then null else false end) as caseCol from emp)\n"
operator|+
literal|"where NOT(caseCol)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testReduceNestedCaseWhen
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when (sal = 1000) then\n"
operator|+
literal|"(case when sal = 1000 then null else 1 end is null) else\n"
operator|+
literal|"(case when sal = 2000 then null else 1 end is null) end is true"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDigestOfApproximateDistinctAggregateCall
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|AggregateProjectMergeRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (\n"
operator|+
literal|"select deptno, count(distinct empno) from emp group by deptno\n"
operator|+
literal|"union all\n"
operator|+
literal|"select deptno, approx_count_distinct(empno) from emp group by deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1479">[CALCITE-1479]    * AssertionError in ReduceExpressionsRule on multi-column IN    * sub-query</a>. */
annotation|@
name|Test
name|void
name|testReduceCompositeInSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where (empno, deptno) in (\n"
operator|+
literal|"  select empno, deptno from (\n"
operator|+
literal|"    select empno, deptno\n"
operator|+
literal|"    from emp\n"
operator|+
literal|"    group by empno, deptno))\n"
operator|+
literal|"or deptno< 40 + 60"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withRelBuilderConfig
argument_list|(
name|b
lambda|->
name|b
operator|.
name|withAggregateUnique
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2865">[CALCITE-2865]    * FilterProjectTransposeRule generates wrong traitSet when copyFilter/Project is true</a>. */
annotation|@
name|Test
name|void
name|testFilterProjectTransposeRule
parameter_list|()
block|{
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|rules
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
comment|// default: copyFilter=true, copyProject=true
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
operator|.
name|config
operator|.
name|withOperandFor
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|filter
lambda|->
operator|!
name|RexUtil
operator|.
name|containsCorrelation
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|,
name|Project
operator|.
name|class
argument_list|,
name|project
lambda|->
literal|true
argument_list|)
operator|.
name|withCopyFilter
argument_list|(
literal|false
argument_list|)
operator|.
name|withCopyProject
argument_list|(
literal|false
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|rules
control|)
block|{
name|RelBuilder
name|b
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|in
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|sort
argument_list|(
operator|-
literal|4
argument_list|)
comment|// salary desc
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|3
argument_list|)
argument_list|)
comment|// salary
operator|.
name|filter
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|11500
argument_list|)
argument_list|)
argument_list|)
comment|// salary = 11500
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|rule
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|RelNode
name|result
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
comment|// Verify LogicalFilter traitSet (must be [3 DESC])
name|RelNode
name|filter
init|=
name|result
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelCollation
name|collation
init|=
name|filter
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|collation
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|collation
operator|.
name|getFieldCollations
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fieldCollations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|RelFieldCollation
name|fieldCollation
init|=
name|fieldCollations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
argument_list|,
name|fieldCollation
operator|.
name|getDirection
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
name|void
name|testReduceOrCaseWhen
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when sal = 1000 then null else 1 end is null\n"
operator|+
literal|"OR case when sal = 2000 then null else 1 end is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testReduceNullableCase
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT CASE WHEN 1=2 "
operator|+
literal|"THEN cast((values(1)) as integer) "
operator|+
literal|"ELSE 2 end from (values(1))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testReduceNullableCase2
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, ename, CASE WHEN 1=2 "
operator|+
literal|"THEN substring(ename, 1, cast(2 as int)) ELSE NULL end from emp"
operator|+
literal|" group by deptno, ename, case when 1=2 then substring(ename,1, cast(2 as int))  else null end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testProjectToWindowRuleForMultipleWindows
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|" count(*) over(partition by empno order by sal) as count1,\n"
operator|+
literal|" count(*) over(partition by deptno order by sal) as count2,\n"
operator|+
literal|" sum(deptno) over(partition by empno order by sal) as sum1,\n"
operator|+
literal|" sum(deptno) over(partition by deptno order by sal) as sum2\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testUnionToDistinctRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from dept union select * from dept"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_TO_DISTINCT
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testExtractJoinFilterRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from emp inner join dept on emp.deptno=dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_EXTRACT_FILTER
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testNotPushExpression
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from emp inner join dept\n"
operator|+
literal|"on emp.deptno=dept.deptno and emp.ename is not null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_EXPRESSIONS
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testAddRedundantSemiJoinRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from emp inner join dept on emp.deptno = dept.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testStrengthenJoinType
parameter_list|()
block|{
comment|// The "Filter(... , right.c IS NOT NULL)" above a left join is pushed into
comment|// the join, makes it an inner join, and then disappears because c is NOT
comment|// NULL.
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept left join emp on dept.deptno = emp.deptno\n"
operator|+
literal|"where emp.deptno is not null and emp.sal> 100"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3170">[CALCITE-3170]    * ANTI join on conditions push down generates wrong plan</a>. */
annotation|@
name|Test
name|void
name|testCanNotPushAntiJoinConditionsToLeft
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select * from emp
comment|// where emp.deptno
comment|// not in (select dept.deptno from dept where emp.deptno> 20)
name|checkCanNotPushSemiOrAntiJoinConditionsToLeft
argument_list|(
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testCanNotPushAntiJoinConditionsToRight
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select * from emp
comment|// where emp.deptno
comment|// not in (select dept.deptno from dept where dept.dname = 'ddd')
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|antiJoin
argument_list|(
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DNAME"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|"ddd"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_CONDITION_PUSH
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3171">[CALCITE-3171]    * SemiJoin on conditions push down throws IndexOutOfBoundsException</a>. */
annotation|@
name|Test
name|void
name|testPushSemiJoinConditionsToLeft
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select * from emp
comment|// where emp.deptno
comment|// in (select dept.deptno from dept where emp.empno> 20)
name|checkCanNotPushSemiOrAntiJoinConditionsToLeft
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCanNotPushSemiOrAntiJoinConditionsToLeft
parameter_list|(
name|JoinRelType
name|type
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|left
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|right
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|left
argument_list|)
operator|.
name|push
argument_list|(
name|right
argument_list|)
operator|.
name|join
argument_list|(
name|type
argument_list|,
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|b
operator|.
name|greaterThan
argument_list|(
name|RexInputRef
operator|.
name|of
argument_list|(
literal|0
argument_list|,
name|left
operator|.
name|getRowType
argument_list|()
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3979">[CALCITE-3979]    * ReduceExpressionsRule might have removed CAST expression(s) incorrectly</a>. */
annotation|@
name|Test
name|void
name|testCastRemove
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|"case when cast(ename as double)< 5 then 0.0\n"
operator|+
literal|"     else coalesce(cast(ename as double), 1.0)\n"
operator|+
literal|"     end as t\n"
operator|+
literal|" from (\n"
operator|+
literal|"       select\n"
operator|+
literal|"          case when ename> 'abc' then ename\n"
operator|+
literal|"               else null\n"
operator|+
literal|"               end as ename from emp\n"
operator|+
literal|" )"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3887">[CALCITE-3887]    * Filter and Join conditions may not need to retain nullability during simplifications</a>. */
annotation|@
name|Test
name|void
name|testPushSemiJoinConditions
parameter_list|()
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|left
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|"ENAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|right
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|"DNAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|b
operator|.
name|push
argument_list|(
name|left
argument_list|)
operator|.
name|push
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|RexInputRef
name|ref1
init|=
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
decl_stmt|;
name|RexInputRef
name|ref2
init|=
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
decl_stmt|;
name|RexInputRef
name|ref3
init|=
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"ENAME"
argument_list|)
decl_stmt|;
name|RexInputRef
name|ref4
init|=
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DNAME"
argument_list|)
decl_stmt|;
comment|// ref1 IS NOT DISTINCT FROM ref2
name|RexCall
name|cond1
init|=
operator|(
name|RexCall
operator|)
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|ref1
argument_list|,
name|ref2
argument_list|)
argument_list|,
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|b
operator|.
name|isNull
argument_list|(
name|ref1
argument_list|)
argument_list|,
name|b
operator|.
name|isNull
argument_list|(
name|ref2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// ref3 IS NOT DISTINCT FROM ref4
name|RexCall
name|cond2
init|=
operator|(
name|RexCall
operator|)
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|ref3
argument_list|,
name|ref4
argument_list|)
argument_list|,
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|b
operator|.
name|isNull
argument_list|(
name|ref3
argument_list|)
argument_list|,
name|b
operator|.
name|isNull
argument_list|(
name|ref4
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|cond
init|=
name|b
operator|.
name|and
argument_list|(
name|cond1
argument_list|,
name|cond2
argument_list|)
decl_stmt|;
return|return
name|b
operator|.
name|semiJoin
argument_list|(
name|cond
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testFullOuterJoinSimplificationToLeftOuter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.dept d full outer join sales.emp e\n"
operator|+
literal|"on d.deptno = e.deptno\n"
operator|+
literal|"where d.name = 'Charlie'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testFullOuterJoinSimplificationToRightOuter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.dept d full outer join sales.emp e\n"
operator|+
literal|"on d.deptno = e.deptno\n"
operator|+
literal|"where e.sal> 100"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testFullOuterJoinSimplificationToInner
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.dept d full outer join sales.emp e\n"
operator|+
literal|"on d.deptno = e.deptno\n"
operator|+
literal|"where d.name = 'Charlie' and e.sal> 100"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testLeftOuterJoinSimplificationToInner
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.dept d left outer join sales.emp e\n"
operator|+
literal|"on d.deptno = e.deptno\n"
operator|+
literal|"where e.sal> 100"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRightOuterJoinSimplificationToInner
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.dept d right outer join sales.emp e\n"
operator|+
literal|"on d.deptno = e.deptno\n"
operator|+
literal|"where d.name = 'Charlie'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPushAboveFiltersIntoInnerJoinCondition
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|""
operator|+
literal|"select * from sales.dept d inner join sales.emp e\n"
operator|+
literal|"on d.deptno = e.deptno and d.deptno> e.mgr\n"
operator|+
literal|"where d.deptno> e.mgr"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3225">[CALCITE-3225]    * JoinToMultiJoinRule should not match SEMI/ANTI LogicalJoin</a>. */
annotation|@
name|Test
name|void
name|testJoinToMultiJoinDoesNotMatchSemiJoin
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select * from
comment|// (select * from emp join dept ON emp.deptno = emp.deptno) t
comment|// where emp.job in (select job from bonus)
name|checkJoinToMultiJoinDoesNotMatchSemiOrAntiJoin
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3225">[CALCITE-3225]    * JoinToMultiJoinRule should not match SEMI/ANTI LogicalJoin</a>. */
annotation|@
name|Test
name|void
name|testJoinToMultiJoinDoesNotMatchAntiJoin
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select * from
comment|// (select * from emp join dept ON emp.deptno = emp.deptno) t
comment|// where not exists (select job from bonus where emp.job = bonus.job)
name|checkJoinToMultiJoinDoesNotMatchSemiOrAntiJoin
argument_list|(
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkJoinToMultiJoinDoesNotMatchSemiOrAntiJoin
parameter_list|(
name|JoinRelType
name|type
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|left
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|right
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|semiRight
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"BONUS"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|left
argument_list|)
operator|.
name|push
argument_list|(
name|right
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|push
argument_list|(
name|semiRight
argument_list|)
operator|.
name|join
argument_list|(
name|type
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"JOB"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"JOB"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_MULTI_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPushFilterPastAgg
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select dname, c from\n"
operator|+
literal|"(select name dname, count(*) as c from dept group by name) t\n"
operator|+
literal|" where dname = 'Charlie'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_AGGREGATE_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|basePushFilterPastAggWithGroupingSets
parameter_list|(
name|boolean
name|unchanged
parameter_list|)
block|{
name|Sql
name|sql
init|=
name|sql
argument_list|(
literal|"${sql}"
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_AGGREGATE_TRANSPOSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|unchanged
condition|)
block|{
name|sql
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sql
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
name|void
name|testPushFilterPastAggWithGroupingSets1
parameter_list|()
block|{
name|basePushFilterPastAggWithGroupingSets
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPushFilterPastAggWithGroupingSets2
parameter_list|()
block|{
name|basePushFilterPastAggWithGroupingSets
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-434">[CALCITE-434]    * FilterAggregateTransposeRule loses conditions that cannot be pushed</a>. */
annotation|@
name|Test
name|void
name|testPushFilterPastAggTwo
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select dept1.c1 from (\n"
operator|+
literal|"select dept.name as c1, count(*) as c2\n"
operator|+
literal|"from dept where dept.name> 'b' group by dept.name) dept1\n"
operator|+
literal|"where dept1.c1> 'c' and (dept1.c2> 30 or dept1.c1< 'z')"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_AGGREGATE_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-799">[CALCITE-799]    * Incorrect result for {@code HAVING count(*)> 1}</a>. */
annotation|@
name|Test
name|void
name|testPushFilterPastAggThree
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno from emp\n"
operator|+
literal|"group by deptno having count(*)> 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_AGGREGATE_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1109">[CALCITE-1109]    * FilterAggregateTransposeRule pushes down incorrect condition</a>. */
annotation|@
name|Test
name|void
name|testPushFilterPastAggFour
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select emp.deptno, count(*) from emp where emp.sal> '12'\n"
operator|+
literal|"group by emp.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_FILTER_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_AGGREGATE_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-448">[CALCITE-448]    * FilterIntoJoinRule creates filters containing invalid RexInputRef</a>. */
annotation|@
name|Test
name|void
name|testPushFilterPastProject
parameter_list|()
block|{
specifier|final
name|FilterJoinRule
operator|.
name|Predicate
name|predicate
init|=
parameter_list|(
name|join
parameter_list|,
name|joinType
parameter_list|,
name|exp
parameter_list|)
lambda|->
name|joinType
operator|!=
name|JoinRelType
operator|.
name|INNER
decl_stmt|;
specifier|final
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
name|join
init|=
name|CoreRules
operator|.
name|JOIN_CONDITION_PUSH
operator|.
name|config
operator|.
name|withPredicate
argument_list|(
name|predicate
argument_list|)
operator|.
name|withDescription
argument_list|(
literal|"FilterJoinRule:no-filter"
argument_list|)
operator|.
name|as
argument_list|(
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
operator|.
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
name|filterOnJoin
init|=
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
operator|.
name|config
operator|.
name|withSmart
argument_list|(
literal|true
argument_list|)
operator|.
name|withPredicate
argument_list|(
name|predicate
argument_list|)
operator|.
name|as
argument_list|(
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
operator|.
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addGroupBegin
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|join
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|filterOnJoin
argument_list|)
operator|.
name|addGroupEnd
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select a.name\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join dept b on b.deptno> 10\n"
operator|+
literal|"right join dept c on b.deptno> 10\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4499">[CALCITE-4499]    * FilterJoinRule misses opportunity to push filter to semijoin input</a>. */
annotation|@
name|Test
name|void
name|testPushFilterSemijoin
parameter_list|()
block|{
specifier|final
name|FilterJoinRule
operator|.
name|Predicate
name|predicate
init|=
parameter_list|(
name|join
parameter_list|,
name|joinType
parameter_list|,
name|exp
parameter_list|)
lambda|->
name|joinType
operator|!=
name|JoinRelType
operator|.
name|INNER
decl_stmt|;
specifier|final
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
name|join
init|=
name|CoreRules
operator|.
name|JOIN_CONDITION_PUSH
operator|.
name|config
operator|.
name|withPredicate
argument_list|(
name|predicate
argument_list|)
operator|.
name|withDescription
argument_list|(
literal|"FilterJoinRule:no-filter"
argument_list|)
operator|.
name|as
argument_list|(
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
operator|.
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|left
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|right
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|left
argument_list|)
operator|.
name|push
argument_list|(
name|right
argument_list|)
operator|.
name|semiJoin
argument_list|(
name|b
operator|.
name|and
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|)
argument_list|)
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|100
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|join
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSemiJoinProjectTranspose
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select a.name from dept a
comment|// where a.deptno in (select b.deptno * 2 from dept);
name|checkSemiOrAntiJoinProjectTranspose
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testAntiJoinProjectTranspose
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select a.name from dept a
comment|// where a.deptno not in (select b.deptno * 2 from dept);
name|checkSemiOrAntiJoinProjectTranspose
argument_list|(
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkSemiOrAntiJoinProjectTranspose
parameter_list|(
name|JoinRelType
name|type
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|left
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|right
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|2
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|b
operator|.
name|groupKey
argument_list|(
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|left
argument_list|)
operator|.
name|push
argument_list|(
name|right
argument_list|)
operator|.
name|join
argument_list|(
name|type
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testJoinProjectTranspose1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.name\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join dept b on b.deptno> 10\n"
operator|+
literal|"right join dept c on b.deptno> 10\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_LEFT_TRANSPOSE_INCLUDE_OUTER
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
argument_list|,
name|CoreRules
operator|.
name|JOIN_PROJECT_LEFT_TRANSPOSE_INCLUDE_OUTER
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1338">[CALCITE-1338]    * JoinProjectTransposeRule should not pull a literal above the    * null-generating side of a join</a>. */
annotation|@
name|Test
name|void
name|testJoinProjectTranspose2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (select name, 1 from dept) as b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should not transpose since the left project of right join has literal. */
annotation|@
name|Test
name|void
name|testJoinProjectTranspose3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (select name, 1 from dept) as a\n"
operator|+
literal|"right join dept b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_LEFT_TRANSPOSE_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should not transpose since the right project of left join has not-strong    * expression {@code y is not null}. */
annotation|@
name|Test
name|void
name|testJoinProjectTranspose4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (select x name, y is not null from\n"
operator|+
literal|"(values (2, cast(null as integer)), (2, 1)) as t(x, y)) b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should not transpose since the right project of left join has not-strong    * expression {@code 1 + 1}. */
annotation|@
name|Test
name|void
name|testJoinProjectTranspose5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (select name, 1 + 1 from dept) as b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should not transpose since both the left project and right project have    * literal. */
annotation|@
name|Test
name|void
name|testJoinProjectTranspose6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from (select name, 1 from dept) a\n"
operator|+
literal|"full join (select name, 1 from dept) as b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * Should transpose since all expressions in the right project of left join    * are strong. */
annotation|@
name|Test
name|void
name|testJoinProjectTranspose7
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (select name from dept) as b\n"
operator|+
literal|" on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testJoinProjectTranspose2()};    * should transpose since all expressions including    * {@code deptno> 10 and cast(null as boolean)} in the right project of left    * join are strong. */
annotation|@
name|Test
name|void
name|testJoinProjectTranspose8
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"left join (\n"
operator|+
literal|"  select name, deptno> 10 and cast(null as boolean)\n"
operator|+
literal|"  from dept) as b\n"
operator|+
literal|"on a.name = b.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testJoinProjectTransposeWindow
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from dept a\n"
operator|+
literal|"join (select rank() over (order by name) as r, 1 + 1 from dept) as b\n"
operator|+
literal|"on a.name = b.r"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_BOTH_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-889">[CALCITE-889]    * Implement SortUnionTransposeRule</a>. */
annotation|@
name|Test
name|void
name|testSortUnionTranspose
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name limit 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SORT_UNION_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-889">[CALCITE-889]    * Implement SortUnionTransposeRule</a>. */
annotation|@
name|Test
name|void
name|testSortUnionTranspose2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SORT_UNION_TRANSPOSE_MATCH_NULL_FETCH
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-987">[CALCITE-987]    * Push limit 0 will result in an infinite loop</a>. */
annotation|@
name|Test
name|void
name|testSortUnionTranspose3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select a.name from dept a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select b.name from dept b\n"
operator|+
literal|"order by name limit 0"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SORT_UNION_TRANSPOSE_MATCH_NULL_FETCH
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortRemovalAllKeysConstant
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno, sal\n"
operator|+
literal|"order by deptno desc nulls last"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_REMOVE_CONSTANT_KEYS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSortRemovalOneKeyConstant
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno, sal\n"
operator|+
literal|"order by deptno, sal desc nulls first"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_REMOVE_CONSTANT_KEYS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that an {@link EnumerableLimit} and {@link EnumerableSort} are    * replaced by an {@link EnumerableLimitSort}, per    *<a href="https://issues.apache.org/jira/browse/CALCITE-3920">[CALCITE-3920]    * Improve ORDER BY computation in Enumerable convention by exploiting    * LIMIT</a>. */
annotation|@
name|Test
name|void
name|testLimitSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select mgr from sales.emp\n"
operator|+
literal|"union select mgr from sales.emp\n"
operator|+
literal|"order by mgr limit 10 offset 5"
decl_stmt|;
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptUtil
operator|.
name|registerDefaultRules
argument_list|(
name|planner
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_LIMIT_SORT_RULE
argument_list|)
expr_stmt|;
name|Tester
name|tester
init|=
name|createTester
argument_list|()
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withClusterFactory
argument_list|(
name|relOptCluster
lambda|->
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|relOptCluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|tester
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_LIMIT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_LIMIT_SORT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_UNION_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_TABLE_SCAN_RULE
argument_list|)
decl_stmt|;
name|Program
name|program
init|=
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
decl_stmt|;
name|RelTraitSet
name|toTraits
init|=
name|root
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSet
argument_list|()
operator|.
name|replace
argument_list|(
literal|0
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|relAfter
init|=
name|program
operator|.
name|run
argument_list|(
name|planner
argument_list|,
name|root
operator|.
name|rel
argument_list|,
name|toTraits
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSemiJoinRuleExists
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from dept where exists (\n"
operator|+
literal|"  select * from emp\n"
operator|+
literal|"  where emp.deptno = dept.deptno\n"
operator|+
literal|"  and emp.sal> 100)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withRelBuilderConfig
argument_list|(
name|b
lambda|->
name|b
operator|.
name|withPruneInputOfAggregate
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSemiJoinRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1495">[CALCITE-1495]    * SemiJoinRule should not apply to RIGHT and FULL JOIN</a>. */
annotation|@
name|Test
name|void
name|testSemiJoinRuleRight
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept right join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Similar to {@link #testSemiJoinRuleRight()} but FULL. */
annotation|@
name|Test
name|void
name|testSemiJoinRuleFull
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select dept.* from dept full join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** Similar to {@link #testSemiJoinRule()} but LEFT. */
annotation|@
name|Test
name|void
name|testSemiJoinRuleLeft
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name from dept left join (\n"
operator|+
literal|"  select distinct deptno from emp\n"
operator|+
literal|"  where sal> 100) using (deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-438">[CALCITE-438]    * Push predicates through SemiJoin</a>. */
annotation|@
name|Test
name|void
name|testPushFilterThroughSemiJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select * from dept where dept.deptno in (\n"
operator|+
literal|"    select emp.deptno from emp))R\n"
operator|+
literal|"where R.deptno<=10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|false
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_CONDITION_PUSH
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-571">[CALCITE-571]    * ReduceExpressionsRule tries to reduce SemiJoin condition to non-equi    * condition</a>. */
annotation|@
name|Test
name|void
name|testSemiJoinReduceConstants
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e1.sal\n"
operator|+
literal|"from (select * from emp where deptno = 200) as e1\n"
operator|+
literal|"where e1.deptno in (\n"
operator|+
literal|"  select e2.deptno from emp e2 where e2.sal = 100)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testSemiJoinTrim
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|DiffRepository
name|diffRepos
init|=
name|getDiffRepos
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
name|diffRepos
operator|.
name|expand
argument_list|(
literal|null
argument_list|,
literal|"${sql}"
argument_list|)
decl_stmt|;
name|TesterImpl
name|t
init|=
operator|(
name|TesterImpl
operator|)
name|tester
decl_stmt|;
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|t
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|Prepare
operator|.
name|CatalogReader
name|catalogReader
init|=
name|t
operator|.
name|createCatalogReader
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidator
name|validator
init|=
name|t
operator|.
name|createValidator
argument_list|(
name|catalogReader
argument_list|,
name|typeFactory
argument_list|)
decl_stmt|;
name|SqlToRelConverter
name|converter
init|=
name|t
operator|.
name|createSqlToRelConverter
argument_list|(
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlToRelConverter
operator|.
name|config
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|sqlQuery
init|=
name|t
operator|.
name|parseQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|validatedQuery
init|=
name|validator
operator|.
name|validate
argument_list|(
name|sqlQuery
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|converter
operator|.
name|convertQuery
argument_list|(
name|validatedQuery
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|decorrelate
argument_list|(
name|sqlQuery
argument_list|,
name|root
operator|.
name|rel
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|HepProgram
name|program
init|=
name|HepProgram
operator|.
name|builder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|root
operator|.
name|rel
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|planner
operator|.
name|findBestExp
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|converter
operator|=
name|t
operator|.
name|createSqlToRelConverter
argument_list|(
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|SqlToRelConverter
operator|.
name|config
argument_list|()
operator|.
name|withTrimUnusedFields
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|converter
operator|.
name|trimUnusedFields
argument_list|(
literal|false
argument_list|,
name|root
operator|.
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|diffRepos
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testReduceAverage
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name, max(name), avg(deptno), min(name)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1621">[CALCITE-1621]    * Adding a cast around the null literal in aggregate rules</a>. */
annotation|@
name|Test
name|void
name|testCastInAggregateReduceFunctions
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),\n"
operator|+
literal|"stddev_samp(deptno),var_pop(deptno), var_samp(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCountWithoutGroupBy
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select max(deptno), count(distinct ename)\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCount1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(distinct ename)\n"
operator|+
literal|"from sales.emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCount2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(distinct ename), sum(sal)\n"
operator|+
literal|"from sales.emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1293">[CALCITE-1293]    * Bad code generated when argument to COUNT(DISTINCT) is a # GROUP BY    * column</a>. */
annotation|@
name|Test
name|void
name|testDistinctCount3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(distinct deptno), sum(sal)"
operator|+
literal|" from sales.emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests implementing multiple distinct count the old way, using a join. */
annotation|@
name|Test
name|void
name|testDistinctCountMultipleViaJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(distinct ename),\n"
operator|+
literal|"  count(distinct job, ename),\n"
operator|+
literal|"  count(distinct deptno, job), sum(sal)\n"
operator|+
literal|"from sales.emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests implementing multiple distinct count the new way, using GROUPING    *  SETS. */
annotation|@
name|Test
name|void
name|testDistinctCountMultiple
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(distinct ename),\n"
operator|+
literal|"  count(distinct job)\n"
operator|+
literal|"from sales.emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCountMultipleNoGroup
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(distinct ename), count(distinct job)\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCountMixedJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(distinct ename), count(distinct job, ename),\n"
operator|+
literal|"count(distinct deptno, job), sum(sal)\n"
operator|+
literal|"from sales.emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCountMixed
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(distinct deptno, job) as cddj,\n"
operator|+
literal|"  sum(sal) as s\n"
operator|+
literal|"from sales.emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCountMixed2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, count(distinct ename) as cde,\n"
operator|+
literal|"count(distinct job, ename) as cdje,\n"
operator|+
literal|"count(distinct deptno, job) as cddj,\n"
operator|+
literal|"sum(sal) as s\n"
operator|+
literal|"from sales.emp group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCountGroupingSets1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, job, count(distinct ename)\n"
operator|+
literal|"from sales.emp group by rollup(deptno,job)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctCountGroupingSets2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, job, count(distinct ename), sum(sal)\n"
operator|+
literal|"from sales.emp group by rollup(deptno,job)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctNonDistinctAggregates
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select emp.empno, count(*), avg(distinct dept.deptno)\n"
operator|+
literal|"from sales.emp emp inner join sales.dept dept\n"
operator|+
literal|"on emp.deptno = dept.deptno\n"
operator|+
literal|"group by emp.empno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1621">[CALCITE-1621]    * Adding a cast around the null literal in aggregate rules</a>. */
annotation|@
name|Test
name|void
name|testCastInAggregateExpandDistinctAggregatesRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name, sum(distinct cn), sum(distinct sm)\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select name, count(dept.deptno) as cn,sum(dept.deptno) as sm\n"
operator|+
literal|"  from sales.dept group by name)\n"
operator|+
literal|"group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1558">[CALCITE-1558]    * AggregateExpandDistinctAggregatesRule gets field mapping wrong if groupKey    * is used in aggregate function</a>. */
annotation|@
name|Test
name|void
name|testDistinctNonDistinctAggregatesWithGrouping1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|"  SUM(deptno), SUM(DISTINCT sal), MAX(deptno), MAX(comm)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctNonDistinctAggregatesWithGrouping2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, COUNT(deptno), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctNonDistinctTwoAggregatesWithGrouping
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(comm), MIN(comm), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctWithGrouping
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT sal, SUM(comm), MIN(comm), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY sal"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testRemoveDistinctOnAgg
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT empno, SUM(distinct sal), MIN(sal), "
operator|+
literal|"MIN(distinct sal), MAX(distinct sal), "
operator|+
literal|"bit_and(distinct sal), bit_or(sal), count(distinct sal) "
operator|+
literal|"from sales.emp group by empno, deptno\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REMOVE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testMultipleDistinctWithGrouping
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT sal, SUM(comm), AVG(DISTINCT comm), SUM(DISTINCT sal)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY sal"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctWithMultipleInputs
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(comm), MIN(comm), COUNT(DISTINCT sal, comm)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctWithMultipleInputsAndGroupby
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(comm), MIN(comm), COUNT(DISTINCT sal, deptno, comm)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctWithFilterWithoutGroupBy
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT SUM(comm), COUNT(DISTINCT sal) FILTER (WHERE sal> 1000)\n"
operator|+
literal|"FROM emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctWithDiffFiltersAndSameGroupSet
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT COUNT(DISTINCT c) FILTER (WHERE d),\n"
operator|+
literal|"COUNT(DISTINCT d) FILTER (WHERE c)\n"
operator|+
literal|"FROM (select sal> 1000 is true as c, sal< 500 is true as d, comm from emp)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testDistinctWithFilterAndGroupBy
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(comm), COUNT(DISTINCT sal) FILTER (WHERE sal> 1000)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link AggregateExpandWithinDistinctRule}. The generated query    * throws if arguments are not functionally dependent on the distinct key. */
annotation|@
name|Test
name|void
name|testWithinDistinct
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(sal), SUM(sal) WITHIN DISTINCT (job)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testWithinDistinct()}, but the generated query does not throw    * if arguments are not functionally dependent on the distinct key.    *    * @see AggregateExpandWithinDistinctRule.Config#throwIfNotUnique() */
annotation|@
name|Test
name|void
name|testWithinDistinctNoThrow
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno, SUM(sal), SUM(sal) WITHIN DISTINCT (job)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
operator|.
name|config
operator|.
name|withThrowIfNotUnique
argument_list|(
literal|false
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link AggregateExpandWithinDistinctRule}. If all aggregate calls    * have the same distinct keys, there is no need for multiple grouping    * sets. */
annotation|@
name|Test
name|void
name|testWithinDistinctUniformDistinctKeys
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|" SUM(sal) WITHIN DISTINCT (job),\n"
operator|+
literal|" AVG(comm) WITHIN DISTINCT (job)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link AggregateExpandWithinDistinctRule}. If all aggregate calls    * have the same distinct keys, and we're not checking for true uniqueness,    * there is no need for filtering in the outer aggregate. */
annotation|@
name|Test
name|void
name|testWithinDistinctUniformDistinctKeysNoThrow
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|" SUM(sal) WITHIN DISTINCT (job),\n"
operator|+
literal|" AVG(comm) WITHIN DISTINCT (job)\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
operator|.
name|config
operator|.
name|withThrowIfNotUnique
argument_list|(
literal|false
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests that {@link AggregateExpandWithinDistinctRule} treats    * "COUNT(DISTINCT x)" as if it were "COUNT(x) WITHIN DISTINCT (x)". */
annotation|@
name|Test
name|void
name|testWithinDistinctCountDistinct
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|"  SUM(sal) WITHIN DISTINCT (comm) AS ss_c,\n"
operator|+
literal|"  COUNT(DISTINCT job) cdj,\n"
operator|+
literal|"  COUNT(job) WITHIN DISTINCT (job) AS cj_j,\n"
operator|+
literal|"  COUNT(DISTINCT job) WITHIN DISTINCT (job) AS cdj_j,\n"
operator|+
literal|"  COUNT(DISTINCT job) FILTER (WHERE sal> 1000) AS cdj_filtered\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
operator|.
name|config
operator|.
name|withThrowIfNotUnique
argument_list|(
literal|false
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4726">[CALCITE-4726]    * Support aggregate calls with a FILTER clause in    * AggregateExpandWithinDistinctRule</a>.    *    *<p>Tests {@link AggregateExpandWithinDistinctRule} with different    * distinct keys and different filters for each aggregate call. */
annotation|@
name|Test
name|void
name|testWithinDistinctFilteredAggs
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|" SUM(sal) WITHIN DISTINCT (job) FILTER (WHERE comm> 10),\n"
operator|+
literal|" AVG(comm) WITHIN DISTINCT (sal) FILTER (WHERE ename LIKE '%ok%')\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link AggregateExpandWithinDistinctRule}. Includes multiple    * different filters for the aggregate calls, and all aggregate calls have the    * same distinct keys, so there is no need to filter based on    * {@code GROUPING()}. */
annotation|@
name|Test
name|void
name|testWithinDistinctFilteredAggsUniformDistinctKeys
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|" SUM(sal) WITHIN DISTINCT (job) FILTER (WHERE comm> 10),\n"
operator|+
literal|" AVG(comm) WITHIN DISTINCT (job) FILTER (WHERE ename LIKE '%ok%')\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link AggregateExpandWithinDistinctRule}. Includes multiple    * different filters for the aggregate calls, and all aggregate calls have the    * same distinct keys, so there is no need to filter based on    * {@code GROUPING()}. Does<em>not</em> throw if not unique. */
annotation|@
name|Test
name|void
name|testWithinDistinctFilteredAggsUniformDistinctKeysNoThrow
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|" SUM(sal) WITHIN DISTINCT (job) FILTER (WHERE comm> 10),\n"
operator|+
literal|" AVG(comm) WITHIN DISTINCT (job) FILTER (WHERE ename LIKE '%ok%')\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
operator|.
name|config
operator|.
name|withThrowIfNotUnique
argument_list|(
literal|false
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Tests {@link AggregateExpandWithinDistinctRule}. Includes multiple    * identical filters for the aggregate calls. The filters should be    * re-used. */
annotation|@
name|Test
name|void
name|testWithinDistinctFilteredAggsSameFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT deptno,\n"
operator|+
literal|" SUM(sal) WITHIN DISTINCT (job) FILTER (WHERE ename LIKE '%ok%'),\n"
operator|+
literal|" AVG(comm) WITHIN DISTINCT (sal) FILTER (WHERE ename LIKE '%ok%')\n"
operator|+
literal|"FROM emp\n"
operator|+
literal|"GROUP BY deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_WITHIN_DISTINCT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testPushProjectPastFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno + deptno from emp where sal = 10 * comm\n"
operator|+
literal|"and upper(ename) = 'FOO'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1778">[CALCITE-1778]    * Query with "WHERE CASE" throws AssertionError "Cast for just nullability    * not allowed"</a>. */
annotation|@
name|Test
name|void
name|testPushProjectPastFilter2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where case when mgr< 10 then true else false end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3975">[CALCITE-3975]    * ProjectFilterTransposeRule should succeed for project that happens to    * reference all input columns</a>. */
annotation|@
name|Test
name|void
name|testPushProjectPastFilter3
parameter_list|()
block|{
name|checkPushProjectPastFilter3
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testPushProjectPastFilter3()} but pushes down project and    * filter expressions whole. */
annotation|@
name|Test
name|void
name|testPushProjectPastFilter3b
parameter_list|()
block|{
name|checkPushProjectPastFilter3
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE_WHOLE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** As {@link #testPushProjectPastFilter3()} but pushes down project    * expressions whole. */
annotation|@
name|Test
name|void
name|testPushProjectPastFilter3c
parameter_list|()
block|{
name|checkPushProjectPastFilter3
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE_WHOLE_PROJECT_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
specifier|private
name|Sql
name|checkPushProjectPastFilter3
parameter_list|(
name|ProjectFilterTransposeRule
name|rule
parameter_list|)
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno + deptno as x, ename, job, mgr,\n"
operator|+
literal|"  hiredate, sal, comm, slacker\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where sal = 10 * comm\n"
operator|+
literal|"and upper(ename) = 'FOO'"
decl_stmt|;
return|return
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
return|;
block|}
annotation|@
name|Test
name|void
name|testPushProjectPastJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.sal + b.comm from emp e inner join bonus b\n"
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3004">[CALCITE-3004]    * Should not push over past union but its operands can since setop    * will affect row count</a>. */
annotation|@
name|Test
name|void
name|testProjectSetOpTranspose
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select job, sum(sal + 100) over (partition by deptno) from\n"
operator|+
literal|"(select * from emp e1 union all select * from emp e2)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testProjectCorrelateTransposeDynamic
parameter_list|()
block|{
name|ProjectCorrelateTransposeRule
name|customPCTrans
init|=
name|ProjectCorrelateTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withPreserveExprCondition
argument_list|(
name|RelOptRulesTest
operator|::
name|skipItem
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select t1.c_nationkey, t2.a as fake_col2 "
operator|+
literal|"from SALES.CUSTOMER as t1, "
operator|+
literal|"unnest(t1.fake_col) as t2(a)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTester
argument_list|(
name|t
lambda|->
name|createDynamicTester
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|customPCTrans
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testProjectCorrelateTransposeRuleLeftCorrelate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e1.empno\n"
operator|+
literal|"FROM emp e1 "
operator|+
literal|"where exists (select empno, deptno from dept d2 where e1.deptno = d2.deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|expand
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_CORRELATE_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testProjectCorrelateTransposeRuleSemiCorrelate
parameter_list|()
block|{
name|checkProjectCorrelateTransposeRuleSemiOrAntiCorrelate
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
name|void
name|testProjectCorrelateTransposeRuleAntiCorrelate
parameter_list|()
block|{
name|checkProjectCorrelateTransposeRuleSemiOrAntiCorrelate
argument_list|(
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkProjectCorrelateTransposeRuleSemiOrAntiCorrelate
parameter_list|(
name|JoinRelType
name|type
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|left
init|=
name|b
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"f"
operator|,
literal|"f2"
block|}
operator|,
literal|"1"
operator|,
literal|"2"
block_content|)
block|.build(
init|)
decl_stmt|;
name|CorrelationId
name|correlationId
init|=
operator|new
name|CorrelationId
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RexNode
name|rexCorrel
init|=
name|b
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCorrel
argument_list|(
name|left
operator|.
name|getRowType
argument_list|()
argument_list|,
name|correlationId
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|b
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"f3"
block|,
literal|"f4"
block|}
argument_list|,
literal|"1"
argument_list|,
literal|"2"
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|b
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|rexCorrel
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|LogicalCorrelate
name|correlate
init|=
operator|new
name|LogicalCorrelate
argument_list|(
name|left
operator|.
name|getCluster
argument_list|()
argument_list|,
name|left
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|correlationId
argument_list|,
name|ImmutableBitSet
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|b
operator|.
name|push
argument_list|(
name|correlate
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
empty_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_CORRELATE_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_class

begin_function
annotation|@
name|Test
name|void
name|testProjectCorrelateTransposeWithExprCond
parameter_list|()
block|{
name|ProjectCorrelateTransposeRule
name|customPCTrans
init|=
name|ProjectCorrelateTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withPreserveExprCondition
argument_list|(
name|RelOptRulesTest
operator|::
name|skipItem
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select t1.name, t2.ename\n"
operator|+
literal|"from DEPT_NESTED as t1,\n"
operator|+
literal|"unnest(t1.employees) as t2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|customPCTrans
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSwapOuterJoinFieldAccess
parameter_list|()
block|{
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|JOIN_PROJECT_LEFT_TRANSPOSE_INCLUDE_OUTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|JOIN_COMMUTE_OUTER
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select t1.name, e.ename\n"
operator|+
literal|"from DEPT_NESTED as t1 left outer join sales.emp e\n"
operator|+
literal|" on t1.skill.type = e.job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testProjectCorrelateTranspose
parameter_list|()
block|{
name|ProjectCorrelateTransposeRule
name|customPCTrans
init|=
name|ProjectCorrelateTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withPreserveExprCondition
argument_list|(
name|expr
lambda|->
literal|true
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select t1.name, t2.ename\n"
operator|+
literal|"from DEPT_NESTED as t1,\n"
operator|+
literal|"unnest(t1.employees) as t2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|customPCTrans
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** As {@link #testProjectSetOpTranspose()};    * should not push over past correlate but its operands can since correlate    * will affect row count. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectCorrelateTransposeWithOver
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(t1.deptno + 1) over (partition by t1.name),\n"
operator|+
literal|"count(t2.empno) over ()\n"
operator|+
literal|"from DEPT_NESTED as t1,\n"
operator|+
literal|"unnest(t1.employees) as t2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_CORRELATE_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that the default instance of {@link FilterProjectTransposeRule}    * does not push a Filter that contains a correlating variable.    *    * @see #testFilterProjectTranspose() */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testFilterProjectTransposePreventedByCorrelation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.empno\n"
operator|+
literal|"FROM emp as e\n"
operator|+
literal|"WHERE exists (\n"
operator|+
literal|"  SELECT *\n"
operator|+
literal|"  FROM (\n"
operator|+
literal|"    SELECT deptno * 2 AS twiceDeptno\n"
operator|+
literal|"    FROM dept) AS d\n"
operator|+
literal|"  WHERE e.deptno = d.twiceDeptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|expand
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests a variant of {@link FilterProjectTransposeRule}    * that pushes a Filter that contains a correlating variable. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testFilterProjectTranspose
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.empno\n"
operator|+
literal|"FROM emp as e\n"
operator|+
literal|"WHERE exists (\n"
operator|+
literal|"  SELECT *\n"
operator|+
literal|"  FROM (\n"
operator|+
literal|"    SELECT deptno * 2 AS twiceDeptno\n"
operator|+
literal|"    FROM dept) AS d\n"
operator|+
literal|"  WHERE e.deptno = d.twiceDeptno)"
decl_stmt|;
specifier|final
name|FilterProjectTransposeRule
name|filterProjectTransposeRule
init|=
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
operator|.
name|config
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|)
operator|.
name|predicate
argument_list|(
name|filter
lambda|->
literal|true
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|)
operator|.
name|predicate
argument_list|(
name|project
lambda|->
literal|true
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
name|FilterProjectTransposeRule
operator|.
name|Config
operator|.
name|class
argument_list|)
operator|.
name|withCopyFilter
argument_list|(
literal|true
argument_list|)
operator|.
name|withCopyProject
argument_list|(
literal|true
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|expand
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|(
name|filterProjectTransposeRule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|private
specifier|static
specifier|final
name|String
name|NOT_STRONG_EXPR
init|=
literal|"case when e.sal< 11 then 11 else -1 * e.sal end"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|private
specifier|static
specifier|final
name|String
name|STRONG_EXPR
init|=
literal|"case when e.sal< 11 then -1 * e.sal else e.sal end"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1753">[CALCITE-1753]    * PushProjector should only preserve expressions if the expression is strong    * when pushing into the nullable-side of outer join</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastInnerJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e inner join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastInnerJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e inner join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastLeftJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e left outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by case when e.sal< 11 then 11 else -1 * e.sal end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastLeftJoinSwap
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b left outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastLeftJoinSwapStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b left outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastRightJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e right outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastRightJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*),\n"
operator|+
literal|" case when e.sal< 11 then -1 * e.sal else e.sal end\n"
operator|+
literal|"from emp e right outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by case when e.sal< 11 then -1 * e.sal else e.sal end"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastRightJoinSwap
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b right outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastRightJoinSwapStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from bonus b right outer join emp e on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastFullJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|NOT_STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e full outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|NOT_STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastFullJoinStrong
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), "
operator|+
name|STRONG_EXPR
operator|+
literal|"\n"
operator|+
literal|"from emp e full outer join bonus b on e.ename = b.ename\n"
operator|+
literal|"group by "
operator|+
name|STRONG_EXPR
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2343">[CALCITE-2343]    * Should not push over whose columns are all from left child past join since    * join will affect row count</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushProjectWithOverPastJoin1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.sal + b.comm,\n"
operator|+
literal|"count(e.empno) over (partition by e.deptno)\n"
operator|+
literal|"from emp e join bonus b\n"
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** As {@link #testPushProjectWithOverPastJoin1()};    * should not push over whose columns are all from right child past join since    * join will affect row count. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushProjectWithOverPastJoin2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.sal + b.comm,\n"
operator|+
literal|"count(b.sal) over (partition by b.job)\n"
operator|+
literal|"from emp e join bonus b\n"
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** As {@link #testPushProjectWithOverPastJoin2()};    * should not push over past join but should push the operands of over past    * join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushProjectWithOverPastJoin3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.sal + b.comm,\n"
operator|+
literal|"sum(b.sal + b.sal + 100) over (partition by b.job)\n"
operator|+
literal|"from emp e join bonus b\n"
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushProjectPastSetOp
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal from\n"
operator|+
literal|"(select * from emp e1 union all select * from emp e2)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushJoinThroughUnionOnLeft
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select r1.sal from\n"
operator|+
literal|"(select * from emp e1 union all select * from emp e2) r1,\n"
operator|+
literal|"emp r2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_LEFT_UNION_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushJoinThroughUnionOnRight
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select r1.sal from\n"
operator|+
literal|"emp r1,\n"
operator|+
literal|"(select * from emp e1 union all select * from emp e2) r2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_RIGHT_UNION_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushJoinThroughUnionOnRightDoesNotMatchSemiJoin
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select r1.sal from
comment|// emp r1 where r1.deptno in
comment|//  (select deptno from dept d1 where deptno< 10
comment|//  union all
comment|//  select deptno from dept d2 where deptno> 20)
name|checkPushJoinThroughUnionOnRightDoesNotMatchSemiOrAntiJoin
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushJoinThroughUnionOnRightDoesNotMatchAntiJoin
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select r1.sal from
comment|// emp r1 where r1.deptno not in
comment|//  (select deptno from dept d1 where deptno< 10
comment|//  union all
comment|//  select deptno from dept d2 where deptno> 20)
name|checkPushJoinThroughUnionOnRightDoesNotMatchSemiOrAntiJoin
argument_list|(
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkPushJoinThroughUnionOnRightDoesNotMatchSemiOrAntiJoin
parameter_list|(
name|JoinRelType
name|type
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|left
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|right
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|filter
argument_list|(
name|b
operator|.
name|lessThan
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|filter
argument_list|(
name|b
operator|.
name|greaterThan
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|union
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|left
argument_list|)
operator|.
name|push
argument_list|(
name|right
argument_list|)
operator|.
name|join
argument_list|(
name|type
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_RIGHT_UNION_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testMergeFilterWithJoinCondition
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.name as dname,e.ename as ename\n"
operator|+
literal|" from emp e inner join dept d\n"
operator|+
literal|" on e.deptno=d.deptno\n"
operator|+
literal|" where d.name='Propane'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_EXTRACT_FILTER
argument_list|,
name|CoreRules
operator|.
name|FILTER_TO_CALC
argument_list|,
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|,
name|CoreRules
operator|.
name|CALC_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that filters are combined if they are identical. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name from (\n"
operator|+
literal|"  select *\n"
operator|+
literal|"  from dept\n"
operator|+
literal|"  where deptno = 10)\n"
operator|+
literal|"where deptno = 10\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests to see if the final branch of union is missed. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testUnionMergeRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"select * from (\n"
operator|+
literal|"  select name, deptno from dept\n"
operator|+
literal|"  union all\n"
operator|+
literal|"  select name, deptno from\n"
operator|+
literal|"  (\n"
operator|+
literal|"    select name, deptno, count(1) from dept group by name, deptno\n"
operator|+
literal|"    union all\n"
operator|+
literal|"    select name, deptno, count(1) from dept group by name, deptno\n"
operator|+
literal|"  ) subq\n"
operator|+
literal|") a\n"
operator|+
literal|"union all\n"
operator|+
literal|"select name, deptno from dept\n"
operator|+
literal|") aa\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_REMOVE
argument_list|,
name|CoreRules
operator|.
name|UNION_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testMinusMergeRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"select * from (\n"
operator|+
literal|"  select name, deptno from\n"
operator|+
literal|"  (\n"
operator|+
literal|"    select name, deptno, count(1) from dept group by name, deptno\n"
operator|+
literal|"    except all\n"
operator|+
literal|"    select name, deptno, 1 from dept\n"
operator|+
literal|"  ) subq\n"
operator|+
literal|"  except all\n"
operator|+
literal|"  select name, deptno from\n"
operator|+
literal|"  (\n"
operator|+
literal|"    select name, deptno, 1 from dept\n"
operator|+
literal|"    except all\n"
operator|+
literal|"    select name, deptno, count(1) from dept group by name, deptno\n"
operator|+
literal|"  ) subq2\n"
operator|+
literal|") a\n"
operator|+
literal|"except all\n"
operator|+
literal|"select name, deptno from dept\n"
operator|+
literal|") aa\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_REMOVE
argument_list|,
name|CoreRules
operator|.
name|MINUS_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that a filters is combined are combined if they are identical,    * even if one of them originates in an ON clause of a JOIN. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeJoinFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select d.deptno, e.ename\n"
operator|+
literal|"  from emp as e\n"
operator|+
literal|"  join dept as d\n"
operator|+
literal|"  on e.deptno = d.deptno\n"
operator|+
literal|"  and d.deptno = 10)\n"
operator|+
literal|"where deptno = 10\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_MERGE
argument_list|,
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link UnionMergeRule}, which merges 2 {@link Union} operators into    * a single {@code Union} with 3 inputs. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeUnionAll
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link UnionMergeRule}, which merges 2 {@link Union}    * {@code DISTINCT} (not {@code ALL}) operators into a single    * {@code Union} with 3 inputs. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeUnionDistinct
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union distinct\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union\n"
comment|// same as 'union distinct'
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that {@link UnionMergeRule} does nothing if its arguments have    * different {@code ALL} settings. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeUnionMixed
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that {@link UnionMergeRule} converts all inputs to DISTINCT    * if the top one is DISTINCT.    * (Since UNION is left-associative, the "top one" is the rightmost.) */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeUnionMixed2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that {@link UnionMergeRule} does nothing if its arguments have    * are different set operators, {@link Union} and {@link Intersect}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeSetOpMixed
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"union\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_MERGE
argument_list|,
name|CoreRules
operator|.
name|INTERSECT_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link CoreRules#INTERSECT_MERGE}, which merges 2    * {@link Intersect} operators into a single {@code Intersect} with 3    * inputs. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeIntersect
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|INTERSECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link org.apache.calcite.rel.rules.IntersectToDistinctRule},    * which rewrites an {@link Intersect} operator with 3 inputs. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testIntersectToDistinct
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|INTERSECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|INTERSECT_TO_DISTINCT
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that {@link org.apache.calcite.rel.rules.IntersectToDistinctRule}    * correctly ignores an {@code INTERSECT ALL}. It can only handle    * {@code INTERSECT DISTINCT}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testIntersectToDistinctAll
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"intersect all\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|INTERSECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|INTERSECT_TO_DISTINCT
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link CoreRules#MINUS_MERGE}, which merges 2    * {@link Minus} operators into a single {@code Minus} with 3    * inputs. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeMinus
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from emp where deptno = 20\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from emp where deptno = 30\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|MINUS_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link CoreRules#MINUS_MERGE}    * does not merge {@code Minus(a, Minus(b, c))}    * into {@code Minus(a, b, c)}, which would be incorrect. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeMinusRightDeep
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where deptno = 10\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (\n"
operator|+
literal|"  select * from emp where deptno = 20\n"
operator|+
literal|"  except\n"
operator|+
literal|"  select * from emp where deptno = 30)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|MINUS_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testHeterogeneousConversion
parameter_list|()
block|{
comment|// This one tests the planner's ability to correctly
comment|// apply different converters on top of a common
comment|// sub-expression.  The common sub-expression is the
comment|// reference to the table sales.emps.  On top of that
comment|// are two projections, unioned at the top.  For one
comment|// of the projections, transfer it to calc, for the other,
comment|// keep it unchanged.
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
comment|// Control the calc conversion.
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select upper(ename) from emp union all\n"
operator|+
literal|"select lower(ename) from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSemiJoinPastJoinRuleLeft
parameter_list|()
block|{
comment|// tests the case where the semijoin is pushed to the left
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename from emp e1, dept d, emp e2\n"
operator|+
literal|"where e1.deptno = d.deptno and e1.empno = e2.empno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSemiJoinPastJoinRuleRight
parameter_list|()
block|{
comment|// tests the case where the semijoin is pushed to the right
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename from emp e1, dept d, emp e2\n"
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSemiJoinPastFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.ename from emp e, dept d\n"
operator|+
literal|"where e.deptno = d.deptno and e.ename = 'foo'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_FILTER_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testConvertMultiJoinRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename from emp e1, dept d, emp e2\n"
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_MULTI_JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testManyFiltersOnTopOfMultiJoinShouldCollapse
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_MULTI_JOIN
argument_list|)
operator|.
name|addRuleCollection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|CoreRules
operator|.
name|FILTER_MULTI_JOIN_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MULTI_JOIN_MERGE
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from emp e1 left outer join dept d\n"
operator|+
literal|"on e1.deptno = d.deptno\n"
operator|+
literal|"where d.deptno> 3) where ename LIKE 'bar'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstants
parameter_list|()
block|{
comment|// NOTE jvs 27-May-2006: among other things, this verifies
comment|// intentionally different treatment for identical coalesce expression
comment|// in select and where.
comment|// There is "CAST(2 AS INTEGER)" in the plan because 2 has type "INTEGER NOT
comment|// NULL" and we need "INTEGER".
specifier|final
name|String
name|sql
init|=
literal|"select"
operator|+
literal|" 1+2, d.deptno+(3+4), (5+6)+d.deptno, cast(null as integer),"
operator|+
literal|" coalesce(2,null), row(7+8)"
operator|+
literal|" from dept d inner join emp e"
operator|+
literal|" on d.deptno = e.deptno + (5-5)"
operator|+
literal|" where d.deptno=(7+8) and d.deptno=(8+7) and d.deptno=coalesce(2,null)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-570">[CALCITE-570]    * ReduceExpressionsRule throws "duplicate key" exception</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDup
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno"
operator|+
literal|" from dept d"
operator|+
literal|" where d.deptno=7 and d.deptno=8"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-935">[CALCITE-935]    * Improve how ReduceExpressionsRule handles duplicate constraints</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDup2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where deptno=7 and deptno=8\n"
operator|+
literal|"and empno = 10 and mgr is null and empno = 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDup3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno"
operator|+
literal|" from dept d"
operator|+
literal|" where d.deptno<>7 or d.deptno<>8"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDup3Null
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.empno"
operator|+
literal|" from emp e"
operator|+
literal|" where e.mgr<>7 or e.mgr<>8"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDupNot
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno"
operator|+
literal|" from dept d"
operator|+
literal|" where not(d.deptno=7 and d.deptno=8)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDupNotNull
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.empno"
operator|+
literal|" from emp e"
operator|+
literal|" where not(e.mgr=7 and e.mgr=8)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDupNot2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno"
operator|+
literal|" from dept d"
operator|+
literal|" where not(d.deptno=7 and d.name='foo' and d.deptno=8)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3198">[CALCITE-3198]    * Enhance RexSimplify to handle (x&lt;&gt;a or x&lt;&gt;b)</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDupNot2Null
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.empno"
operator|+
literal|" from emp e"
operator|+
literal|" where not(e.mgr=7 and e.deptno=8 and e.mgr=8)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullNull
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where deptno=7\n"
operator|+
literal|"and empno = 10 and mgr is null and empno = 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testOrAlwaysTrue
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from EMPNULLABLES_20\n"
operator|+
literal|"where sal is null or sal is not null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testOrAlwaysTrue2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from EMPNULLABLES_20\n"
operator|+
literal|"where sal is not null or sal is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstants2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select p1 is not distinct from p0\n"
operator|+
literal|"from (values (2, cast(null as integer))) as t(p0, p1)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRelBuilderConfig
argument_list|(
name|b
lambda|->
name|b
operator|.
name|withSimplifyValues
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstants3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.mgr is not distinct from f.mgr "
operator|+
literal|"from emp e join emp f on (e.mgr=f.mgr) where e.mgr is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-902">[CALCITE-902]    * Match nullability when reducing expressions in a Project</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsProjectNullable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select mgr from emp where mgr=10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// see HIVE-9645
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsNullEqualsOne
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(1) from emp where cast(null as integer) = 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// see HIVE-9644
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsCaseEquals
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  else 3 end = 1"
decl_stmt|;
comment|// Equivalent to 'deptno = 10'
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsCaseEquals2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  else cast(null as integer) end = 1"
decl_stmt|;
comment|// Equivalent to 'case when deptno = 20 then false
comment|//                     when deptno = 10 then true
comment|//                     else null end'
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsCaseEquals3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(1) from emp\n"
operator|+
literal|"where case deptno\n"
operator|+
literal|"  when 30 then 1\n"
operator|+
literal|"  when 20 then 2\n"
operator|+
literal|"  when 10 then 1\n"
operator|+
literal|"  when 30 then 111\n"
operator|+
literal|"  else 0 end = 1"
decl_stmt|;
comment|// Equivalent to 'deptno = 30 or deptno = 10'
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSkipReduceConstantsCaseEquals
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1, emp e2\n"
operator|+
literal|"where coalesce(e1.mgr, -1) = coalesce(e2.mgr, -1)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsEliminatesFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1,2)) where 1 + 2> 3 + CAST(NULL AS INTEGER)"
decl_stmt|;
comment|// WHERE NULL is the same as WHERE FALSE, so get empty result
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1860">[CALCITE-1860]    * Duplicate null predicates cause NullPointerException in RexUtil</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsNull
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select *\n"
operator|+
literal|"  from (\n"
operator|+
literal|"    select cast(null as integer) as n\n"
operator|+
literal|"    from emp)\n"
operator|+
literal|"  where n is null and n is null)\n"
operator|+
literal|"where n is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-566">[CALCITE-566]    * ReduceExpressionsRule requires planner to have an Executor</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsRequiresExecutor
parameter_list|()
block|{
comment|// Remove the executor
name|tester
operator|.
name|convertSqlToRel
argument_list|(
literal|"values 1"
argument_list|)
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|setExecutor
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Rule should not fire, but there should be no NPE
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1,2)) where 1 + 2> 3 + CAST(NULL AS INTEGER)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAlreadyFalseEliminatesFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (1,2)) where false"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsCalc
parameter_list|()
block|{
comment|// This reduction does not work using
comment|// ReduceExpressionsRule.PROJECT_INSTANCE or FILTER_INSTANCE,
comment|// only CALC_INSTANCE, because we need to pull the project expression
comment|//    upper('table')
comment|// into the condition
comment|//    upper('table') = 'TABLE'
comment|// and reduce it to TRUE. Only in the Calc are projects and conditions
comment|// combined.
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_SET_OP_TRANSPOSE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_TO_CALC
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|CALC_MERGE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|CALC_REDUCE_EXPRESSIONS
argument_list|)
comment|// the hard part is done... a few more rule calls to clean up
operator|.
name|addRuleInstance
argument_list|(
name|PruneEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|CALC_MERGE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|CALC_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Result should be same as typing
comment|//  SELECT * FROM (VALUES ('TABLE        ', 'T')) AS T(U, S)
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select upper(substring(x FROM 1 FOR 2) || substring(x FROM 3)) as u,\n"
operator|+
literal|"      substring(x FROM 1 FOR 1) as s\n"
operator|+
literal|"  from (\n"
operator|+
literal|"    select 'table' as x from (values (true))\n"
operator|+
literal|"    union\n"
operator|+
literal|"    select 'view' from (values (true))\n"
operator|+
literal|"    union\n"
operator|+
literal|"    select 'foreign table' from (values (true))\n"
operator|+
literal|"  )\n"
operator|+
literal|") where u = 'TABLE'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRelBuilderConfig
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withSimplifyValues
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRemoveSemiJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.ename from emp e, dept d\n"
operator|+
literal|"where e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRemoveSemiJoinWithFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.ename from emp e, dept d\n"
operator|+
literal|"where e.deptno = d.deptno and e.ename = 'foo'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_FILTER_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRemoveSemiJoinRight
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename from emp e1, dept d, emp e2\n"
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_JOIN_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRemoveSemiJoinRightWithFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename from emp e1, dept d, emp e2\n"
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno\n"
operator|+
literal|"and d.name = 'foo'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_JOIN_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_FILTER_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Creates an environment for testing multi-join queries. */
end_comment

begin_function
specifier|private
name|Sql
name|multiJoin
parameter_list|(
name|String
name|query
parameter_list|)
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REMOVE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_MULTI_JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|sql
argument_list|(
name|query
argument_list|)
operator|.
name|withCatalogReaderFactory
argument_list|(
parameter_list|(
name|typeFactory
parameter_list|,
name|caseSensitive
parameter_list|)
lambda|->
operator|new
name|MockCatalogReader
argument_list|(
name|typeFactory
argument_list|,
name|caseSensitive
argument_list|)
block|{
block_content|@Override public MockCatalogReader init(
argument_list|)
block|{
comment|// CREATE SCHEMA abc;
comment|// CREATE TABLE a(a INT);
comment|// ...
comment|// CREATE TABLE j(j INT);
name|MockSchema
name|schema
operator|=
operator|new
name|MockSchema
argument_list|(
literal|"SALES"
argument_list|)
block|;
name|registerSchema
argument_list|(
name|schema
argument_list|)
block|;
name|final
name|RelDataType
name|intType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|String
name|t
init|=
name|String
operator|.
name|valueOf
argument_list|(
operator|(
name|char
operator|)
operator|(
literal|'A'
operator|+
name|i
operator|)
argument_list|)
decl_stmt|;
name|MockTable
name|table
init|=
name|MockTable
operator|.
name|create
argument_list|(
name|this
argument_list|,
name|schema
argument_list|,
name|t
argument_list|,
literal|false
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|table
operator|.
name|addColumn
argument_list|(
name|t
argument_list|,
name|intType
argument_list|)
expr_stmt|;
name|registerTable
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|// CHECKSTYLE: IGNORE 1
end_comment

begin_expr_stmt
unit|})
operator|.
name|with
argument_list|(
name|program
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}    @
name|Test
name|void
name|testConvertMultiJoinRuleOuterJoins
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from "
operator|+
literal|"    (select * from "
operator|+
literal|"        (select * from "
operator|+
literal|"            (select * from A right outer join B on a = b) "
operator|+
literal|"            left outer join "
operator|+
literal|"            (select * from C full outer join D on c = d)"
operator|+
literal|"            on a = c and b = d) "
operator|+
literal|"        right outer join "
operator|+
literal|"        (select * from "
operator|+
literal|"            (select * from E full outer join F on e = f) "
operator|+
literal|"            right outer join "
operator|+
literal|"            (select * from G left outer join H on g = h) "
operator|+
literal|"            on e = g and f = h) "
operator|+
literal|"        on a = e and b = f and c = g and d = h) "
operator|+
literal|"    inner join "
operator|+
literal|"    (select * from I inner join J on i = j) "
operator|+
literal|"    on a = i and h = j"
decl_stmt|;
name|multiJoin
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testConvertMultiJoinRuleOuterJoins2
parameter_list|()
block|{
comment|// in (A right join B) join C, pushing C is not allowed;
comment|// therefore there should be 2 MultiJoin
name|multiJoin
argument_list|(
literal|"select * from A right join B on a = b join C on b = c"
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testConvertMultiJoinRuleOuterJoins3
parameter_list|()
block|{
comment|// in (A join B) left join C, pushing C is allowed;
comment|// therefore there should be 1 MultiJoin
name|multiJoin
argument_list|(
literal|"select * from A join B on a = b left join C on b = c"
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testConvertMultiJoinRuleOuterJoins4
parameter_list|()
block|{
comment|// in (A join B) right join C, pushing C is not allowed;
comment|// therefore there should be 2 MultiJoin
name|multiJoin
argument_list|(
literal|"select * from A join B on a = b right join C on b = c"
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSemiJoinPastProject
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.* from\n"
operator|+
literal|"(select ename, trim(job), sal * 2, deptno from emp) e, dept d\n"
operator|+
literal|"where e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
argument_list|,
name|CoreRules
operator|.
name|SEMI_JOIN_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceValuesUnderFilter
parameter_list|()
block|{
comment|// Plan should be same as for
comment|// select a, b from (values (10,'x')) as t(a, b)");
specifier|final
name|String
name|sql
init|=
literal|"select a, b from (values (10, 'x'), (20, 'y')) as t(a, b) where a< 15"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_VALUES_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceValuesUnderProject
parameter_list|()
block|{
comment|// Plan should be same as for
comment|// select a, b as x from (values (11), (23)) as t(x)");
specifier|final
name|String
name|sql
init|=
literal|"select a + b from (values (10, 1), (20, 3)) as t(a, b)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_VALUES_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceValuesUnderProjectFilter
parameter_list|()
block|{
comment|// Plan should be same as for
comment|// select * from (values (11, 1, 10), (23, 3, 20)) as t(x, b, a)");
specifier|final
name|String
name|sql
init|=
literal|"select a + b as x, b, a\n"
operator|+
literal|"from (values (10, 1), (30, 7), (20, 3)) as t(a, b)\n"
operator|+
literal|"where a - b< 21"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_FILTER_VALUES_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1439">[CALCITE-1439]    * Handling errors during constant reduction</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceCase
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|"  case when false then cast(2.1 as float)\n"
operator|+
literal|"   else cast(1 as integer) end as newcol\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkReduceNullableToNotNull
parameter_list|(
name|ReduceExpressionsRule
argument_list|<
name|?
argument_list|>
name|rule
parameter_list|)
block|{
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|"  empno + case when 'a' = 'a' then 1 else null end as newcol\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case that reduces a nullable expression to a NOT NULL literal that    *  is cast to nullable. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceNullableToNotNull
parameter_list|()
block|{
name|checkReduceNullableToNotNull
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case that reduces a nullable expression to a NOT NULL literal. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceNullableToNotNull2
parameter_list|()
block|{
specifier|final
name|ProjectReduceExpressionsRule
name|rule
init|=
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
operator|.
name|config
operator|.
name|withOperandFor
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|)
operator|.
name|withMatchNullability
argument_list|(
literal|false
argument_list|)
operator|.
name|as
argument_list|(
name|ProjectReduceExpressionsRule
operator|.
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
name|checkReduceNullableToNotNull
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsIsNull
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp where empno=10 and empno is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsIsNotNull
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp\n"
operator|+
literal|"where empno=10 and empno is not null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsNegated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp\n"
operator|+
literal|"where empno=10 and not(empno=10)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsNegatedInverted
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp where empno>10 and empno<=10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2638">[CALCITE-2638]    * Constant reducer must not duplicate calls to non-deterministic    * functions</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsNonDeterministicFunction
parameter_list|()
block|{
specifier|final
name|SqlOperator
name|nonDeterministicOp
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"NDC"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|INTEGER
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
comment|// Build a tree equivalent to the SQL
comment|//  SELECT sal, n
comment|//  FROM (SELECT sal, NDC() AS n FROM emp)
comment|//  WHERE n> 10
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|,
name|b
operator|.
name|alias
argument_list|(
name|b
operator|.
name|call
argument_list|(
name|nonDeterministicOp
argument_list|)
argument_list|,
literal|"N"
argument_list|)
argument_list|)
operator|.
name|filter
argument_list|(
name|b
operator|.
name|greaterThan
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"N"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Checks that constant reducer duplicates calls to dynamic functions, if    * appropriate. CURRENT_TIMESTAMP is a dynamic function. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsDynamicFunction
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal, t\n"
operator|+
literal|"from (select sal, current_timestamp t from emp)\n"
operator|+
literal|"where t> TIMESTAMP '2018-01-01 00:00:00'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testCasePushIsAlwaysWorking
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp"
operator|+
literal|" where case when sal> 1000 then empno else sal end = 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|CALC_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceValuesNull
parameter_list|()
block|{
comment|// The NULL literal presents pitfalls for value-reduction. Only
comment|// an INSERT statement contains un-CASTed NULL values.
specifier|final
name|String
name|sql
init|=
literal|"insert into EMPNULLABLES(EMPNO, ENAME, JOB) (select 0, 'null', NULL)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_VALUES_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceValuesToEmpty
parameter_list|()
block|{
comment|// Plan should be same as for
comment|// select * from (values (11, 1, 10), (23, 3, 20)) as t(x, b, a)");
specifier|final
name|String
name|sql
init|=
literal|"select a + b as x, b, a from (values (10, 1), (30, 7)) as t(a, b)\n"
operator|+
literal|"where a - b< 0"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_FILTER_VALUES_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceConstantsWindow
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select col1, col2, col3\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select empno,\n"
operator|+
literal|"    sum(100) over (partition by deptno, sal order by sal) as col1,\n"
operator|+
literal|"    sum(100) over (partition by sal order by deptno) as col2,\n"
operator|+
literal|"    sum(sal) over (partition by deptno order by sal) as col3\n"
operator|+
literal|"  from emp where sal = 5000)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_WINDOW_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|WINDOW_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptyFilterProjectUnion
parameter_list|()
block|{
comment|// Plan should be same as for
comment|// select * from (values (30, 3)) as t(x, y)");
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from (values (20, 2))\n"
operator|+
literal|")\n"
operator|+
literal|"where x + y> 30"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_SET_OP_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_FILTER_VALUES_MERGE
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1488">[CALCITE-1488]    * ValuesReduceRule should ignore empty Values</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testEmptyProject
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select z + x from (\n"
operator|+
literal|"  select x + y as z, x from (\n"
operator|+
literal|"    select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"    where x + y> 50))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_VALUES_MERGE
argument_list|,
name|CoreRules
operator|.
name|FILTER_VALUES_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_VALUES_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Same query as {@link #testEmptyProject()}, and {@link PruneEmptyRules}    * is able to do the job that {@link ValuesReduceRule} cannot do. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testEmptyProject2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select z + x from (\n"
operator|+
literal|"  select x + y as z, x from (\n"
operator|+
literal|"    select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"    where x + y> 50))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_VALUES_MERGE
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptyIntersect
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3))"
operator|+
literal|"intersect\n"
operator|+
literal|"select *\nfrom (values (10, 1), (30, 3)) as t (x, y) where x> 50\n"
operator|+
literal|"intersect\n"
operator|+
literal|"select * from (values (30, 3))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_VALUES_MERGE
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|INTERSECT_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptyMinus
parameter_list|()
block|{
comment|// First input is empty; therefore whole expression is empty
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3)) as t (x, y)\n"
operator|+
literal|"where x> 30\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (20, 2))\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (40, 4))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_VALUES_MERGE
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptyMinus2
parameter_list|()
block|{
comment|// Second and fourth inputs are empty; they are removed
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (30, 3)) as t (x, y)\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (20, 2)) as t (x, y) where x> 30\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (40, 4))\n"
operator|+
literal|"except\n"
operator|+
literal|"select * from (values (50, 5)) as t (x, y) where x> 50"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_VALUES_MERGE
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|MINUS_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testLeftEmptyInnerJoin
parameter_list|()
block|{
comment|// Plan should be empty
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"select * from emp where false) as e\n"
operator|+
literal|"join dept as d on e.deptno = d.deptno"
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|sql
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testLeftEmptyLeftJoin
parameter_list|()
block|{
comment|// Plan should be empty
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select * from emp where false) e\n"
operator|+
literal|"left join dept d on e.deptno = d.deptno"
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|sql
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testLeftEmptyRightJoin
parameter_list|()
block|{
comment|// Plan should be equivalent to "select * from emp right join dept".
comment|// Cannot optimize away the join because of RIGHT.
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select * from emp where false) e\n"
operator|+
literal|"right join dept d on e.deptno = d.deptno"
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|sql
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testLeftEmptyFullJoin
parameter_list|()
block|{
comment|// Plan should be equivalent to "select * from emp full join dept".
comment|// Cannot optimize away the join because of FULL.
specifier|final
name|String
name|sql
init|=
literal|"select * from (\n"
operator|+
literal|"  select * from emp where false) e\n"
operator|+
literal|"full join dept d on e.deptno = d.deptno"
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|sql
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testLeftEmptySemiJoin
parameter_list|()
block|{
name|checkLeftEmptySemiOrAntiJoin
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testLeftEmptyAntiJoin
parameter_list|()
block|{
name|checkLeftEmptySemiOrAntiJoin
argument_list|(
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkLeftEmptySemiOrAntiJoin
parameter_list|(
name|JoinRelType
name|type
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|empty
argument_list|()
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|type
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|relFn
argument_list|(
name|relFn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRightEmptyInnerJoin
parameter_list|()
block|{
comment|// Plan should be empty
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e\n"
operator|+
literal|"join (select * from dept where false) as d\n"
operator|+
literal|"on e.deptno = d.deptno"
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|sql
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRightEmptyLeftJoin
parameter_list|()
block|{
comment|// Plan should be equivalent to "select * from emp left join dept".
comment|// Cannot optimize away the join because of LEFT.
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e\n"
operator|+
literal|"left join (select * from dept where false) as d\n"
operator|+
literal|"on e.deptno = d.deptno"
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|sql
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRightEmptyRightJoin
parameter_list|()
block|{
comment|// Plan should be empty
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e\n"
operator|+
literal|"right join (select * from dept where false) as d\n"
operator|+
literal|"on e.deptno = d.deptno"
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|sql
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRightEmptyFullJoin
parameter_list|()
block|{
comment|// Plan should be equivalent to "select * from emp full join dept".
comment|// Cannot optimize away the join because of FULL.
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e\n"
operator|+
literal|"full join (select * from dept where false) as d\n"
operator|+
literal|"on e.deptno = d.deptno"
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|sql
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRightEmptySemiJoin
parameter_list|()
block|{
name|checkRightEmptyAntiJoin
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRightEmptyAntiJoin
parameter_list|()
block|{
name|checkRightEmptyAntiJoin
argument_list|(
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkRightEmptyAntiJoin
parameter_list|(
name|JoinRelType
name|type
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|empty
argument_list|()
operator|.
name|join
argument_list|(
name|type
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|relFn
argument_list|(
name|relFn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testRightEmptyAntiJoinNonEqui
parameter_list|()
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|empty
argument_list|()
operator|.
name|antiJoin
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"SAL"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|2000
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkEmptyJoin
argument_list|(
name|relFn
argument_list|(
name|relFn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkEmptyJoin
parameter_list|(
name|RelOptTestBase
operator|.
name|Sql
name|sql
parameter_list|)
block|{
name|sql
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptySort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where false order by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|SORT_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptySort2
parameter_list|()
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|empty
argument_list|()
operator|.
name|sort
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DNAME"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|PruneEmptyRules
operator|.
name|SORT_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptySortLimitZero
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp order by deptno limit 0"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|PruneEmptyRules
operator|.
name|SORT_FETCH_ZERO_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptyAggregate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(empno) from emp where false group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|AGGREGATE_INSTANCE
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptyAggregateEmptyKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(empno) from emp where false"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|withRule
argument_list|(
name|PruneEmptyRules
operator|.
name|AGGREGATE_INSTANCE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEmptyAggregateEmptyKeyWithAggregateValuesRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*), sum(empno) from emp where false"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|PruneEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_VALUES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceCasts
parameter_list|()
block|{
comment|// Disable simplify in RelBuilder so that there are casts in 'before';
comment|// The resulting plan should have no cast expressions
specifier|final
name|String
name|sql
init|=
literal|"select cast(d.name as varchar(128)), cast(e.empno as integer)\n"
operator|+
literal|"from dept as d inner join emp as e\n"
operator|+
literal|"on cast(d.deptno as integer) = cast(e.deptno as integer)\n"
operator|+
literal|"where cast(e.job as varchar(1)) = 'Manager'"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that a cast from a TIME to a TIMESTAMP is not reduced. It is not    * constant because the result depends upon the current date. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceCastTimeUnchanged
parameter_list|()
block|{
name|sql
argument_list|(
literal|"select cast(time '12:34:56' as timestamp) from emp as e"
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceCastAndConsts
parameter_list|()
block|{
comment|// Make sure constant expressions inside the cast can be reduced
comment|// in addition to the casts.
specifier|final
name|String
name|sql
init|=
literal|"select * from emp\n"
operator|+
literal|"where cast((empno + (10/2)) as int) = 13"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceCaseNullabilityChange
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select case when empno = 1 then 1\n"
operator|+
literal|"when 1 IS NOT NULL then 2\n"
operator|+
literal|"else null end as qx "
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceCastsNullable
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
comment|// Simulate the way INSERT will insert casts to the target types
operator|.
name|addRuleInstance
argument_list|(
name|CoerceInputsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withCoerceNames
argument_list|(
literal|false
argument_list|)
operator|.
name|withConsumerRelClass
argument_list|(
name|LogicalTableModify
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|)
comment|// Convert projects to calcs, merge two calcs, and then
comment|// reduce redundant casts in merged calc.
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|CALC_MERGE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|CALC_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"insert into sales.dept(deptno, name)\n"
operator|+
literal|"select empno, cast(job as varchar(128)) from sales.empnullables"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceCaseWhenWithCast
parameter_list|()
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|b
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BIGINT
argument_list|)
decl_stmt|;
name|RelNode
name|left
init|=
name|b
operator|.
name|values
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"x"
operator|,
literal|"y"
block|}
operator|,
literal|1
operator|,
literal|2
block_content|)
block|.build(
init|)
decl_stmt|;
name|RexNode
name|ref
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|RexLiteral
name|literal1
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|RexLiteral
name|literal2
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|2
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|RexLiteral
name|literal3
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|3
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|// CASE WHEN x % 2 = 1 THEN x< 2
comment|//      WHEN x % 3 = 2 THEN x< 1
comment|//      ELSE x< 3
specifier|final
name|RexNode
name|caseRexNode
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MOD
argument_list|,
name|ref
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|ref
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MOD
argument_list|,
name|ref
argument_list|,
name|literal3
argument_list|)
argument_list|,
name|literal2
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|ref
argument_list|,
name|literal1
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|ref
argument_list|,
name|literal3
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|castNode
init|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createTypeWithNullability
argument_list|(
name|caseRexNode
operator|.
name|getType
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|caseRexNode
argument_list|)
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|left
argument_list|)
operator|.
name|project
argument_list|(
name|castNode
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ReduceExpressionsRule
operator|.
name|class
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}    private
name|void
name|basePushAggThroughUnion
parameter_list|()
block|{
name|sql
argument_list|(
literal|"${sql}"
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_UNION_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumConstantThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumNullConstantThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumNullableThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumNullableNOGBYThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushCountStarThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushCountNullableThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushMaxNullableThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushMinThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushAvgThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumCountStarThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumConstantGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumNullConstantGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumNullableGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushCountStarGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushCountNullableGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushMaxNullableGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushMinGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushAvgGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushSumCountStarGroupingSetsThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushCountFilterThroughUnion
parameter_list|()
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushBoolAndBoolOrThroughUnion
parameter_list|()
block|{
name|sql
argument_list|(
literal|"${sql}"
argument_list|)
operator|.
name|withContext
argument_list|(
name|c
lambda|->
name|Contexts
operator|.
name|of
argument_list|(
name|SqlValidatorTest
operator|.
name|operatorTableFor
argument_list|(
name|SqlLibrary
operator|.
name|POSTGRESQL
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SET_OP_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_UNION_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullFilterThroughAggregate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal, deptno from ("
operator|+
literal|"  select ename, sal, deptno"
operator|+
literal|"  from emp"
operator|+
literal|"  where sal> 5000)"
operator|+
literal|"group by ename, sal, deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_FILTER_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullFilterThroughAggregateGroupingSets
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal, deptno from ("
operator|+
literal|"  select ename, sal, deptno"
operator|+
literal|"  from emp"
operator|+
literal|"  where sal> 5000)"
operator|+
literal|"group by rollup(ename, sal, deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_FILTER_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|basePullConstantTroughAggregate
parameter_list|()
block|{
name|sql
argument_list|(
literal|"${sql}"
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_PULL_UP_CONSTANTS
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughConstLast
parameter_list|()
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughAggregateSimpleNonNullable
parameter_list|()
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughAggregatePermuted
parameter_list|()
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughAggregatePermutedConstFirst
parameter_list|()
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughAggregatePermutedConstGroupBy
parameter_list|()
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughAggregateConstGroupBy
parameter_list|()
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughAggregateAllConst
parameter_list|()
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughAggregateAllLiterals
parameter_list|()
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 2, deptno, job from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 2, deptno, job from emp as e2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_PULL_UP_CONSTANTS
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughUnion2
parameter_list|()
block|{
comment|// Negative test: constants should not be pulled up
specifier|final
name|String
name|sql
init|=
literal|"select 2, deptno, job from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 1, deptno, job from emp as e2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_PULL_UP_CONSTANTS
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantThroughUnion3
parameter_list|()
block|{
comment|// We should leave at least a single column in each Union input
specifier|final
name|String
name|sql
init|=
literal|"select 2, 3 from emp as e1\n"
operator|+
literal|"union all\n"
operator|+
literal|"select 2, 3 from emp as e2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|UNION_PULL_UP_CONSTANTS
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAggregateProjectMerge
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select x, sum(z), y from (\n"
operator|+
literal|"  select deptno as x, empno as y, sal as z, sal * 2 as zz\n"
operator|+
literal|"  from emp)\n"
operator|+
literal|"group by x, y"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAggregateGroupingSetsProjectMerge
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select x, sum(z), y from (\n"
operator|+
literal|"  select deptno as x, empno as y, sal as z, sal * 2 as zz\n"
operator|+
literal|"  from emp)\n"
operator|+
literal|"group by rollup(x, y)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAggregateExtractProjectRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(sal)\n"
operator|+
literal|"from emp"
decl_stmt|;
name|HepProgram
name|pre
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|pre
argument_list|)
operator|.
name|withRule
argument_list|(
name|AggregateExtractProjectRule
operator|.
name|SCAN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAggregateExtractProjectRuleWithGroupingSets
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, sum(sal)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by grouping sets ((empno, deptno),(deptno),(empno))"
decl_stmt|;
name|HepProgram
name|pre
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|pre
argument_list|)
operator|.
name|withRule
argument_list|(
name|AggregateExtractProjectRule
operator|.
name|SCAN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test with column used in both grouping set and argument to aggregate    * function. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateExtractProjectRuleWithGroupingSets2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, sum(empno)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by grouping sets ((empno, deptno),(deptno),(empno))"
decl_stmt|;
name|HepProgram
name|pre
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|pre
argument_list|)
operator|.
name|withRule
argument_list|(
name|AggregateExtractProjectRule
operator|.
name|SCAN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAggregateExtractProjectRuleWithFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(sal) filter (where empno = 40)\n"
operator|+
literal|"from emp"
decl_stmt|;
name|HepProgram
name|pre
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// AggregateProjectMergeRule does not merges Project with Filter.
comment|// Force match Aggregate on top of Project once explicitly in unit test.
specifier|final
name|AggregateExtractProjectRule
name|rule
init|=
name|AggregateExtractProjectRule
operator|.
name|SCAN
operator|.
name|config
operator|.
name|withOperandSupplier
argument_list|(
name|b0
lambda|->
name|b0
operator|.
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|)
operator|.
name|oneInput
argument_list|(
name|b1
lambda|->
name|b1
operator|.
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|)
operator|.
name|predicate
argument_list|(
operator|new
name|Predicate
argument_list|<
name|Project
argument_list|>
argument_list|()
block|{
name|int
name|matchCount
operator|=
literal|0
argument_list|;
specifier|public
name|boolean
name|test
argument_list|(
name|Project
name|project
argument_list|)
block|{
return|return
name|matchCount
operator|++
operator|==
literal|0
return|;
block|}
block|}
end_function

begin_expr_stmt
unit|)
operator|.
name|anyInputs
argument_list|()
end_expr_stmt

begin_expr_stmt
unit|))
operator|.
name|as
argument_list|(
name|AggregateExtractProjectRule
operator|.
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|pre
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}    @
name|Test
name|void
name|testAggregateCaseToFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|" sum(sal) as sum_sal,\n"
operator|+
literal|" count(distinct case\n"
operator|+
literal|"       when job = 'CLERK'\n"
operator|+
literal|"       then deptno else null end) as count_distinct_clerk,\n"
operator|+
literal|" sum(case when deptno = 10 then sal end) as sum_sal_d10,\n"
operator|+
literal|" sum(case when deptno = 20 then sal else 0 end) as sum_sal_d20,\n"
operator|+
literal|" sum(case when deptno = 30 then 1 else 0 end) as count_d30,\n"
operator|+
literal|" count(case when deptno = 40 then 'x' end) as count_d40,\n"
operator|+
literal|" sum(case when deptno = 45 then 1 end) as count_d45,\n"
operator|+
literal|" sum(case when deptno = 50 then 1 else null end) as count_d50,\n"
operator|+
literal|" sum(case when deptno = 60 then null end) as sum_null_d60,\n"
operator|+
literal|" sum(case when deptno = 70 then null else 1 end) as sum_null_d70,\n"
operator|+
literal|" count(case when deptno = 20 then 1 end) as count_d20\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_CASE_TO_FILTER
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullAggregateThroughUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, job from"
operator|+
literal|" (select deptno, job from emp as e1"
operator|+
literal|" group by deptno,job"
operator|+
literal|"  union all"
operator|+
literal|" select deptno, job from emp as e2"
operator|+
literal|" group by deptno,job)"
operator|+
literal|" group by deptno,job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_UNION_AGGREGATE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullAggregateThroughUnion2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, job from"
operator|+
literal|" (select deptno, job from emp as e1"
operator|+
literal|" group by deptno,job"
operator|+
literal|"  union all"
operator|+
literal|" select deptno, job from emp as e2"
operator|+
literal|" group by deptno,job)"
operator|+
literal|" group by deptno,job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_UNION_AGGREGATE_SECOND
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_UNION_AGGREGATE_FIRST
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Once the bottom aggregate pulled through union, we need to add a Project    * if the new input contains a different type from the union.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPullAggregateThroughUnionAndAddProjects
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select job, deptno from"
operator|+
literal|" (select job, deptno from emp as e1"
operator|+
literal|" group by job, deptno"
operator|+
literal|"  union all"
operator|+
literal|" select job, deptno from emp as e2"
operator|+
literal|" group by job, deptno)"
operator|+
literal|" group by job, deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_UNION_AGGREGATE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Make sure the union alias is preserved when the bottom aggregate is    * pulled up through union.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPullAggregateThroughUnionWithAlias
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select job, c from"
operator|+
literal|" (select job, deptno c from emp as e1"
operator|+
literal|" group by job, deptno"
operator|+
literal|"  union all"
operator|+
literal|" select job, deptno from emp as e2"
operator|+
literal|" group by job, deptno)"
operator|+
literal|" group by job, c"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_UNION_AGGREGATE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Creates a {@link HepProgram} with common transitive rules.    */
end_comment

begin_function
specifier|private
name|HepProgram
name|getTransitiveProgram
parameter_list|()
block|{
return|return
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN_DUMB
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|JOIN_CONDITION_PUSH
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_SET_OP_TRANSPOSE
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno where e.deptno> 7"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceProject
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from (select * from sales.emp where deptno> 7) d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceAggregate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from (select deptno, count(*) from sales.emp where deptno> 7\n"
operator|+
literal|"group by deptno) d inner join sales.emp e on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceUnion
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from\n"
operator|+
literal|"(select deptno from sales.emp where deptno> 7\n"
operator|+
literal|"union all select deptno from sales.emp where deptno> 10) d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceJoin3way
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno\n"
operator|+
literal|"inner join sales.emp f on e.deptno = f.deptno\n"
operator|+
literal|"where d.deptno> 7"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceJoin3wayAgg
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from\n"
operator|+
literal|"(select deptno, count(*) from sales.emp where deptno> 7 group by deptno) d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno\n"
operator|+
literal|"inner join sales.emp f on e.deptno = f.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceLeftOuterJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d\n"
operator|+
literal|"left outer join sales.emp e on d.deptno = e.deptno\n"
operator|+
literal|"where d.deptno> 7 and e.deptno> 9"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceRightOuterJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d\n"
operator|+
literal|"right outer join sales.emp e on d.deptno = e.deptno\n"
operator|+
literal|"where d.deptno> 7 and e.deptno> 9"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceFullOuterJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d full outer join sales.emp e\n"
operator|+
literal|"on d.deptno = e.deptno  where d.deptno> 7 and e.deptno> 9"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferencePreventProjectPullUp
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from (select comm as deptno from sales.emp where deptno> 7) d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferencePullUpThruAlias
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from (select comm as deptno from sales.emp where comm> 7) d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceConjunctInPullUp
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno\n"
operator|+
literal|"where d.deptno in (7, 9) or d.deptno> 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceNoPullUpExprs
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno\n"
operator|+
literal|"where d.deptno in (7, 9) or d.comm> 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceUnion3way
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from\n"
operator|+
literal|"(select deptno from sales.emp where deptno> 7\n"
operator|+
literal|"union all\n"
operator|+
literal|"select deptno from sales.emp where deptno> 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select deptno from sales.emp where deptno> 1) d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceUnion3wayOr
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from\n"
operator|+
literal|"(select empno, deptno from sales.emp where deptno> 7 or empno< 10\n"
operator|+
literal|"union all\n"
operator|+
literal|"select empno, deptno from sales.emp where deptno> 10 or empno< deptno\n"
operator|+
literal|"union all\n"
operator|+
literal|"select empno, deptno from sales.emp where deptno> 1) d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-443">[CALCITE-443]    * getPredicates from a union is not correct</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceUnionAlwaysTrue
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, e.deptno from\n"
operator|+
literal|"(select deptno from sales.emp where deptno< 4) d\n"
operator|+
literal|"inner join\n"
operator|+
literal|"(select deptno from sales.emp where deptno> 7\n"
operator|+
literal|"union all select deptno from sales.emp) e\n"
operator|+
literal|"on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceConstantEquiPredicate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno  where 1 = 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testTransitiveInferenceComplexPredicate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.emp d\n"
operator|+
literal|"inner join sales.emp e on d.deptno = e.deptno\n"
operator|+
literal|"where d.deptno> 7 and e.sal = e.deptno and d.comm = d.deptno\n"
operator|+
literal|"and d.comm + d.deptno> d.comm/2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantIntoProject
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, deptno + 1, empno + deptno\n"
operator|+
literal|"from sales.emp where deptno = 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|,
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantIntoFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from sales.emp where deptno = 10)\n"
operator|+
literal|"where deptno + 5> empno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1995">[CALCITE-1995]    * Remove predicates from Filter if they can be proved to be always true or    * false</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSimplifyFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from sales.emp where deptno> 10)\n"
operator|+
literal|"where empno> 3 and deptno> 5"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantIntoJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"left join sales.dept as d on e.empno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPullConstantIntoJoin2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.empno = d.deptno and e.deptno + e.empno = d.deptno + 5"
decl_stmt|;
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|addRuleCollection
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|getTransitiveProgram
argument_list|()
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2110">[CALCITE-2110]    * ArrayIndexOutOfBoundsException in RexSimplify when using    * ReduceExpressionsRule.JOIN_INSTANCE</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testCorrelationScalarAggAndFilter
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e1.empno\n"
operator|+
literal|"FROM emp e1, dept d1 where e1.deptno = d1.deptno\n"
operator|+
literal|"and e1.deptno< 10 and d1.deptno< 15\n"
operator|+
literal|"and e1.sal> (select avg(sal) from emp e2 where e1.empno = e2.empno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|true
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|,
name|CoreRules
operator|.
name|JOIN_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3111">[CALCITE-3111]    * Allow custom implementations of Correlate in RelDecorrelator</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testCustomDecorrelate
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e1.empno\n"
operator|+
literal|"FROM emp e1, dept d1 where e1.deptno = d1.deptno\n"
operator|+
literal|"and e1.deptno< 10 and d1.deptno< 15\n"
operator|+
literal|"and e1.sal> (select avg(sal) from emp e2 where e1.empno = e2.empno)"
decl_stmt|;
comment|// Convert sql to rel
name|RelRoot
name|root
init|=
name|tester
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
comment|// Create a duplicate rel tree with a custom correlate instead of logical correlate
name|LogicalCorrelate
name|logicalCorrelate
init|=
operator|(
name|LogicalCorrelate
operator|)
name|root
operator|.
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|CustomCorrelate
name|customCorrelate
init|=
operator|new
name|CustomCorrelate
argument_list|(
name|logicalCorrelate
operator|.
name|getCluster
argument_list|()
argument_list|,
name|logicalCorrelate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|logicalCorrelate
operator|.
name|getLeft
argument_list|()
argument_list|,
name|logicalCorrelate
operator|.
name|getRight
argument_list|()
argument_list|,
name|logicalCorrelate
operator|.
name|getCorrelationId
argument_list|()
argument_list|,
name|logicalCorrelate
operator|.
name|getRequiredColumns
argument_list|()
argument_list|,
name|logicalCorrelate
operator|.
name|getJoinType
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|newRoot
init|=
name|root
operator|.
name|rel
operator|.
name|copy
argument_list|(
name|root
operator|.
name|rel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|root
operator|.
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|copy
argument_list|(
name|root
operator|.
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|customCorrelate
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Decorrelate both trees using the same relBuilder
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|RelNode
name|logicalDecorrelated
init|=
name|RelDecorrelator
operator|.
name|decorrelateQuery
argument_list|(
name|root
operator|.
name|rel
argument_list|,
name|relBuilder
argument_list|)
decl_stmt|;
name|RelNode
name|customDecorrelated
init|=
name|RelDecorrelator
operator|.
name|decorrelateQuery
argument_list|(
name|newRoot
argument_list|,
name|relBuilder
argument_list|)
decl_stmt|;
name|String
name|logicalDecorrelatedPlan
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|logicalDecorrelated
argument_list|)
decl_stmt|;
name|String
name|customDecorrelatedPlan
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|customDecorrelated
argument_list|)
decl_stmt|;
comment|// Ensure that the plans are equal
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"Comparing Plans from LogicalCorrelate and CustomCorrelate"
argument_list|,
name|logicalDecorrelatedPlan
argument_list|,
name|customDecorrelatedPlan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testProjectWindowTransposeRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(empno) over(), deptno from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|,
name|CoreRules
operator|.
name|PROJECT_WINDOW_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testProjectWindowTransposeRuleWithConstants
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select col1, col2\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select empno,\n"
operator|+
literal|"    sum(100) over (partition by  deptno order by sal) as col1,\n"
operator|+
literal|"  sum(1000) over(partition by deptno order by sal) as col2\n"
operator|+
literal|"  from emp)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_WINDOW_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** While it's probably valid relational algebra for a Project to contain    * a RexOver inside a RexOver, ProjectMergeRule should not bring it about. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectMergeShouldIgnoreOver
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select row_number() over (order by deptno), col1\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select deptno,\n"
operator|+
literal|"    sum(100) over (partition by  deptno order by sal) as col1\n"
operator|+
literal|"  from emp)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAggregateProjectPullUpConstants
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select job, empno, sal, sum(sal) as s\n"
operator|+
literal|"from emp where empno = 10\n"
operator|+
literal|"group by job, empno, sal"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_ANY_PULL_UP_CONSTANTS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAggregateProjectPullUpConstants2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename, sal\n"
operator|+
literal|"from (select '1', ename, sal from emp where ename = 'John') subq\n"
operator|+
literal|"group by ename, sal"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_ANY_PULL_UP_CONSTANTS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushFilterWithRank
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename, r\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select ename, "
operator|+
literal|"  rank() over(partition by  deptno order by sal) as r "
operator|+
literal|"  from emp) e1\n"
operator|+
literal|"where r< 2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushFilterWithRankExpr
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e1.ename, r\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select ename,\n"
operator|+
literal|"  rank() over(partition by  deptno order by sal) + 1 as r "
operator|+
literal|"  from emp) e1\n"
operator|+
literal|"where r< 2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-841">[CALCITE-841]    * Redundant windows when window function arguments are expressions</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testExpressionInWindowFunction
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|" sum(deptno) over(partition by deptno order by sal) as sum1,\n"
operator|+
literal|"sum(deptno + sal) over(partition by deptno order by sal) as sum2\n"
operator|+
literal|"from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-888">[CALCITE-888]    * Overlay window loses PARTITION BY list</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testWindowInParenthesis
parameter_list|()
block|{
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleClass
argument_list|(
name|ProjectToWindowRule
operator|.
name|class
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|addRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select count(*) over (w), count(*) over w\n"
operator|+
literal|"from emp\n"
operator|+
literal|"window w as (partition by empno order by empno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for DX-11490:    * Make sure the planner doesn't fail over wrong push down    * of is null. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testIsNullPushDown
parameter_list|()
block|{
name|HepProgramBuilder
name|preBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|preBuilder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|)
expr_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, w_count from (\n"
operator|+
literal|"  select empno, deptno, count(empno) over (w) w_count\n"
operator|+
literal|"  from emp\n"
operator|+
literal|"  window w as (partition by deptno order by empno)\n"
operator|+
literal|") sub_query where w_count is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preBuilder
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testIsNullPushDown2
parameter_list|()
block|{
name|HepProgramBuilder
name|preBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|preBuilder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|)
expr_stmt|;
name|HepProgramBuilder
name|builder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, w_count from (\n"
operator|+
literal|"  select empno, deptno, count(empno) over (ROWS BETWEEN 10 PRECEDING AND 1 PRECEDING) w_count\n"
operator|+
literal|"  from emp\n"
operator|+
literal|") sub_query where w_count is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPre
argument_list|(
name|preBuilder
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-750">[CALCITE-750]    * Allow windowed aggregate on top of regular aggregate</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testNestedAggregates
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT\n"
operator|+
literal|"  avg(sum(sal) + 2 * min(empno) + 3 * avg(empno))\n"
operator|+
literal|"  over (partition by deptno)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2078">[CALCITE-2078]    * Aggregate functions in OVER clause</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testWindowFunctionOnAggregations
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT\n"
operator|+
literal|"  min(empno),\n"
operator|+
literal|"  sum(sal),\n"
operator|+
literal|"  sum(sum(sal))\n"
operator|+
literal|"    over (partition by min(empno) order by sum(sal))\n"
operator|+
literal|"from emp\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoin1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job,d.name\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by on non-join keys, group by on    * non-null generating side only. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.ename\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by on non-join keys, on null    * generating side only. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.ename\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.emp as d on e.job = d.job\n"
operator|+
literal|"group by d.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by on both side on non-join    * keys. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.ename, d.mgr\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.emp as d on e.job = d.job\n"
operator|+
literal|"group by e.ename,d.mgr"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by on key same as join key,    * group by on non-null generating side. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by on key same as join key,    * group by on null generating side. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.name\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by on key same as join key,    * group by on both side. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job,d.name\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by key is susbset of join keys,    * group by on non-null generating side. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin7
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"and e.deptno + e.empno = d.deptno + 5\n"
operator|+
literal|"group by e.job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by key is a subset of join keys,    * group by on null generating side. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin8
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.name\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"and e.deptno + e.empno = d.deptno + 5\n"
operator|+
literal|"group by d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, group by key is susbset of join keys,    * group by on both sides. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin9
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job, d.name\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"left outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"and e.deptno + e.empno = d.deptno + 5\n"
operator|+
literal|"group by e.job, d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for outer join, with aggregate functions. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin10
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(e.ename)\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"left outer join sales.emp as d on e.job = d.job\n"
operator|+
literal|"group by e.ename,d.mgr"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for non-equi outer join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin11
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.empno,d.deptno\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"left outer join sales.dept as d on e.empno< d.deptno\n"
operator|+
literal|"group by e.empno,d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRelBuilderConfig
argument_list|(
name|b
lambda|->
name|b
operator|.
name|withAggregateUnique
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for right outer join, group by on key same as join    * key, group by on (left)null generating side. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin12
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"right outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for full outer join, group by on key same as join key,    * group by on one side. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin13
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"full outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for full outer join, group by on key same as join key,    * group by on both side. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin14
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.mgr, d.mgr\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"full outer join sales.emp as d on e.mgr = d.mgr\n"
operator|+
literal|"group by d.mgr, e.mgr"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for full outer join, group by on both side on non-join    * keys. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin15
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.ename, d.mgr\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"full outer join sales.emp as d on e.job = d.job\n"
operator|+
literal|"group by e.ename,d.mgr"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for full outer join, group by key is susbset of join    * keys. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughOuterJoin16
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"full outer join sales.dept as d on e.job = d.name\n"
operator|+
literal|"and e.deptno + e.empno = d.deptno + 5\n"
operator|+
literal|"group by e.job"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoin2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job,d.name\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"and e.deptno + e.empno = d.deptno + 5\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoin3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.empno,d.deptno\n"
operator|+
literal|"from (select * from sales.emp where empno = 10) as e\n"
operator|+
literal|"join sales.dept as d on e.empno< d.deptno\n"
operator|+
literal|"group by e.empno,d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRelBuilderConfig
argument_list|(
name|b
lambda|->
name|b
operator|.
name|withAggregateUnique
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1544">[CALCITE-1544]    * AggregateJoinTransposeRule fails to preserve row type</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoin4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno\n"
operator|+
literal|"from sales.emp as e join sales.dept as d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoin5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno, d.deptno\n"
operator|+
literal|"from sales.emp as e join sales.dept as d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno, d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2200">[CALCITE-2200]    * Infinite loop for JoinPushTransitivePredicatesRule</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testJoinPushTransitivePredicatesRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.emp d where d.deptno\n"
operator|+
literal|"IN (select e.deptno from sales.emp e "
operator|+
literal|"where e.deptno = d.deptno or e.deptno = 4)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_CONDITION_PUSH
argument_list|,
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|withRule
argument_list|()
comment|// empty program
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2205">[CALCITE-2205]    * One more infinite loop for JoinPushTransitivePredicatesRule</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testJoinPushTransitivePredicatesRule2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select n1.SAL\n"
operator|+
literal|"from EMPNULLABLES_20 n1\n"
operator|+
literal|"where n1.SAL IN (\n"
operator|+
literal|"  select n2.SAL\n"
operator|+
literal|"  from EMPNULLABLES_20 n2\n"
operator|+
literal|"  where n1.SAL = n2.SAL or n1.SAL = 4)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_CONDITION_PUSH
argument_list|,
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2275">[CALCITE-2275]    * JoinPushTransitivePredicatesRule wrongly pushes down NOT condition</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testInferringPredicatesWithNotOperatorInJoinCondition
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp d\n"
operator|+
literal|"join sales.emp e on e.deptno = d.deptno and d.deptno not in (4, 6)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_CONDITION_PUSH
argument_list|,
name|CoreRules
operator|.
name|JOIN_PUSH_TRANSITIVE_PREDICATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2195">[CALCITE-2195]    * AggregateJoinTransposeRule fails to aggregate over unique column</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoin6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(B.sal)\n"
operator|+
literal|"from sales.emp as A\n"
operator|+
literal|"join (select distinct sal from sales.emp) as B\n"
operator|+
literal|"on A.sal=B.sal\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoin7
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select any_value(distinct B.sal)\n"
operator|+
literal|"from sales.emp as A\n"
operator|+
literal|"join (select distinct sal from sales.emp) as B\n"
operator|+
literal|"on A.sal=B.sal\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoin8
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select single_value(distinct B.sal)\n"
operator|+
literal|"from sales.emp as A\n"
operator|+
literal|"join (select distinct sal from sales.emp) as B\n"
operator|+
literal|"on A.sal=B.sal\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2278">[CALCITE-2278]    * AggregateJoinTransposeRule fails to split aggregate call if input contains    * an aggregate call and has distinct rows</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoinWithUniqueInput
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select A.job, B.mgr, A.deptno,\n"
operator|+
literal|"max(B.hiredate1) as hiredate1, sum(B.comm1) as comm1\n"
operator|+
literal|"from sales.emp as A\n"
operator|+
literal|"join (select mgr, sal, max(hiredate) as hiredate1,\n"
operator|+
literal|"    sum(comm) as comm1 from sales.emp group by mgr, sal) as B\n"
operator|+
literal|"on A.sal=B.sal\n"
operator|+
literal|"group by A.job, B.mgr, A.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** SUM is the easiest aggregate function to split. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateSumThroughJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job,sum(sal)\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2105">[CALCITE-2105]    * AggregateJoinTransposeRule incorrectly makes a SUM NOT NULL when Aggregate    * has no group keys</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateSumWithoutGroupKeyThroughJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(sal)\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2108">[CALCITE-2108]    * AggregateJoinTransposeRule incorrectly splits a SUM0 call when Aggregate    * has no group keys</a>.    *    *<p>Similar to {@link #testPushAggregateSumThroughJoin()},    * but also uses {@link AggregateReduceFunctionsRule}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateSumThroughJoinAfterAggregateReduce
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(sal)\n"
operator|+
literal|"from (select * from sales.emp where ename = 'A') as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REDUCE_FUNCTIONS
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Push a variety of aggregate functions. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateFunctionsThroughJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.job,\n"
operator|+
literal|"  min(sal) as min_sal, min(e.deptno) as min_deptno,\n"
operator|+
literal|"  sum(sal) + 1 as sum_sal_plus, max(sal) as max_sal,\n"
operator|+
literal|"  sum(sal) as sum_sal_2, count(sal) as count_sal,\n"
operator|+
literal|"  count(mgr) as count_mgr\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"join sales.dept as d on e.job = d.name\n"
operator|+
literal|"group by e.job,d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Push a aggregate functions into a relation that is unique on the join    * key. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoinDistinct
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.name,\n"
operator|+
literal|"  sum(sal) as sum_sal, count(*) as c\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"join (select distinct name from sales.dept) as d\n"
operator|+
literal|"  on e.job = d.name\n"
operator|+
literal|"group by d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Push count(*) through join, no GROUP BY. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateSumNoGroup
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) from sales.emp join sales.dept on job = name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3076">[CALCITE-3076]    * AggregateJoinTransposeRule throws error for unique under aggregate keys when    * generating merged calls</a>.*/
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushAggregateThroughJoinOnEmptyLogicalValues
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) volume, sum(C1.sal) C1_sum_sal "
operator|+
literal|"from (select sal, ename from sales.emp where 1=2) C1 "
operator|+
literal|"inner join (select ename from sales.emp) C2   "
operator|+
literal|"on C1.ename = C2.ename "
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2249">[CALCITE-2249]    * AggregateJoinTransposeRule generates non-equivalent nodes if Aggregate    * contains DISTINCT aggregate function</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushDistinctAggregateIntoJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(distinct sal) from sales.emp\n"
operator|+
literal|" join sales.dept on job = name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that ProjectAggregateMergeRule removes unused aggregate calls but    * not group keys. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectAggregateMerge
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno + ss\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select job, deptno, min(sal) as ms, sum(sal) as ss\n"
operator|+
literal|"  from sales.emp\n"
operator|+
literal|"  group by job, deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_AGGREGATE_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that ProjectAggregateMergeRule does nothing when all aggregate calls    * are referenced. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectAggregateMergeNoOp
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno + ss + ms\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select job, deptno, min(sal) as ms, sum(sal) as ss\n"
operator|+
literal|"  from sales.emp\n"
operator|+
literal|"  group by job, deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_AGGREGATE_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that ProjectAggregateMergeRule converts {@code COALESCE(SUM(x), 0)}    * into {@code SUM0(x)}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectAggregateMergeSum0
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select coalesce(sum_sal, 0) as ss0\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select sum(sal) as sum_sal\n"
operator|+
literal|"  from sales.emp)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_AGGREGATE_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** As {@link #testProjectAggregateMergeSum0()} but there is another use of    * {@code SUM} that cannot be converted to {@code SUM0}. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectAggregateMergeSum0AndSum
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum_sal * 2, coalesce(sum_sal, 0) as ss0\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select sum(sal) as sum_sal\n"
operator|+
literal|"  from sales.emp)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_AGGREGATE_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should merge 2 aggregates    * into a single aggregate.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMerge1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno c, min(y), max(z) z,\n"
operator|+
literal|"sum(r), sum(m) n, sum(x) sal from (\n"
operator|+
literal|"   select deptno, ename, sum(sal) x, max(sal) z,\n"
operator|+
literal|"      min(sal) y, count(hiredate) m, count(mgr) r\n"
operator|+
literal|"   from sales.emp group by deptno, ename) t\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should merge 2 aggregates    * into a single aggregate, top aggregate is not simple aggregate.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMerge2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, empno, sum(x), sum(y)\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select ename, empno, deptno, sum(sal) x, count(mgr) y\n"
operator|+
literal|"    from sales.emp\n"
operator|+
literal|"  group by deptno, ename, empno) t\n"
operator|+
literal|"group by grouping sets(deptno, empno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since lower aggregate is not simple aggregate.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMerge3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, sum(x) from (\n"
operator|+
literal|" select ename, deptno, sum(sal) x from\n"
operator|+
literal|"   sales.emp group by cube(deptno, ename)) t\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since it contains distinct aggregate    * function.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMerge4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, sum(x) from (\n"
operator|+
literal|"  select ename, deptno, count(distinct sal) x\n"
operator|+
literal|"    from sales.emp group by deptno, ename) t\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since AVG doesn't support splitting.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMerge5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, avg(x) from (\n"
operator|+
literal|"  select mgr, deptno, avg(sal) x from\n"
operator|+
literal|"    sales.emp group by deptno, mgr) t\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since top agg has no group key, and    * lower agg function is COUNT.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMerge6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(x) from (\n"
operator|+
literal|"select mgr, deptno, count(sal) x from\n"
operator|+
literal|"sales.emp group by deptno, mgr) t"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3957">[CALCITE-3957]    * AggregateMergeRule should merge SUM0 into COUNT even if GROUP BY is    * empty</a>. (It is not valid to merge a SUM onto a SUM0 if the top GROUP BY    * is empty.) */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMergeSum0
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select coalesce(sum(count_comm), 0)\n"
operator|+
literal|"from (\n"
operator|+
literal|"  select deptno, count(comm) as count_comm\n"
operator|+
literal|"  from sales.emp\n"
operator|+
literal|"  group by deptno, mgr) t"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_AGGREGATE_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should not merge 2 aggregates    * into a single aggregate, since top agg contains empty grouping set,    * and lower agg function is COUNT.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMerge7
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select mgr, deptno, sum(x) from (\n"
operator|+
literal|"  select mgr, deptno, count(sal) x from\n"
operator|+
literal|"    sales.emp group by deptno, mgr) t\n"
operator|+
literal|"group by cube(mgr, deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateMergeRule, should merge 2 aggregates    * into a single aggregate, since both top and bottom aggregates    * contains empty grouping set and they are mergable.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateMerge8
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(x) x, min(y) z from (\n"
operator|+
literal|"  select sum(sal) x, min(sal) y from sales.emp)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateRemoveRule, should remove aggregates since    * empno is unique and all aggregate functions are splittable.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateRemove1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, sum(sal), min(sal), max(sal), "
operator|+
literal|"bit_and(distinct sal), bit_or(sal), count(distinct sal) "
operator|+
literal|"from sales.emp group by empno, deptno\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REMOVE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateRemoveRule, should remove aggregates since    * empno is unique and there are no aggregate functions.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateRemove2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select distinct empno, deptno from sales.emp\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRelBuilderConfig
argument_list|(
name|b
lambda|->
name|b
operator|.
name|withAggregateUnique
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REMOVE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for AggregateRemoveRule, should remove aggregates since    * empno is unique and all aggregate functions are splittable. Count    * aggregate function should be transformed to CASE function call    * because mgr is nullable.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateRemove3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, count(mgr) "
operator|+
literal|"from sales.emp group by empno, deptno\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REMOVE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Negative test case for AggregateRemoveRule, should not    * remove aggregate because avg is not splittable.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateRemove4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, max(sal), avg(sal) "
operator|+
literal|"from sales.emp group by empno, deptno\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REMOVE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Negative test case for AggregateRemoveRule, should not    * remove non-simple aggregates.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateRemove5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, deptno, sum(sal) "
operator|+
literal|"from sales.emp group by cube(empno, deptno)\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REMOVE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Negative test case for AggregateRemoveRule, should not    * remove aggregate because deptno is not unique.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateRemove6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, max(sal) "
operator|+
literal|"from sales.emp group by deptno\n"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REMOVE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that top Aggregate is removed. Given "deptno=100", the    * input of top Aggregate must be already distinct by "mgr". */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateRemove7
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|""
operator|+
literal|"select mgr, sum(sum_sal)\n"
operator|+
literal|"from\n"
operator|+
literal|"(select mgr, deptno, sum(sal) sum_sal\n"
operator|+
literal|" from sales.emp\n"
operator|+
literal|" group by mgr, deptno)\n"
operator|+
literal|"where deptno=100\n"
operator|+
literal|"group by mgr"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_REMOVE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2712">[CALCITE-2712]    * Should remove the left join since the aggregate has no call and    * only uses column in the left input of the bottom join as group key</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select distinct e.deptno from sales.emp e\n"
operator|+
literal|"left outer join sales.dept d on e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()} but has aggregate    * call with distinct. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno, count(distinct e.job)\n"
operator|+
literal|"from sales.emp e\n"
operator|+
literal|"left outer join sales.dept d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()} but should not    * remove the left join since the aggregate uses column in the right    * input of the bottom join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno, count(distinct d.name)\n"
operator|+
literal|"from sales.emp e\n"
operator|+
literal|"left outer join sales.dept d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()} but right join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select distinct d.deptno\n"
operator|+
literal|"from sales.emp e\n"
operator|+
literal|"right outer join sales.dept d on e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove2()} but right join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, count(distinct d.name)\n"
operator|+
literal|"from sales.emp e\n"
operator|+
literal|"right outer join sales.dept d on e.deptno = d.deptno\n"
operator|+
literal|"group by d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove3()} but right join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, count(distinct e.job)\n"
operator|+
literal|"from sales.emp e\n"
operator|+
literal|"right outer join sales.dept d on e.deptno = d.deptno\n"
operator|+
literal|"group by d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should remove the bottom join since the aggregate has no aggregate    * call. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove7
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT distinct e.deptno\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d1 ON e.deptno = d1.deptno\n"
operator|+
literal|"LEFT JOIN sales.dept d2 ON e.deptno = d2.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove7()} but has aggregate    * call. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove8
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno, COUNT(DISTINCT d2.name)\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d1 ON e.deptno = d1.deptno\n"
operator|+
literal|"LEFT JOIN sales.dept d2 ON e.deptno = d2.deptno\n"
operator|+
literal|"GROUP BY e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove7()} but use columns in    * the right input of the top join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove9
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT distinct e.deptno, d2.name\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d1 ON e.deptno = d1.deptno\n"
operator|+
literal|"LEFT JOIN sales.dept d2 ON e.deptno = d2.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should not remove the bottom join since the aggregate uses column in the    * right input of bottom join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove10
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno, COUNT(DISTINCT d1.name, d2.name)\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d1 ON e.deptno = d1.deptno\n"
operator|+
literal|"LEFT JOIN sales.dept d2 ON e.deptno = d2.deptno\n"
operator|+
literal|"GROUP BY e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove3()} but with agg call    * referencing the last column of the left input. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateJoinRemove11
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.deptno, count(distinct e.slacker)\n"
operator|+
literal|"from sales.emp e\n"
operator|+
literal|"left outer join sales.dept d on e.deptno = d.deptno\n"
operator|+
literal|"group by e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_PROJECT_MERGE
argument_list|,
name|CoreRules
operator|.
name|AGGREGATE_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should remove the bottom join since the project uses column in the    * right input of bottom join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno, d2.deptno\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d1 ON e.deptno = d1.deptno\n"
operator|+
literal|"LEFT JOIN sales.dept d2 ON e.deptno = d2.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should not remove the bottom join since the project uses column in the    * left input of bottom join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno, d1.deptno\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d1 ON e.deptno = d1.deptno\n"
operator|+
literal|"LEFT JOIN sales.dept d2 ON e.deptno = d2.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_JOIN_REMOVE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should not remove the bottom join since the right join keys of bottom    * join are not unique. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e1.deptno, d.deptno\n"
operator|+
literal|"FROM sales.emp e1\n"
operator|+
literal|"LEFT JOIN sales.emp e2 ON e1.deptno = e2.deptno\n"
operator|+
literal|"LEFT JOIN sales.dept d ON e1.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_JOIN_REMOVE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should remove the left join since the join key of the right input is    * unique. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove4
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d ON e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should not remove the left join since the join key of the right input is    * not unique. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove5
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e1.deptno\n"
operator|+
literal|"FROM sales.emp e1\n"
operator|+
literal|"LEFT JOIN sales.emp e2 ON e1.deptno = e2.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_REMOVE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should not remove the left join since the project use columns in the right    * input of the join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove6
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno, d.name\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d ON e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_REMOVE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should remove the right join since the join key of the left input is    * unique. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove7
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno\n"
operator|+
literal|"FROM sales.dept d\n"
operator|+
literal|"RIGHT JOIN sales.emp e ON e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should not remove the right join since the join key of the left input is    * not unique. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove8
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e2.deptno\n"
operator|+
literal|"FROM sales.emp e1\n"
operator|+
literal|"RIGHT JOIN sales.emp e2 ON e1.deptno = e2.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_REMOVE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove1()};    * Should not remove the right join since the project uses columns in the    * left input of the join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove9
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno, d.name\n"
operator|+
literal|"FROM sales.dept d\n"
operator|+
literal|"RIGHT JOIN sales.emp e ON e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_REMOVE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Similar to {@link #testAggregateJoinRemove4()};    * The project references the last column of the left input.    * The rule should be fired.*/
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinRemove10
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e.deptno, e.slacker\n"
operator|+
literal|"FROM sales.emp e\n"
operator|+
literal|"LEFT JOIN sales.dept d ON e.deptno = d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_REMOVE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSwapOuterJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|JOIN_COMMUTE_OUTER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select 1 from sales.dept d left outer join sales.emp e\n"
operator|+
literal|" on d.deptno = e.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4042">[CALCITE-4042]    * JoinCommuteRule must not match SEMI / ANTI join</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSwapSemiJoin
parameter_list|()
block|{
name|checkSwapJoinShouldNotMatch
argument_list|(
name|JoinRelType
operator|.
name|SEMI
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4042">[CALCITE-4042]    * JoinCommuteRule must not match SEMI / ANTI join</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSwapAntiJoin
parameter_list|()
block|{
name|checkSwapJoinShouldNotMatch
argument_list|(
name|JoinRelType
operator|.
name|ANTI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkSwapJoinShouldNotMatch
parameter_list|(
name|JoinRelType
name|type
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|type
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|JOIN_COMMUTE_OUTER
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4621">[CALCITE-4621]    * SemiJoinRule throws AssertionError on ANTI join</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testJoinToSemiJoinRuleOnAntiJoin
parameter_list|()
block|{
name|checkSemiJoinRuleOnAntiJoin
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_SEMI_JOIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4621">[CALCITE-4621]    * SemiJoinRule throws AssertionError on ANTI join</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectToSemiJoinRuleOnAntiJoin
parameter_list|()
block|{
name|checkSemiJoinRuleOnAntiJoin
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkSemiJoinRuleOnAntiJoin
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|distinct
argument_list|()
operator|.
name|antiJoin
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|"DNAME"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushJoinCondDownToProject
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, e.deptno from sales.dept d, sales.emp e\n"
operator|+
literal|" where d.deptno + 10 = e.deptno * 2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|,
name|CoreRules
operator|.
name|JOIN_PUSH_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortJoinTranspose1
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e left join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"order by sal limit 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortJoinTranspose2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"order by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortJoinTranspose3
parameter_list|()
block|{
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e left join (\n"
operator|+
literal|"  select * from sales.dept) d on e.deptno = d.deptno\n"
operator|+
literal|"order by sal, name limit 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-931">[CALCITE-931]    * Wrong collation trait in SortJoinTransposeRule for right joins</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSortJoinTranspose4
parameter_list|()
block|{
comment|// Create a customized test with RelCollation trait in the test cluster.
name|Tester
name|tester
init|=
operator|new
name|TesterImpl
argument_list|(
name|getDiffRepos
argument_list|()
argument_list|)
operator|.
name|withPlannerFactory
argument_list|(
name|context
lambda|->
operator|new
name|MockRelOptPlanner
argument_list|(
name|Contexts
operator|.
name|empty
argument_list|()
argument_list|)
block|{
block_content|@Override public List<RelTraitDef> getRelTraitDefs(
argument_list|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelTraitSet
name|emptyTraitSet
parameter_list|()
block|{
return|return
name|RelTraitSet
operator|.
name|createEmpty
argument_list|()
operator|.
name|plus
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
operator|.
name|getDefault
argument_list|()
argument_list|)
return|;
block|}
block|}
end_function

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"order by name"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTester
argument_list|(
name|t
lambda|->
name|tester
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1498">[CALCITE-1498]    * Avoid LIMIT with trivial ORDER BY being pushed through JOIN endlessly</a>. */
end_comment

begin_function
unit|@
name|Test
name|void
name|testSortJoinTranspose5
parameter_list|()
block|{
comment|// SortJoinTransposeRule should not be fired again.
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e right join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"limit 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1507">[CALCITE-1507]    * OFFSET cannot be pushed through a JOIN if the non-preserved side of outer    * join is not count-preserving</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSortJoinTranspose6
parameter_list|()
block|{
comment|// This one can be pushed down even if it has an OFFSET, since the dept
comment|// table is count-preserving against the join condition.
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, empno from sales.dept d\n"
operator|+
literal|"right join sales.emp e using (deptno) limit 10 offset 2"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1507">[CALCITE-1507]    * OFFSET cannot be pushed through a JOIN if the non-preserved side of outer    * join is not count-preserving</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSortJoinTranspose7
parameter_list|()
block|{
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno, empno from sales.dept d\n"
operator|+
literal|"left join sales.emp e using (deptno) order by d.deptno offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortProjectTranspose1
parameter_list|()
block|{
comment|// This one can be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as integer) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortProjectTranspose2
parameter_list|()
block|{
comment|// This one can be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as double) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortProjectTranspose3
parameter_list|()
block|{
comment|// This one cannot be pushed down
specifier|final
name|String
name|sql
init|=
literal|"select d.deptno from sales.dept d\n"
operator|+
literal|"order by cast(d.deptno as varchar(10)) offset 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1023">[CALCITE-1023]    * Planner rule that removes Aggregate keys that are constant</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateConstantKeyRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno, sal"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_ANY_PULL_UP_CONSTANTS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link AggregateProjectPullUpConstantsRule} where reduction is not    * possible because "deptno" is the only key. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateConstantKeyRule2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select count(*) as c\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno = 10\n"
operator|+
literal|"group by deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_ANY_PULL_UP_CONSTANTS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link AggregateProjectPullUpConstantsRule} where both keys are    * constants but only one can be removed. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateConstantKeyRule3
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select job\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where sal is null and job = 'Clerk'\n"
operator|+
literal|"group by sal, job\n"
operator|+
literal|"having count(*)> 3"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_ANY_PULL_UP_CONSTANTS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests {@link AggregateProjectPullUpConstantsRule} where    * there are group keys of type    * {@link org.apache.calcite.sql.fun.SqlAbstractTimeFunction}    * that can not be removed. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAggregateDynamicFunction
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select hiredate\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where sal is null and hiredate = current_timestamp\n"
operator|+
literal|"group by sal, hiredate\n"
operator|+
literal|"having count(*)> 3"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_ANY_PULL_UP_CONSTANTS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceExpressionsNot
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from (values (false),(true)) as q (col1) where not(col1)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|Sql
name|checkSubQuery
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
return|return
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SUB_QUERY_TO_CORRELATE
argument_list|,
name|CoreRules
operator|.
name|FILTER_SUB_QUERY_TO_CORRELATE
argument_list|,
name|CoreRules
operator|.
name|JOIN_SUB_QUERY_TO_CORRELATE
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Tests expanding a sub-query, specifically an uncorrelated scalar    * sub-query in a project (SELECT clause). */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testExpandProjectScalar
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectNotInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal,\n"
operator|+
literal|" empno NOT IN (\n"
operator|+
literal|" select deptno from dept\n"
operator|+
literal|"   where emp.job=dept.name)\n"
operator|+
literal|" from emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1493">[CALCITE-1493]    * Wrong plan for NOT IN correlated queries</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testWhereNotInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal from emp\n"
operator|+
literal|"where empno NOT IN (\n"
operator|+
literal|"  select deptno from dept\n"
operator|+
literal|"  where emp.job = dept.name)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testWhereNotInCorrelated2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.empno NOT IN\n"
operator|+
literal|"   (select empno from (select ename, empno, sal as r from emp) e2\n"
operator|+
literal|"    where r> 2 and e1.ename= e2.ename)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testAll
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.empno> ALL (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSome
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.empno> SOME (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for testing type created by SubQueryRemoveRule: an    * ANY sub-query is non-nullable therefore plan should have cast. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAnyInProjectNonNullable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name, deptno> ANY (\n"
operator|+
literal|"  select deptno from emp)\n"
operator|+
literal|"from dept"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for testing type created by SubQueryRemoveRule; an    * ANY sub-query is nullable therefore plan should not have cast. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testAnyInProjectNullable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno, name = ANY (\n"
operator|+
literal|"  select mgr from emp)\n"
operator|+
literal|"from dept"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSelectAnyCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno> ANY (\n"
operator|+
literal|"  select deptno from dept where emp.job = dept.name)\n"
operator|+
literal|"from emp\n"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testWhereAnyCorrelatedInSelect
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp where empno> ANY (\n"
operator|+
literal|"  select deptno from dept where emp.job = dept.name)\n"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSomeWithEquality
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.deptno = SOME (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSomeWithEquality2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.ename= SOME (select name from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSomeWithNotEquality
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1\n"
operator|+
literal|"  where e1.deptno<> SOME (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1546">[CALCITE-1546]    * Sub-queries connected by OR</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testWhereOrSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp\n"
operator|+
literal|"where sal = 4\n"
operator|+
literal|"or empno NOT IN (select deptno from dept)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandProjectIn
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  deptno in (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandProjectInNullable
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"with e2 as (\n"
operator|+
literal|"  select empno, case when true then deptno else null end as deptno\n"
operator|+
literal|"  from sales.emp)\n"
operator|+
literal|"select empno,\n"
operator|+
literal|"  deptno in (select deptno from e2 where empno< 20) as d\n"
operator|+
literal|"from e2"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandProjectInComposite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno, (empno, deptno) in (\n"
operator|+
literal|"    select empno, deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandProjectExists
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno,\n"
operator|+
literal|"  exists (select deptno from sales.emp where empno< 20) as d\n"
operator|+
literal|"from sales.emp"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandFilterScalar
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"< (select deptno from sales.emp where empno> 100)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandFilterIn
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where deptno in (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandFilterInComposite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where (empno, deptno) in (\n"
operator|+
literal|"  select empno, deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** An IN filter that requires full 3-value logic (true, false, unknown). */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testExpandFilterIn3Value
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where empno\n"
operator|+
literal|"< case deptno in (select case when true then deptno else null end\n"
operator|+
literal|"                   from sales.emp where empno< 20)\n"
operator|+
literal|"   when true then 10\n"
operator|+
literal|"   when false then 20\n"
operator|+
literal|"   else 30\n"
operator|+
literal|"   end"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** An EXISTS filter that can be converted into true/false. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testExpandFilterExists
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"or emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** An EXISTS filter that can be converted into a semi-join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testExpandFilterExistsSimple
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** An EXISTS filter that can be converted into a semi-join. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testExpandFilterExistsSimpleAnd
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where exists (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"and emp.sal< 100"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandJoinScalar
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on (select deptno from sales.emp where empno< 20)\n"
operator|+
literal|"< (select deptno from sales.emp where empno> 100)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3121">[CALCITE-3121]    * VolcanoPlanner hangs due to sub-query with dynamic star</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSubQueryWithDynamicStarHang
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select n.n_regionkey from (select * from "
operator|+
literal|"(select * from sales.customer) t) n where n.n_nationkey>1"
decl_stmt|;
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|Tester
name|dynamicTester
init|=
name|createDynamicTester
argument_list|()
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withClusterFactory
argument_list|(
name|relOptCluster
lambda|->
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|relOptCluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|dynamicTester
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|PushProjector
operator|.
name|ExprCondition
name|exprCondition
init|=
name|expr
lambda|->
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
return|return
literal|"item"
operator|.
name|equals
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
decl_stmt|;
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|CoreRules
operator|.
name|FILTER_PROJECT_TRANSPOSE
argument_list|,
name|CoreRules
operator|.
name|FILTER_MERGE
argument_list|,
name|CoreRules
operator|.
name|PROJECT_MERGE
argument_list|,
name|ProjectFilterTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|Filter
operator|.
name|class
argument_list|)
operator|.
name|withPreserveExprCondition
argument_list|(
name|exprCondition
argument_list|)
operator|.
name|toRule
argument_list|()
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_LIMIT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_TABLE_SCAN_RULE
argument_list|)
decl_stmt|;
name|Program
name|program
init|=
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
decl_stmt|;
name|RelTraitSet
name|toTraits
init|=
name|root
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSet
argument_list|()
operator|.
name|replace
argument_list|(
literal|0
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|relAfter
init|=
name|program
operator|.
name|run
argument_list|(
name|planner
argument_list|,
name|root
operator|.
name|rel
argument_list|,
name|toTraits
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3188">[CALCITE-3188]    * IndexOutOfBoundsException in ProjectFilterTransposeRule when executing SELECT COUNT(*)</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectFilterTransposeRuleOnEmptyRowType
parameter_list|()
block|{
comment|// build a rel equivalent to sql:
comment|// select `empty` from emp
comment|// where emp.deptno = 20
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_FILTER_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testFlattenUncorrelatedCallBelowEquals
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1 where exists ("
operator|+
literal|"select * from emp e2 where e1.deptno = (e2.deptno+30))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|FilterFlattenCorrelatedConditionRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testCallOverCorrelationVariableIsNotFlattened
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1 where exists ("
operator|+
literal|"select * from emp e2 where (e1.deptno+30) = e2.deptno)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|FilterFlattenCorrelatedConditionRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testFlattenUncorrelatedTwoLevelCallBelowEqualsSucceeds
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1 where exists ("
operator|+
literal|"select * from emp e2 where e1.deptno = (2 * e2.deptno+30))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|FilterFlattenCorrelatedConditionRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testUncorrelatedCallBelowNonComparisonOpIsNotFlattened
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1 where exists ("
operator|+
literal|"select * from emp e2 where (e1.deptno + (e2.deptno+30))> 0)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|FilterFlattenCorrelatedConditionRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testUncorrelatedCallInConjunctionIsFlattenedOnlyIfSiblingOfCorrelation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from emp e1 where exists ("
operator|+
literal|"select * from emp e2 where (e2.empno+50)< 20 and e1.deptno>= (30+e2.deptno))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withDecorrelation
argument_list|(
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|FilterFlattenCorrelatedConditionRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Disabled
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
name|void
name|testExpandJoinIn
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on emp.deptno in (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Disabled
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
name|void
name|testExpandJoinInComposite
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on (emp.empno, dept.deptno) in (\n"
operator|+
literal|"  select empno, deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandJoinExists
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp left join sales.dept\n"
operator|+
literal|"on exists (select deptno from sales.emp where empno< 20)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDecorrelateExists
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp\n"
operator|+
literal|"where EXISTS (\n"
operator|+
literal|"  select * from emp e where emp.deptno = e.deptno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1511">[CALCITE-1511]    * AssertionError while decorrelating query with two EXISTS    * sub-queries</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testDecorrelateTwoExists
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp\n"
operator|+
literal|"where EXISTS (\n"
operator|+
literal|"  select * from emp e where emp.deptno = e.deptno)\n"
operator|+
literal|"AND NOT EXISTS (\n"
operator|+
literal|"  select * from emp ee where ee.job = emp.job AND ee.sal=34)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2028">[CALCITE-2028]    * Un-correlated IN sub-query should be converted into a Join,    * rather than a Correlate without correlation variables</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testDecorrelateUncorrelatedInAndCorrelatedExists
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp\n"
operator|+
literal|"WHERE job in (\n"
operator|+
literal|"  select job from emp ee where ee.sal=34)"
operator|+
literal|"AND EXISTS (\n"
operator|+
literal|"  select * from emp e where emp.deptno = e.deptno)\n"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1537">[CALCITE-1537]    * Unnecessary project expression in multi-sub-query plan</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testDecorrelateTwoIn
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal\n"
operator|+
literal|"from sales.emp\n"
operator|+
literal|"where empno IN (\n"
operator|+
literal|"  select deptno from dept where emp.job = dept.name)\n"
operator|+
literal|"AND empno IN (\n"
operator|+
literal|"  select empno from emp e where emp.ename = e.ename)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1045">[CALCITE-1045]    * Decorrelate sub-queries in Project and Join</a>, with the added    * complication that there are two sub-queries. */
end_comment

begin_function
annotation|@
name|Disabled
argument_list|(
literal|"[CALCITE-1045]"
argument_list|)
annotation|@
name|Test
name|void
name|testDecorrelateTwoScalar
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select deptno,\n"
operator|+
literal|"  (select min(1) from emp where empno> d.deptno) as i0,\n"
operator|+
literal|"  (select min(0) from emp\n"
operator|+
literal|"    where deptno = d.deptno and ename = 'SMITH') as i1\n"
operator|+
literal|"from dept as d"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testWhereInJoinCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno from emp as e\n"
operator|+
literal|"join dept as d using (deptno)\n"
operator|+
literal|"where e.sal in (\n"
operator|+
literal|"  select e2.sal from emp as e2 where e2.deptno> e.deptno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-1494">[CALCITE-1494]    * Inefficient plan for correlated sub-queries</a>. In "planAfter", there    * must be only one scan each of emp and dept. We don't need a separate    * value-generator for emp.job. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testWhereInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sal from emp where empno IN (\n"
operator|+
literal|"  select deptno from dept where emp.job = dept.name)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testWhereExpressionInCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from (\n"
operator|+
literal|"  select ename, deptno, sal + 1 as salPlus from emp) as e\n"
operator|+
literal|"where deptno in (\n"
operator|+
literal|"  select deptno from emp where sal + 1 = e.salPlus)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testWhereExpressionInCorrelated2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select name from (\n"
operator|+
literal|"  select name, deptno, deptno - 10 as deptnoMinus from dept) as d\n"
operator|+
literal|"where deptno in (\n"
operator|+
literal|"  select deptno from emp where sal + 1 = d.deptnoMinus)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExpandWhereComparisonCorrelated
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select empno\n"
operator|+
literal|"from sales.emp as e\n"
operator|+
literal|"where sal = (\n"
operator|+
literal|"  select max(sal) from sales.emp e2 where e2.empno = e.empno)"
decl_stmt|;
name|checkSubQuery
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testCustomColumnResolvingInNonCorrelatedSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 in (\n"
operator|+
literal|"  select f1.c0 from struct.t t2)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SUB_QUERY_TO_CORRELATE
argument_list|,
name|CoreRules
operator|.
name|FILTER_SUB_QUERY_TO_CORRELATE
argument_list|,
name|CoreRules
operator|.
name|JOIN_SUB_QUERY_TO_CORRELATE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testCustomColumnResolvingInCorrelatedSubQuery
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 = (\n"
operator|+
literal|"  select max(f1.c0) from struct.t t2 where t1.k0 = t2.k0)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SUB_QUERY_TO_CORRELATE
argument_list|,
name|CoreRules
operator|.
name|FILTER_SUB_QUERY_TO_CORRELATE
argument_list|,
name|CoreRules
operator|.
name|JOIN_SUB_QUERY_TO_CORRELATE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testCustomColumnResolvingInCorrelatedSubQuery2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from struct.t t1\n"
operator|+
literal|"where c0 in (\n"
operator|+
literal|"  select f1.c0 from struct.t t2 where t1.c2 = t2.c2)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|expand
argument_list|(
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_SUB_QUERY_TO_CORRELATE
argument_list|,
name|CoreRules
operator|.
name|FILTER_SUB_QUERY_TO_CORRELATE
argument_list|,
name|CoreRules
operator|.
name|JOIN_SUB_QUERY_TO_CORRELATE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-2744">[CALCITE-2744]    * RelDecorrelator use wrong output map for LogicalAggregate decorrelate</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testDecorrelateAggWithConstantGroupKey
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT * FROM emp A where sal in\n"
operator|+
literal|"(SELECT max(sal) FROM emp B where A.mgr = B.empno group by deptno, 'abc')"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|()
comment|// empty program
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for CALCITE-2744 for aggregate decorrelate with multi-param agg call    * but without group key. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testDecorrelateAggWithMultiParamsAggCall
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT * FROM (SELECT MYAGG(sal, 1) AS c FROM emp) as m,\n"
operator|+
literal|" LATERAL TABLE(ramp(m.c)) AS T(s)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|()
comment|// empty program
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Same as {@link #testDecorrelateAggWithMultiParamsAggCall}    * but with a constant group key. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testDecorrelateAggWithMultiParamsAggCall2
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT * FROM "
operator|+
literal|"(SELECT MYAGG(sal, 1) AS c FROM emp group by empno, 'abc') as m,\n"
operator|+
literal|" LATERAL TABLE(ramp(m.c)) AS T(s)"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withLateDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withRule
argument_list|()
comment|// empty program
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-434">[CALCITE-434]    * Converting predicates on date dimension columns into date ranges</a>,    * specifically a rule that converts {@code EXTRACT(YEAR FROM ...) = constant}    * to a range. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testExtractYearToRange
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from sales.emp_b as e\n"
operator|+
literal|"where extract(year from birthdate) = 2014"
decl_stmt|;
specifier|final
name|Context
name|context
init|=
name|Contexts
operator|.
name|of
argument_list|(
name|CalciteConnectionConfig
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|DateRangeRules
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|withContext
argument_list|(
name|c
lambda|->
name|Contexts
operator|.
name|of
argument_list|(
name|CalciteConnectionConfig
operator|.
name|DEFAULT
argument_list|,
name|c
argument_list|)
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExtractYearMonthToRange
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from sales.emp_b as e\n"
operator|+
literal|"where extract(year from birthdate) = 2014"
operator|+
literal|"and extract(month from birthdate) = 4"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|DateRangeRules
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|withContext
argument_list|(
name|c
lambda|->
name|Contexts
operator|.
name|of
argument_list|(
name|CalciteConnectionConfig
operator|.
name|DEFAULT
argument_list|,
name|c
argument_list|)
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testFilterRemoveIsNotDistinctFromRule
parameter_list|()
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|20
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_EXPAND_IS_NOT_DISTINCT_FROM
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Creates an environment for testing spatial queries. */
end_comment

begin_function
specifier|private
name|Sql
name|spatial
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
specifier|final
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|SpatialRules
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withCatalogReaderFactory
argument_list|(
parameter_list|(
name|typeFactory
parameter_list|,
name|caseSensitive
parameter_list|)
lambda|->
operator|new
name|MockCatalogReaderExtended
argument_list|(
name|typeFactory
argument_list|,
name|caseSensitive
argument_list|)
operator|.
name|init
argument_list|()
argument_list|)
operator|.
name|withConformance
argument_list|(
name|SqlConformanceEnum
operator|.
name|LENIENT
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Tests that a call to {@code ST_DWithin}    * is rewritten with an additional range predicate. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSpatialDWithinToHilbert
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from GEO.Restaurants as r\n"
operator|+
literal|"where ST_DWithin(ST_Point(10.0, 20.0),\n"
operator|+
literal|"                 ST_Point(r.longitude, r.latitude), 10)"
decl_stmt|;
name|spatial
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tests that a call to {@code ST_DWithin}    * is rewritten with an additional range predicate. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSpatialDWithinToHilbertZero
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from GEO.Restaurants as r\n"
operator|+
literal|"where ST_DWithin(ST_Point(10.0, 20.0),\n"
operator|+
literal|"                 ST_Point(r.longitude, r.latitude), 0)"
decl_stmt|;
name|spatial
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSpatialDWithinToHilbertNegative
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from GEO.Restaurants as r\n"
operator|+
literal|"where ST_DWithin(ST_Point(10.0, 20.0),\n"
operator|+
literal|"                 ST_Point(r.longitude, r.latitude), -2)"
decl_stmt|;
name|spatial
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** As {@link #testSpatialDWithinToHilbert()} but arguments reversed. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSpatialDWithinReversed
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from GEO.Restaurants as r\n"
operator|+
literal|"where ST_DWithin(ST_Point(r.longitude, r.latitude),\n"
operator|+
literal|"                 ST_Point(10.0, 20.0), 6)"
decl_stmt|;
name|spatial
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Points within a given distance of a line. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSpatialDWithinLine
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from GEO.Restaurants as r\n"
operator|+
literal|"where ST_DWithin(\n"
operator|+
literal|"  ST_MakeLine(ST_Point(8.0, 20.0), ST_Point(12.0, 20.0)),\n"
operator|+
literal|"  ST_Point(r.longitude, r.latitude), 4)"
decl_stmt|;
name|spatial
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Points near a constant point, using ST_Contains and ST_Buffer. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSpatialContainsPoint
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from GEO.Restaurants as r\n"
operator|+
literal|"where ST_Contains(\n"
operator|+
literal|"  ST_Buffer(ST_Point(10.0, 20.0), 6),\n"
operator|+
literal|"  ST_Point(r.longitude, r.latitude))"
decl_stmt|;
name|spatial
argument_list|(
name|sql
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Constant reduction on geo-spatial expression. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testSpatialReduce
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select\n"
operator|+
literal|"  ST_Buffer(ST_Point(0.0, 1.0), 2) as b\n"
operator|+
literal|"from GEO.Restaurants as r"
decl_stmt|;
name|spatial
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testOversimplifiedCaseStatement
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select * from emp "
operator|+
literal|"where MGR> 0 and "
operator|+
literal|"case when MGR> 0 then deptno / MGR else null end> 1"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for   *<a href="https://issues.apache.org/jira/browse/CALCITE-2726">[CALCITE-2726]   * ReduceExpressionRule may oversimplify filter conditions containing nulls</a>.   */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testNoOversimplificationBelowIsNull
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from emp\n"
operator|+
literal|"where ( (empno=1 and mgr=1) or (empno=null and mgr=1) ) is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testExchangeRemoveConstantKeysRule
parameter_list|()
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|filter
argument_list|(
name|b
operator|.
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|"EMPNO"
argument_list|)
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|10
argument_list|)
argument_list|)
argument_list|)
operator|.
name|exchange
argument_list|(
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|sortExchange
argument_list|(
name|RelDistributions
operator|.
name|hash
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|RelFieldCollation
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|EXCHANGE_REMOVE_CONSTANT_KEYS
argument_list|,
name|CoreRules
operator|.
name|SORT_EXCHANGE_REMOVE_CONSTANT_KEYS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceAverageWithNoReduceSum
parameter_list|()
block|{
specifier|final
name|RelOptRule
name|rule
init|=
name|AggregateReduceFunctionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
operator|.
name|withFunctionsToReduce
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|)
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, max(name), avg(deptno), min(name)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNoReduceAverage
parameter_list|()
block|{
specifier|final
name|RelOptRule
name|rule
init|=
name|AggregateReduceFunctionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
operator|.
name|withFunctionsToReduce
argument_list|(
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SqlKind
operator|.
name|class
argument_list|)
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select name, max(name), avg(deptno), min(name)"
operator|+
literal|" from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testNoReduceSum
parameter_list|()
block|{
specifier|final
name|RelOptRule
name|rule
init|=
name|AggregateReduceFunctionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
operator|.
name|withFunctionsToReduce
argument_list|(
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SqlKind
operator|.
name|class
argument_list|)
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select name, sum(deptno)"
operator|+
literal|" from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceAverageAndVarWithNoReduceStddev
parameter_list|()
block|{
comment|// configure rule to reduce AVG and VAR_POP functions
comment|// other functions like SUM, STDDEV won't be reduced
specifier|final
name|RelOptRule
name|rule
init|=
name|AggregateReduceFunctionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
operator|.
name|withFunctionsToReduce
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|,
name|SqlKind
operator|.
name|VAR_POP
argument_list|)
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),"
operator|+
literal|" var_pop(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceAverageAndSumWithNoReduceStddevAndVar
parameter_list|()
block|{
comment|// configure rule to reduce AVG and SUM functions
comment|// other functions like VAR_POP, STDDEV_POP won't be reduced
specifier|final
name|RelOptRule
name|rule
init|=
name|AggregateReduceFunctionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
operator|.
name|withFunctionsToReduce
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|,
name|SqlKind
operator|.
name|SUM
argument_list|)
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),"
operator|+
literal|" var_pop(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testReduceAllAggregateFunctions
parameter_list|()
block|{
comment|// configure rule to reduce all used functions
specifier|final
name|RelOptRule
name|rule
init|=
name|AggregateReduceFunctionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|)
operator|.
name|withFunctionsToReduce
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|,
name|SqlKind
operator|.
name|SUM
argument_list|,
name|SqlKind
operator|.
name|STDDEV_POP
argument_list|,
name|SqlKind
operator|.
name|STDDEV_SAMP
argument_list|,
name|SqlKind
operator|.
name|VAR_POP
argument_list|,
name|SqlKind
operator|.
name|VAR_SAMP
argument_list|)
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select name, stddev_pop(deptno), avg(deptno),"
operator|+
literal|" stddev_samp(deptno), var_pop(deptno), var_samp(deptno)\n"
operator|+
literal|"from sales.dept group by name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|rule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for   *<a href="https://issues.apache.org/jira/browse/CALCITE-2803">[CALCITE-2803]   * Identify expanded IS NOT DISTINCT FROM expression when pushing project past join</a>.   */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testPushProjectWithIsNotDistinctFromPastJoin
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select e.sal + b.comm from emp e inner join bonus b\n"
operator|+
literal|"on (e.ename || e.job) IS NOT DISTINCT FROM (b.ename || b.job) and e.deptno = 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withProperty
argument_list|(
name|Hook
operator|.
name|REL_BUILDER_SIMPLIFY
argument_list|,
literal|false
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testDynamicStarWithUnion
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"(select n_nationkey from SALES.CUSTOMER) union all\n"
operator|+
literal|"(select n_name from CUSTOMER_MODIFIABLEVIEW)"
decl_stmt|;
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|Tester
name|dynamicTester
init|=
name|createDynamicTester
argument_list|()
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withClusterFactory
argument_list|(
name|relOptCluster
lambda|->
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|relOptCluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|dynamicTester
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_TABLE_SCAN_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_UNION_RULE
argument_list|)
decl_stmt|;
name|Program
name|program
init|=
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
decl_stmt|;
name|RelTraitSet
name|toTraits
init|=
name|root
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSet
argument_list|()
operator|.
name|replace
argument_list|(
literal|0
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|relAfter
init|=
name|program
operator|.
name|run
argument_list|(
name|planner
argument_list|,
name|root
operator|.
name|rel
argument_list|,
name|toTraits
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testFilterAndProjectWithMultiJoin
parameter_list|()
block|{
specifier|final
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleCollection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|MyFilterRule
operator|.
name|INSTANCE
argument_list|,
name|MyProjectRule
operator|.
name|INSTANCE
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|FilterMultiJoinMergeRule
name|filterMultiJoinMergeRule
init|=
name|FilterMultiJoinMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|MyFilter
operator|.
name|class
argument_list|,
name|MultiJoin
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|ProjectMultiJoinMergeRule
name|projectMultiJoinMergeRule
init|=
name|ProjectMultiJoinMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|MyProject
operator|.
name|class
argument_list|,
name|MultiJoin
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleCollection
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|CoreRules
operator|.
name|JOIN_TO_MULTI_JOIN
argument_list|,
name|filterMultiJoinMergeRule
argument_list|,
name|projectMultiJoinMergeRule
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|sql
argument_list|(
literal|"select * from emp e1 left outer join dept d on e1.deptno = d.deptno where d.deptno> 3"
argument_list|)
operator|.
name|withPre
argument_list|(
name|preProgram
argument_list|)
operator|.
name|with
argument_list|(
name|program
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3151">[CALCITE-3151]    * RexCall's Monotonicity is not considered in determining a Calc's    * collation</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMonotonicityUDF
parameter_list|()
block|{
specifier|final
name|SqlFunction
name|monotonicityFun
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"MONOFUN"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|BIGINT
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NILADIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|USER_DEFINED_FUNCTION
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlMonotonicity
name|getMonotonicity
parameter_list|(
name|SqlOperatorBinding
name|call
parameter_list|)
block|{
return|return
name|SqlMonotonicity
operator|.
name|INCREASING
return|;
block|}
block|}
decl_stmt|;
comment|// Build a tree equivalent to the SQL
comment|// SELECT sal, MONOFUN() AS n FROM emp
specifier|final
name|RelBuilder
name|builder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|root
init|=
name|builder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|builder
operator|.
name|field
argument_list|(
literal|"SAL"
argument_list|)
argument_list|,
name|builder
operator|.
name|alias
argument_list|(
name|builder
operator|.
name|call
argument_list|(
name|monotonicityFun
argument_list|)
argument_list|,
literal|"M"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepProgram
name|preProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|prePlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|preProgram
argument_list|)
decl_stmt|;
name|prePlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|relBefore
init|=
name|prePlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|RelCollation
name|collationBefore
init|=
name|relBefore
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|HepProgram
name|hepProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_CALC
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|hepProgram
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|relAfter
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|RelCollation
name|collationAfter
init|=
name|relAfter
operator|.
name|getTraitSet
argument_list|()
operator|.
name|getTrait
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|collationBefore
argument_list|,
name|collationAfter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testPushFilterWithIsNotDistinctFromPastJoin
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"SELECT * FROM "
operator|+
literal|"emp t1 INNER JOIN "
operator|+
literal|"emp t2 "
operator|+
literal|"ON t1.deptno = t2.deptno "
operator|+
literal|"WHERE t1.ename is not distinct from t2.ename"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_INTO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3997">[CALCITE-3997]    * Logical rules applied on physical operator but failed handle    * traits</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMergeJoinCollation
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select r.ename, s.sal from\n"
operator|+
literal|"sales.emp r join sales.bonus s\n"
operator|+
literal|"on r.ename=s.ename where r.sal+1=s.sal"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|,
literal|false
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// TODO: obsolete this method;
end_comment

begin_comment
comment|// move the code into a new method Sql.withTopDownPlanner() so that you can
end_comment

begin_comment
comment|// write sql.withTopDownPlanner();
end_comment

begin_comment
comment|// withTopDownPlanner should call Sql.withTester and should be documented.
end_comment

begin_function
name|Sql
name|sql
parameter_list|(
name|String
name|sql
parameter_list|,
name|boolean
name|topDown
parameter_list|)
block|{
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|()
decl_stmt|;
name|planner
operator|.
name|setTopDownOpt
argument_list|(
name|topDown
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|RelOptUtil
operator|.
name|registerDefaultRules
argument_list|(
name|planner
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Tester
name|tester
init|=
name|createTester
argument_list|()
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withClusterFactory
argument_list|(
name|cluster
lambda|->
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|Sql
argument_list|(
name|tester
argument_list|,
name|sql
argument_list|,
literal|null
argument_list|,
name|planner
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Custom implementation of {@link Filter} for use    * in test case to verify that {@link FilterMultiJoinMergeRule}    * can be created with any {@link Filter} and not limited to    * {@link org.apache.calcite.rel.logical.LogicalFilter}.    */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|MyFilter
extends|extends
name|Filter
block|{
name|MyFilter
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelTraitSet
name|traitSet
parameter_list|,
name|RelNode
name|child
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|child
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
specifier|public
name|MyFilter
name|copy
parameter_list|(
name|RelTraitSet
name|traitSet
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
return|return
operator|new
name|MyFilter
argument_list|(
name|getCluster
argument_list|()
argument_list|,
name|traitSet
argument_list|,
name|input
argument_list|,
name|condition
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Rule to transform {@link LogicalFilter} into    * custom MyFilter.    */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|MyFilterRule
extends|extends
name|RelRule
argument_list|<
name|MyFilterRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
specifier|final
name|MyFilterRule
name|INSTANCE
init|=
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b
lambda|->
name|b
operator|.
name|operand
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|protected
name|MyFilterRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|LogicalFilter
name|logicalFilter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|logicalFilter
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|MyFilter
name|myFilter
init|=
operator|new
name|MyFilter
argument_list|(
name|input
operator|.
name|getCluster
argument_list|()
argument_list|,
name|input
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|input
argument_list|,
name|logicalFilter
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|myFilter
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|MyFilterRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|MyFilterRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * Custom implementation of {@link Project} for use    * in test case to verify that {@link ProjectMultiJoinMergeRule}    * can be created with any {@link Project} and not limited to    * {@link org.apache.calcite.rel.logical.LogicalProject}.    */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|MyProject
extends|extends
name|Project
block|{
name|MyProject
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelTraitSet
name|traitSet
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|projects
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|super
argument_list|(
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|input
argument_list|,
name|projects
argument_list|,
name|rowType
argument_list|)
expr_stmt|;
block|}
specifier|public
name|MyProject
name|copy
parameter_list|(
name|RelTraitSet
name|traitSet
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
operator|new
name|MyProject
argument_list|(
name|getCluster
argument_list|()
argument_list|,
name|traitSet
argument_list|,
name|input
argument_list|,
name|projects
argument_list|,
name|rowType
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Rule to transform {@link LogicalProject} into custom    * MyProject.    */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|MyProjectRule
extends|extends
name|RelRule
argument_list|<
name|MyProjectRule
operator|.
name|Config
argument_list|>
block|{
specifier|static
specifier|final
name|MyProjectRule
name|INSTANCE
init|=
name|Config
operator|.
name|EMPTY
operator|.
name|withOperandSupplier
argument_list|(
name|b
lambda|->
name|b
operator|.
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|protected
name|MyProjectRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|LogicalProject
name|logicalProject
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|logicalProject
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|MyProject
name|myProject
init|=
operator|new
name|MyProject
argument_list|(
name|input
operator|.
name|getCluster
argument_list|()
argument_list|,
name|input
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|input
argument_list|,
name|logicalProject
operator|.
name|getProjects
argument_list|()
argument_list|,
name|logicalProject
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|myProject
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
annotation|@
name|Override
specifier|default
name|MyProjectRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|MyProjectRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_function
annotation|@
name|Test
name|void
name|testSortJoinCopyInnerJoinOrderBy
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp join sales.dept on\n"
operator|+
literal|"sales.emp.deptno = sales.dept.deptno order by sal"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_COPY
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortJoinCopyInnerJoinOrderByLimit
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e join (\n"
operator|+
literal|"  select * from sales.dept d) d on e.deptno = d.deptno\n"
operator|+
literal|"order by sal limit 10"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_COPY
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortJoinCopyInnerJoinOrderByTwoFields
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.emp e join  sales.dept d on\n"
operator|+
literal|" e.deptno = d.deptno order by e.sal,d.name"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|SORT_PROJECT_TRANSPOSE
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_COPY
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortJoinCopySemiJoinOrderBy
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.dept d where d.deptno in\n"
operator|+
literal|" (select e.deptno from sales.emp e) order by d.deptno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_COPY
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortJoinCopySemiJoinOrderByLimitOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.dept d where d.deptno in\n"
operator|+
literal|" (select e.deptno from sales.emp e) order by d.deptno limit 10 offset 2"
decl_stmt|;
comment|// Do not copy the limit and offset
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_COPY
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSortJoinCopySemiJoinOrderByOffset
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select * from sales.dept d where d.deptno in"
operator|+
literal|" (select e.deptno from sales.emp e) order by d.deptno offset 2"
decl_stmt|;
comment|// Do not copy the offset
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withPreRule
argument_list|(
name|CoreRules
operator|.
name|PROJECT_TO_SEMI_JOIN
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|SORT_JOIN_COPY
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3296">[CALCITE-3296]    * Decorrelator gives empty result after decorrelating sort rel with    * null offset and fetch</a>.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testDecorrelationWithSort
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"SELECT e1.empno\n"
operator|+
literal|"FROM emp e1, dept d1 where e1.deptno = d1.deptno\n"
operator|+
literal|"and e1.deptno< 10 and d1.deptno< 15\n"
operator|+
literal|"and e1.sal> (select avg(sal) from emp e2 where e1.empno = e2.empno)\n"
operator|+
literal|"order by e1.empno"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|()
comment|// empty program
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3319">[CALCITE-3319]    * AssertionError for ReduceDecimalsRule</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testReduceDecimal
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select ename from emp where sal> cast (100.0 as decimal(4, 1))"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_TO_CALC
argument_list|,
name|CoreRules
operator|.
name|CALC_REDUCE_DECIMALS
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testEnumerableCalcRule
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select FNAME, LNAME from SALES.CUSTOMER where CONTACTNO> 10"
decl_stmt|;
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|RelDistributionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|Tester
name|dynamicTester
init|=
name|createDynamicTester
argument_list|()
operator|.
name|withDecorrelation
argument_list|(
literal|true
argument_list|)
operator|.
name|withClusterFactory
argument_list|(
name|relOptCluster
lambda|->
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|relOptCluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|dynamicTester
operator|.
name|convertSqlToRel
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|String
name|planBefore
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|root
operator|.
name|rel
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planBefore"
argument_list|,
literal|"${planBefore}"
argument_list|,
name|planBefore
argument_list|)
expr_stmt|;
name|RuleSet
name|ruleSet
init|=
name|RuleSets
operator|.
name|ofList
argument_list|(
name|CoreRules
operator|.
name|FILTER_TO_CALC
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_TABLE_SCAN_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_CALC_RULE
argument_list|)
decl_stmt|;
name|Program
name|program
init|=
name|Programs
operator|.
name|of
argument_list|(
name|ruleSet
argument_list|)
decl_stmt|;
name|RelTraitSet
name|toTraits
init|=
name|root
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSet
argument_list|()
operator|.
name|replace
argument_list|(
literal|0
argument_list|,
name|EnumerableConvention
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|RelNode
name|relAfter
init|=
name|program
operator|.
name|run
argument_list|(
name|planner
argument_list|,
name|root
operator|.
name|rel
argument_list|,
name|toTraits
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|planAfter
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|relAfter
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planAfter"
argument_list|,
literal|"${planAfter}"
argument_list|,
name|planAfter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-3404">[CALCITE-3404]    * Treat agg expressions that can ignore distinct constraint as    * distinct in AggregateExpandDistinctAggregatesRule when all the    * other agg expressions are distinct and have same arguments</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testMaxReuseDistinctAttrWithMixedOptionality
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(distinct deptno), count(distinct deptno), "
operator|+
literal|"max(deptno) from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testMinReuseDistinctAttrWithMixedOptionality
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(distinct deptno), count(distinct deptno), "
operator|+
literal|"min(deptno) from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testBitAndReuseDistinctAttrWithMixedOptionality
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(distinct deptno), count(distinct deptno), "
operator|+
literal|"bit_and(deptno) from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testBitOrReuseDistinctAttrWithMixedOptionality
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select sum(distinct deptno), count(distinct deptno), "
operator|+
literal|"bit_or(deptno) from emp"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinTransposeItem
parameter_list|()
block|{
name|ProjectJoinTransposeRule
name|projectJoinTransposeRule
init|=
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
operator|.
name|config
operator|.
name|withOperandFor
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|Join
operator|.
name|class
argument_list|)
operator|.
name|withPreserveExprCondition
argument_list|(
name|RelOptRulesTest
operator|::
name|skipItem
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"select t1.c_nationkey[0], t2.c_nationkey[0]\n"
operator|+
literal|"from sales.customer as t1\n"
operator|+
literal|"left outer join sales.customer as t2\n"
operator|+
literal|"on t1.c_nationkey[0] = t2.c_nationkey[0]"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTester
argument_list|(
name|t
lambda|->
name|createDynamicTester
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|projectJoinTransposeRule
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-4317">[CALCITE-4317]    * RelFieldTrimmer after trimming all the fields in an aggregate    * should not return a zero field Aggregate</a>. */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testProjectJoinTransposeRuleOnAggWithNoFieldsWithTrimmer
parameter_list|()
block|{
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|RelBuilder
operator|.
name|create
argument_list|(
name|RelBuilderTest
operator|.
name|config
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// Build a rel equivalent to sql:
comment|// SELECT name FROM (SELECT count(*) cnt_star, count(empno) cnt_en FROM sales.emp)
comment|// cross join sales.dept
comment|// limit 10
name|RelNode
name|left
init|=
name|relBuilder
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|right
init|=
name|relBuilder
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|project
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"DUMMY"
argument_list|)
argument_list|)
operator|.
name|aggregate
argument_list|(
name|relBuilder
operator|.
name|groupKey
argument_list|()
argument_list|,
name|relBuilder
operator|.
name|count
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|as
argument_list|(
literal|"DUMMY_COUNT"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|plan
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|left
argument_list|)
operator|.
name|push
argument_list|(
name|right
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|relBuilder
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|field
argument_list|(
literal|"DEPTNO"
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|String
name|planBeforeTrimming
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|plan
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planBeforeTrimming"
argument_list|,
literal|"${planBeforeTrimming}"
argument_list|,
name|planBeforeTrimming
argument_list|)
expr_stmt|;
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|RelDistributionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|Tester
name|tester
init|=
name|createDynamicTester
argument_list|()
operator|.
name|withTrim
argument_list|(
literal|true
argument_list|)
operator|.
name|withClusterFactory
argument_list|(
name|relOptCluster
lambda|->
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|relOptCluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|plan
operator|=
name|tester
operator|.
name|trimRelNode
argument_list|(
name|plan
argument_list|)
expr_stmt|;
specifier|final
name|String
name|planAfterTrimming
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|plan
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"planAfterTrimming"
argument_list|,
literal|"${planAfterTrimming}"
argument_list|,
name|planAfterTrimming
argument_list|)
expr_stmt|;
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|CoreRules
operator|.
name|PROJECT_JOIN_TRANSPOSE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|RelNode
name|output
init|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|String
name|finalPlan
init|=
name|NL
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|getDiffRepos
argument_list|()
operator|.
name|assertEquals
argument_list|(
literal|"finalPlan"
argument_list|,
literal|"${finalPlan}"
argument_list|,
name|finalPlan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSimplifyItemIsNotNull
parameter_list|()
block|{
specifier|final
name|String
name|sql
init|=
literal|"select *\n"
operator|+
literal|"from sales.customer as t1\n"
operator|+
literal|"where t1.c_nationkey[0] is not null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTester
argument_list|(
name|t
lambda|->
name|createDynamicTester
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testSimplifyItemIsNull
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select * from sales.customer as t1 where t1.c_nationkey[0] is null"
decl_stmt|;
name|sql
argument_list|(
name|sql
argument_list|)
operator|.
name|withTester
argument_list|(
name|t
lambda|->
name|createDynamicTester
argument_list|()
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|FILTER_REDUCE_EXPRESSIONS
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testJoinCommuteRuleWithAlwaysTrueConditionAllowed
parameter_list|()
block|{
name|checkJoinCommuteRuleWithAlwaysTrueConditionDisallowed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testJoinCommuteRuleWithAlwaysTrueConditionDisallowed
parameter_list|()
block|{
name|checkJoinCommuteRuleWithAlwaysTrueConditionDisallowed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkJoinCommuteRuleWithAlwaysTrueConditionDisallowed
parameter_list|(
name|boolean
name|allowAlwaysTrue
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|JoinCommuteRule
operator|.
name|Config
name|ruleConfig
init|=
name|JoinCommuteRule
operator|.
name|Config
operator|.
name|DEFAULT
decl_stmt|;
if|if
condition|(
operator|!
name|allowAlwaysTrue
condition|)
block|{
name|ruleConfig
operator|=
name|ruleConfig
operator|.
name|withAllowAlwaysTrueCondition
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ruleConfig
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|allowAlwaysTrue
condition|)
block|{
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testJoinAssociateRuleWithBottomAlwaysTrueConditionAllowed
parameter_list|()
block|{
name|checkJoinAssociateRuleWithBottomAlwaysTrueCondition
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testJoinAssociateRuleWithBottomAlwaysTrueConditionDisallowed
parameter_list|()
block|{
name|checkJoinAssociateRuleWithBottomAlwaysTrueCondition
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkJoinAssociateRuleWithBottomAlwaysTrueCondition
parameter_list|(
name|boolean
name|allowAlwaysTrue
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|bottomLeft
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|bottomRight
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|top
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"BONUS"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|bottomLeft
argument_list|)
operator|.
name|push
argument_list|(
name|bottomRight
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|push
argument_list|(
name|top
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"JOB"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"JOB"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
decl_stmt|;
name|JoinAssociateRule
operator|.
name|Config
name|ruleConfig
init|=
name|JoinAssociateRule
operator|.
name|Config
operator|.
name|DEFAULT
decl_stmt|;
if|if
condition|(
operator|!
name|allowAlwaysTrue
condition|)
block|{
name|ruleConfig
operator|=
name|ruleConfig
operator|.
name|withAllowAlwaysTrueCondition
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|TOP_DOWN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ruleConfig
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|allowAlwaysTrue
condition|)
block|{
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testJoinAssociateRuleWithTopAlwaysTrueConditionAllowed
parameter_list|()
block|{
name|checkJoinAssociateRuleWithTopAlwaysTrueCondition
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Test
name|void
name|testJoinAssociateRuleWithTopAlwaysTrueConditionDisallowed
parameter_list|()
block|{
name|checkJoinAssociateRuleWithTopAlwaysTrueCondition
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|checkJoinAssociateRuleWithTopAlwaysTrueCondition
parameter_list|(
name|boolean
name|allowAlwaysTrue
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|RelBuilder
argument_list|,
name|RelNode
argument_list|>
name|relFn
init|=
name|b
lambda|->
block|{
name|RelNode
name|bottomLeft
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"EMP"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|bottomRight
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"BONUS"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|RelNode
name|top
init|=
name|b
operator|.
name|scan
argument_list|(
literal|"DEPT"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|b
operator|.
name|push
argument_list|(
name|bottomLeft
argument_list|)
operator|.
name|push
argument_list|(
name|bottomRight
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|b
operator|.
name|literal
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|push
argument_list|(
name|top
argument_list|)
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|b
operator|.
name|equals
argument_list|(
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|,
name|b
operator|.
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|"DEPTNO"
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
decl_stmt|;
name|JoinAssociateRule
operator|.
name|Config
name|ruleConfig
init|=
name|JoinAssociateRule
operator|.
name|Config
operator|.
name|DEFAULT
decl_stmt|;
if|if
condition|(
operator|!
name|allowAlwaysTrue
condition|)
block|{
name|ruleConfig
operator|=
name|ruleConfig
operator|.
name|withAllowAlwaysTrueCondition
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|TOP_DOWN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ruleConfig
operator|.
name|toRule
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|program
argument_list|)
decl_stmt|;
if|if
condition|(
name|allowAlwaysTrue
condition|)
block|{
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|relFn
argument_list|(
name|relFn
argument_list|)
operator|.
name|with
argument_list|(
name|hepPlanner
argument_list|)
operator|.
name|checkUnchanged
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Test case for<a href="https://issues.apache.org/jira/browse/CALCITE-4652">[CALCITE-4652]    * AggregateExpandDistinctAggregatesRule must cast top aggregates to original type</a>.    *<p>    * Checks AggregateExpandDistinctAggregatesRule when return type of the SUM aggregate    * is changed (expanded) by define custom type factory.    */
end_comment

begin_function
annotation|@
name|Test
name|void
name|testDistinctCountWithExpandSumType
parameter_list|()
block|{
comment|// Define new type system to expand SUM return type.
name|RelDataTypeSystemImpl
name|typeSystem
init|=
operator|new
name|RelDataTypeSystemImpl
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RelDataType
name|deriveSumType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|argumentType
parameter_list|)
block|{
switch|switch
condition|(
name|argumentType
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|)
return|;
default|default:
return|return
name|super
operator|.
name|deriveSumType
argument_list|(
name|typeFactory
argument_list|,
name|argumentType
argument_list|)
return|;
block|}
block|}
block|}
decl_stmt|;
name|Supplier
argument_list|<
name|RelDataTypeFactory
argument_list|>
name|typeFactorySupplier
init|=
parameter_list|()
lambda|->
operator|new
name|SqlTypeFactoryImpl
argument_list|(
name|typeSystem
argument_list|)
decl_stmt|;
comment|// Expected plan:
comment|// LogicalProject(EXPR$0=[CAST($0):BIGINT NOT NULL], EXPR$1=[$1])
comment|//   LogicalAggregate(group=[{}], EXPR$0=[$SUM0($1)], EXPR$1=[COUNT($0)])
comment|//     LogicalAggregate(group=[{0}], EXPR$0=[COUNT()])
comment|//       LogicalProject(COMM=[$6])
comment|//         LogicalTableScan(table=[[CATALOG, SALES, EMP]])
comment|//
comment|// The top 'LogicalProject' must be added in case SUM type is expanded
comment|// because type of original expression 'COUNT(DISTINCT comm)' is BIGINT
comment|// and type of SUM (of BIGINT) is DECIMAL.
name|sql
argument_list|(
literal|"SELECT count(comm), COUNT(DISTINCT comm) FROM emp"
argument_list|)
operator|.
name|withTester
argument_list|(
name|t
lambda|->
name|t
operator|.
name|withTypeFactorySupplier
argument_list|(
name|typeFactorySupplier
argument_list|)
argument_list|)
operator|.
name|withRule
argument_list|(
name|CoreRules
operator|.
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
argument_list|)
operator|.
name|check
argument_list|()
expr_stmt|;
block|}
end_function

unit|}
end_unit

