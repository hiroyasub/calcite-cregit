begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|AvaticaConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|Meta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|SqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|remote
operator|.
name|LocalJsonService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|remote
operator|.
name|LocalService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|remote
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|server
operator|.
name|AvaticaJsonHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|server
operator|.
name|HttpServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|server
operator|.
name|Main
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|CalciteAssert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|JdbcFrontLinqBackTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|JdbcTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|AfterAll
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|BeforeAll
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|parallel
operator|.
name|Execution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|parallel
operator|.
name|ExecutionMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Blob
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Clob
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DriverManager
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|NClob
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|PreparedStatement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Ref
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|ResultSetMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|RowId
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|SQLXML
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Struct
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|notNullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|nullValue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|MatcherAssert
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|jupiter
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertThrows
import|;
end_import

begin_comment
comment|/**  * Test for Calcite's remote JDBC driver.  * Technically speaking, the test is thread safe, however Caclite/Avatica have thread-safety issues  * see https://issues.apache.org/jira/browse/CALCITE-2853.  */
end_comment

begin_class
annotation|@
name|Execution
argument_list|(
name|ExecutionMode
operator|.
name|SAME_THREAD
argument_list|)
specifier|public
class|class
name|CalciteRemoteDriverTest
block|{
specifier|public
specifier|static
specifier|final
name|String
name|LJS
init|=
name|Factory2
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|PrintWriter
name|out
init|=
name|CalciteSystemProperty
operator|.
name|DEBUG
operator|.
name|value
argument_list|()
condition|?
name|Util
operator|.
name|printWriter
argument_list|(
name|System
operator|.
name|out
argument_list|)
else|:
operator|new
name|PrintWriter
argument_list|(
operator|new
name|StringWriter
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CalciteAssert
operator|.
name|ConnectionFactory
name|REMOTE_CONNECTION_FACTORY
init|=
operator|new
name|CalciteAssert
operator|.
name|ConnectionFactory
argument_list|()
block|{
specifier|public
name|Connection
name|createConnection
parameter_list|()
throws|throws
name|SQLException
block|{
return|return
name|getRemoteConnection
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Connection
argument_list|,
name|ResultSet
argument_list|>
name|GET_SCHEMAS
init|=
name|connection
lambda|->
block|{
try|try
block|{
return|return
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSchemas
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Connection
argument_list|,
name|ResultSet
argument_list|>
name|GET_CATALOGS
init|=
name|connection
lambda|->
block|{
try|try
block|{
return|return
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getCatalogs
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Connection
argument_list|,
name|ResultSet
argument_list|>
name|GET_COLUMNS
init|=
name|connection
lambda|->
block|{
try|try
block|{
return|return
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getColumns
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Connection
argument_list|,
name|ResultSet
argument_list|>
name|GET_TYPEINFO
init|=
name|connection
lambda|->
block|{
try|try
block|{
return|return
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getTypeInfo
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Connection
argument_list|,
name|ResultSet
argument_list|>
name|GET_TABLE_TYPES
init|=
name|connection
lambda|->
block|{
try|try
block|{
return|return
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getTableTypes
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
name|Connection
name|localConnection
decl_stmt|;
specifier|private
specifier|static
name|HttpServer
name|start
decl_stmt|;
annotation|@
name|BeforeAll
specifier|public
specifier|static
name|void
name|beforeClass
parameter_list|()
throws|throws
name|Exception
block|{
name|localConnection
operator|=
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|connect
argument_list|()
expr_stmt|;
comment|// Make sure we pick an ephemeral port for the server
name|start
operator|=
name|Main
operator|.
name|start
argument_list|(
operator|new
name|String
index|[]
block|{
name|Factory
operator|.
name|class
operator|.
name|getName
argument_list|()
block|}
argument_list|,
literal|0
argument_list|,
name|AvaticaJsonHandler
operator|::
operator|new
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|static
name|Connection
name|getRemoteConnection
parameter_list|()
throws|throws
name|SQLException
block|{
specifier|final
name|int
name|port
init|=
name|start
operator|.
name|getPort
argument_list|()
decl_stmt|;
return|return
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:avatica:remote:url=http://localhost:"
operator|+
name|port
argument_list|)
return|;
block|}
annotation|@
name|AfterAll
specifier|public
specifier|static
name|void
name|afterClass
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|localConnection
operator|!=
literal|null
condition|)
block|{
name|localConnection
operator|.
name|close
argument_list|()
expr_stmt|;
name|localConnection
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
literal|null
condition|)
block|{
name|start
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCatalogsLocal
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:avatica:remote:factory="
operator|+
name|LJS
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getCatalogs
argument_list|()
decl_stmt|;
specifier|final
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnCount
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnName
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"TABLE_CAT"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSchemasLocal
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:avatica:remote:factory="
operator|+
name|LJS
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSchemas
argument_list|()
decl_stmt|;
specifier|final
name|ResultSetMetaData
name|metaData
init|=
name|resultSet
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnCount
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnName
argument_list|(
literal|1
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"TABLE_SCHEM"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|metaData
operator|.
name|getColumnName
argument_list|(
literal|2
argument_list|)
argument_list|,
name|is
argument_list|(
literal|"TABLE_CATALOG"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"POST"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|,
name|CoreMatchers
operator|.
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|getString
argument_list|(
literal|1
argument_list|)
argument_list|,
name|equalTo
argument_list|(
literal|"foodmart"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|getString
argument_list|(
literal|2
argument_list|)
argument_list|,
name|CoreMatchers
operator|.
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMetaFunctionsLocal
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Connection
name|connection
init|=
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|connect
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Meta
operator|.
name|DatabaseProperty
name|p
range|:
name|Meta
operator|.
name|DatabaseProperty
operator|.
name|values
argument_list|()
control|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|GET_NUMERIC_FUNCTIONS
case|:
name|assertThat
argument_list|(
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getNumericFunctions
argument_list|()
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
literal|""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_SYSTEM_FUNCTIONS
case|:
name|assertThat
argument_list|(
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSystemFunctions
argument_list|()
argument_list|,
name|CoreMatchers
operator|.
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_TIME_DATE_FUNCTIONS
case|:
name|assertThat
argument_list|(
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getTimeDateFunctions
argument_list|()
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
literal|""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_S_Q_L_KEYWORDS
case|:
name|assertThat
argument_list|(
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSQLKeywords
argument_list|()
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
literal|""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GET_STRING_FUNCTIONS
case|:
name|assertThat
argument_list|(
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|getStringFunctions
argument_list|()
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
literal|""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
block|}
block|}
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteCatalogs
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|with
argument_list|(
name|REMOTE_CONNECTION_FACTORY
argument_list|)
operator|.
name|metaData
argument_list|(
name|GET_CATALOGS
argument_list|)
operator|.
name|returns
argument_list|(
literal|"TABLE_CAT=null\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteSchemas
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|with
argument_list|(
name|REMOTE_CONNECTION_FACTORY
argument_list|)
operator|.
name|metaData
argument_list|(
name|GET_SCHEMAS
argument_list|)
operator|.
name|returns
argument_list|(
literal|"TABLE_SCHEM=POST; TABLE_CATALOG=null\n"
operator|+
literal|"TABLE_SCHEM=foodmart; TABLE_CATALOG=null\n"
operator|+
literal|"TABLE_SCHEM=hr; TABLE_CATALOG=null\n"
operator|+
literal|"TABLE_SCHEM=metadata; TABLE_CATALOG=null\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteColumns
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|with
argument_list|(
name|REMOTE_CONNECTION_FACTORY
argument_list|)
operator|.
name|metaData
argument_list|(
name|GET_COLUMNS
argument_list|)
operator|.
name|returns
argument_list|(
name|CalciteAssert
operator|.
name|checkResultContains
argument_list|(
literal|"COLUMN_NAME=EMPNO"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteTypeInfo
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|with
argument_list|(
name|REMOTE_CONNECTION_FACTORY
argument_list|)
operator|.
name|metaData
argument_list|(
name|GET_TYPEINFO
argument_list|)
operator|.
name|returns
argument_list|(
name|CalciteAssert
operator|.
name|checkResultCount
argument_list|(
name|is
argument_list|(
literal|45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteTableTypes
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|with
argument_list|(
name|REMOTE_CONNECTION_FACTORY
argument_list|)
operator|.
name|metaData
argument_list|(
name|GET_TABLE_TYPES
argument_list|)
operator|.
name|returns
argument_list|(
literal|"TABLE_TYPE=TABLE\n"
operator|+
literal|"TABLE_TYPE=VIEW\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteExecuteQuery
parameter_list|()
throws|throws
name|Exception
block|{
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|with
argument_list|(
name|REMOTE_CONNECTION_FACTORY
argument_list|)
operator|.
name|query
argument_list|(
literal|"values (1, 'a'), (cast(null as integer), 'b')"
argument_list|)
operator|.
name|returnsUnordered
argument_list|(
literal|"EXPR$0=1; EXPR$1=a"
argument_list|,
literal|"EXPR$0=null; EXPR$1=b"
argument_list|)
expr_stmt|;
block|}
comment|/** Same query as {@link #testRemoteExecuteQuery()}, run without the test    * infrastructure. */
annotation|@
name|Test
specifier|public
name|void
name|testRemoteExecuteQuery2
parameter_list|()
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|remoteConnection
init|=
name|getRemoteConnection
argument_list|()
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|remoteConnection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
specifier|final
name|String
name|sql
init|=
literal|"values (1, 'a'), (cast(null as integer), 'b')"
decl_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|n
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** For each (source, destination) type, make sure that we can convert bind    * variables. */
annotation|@
name|Test
specifier|public
name|void
name|testParameterConvert
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|StringBuilder
name|sql
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select 1"
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|SqlType
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Class
argument_list|,
name|SqlType
argument_list|>
name|entry
range|:
name|SqlType
operator|.
name|getSetConversions
argument_list|()
control|)
block|{
specifier|final
name|SqlType
name|sqlType
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|sqlType
condition|)
block|{
case|case
name|BIT
case|:
case|case
name|LONGVARCHAR
case|:
case|case
name|LONGVARBINARY
case|:
case|case
name|NCHAR
case|:
case|case
name|NVARCHAR
case|:
case|case
name|LONGNVARCHAR
case|:
case|case
name|BLOB
case|:
case|case
name|CLOB
case|:
case|case
name|NCLOB
case|:
case|case
name|ARRAY
case|:
case|case
name|REF
case|:
case|case
name|STRUCT
case|:
case|case
name|DATALINK
case|:
case|case
name|ROWID
case|:
case|case
name|JAVA_OBJECT
case|:
case|case
name|SQLXML
case|:
continue|continue;
block|}
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|sqlType
argument_list|)
condition|)
block|{
name|sql
operator|.
name|append
argument_list|(
literal|", cast(? as "
argument_list|)
operator|.
name|append
argument_list|(
name|sqlType
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|sqlType
argument_list|,
name|map
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sql
operator|.
name|append
argument_list|(
literal|" from (values 1)"
argument_list|)
expr_stmt|;
specifier|final
name|PreparedStatement
name|statement
init|=
name|localConnection
operator|.
name|prepareStatement
argument_list|(
name|sql
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SqlType
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|statement
operator|.
name|setNull
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Class
argument_list|,
name|SqlType
argument_list|>
name|entry
range|:
name|SqlType
operator|.
name|getSetConversions
argument_list|()
control|)
block|{
specifier|final
name|SqlType
name|sqlType
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|map
operator|.
name|containsKey
argument_list|(
name|sqlType
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|param
init|=
name|map
operator|.
name|get
argument_list|(
name|sqlType
argument_list|)
decl_stmt|;
name|Class
name|clazz
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|sampleValue
range|:
name|values
argument_list|(
name|sqlType
operator|.
name|boxedClass
argument_list|()
argument_list|)
control|)
block|{
switch|switch
condition|(
name|sqlType
condition|)
block|{
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
continue|continue;
comment|// FIXME
block|}
if|if
condition|(
name|clazz
operator|==
name|Calendar
operator|.
name|class
condition|)
block|{
continue|continue;
comment|// FIXME
block|}
specifier|final
name|Object
name|o
decl_stmt|;
try|try
block|{
name|o
operator|=
name|convert
argument_list|(
name|sampleValue
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
decl||
name|ParseException
name|e
parameter_list|)
block|{
continue|continue;
block|}
name|out
operator|.
name|println
argument_list|(
literal|"check "
operator|+
name|o
operator|+
literal|" (originally "
operator|+
name|sampleValue
operator|.
name|getClass
argument_list|()
operator|+
literal|", now "
operator|+
name|o
operator|.
name|getClass
argument_list|()
operator|+
literal|") converted to "
operator|+
name|sqlType
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Double
operator|&&
name|o
operator|.
name|equals
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
operator|||
name|o
operator|instanceof
name|Float
operator|&&
name|o
operator|.
name|equals
argument_list|(
name|Float
operator|.
name|POSITIVE_INFINITY
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|statement
operator|.
name|setObject
argument_list|(
name|param
argument_list|,
name|o
argument_list|,
name|sqlType
operator|.
name|id
argument_list|)
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultSet
operator|.
name|next
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
name|resultSet
operator|.
name|getString
argument_list|(
name|param
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Check that the "set" conversion table looks like Table B-5 in JDBC 4.1    * specification */
annotation|@
name|Test
specifier|public
name|void
name|testTableB5
parameter_list|()
block|{
name|SqlType
index|[]
name|columns
init|=
block|{
name|SqlType
operator|.
name|TINYINT
block|,
name|SqlType
operator|.
name|SMALLINT
block|,
name|SqlType
operator|.
name|INTEGER
block|,
name|SqlType
operator|.
name|BIGINT
block|,
name|SqlType
operator|.
name|REAL
block|,
name|SqlType
operator|.
name|FLOAT
block|,
name|SqlType
operator|.
name|DOUBLE
block|,
name|SqlType
operator|.
name|DECIMAL
block|,
name|SqlType
operator|.
name|NUMERIC
block|,
name|SqlType
operator|.
name|BIT
block|,
name|SqlType
operator|.
name|BOOLEAN
block|,
name|SqlType
operator|.
name|CHAR
block|,
name|SqlType
operator|.
name|VARCHAR
block|,
name|SqlType
operator|.
name|LONGVARCHAR
block|,
name|SqlType
operator|.
name|BINARY
block|,
name|SqlType
operator|.
name|VARBINARY
block|,
name|SqlType
operator|.
name|LONGVARBINARY
block|,
name|SqlType
operator|.
name|DATE
block|,
name|SqlType
operator|.
name|TIME
block|,
name|SqlType
operator|.
name|TIMESTAMP
block|,
name|SqlType
operator|.
name|ARRAY
block|,
name|SqlType
operator|.
name|BLOB
block|,
name|SqlType
operator|.
name|CLOB
block|,
name|SqlType
operator|.
name|STRUCT
block|,
name|SqlType
operator|.
name|REF
block|,
name|SqlType
operator|.
name|DATALINK
block|,
name|SqlType
operator|.
name|JAVA_OBJECT
block|,
name|SqlType
operator|.
name|ROWID
block|,
name|SqlType
operator|.
name|NCHAR
block|,
name|SqlType
operator|.
name|NVARCHAR
block|,
name|SqlType
operator|.
name|LONGNVARCHAR
block|,
name|SqlType
operator|.
name|NCLOB
block|,
name|SqlType
operator|.
name|SQLXML
block|}
decl_stmt|;
name|Class
index|[]
name|rows
init|=
block|{
name|String
operator|.
name|class
block|,
name|BigDecimal
operator|.
name|class
block|,
name|Boolean
operator|.
name|class
block|,
name|Byte
operator|.
name|class
block|,
name|Short
operator|.
name|class
block|,
name|Integer
operator|.
name|class
block|,
name|Long
operator|.
name|class
block|,
name|Float
operator|.
name|class
block|,
name|Double
operator|.
name|class
block|,
name|byte
index|[]
operator|.
name|class
block|,
name|BigInteger
operator|.
name|class
block|,
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
block|,
name|Time
operator|.
name|class
block|,
name|Timestamp
operator|.
name|class
block|,
name|Array
operator|.
name|class
block|,
name|Blob
operator|.
name|class
block|,
name|Clob
operator|.
name|class
block|,
name|Struct
operator|.
name|class
block|,
name|Ref
operator|.
name|class
block|,
name|URL
operator|.
name|class
block|,
name|Class
operator|.
name|class
block|,
name|RowId
operator|.
name|class
block|,
name|NClob
operator|.
name|class
block|,
name|SQLXML
operator|.
name|class
block|,
name|Calendar
operator|.
name|class
block|,
name|java
operator|.
name|util
operator|.
name|Date
operator|.
name|class
block|}
decl_stmt|;
for|for
control|(
name|Class
name|row
range|:
name|rows
control|)
block|{
specifier|final
name|String
name|s
init|=
name|row
operator|==
name|Date
operator|.
name|class
condition|?
name|row
operator|.
name|getName
argument_list|()
else|:
name|row
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
name|out
operator|.
name|print
argument_list|(
name|pad
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlType
name|column
range|:
name|columns
control|)
block|{
name|out
operator|.
name|print
argument_list|(
name|SqlType
operator|.
name|canSet
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
condition|?
literal|"x "
else|:
literal|". "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|pad
parameter_list|(
name|String
name|x
parameter_list|)
block|{
while|while
condition|(
name|x
operator|.
name|length
argument_list|()
operator|<
literal|20
condition|)
block|{
name|x
operator|=
name|x
operator|+
literal|" "
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/** Check that the "get" conversion table looks like Table B-5 in JDBC 4.1    * specification */
annotation|@
name|Test
specifier|public
name|void
name|testTableB6
parameter_list|()
block|{
name|SqlType
index|[]
name|columns
init|=
block|{
name|SqlType
operator|.
name|TINYINT
block|,
name|SqlType
operator|.
name|SMALLINT
block|,
name|SqlType
operator|.
name|INTEGER
block|,
name|SqlType
operator|.
name|BIGINT
block|,
name|SqlType
operator|.
name|REAL
block|,
name|SqlType
operator|.
name|FLOAT
block|,
name|SqlType
operator|.
name|DOUBLE
block|,
name|SqlType
operator|.
name|DECIMAL
block|,
name|SqlType
operator|.
name|NUMERIC
block|,
name|SqlType
operator|.
name|BIT
block|,
name|SqlType
operator|.
name|BOOLEAN
block|,
name|SqlType
operator|.
name|CHAR
block|,
name|SqlType
operator|.
name|VARCHAR
block|,
name|SqlType
operator|.
name|LONGVARCHAR
block|,
name|SqlType
operator|.
name|BINARY
block|,
name|SqlType
operator|.
name|VARBINARY
block|,
name|SqlType
operator|.
name|LONGVARBINARY
block|,
name|SqlType
operator|.
name|DATE
block|,
name|SqlType
operator|.
name|TIME
block|,
name|SqlType
operator|.
name|TIMESTAMP
block|,
name|SqlType
operator|.
name|CLOB
block|,
name|SqlType
operator|.
name|BLOB
block|,
name|SqlType
operator|.
name|ARRAY
block|,
name|SqlType
operator|.
name|REF
block|,
name|SqlType
operator|.
name|DATALINK
block|,
name|SqlType
operator|.
name|STRUCT
block|,
name|SqlType
operator|.
name|JAVA_OBJECT
block|,
name|SqlType
operator|.
name|ROWID
block|,
name|SqlType
operator|.
name|NCHAR
block|,
name|SqlType
operator|.
name|NVARCHAR
block|,
name|SqlType
operator|.
name|LONGNVARCHAR
block|,
name|SqlType
operator|.
name|NCLOB
block|,
name|SqlType
operator|.
name|SQLXML
block|}
decl_stmt|;
specifier|final
name|PrintWriter
name|out
init|=
name|CalciteSystemProperty
operator|.
name|DEBUG
operator|.
name|value
argument_list|()
condition|?
name|Util
operator|.
name|printWriter
argument_list|(
name|System
operator|.
name|out
argument_list|)
else|:
operator|new
name|PrintWriter
argument_list|(
operator|new
name|StringWriter
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlType
operator|.
name|Method
name|row
range|:
name|SqlType
operator|.
name|Method
operator|.
name|values
argument_list|()
control|)
block|{
name|out
operator|.
name|print
argument_list|(
name|pad
argument_list|(
name|row
operator|.
name|methodName
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlType
name|column
range|:
name|columns
control|)
block|{
name|out
operator|.
name|print
argument_list|(
name|SqlType
operator|.
name|canGet
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
condition|?
literal|"x "
else|:
literal|". "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Checks {@link Statement#execute} on a query over a remote connection.    *    *<p>Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-646">[CALCITE-646]    * AvaticaStatement execute method broken over remote JDBC</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testRemoteStatementExecute
parameter_list|()
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|remoteConnection
init|=
name|getRemoteConnection
argument_list|()
init|)
block|{
specifier|final
name|Statement
name|statement
init|=
name|remoteConnection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|status
init|=
name|statement
operator|.
name|execute
argument_list|(
literal|"values (1, 2), (3, 4), (5, 6)"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|status
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|n
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|n
argument_list|,
name|equalTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAvaticaConnectionException
parameter_list|()
block|{
name|assertThrows
argument_list|(
name|SQLException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
try|try
init|(
name|Connection
name|remoteConnection
init|=
name|getRemoteConnection
argument_list|()
init|)
block|{
name|remoteConnection
operator|.
name|isValid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAvaticaStatementException
parameter_list|()
block|{
name|assertThrows
argument_list|(
name|SQLException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
try|try
init|(
name|Connection
name|remoteConnection
init|=
name|getRemoteConnection
argument_list|()
init|)
block|{
try|try
init|(
name|Statement
name|statement
init|=
name|remoteConnection
operator|.
name|createStatement
argument_list|()
init|)
block|{
name|statement
operator|.
name|setCursorName
argument_list|(
literal|"foo"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAvaticaStatementGetMoreResults
parameter_list|()
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|remoteConnection
init|=
name|getRemoteConnection
argument_list|()
init|)
block|{
try|try
init|(
name|Statement
name|statement
init|=
name|remoteConnection
operator|.
name|createStatement
argument_list|()
init|)
block|{
name|assertThat
argument_list|(
name|statement
operator|.
name|getMoreResults
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteExecute
parameter_list|()
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|remoteConnection
init|=
name|getRemoteConnection
argument_list|()
init|)
block|{
name|ResultSet
name|resultSet
init|=
name|remoteConnection
operator|.
name|createStatement
argument_list|()
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"hr\".\"emps\""
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|count
operator|>
literal|0
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteExecuteMaxRow
parameter_list|()
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|remoteConnection
init|=
name|getRemoteConnection
argument_list|()
init|)
block|{
name|Statement
name|statement
init|=
name|remoteConnection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|statement
operator|.
name|setMaxRows
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
literal|"select * from \"hr\".\"emps\""
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|count
argument_list|,
name|equalTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Test case for    *<a href="https://issues.apache.org/jira/browse/CALCITE-661">[CALCITE-661]    * Remote fetch in Calcite JDBC driver</a>. */
annotation|@
name|Test
specifier|public
name|void
name|testRemotePrepareExecute
parameter_list|()
throws|throws
name|Exception
block|{
try|try
init|(
name|Connection
name|remoteConnection
init|=
name|getRemoteConnection
argument_list|()
init|)
block|{
specifier|final
name|PreparedStatement
name|preparedStatement
init|=
name|remoteConnection
operator|.
name|prepareStatement
argument_list|(
literal|"select * from \"hr\".\"emps\""
argument_list|)
decl_stmt|;
name|ResultSet
name|resultSet
init|=
name|preparedStatement
operator|.
name|executeQuery
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|count
operator|>
literal|0
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|Connection
name|makeConnection
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|JdbcTest
operator|.
name|Employee
argument_list|>
name|employees
init|=
operator|new
name|ArrayList
argument_list|<
name|JdbcTest
operator|.
name|Employee
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|101
condition|;
name|i
operator|++
control|)
block|{
name|employees
operator|.
name|add
argument_list|(
operator|new
name|JdbcTest
operator|.
name|Employee
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
literal|"first"
argument_list|,
literal|0f
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Connection
name|conn
init|=
name|JdbcFrontLinqBackTest
operator|.
name|makeConnection
argument_list|(
name|employees
argument_list|)
decl_stmt|;
return|return
name|conn
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLocalStatementFetch
parameter_list|()
throws|throws
name|Exception
block|{
name|Connection
name|conn
init|=
name|makeConnection
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select * from \"foo\".\"bar\""
decl_stmt|;
name|Statement
name|statement
init|=
name|conn
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|boolean
name|status
init|=
name|statement
operator|.
name|execute
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|status
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|count
argument_list|,
name|is
argument_list|(
literal|101
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Test that returns all result sets in one go. */
annotation|@
name|Test
specifier|public
name|void
name|testLocalPreparedStatementFetch
parameter_list|()
throws|throws
name|Exception
block|{
name|Connection
name|conn
init|=
name|makeConnection
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|conn
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|sql
init|=
literal|"select * from \"foo\".\"bar\""
decl_stmt|;
name|PreparedStatement
name|preparedStatement
init|=
name|conn
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|conn
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|status
init|=
name|preparedStatement
operator|.
name|execute
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|status
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|preparedStatement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultSet
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|getObject
argument_list|(
literal|1
argument_list|)
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|count
argument_list|,
name|is
argument_list|(
literal|101
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemoteStatementFetch
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:avatica:remote:factory="
operator|+
name|LocalServiceMoreFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|sql
init|=
literal|"select * from \"foo\".\"bar\""
decl_stmt|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|boolean
name|status
init|=
name|statement
operator|.
name|execute
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|status
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|count
argument_list|,
name|is
argument_list|(
literal|101
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRemotePreparedStatementFetch
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:avatica:remote:factory="
operator|+
name|LocalServiceMoreFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|sql
init|=
literal|"select * from \"foo\".\"bar\""
decl_stmt|;
name|PreparedStatement
name|preparedStatement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|preparedStatement
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|status
init|=
name|preparedStatement
operator|.
name|execute
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|status
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|preparedStatement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultSet
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|resultSet
operator|.
name|next
argument_list|()
condition|)
block|{
name|assertThat
argument_list|(
name|resultSet
operator|.
name|getObject
argument_list|(
literal|1
argument_list|)
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|count
argument_list|,
name|is
argument_list|(
literal|101
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Service factory that creates a Calcite instance with more data. */
specifier|public
specifier|static
class|class
name|LocalServiceMoreFactory
implements|implements
name|Service
operator|.
name|Factory
block|{
annotation|@
name|Override
specifier|public
name|Service
name|create
parameter_list|(
name|AvaticaConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|Connection
name|conn
init|=
name|makeConnection
argument_list|()
decl_stmt|;
specifier|final
name|CalciteMetaImpl
name|meta
init|=
operator|new
name|CalciteMetaImpl
argument_list|(
name|conn
operator|.
name|unwrap
argument_list|(
name|CalciteConnectionImpl
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|LocalService
argument_list|(
name|meta
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** A bunch of sample values of various types. */
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|SAMPLE_VALUES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
comment|// byte
operator|(
name|byte
operator|)
literal|0
argument_list|,
operator|(
name|byte
operator|)
literal|1
argument_list|,
name|Byte
operator|.
name|MIN_VALUE
argument_list|,
name|Byte
operator|.
name|MAX_VALUE
argument_list|,
comment|// short
operator|(
name|short
operator|)
literal|0
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
name|Short
operator|.
name|MIN_VALUE
argument_list|,
name|Short
operator|.
name|MAX_VALUE
argument_list|,
operator|(
name|short
operator|)
name|Byte
operator|.
name|MIN_VALUE
argument_list|,
operator|(
name|short
operator|)
name|Byte
operator|.
name|MAX_VALUE
argument_list|,
comment|// int
literal|0
argument_list|,
literal|1
argument_list|,
operator|-
literal|3
argument_list|,
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
operator|(
name|int
operator|)
name|Short
operator|.
name|MIN_VALUE
argument_list|,
operator|(
name|int
operator|)
name|Short
operator|.
name|MAX_VALUE
argument_list|,
operator|(
name|int
operator|)
name|Byte
operator|.
name|MIN_VALUE
argument_list|,
operator|(
name|int
operator|)
name|Byte
operator|.
name|MAX_VALUE
argument_list|,
comment|// long
literal|0L
argument_list|,
literal|1L
argument_list|,
operator|-
literal|2L
argument_list|,
name|Long
operator|.
name|MIN_VALUE
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|,
operator|(
name|long
operator|)
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
operator|(
name|long
operator|)
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
operator|(
name|long
operator|)
name|Short
operator|.
name|MIN_VALUE
argument_list|,
operator|(
name|long
operator|)
name|Short
operator|.
name|MAX_VALUE
argument_list|,
operator|(
name|long
operator|)
name|Byte
operator|.
name|MIN_VALUE
argument_list|,
operator|(
name|long
operator|)
name|Byte
operator|.
name|MAX_VALUE
argument_list|,
comment|// float
literal|0F
argument_list|,
literal|1.5F
argument_list|,
operator|-
literal|10F
argument_list|,
name|Float
operator|.
name|MIN_VALUE
argument_list|,
name|Float
operator|.
name|MAX_VALUE
argument_list|,
comment|// double
literal|0D
argument_list|,
name|Math
operator|.
name|PI
argument_list|,
name|Double
operator|.
name|MIN_VALUE
argument_list|,
name|Double
operator|.
name|MAX_VALUE
argument_list|,
operator|(
name|double
operator|)
name|Float
operator|.
name|MIN_VALUE
argument_list|,
operator|(
name|double
operator|)
name|Float
operator|.
name|MAX_VALUE
argument_list|,
operator|(
name|double
operator|)
name|Integer
operator|.
name|MIN_VALUE
argument_list|,
operator|(
name|double
operator|)
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
comment|// BigDecimal
name|BigDecimal
operator|.
name|ZERO
argument_list|,
name|BigDecimal
operator|.
name|ONE
argument_list|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|2.5D
argument_list|)
argument_list|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Double
operator|.
name|MAX_VALUE
argument_list|)
argument_list|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
argument_list|,
comment|// datetime
operator|new
name|Timestamp
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|java
operator|.
name|sql
operator|.
name|Date
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|Time
argument_list|(
literal|0
argument_list|)
argument_list|,
comment|// string
literal|""
argument_list|,
literal|"foo"
argument_list|,
literal|" foo! Baz "
argument_list|,
comment|// byte[]
operator|new
name|byte
index|[
literal|0
index|]
argument_list|,
literal|"hello"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|List
argument_list|<
name|Object
argument_list|>
name|values
parameter_list|(
name|Class
name|clazz
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|sampleValue
range|:
name|SAMPLE_VALUES
control|)
block|{
if|if
condition|(
name|sampleValue
operator|.
name|getClass
argument_list|()
operator|==
name|clazz
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|sampleValue
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
specifier|private
name|Object
name|convert
parameter_list|(
name|Object
name|o
parameter_list|,
name|Class
name|clazz
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|o
operator|.
name|getClass
argument_list|()
operator|==
name|clazz
condition|)
block|{
return|return
name|o
return|;
block|}
if|if
condition|(
name|clazz
operator|==
name|String
operator|.
name|class
condition|)
block|{
return|return
name|o
operator|.
name|toString
argument_list|()
return|;
block|}
if|if
condition|(
name|clazz
operator|==
name|Boolean
operator|.
name|class
condition|)
block|{
return|return
name|o
operator|instanceof
name|Number
operator|&&
operator|(
operator|(
name|Number
operator|)
name|o
operator|)
operator|.
name|intValue
argument_list|()
operator|!=
literal|0
operator|||
name|o
operator|instanceof
name|String
operator|&&
operator|(
operator|(
name|String
operator|)
name|o
operator|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"true"
argument_list|)
return|;
block|}
if|if
condition|(
name|clazz
operator|==
name|byte
index|[]
operator|.
name|class
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
return|return
operator|(
operator|(
name|String
operator|)
name|o
operator|)
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|clazz
operator|==
name|Timestamp
operator|.
name|class
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
return|return
name|Timestamp
operator|.
name|valueOf
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|clazz
operator|==
name|Time
operator|.
name|class
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
return|return
name|Time
operator|.
name|valueOf
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|clazz
operator|==
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
return|return
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|clazz
operator|==
name|java
operator|.
name|util
operator|.
name|Date
operator|.
name|class
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
specifier|final
name|DateFormat
name|dateFormat
init|=
name|DateFormat
operator|.
name|getDateTimeInstance
argument_list|(
name|DateFormat
operator|.
name|SHORT
argument_list|,
name|DateFormat
operator|.
name|SHORT
argument_list|,
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
return|return
name|dateFormat
operator|.
name|parse
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|clazz
operator|==
name|Calendar
operator|.
name|class
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
return|return
name|Util
operator|.
name|calendar
argument_list|()
return|;
comment|// TODO:
block|}
block|}
if|if
condition|(
name|o
operator|instanceof
name|Boolean
condition|)
block|{
name|o
operator|=
operator|(
name|Boolean
operator|)
name|o
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|instanceof
name|Number
condition|)
block|{
specifier|final
name|Number
name|number
init|=
operator|(
name|Number
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|Number
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
if|if
condition|(
name|clazz
operator|==
name|BigDecimal
operator|.
name|class
condition|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Double
operator|||
name|o
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|new
name|BigDecimal
argument_list|(
name|number
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|BigDecimal
argument_list|(
name|number
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|clazz
operator|==
name|BigInteger
operator|.
name|class
condition|)
block|{
return|return
operator|new
name|BigInteger
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Byte
operator|.
name|class
operator|||
name|clazz
operator|==
name|byte
operator|.
name|class
condition|)
block|{
return|return
name|number
operator|.
name|byteValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Short
operator|.
name|class
operator|||
name|clazz
operator|==
name|short
operator|.
name|class
condition|)
block|{
return|return
name|number
operator|.
name|shortValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Integer
operator|.
name|class
operator|||
name|clazz
operator|==
name|int
operator|.
name|class
condition|)
block|{
return|return
name|number
operator|.
name|intValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Long
operator|.
name|class
operator|||
name|clazz
operator|==
name|long
operator|.
name|class
condition|)
block|{
return|return
name|number
operator|.
name|longValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Float
operator|.
name|class
operator|||
name|clazz
operator|==
name|float
operator|.
name|class
condition|)
block|{
return|return
name|number
operator|.
name|floatValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Double
operator|.
name|class
operator|||
name|clazz
operator|==
name|double
operator|.
name|class
condition|)
block|{
return|return
name|number
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
block|}
if|if
condition|(
name|Number
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
if|if
condition|(
name|clazz
operator|==
name|BigDecimal
operator|.
name|class
condition|)
block|{
return|return
operator|new
name|BigDecimal
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|BigInteger
operator|.
name|class
condition|)
block|{
return|return
operator|new
name|BigInteger
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Byte
operator|.
name|class
operator|||
name|clazz
operator|==
name|byte
operator|.
name|class
condition|)
block|{
return|return
name|Byte
operator|.
name|valueOf
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Short
operator|.
name|class
operator|||
name|clazz
operator|==
name|short
operator|.
name|class
condition|)
block|{
return|return
name|Short
operator|.
name|valueOf
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Integer
operator|.
name|class
operator|||
name|clazz
operator|==
name|int
operator|.
name|class
condition|)
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Long
operator|.
name|class
operator|||
name|clazz
operator|==
name|long
operator|.
name|class
condition|)
block|{
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Float
operator|.
name|class
operator|||
name|clazz
operator|==
name|float
operator|.
name|class
condition|)
block|{
return|return
name|Float
operator|.
name|valueOf
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|clazz
operator|==
name|Double
operator|.
name|class
operator|||
name|clazz
operator|==
name|double
operator|.
name|class
condition|)
block|{
return|return
name|Double
operator|.
name|valueOf
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"cannot convert "
operator|+
name|o
operator|+
literal|"("
operator|+
name|o
operator|.
name|getClass
argument_list|()
operator|+
literal|") to "
operator|+
name|clazz
argument_list|)
throw|;
block|}
comment|/** Factory that creates a {@link Meta} that can see the test databases. */
specifier|public
specifier|static
class|class
name|Factory
implements|implements
name|Meta
operator|.
name|Factory
block|{
specifier|public
name|Meta
name|create
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
block|{
try|try
block|{
specifier|final
name|Connection
name|connection
init|=
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|connect
argument_list|()
decl_stmt|;
return|return
operator|new
name|CalciteMetaImpl
argument_list|(
operator|(
name|CalciteConnectionImpl
operator|)
name|connection
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Factory that creates a {@code LocalJsonService}. */
specifier|public
specifier|static
class|class
name|Factory2
implements|implements
name|Service
operator|.
name|Factory
block|{
specifier|public
name|Service
name|create
parameter_list|(
name|AvaticaConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|Connection
name|localConnection
init|=
name|CalciteAssert
operator|.
name|hr
argument_list|()
operator|.
name|connect
argument_list|()
decl_stmt|;
specifier|final
name|Meta
name|meta
init|=
name|CalciteConnectionImpl
operator|.
name|TROJAN
operator|.
name|getMeta
argument_list|(
operator|(
name|CalciteConnectionImpl
operator|)
name|localConnection
argument_list|)
decl_stmt|;
return|return
operator|new
name|LocalJsonService
argument_list|(
operator|new
name|LocalService
argument_list|(
name|meta
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Factory that creates a Service with connection to a modifiable table. */
specifier|public
specifier|static
class|class
name|LocalServiceModifiableFactory
implements|implements
name|Service
operator|.
name|Factory
block|{
annotation|@
name|Override
specifier|public
name|Service
name|create
parameter_list|(
name|AvaticaConnection
name|connection
parameter_list|)
block|{
try|try
block|{
name|Connection
name|conn
init|=
name|JdbcFrontLinqBackTest
operator|.
name|makeConnection
argument_list|()
decl_stmt|;
specifier|final
name|CalciteMetaImpl
name|meta
init|=
operator|new
name|CalciteMetaImpl
argument_list|(
name|conn
operator|.
name|unwrap
argument_list|(
name|CalciteConnectionImpl
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|LocalService
argument_list|(
name|meta
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|TestUtil
operator|.
name|rethrow
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Test remote Statement insert. */
annotation|@
name|Test
specifier|public
name|void
name|testInsert
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:avatica:remote:factory="
operator|+
name|LocalServiceModifiableFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|statement
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|sql
init|=
literal|"insert into \"foo\".\"bar\" values (1, 1, 'second', 2, 2)"
decl_stmt|;
name|boolean
name|status
init|=
name|statement
operator|.
name|execute
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|status
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultSet
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|updateCount
init|=
name|statement
operator|.
name|getUpdateCount
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|updateCount
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Test remote Statement batched insert. */
annotation|@
name|Test
specifier|public
name|void
name|testInsertBatch
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:avatica:remote:factory="
operator|+
name|LocalServiceModifiableFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|supportsBatchUpdates
argument_list|()
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|Statement
name|statement
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|statement
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|sql
init|=
literal|"insert into \"foo\".\"bar\" values (1, 1, 'second', 2, 2)"
decl_stmt|;
name|statement
operator|.
name|addBatch
argument_list|(
name|sql
argument_list|)
expr_stmt|;
name|statement
operator|.
name|addBatch
argument_list|(
name|sql
argument_list|)
expr_stmt|;
name|int
index|[]
name|updateCounts
init|=
name|statement
operator|.
name|executeBatch
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|updateCounts
operator|.
name|length
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|updateCounts
index|[
literal|0
index|]
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|updateCounts
index|[
literal|1
index|]
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultSet
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now empty batch
name|statement
operator|.
name|clearBatch
argument_list|()
expr_stmt|;
name|updateCounts
operator|=
name|statement
operator|.
name|executeBatch
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|updateCounts
operator|.
name|length
argument_list|,
name|is
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|resultSet
operator|=
name|statement
operator|.
name|getResultSet
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|resultSet
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Remote PreparedStatement insert WITHOUT bind variables    */
annotation|@
name|Test
specifier|public
name|void
name|testRemotePreparedStatementInsert
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
literal|"jdbc:avatica:remote:factory="
operator|+
name|LocalServiceModifiableFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|connection
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|sql
init|=
literal|"insert into \"foo\".\"bar\" values (1, 1, 'second', 2, 2)"
decl_stmt|;
name|PreparedStatement
name|preparedStatement
init|=
name|connection
operator|.
name|prepareStatement
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|preparedStatement
operator|.
name|isClosed
argument_list|()
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|status
init|=
name|preparedStatement
operator|.
name|execute
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|status
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|ResultSet
name|resultSet
init|=
name|preparedStatement
operator|.
name|getResultSet
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|resultSet
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|updateCount
init|=
name|preparedStatement
operator|.
name|getUpdateCount
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|updateCount
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remote PreparedStatement insert WITH bind variables    */
annotation|@
name|Test
specifier|public
name|void
name|testRemotePreparedStatementInsert2
parameter_list|()
throws|throws
name|Exception
block|{
block|}
block|}
end_class

end_unit

