begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|materialize
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|PlannerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|statistic
operator|.
name|MapSqlStatisticProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|CalciteAssert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|FoodMartQuerySet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|test
operator|.
name|SlowTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|FrameworkConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Planner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelConversionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|ValidationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|BaseMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Description
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|TypeSafeMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|allOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|CoreMatchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_comment
comment|/**  * Unit tests for {@link LatticeSuggester}.  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
name|SlowTests
operator|.
name|class
argument_list|)
specifier|public
class|class
name|LatticeSuggesterTest
block|{
comment|/** Some basic query patterns on the Scott schema with "EMP" and "DEPT"    * tables. */
annotation|@
name|Test
specifier|public
name|void
name|testEmpDept
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
decl_stmt|;
specifier|final
name|String
name|q0
init|=
literal|"select dept.dname, count(*), sum(sal)\n"
operator|+
literal|"from emp\n"
operator|+
literal|"join dept using (deptno)\n"
operator|+
literal|"group by dept.dname"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q0
argument_list|)
argument_list|,
name|isGraphs
argument_list|(
literal|"EMP (DEPT:DEPTNO)"
argument_list|,
literal|"[COUNT(), SUM(EMP.SAL)]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Same as above, but using WHERE rather than JOIN
specifier|final
name|String
name|q1
init|=
literal|"select dept.dname, count(*), sum(sal)\n"
operator|+
literal|"from emp, dept\n"
operator|+
literal|"where emp.deptno = dept.deptno\n"
operator|+
literal|"group by dept.dname"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q1
argument_list|)
argument_list|,
name|isGraphs
argument_list|(
literal|"EMP (DEPT:DEPTNO)"
argument_list|,
literal|"[COUNT(), SUM(EMP.SAL)]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// With HAVING
specifier|final
name|String
name|q2
init|=
literal|"select dept.dname\n"
operator|+
literal|"from emp, dept\n"
operator|+
literal|"where emp.deptno = dept.deptno\n"
operator|+
literal|"group by dept.dname\n"
operator|+
literal|"having count(*)> 10"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q2
argument_list|)
argument_list|,
name|isGraphs
argument_list|(
literal|"EMP (DEPT:DEPTNO)"
argument_list|,
literal|"[COUNT()]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// No joins, therefore graph has a single node and no edges
specifier|final
name|String
name|q3
init|=
literal|"select distinct dname\n"
operator|+
literal|"from dept"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q3
argument_list|)
argument_list|,
name|isGraphs
argument_list|(
literal|"DEPT"
argument_list|,
literal|"[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Graph is empty because there are no tables
specifier|final
name|String
name|q4
init|=
literal|"select distinct t.c\n"
operator|+
literal|"from (values 1, 2) as t(c)"
operator|+
literal|"join (values 2, 3) as u(c) using (c)\n"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q4
argument_list|)
argument_list|,
name|isGraphs
argument_list|()
argument_list|)
expr_stmt|;
comment|// Self-join
specifier|final
name|String
name|q5
init|=
literal|"select *\n"
operator|+
literal|"from emp as e\n"
operator|+
literal|"join emp as m on e.mgr = m.empno"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q5
argument_list|)
argument_list|,
name|isGraphs
argument_list|(
literal|"EMP (EMP:MGR)"
argument_list|,
literal|"[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Self-join, twice
specifier|final
name|String
name|q6
init|=
literal|"select *\n"
operator|+
literal|"from emp as e join emp as m on e.mgr = m.empno\n"
operator|+
literal|"join emp as m2 on m.mgr = m2.empno"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q6
argument_list|)
argument_list|,
name|isGraphs
argument_list|(
literal|"EMP (EMP:MGR (EMP:MGR))"
argument_list|,
literal|"[]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// No graphs, because cyclic: e -> m, m -> m2, m2 -> e
specifier|final
name|String
name|q7
init|=
literal|"select *\n"
operator|+
literal|"from emp as e\n"
operator|+
literal|"join emp as m on e.mgr = m.empno\n"
operator|+
literal|"join emp as m2 on m.mgr = m2.empno\n"
operator|+
literal|"where m2.mgr = e.empno"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q7
argument_list|)
argument_list|,
name|isGraphs
argument_list|()
argument_list|)
expr_stmt|;
comment|// The graph of all tables and hops
specifier|final
name|String
name|expected
init|=
literal|"graph("
operator|+
literal|"vertices: [[scott, DEPT],"
operator|+
literal|" [scott, EMP]], "
operator|+
literal|"edges: [Step([scott, EMP], [scott, DEPT], DEPTNO:DEPTNO),"
operator|+
literal|" Step([scott, EMP], [scott, EMP], MGR:EMPNO)])"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|space
operator|.
name|g
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFoodmart
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
decl_stmt|;
specifier|final
name|String
name|q
init|=
literal|"select \"t\".\"the_year\" as \"c0\",\n"
operator|+
literal|" \"t\".\"quarter\" as \"c1\",\n"
operator|+
literal|" \"pc\".\"product_family\" as \"c2\",\n"
operator|+
literal|" sum(\"s\".\"unit_sales\") as \"m0\"\n"
operator|+
literal|"from \"time_by_day\" as \"t\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"s\",\n"
operator|+
literal|" \"product_class\" as \"pc\",\n"
operator|+
literal|" \"product\" as \"p\"\n"
operator|+
literal|"where \"s\".\"time_id\" = \"t\".\"time_id\"\n"
operator|+
literal|"and \"t\".\"the_year\" = 1997\n"
operator|+
literal|"and \"s\".\"product_id\" = \"p\".\"product_id\"\n"
operator|+
literal|"and \"p\".\"product_class_id\" = \"pc\".\"product_class_id\"\n"
operator|+
literal|"group by \"t\".\"the_year\",\n"
operator|+
literal|" \"t\".\"quarter\",\n"
operator|+
literal|" \"pc\".\"product_family\""
decl_stmt|;
specifier|final
name|String
name|g
init|=
literal|"sales_fact_1997"
operator|+
literal|" (product:product_id (product_class:product_class_id)"
operator|+
literal|" time_by_day:time_id)"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q
argument_list|)
argument_list|,
name|isGraphs
argument_list|(
name|g
argument_list|,
literal|"[SUM(sales_fact_1997.unit_sales)]"
argument_list|)
argument_list|)
expr_stmt|;
comment|// The graph of all tables and hops
specifier|final
name|String
name|expected
init|=
literal|"graph("
operator|+
literal|"vertices: ["
operator|+
literal|"[foodmart, product], "
operator|+
literal|"[foodmart, product_class], "
operator|+
literal|"[foodmart, sales_fact_1997], "
operator|+
literal|"[foodmart, time_by_day]], "
operator|+
literal|"edges: ["
operator|+
literal|"Step([foodmart, product], [foodmart, product_class],"
operator|+
literal|" product_class_id:product_class_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, product],"
operator|+
literal|" product_id:product_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, time_by_day],"
operator|+
literal|" time_id:time_id)])"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|space
operator|.
name|g
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAggregateExpression
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
decl_stmt|;
specifier|final
name|String
name|q
init|=
literal|"select \"t\".\"the_year\" as \"c0\",\n"
operator|+
literal|" \"pc\".\"product_family\" as \"c1\",\n"
operator|+
literal|" sum((case when \"s\".\"promotion_id\" = 0\n"
operator|+
literal|"     then 0 else \"s\".\"store_sales\"\n"
operator|+
literal|"     end)) as \"sum_m0\"\n"
operator|+
literal|"from \"time_by_day\" as \"t\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"s\",\n"
operator|+
literal|" \"product_class\" as \"pc\",\n"
operator|+
literal|" \"product\" as \"p\"\n"
operator|+
literal|"where \"s\".\"time_id\" = \"t\".\"time_id\"\n"
operator|+
literal|" and \"t\".\"the_year\" = 1997\n"
operator|+
literal|" and \"s\".\"product_id\" = \"p\".\"product_id\"\n"
operator|+
literal|" and \"p\".\"product_class_id\" = \"pc\".\"product_class_id\"\n"
operator|+
literal|"group by \"t\".\"the_year\",\n"
operator|+
literal|" \"pc\".\"product_family\"\n"
decl_stmt|;
specifier|final
name|String
name|g
init|=
literal|"sales_fact_1997"
operator|+
literal|" (product:product_id (product_class:product_class_id)"
operator|+
literal|" time_by_day:time_id)"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"[SUM(m0)]"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q
argument_list|)
argument_list|,
name|allOf
argument_list|(
name|isGraphs
argument_list|(
name|g
argument_list|,
name|expected
argument_list|)
argument_list|,
name|hasMeasureNames
argument_list|(
literal|0
argument_list|,
literal|"sum_m0"
argument_list|)
argument_list|,
name|hasDerivedColumnNames
argument_list|(
literal|0
argument_list|,
literal|"m0"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Matcher
argument_list|<
name|List
argument_list|<
name|Lattice
argument_list|>
argument_list|>
name|hasMeasureNames
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|String
modifier|...
name|names
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|names
argument_list|)
decl_stmt|;
return|return
operator|new
name|TypeSafeMatcher
argument_list|<
name|List
argument_list|<
name|Lattice
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|void
name|describeTo
parameter_list|(
name|Description
name|description
parameter_list|)
block|{
name|description
operator|.
name|appendValue
argument_list|(
name|names
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|boolean
name|matchesSafely
parameter_list|(
name|List
argument_list|<
name|Lattice
argument_list|>
name|lattices
parameter_list|)
block|{
specifier|final
name|Lattice
name|lattice
init|=
name|lattices
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|actualNameList
init|=
name|Util
operator|.
name|transform
argument_list|(
name|lattice
operator|.
name|defaultMeasures
argument_list|,
name|measure
lambda|->
name|measure
operator|.
name|name
argument_list|)
decl_stmt|;
return|return
name|actualNameList
operator|.
name|equals
argument_list|(
name|nameList
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|private
name|Matcher
argument_list|<
name|List
argument_list|<
name|Lattice
argument_list|>
argument_list|>
name|hasDerivedColumnNames
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|String
modifier|...
name|names
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|names
argument_list|)
decl_stmt|;
return|return
operator|new
name|TypeSafeMatcher
argument_list|<
name|List
argument_list|<
name|Lattice
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|void
name|describeTo
parameter_list|(
name|Description
name|description
parameter_list|)
block|{
name|description
operator|.
name|appendValue
argument_list|(
name|names
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|boolean
name|matchesSafely
parameter_list|(
name|List
argument_list|<
name|Lattice
argument_list|>
name|lattices
parameter_list|)
block|{
specifier|final
name|Lattice
name|lattice
init|=
name|lattices
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|actualNameList
init|=
name|lattice
operator|.
name|columns
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|c
lambda|->
name|c
operator|instanceof
name|Lattice
operator|.
name|DerivedColumn
argument_list|)
operator|.
name|map
argument_list|(
name|c
lambda|->
operator|(
operator|(
name|Lattice
operator|.
name|DerivedColumn
operator|)
name|c
operator|)
operator|.
name|alias
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|actualNameList
operator|.
name|equals
argument_list|(
name|nameList
argument_list|)
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSharedSnowflake
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
decl_stmt|;
comment|// foodmart query 5827 (also 5828, 5830, 5832) uses the "region" table
comment|// twice: once via "store" and once via "customer";
comment|// TODO: test what happens if FK from "store" to "region" is reversed
specifier|final
name|String
name|q
init|=
literal|"select \"s\".\"store_country\" as \"c0\",\n"
operator|+
literal|" \"r\".\"sales_region\" as \"c1\",\n"
operator|+
literal|" \"r1\".\"sales_region\" as \"c2\",\n"
operator|+
literal|" sum(\"f\".\"unit_sales\") as \"m0\"\n"
operator|+
literal|"from \"store\" as \"s\",\n"
operator|+
literal|" \"sales_fact_1997\" as \"f\",\n"
operator|+
literal|" \"region\" as \"r\",\n"
operator|+
literal|" \"region\" as \"r1\",\n"
operator|+
literal|" \"customer\" as \"c\"\n"
operator|+
literal|"where \"f\".\"store_id\" = \"s\".\"store_id\"\n"
operator|+
literal|" and \"s\".\"store_country\" = 'USA'\n"
operator|+
literal|" and \"s\".\"region_id\" = \"r\".\"region_id\"\n"
operator|+
literal|" and \"r\".\"sales_region\" = 'South West'\n"
operator|+
literal|" and \"f\".\"customer_id\" = \"c\".\"customer_id\"\n"
operator|+
literal|" and \"c\".\"customer_region_id\" = \"r1\".\"region_id\"\n"
operator|+
literal|" and \"r1\".\"sales_region\" = 'South West'\n"
operator|+
literal|"group by \"s\".\"store_country\",\n"
operator|+
literal|" \"r\".\"sales_region\",\n"
operator|+
literal|" \"r1\".\"sales_region\"\n"
decl_stmt|;
specifier|final
name|String
name|g
init|=
literal|"sales_fact_1997"
operator|+
literal|" (customer:customer_id (region:customer_region_id)"
operator|+
literal|" store:store_id (region:region_id))"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|addQuery
argument_list|(
name|q
argument_list|)
argument_list|,
name|isGraphs
argument_list|(
name|g
argument_list|,
literal|"[SUM(sales_fact_1997.unit_sales)]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionInAggregate
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|withEvolve
argument_list|(
literal|true
argument_list|)
operator|.
name|foodmart
argument_list|()
decl_stmt|;
specifier|final
name|FoodMartQuerySet
name|set
init|=
name|FoodMartQuerySet
operator|.
name|instance
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|id
range|:
operator|new
name|int
index|[]
block|{
literal|392
block|,
literal|393
block|}
control|)
block|{
name|t
operator|.
name|addQuery
argument_list|(
name|set
operator|.
name|queries
operator|.
name|get
argument_list|(
name|id
argument_list|)
operator|.
name|sql
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkFoodMartAll
parameter_list|(
name|boolean
name|evolve
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
operator|.
name|withEvolve
argument_list|(
name|evolve
argument_list|)
decl_stmt|;
specifier|final
name|FoodMartQuerySet
name|set
init|=
name|FoodMartQuerySet
operator|.
name|instance
argument_list|()
decl_stmt|;
for|for
control|(
name|FoodMartQuerySet
operator|.
name|FoodmartQuery
name|query
range|:
name|set
operator|.
name|queries
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"agg_10_foo_fact\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"agg_line_class\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"agg_tenant\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"line\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"line_class\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"tenant\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"test_lp_xxx_fact\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"product_csv\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"product_cat\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"cat\""
argument_list|)
operator|||
name|query
operator|.
name|sql
operator|.
name|contains
argument_list|(
literal|"\"fact\""
argument_list|)
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|query
operator|.
name|id
condition|)
block|{
case|case
literal|2455
case|:
comment|// missing RTRIM function
case|case
literal|2456
case|:
comment|// missing RTRIM function
case|case
literal|2457
case|:
comment|// missing RTRIM function
case|case
literal|5682
case|:
comment|// case sensitivity
case|case
literal|5700
case|:
comment|// || applied to smallint
continue|continue;
default|default:
name|t
operator|.
name|addQuery
argument_list|(
name|query
operator|.
name|sql
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The graph of all tables and hops
specifier|final
name|String
name|expected
init|=
literal|"graph("
operator|+
literal|"vertices: ["
operator|+
literal|"[foodmart, agg_c_10_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_c_14_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_c_special_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_g_ms_pcat_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_l_03_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_l_04_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_l_05_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_lc_06_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_lc_100_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_ll_01_sales_fact_1997], "
operator|+
literal|"[foodmart, agg_pl_01_sales_fact_1997], "
operator|+
literal|"[foodmart, customer], "
operator|+
literal|"[foodmart, department], "
operator|+
literal|"[foodmart, employee], "
operator|+
literal|"[foodmart, employee_closure], "
operator|+
literal|"[foodmart, inventory_fact_1997], "
operator|+
literal|"[foodmart, position], "
operator|+
literal|"[foodmart, product], "
operator|+
literal|"[foodmart, product_class], "
operator|+
literal|"[foodmart, promotion], "
operator|+
literal|"[foodmart, region], "
operator|+
literal|"[foodmart, salary], "
operator|+
literal|"[foodmart, sales_fact_1997], "
operator|+
literal|"[foodmart, store], "
operator|+
literal|"[foodmart, store_ragged], "
operator|+
literal|"[foodmart, time_by_day], "
operator|+
literal|"[foodmart, warehouse], "
operator|+
literal|"[foodmart, warehouse_class]], "
operator|+
literal|"edges: ["
operator|+
literal|"Step([foodmart, agg_c_14_sales_fact_1997], [foodmart, store], store_id:store_id), "
operator|+
literal|"Step([foodmart, customer], [foodmart, region], customer_region_id:region_id), "
operator|+
literal|"Step([foodmart, employee], [foodmart, employee], supervisor_id:employee_id), "
operator|+
literal|"Step([foodmart, employee], [foodmart, position], position_id:position_id), "
operator|+
literal|"Step([foodmart, employee], [foodmart, store], store_id:store_id), "
operator|+
literal|"Step([foodmart, inventory_fact_1997], [foodmart, employee], product_id:employee_id), "
operator|+
literal|"Step([foodmart, inventory_fact_1997], [foodmart, employee], time_id:employee_id), "
operator|+
literal|"Step([foodmart, inventory_fact_1997], [foodmart, product], product_id:product_id), "
operator|+
literal|"Step([foodmart, inventory_fact_1997], [foodmart, store], store_id:store_id), "
operator|+
literal|"Step([foodmart, inventory_fact_1997], [foodmart, store], warehouse_id:store_id), "
operator|+
literal|"Step([foodmart, inventory_fact_1997], [foodmart, time_by_day], time_id:time_id), "
operator|+
literal|"Step([foodmart, inventory_fact_1997], [foodmart, warehouse],"
operator|+
literal|" warehouse_id:warehouse_id), "
operator|+
literal|"Step([foodmart, product], [foodmart, product_class],"
operator|+
literal|" product_class_id:product_class_id), "
operator|+
literal|"Step([foodmart, product], [foodmart, store], product_class_id:store_id), "
operator|+
literal|"Step([foodmart, salary], [foodmart, department], department_id:department_id), "
operator|+
literal|"Step([foodmart, salary], [foodmart, employee], employee_id:employee_id), "
operator|+
literal|"Step([foodmart, salary], [foodmart, employee_closure], employee_id:employee_id), "
operator|+
literal|"Step([foodmart, salary], [foodmart, time_by_day], pay_date:the_date), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, customer], customer_id:customer_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, customer], product_id:customer_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, customer], store_id:customer_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, product], product_id:product_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, promotion], promotion_id:promotion_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, store], product_id:store_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, store], store_id:store_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, store_ragged], store_id:store_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, time_by_day], product_id:time_id), "
operator|+
literal|"Step([foodmart, sales_fact_1997], [foodmart, time_by_day], time_id:time_id), "
operator|+
literal|"Step([foodmart, store], [foodmart, customer], store_state:state_province), "
operator|+
literal|"Step([foodmart, store], [foodmart, product_class], region_id:product_class_id), "
operator|+
literal|"Step([foodmart, store], [foodmart, region], region_id:region_id), "
operator|+
literal|"Step([foodmart, time_by_day], [foodmart, agg_c_14_sales_fact_1997], month_of_year:month_of_year), "
operator|+
literal|"Step([foodmart, warehouse], [foodmart, store], stores_id:store_id), "
operator|+
literal|"Step([foodmart, warehouse], [foodmart, warehouse_class],"
operator|+
literal|" warehouse_class_id:warehouse_class_id)])"
decl_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|space
operator|.
name|g
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evolve
condition|)
block|{
comment|// compared to evolve=false, there are a few more nodes (137 vs 119),
comment|// the same number of paths, and a lot fewer lattices (27 vs 388)
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|space
operator|.
name|nodeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|137
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|27
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|space
operator|.
name|pathMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|46
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|space
operator|.
name|nodeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|119
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|388
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|space
operator|.
name|pathMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|46
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFoodMartAll
parameter_list|()
throws|throws
name|Exception
block|{
name|checkFoodMartAll
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFoodMartAllEvolve
parameter_list|()
throws|throws
name|Exception
block|{
name|checkFoodMartAll
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testContains
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
decl_stmt|;
specifier|final
name|LatticeRootNode
name|fNode
init|=
name|t
operator|.
name|node
argument_list|(
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\""
argument_list|)
decl_stmt|;
specifier|final
name|LatticeRootNode
name|fcNode
init|=
name|t
operator|.
name|node
argument_list|(
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\"\n"
operator|+
literal|"join \"customer\" using (\"customer_id\")"
argument_list|)
decl_stmt|;
specifier|final
name|LatticeRootNode
name|fcpNode
init|=
name|t
operator|.
name|node
argument_list|(
literal|"select *\n"
operator|+
literal|"from \"sales_fact_1997\"\n"
operator|+
literal|"join \"customer\" using (\"customer_id\")\n"
operator|+
literal|"join \"product\" using (\"product_id\")"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|fNode
operator|.
name|contains
argument_list|(
name|fNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|fNode
operator|.
name|contains
argument_list|(
name|fcNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|fNode
operator|.
name|contains
argument_list|(
name|fcpNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|fcNode
operator|.
name|contains
argument_list|(
name|fNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|fcNode
operator|.
name|contains
argument_list|(
name|fcNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|fcNode
operator|.
name|contains
argument_list|(
name|fcpNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|fcpNode
operator|.
name|contains
argument_list|(
name|fNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|fcpNode
operator|.
name|contains
argument_list|(
name|fcNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|fcpNode
operator|.
name|contains
argument_list|(
name|fcpNode
argument_list|)
argument_list|,
name|is
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEvolve
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
operator|.
name|withEvolve
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|String
name|q0
init|=
literal|"select count(*)\n"
operator|+
literal|"from \"sales_fact_1997\""
decl_stmt|;
specifier|final
name|String
name|l0
init|=
literal|"sales_fact_1997:[COUNT()]"
decl_stmt|;
name|t
operator|.
name|addQuery
argument_list|(
name|q0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|l0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|q1
init|=
literal|"select sum(\"unit_sales\")\n"
operator|+
literal|"from \"sales_fact_1997\"\n"
operator|+
literal|"join \"customer\" using (\"customer_id\")\n"
operator|+
literal|"group by \"customer\".\"city\""
decl_stmt|;
specifier|final
name|String
name|l1
init|=
literal|"sales_fact_1997 (customer:customer_id)"
operator|+
literal|":[COUNT(), SUM(sales_fact_1997.unit_sales)]"
decl_stmt|;
name|t
operator|.
name|addQuery
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|l1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|q2
init|=
literal|"select count(distinct \"the_day\")\n"
operator|+
literal|"from \"sales_fact_1997\"\n"
operator|+
literal|"join \"time_by_day\" using (\"time_id\")\n"
operator|+
literal|"join \"product\" using (\"product_id\")"
decl_stmt|;
specifier|final
name|String
name|l2
init|=
literal|"sales_fact_1997"
operator|+
literal|" (customer:customer_id product:product_id time_by_day:time_id)"
operator|+
literal|":[COUNT(), SUM(sales_fact_1997.unit_sales),"
operator|+
literal|" COUNT(DISTINCT time_by_day.the_day)]"
decl_stmt|;
name|t
operator|.
name|addQuery
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|l2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Lattice
name|lattice
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|tableNames
init|=
name|lattice
operator|.
name|tables
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|table
lambda|->
name|table
operator|.
name|t
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
operator|.
name|sorted
argument_list|(
name|Comparator
operator|.
name|comparing
argument_list|(
name|Object
operator|::
name|toString
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|tableNames
operator|.
name|toString
argument_list|()
argument_list|,
name|is
argument_list|(
literal|"[[foodmart, customer],"
operator|+
literal|" [foodmart, product],"
operator|+
literal|" [foodmart, sales_fact_1997],"
operator|+
literal|" [foodmart, time_by_day]]"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|q3
init|=
literal|"select min(\"product\".\"product_id\")\n"
operator|+
literal|"from \"sales_fact_1997\"\n"
operator|+
literal|"join \"product\" using (\"product_id\")\n"
operator|+
literal|"join \"product_class\" as pc using (\"product_class_id\")\n"
operator|+
literal|"group by pc.\"product_department\""
decl_stmt|;
specifier|final
name|String
name|l3
init|=
literal|"sales_fact_1997"
operator|+
literal|" (customer:customer_id product:product_id"
operator|+
literal|" (product_class:product_class_id) time_by_day:time_id)"
operator|+
literal|":[COUNT(), SUM(sales_fact_1997.unit_sales),"
operator|+
literal|" MIN(product.product_id), COUNT(DISTINCT time_by_day.the_day)]"
decl_stmt|;
name|t
operator|.
name|addQuery
argument_list|(
name|q3
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|l3
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpression
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
operator|.
name|withEvolve
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|String
name|q0
init|=
literal|"select\n"
operator|+
literal|"  \"fname\" || ' ' || \"lname\" as \"full_name\",\n"
operator|+
literal|"  count(*) as c,\n"
operator|+
literal|"  avg(\"total_children\" - \"num_children_at_home\")\n"
operator|+
literal|"from \"customer\"\n"
operator|+
literal|"group by \"fname\", \"lname\""
decl_stmt|;
specifier|final
name|String
name|l0
init|=
literal|"customer:[COUNT(), AVG($f2)]"
decl_stmt|;
name|t
operator|.
name|addQuery
argument_list|(
name|q0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|l0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Lattice
name|lattice
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Lattice
operator|.
name|DerivedColumn
argument_list|>
name|derivedColumns
init|=
name|lattice
operator|.
name|columns
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|c
lambda|->
name|c
operator|instanceof
name|Lattice
operator|.
name|DerivedColumn
argument_list|)
operator|.
name|map
argument_list|(
name|c
lambda|->
operator|(
name|Lattice
operator|.
name|DerivedColumn
operator|)
name|c
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|derivedColumns
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tables
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"customer"
argument_list|)
decl_stmt|;
name|checkDerivedColumn
argument_list|(
name|lattice
argument_list|,
name|tables
argument_list|,
name|derivedColumns
argument_list|,
literal|0
argument_list|,
literal|"$f2"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|checkDerivedColumn
argument_list|(
name|lattice
argument_list|,
name|tables
argument_list|,
name|derivedColumns
argument_list|,
literal|1
argument_list|,
literal|"full_name"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/** As {@link #testExpression()} but with multiple queries.    * Some expressions are measures in one query and dimensions in another. */
annotation|@
name|Test
specifier|public
name|void
name|testExpressionEvolution
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
operator|.
name|withEvolve
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// q0 uses n10 as a measure, n11 as a measure, n12 as a dimension
specifier|final
name|String
name|q0
init|=
literal|"select\n"
operator|+
literal|"  \"num_children_at_home\" + 12 as \"n12\",\n"
operator|+
literal|"  sum(\"num_children_at_home\" + 10) as \"n10\",\n"
operator|+
literal|"  sum(\"num_children_at_home\" + 11) as \"n11\",\n"
operator|+
literal|"  count(*) as c\n"
operator|+
literal|"from \"customer\"\n"
operator|+
literal|"group by \"num_children_at_home\" + 12"
decl_stmt|;
comment|// q1 uses n10 as a dimension, n12 as a measure
specifier|final
name|String
name|q1
init|=
literal|"select\n"
operator|+
literal|"  \"num_children_at_home\" + 10 as \"n10\",\n"
operator|+
literal|"  \"num_children_at_home\" + 14 as \"n14\",\n"
operator|+
literal|"  sum(\"num_children_at_home\" + 12) as \"n12\",\n"
operator|+
literal|"  sum(\"num_children_at_home\" + 13) as \"n13\"\n"
operator|+
literal|"from \"customer\"\n"
operator|+
literal|"group by \"num_children_at_home\" + 10,"
operator|+
literal|"   \"num_children_at_home\" + 14"
decl_stmt|;
comment|// n10 = [measure, dimension] -> not always measure
comment|// n11 = [measure, _] -> always measure
comment|// n12 = [dimension, measure] -> not always measure
comment|// n13 = [_, measure] -> always measure
comment|// n14 = [_, dimension] -> not always measure
name|t
operator|.
name|addQuery
argument_list|(
name|q0
argument_list|)
expr_stmt|;
name|t
operator|.
name|addQuery
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|String
name|l0
init|=
literal|"customer:[COUNT(), SUM(n10), SUM(n11), SUM(n12), SUM(n13)]"
decl_stmt|;
name|assertThat
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|l0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Lattice
name|lattice
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Lattice
operator|.
name|DerivedColumn
argument_list|>
name|derivedColumns
init|=
name|lattice
operator|.
name|columns
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|c
lambda|->
name|c
operator|instanceof
name|Lattice
operator|.
name|DerivedColumn
argument_list|)
operator|.
name|map
argument_list|(
name|c
lambda|->
operator|(
name|Lattice
operator|.
name|DerivedColumn
operator|)
name|c
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|derivedColumns
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tables
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"customer"
argument_list|)
decl_stmt|;
name|checkDerivedColumn
argument_list|(
name|lattice
argument_list|,
name|tables
argument_list|,
name|derivedColumns
argument_list|,
literal|0
argument_list|,
literal|"n10"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkDerivedColumn
argument_list|(
name|lattice
argument_list|,
name|tables
argument_list|,
name|derivedColumns
argument_list|,
literal|1
argument_list|,
literal|"n11"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|checkDerivedColumn
argument_list|(
name|lattice
argument_list|,
name|tables
argument_list|,
name|derivedColumns
argument_list|,
literal|2
argument_list|,
literal|"n12"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkDerivedColumn
argument_list|(
name|lattice
argument_list|,
name|tables
argument_list|,
name|derivedColumns
argument_list|,
literal|3
argument_list|,
literal|"n13"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|checkDerivedColumn
argument_list|(
name|lattice
argument_list|,
name|tables
argument_list|,
name|derivedColumns
argument_list|,
literal|4
argument_list|,
literal|"n14"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkDerivedColumn
parameter_list|(
name|Lattice
name|lattice
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tables
parameter_list|,
name|List
argument_list|<
name|Lattice
operator|.
name|DerivedColumn
argument_list|>
name|derivedColumns
parameter_list|,
name|int
name|index
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|alwaysMeasure
parameter_list|)
block|{
specifier|final
name|Lattice
operator|.
name|DerivedColumn
name|dc0
init|=
name|derivedColumns
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|dc0
operator|.
name|tables
argument_list|,
name|is
argument_list|(
name|tables
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|dc0
operator|.
name|alias
argument_list|,
name|is
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|lattice
operator|.
name|isAlwaysMeasure
argument_list|(
name|dc0
argument_list|)
argument_list|,
name|is
argument_list|(
name|alwaysMeasure
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpressionInJoin
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Tester
name|t
init|=
operator|new
name|Tester
argument_list|()
operator|.
name|foodmart
argument_list|()
operator|.
name|withEvolve
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|String
name|q0
init|=
literal|"select\n"
operator|+
literal|"  \"fname\" || ' ' || \"lname\" as \"full_name\",\n"
operator|+
literal|"  count(*) as c,\n"
operator|+
literal|"  avg(\"total_children\" - \"num_children_at_home\")\n"
operator|+
literal|"from \"customer\" join \"sales_fact_1997\" using (\"customer_id\")\n"
operator|+
literal|"group by \"fname\", \"lname\""
decl_stmt|;
specifier|final
name|String
name|l0
init|=
literal|"sales_fact_1997 (customer:customer_id)"
operator|+
literal|":[COUNT(), AVG($f2)]"
decl_stmt|;
name|t
operator|.
name|addQuery
argument_list|(
name|q0
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|is
argument_list|(
name|l0
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Lattice
name|lattice
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|t
operator|.
name|s
operator|.
name|latticeMap
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Lattice
operator|.
name|DerivedColumn
argument_list|>
name|derivedColumns
init|=
name|lattice
operator|.
name|columns
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|c
lambda|->
name|c
operator|instanceof
name|Lattice
operator|.
name|DerivedColumn
argument_list|)
operator|.
name|map
argument_list|(
name|c
lambda|->
operator|(
name|Lattice
operator|.
name|DerivedColumn
operator|)
name|c
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|derivedColumns
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tables
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"customer"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|derivedColumns
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|tables
argument_list|,
name|is
argument_list|(
name|tables
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|derivedColumns
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|tables
argument_list|,
name|is
argument_list|(
name|tables
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a matcher that matches query graphs to strings. */
specifier|private
name|BaseMatcher
argument_list|<
name|List
argument_list|<
name|Lattice
argument_list|>
argument_list|>
name|isGraphs
parameter_list|(
name|String
modifier|...
name|strings
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|strings
argument_list|)
decl_stmt|;
return|return
operator|new
name|BaseMatcher
argument_list|<
name|List
argument_list|<
name|Lattice
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|matches
parameter_list|(
name|Object
name|item
parameter_list|)
block|{
comment|//noinspection unchecked
return|return
name|item
operator|instanceof
name|List
operator|&&
operator|(
operator|(
name|List
operator|)
name|item
operator|)
operator|.
name|size
argument_list|()
operator|*
literal|2
operator|==
name|expectedList
operator|.
name|size
argument_list|()
operator|&&
name|allEqual
argument_list|(
operator|(
name|List
operator|)
name|item
argument_list|,
name|expectedList
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|allEqual
parameter_list|(
name|List
argument_list|<
name|Lattice
argument_list|>
name|items
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|expects
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Lattice
name|lattice
init|=
name|items
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expectedNode
init|=
name|expects
operator|.
name|get
argument_list|(
literal|2
operator|*
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lattice
operator|.
name|rootNode
operator|.
name|digest
operator|.
name|equals
argument_list|(
name|expectedNode
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|String
name|expectedMeasures
init|=
name|expects
operator|.
name|get
argument_list|(
literal|2
operator|*
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lattice
operator|.
name|defaultMeasures
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|expectedMeasures
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|describeTo
parameter_list|(
name|Description
name|description
parameter_list|)
block|{
name|description
operator|.
name|appendValue
argument_list|(
name|expectedList
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/** Test helper. */
specifier|private
specifier|static
class|class
name|Tester
block|{
specifier|final
name|LatticeSuggester
name|s
decl_stmt|;
specifier|private
specifier|final
name|FrameworkConfig
name|config
decl_stmt|;
name|Tester
parameter_list|()
block|{
name|this
argument_list|(
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|()
operator|.
name|defaultSchema
argument_list|(
name|schemaFrom
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|SCOTT
argument_list|)
argument_list|)
operator|.
name|statisticProvider
argument_list|(
name|MapSqlStatisticProvider
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Tester
parameter_list|(
name|FrameworkConfig
name|config
parameter_list|)
block|{
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|s
operator|=
operator|new
name|LatticeSuggester
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
name|Tester
name|withConfig
parameter_list|(
name|FrameworkConfig
name|config
parameter_list|)
block|{
return|return
operator|new
name|Tester
argument_list|(
name|config
argument_list|)
return|;
block|}
name|Tester
name|foodmart
parameter_list|()
block|{
return|return
name|schema
argument_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
operator|.
name|JDBC_FOODMART
argument_list|)
return|;
block|}
specifier|private
name|Tester
name|schema
parameter_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
name|schemaSpec
parameter_list|)
block|{
return|return
name|withConfig
argument_list|(
name|builder
argument_list|()
operator|.
name|defaultSchema
argument_list|(
name|schemaFrom
argument_list|(
name|schemaSpec
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|Frameworks
operator|.
name|ConfigBuilder
name|builder
parameter_list|()
block|{
return|return
name|Frameworks
operator|.
name|newConfigBuilder
argument_list|(
name|config
argument_list|)
return|;
block|}
name|List
argument_list|<
name|Lattice
argument_list|>
name|addQuery
parameter_list|(
name|String
name|q
parameter_list|)
throws|throws
name|SqlParseException
throws|,
name|ValidationException
throws|,
name|RelConversionException
block|{
specifier|final
name|Planner
name|planner
init|=
operator|new
name|PlannerImpl
argument_list|(
name|config
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|node
init|=
name|planner
operator|.
name|parse
argument_list|(
name|q
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|node2
init|=
name|planner
operator|.
name|validate
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|RelRoot
name|root
init|=
name|planner
operator|.
name|rel
argument_list|(
name|node2
argument_list|)
decl_stmt|;
return|return
name|s
operator|.
name|addQuery
argument_list|(
name|root
operator|.
name|project
argument_list|()
argument_list|)
return|;
block|}
comment|/** Parses a query returns its graph. */
name|LatticeRootNode
name|node
parameter_list|(
name|String
name|q
parameter_list|)
throws|throws
name|SqlParseException
throws|,
name|ValidationException
throws|,
name|RelConversionException
block|{
specifier|final
name|List
argument_list|<
name|Lattice
argument_list|>
name|list
init|=
name|addQuery
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|,
name|is
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|rootNode
return|;
block|}
specifier|private
specifier|static
name|SchemaPlus
name|schemaFrom
parameter_list|(
name|CalciteAssert
operator|.
name|SchemaSpec
name|spec
parameter_list|)
block|{
specifier|final
name|SchemaPlus
name|rootSchema
init|=
name|Frameworks
operator|.
name|createRootSchema
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|CalciteAssert
operator|.
name|addSchema
argument_list|(
name|rootSchema
argument_list|,
name|spec
argument_list|)
return|;
block|}
name|Tester
name|withEvolve
parameter_list|(
name|boolean
name|evolve
parameter_list|)
block|{
return|return
name|withConfig
argument_list|(
name|builder
argument_list|()
operator|.
name|evolveLattice
argument_list|(
name|evolve
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End LatticeSuggesterTest.java
end_comment

end_unit

