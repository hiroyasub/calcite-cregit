begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|test
operator|.
name|concurrent
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|SqlTimeoutException
import|;
end_import

begin_comment
comment|/**  * ConcurrentTestCommandScript creates instances of {@link  * ConcurrentTestCommand} that perform specific actions in a specific  * order and within the context of a test thread ({@link  * ConcurrentTestCommandExecutor}).  *  *<p>Actions are loaded from a script (see package javadoc for script format).  *  *<p>A single ConcurrentTestCommandScript creates commands  * for multiple threads. Each thread is represented by an integer "thread ID"  * and, optionally, a String thread name. Thread IDs may take on any positive  * integer value and may be a sparse set (e.g. 1, 2, 5). Thread names may be any  * String.  *  *<p>When each command is created, it is associated with a thread and given an  * execution order. Execution order values are positive integers, must be unique  * within a thread, and may be a sparse set.  * See {@link ConcurrentTestCommandGenerator#synchronizeCommandSets} for other  * considerations.  */
end_comment

begin_class
specifier|public
class|class
name|ConcurrentTestCommandScript
extends|extends
name|ConcurrentTestCommandGenerator
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|String
name|PRE_SETUP_STATE
init|=
literal|"pre-setup"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SETUP_STATE
init|=
literal|"setup"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|POST_SETUP_STATE
init|=
literal|"post-setup"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CLEANUP_STATE
init|=
literal|"cleanup"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|POST_CLEANUP_STATE
init|=
literal|"post-cleanup"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|THREAD_STATE
init|=
literal|"thread"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|REPEAT_STATE
init|=
literal|"repeat"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SQL_STATE
init|=
literal|"sql"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|POST_THREAD_STATE
init|=
literal|"post-thread"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|EOF_STATE
init|=
literal|"eof"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|VAR
init|=
literal|"@var"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|LOCKSTEP
init|=
literal|"@lockstep"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|NOLOCKSTEP
init|=
literal|"@nolockstep"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ENABLED
init|=
literal|"@enabled"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DISABLED
init|=
literal|"@disabled"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SETUP
init|=
literal|"@setup"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CLEANUP
init|=
literal|"@cleanup"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|END
init|=
literal|"@end"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|THREAD
init|=
literal|"@thread"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|REPEAT
init|=
literal|"@repeat"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SYNC
init|=
literal|"@sync"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TIMEOUT
init|=
literal|"@timeout"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ROWLIMIT
init|=
literal|"@rowlimit"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PREPARE
init|=
literal|"@prepare"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PRINT
init|=
literal|"@print"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FETCH
init|=
literal|"@fetch"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CLOSE
init|=
literal|"@close"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SLEEP
init|=
literal|"@sleep"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ERR
init|=
literal|"@err"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ECHO
init|=
literal|"@echo"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|INCLUDE
init|=
literal|"@include"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SHELL
init|=
literal|"@shell"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PLUGIN
init|=
literal|"@plugin"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SQL
init|=
literal|""
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|EOF
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|StateAction
index|[]
name|STATE_TABLE
init|=
block|{
operator|new
name|StateAction
argument_list|(
name|PRE_SETUP_STATE
argument_list|,
operator|new
name|StateDatum
index|[]
block|{
operator|new
name|StateDatum
argument_list|(
name|VAR
argument_list|,
name|PRE_SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|LOCKSTEP
argument_list|,
name|PRE_SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|NOLOCKSTEP
argument_list|,
name|PRE_SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|ENABLED
argument_list|,
name|PRE_SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|DISABLED
argument_list|,
name|PRE_SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|PLUGIN
argument_list|,
name|PRE_SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SETUP
argument_list|,
name|SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|CLEANUP
argument_list|,
name|CLEANUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|THREAD
argument_list|,
name|THREAD_STATE
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|StateAction
argument_list|(
name|SETUP_STATE
argument_list|,
operator|new
name|StateDatum
index|[]
block|{
operator|new
name|StateDatum
argument_list|(
name|END
argument_list|,
name|POST_SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SQL
argument_list|,
name|SETUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|INCLUDE
argument_list|,
name|SETUP_STATE
argument_list|)
block|,           }
argument_list|)
block|,
operator|new
name|StateAction
argument_list|(
name|POST_SETUP_STATE
argument_list|,
operator|new
name|StateDatum
index|[]
block|{
operator|new
name|StateDatum
argument_list|(
name|CLEANUP
argument_list|,
name|CLEANUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|THREAD
argument_list|,
name|THREAD_STATE
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|StateAction
argument_list|(
name|CLEANUP_STATE
argument_list|,
operator|new
name|StateDatum
index|[]
block|{
operator|new
name|StateDatum
argument_list|(
name|END
argument_list|,
name|POST_CLEANUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SQL
argument_list|,
name|CLEANUP_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|INCLUDE
argument_list|,
name|CLEANUP_STATE
argument_list|)
block|,           }
argument_list|)
block|,
operator|new
name|StateAction
argument_list|(
name|POST_CLEANUP_STATE
argument_list|,
operator|new
name|StateDatum
index|[]
block|{
operator|new
name|StateDatum
argument_list|(
name|THREAD
argument_list|,
name|THREAD_STATE
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|StateAction
argument_list|(
name|THREAD_STATE
argument_list|,
operator|new
name|StateDatum
index|[]
block|{
operator|new
name|StateDatum
argument_list|(
name|REPEAT
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SYNC
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|TIMEOUT
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|ROWLIMIT
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|PREPARE
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|PRINT
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|FETCH
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|CLOSE
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SLEEP
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SQL
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|ECHO
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|ERR
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SHELL
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|END
argument_list|,
name|POST_THREAD_STATE
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|StateAction
argument_list|(
name|REPEAT_STATE
argument_list|,
operator|new
name|StateDatum
index|[]
block|{
operator|new
name|StateDatum
argument_list|(
name|SYNC
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|TIMEOUT
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|ROWLIMIT
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|PREPARE
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|PRINT
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|FETCH
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|CLOSE
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SLEEP
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SQL
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|ECHO
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|ERR
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|SHELL
argument_list|,
name|REPEAT_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|END
argument_list|,
name|THREAD_STATE
argument_list|)
block|}
argument_list|)
block|,
operator|new
name|StateAction
argument_list|(
name|POST_THREAD_STATE
argument_list|,
operator|new
name|StateDatum
index|[]
block|{
operator|new
name|StateDatum
argument_list|(
name|THREAD
argument_list|,
name|THREAD_STATE
argument_list|)
block|,
operator|new
name|StateDatum
argument_list|(
name|EOF
argument_list|,
name|EOF_STATE
argument_list|)
block|}
argument_list|)
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|FETCH_LEN
init|=
name|FETCH
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PREPARE_LEN
init|=
name|PREPARE
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PRINT_LEN
init|=
name|PRINT
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|REPEAT_LEN
init|=
name|REPEAT
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SLEEP_LEN
init|=
name|SLEEP
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|THREAD_LEN
init|=
name|THREAD
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|TIMEOUT_LEN
init|=
name|TIMEOUT
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ROWLIMIT_LEN
init|=
name|ROWLIMIT
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ERR_LEN
init|=
name|ERR
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ECHO_LEN
init|=
name|ECHO
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SHELL_LEN
init|=
name|SHELL
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PLUGIN_LEN
init|=
name|PLUGIN
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|INCLUDE_LEN
init|=
name|INCLUDE
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|VAR_LEN
init|=
name|VAR
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|spaces
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|dashes
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|BUF_SIZE
init|=
literal|1024
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|REPEAT_READ_AHEAD_LIMIT
init|=
literal|65536
decl_stmt|;
static|static
block|{
name|spaces
operator|=
operator|new
name|char
index|[
name|BUF_SIZE
index|]
expr_stmt|;
name|dashes
operator|=
operator|new
name|char
index|[
name|BUF_SIZE
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BUF_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|spaces
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|dashes
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
block|}
comment|// Special "thread ids" for setup& cleanup sections; actually setup&
comment|// cleanup SQL is executed by the main thread, and neither are in the the
comment|// thread map.
specifier|private
specifier|static
specifier|final
name|Integer
name|SETUP_THREAD_ID
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Integer
name|CLEANUP_THREAD_ID
init|=
operator|-
literal|2
decl_stmt|;
comment|//~ Instance fields (representing a single script):
specifier|private
name|boolean
name|quiet
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|verbose
init|=
literal|false
decl_stmt|;
specifier|private
name|Boolean
name|lockstep
decl_stmt|;
specifier|private
name|Boolean
name|disabled
decl_stmt|;
specifier|private
name|VariableTable
name|vars
init|=
operator|new
name|VariableTable
argument_list|()
decl_stmt|;
specifier|private
name|File
name|scriptDirectory
decl_stmt|;
specifier|private
name|long
name|scriptStartTime
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|ConcurrentTestPlugin
argument_list|>
name|plugins
init|=
operator|new
name|ArrayList
argument_list|<
name|ConcurrentTestPlugin
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ConcurrentTestPlugin
argument_list|>
name|pluginForCommand
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ConcurrentTestPlugin
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ConcurrentTestPlugin
argument_list|>
name|preSetupPluginForCommand
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ConcurrentTestPlugin
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|setupCommands
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|cleanupCommands
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|BufferedWriter
argument_list|>
name|threadBufferedWriters
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|BufferedWriter
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|StringWriter
argument_list|>
name|threadStringWriters
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|StringWriter
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|ResultsReader
argument_list|>
name|threadResultsReaders
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ResultsReader
argument_list|>
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|ConcurrentTestCommandScript
parameter_list|()
throws|throws
name|IOException
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**    * Constructs and prepares a new ConcurrentTestCommandScript.    */
specifier|public
name|ConcurrentTestCommandScript
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|()
expr_stmt|;
name|prepare
argument_list|(
name|filename
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Gets ready to execute: loads script FILENAME applying external variable    * BINDINGS    */
specifier|private
name|void
name|prepare
parameter_list|(
name|String
name|filename
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|bindings
parameter_list|)
throws|throws
name|IOException
block|{
name|vars
operator|=
operator|new
name|VariableTable
argument_list|()
expr_stmt|;
name|CommandParser
name|parser
init|=
operator|new
name|CommandParser
argument_list|()
decl_stmt|;
name|parser
operator|.
name|rememberVariableRebindings
argument_list|(
name|bindings
argument_list|)
expr_stmt|;
name|parser
operator|.
name|load
argument_list|(
name|filename
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|threadId
range|:
name|getThreadIds
argument_list|()
control|)
block|{
name|addThreadWriters
argument_list|(
name|threadId
argument_list|)
expr_stmt|;
block|}
comment|// Backwards compatible: printed results always has a setup section, but
comment|// cleanup section is optional:
name|setThreadName
argument_list|(
name|SETUP_THREAD_ID
argument_list|,
literal|"setup"
argument_list|)
expr_stmt|;
name|addThreadWriters
argument_list|(
name|SETUP_THREAD_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cleanupCommands
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setThreadName
argument_list|(
name|CLEANUP_THREAD_ID
argument_list|,
literal|"cleanup"
argument_list|)
expr_stmt|;
name|addThreadWriters
argument_list|(
name|CLEANUP_THREAD_ID
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Executes the script    */
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|Exception
block|{
name|scriptStartTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|executeSetup
argument_list|()
expr_stmt|;
name|ConcurrentTestCommandExecutor
name|threads
index|[]
init|=
name|innerExecute
argument_list|()
decl_stmt|;
name|executeCleanup
argument_list|()
expr_stmt|;
name|postExecute
argument_list|(
name|threads
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addThreadWriters
parameter_list|(
name|Integer
name|threadId
parameter_list|)
block|{
name|StringWriter
name|w
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|BufferedWriter
name|bw
init|=
operator|new
name|BufferedWriter
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|threadStringWriters
operator|.
name|put
argument_list|(
name|threadId
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|threadBufferedWriters
operator|.
name|put
argument_list|(
name|threadId
argument_list|,
name|bw
argument_list|)
expr_stmt|;
name|threadResultsReaders
operator|.
name|put
argument_list|(
name|threadId
argument_list|,
operator|new
name|ResultsReader
argument_list|(
name|bw
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setQuiet
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|quiet
operator|=
name|val
expr_stmt|;
block|}
specifier|public
name|void
name|setVerbose
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|verbose
operator|=
name|val
expr_stmt|;
block|}
specifier|public
name|boolean
name|useLockstep
parameter_list|()
block|{
if|if
condition|(
name|lockstep
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|lockstep
operator|.
name|booleanValue
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isDisabled
parameter_list|()
block|{
for|for
control|(
name|ConcurrentTestPlugin
name|plugin
range|:
name|plugins
control|)
block|{
if|if
condition|(
name|plugin
operator|.
name|isTestDisabled
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|disabled
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|disabled
operator|.
name|booleanValue
argument_list|()
return|;
block|}
specifier|public
name|void
name|executeSetup
parameter_list|()
throws|throws
name|Exception
block|{
name|executeCommands
argument_list|(
name|SETUP_THREAD_ID
argument_list|,
name|setupCommands
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|executeCleanup
parameter_list|()
throws|throws
name|Exception
block|{
name|executeCommands
argument_list|(
name|CLEANUP_THREAD_ID
argument_list|,
name|cleanupCommands
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|executeCommands
parameter_list|(
name|int
name|threadID
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|commands
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|(
name|commands
operator|==
literal|null
operator|)
operator|||
operator|(
name|commands
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
name|Connection
name|connection
init|=
name|DriverManager
operator|.
name|getConnection
argument_list|(
name|jdbcURL
argument_list|,
name|jdbcProps
argument_list|)
decl_stmt|;
if|if
condition|(
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|supportsTransactions
argument_list|()
condition|)
block|{
name|connection
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|boolean
name|forced
init|=
literal|false
decl_stmt|;
comment|// flag, keep going after an error
try|try
block|{
for|for
control|(
name|String
name|command
range|:
name|commands
control|)
block|{
name|String
name|sql
init|=
operator|(
name|command
operator|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|storeSql
argument_list|(
name|threadID
argument_list|,
name|sql
argument_list|)
expr_stmt|;
if|if
condition|(
name|isComment
argument_list|(
name|sql
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// handle sqlline-type directives:
if|if
condition|(
name|sql
operator|.
name|startsWith
argument_list|(
literal|"!set"
argument_list|)
condition|)
block|{
name|String
index|[]
name|tokens
init|=
name|sql
operator|.
name|split
argument_list|(
literal|" +"
argument_list|)
decl_stmt|;
comment|// handle only SET FORCE
if|if
condition|(
operator|(
name|tokens
operator|.
name|length
operator|>
literal|2
operator|)
operator|&&
name|tokens
index|[
literal|1
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"force"
argument_list|)
condition|)
block|{
name|forced
operator|=
name|asBoolValue
argument_list|(
name|tokens
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|// else ignore
block|}
if|else if
condition|(
name|sql
operator|.
name|startsWith
argument_list|(
literal|"!"
argument_list|)
condition|)
block|{
continue|continue;
comment|// else ignore
block|}
if|if
condition|(
name|sql
operator|.
name|endsWith
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
name|sql
operator|=
name|sql
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sql
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isSelect
argument_list|(
name|sql
argument_list|)
condition|)
block|{
name|Statement
name|stmt
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
try|try
block|{
name|ResultSet
name|rset
init|=
name|stmt
operator|.
name|executeQuery
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|storeResults
argument_list|(
name|threadID
argument_list|,
name|rset
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|sql
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"commit"
argument_list|)
condition|)
block|{
name|connection
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
if|else if
condition|(
name|sql
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"rollback"
argument_list|)
condition|)
block|{
name|connection
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Statement
name|stmt
init|=
name|connection
operator|.
name|createStatement
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|rows
init|=
name|stmt
operator|.
name|executeUpdate
argument_list|(
name|sql
argument_list|)
decl_stmt|;
if|if
condition|(
name|rows
operator|!=
literal|1
condition|)
block|{
name|storeMessage
argument_list|(
name|threadID
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|rows
argument_list|)
operator|+
literal|" rows affected."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storeMessage
argument_list|(
name|threadID
argument_list|,
literal|"1 row affected."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SQLException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|forced
condition|)
block|{
name|storeMessage
argument_list|(
name|threadID
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// swallow
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|connection
operator|.
name|getMetaData
argument_list|()
operator|.
name|supportsTransactions
argument_list|()
condition|)
block|{
name|connection
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// timeout< 0 means no timeout
specifier|private
name|void
name|storeResults
parameter_list|(
name|Integer
name|threadId
parameter_list|,
name|ResultSet
name|rset
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|SQLException
block|{
name|ResultsReader
name|r
init|=
name|threadResultsReaders
operator|.
name|get
argument_list|(
name|threadId
argument_list|)
decl_stmt|;
name|r
operator|.
name|read
argument_list|(
name|rset
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/**    * Identifies the start of a comment line; same rules as sqlline    */
specifier|private
name|boolean
name|isComment
parameter_list|(
name|String
name|line
parameter_list|)
block|{
return|return
name|line
operator|.
name|startsWith
argument_list|(
literal|"--"
argument_list|)
operator|||
name|line
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
return|;
block|}
comment|/**    * translates argument of !set force etc.    */
specifier|private
name|boolean
name|asBoolValue
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|s
operator|=
name|s
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
return|return
name|s
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
operator|||
name|s
operator|.
name|equals
argument_list|(
literal|"yes"
argument_list|)
operator|||
name|s
operator|.
name|equals
argument_list|(
literal|"on"
argument_list|)
return|;
block|}
comment|/**    * Determines if a block of SQL is a select statment or not.    */
specifier|private
name|boolean
name|isSelect
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|BufferedReader
name|rdr
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|StringReader
argument_list|(
name|sql
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|rdr
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|isComment
argument_list|(
name|line
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"select"
argument_list|)
operator|||
name|line
operator|.
name|startsWith
argument_list|(
literal|"values"
argument_list|)
operator|||
name|line
operator|.
name|startsWith
argument_list|(
literal|"explain"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
assert|assert
operator|(
literal|false
operator|)
operator|:
literal|"IOException via StringReader"
assert|;
block|}
finally|finally
block|{
try|try
block|{
name|rdr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
assert|assert
operator|(
literal|false
operator|)
operator|:
literal|"IOException via StringReader"
assert|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Builds a map of thread ids to result data for the thread. Each result    * datum is an<code>String[2]</code> containing the thread name and the    * thread's output.    *    * @return the map.    */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
index|[]
argument_list|>
name|collectResults
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|// get all normal threads
name|TreeSet
argument_list|<
name|Integer
argument_list|>
name|threadIds
init|=
operator|new
name|TreeSet
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|getThreadIds
argument_list|()
argument_list|)
decl_stmt|;
comment|// add the "special threads"
name|threadIds
operator|.
name|add
argument_list|(
name|SETUP_THREAD_ID
argument_list|)
expr_stmt|;
name|threadIds
operator|.
name|add
argument_list|(
name|CLEANUP_THREAD_ID
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|threadId
range|:
name|threadIds
control|)
block|{
try|try
block|{
name|BufferedWriter
name|bout
init|=
name|threadBufferedWriters
operator|.
name|get
argument_list|(
name|threadId
argument_list|)
decl_stmt|;
if|if
condition|(
name|bout
operator|!=
literal|null
condition|)
block|{
name|bout
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
assert|assert
operator|(
literal|false
operator|)
operator|:
literal|"IOException via StringWriter"
assert|;
block|}
name|String
name|threadName
init|=
name|getFormattedThreadName
argument_list|(
name|threadId
argument_list|)
decl_stmt|;
name|StringWriter
name|out
init|=
name|threadStringWriters
operator|.
name|get
argument_list|(
name|threadId
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|results
operator|.
name|put
argument_list|(
name|threadId
argument_list|,
operator|new
name|String
index|[]
block|{
name|threadName
block|,
name|out
operator|.
name|toString
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|// solely for backwards-compatible output
specifier|private
name|String
name|getFormattedThreadName
parameter_list|(
name|Integer
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|<
literal|0
condition|)
block|{
comment|// special thread
return|return
name|getThreadName
argument_list|(
name|id
argument_list|)
return|;
block|}
else|else
block|{
comment|// normal thread
return|return
literal|"thread "
operator|+
name|getThreadName
argument_list|(
name|id
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|printResults
parameter_list|(
name|BufferedWriter
name|out
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
index|[]
argument_list|>
name|results
init|=
name|collectResults
argument_list|()
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"script execution started at %tc (%d)%n"
argument_list|,
operator|new
name|Timestamp
argument_list|(
name|scriptStartTime
argument_list|)
argument_list|,
name|scriptStartTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printThreadResults
argument_list|(
name|out
argument_list|,
name|results
operator|.
name|get
argument_list|(
name|SETUP_THREAD_ID
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|id
range|:
name|results
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|id
operator|<
literal|0
condition|)
block|{
continue|continue;
comment|// special thread
block|}
name|printThreadResults
argument_list|(
name|out
argument_list|,
name|results
operator|.
name|get
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|// normal thread
block|}
name|printThreadResults
argument_list|(
name|out
argument_list|,
name|results
operator|.
name|get
argument_list|(
name|CLEANUP_THREAD_ID
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|printThreadResults
parameter_list|(
name|BufferedWriter
name|out
parameter_list|,
name|String
index|[]
name|threadResult
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|threadResult
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|threadName
init|=
name|threadResult
index|[
literal|0
index|]
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|"-- "
operator|+
name|threadName
argument_list|)
expr_stmt|;
name|out
operator|.
name|newLine
argument_list|()
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|threadResult
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|"-- end of "
operator|+
name|threadName
argument_list|)
expr_stmt|;
name|out
operator|.
name|newLine
argument_list|()
expr_stmt|;
name|out
operator|.
name|newLine
argument_list|()
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Causes errors to be send here for custom handling. See {@link    * #customErrorHandler(ConcurrentTestCommandExecutor)}.    */
name|boolean
name|requiresCustomErrorHandling
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
name|void
name|customErrorHandler
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Throwable
name|cause
init|=
name|executor
operator|.
name|getFailureCause
argument_list|()
decl_stmt|;
name|ConcurrentTestCommand
name|command
init|=
name|executor
operator|.
name|getFailureCommand
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|command
operator|==
literal|null
operator|)
operator|||
operator|!
name|command
operator|.
name|isFailureExpected
argument_list|()
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|cause
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|StackTraceElement
index|[]
name|trace
init|=
name|cause
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
for|for
control|(
name|StackTraceElement
name|aTrace
range|:
name|trace
control|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|"\n\t"
argument_list|)
operator|.
name|append
argument_list|(
name|aTrace
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|cause
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
operator|.
name|append
argument_list|(
name|cause
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|storeMessage
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|message
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Retrieves the output stream for the given thread id.    *    * @return a BufferedWriter on a StringWriter for the thread.    */
specifier|private
name|BufferedWriter
name|getThreadWriter
parameter_list|(
name|Integer
name|threadId
parameter_list|)
block|{
assert|assert
operator|(
name|threadBufferedWriters
operator|.
name|containsKey
argument_list|(
name|threadId
argument_list|)
operator|)
assert|;
return|return
name|threadBufferedWriters
operator|.
name|get
argument_list|(
name|threadId
argument_list|)
return|;
block|}
comment|/**    * Saves a SQL command to be printed with the thread's output.    */
specifier|private
name|void
name|storeSql
parameter_list|(
name|Integer
name|threadId
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|BufferedReader
name|rdr
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|StringReader
argument_list|(
name|sql
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|rdr
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|message
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|append
argument_list|(
literal|"> "
argument_list|)
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
assert|assert
operator|(
literal|false
operator|)
operator|:
literal|"IOException via StringReader"
assert|;
block|}
finally|finally
block|{
try|try
block|{
name|rdr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
assert|assert
operator|(
literal|false
operator|)
operator|:
literal|"IOException via StringReader"
assert|;
block|}
block|}
name|storeMessage
argument_list|(
name|threadId
argument_list|,
name|message
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Saves a message to be printed with the thread's output.    */
specifier|private
name|void
name|storeMessage
parameter_list|(
name|Integer
name|threadId
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|BufferedWriter
name|out
init|=
name|getThreadWriter
argument_list|(
name|threadId
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|long
name|t
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|scriptStartTime
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
literal|"at "
operator|+
name|t
operator|+
literal|": "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|out
operator|.
name|newLine
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
assert|assert
operator|(
literal|false
operator|)
operator|:
literal|"IOException on StringWriter"
assert|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|private
specifier|static
class|class
name|StateAction
block|{
specifier|final
name|String
name|state
decl_stmt|;
specifier|final
name|StateDatum
index|[]
name|stateData
decl_stmt|;
name|StateAction
parameter_list|(
name|String
name|state
parameter_list|,
name|StateDatum
index|[]
name|stateData
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|stateData
operator|=
name|stateData
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|StateDatum
block|{
specifier|final
name|String
name|x
decl_stmt|;
specifier|final
name|String
name|y
decl_stmt|;
name|StateDatum
parameter_list|(
name|String
name|x
parameter_list|,
name|String
name|y
parameter_list|)
block|{
name|this
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|this
operator|.
name|y
operator|=
name|y
expr_stmt|;
block|}
block|}
comment|// Inner Class: a symbol table of script variables
specifier|private
class|class
name|VariableTable
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
decl_stmt|;
comment|// matches $$, $var, ${var}
specifier|private
specifier|final
name|Pattern
name|symbolPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\$((\\$)|([A-Za-z]\\w*)|\\{([A-Za-z]\\w*)\\})"
argument_list|)
decl_stmt|;
specifier|public
name|VariableTable
parameter_list|()
block|{
name|map
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
specifier|public
class|class
name|Excn
extends|extends
name|IllegalArgumentException
block|{
specifier|public
name|Excn
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isDefined
parameter_list|(
name|String
name|sym
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|sym
argument_list|)
return|;
block|}
comment|// a symbol must be explicitly defined before it can be set or read.
specifier|public
name|void
name|define
parameter_list|(
name|String
name|sym
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|Excn
block|{
if|if
condition|(
name|isDefined
argument_list|(
name|sym
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Excn
argument_list|(
literal|"second declaration of variable "
operator|+
name|sym
argument_list|)
throw|;
block|}
comment|// convert a null val to a null string
name|map
operator|.
name|put
argument_list|(
name|sym
argument_list|,
operator|(
name|val
operator|==
literal|null
condition|?
literal|""
else|:
name|val
operator|)
argument_list|)
expr_stmt|;
block|}
comment|// returns null is SYM is not defined
specifier|public
name|String
name|get
parameter_list|(
name|String
name|sym
parameter_list|)
block|{
if|if
condition|(
name|isDefined
argument_list|(
name|sym
argument_list|)
condition|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|sym
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|void
name|set
parameter_list|(
name|String
name|sym
parameter_list|,
name|String
name|val
parameter_list|)
throws|throws
name|Excn
block|{
if|if
condition|(
name|isDefined
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|sym
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
throw|throw
operator|new
name|Excn
argument_list|(
literal|"undeclared variable "
operator|+
name|sym
argument_list|)
throw|;
block|}
specifier|public
name|String
name|expand
parameter_list|(
name|String
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|.
name|contains
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
name|StringBuffer
name|out
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|Matcher
name|matcher
init|=
name|symbolPattern
operator|.
name|matcher
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|int
name|lastEnd
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|int
name|start
init|=
name|matcher
operator|.
name|start
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|matcher
operator|.
name|end
argument_list|()
decl_stmt|;
name|String
name|val
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|val
operator|=
literal|"$"
expr_stmt|;
comment|// matched $$
block|}
else|else
block|{
name|String
name|var
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|3
argument_list|)
decl_stmt|;
comment|// matched $var
if|if
condition|(
name|var
operator|==
literal|null
condition|)
block|{
name|var
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|// matched ${var}
block|}
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|val
operator|=
name|map
operator|.
name|get
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// not our var, so can't expand
name|val
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|lastEnd
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|append
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|lastEnd
operator|=
name|end
expr_stmt|;
block|}
name|out
operator|.
name|append
argument_list|(
name|in
operator|.
name|substring
argument_list|(
name|lastEnd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|in
return|;
block|}
block|}
block|}
comment|// Inner Class: the command parser
specifier|private
class|class
name|CommandParser
block|{
specifier|final
name|Pattern
name|splitWords
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s+"
argument_list|)
decl_stmt|;
specifier|final
name|Pattern
name|splitBinding
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
specifier|final
name|Pattern
name|matchesVarDefn
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([A-Za-z]\\w*) *=(.*)$"
argument_list|)
decl_stmt|;
comment|// \1 is VAR, \2 is VAL
comment|// parser state
specifier|private
name|String
name|state
decl_stmt|;
specifier|private
name|int
name|threadId
decl_stmt|;
specifier|private
name|int
name|nextThreadId
decl_stmt|;
specifier|private
name|int
name|order
decl_stmt|;
specifier|private
name|int
name|repeatCount
decl_stmt|;
specifier|private
name|boolean
name|scriptHasVars
decl_stmt|;
specifier|private
name|Stack
argument_list|<
name|File
argument_list|>
name|currentDirectory
init|=
operator|new
name|Stack
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
class|class
name|Binding
block|{
specifier|public
specifier|final
name|String
name|var
decl_stmt|;
specifier|public
specifier|final
name|String
name|val
decl_stmt|;
specifier|public
name|Binding
parameter_list|(
name|String
name|var
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|this
operator|.
name|var
operator|=
name|var
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
block|}
comment|// @param phrase has form VAR=VAL
specifier|public
name|Binding
parameter_list|(
name|String
name|phrase
parameter_list|)
block|{
name|String
index|[]
name|parts
init|=
name|splitBinding
operator|.
name|split
argument_list|(
name|phrase
argument_list|)
decl_stmt|;
assert|assert
name|parts
operator|.
name|length
operator|==
literal|2
assert|;
name|this
operator|.
name|var
operator|=
name|parts
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|parts
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|// A list of Bindings that must be applied immediately after parsing
comment|// last @var.
specifier|private
name|List
argument_list|<
name|Binding
argument_list|>
name|deferredBindings
init|=
operator|new
name|ArrayList
argument_list|<
name|Binding
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|CommandParser
parameter_list|()
block|{
name|state
operator|=
name|PRE_SETUP_STATE
expr_stmt|;
name|threadId
operator|=
name|nextThreadId
operator|=
literal|1
expr_stmt|;
name|order
operator|=
literal|1
expr_stmt|;
name|repeatCount
operator|=
literal|0
expr_stmt|;
name|scriptHasVars
operator|=
literal|false
expr_stmt|;
name|currentDirectory
operator|.
name|push
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Parses a set of VAR=VAL pairs from the command line, and saves it for
comment|// later application.
specifier|public
name|void
name|rememberVariableRebindings
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|pairs
parameter_list|)
block|{
if|if
condition|(
name|pairs
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|String
name|pair
range|:
name|pairs
control|)
block|{
name|deferredBindings
operator|.
name|add
argument_list|(
operator|new
name|Binding
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// to call after all @var commands but before any SQL.
specifier|private
name|void
name|applyVariableRebindings
parameter_list|()
block|{
for|for
control|(
name|Binding
name|binding
range|:
name|deferredBindings
control|)
block|{
name|vars
operator|.
name|set
argument_list|(
name|binding
operator|.
name|var
argument_list|,
name|binding
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|// trace loading of a script
specifier|private
name|void
name|trace
parameter_list|(
name|String
name|prefix
parameter_list|,
name|Object
name|message
parameter_list|)
block|{
if|if
condition|(
name|verbose
operator|&&
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|prefix
operator|+
literal|": "
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|trace
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|trace
argument_list|(
literal|null
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parses a multi-threaded script and converts it into test commands.      */
specifier|private
name|void
name|load
parameter_list|(
name|String
name|scriptFileName
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|scriptFile
init|=
operator|new
name|File
argument_list|(
name|currentDirectory
operator|.
name|peek
argument_list|()
argument_list|,
name|scriptFileName
argument_list|)
decl_stmt|;
name|currentDirectory
operator|.
name|push
argument_list|(
name|scriptDirectory
operator|=
name|scriptFile
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|scriptFile
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|commandStateMap
init|=
name|lookupState
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|String
name|command
init|=
literal|null
decl_stmt|;
name|boolean
name|isSql
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|||
name|line
operator|.
name|startsWith
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|else if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"@"
argument_list|)
condition|)
block|{
name|command
operator|=
name|firstWord
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isSql
operator|=
literal|true
expr_stmt|;
name|command
operator|=
name|SQL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|commandStateMap
operator|.
name|containsKey
argument_list|(
name|command
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|command
operator|+
literal|" not allowed in state "
operator|+
name|state
argument_list|)
throw|;
block|}
name|boolean
name|changeState
decl_stmt|;
if|if
condition|(
name|isSql
condition|)
block|{
name|String
name|sql
init|=
name|readSql
argument_list|(
name|line
argument_list|,
name|in
argument_list|)
decl_stmt|;
name|loadSql
argument_list|(
name|sql
argument_list|)
expr_stmt|;
name|changeState
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|changeState
operator|=
name|loadCommand
argument_list|(
name|command
argument_list|,
name|line
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changeState
condition|)
block|{
name|String
name|nextState
init|=
name|commandStateMap
operator|.
name|get
argument_list|(
name|command
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|nextState
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
operator|!
name|nextState
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|doEndOfState
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|nextState
expr_stmt|;
block|}
block|}
comment|// at EOF
name|currentDirectory
operator|.
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentDirectory
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// at top EOF
if|if
condition|(
operator|!
name|lookupState
argument_list|(
name|state
argument_list|)
operator|.
name|containsKey
argument_list|(
name|EOF
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Premature end of file in '"
operator|+
name|state
operator|+
literal|"' state"
argument_list|)
throw|;
block|}
block|}
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|loadSql
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
if|if
condition|(
name|SETUP_STATE
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"@setup"
argument_list|,
name|sql
argument_list|)
expr_stmt|;
name|setupCommands
operator|.
name|add
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|CLEANUP_STATE
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"@cleanup"
argument_list|,
name|sql
argument_list|)
expr_stmt|;
name|cleanupCommands
operator|.
name|add
argument_list|(
name|sql
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|THREAD_STATE
operator|.
name|equals
argument_list|(
name|state
argument_list|)
operator|||
name|REPEAT_STATE
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|boolean
name|isSelect
init|=
name|isSelect
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|trace
argument_list|(
name|sql
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|CommandWithTimeout
name|cmd
init|=
name|isSelect
condition|?
operator|new
name|SelectCommand
argument_list|(
name|sql
argument_list|)
else|:
operator|new
name|SqlCommand
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
block|}
comment|// returns TRUE when load-state should advance, FALSE when it must not.
specifier|private
name|boolean
name|loadCommand
parameter_list|(
name|String
name|command
parameter_list|,
name|String
name|line
parameter_list|,
name|BufferedReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|VAR
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|args
init|=
name|line
operator|.
name|substring
argument_list|(
name|VAR_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|scriptHasVars
operator|=
literal|true
expr_stmt|;
name|trace
argument_list|(
literal|"@var"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|defineVariables
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|LOCKSTEP
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
assert|assert
operator|(
name|lockstep
operator|==
literal|null
operator|)
operator|:
name|LOCKSTEP
operator|+
literal|" and "
operator|+
name|NOLOCKSTEP
operator|+
literal|" may only appear once"
assert|;
name|lockstep
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
name|trace
argument_list|(
literal|"lockstep"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|NOLOCKSTEP
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
assert|assert
operator|(
name|lockstep
operator|==
literal|null
operator|)
operator|:
name|LOCKSTEP
operator|+
literal|" and "
operator|+
name|NOLOCKSTEP
operator|+
literal|" may only appear once"
assert|;
name|lockstep
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
name|trace
argument_list|(
literal|"no lockstep"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|DISABLED
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
assert|assert
operator|(
name|disabled
operator|==
literal|null
operator|)
operator|:
name|DISABLED
operator|+
literal|" and "
operator|+
name|ENABLED
operator|+
literal|" may only appear once"
assert|;
name|disabled
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
name|trace
argument_list|(
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|ENABLED
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
assert|assert
operator|(
name|disabled
operator|==
literal|null
operator|)
operator|:
name|DISABLED
operator|+
literal|" and "
operator|+
name|ENABLED
operator|+
literal|" may only appear once"
assert|;
name|disabled
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
name|trace
argument_list|(
literal|"enabled"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|SETUP
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"@setup"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|CLEANUP
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"@cleanup"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|INCLUDE
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|includedFile
init|=
name|vars
operator|.
name|expand
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|INCLUDE_LEN
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|trace
argument_list|(
literal|"@include"
argument_list|,
name|includedFile
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|includedFile
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|"end @include"
argument_list|,
name|includedFile
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|THREAD
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|threadNamesStr
init|=
name|line
operator|.
name|substring
argument_list|(
name|THREAD_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|trace
argument_list|(
literal|"@thread"
argument_list|,
name|threadNamesStr
argument_list|)
expr_stmt|;
name|StringTokenizer
name|threadNamesTok
init|=
operator|new
name|StringTokenizer
argument_list|(
name|threadNamesStr
argument_list|,
literal|","
argument_list|)
decl_stmt|;
while|while
condition|(
name|threadNamesTok
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|setThreadName
argument_list|(
name|nextThreadId
operator|++
argument_list|,
name|threadNamesTok
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|REPEAT
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|arg
init|=
name|line
operator|.
name|substring
argument_list|(
name|REPEAT_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|repeatCount
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|vars
operator|.
name|expand
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|"start @repeat block"
argument_list|,
name|repeatCount
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|repeatCount
operator|>
literal|0
operator|)
operator|:
literal|"Repeat count must be> 0"
assert|;
name|in
operator|.
name|mark
argument_list|(
name|REPEAT_READ_AHEAD_LIMIT
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|END
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
if|if
condition|(
name|SETUP_STATE
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"end @setup"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|CLEANUP_STATE
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"end @cleanup"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|THREAD_STATE
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|threadId
operator|=
name|nextThreadId
expr_stmt|;
block|}
if|else if
condition|(
name|REPEAT_STATE
operator|.
name|equals
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"repeating"
argument_list|)
expr_stmt|;
name|repeatCount
operator|--
expr_stmt|;
if|if
condition|(
name|repeatCount
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to reset reader -- repeat "
operator|+
literal|"contents must be less than "
operator|+
name|REPEAT_READ_AHEAD_LIMIT
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
name|trace
argument_list|(
literal|"end @repeat block"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// don't change the state
block|}
block|}
else|else
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
block|}
if|else if
condition|(
name|SYNC
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"@sync"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addSynchronizationCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|TIMEOUT
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|args
init|=
name|line
operator|.
name|substring
argument_list|(
name|TIMEOUT_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|millisStr
init|=
name|vars
operator|.
name|expand
argument_list|(
name|firstWord
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|millis
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|millisStr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|millis
operator|>=
literal|0L
operator|)
operator|:
literal|"Timeout must be>= 0"
assert|;
name|String
name|sql
init|=
name|readSql
argument_list|(
name|skipFirstWord
argument_list|(
name|args
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|,
name|in
argument_list|)
decl_stmt|;
name|trace
argument_list|(
literal|"@timeout"
argument_list|,
name|sql
argument_list|)
expr_stmt|;
name|boolean
name|isSelect
init|=
name|isSelect
argument_list|(
name|sql
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|CommandWithTimeout
name|cmd
init|=
name|isSelect
condition|?
operator|new
name|SelectCommand
argument_list|(
name|sql
argument_list|,
name|millis
argument_list|)
else|:
operator|new
name|SqlCommand
argument_list|(
name|sql
argument_list|,
name|millis
argument_list|)
decl_stmt|;
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|ROWLIMIT
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|args
init|=
name|line
operator|.
name|substring
argument_list|(
name|ROWLIMIT_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|limitStr
init|=
name|vars
operator|.
name|expand
argument_list|(
name|firstWord
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|limitStr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|limit
operator|>=
literal|0
operator|)
operator|:
literal|"Rowlimit must be>= 0"
assert|;
name|String
name|sql
init|=
name|readSql
argument_list|(
name|skipFirstWord
argument_list|(
name|args
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|,
name|in
argument_list|)
decl_stmt|;
name|trace
argument_list|(
literal|"@rowlimit "
argument_list|,
name|sql
argument_list|)
expr_stmt|;
name|boolean
name|isSelect
init|=
name|isSelect
argument_list|(
name|sql
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isSelect
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Only select can be used with rowlimit"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
operator|new
name|SelectCommand
argument_list|(
name|sql
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|PRINT
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|spec
init|=
name|vars
operator|.
name|expand
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|PRINT_LEN
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|trace
argument_list|(
literal|"@print"
argument_list|,
name|spec
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
operator|new
name|PrintCommand
argument_list|(
name|spec
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|PREPARE
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|startOfSql
init|=
name|line
operator|.
name|substring
argument_list|(
name|PREPARE_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
name|readSql
argument_list|(
name|startOfSql
argument_list|,
name|in
argument_list|)
decl_stmt|;
name|trace
argument_list|(
literal|"@prepare"
argument_list|,
name|sql
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
operator|new
name|PrepareCommand
argument_list|(
name|sql
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|PLUGIN
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|cmd
init|=
name|line
operator|.
name|substring
argument_list|(
name|PLUGIN_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|pluginName
init|=
name|readLine
argument_list|(
name|cmd
argument_list|,
name|in
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|trace
argument_list|(
literal|"@plugin"
argument_list|,
name|pluginName
argument_list|)
expr_stmt|;
name|plugin
argument_list|(
name|pluginName
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|pluginForCommand
operator|.
name|containsKey
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|cmd
init|=
name|line
operator|.
name|substring
argument_list|(
name|command
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|cmd
operator|=
name|readLine
argument_list|(
name|cmd
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|"@"
operator|+
name|command
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
operator|new
name|PluginCommand
argument_list|(
name|command
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|preSetupPluginForCommand
operator|.
name|containsKey
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|cmd
init|=
name|line
operator|.
name|substring
argument_list|(
name|command
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|cmd
operator|=
name|readLine
argument_list|(
name|cmd
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|"@"
operator|+
name|command
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ConcurrentTestPlugin
name|plugin
init|=
name|preSetupPluginForCommand
operator|.
name|get
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|plugin
operator|.
name|preSetupFor
argument_list|(
name|command
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|SHELL
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|cmd
init|=
name|line
operator|.
name|substring
argument_list|(
name|SHELL_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|cmd
operator|=
name|readLine
argument_list|(
name|cmd
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|"@shell"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
operator|new
name|ShellCommand
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|ECHO
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
name|line
operator|.
name|substring
argument_list|(
name|ECHO_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|msg
operator|=
name|readLine
argument_list|(
name|msg
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|trace
argument_list|(
literal|"@echo"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
operator|new
name|EchoCommand
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|ERR
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|startOfSql
init|=
name|line
operator|.
name|substring
argument_list|(
name|ERR_LEN
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
name|readSql
argument_list|(
name|startOfSql
argument_list|,
name|in
argument_list|)
decl_stmt|;
name|trace
argument_list|(
literal|"@err "
argument_list|,
name|sql
argument_list|)
expr_stmt|;
name|boolean
name|isSelect
init|=
name|isSelect
argument_list|(
name|sql
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|CommandWithTimeout
name|cmd
init|=
name|isSelect
condition|?
operator|new
name|SelectCommand
argument_list|(
name|sql
argument_list|,
literal|true
argument_list|)
else|:
operator|new
name|SqlCommand
argument_list|(
name|sql
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|FETCH
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|arg
init|=
name|vars
operator|.
name|expand
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|FETCH_LEN
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|trace
argument_list|(
literal|"@fetch"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|long
name|millis
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|millis
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|arg
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|millis
operator|>=
literal|0L
operator|)
operator|:
literal|"Fetch timeout must be>= 0"
assert|;
block|}
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
operator|new
name|FetchAndPrintCommand
argument_list|(
name|millis
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|CLOSE
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|trace
argument_list|(
literal|"@close"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addCloseCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|SLEEP
operator|.
name|equals
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|String
name|arg
init|=
name|vars
operator|.
name|expand
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|SLEEP_LEN
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|trace
argument_list|(
literal|"@sleep"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|long
name|millis
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|arg
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|millis
operator|>=
literal|0L
operator|)
operator|:
literal|"Sleep timeout must be>= 0"
assert|;
for|for
control|(
name|int
name|i
init|=
name|threadId
init|;
name|i
operator|<
name|nextThreadId
condition|;
name|i
operator|++
control|)
block|{
name|addSleepCommand
argument_list|(
name|i
argument_list|,
name|order
argument_list|,
name|millis
argument_list|)
expr_stmt|;
block|}
name|order
operator|++
expr_stmt|;
block|}
else|else
block|{
assert|assert
literal|false
operator|:
literal|"Unknown command "
operator|+
name|command
assert|;
block|}
return|return
literal|true
return|;
comment|// normally, advance the state
block|}
specifier|private
name|void
name|doEndOfState
parameter_list|(
name|String
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|.
name|equals
argument_list|(
name|PRE_SETUP_STATE
argument_list|)
condition|)
block|{
name|applyVariableRebindings
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|defineVariables
parameter_list|(
name|String
name|line
parameter_list|)
block|{
comment|// two forms: "VAR VAR*" and "VAR=VAL$"
name|Matcher
name|varDefn
init|=
name|matchesVarDefn
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|varDefn
operator|.
name|lookingAt
argument_list|()
condition|)
block|{
name|String
name|var
init|=
name|varDefn
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|val
init|=
name|varDefn
operator|.
name|group
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|vars
operator|.
name|define
argument_list|(
name|var
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|words
init|=
name|splitWords
operator|.
name|split
argument_list|(
name|line
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|var
range|:
name|words
control|)
block|{
name|String
name|value
init|=
name|System
operator|.
name|getenv
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|vars
operator|.
name|define
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|plugin
parameter_list|(
name|String
name|pluginName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|pluginClass
init|=
name|Class
operator|.
name|forName
argument_list|(
name|pluginName
argument_list|)
decl_stmt|;
name|ConcurrentTestPlugin
name|plugin
init|=
operator|(
name|ConcurrentTestPlugin
operator|)
name|pluginClass
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|plugins
operator|.
name|add
argument_list|(
name|plugin
argument_list|)
expr_stmt|;
name|addExtraCommands
argument_list|(
name|plugin
operator|.
name|getSupportedThreadCommands
argument_list|()
argument_list|,
name|THREAD_STATE
argument_list|)
expr_stmt|;
name|addExtraCommands
argument_list|(
name|plugin
operator|.
name|getSupportedThreadCommands
argument_list|()
argument_list|,
name|REPEAT_STATE
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|commandName
range|:
name|plugin
operator|.
name|getSupportedThreadCommands
argument_list|()
control|)
block|{
name|pluginForCommand
operator|.
name|put
argument_list|(
name|commandName
argument_list|,
name|plugin
argument_list|)
expr_stmt|;
block|}
name|addExtraCommands
argument_list|(
name|plugin
operator|.
name|getSupportedPreSetupCommands
argument_list|()
argument_list|,
name|PRE_SETUP_STATE
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|commandName
range|:
name|plugin
operator|.
name|getSupportedPreSetupCommands
argument_list|()
control|)
block|{
name|preSetupPluginForCommand
operator|.
name|put
argument_list|(
name|commandName
argument_list|,
name|plugin
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|addExtraCommands
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|commands
parameter_list|,
name|String
name|state
parameter_list|)
block|{
assert|assert
operator|(
name|state
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|STATE_TABLE
operator|.
name|length
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|state
operator|.
name|equals
argument_list|(
name|STATE_TABLE
index|[
name|i
index|]
operator|.
name|state
argument_list|)
condition|)
block|{
name|StateDatum
index|[]
name|stateData
init|=
name|STATE_TABLE
index|[
name|i
index|]
operator|.
name|stateData
decl_stmt|;
name|ArrayList
argument_list|<
name|StateDatum
argument_list|>
name|stateDataList
init|=
operator|new
name|ArrayList
argument_list|<
name|StateDatum
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|stateData
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|cmd
range|:
name|commands
control|)
block|{
name|stateDataList
operator|.
name|add
argument_list|(
operator|new
name|StateDatum
argument_list|(
name|cmd
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|STATE_TABLE
index|[
name|i
index|]
operator|=
operator|new
name|StateAction
argument_list|(
name|state
argument_list|,
name|stateDataList
operator|.
name|toArray
argument_list|(
name|stateData
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Manages state transitions.      * Converts a state name into a map. Map keys are the names of available      * commands (e.g. @sync), and map values are the state to switch to open      * seeing the command.      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|lookupState
parameter_list|(
name|String
name|state
parameter_list|)
block|{
assert|assert
operator|(
name|state
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|STATE_TABLE
operator|.
name|length
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|state
operator|.
name|equals
argument_list|(
name|STATE_TABLE
index|[
name|i
index|]
operator|.
name|state
argument_list|)
condition|)
block|{
name|StateDatum
index|[]
name|stateData
init|=
name|STATE_TABLE
index|[
name|i
index|]
operator|.
name|stateData
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|,
name|m
init|=
name|stateData
operator|.
name|length
init|;
name|j
operator|<
name|m
condition|;
name|j
operator|++
control|)
block|{
name|result
operator|.
name|put
argument_list|(
name|stateData
index|[
name|j
index|]
operator|.
name|x
argument_list|,
name|stateData
index|[
name|j
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
comment|/**      * Returns the first word of the given line, assuming the line is      * trimmed. Returns the characters up the first non-whitespace      * character in the line.      */
specifier|private
name|String
name|firstWord
parameter_list|(
name|String
name|trimmedLine
parameter_list|)
block|{
return|return
name|trimmedLine
operator|.
name|replaceFirst
argument_list|(
literal|"\\s.*"
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**      * Returns everything but the first word of the given line, assuming the      * line is trimmed. Returns the characters following the first series of      * consecutive whitespace characters in the line.      */
specifier|private
name|String
name|skipFirstWord
parameter_list|(
name|String
name|trimmedLine
parameter_list|)
block|{
return|return
name|trimmedLine
operator|.
name|replaceFirst
argument_list|(
literal|"^\\S+\\s+"
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**      * Returns an input line, possible extended by the continuation      * character (\).  Scans the script until it finds an un-escaped      * newline.      */
specifier|private
name|String
name|readLine
parameter_list|(
name|String
name|line
parameter_list|,
name|BufferedReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
name|boolean
name|more
init|=
name|line
operator|.
name|endsWith
argument_list|(
literal|"\\"
argument_list|)
decl_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|line
operator|.
name|lastIndexOf
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
comment|// snip
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
name|line
argument_list|)
decl_stmt|;
comment|// save
while|while
condition|(
name|more
condition|)
block|{
name|line
operator|=
name|in
operator|.
name|readLine
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
name|more
operator|=
name|line
operator|.
name|endsWith
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|line
operator|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|line
operator|.
name|lastIndexOf
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|buf
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|scriptHasVars
operator|&&
name|line
operator|.
name|contains
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
name|line
operator|=
name|vars
operator|.
name|expand
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
return|return
name|line
return|;
block|}
comment|/**      * Returns a block of SQL, starting with the given String. Returns      *<code> startOfSql</code> concatenated with each line from      *<code>in</code> until a line ending with a semicolon is found.      */
specifier|private
name|String
name|readSql
parameter_list|(
name|String
name|startOfSql
parameter_list|,
name|BufferedReader
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// REVIEW mb StringBuffer not always needed
name|StringBuffer
name|sql
init|=
operator|new
name|StringBuffer
argument_list|(
name|startOfSql
argument_list|)
decl_stmt|;
name|sql
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|String
name|line
decl_stmt|;
if|if
condition|(
operator|!
name|startOfSql
operator|.
name|trim
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|line
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|sql
operator|.
name|append
argument_list|(
name|line
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|trim
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
name|line
operator|=
name|sql
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|scriptHasVars
operator|&&
name|line
operator|.
name|contains
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
name|line
operator|=
name|vars
operator|.
name|expand
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
return|return
name|line
return|;
block|}
block|}
comment|// Inner Classes: the Commands
comment|// When executed, a @print command defines how any following @fetch
comment|// or @select commands will handle their resuult rows. MTSQL can print all
comment|// rows, no rows, or every nth row. A printed row can be prefixed by a
comment|// sequence nuber and/or the time it was received (a different notion than
comment|// its rowtime, which often tells when it was inserted).
specifier|private
class|class
name|PrintCommand
extends|extends
name|AbstractCommand
block|{
comment|// print every nth row: 1 means all rows, 0 means no rows.
specifier|private
specifier|final
name|int
name|nth
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|count
decl_stmt|;
comment|// print a sequence number
specifier|private
specifier|final
name|boolean
name|time
decl_stmt|;
comment|// print the time row was fetched
comment|// print total row count and elapsed fetch time:
specifier|private
specifier|final
name|boolean
name|total
decl_stmt|;
comment|// TODO: more control of formats
name|PrintCommand
parameter_list|(
name|String
name|spec
parameter_list|)
block|{
name|int
name|nth
init|=
literal|0
decl_stmt|;
name|boolean
name|count
init|=
literal|false
decl_stmt|;
name|boolean
name|time
init|=
literal|false
decl_stmt|;
name|boolean
name|total
init|=
literal|false
decl_stmt|;
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|spec
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenizer
operator|.
name|countTokens
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// a bare "@print" means "@print all"
name|nth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|token
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"none"
argument_list|)
condition|)
block|{
name|nth
operator|=
literal|0
expr_stmt|;
block|}
if|else if
condition|(
name|token
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"all"
argument_list|)
condition|)
block|{
name|nth
operator|=
literal|1
expr_stmt|;
block|}
if|else if
condition|(
name|token
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"total"
argument_list|)
condition|)
block|{
name|total
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
name|token
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"count"
argument_list|)
condition|)
block|{
name|count
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
name|token
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"time"
argument_list|)
condition|)
block|{
name|time
operator|=
literal|true
expr_stmt|;
block|}
if|else if
condition|(
name|token
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"every"
argument_list|)
condition|)
block|{
name|nth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|token
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|nth
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|nth
operator|=
name|nth
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|this
operator|.
name|time
operator|=
name|time
expr_stmt|;
name|this
operator|.
name|total
operator|=
name|total
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|Integer
name|threadId
init|=
name|executor
operator|.
name|getThreadId
argument_list|()
decl_stmt|;
name|BufferedWriter
name|out
init|=
name|threadBufferedWriters
operator|.
name|get
argument_list|(
name|threadId
argument_list|)
decl_stmt|;
name|threadResultsReaders
operator|.
name|put
argument_list|(
name|threadId
argument_list|,
operator|new
name|ResultsReader
argument_list|(
name|out
argument_list|,
name|nth
argument_list|,
name|count
argument_list|,
name|time
argument_list|,
name|total
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|EchoCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
specifier|final
name|String
name|msg
decl_stmt|;
specifier|private
name|EchoCommand
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|this
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|storeMessage
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|PluginCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
specifier|final
name|ConcurrentTestPluginCommand
name|pluginCommand
decl_stmt|;
specifier|private
name|PluginCommand
parameter_list|(
name|String
name|command
parameter_list|,
name|String
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|ConcurrentTestPlugin
name|plugin
init|=
name|pluginForCommand
operator|.
name|get
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|pluginCommand
operator|=
name|plugin
operator|.
name|getCommandFor
argument_list|(
name|command
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
specifier|final
name|ConcurrentTestCommandExecutor
name|exec
parameter_list|)
throws|throws
name|Exception
block|{
name|ConcurrentTestPluginCommand
operator|.
name|TestContext
name|context
init|=
operator|new
name|ConcurrentTestPluginCommand
operator|.
name|TestContext
argument_list|()
block|{
specifier|public
name|void
name|storeMessage
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|ConcurrentTestCommandScript
operator|.
name|this
operator|.
name|storeMessage
argument_list|(
name|exec
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Connection
name|getConnection
parameter_list|()
block|{
return|return
name|exec
operator|.
name|getConnection
argument_list|()
return|;
block|}
specifier|public
name|Statement
name|getCurrentStatement
parameter_list|()
block|{
return|return
name|exec
operator|.
name|getStatement
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|pluginCommand
operator|.
name|execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Matches shell wilcards and other special characters: when a command
comment|// contains some of these, it needs a shell to run it.
specifier|private
specifier|final
name|Pattern
name|shellWildcardPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[*?$|<>&]"
argument_list|)
decl_stmt|;
comment|// REVIEW mb 2/24/09 (Mardi Gras) Should this have a timeout?
specifier|private
class|class
name|ShellCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
specifier|final
name|String
name|command
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|argv
decl_stmt|;
comment|// the command, parsed and massaged
specifier|private
name|ShellCommand
parameter_list|(
name|String
name|command
parameter_list|)
block|{
name|this
operator|.
name|command
operator|=
name|command
expr_stmt|;
name|boolean
name|needShell
init|=
name|hasWildcard
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|needShell
condition|)
block|{
name|argv
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|argv
operator|.
name|add
argument_list|(
literal|"/bin/sh"
argument_list|)
expr_stmt|;
name|argv
operator|.
name|add
argument_list|(
literal|"-c"
argument_list|)
expr_stmt|;
name|argv
operator|.
name|add
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
operator|=
name|tokenize
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|hasWildcard
parameter_list|(
name|String
name|command
parameter_list|)
block|{
return|return
name|shellWildcardPattern
operator|.
name|matcher
argument_list|(
name|command
argument_list|)
operator|.
name|find
argument_list|()
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|tokenize
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
block|{
name|Integer
name|threadId
init|=
name|executor
operator|.
name|getThreadId
argument_list|()
decl_stmt|;
name|storeMessage
argument_list|(
name|threadId
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|// argv[0] is found on $PATH. Working directory is the script's home
comment|// directory.
name|ProcessBuilder
name|pb
init|=
operator|new
name|ProcessBuilder
argument_list|(
name|argv
argument_list|)
decl_stmt|;
name|pb
operator|.
name|directory
argument_list|(
name|scriptDirectory
argument_list|)
expr_stmt|;
try|try
block|{
comment|// direct stdout& stderr to the the threadWriter
name|int
name|status
init|=
name|Util
operator|.
name|runAppProcess
argument_list|(
name|pb
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|getThreadWriter
argument_list|(
name|threadId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|storeMessage
argument_list|(
name|threadId
argument_list|,
literal|"command "
operator|+
name|command
operator|+
literal|": exited with status "
operator|+
name|status
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|storeMessage
argument_list|(
name|threadId
argument_list|,
literal|"command "
operator|+
name|command
operator|+
literal|": failed with exception "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: replace by super.CommmandWithTimeout
specifier|private
specifier|static
specifier|abstract
class|class
name|CommandWithTimeout
extends|extends
name|AbstractCommand
block|{
specifier|private
name|long
name|timeout
decl_stmt|;
specifier|private
name|CommandWithTimeout
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
comment|// returns the timeout as set (-1 means no timeout)
specifier|protected
name|long
name|setTimeout
parameter_list|(
name|Statement
name|stmt
parameter_list|)
throws|throws
name|SQLException
block|{
assert|assert
operator|(
name|timeout
operator|>=
literal|0
operator|)
assert|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
comment|// FIX: call setQueryTimeoutMillis() when available.
assert|assert
operator|(
name|timeout
operator|>=
literal|1000
operator|)
operator|:
literal|"timeout too short"
assert|;
name|int
name|t
init|=
operator|(
name|int
operator|)
operator|(
name|timeout
operator|/
literal|1000
operator|)
decl_stmt|;
name|stmt
operator|.
name|setQueryTimeout
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
specifier|private
specifier|static
specifier|abstract
class|class
name|CommandWithTimeoutAndRowLimit
extends|extends
name|CommandWithTimeout
block|{
specifier|private
name|int
name|rowLimit
decl_stmt|;
specifier|private
name|CommandWithTimeoutAndRowLimit
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
name|this
argument_list|(
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|private
name|CommandWithTimeoutAndRowLimit
parameter_list|(
name|long
name|timeout
parameter_list|,
name|int
name|rowLimit
parameter_list|)
block|{
name|super
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|this
operator|.
name|rowLimit
operator|=
name|rowLimit
expr_stmt|;
block|}
specifier|protected
name|void
name|setRowLimit
parameter_list|(
name|Statement
name|stmt
parameter_list|)
throws|throws
name|SQLException
block|{
assert|assert
operator|(
name|rowLimit
operator|>=
literal|0
operator|)
assert|;
if|if
condition|(
name|rowLimit
operator|>
literal|0
condition|)
block|{
name|stmt
operator|.
name|setMaxRows
argument_list|(
name|rowLimit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * SelectCommand creates and executes a SQL select statement, with optional    * timeout and row limit.    */
specifier|private
class|class
name|SelectCommand
extends|extends
name|CommandWithTimeoutAndRowLimit
block|{
specifier|private
name|String
name|sql
decl_stmt|;
specifier|private
name|SelectCommand
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|this
argument_list|(
name|sql
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|private
name|SelectCommand
parameter_list|(
name|String
name|sql
parameter_list|,
name|boolean
name|errorExpected
parameter_list|)
block|{
name|this
argument_list|(
name|sql
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorExpected
condition|)
block|{
name|this
operator|.
name|markToFail
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|SelectCommand
parameter_list|(
name|String
name|sql
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
name|this
argument_list|(
name|sql
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|private
name|SelectCommand
parameter_list|(
name|String
name|sql
parameter_list|,
name|long
name|timeout
parameter_list|,
name|int
name|rowLimit
parameter_list|)
block|{
name|super
argument_list|(
name|timeout
argument_list|,
name|rowLimit
argument_list|)
expr_stmt|;
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
comment|// TODO: trim and chop in constructor; stash sql in base class;
comment|// execute() calls storeSql.
name|String
name|properSql
init|=
name|sql
operator|.
name|trim
argument_list|()
decl_stmt|;
name|storeSql
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|properSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|properSql
operator|.
name|endsWith
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
name|properSql
operator|=
name|properSql
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|properSql
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|PreparedStatement
name|stmt
init|=
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|prepareStatement
argument_list|(
name|properSql
argument_list|)
decl_stmt|;
name|long
name|timeout
init|=
name|setTimeout
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|setRowLimit
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
try|try
block|{
name|storeResults
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|stmt
operator|.
name|executeQuery
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * SelectCommand creates and executes a SQL select statement, with optional    * timeout.    */
specifier|private
class|class
name|SqlCommand
extends|extends
name|CommandWithTimeout
block|{
specifier|private
name|String
name|sql
decl_stmt|;
specifier|private
name|SqlCommand
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|super
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
block|}
specifier|private
name|SqlCommand
parameter_list|(
name|String
name|sql
parameter_list|,
name|boolean
name|errorExpected
parameter_list|)
block|{
name|super
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
if|if
condition|(
name|errorExpected
condition|)
block|{
name|this
operator|.
name|markToFail
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|SqlCommand
parameter_list|(
name|String
name|sql
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
name|super
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|properSql
init|=
name|sql
operator|.
name|trim
argument_list|()
decl_stmt|;
name|storeSql
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|properSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|properSql
operator|.
name|endsWith
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
name|properSql
operator|=
name|properSql
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|properSql
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|properSql
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"commit"
argument_list|)
condition|)
block|{
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return;
block|}
if|else if
condition|(
name|properSql
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"rollback"
argument_list|)
condition|)
block|{
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|rollback
argument_list|()
expr_stmt|;
return|return;
block|}
name|PreparedStatement
name|stmt
init|=
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|prepareStatement
argument_list|(
name|properSql
argument_list|)
decl_stmt|;
name|long
name|timeout
init|=
name|setTimeout
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|boolean
name|timeoutSet
init|=
operator|(
name|timeout
operator|>=
literal|0
operator|)
decl_stmt|;
try|try
block|{
name|boolean
name|haveResults
init|=
name|stmt
operator|.
name|execute
argument_list|()
decl_stmt|;
if|if
condition|(
name|haveResults
condition|)
block|{
comment|// Farrago rewrites "call" statements as selects.
name|storeMessage
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
literal|"0 rows affected."
argument_list|)
expr_stmt|;
comment|// is there anything interesting in the ResultSet?
block|}
else|else
block|{
name|int
name|rows
init|=
name|stmt
operator|.
name|getUpdateCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|rows
operator|!=
literal|1
condition|)
block|{
name|storeMessage
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|rows
argument_list|)
operator|+
literal|" rows affected."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storeMessage
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
literal|"1 row affected."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SqlTimeoutException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|timeoutSet
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|storeMessage
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
literal|"Timeout"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|stmt
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * PrepareCommand creates a {@link PreparedStatement}, which is saved as the    * current statement of its test thread. For a preparted query (a SELECT or    * a CALL with results), a subsequent FetchAndPrintCommand executes the    * statement and fetches its reults, until end-of-data or a timeout. A    * PrintCommand attaches a listener, called for each rows, that selects rows    * to save and print, and sets the format. By default, if no PrintCommand    * appears before a FetchAndPrintCommand, all rows are printed. A    * CloseCommand closes and discards the prepared statement.    */
specifier|private
class|class
name|PrepareCommand
extends|extends
name|AbstractCommand
block|{
specifier|private
name|String
name|sql
decl_stmt|;
specifier|private
name|PrepareCommand
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|String
name|properSql
init|=
name|sql
operator|.
name|trim
argument_list|()
decl_stmt|;
name|storeSql
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|properSql
argument_list|)
expr_stmt|;
if|if
condition|(
name|properSql
operator|.
name|endsWith
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
name|properSql
operator|=
name|properSql
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|properSql
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|PreparedStatement
name|stmt
init|=
name|executor
operator|.
name|getConnection
argument_list|()
operator|.
name|prepareStatement
argument_list|(
name|properSql
argument_list|)
decl_stmt|;
name|executor
operator|.
name|setStatement
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * FetchAndPrintCommand executes a previously prepared statement stored    * inthe ConcurrentTestCommandExecutor and then outputs the returned    * rows.    */
specifier|private
class|class
name|FetchAndPrintCommand
extends|extends
name|CommandWithTimeout
block|{
specifier|private
name|FetchAndPrintCommand
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
name|super
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|doExecute
parameter_list|(
name|ConcurrentTestCommandExecutor
name|executor
parameter_list|)
throws|throws
name|SQLException
block|{
name|PreparedStatement
name|stmt
init|=
operator|(
name|PreparedStatement
operator|)
name|executor
operator|.
name|getStatement
argument_list|()
decl_stmt|;
name|long
name|timeout
init|=
name|setTimeout
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|storeResults
argument_list|(
name|executor
operator|.
name|getThreadId
argument_list|()
argument_list|,
name|stmt
operator|.
name|executeQuery
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|ResultsReader
block|{
specifier|private
specifier|final
name|PrintWriter
name|out
decl_stmt|;
comment|// print every Nth row. 1 means all rows, 0 means none.
specifier|private
specifier|final
name|int
name|nth
decl_stmt|;
comment|// prefix printed row with its sequence number
specifier|private
specifier|final
name|boolean
name|counted
decl_stmt|;
comment|// prefix printed row with time it was fetched
specifier|private
specifier|final
name|boolean
name|timestamped
decl_stmt|;
comment|// print final summary, rows& elapsed time.
specifier|private
specifier|final
name|boolean
name|totaled
decl_stmt|;
specifier|private
name|long
name|baseTime
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|rowCount
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|ncols
init|=
literal|0
decl_stmt|;
specifier|private
name|int
index|[]
name|widths
decl_stmt|;
specifier|private
name|String
index|[]
name|labels
decl_stmt|;
name|ResultsReader
parameter_list|(
name|BufferedWriter
name|out
parameter_list|)
block|{
name|this
argument_list|(
name|out
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|ResultsReader
parameter_list|(
name|BufferedWriter
name|out
parameter_list|,
name|int
name|nth
parameter_list|,
name|boolean
name|counted
parameter_list|,
name|boolean
name|timestamped
parameter_list|,
name|boolean
name|totaled
parameter_list|)
block|{
name|this
operator|.
name|out
operator|=
operator|new
name|PrintWriter
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|this
operator|.
name|nth
operator|=
name|nth
expr_stmt|;
name|this
operator|.
name|counted
operator|=
name|counted
expr_stmt|;
name|this
operator|.
name|timestamped
operator|=
name|timestamped
expr_stmt|;
name|this
operator|.
name|totaled
operator|=
name|totaled
expr_stmt|;
name|this
operator|.
name|baseTime
operator|=
name|scriptStartTime
expr_stmt|;
block|}
name|void
name|prepareFormat
parameter_list|(
name|ResultSet
name|rset
parameter_list|)
throws|throws
name|SQLException
block|{
name|ResultSetMetaData
name|meta
init|=
name|rset
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|ncols
operator|=
name|meta
operator|.
name|getColumnCount
argument_list|()
expr_stmt|;
name|widths
operator|=
operator|new
name|int
index|[
name|ncols
index|]
expr_stmt|;
name|labels
operator|=
operator|new
name|String
index|[
name|ncols
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
name|labels
index|[
name|i
index|]
operator|=
name|meta
operator|.
name|getColumnLabel
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|int
name|displaySize
init|=
name|meta
operator|.
name|getColumnDisplaySize
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// NOTE jvs 13-June-2006: I put this in to cap EXPLAIN PLAN,
comment|// which now returns a very large worst-case display size.
if|if
condition|(
name|displaySize
operator|>
literal|4096
condition|)
block|{
name|displaySize
operator|=
literal|0
expr_stmt|;
block|}
name|widths
index|[
name|i
index|]
operator|=
name|Math
operator|.
name|max
argument_list|(
name|labels
index|[
name|i
index|]
operator|.
name|length
argument_list|()
argument_list|,
name|displaySize
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|printHeaders
parameter_list|()
block|{
name|printSeparator
argument_list|()
expr_stmt|;
name|indent
argument_list|()
expr_stmt|;
name|printRow
argument_list|(
name|labels
argument_list|)
expr_stmt|;
name|printSeparator
argument_list|()
expr_stmt|;
block|}
name|void
name|read
parameter_list|(
name|ResultSet
name|rset
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|SQLException
block|{
name|boolean
name|withTimeout
init|=
operator|(
name|timeout
operator|>=
literal|0
operator|)
decl_stmt|;
name|boolean
name|timedOut
init|=
literal|false
decl_stmt|;
name|long
name|startTime
init|=
literal|0
decl_stmt|,
name|endTime
init|=
literal|0
decl_stmt|;
try|try
block|{
name|prepareFormat
argument_list|(
name|rset
argument_list|)
expr_stmt|;
name|String
index|[]
name|values
init|=
operator|new
name|String
index|[
name|ncols
index|]
decl_stmt|;
name|int
name|printedRowCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nth
operator|>
literal|0
condition|)
block|{
name|printHeaders
argument_list|()
expr_stmt|;
block|}
name|startTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
for|for
control|(
name|rowCount
operator|=
literal|0
init|;
name|rset
operator|.
name|next
argument_list|()
condition|;
name|rowCount
operator|++
control|)
block|{
if|if
condition|(
name|nth
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|nth
operator|==
literal|1
operator|||
name|rowCount
operator|%
name|nth
operator|==
literal|0
condition|)
block|{
name|long
name|time
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|printedRowCount
operator|>
literal|0
operator|&&
operator|(
name|printedRowCount
operator|%
literal|100
operator|==
literal|0
operator|)
condition|)
block|{
name|printHeaders
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
name|rset
operator|.
name|getString
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|counted
condition|)
block|{
name|printRowCount
argument_list|(
name|rowCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timestamped
condition|)
block|{
name|printTimestamp
argument_list|(
name|time
argument_list|)
expr_stmt|;
block|}
name|printRow
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|printedRowCount
operator|++
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SqlTimeoutException
name|e
parameter_list|)
block|{
name|endTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|timedOut
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|withTimeout
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|endTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|timedOut
operator|=
literal|true
expr_stmt|;
comment|// 2007-10-23 hersker: hack to ignore timeout exceptions
comment|// from other Farrago projects without being able to
comment|// import/reference the actual exceptions
specifier|final
name|String
name|eClassName
init|=
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|eClassName
operator|.
name|endsWith
argument_list|(
literal|"TimeoutException"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|withTimeout
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|endTime
operator|==
literal|0
condition|)
block|{
name|endTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|rset
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|nth
operator|>
literal|0
condition|)
block|{
name|printSeparator
argument_list|()
expr_stmt|;
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|out
operator|.
name|printf
argument_list|(
literal|"fetch started at %tc %d, %s at %tc %d%n"
argument_list|,
name|startTime
argument_list|,
name|startTime
argument_list|,
operator|(
name|timedOut
condition|?
literal|"timeout"
else|:
literal|"eos"
operator|)
argument_list|,
name|endTime
argument_list|,
name|endTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totaled
condition|)
block|{
name|long
name|dt
init|=
name|endTime
operator|-
name|startTime
decl_stmt|;
if|if
condition|(
name|withTimeout
condition|)
block|{
name|dt
operator|-=
name|timeout
expr_stmt|;
block|}
assert|assert
operator|(
name|dt
operator|>=
literal|0
operator|)
assert|;
name|out
operator|.
name|printf
argument_list|(
literal|"fetched %d rows in %d msecs %s%n"
argument_list|,
name|rowCount
argument_list|,
name|dt
argument_list|,
name|timedOut
condition|?
literal|"(timeout)"
else|:
literal|"(end)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|printRowCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|out
operator|.
name|printf
argument_list|(
literal|"(%06d) "
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|printTimestamp
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|time
operator|-=
name|baseTime
expr_stmt|;
name|out
operator|.
name|printf
argument_list|(
literal|"(% 4d.%03d) "
argument_list|,
name|time
operator|/
literal|1000
argument_list|,
name|time
operator|%
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|// indent a heading or separator line to match a row-values line
specifier|private
name|void
name|indent
parameter_list|()
block|{
if|if
condition|(
name|counted
condition|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"         "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timestamped
condition|)
block|{
name|out
operator|.
name|print
argument_list|(
literal|"           "
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Prints an output table separator. Something like<code>      * "+----+--------+"</code>.      */
specifier|private
name|void
name|printSeparator
parameter_list|()
block|{
name|indent
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|widths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|"-+-"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
literal|"+-"
argument_list|)
expr_stmt|;
block|}
name|int
name|numDashes
init|=
name|widths
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|numDashes
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|dashes
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|numDashes
argument_list|,
name|BUF_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|numDashes
operator|-=
name|Math
operator|.
name|min
argument_list|(
name|numDashes
argument_list|,
name|BUF_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|println
argument_list|(
literal|"-+"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Prints an output table row. Something like<code>"| COL1 | COL2      * |"</code>.      */
specifier|private
name|void
name|printRow
parameter_list|(
name|String
index|[]
name|values
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|value
init|=
name|values
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|value
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
literal|"| "
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|excess
init|=
name|widths
index|[
name|i
index|]
operator|-
name|value
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|excess
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|spaces
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|excess
argument_list|,
name|BUF_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|excess
operator|-=
name|Math
operator|.
name|min
argument_list|(
name|excess
argument_list|,
name|BUF_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|.
name|println
argument_list|(
literal|" |"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Inner class: stand-alone client test tool
specifier|private
specifier|static
class|class
name|Tool
block|{
name|boolean
name|quiet
init|=
literal|false
decl_stmt|;
comment|// -q
name|boolean
name|verbose
init|=
literal|false
decl_stmt|;
comment|// -v
name|boolean
name|debug
init|=
literal|false
decl_stmt|;
comment|// -g
name|String
name|server
decl_stmt|;
comment|// -u
name|String
name|driver
decl_stmt|;
comment|// -d
name|String
name|user
decl_stmt|;
comment|// -n
name|String
name|password
decl_stmt|;
comment|// -p
name|List
argument_list|<
name|String
argument_list|>
name|bindings
decl_stmt|;
comment|// VAR=VAL
name|List
argument_list|<
name|String
argument_list|>
name|files
decl_stmt|;
comment|// FILE
specifier|public
name|Tool
parameter_list|()
block|{
name|bindings
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|files
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|// returns 0 on success, 1 on error, 2 on bad invocation.
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|parseCommand
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
return|return
literal|2
return|;
block|}
name|Class
name|z
init|=
name|Class
operator|.
name|forName
argument_list|(
name|driver
argument_list|)
decl_stmt|;
comment|// load driver
name|Properties
name|jdbcProps
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
name|jdbcProps
operator|.
name|setProperty
argument_list|(
literal|"user"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|password
operator|!=
literal|null
condition|)
block|{
name|jdbcProps
operator|.
name|setProperty
argument_list|(
literal|"password"
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
name|BufferedWriter
name|cout
init|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|System
operator|.
name|out
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|files
control|)
block|{
name|ConcurrentTestCommandScript
name|script
init|=
operator|new
name|ConcurrentTestCommandScript
argument_list|()
decl_stmt|;
try|try
block|{
name|script
operator|.
name|setQuiet
argument_list|(
name|quiet
argument_list|)
expr_stmt|;
name|script
operator|.
name|setVerbose
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
name|script
operator|.
name|setDebug
argument_list|(
name|debug
argument_list|)
expr_stmt|;
name|script
operator|.
name|prepare
argument_list|(
name|file
argument_list|,
name|bindings
argument_list|)
expr_stmt|;
name|script
operator|.
name|setDataSource
argument_list|(
name|server
argument_list|,
name|jdbcProps
argument_list|)
expr_stmt|;
name|script
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|script
operator|.
name|printResults
argument_list|(
name|cout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: mtsql [-vg] -u SERVER -d DRIVER "
operator|+
literal|"[-n USER][-p PASSWORD] SCRIPT [SCRIPT]..."
argument_list|)
expr_stmt|;
block|}
name|boolean
name|parseCommand
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
try|try
block|{
comment|// very permissive as to order
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
control|)
block|{
name|String
name|arg
init|=
name|args
index|[
name|i
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|arg
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|debug
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|this
operator|.
name|server
operator|=
name|args
index|[
name|i
operator|++
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|this
operator|.
name|driver
operator|=
name|args
index|[
name|i
operator|++
index|]
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|this
operator|.
name|user
operator|=
name|args
index|[
name|i
operator|++
index|]
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|this
operator|.
name|password
operator|=
name|args
index|[
name|i
operator|++
index|]
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
block|}
if|else if
condition|(
name|arg
operator|.
name|contains
argument_list|(
literal|"="
argument_list|)
condition|)
block|{
if|if
condition|(
name|Character
operator|.
name|isJavaIdentifierStart
argument_list|(
name|arg
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|bindings
operator|.
name|add
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|files
operator|.
name|add
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|server
operator|==
literal|null
operator|||
name|driver
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Client tool that connects via jdbc and runs one or more mtsql on that    * connection.    *    *<p>Usage: mtsql [-vgq] -u SERVER -d DRIVER [-n USER][-p PASSWORD]    * [VAR=VAL]...  SCRIPT [SCRIPT]...    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|int
name|status
init|=
operator|new
name|Tool
argument_list|()
operator|.
name|run
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// End ConcurrentTestCommandScript.java
end_comment

end_unit

