begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|TableModificationRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|hep
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * Unit test for rules in {@code org.eigenbase.rel} and subpackages.  *  *<p>As input, the test supplies a SQL statement and a single rule; the SQL is  * translated into relational algebra and then fed into a  * {@link org.eigenbase.relopt.hep.HepPlanner}. The planner fires the rule on  * every  * pattern match in a depth-first left-to-right preorder traversal of the tree  * for as long as the rule continues to succeed in applying its transform. (For  * rules which call transformTo more than once, only the last result is used.)  * The plan before and after "optimization" is diffed against a .ref file using  * {@link DiffRepository}.  *  *<p>Procedure for adding a new test case:  *  *<ol>  *<li>Add a new public test method for your rule, following the existing  * examples. You'll have to come up with an SQL statement to which your rule  * will apply in a meaningful way. See {@link SqlToRelTestBase} class comments  * for details on the schema.  *<li>Run the test. It should fail. Inspect the output in  * RelOptRulesTest.log.xml; verify that the "planBefore" is the correct  * translation of your SQL, and that it contains the pattern on which your rule  * is supposed to fire. If all is well, check out RelOptRulesTest.ref.xml and  * replace it with the new .log.xml.  *<li>Run the test again. It should fail again, but this time it should contain  * a "planAfter" entry for your rule. Verify that your rule applied its  * transformation correctly, and then update the .ref.xml file again.  *<li>Run the test one last time; this time it should pass.  *</ol>  */
end_comment

begin_class
specifier|public
class|class
name|RelOptRulesTest
extends|extends
name|RelOptTestBase
block|{
comment|//~ Methods ----------------------------------------------------------------
specifier|protected
name|DiffRepository
name|getDiffRepos
parameter_list|()
block|{
return|return
name|DiffRepository
operator|.
name|lookup
argument_list|(
name|RelOptRulesTest
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnionToDistinctRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|UnionToDistinctRule
operator|.
name|INSTANCE
argument_list|,
literal|"select * from dept union select * from dept"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExtractJoinFilterRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ExtractJoinFilterRule
operator|.
name|INSTANCE
argument_list|,
literal|"select 1 from emp inner join dept on emp.deptno=dept.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAddRedundantSemiJoinRule
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|,
literal|"select 1 from emp inner join dept on emp.deptno = dept.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushFilterThroughOuterJoin
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
literal|"select 1 from sales.dept d left outer join sales.emp e"
operator|+
literal|" on d.deptno = e.deptno"
operator|+
literal|" where d.name = 'Charlie'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceAverage
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|ReduceAggregatesRule
operator|.
name|INSTANCE
argument_list|,
literal|"select name, max(name), avg(deptno), min(name)"
operator|+
literal|" from sales.dept group by name"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastFilter
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|PushProjectPastFilterRule
operator|.
name|INSTANCE
argument_list|,
literal|"select empno + deptno from emp where sal = 10 * comm "
operator|+
literal|"and upper(ename) = 'FOO'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastJoin
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|PushProjectPastJoinRule
operator|.
name|INSTANCE
argument_list|,
literal|"select e.sal + b.comm from emp e inner join bonus b "
operator|+
literal|"on e.ename = b.ename and e.deptno = 10"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushProjectPastSetOp
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|PushProjectPastSetOpRule
operator|.
name|INSTANCE
argument_list|,
literal|"select sal from "
operator|+
literal|"(select * from emp e1 union all select * from emp e2)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushJoinThroughUnionOnLeft
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|PushJoinThroughUnionRule
operator|.
name|LEFT_UNION
argument_list|,
literal|"select r1.sal from "
operator|+
literal|"(select * from emp e1 union all select * from emp e2) r1, "
operator|+
literal|"emp r2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushJoinThroughUnionOnRight
parameter_list|()
block|{
name|checkPlanning
argument_list|(
name|PushJoinThroughUnionRule
operator|.
name|RIGHT_UNION
argument_list|,
literal|"select r1.sal from "
operator|+
literal|"emp r1, "
operator|+
literal|"(select * from emp e1 union all select * from emp e2) r2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testMergeFilterWithJoinCondition
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|TableAccessRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ExtractJoinFilterRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeCalcRule
operator|.
name|INSTANCE
argument_list|)
comment|//.addRuleInstance(FennelCalcRule.instance);
comment|//.addRuleInstance(FennelCartesianJoinRule.instance);
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select d.name as dname,e.name as ename"
operator|+
literal|" from sales.emps e inner join sales.depts d"
operator|+
literal|" on e.deptno=d.deptno"
operator|+
literal|" where d.name='Propane'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testHeterogeneousConversion
parameter_list|()
throws|throws
name|Exception
block|{
comment|// This one tests the planner's ability to correctly
comment|// apply different converters on top of a common
comment|// sub-expression.  The common sub-expression is the
comment|// reference to the table sales.emps.  On top of that
comment|// are two projections, unioned at the top.  For one
comment|// of the projections, we force a Fennel implementation.
comment|// For the other, we force a Java implementation.
comment|// Then, we request conversion from Fennel to Java,
comment|// and verify that it only applies to one usage of the
comment|// table, not both (which would be incorrect).
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|TableAccessRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
comment|// Control the calc conversion.
operator|.
name|addMatchLimit
argument_list|(
literal|1
argument_list|)
comment|// Let the converter rule fire to its heart's content.
operator|.
name|addMatchLimit
argument_list|(
name|HepProgram
operator|.
name|MATCH_UNTIL_FIXPOINT
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select upper(name) from sales.emps union all"
operator|+
literal|" select lower(name) from sales.emps"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastJoinRuleLeft
parameter_list|()
throws|throws
name|Exception
block|{
comment|// tests the case where the semijoin is pushed to the left
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushSemiJoinPastJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.name from sales.emps e1, sales.depts d, sales.emps e2 "
operator|+
literal|"where e1.deptno = d.deptno and e1.empno = e2.empno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastJoinRuleRight
parameter_list|()
throws|throws
name|Exception
block|{
comment|// tests the case where the semijoin is pushed to the right
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushSemiJoinPastJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.name from sales.emps e1, sales.depts d, sales.emps e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushSemiJoinPastFilterRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.name from sales.emps e, sales.depts d "
operator|+
literal|"where e.deptno = d.deptno and e.name = 'foo'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRule
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ConvertMultiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.name from sales.emps e1, sales.depts d, sales.emps e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstants
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// NOTE jvs 27-May-2006: among other things, this verifies
comment|// intentionally different treatment for identical coalesce expression
comment|// in select and where.
comment|// There is "CAST(2 AS INTEGER)" in the plan because 2 has type "INTEGER NOT
comment|// NULL" and we need "INTEGER".
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select 1+2, d.deptno+(3+4), (5+6)+d.deptno, cast(null as integer),"
operator|+
literal|" coalesce(2,null), row(7+8)"
operator|+
literal|" from dept d inner join emp e"
operator|+
literal|" on d.deptno = e.deptno + (5-5)"
operator|+
literal|" where d.deptno=(7+8) and d.deptno=coalesce(2,null)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstants2
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select p1 is not distinct from p0 from (values (2, cast(null as integer))) as t(p0, p1)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsEliminatesFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// WHERE NULL is the same as WHERE FALSE, so get empty result
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (values (1,2)) where 1 + 2> 3 + CAST(NULL AS INTEGER)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAlreadyFalseEliminatesFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (values (1,2)) where false"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceConstantsCalc
parameter_list|()
throws|throws
name|Exception
block|{
comment|// This reduction does not work using
comment|// ReduceExpressionsRule.PROJECT_INSTANCE or FILTER_INSTANCE,
comment|// only CALC_INSTANCE, because we need to pull the project expression
comment|//    upper('table')
comment|// into the condition
comment|//    upper('table') = 'TABLE'
comment|// and reduce it to TRUE. Only in the Calc are projects and conditions
comment|// combined.
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastSetOpRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
comment|// the hard part is done... a few more rule calls to clean up
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Result should be same as typing
comment|//  SELECT * FROM (VALUES ('TABLE        ', 'T')) AS T(U, S)
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"  select upper(substring(x FROM 1 FOR 2) || substring(x FROM 3)) as u,\n"
operator|+
literal|"      substring(x FROM 1 FOR 1) as s\n"
operator|+
literal|"  from (\n"
operator|+
literal|"    select 'table' as x from (values (true))\n"
operator|+
literal|"    union\n"
operator|+
literal|"    select 'view' from (values (true))\n"
operator|+
literal|"    union\n"
operator|+
literal|"    select 'foreign table' from (values (true))\n"
operator|+
literal|"  )\n"
operator|+
literal|") where u = 'TABLE'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.name from sales.emps e, sales.depts d "
operator|+
literal|"where e.deptno = d.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinWithFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushSemiJoinPastFilterRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.name from sales.emps e, sales.depts d "
operator|+
literal|"where e.deptno = d.deptno and e.name = 'foo'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinRight
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushSemiJoinPastJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.name from sales.emps e1, sales.depts d, sales.emps e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testRemoveSemiJoinRightWithFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushSemiJoinPastJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushSemiJoinPastFilterRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e1.name from sales.emps e1, sales.depts d, sales.emps e2 "
operator|+
literal|"where e1.deptno = d.deptno and d.deptno = e2.deptno "
operator|+
literal|"and d.name = 'foo'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testConvertMultiJoinRuleOuterJoins
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*     stmt.executeUpdate("create schema oj");     stmt.executeUpdate("set schema 'oj'");     stmt.executeUpdate(         "create table A(a int primary key)");     stmt.executeUpdate(         "create table B(b int primary key)");     stmt.executeUpdate(         "create table C(c int primary key)");     stmt.executeUpdate(         "create table D(d int primary key)");     stmt.executeUpdate(         "create table E(e int primary key)");     stmt.executeUpdate(         "create table F(f int primary key)");     stmt.executeUpdate(         "create table G(g int primary key)");     stmt.executeUpdate(         "create table H(h int primary key)");     stmt.executeUpdate(         "create table I(i int primary key)");     stmt.executeUpdate(         "create table J(j int primary key)"); */
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addMatchOrder
argument_list|(
name|HepMatchOrder
operator|.
name|BOTTOM_UP
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveTrivialProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ConvertMultiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from "
operator|+
literal|"    (select * from "
operator|+
literal|"        (select * from "
operator|+
literal|"            (select * from A right outer join B on a = b) "
operator|+
literal|"            left outer join "
operator|+
literal|"            (select * from C full outer join D on c = d)"
operator|+
literal|"            on a = c and b = d) "
operator|+
literal|"        right outer join "
operator|+
literal|"        (select * from "
operator|+
literal|"            (select * from E full outer join F on e = f) "
operator|+
literal|"            right outer join "
operator|+
literal|"            (select * from G left outer join H on g = h) "
operator|+
literal|"            on e = g and f = h) "
operator|+
literal|"        on a = e and b = f and c = g and d = h) "
operator|+
literal|"    inner join "
operator|+
literal|"    (select * from I inner join J on i = j) "
operator|+
literal|"    on a = i and h = j"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// have not tried under optiq (it might work)
annotation|@
name|Test
specifier|public
name|void
name|testPushSemiJoinPastProject
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|AddRedundantSemiJoinRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushSemiJoinPastProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select e.* from "
operator|+
literal|"(select name, trim(city), age * 2, deptno from sales.emps) e, "
operator|+
literal|"sales.depts d "
operator|+
literal|"where e.deptno = d.deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceValuesRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select a, b from (values (10,'x')) as t(a, b)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a, b from (values (10, 'x'), (20, 'y')) as t(a, b) where a< 15"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderProject
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|MergeProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceValuesRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select a, b as x from (values (11), (23)) as t(x)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b from (values (10, 1), (20, 3)) as t(a, b)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesUnderProjectFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceValuesRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (11, 1, 10), (23, 3, 20)) as t(x, b, a)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b as x, b, a from (values (10, 1), (30, 7), (20, 3)) as t(a, b)"
operator|+
literal|" where a - b< 21"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// Optiq does not support INSERT yet
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesNull
parameter_list|()
throws|throws
name|Exception
block|{
comment|// The NULL literal presents pitfalls for value-reduction. Only
comment|// an INSERT statement contains un-CASTed NULL values.
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceValuesRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"insert into sales.depts(deptno,name) values (NULL, 'null')"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceValuesToEmpty
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceValuesRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (11, 1, 10), (23, 3, 20)) as t(x, b, a)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select a + b as x, b, a from (values (10, 1), (30, 7)) as t(a, b)"
operator|+
literal|" where a - b< 0"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyFilterProjectUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastSetOpRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushFilterPastProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceValuesRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|UNION_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be same as for
comment|// select * from (values (30, 3)) as t(x, y)");
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from (values (10, 1), (30, 3)) as t (x, y)\n"
operator|+
literal|"union all\n"
operator|+
literal|"select * from (values (20, 2))\n"
operator|+
literal|")\n"
operator|+
literal|"where x + y> 30"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoin
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be empty
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from emp where false)\n"
operator|+
literal|"join dept using (deptno)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoinLeft
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be empty
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from emp where false)\n"
operator|+
literal|"left join dept using (deptno)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptyJoinRight
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|JOIN_LEFT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|JOIN_RIGHT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Plan should be equivalent to "select * from emp join dept".
comment|// Cannot optimize away the join because of RIGHT.
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from (\n"
operator|+
literal|"select * from emp where false)\n"
operator|+
literal|"right join dept using (deptno)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptySort
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|SORT_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp where false order by deptno"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEmptySortLimitZero
parameter_list|()
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|RemoveEmptyRules
operator|.
name|SORT_FETCH_ZERO_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp order by deptno limit 0"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceCasts
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// The resulting plan should have no cast expressions
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select cast(d.name as varchar(128)), cast(e.empno as integer) "
operator|+
literal|"from dept as d inner join emp as e "
operator|+
literal|"on cast(d.deptno as integer) = cast(e.deptno as integer) "
operator|+
literal|"where cast(e.job as varchar(1)) = 'Manager'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testReduceCastAndConsts
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Make sure constant expressions inside the cast can be reduced
comment|// in addition to the casts.
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"select * from emp "
operator|+
literal|"where cast((empno + (10/2)) as int) = 13"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
comment|// Optiq does not support INSERT yet
annotation|@
name|Test
specifier|public
name|void
name|testReduceCastsNullable
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
comment|// Simulate the way INSERT will insert casts to the target types
operator|.
name|addRuleInstance
argument_list|(
operator|new
name|CoerceInputsRule
argument_list|(
name|TableModificationRel
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
comment|// Convert projects to calcs, merge two calcs, and then
comment|// reduce redundant casts in merged calc.
operator|.
name|addRuleInstance
argument_list|(
name|ProjectToCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeCalcRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"insert into sales.depts(name) "
operator|+
literal|"select cast(gender as varchar(128)) from sales.emps"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|basePushAggThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|PushProjectPastSetOpRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PushAggregateThroughUnionRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"${sql}"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumConstantThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullConstantThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumNullableNOGBYThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushCountStarThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushCountNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushMaxNullableThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushMinThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushAvgThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPushSumCountStarThroughUnion
parameter_list|()
throws|throws
name|Exception
block|{
name|basePushAggThroughUnion
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|basePullConstantTroughAggregate
parameter_list|()
throws|throws
name|Exception
block|{
name|HepProgram
name|program
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|MergeProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|PullConstantsThroughAggregatesRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|MergeProjectRule
operator|.
name|INSTANCE
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|checkPlanning
argument_list|(
name|program
argument_list|,
literal|"${sql}"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughConstLast
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateSimpleNonNullable
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermuted
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermutedConstFirst
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregatePermutedConstGroupBy
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateConstGroupBy
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateAllConst
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPullConstantThroughAggregateAllLiterals
parameter_list|()
throws|throws
name|Exception
block|{
name|basePullConstantTroughAggregate
argument_list|()
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// End RelOptRulesTest.java
end_comment

end_unit

