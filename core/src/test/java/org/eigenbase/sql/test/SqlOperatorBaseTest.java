begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/* // Licensed to Julian Hyde under one or more contributor license // agreements. See the NOTICE file distributed with this work for // additional information regarding copyright ownership. // // Julian Hyde licenses this file to you under the Apache License, // Version 2.0 (the "License"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at: // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an "AS IS" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|test
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|test
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Contains unit tests for all operators. Each of the methods is named after an  * operator.  *  *<p>The class is abstract. It contains a test for every operator, but does not  * provide a mechanism to execute the tests: parse, validate, and execute  * expressions on the operators. This is left to a {@link SqlTester} object  * which the derived class must provide.</p>  *  *<p>Different implementations of {@link SqlTester} are possible, such as:</p>  *  *<ul>  *<li>Execute against a real farrago database  *<li>Execute in pure java (parsing and validation can be done, but expression  * evaluation is not possible)  *<li>Generate a SQL script.  *<li>Analyze which operators are adequately tested.  *</ul>  *  *<p>A typical method will be named after the operator it is testing (say  *<code>testSubstringFunc</code>). It first calls  * {@link SqlTester#setFor(org.eigenbase.sql.SqlOperator, org.eigenbase.sql.test.SqlTester.VmName...)}  * to declare which operator it is testing.  *  *<blockquote>  *<pre><code>  * public void testSubstringFunc() {  *     tester.setFor(SqlStdOperatorTable.substringFunc);  *     tester.checkScalar("sin(0)", "0");  *     tester.checkScalar("sin(1.5707)", "1");  * }</code></pre>  *</blockquote>  *  *<p>The rest of the method contains calls to the various {@code checkXxx}  * methods in the {@link SqlTester} interface. For an operator  * to be adequately tested, there need to be tests for:  *  *<ul>  *<li>Parsing all of its the syntactic variants.  *<li>Deriving the type of in all combinations of arguments.  *  *<ul>  *<li>Pay particular attention to nullability. For example, the result of the  * "+" operator is NOT NULL if and only if both of its arguments are NOT  * NULL.</li>  *<li>Also pay attention to precision/scale/length. For example, the maximum  * length of the "||" operator is the sum of the maximum lengths of its  * arguments.</li>  *</ul>  *</li>  *<li>Executing the function. Pay particular attention to corner cases such as  * null arguments or null results.</li>  *</ul>  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlOperatorBaseTest
block|{
comment|//~ Static fields/initializers ---------------------------------------------
comment|// TODO: Change message when Fnl3Fixed to something like
comment|// "Invalid character for cast: PC=0 Code=22018"
specifier|public
specifier|static
specifier|final
name|String
name|INVALID_CHAR_MESSAGE
init|=
name|Bug
operator|.
name|FNL3_FIXED
condition|?
literal|null
else|:
literal|"(?s).*"
decl_stmt|;
comment|// TODO: Change message when Fnl3Fixed to something like
comment|// "Overflow during calculation or cast: PC=0 Code=22003"
specifier|public
specifier|static
specifier|final
name|String
name|OUT_OF_RANGE_MESSAGE
init|=
name|Bug
operator|.
name|FNL3_FIXED
condition|?
literal|null
else|:
literal|"(?s).*"
decl_stmt|;
comment|// TODO: Change message when Fnl3Fixed to something like
comment|// "Division by zero: PC=0 Code=22012"
specifier|public
specifier|static
specifier|final
name|String
name|DIVISION_BY_ZERO_MESSAGE
init|=
name|Bug
operator|.
name|FNL3_FIXED
condition|?
literal|null
else|:
literal|"(?s).*"
decl_stmt|;
comment|// TODO: Change message when Fnl3Fixed to something like
comment|// "String right truncation: PC=0 Code=22001"
specifier|public
specifier|static
specifier|final
name|String
name|STRING_TRUNC_MESSAGE
init|=
name|Bug
operator|.
name|FNL3_FIXED
condition|?
literal|null
else|:
literal|"(?s).*"
decl_stmt|;
comment|// TODO: Change message when Fnl3Fixed to something like
comment|// "Invalid datetime format: PC=0 Code=22007"
specifier|public
specifier|static
specifier|final
name|String
name|BAD_DATETIME_MESSAGE
init|=
name|Bug
operator|.
name|FNL3_FIXED
condition|?
literal|null
else|:
literal|"(?s).*"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|LITERAL_OUT_OF_RANGE_MESSAGE
init|=
literal|"(?s).*Numeric literal.*out of range.*"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|TODO
init|=
literal|false
decl_stmt|;
comment|/**    * Regular expression for a SQL TIME(0) value.    */
specifier|public
specifier|static
specifier|final
name|Pattern
name|TIME_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[0-9][0-9]:[0-9][0-9]:[0-9][0-9]"
argument_list|)
decl_stmt|;
comment|/**    * Regular expression for a SQL TIMESTAMP(0) value.    */
specifier|public
specifier|static
specifier|final
name|Pattern
name|TIMESTAMP_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] "
operator|+
literal|"[0-9][0-9]:[0-9][0-9]:[0-9][0-9]"
argument_list|)
decl_stmt|;
comment|/**    * Regular expression for a SQL DATE value.    */
specifier|public
specifier|static
specifier|final
name|Pattern
name|DATE_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|NUMERIC_TYPE_NAMES
init|=
block|{
literal|"TINYINT"
block|,
literal|"SMALLINT"
block|,
literal|"INTEGER"
block|,
literal|"BIGINT"
block|,
literal|"DECIMAL(5, 2)"
block|,
literal|"REAL"
block|,
literal|"FLOAT"
block|,
literal|"DOUBLE"
block|}
decl_stmt|;
comment|// REVIEW jvs 27-Apr-2006:  for Float and Double, MIN_VALUE
comment|// is the smallest positive value, not the smallest negative value
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|MIN_NUMERIC_STRINGS
init|=
block|{
name|Long
operator|.
name|toString
argument_list|(
name|Byte
operator|.
name|MIN_VALUE
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
name|Short
operator|.
name|MIN_VALUE
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
name|Integer
operator|.
name|MIN_VALUE
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
block|,
literal|"-999.99"
block|,
comment|// NOTE jvs 26-Apr-2006:  Win32 takes smaller values from win32_values.h
literal|"1E-37"
block|,
comment|/*Float.toString(Float.MIN_VALUE)*/
literal|"2E-307"
block|,
comment|/*Double.toString(Double.MIN_VALUE)*/
literal|"2E-307"
comment|/*Double.toString(Double.MIN_VALUE)*/
block|,   }
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|MIN_OVERFLOW_NUMERIC_STRINGS
init|=
block|{
name|Long
operator|.
name|toString
argument_list|(
name|Byte
operator|.
name|MIN_VALUE
operator|-
literal|1
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
name|Short
operator|.
name|MIN_VALUE
operator|-
literal|1
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
operator|(
name|long
operator|)
name|Integer
operator|.
name|MIN_VALUE
operator|-
literal|1
argument_list|)
block|,
operator|new
name|BigDecimal
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
operator|.
name|subtract
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
operator|.
name|toString
argument_list|()
block|,
literal|"-1000.00"
block|,
literal|"1e-46"
block|,
literal|"1e-324"
block|,
literal|"1e-324"
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|MAX_NUMERIC_STRINGS
init|=
block|{
name|Long
operator|.
name|toString
argument_list|(
name|Byte
operator|.
name|MAX_VALUE
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
name|Short
operator|.
name|MAX_VALUE
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
block|,
literal|"999.99"
block|,
comment|// NOTE jvs 26-Apr-2006:  use something slightly less than MAX_VALUE
comment|// because roundtripping string to approx to string doesn't preserve
comment|// MAX_VALUE on win32
literal|"3.4028234E38"
block|,
comment|/*Float.toString(Float.MAX_VALUE)*/
literal|"1.79769313486231E308"
block|,
comment|/*Double.toString(Double.MAX_VALUE)*/
literal|"1.79769313486231E308"
comment|/*Double.toString(Double.MAX_VALUE)*/
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|MAX_OVERFLOW_NUMERIC_STRINGS
init|=
block|{
name|Long
operator|.
name|toString
argument_list|(
name|Byte
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
name|Short
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
block|,
name|Long
operator|.
name|toString
argument_list|(
operator|(
name|long
operator|)
name|Integer
operator|.
name|MAX_VALUE
operator|+
literal|1
argument_list|)
block|,
operator|(
operator|new
name|BigDecimal
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|)
operator|.
name|add
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
operator|.
name|toString
argument_list|()
block|,
literal|"1000.00"
block|,
literal|"1e39"
block|,
literal|"-1e309"
block|,
literal|"1e309"
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
index|[]
name|FALSE_TRUE
init|=
block|{
literal|false
block|,
literal|true
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|SqlTester
operator|.
name|VmName
name|VM_FENNEL
init|=
name|SqlTester
operator|.
name|VmName
operator|.
name|FENNEL
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|SqlTester
operator|.
name|VmName
name|VM_JAVA
init|=
name|SqlTester
operator|.
name|VmName
operator|.
name|JAVA
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|SqlTester
operator|.
name|VmName
name|VM_EXPAND
init|=
name|SqlTester
operator|.
name|VmName
operator|.
name|EXPAND
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|TimeZone
name|UTC_TZ
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"GMT"
argument_list|)
decl_stmt|;
comment|// time zone for the LOCAL_{DATE,TIME,TIMESTAMP} functions
specifier|protected
specifier|static
specifier|final
name|TimeZone
name|LOCAL_TZ
init|=
name|TimeZone
operator|.
name|getDefault
argument_list|()
decl_stmt|;
comment|// time zone for the CURRENT{DATE,TIME,TIMESTAMP} functions
specifier|protected
specifier|static
specifier|final
name|TimeZone
name|CURRENT_TZ
init|=
name|LOCAL_TZ
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|INVALID_ARG_FOR_POWER
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(?s).*Invalid argument\\(s\\) for 'POWER' function.*"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|CODE_2201F
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(?s).*could not calculate results for the following row.*PC=5 Code=2201F.*"
argument_list|)
decl_stmt|;
comment|/**    * Whether DECIMAL type is implemented.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DECIMAL
init|=
literal|false
decl_stmt|;
comment|/**    * Whether INTERVAL type is implemented.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|INTERVAL
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|enable
decl_stmt|;
specifier|protected
specifier|final
name|SqlTester
name|tester
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a SqlOperatorBaseTest.    *    * @param enable Whether to run "failing" tests.    * @param tester Means to validate, execute various statements.    */
specifier|protected
name|SqlOperatorBaseTest
parameter_list|(
name|boolean
name|enable
parameter_list|,
name|SqlTester
name|tester
parameter_list|)
block|{
name|this
operator|.
name|enable
operator|=
name|enable
expr_stmt|;
name|this
operator|.
name|tester
operator|=
name|tester
expr_stmt|;
assert|assert
name|tester
operator|!=
literal|null
assert|;
block|}
comment|//~ Methods ----------------------------------------------------------------
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|tester
operator|.
name|setFor
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|//--- Tests -----------------------------------------------------------
comment|/**    * For development. Put any old code in here.    */
annotation|@
name|Test
specifier|public
name|void
name|testDummy
parameter_list|()
block|{
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBetween
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|BETWEEN
argument_list|,
name|SqlTester
operator|.
name|VmName
operator|.
name|EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"2 between 1 and 3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"2 between 3 and 2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"2 between symmetric 3 and 2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"3 between 1 and 3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"4 between 1 and 3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 between 4 and -3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 between -1 and -3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 between -1 and 3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 between 1 and 1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.5 between 1 and 3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2 between 1.1 and 1.3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.5 between 2 and 3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.5 between 1.6 and 1.7"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e1 between 1.1 and 1.3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e0 between 1.1 and 1.3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.5e0 between 2 and 3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.5e0 between 2e0 and 3e0"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.5e1 between 1.6e1 and 1.7e1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"x'' between x'' and x''"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as integer) between -1 and 2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"1 between -1 and cast(null as integer)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"1 between cast(null as integer) and cast(null as integer)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"1 between cast(null as integer) and 1"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNotBetween
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_BETWEEN
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"2 not between 1 and 3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"3 not between 1 and 3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"4 not between 1 and 3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e0 not between 1.1 and 1.3"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e1 not between 1.1 and 1.3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.5e0 not between 2 and 3"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.5e0 not between 2e0 and 3e0"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|getCastString
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|targetType
parameter_list|,
name|boolean
name|errorLoc
parameter_list|)
block|{
if|if
condition|(
name|errorLoc
condition|)
block|{
name|value
operator|=
literal|"^"
operator|+
name|value
operator|+
literal|"^"
expr_stmt|;
block|}
return|return
literal|"cast("
operator|+
name|value
operator|+
literal|" as "
operator|+
name|targetType
operator|+
literal|")"
return|;
block|}
specifier|private
name|void
name|checkCastToApproxOkay
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|targetType
parameter_list|,
name|double
name|expected
parameter_list|,
name|double
name|delta
parameter_list|)
block|{
name|tester
operator|.
name|checkScalarApprox
argument_list|(
name|getCastString
argument_list|(
name|value
argument_list|,
name|targetType
argument_list|,
literal|false
argument_list|)
argument_list|,
name|targetType
operator|+
literal|" NOT NULL"
argument_list|,
name|expected
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCastToStringOkay
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|targetType
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|tester
operator|.
name|checkString
argument_list|(
name|getCastString
argument_list|(
name|value
argument_list|,
name|targetType
argument_list|,
literal|false
argument_list|)
argument_list|,
name|expected
argument_list|,
name|targetType
operator|+
literal|" NOT NULL"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCastToScalarOkay
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|targetType
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|tester
operator|.
name|checkScalarExact
argument_list|(
name|getCastString
argument_list|(
name|value
argument_list|,
name|targetType
argument_list|,
literal|false
argument_list|)
argument_list|,
name|targetType
operator|+
literal|" NOT NULL"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCastToScalarOkay
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|targetType
parameter_list|)
block|{
name|checkCastToScalarOkay
argument_list|(
name|value
argument_list|,
name|targetType
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCastFails
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|targetType
parameter_list|,
name|String
name|expectedError
parameter_list|,
name|boolean
name|runtime
parameter_list|)
block|{
name|tester
operator|.
name|checkFails
argument_list|(
name|getCastString
argument_list|(
name|value
argument_list|,
name|targetType
argument_list|,
operator|!
name|runtime
argument_list|)
argument_list|,
name|expectedError
argument_list|,
name|runtime
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCastToString
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|String
name|spaces
init|=
literal|"     "
decl_stmt|;
if|if
condition|(
name|expected
operator|==
literal|null
condition|)
block|{
name|expected
operator|=
name|value
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
name|int
name|len
init|=
name|expected
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|getCastString
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// currently no exception thrown for truncation
if|if
condition|(
name|Bug
operator|.
name|DT239_FIXED
condition|)
block|{
name|checkCastFails
argument_list|(
name|value
argument_list|,
literal|"VARCHAR("
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|+
literal|")"
argument_list|,
name|STRING_TRUNC_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|checkCastToStringOkay
argument_list|(
name|value
argument_list|,
literal|"VARCHAR("
operator|+
name|len
operator|+
literal|")"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|checkCastToStringOkay
argument_list|(
name|value
argument_list|,
literal|"VARCHAR("
operator|+
operator|(
name|len
operator|+
literal|5
operator|)
operator|+
literal|")"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// currently no exception thrown for truncation
if|if
condition|(
name|Bug
operator|.
name|DT239_FIXED
condition|)
block|{
name|checkCastFails
argument_list|(
name|value
argument_list|,
literal|"CHAR("
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|+
literal|")"
argument_list|,
name|STRING_TRUNC_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|checkCastToStringOkay
argument_list|(
name|value
argument_list|,
literal|"CHAR("
operator|+
name|len
operator|+
literal|")"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|checkCastToStringOkay
argument_list|(
name|value
argument_list|,
literal|"CHAR("
operator|+
operator|(
name|len
operator|+
literal|5
operator|)
operator|+
literal|")"
argument_list|,
name|expected
operator|+
name|spaces
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastToString
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
comment|// integer
name|checkCastToString
argument_list|(
literal|"123"
argument_list|,
literal|"CHAR(3)"
argument_list|,
literal|"123"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"0"
argument_list|,
literal|"CHAR"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"-123"
argument_list|,
literal|"CHAR(4)"
argument_list|,
literal|"-123"
argument_list|)
expr_stmt|;
comment|// decimal
name|checkCastToString
argument_list|(
literal|"123.4"
argument_list|,
literal|"CHAR(5)"
argument_list|,
literal|"123.4"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"-0.0"
argument_list|,
literal|"CHAR(2)"
argument_list|,
literal|".0"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"-123.4"
argument_list|,
literal|"CHAR(6)"
argument_list|,
literal|"-123.4"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"cast(1.29 as varchar(10))"
argument_list|,
literal|"1.29"
argument_list|,
literal|"VARCHAR(10) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"cast(.48 as varchar(10))"
argument_list|,
literal|".48"
argument_list|,
literal|"VARCHAR(10) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(2.523 as char(2))"
argument_list|,
name|STRING_TRUNC_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"cast(-0.29 as varchar(10))"
argument_list|,
literal|"-.29"
argument_list|,
literal|"VARCHAR(10) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"cast(-1.29 as varchar(10))"
argument_list|,
literal|"-1.29"
argument_list|,
literal|"VARCHAR(10) NOT NULL"
argument_list|)
expr_stmt|;
comment|// approximate
name|checkCastToString
argument_list|(
literal|"1.23E45"
argument_list|,
literal|"CHAR(7)"
argument_list|,
literal|"1.23E45"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"CAST(0 AS DOUBLE)"
argument_list|,
literal|"CHAR(3)"
argument_list|,
literal|"0E0"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"-1.20e-07"
argument_list|,
literal|"CHAR(7)"
argument_list|,
literal|"-1.2E-7"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"cast(0e0 as varchar(5))"
argument_list|,
literal|"CHAR(3)"
argument_list|,
literal|"0E0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TODO
condition|)
block|{
name|checkCastToString
argument_list|(
literal|"cast(-45e-2 as varchar(17))"
argument_list|,
literal|"CHAR(7)"
argument_list|,
literal|"-4.5E-1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TODO
condition|)
block|{
name|checkCastToString
argument_list|(
literal|"cast(4683442.3432498375e0 as varchar(20))"
argument_list|,
literal|"CHAR(19)"
argument_list|,
literal|"4.683442343249838E6"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TODO
condition|)
block|{
name|checkCastToString
argument_list|(
literal|"cast(-0.1 as real)"
argument_list|,
literal|"CHAR(5)"
argument_list|,
literal|"-1E-1"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(1.3243232e0 as varchar(4))"
argument_list|,
name|STRING_TRUNC_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(1.9e5 as char(4))"
argument_list|,
name|STRING_TRUNC_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// string
name|checkCastToString
argument_list|(
literal|"'abc'"
argument_list|,
literal|"CHAR(1)"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"'abc'"
argument_list|,
literal|"CHAR(3)"
argument_list|,
literal|"abc"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"cast('abc' as varchar(6))"
argument_list|,
literal|"CHAR(3)"
argument_list|,
literal|"abc"
argument_list|)
expr_stmt|;
comment|// date& time
name|checkCastToString
argument_list|(
literal|"date '2008-01-01'"
argument_list|,
literal|"CHAR(10)"
argument_list|,
literal|"2008-01-01"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"time '1:2:3'"
argument_list|,
literal|"CHAR(8)"
argument_list|,
literal|"01:02:03"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"timestamp '2008-1-1 1:2:3'"
argument_list|,
literal|"CHAR(19)"
argument_list|,
literal|"2008-01-01 01:02:03"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"timestamp '2008-1-1 1:2:3'"
argument_list|,
literal|"VARCHAR(30)"
argument_list|,
literal|"2008-01-01 01:02:03"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"interval '3-2' year to month"
argument_list|,
literal|"CHAR(5)"
argument_list|,
literal|"+3-02"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"interval '32' month"
argument_list|,
literal|"CHAR(3)"
argument_list|,
literal|"+32"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"interval '1 2:3:4' day to second"
argument_list|,
literal|"CHAR(11)"
argument_list|,
literal|"+1 02:03:04"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"interval '1234.56' second(4,2)"
argument_list|,
literal|"CHAR(8)"
argument_list|,
literal|"+1234.56"
argument_list|)
expr_stmt|;
comment|// boolean
name|checkCastToString
argument_list|(
literal|"True"
argument_list|,
literal|"CHAR(4)"
argument_list|,
literal|"TRUE"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"False"
argument_list|,
literal|"CHAR(5)"
argument_list|,
literal|"FALSE"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(true as char(3))"
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(false as char(4))"
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(true as varchar(3))"
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(false as varchar(4))"
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastExactNumericLimits
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
comment|// Test casting for min,max, out of range for exact numeric types
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUMERIC_TYPE_NAMES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|type
init|=
name|NUMERIC_TYPE_NAMES
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"DOUBLE"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"FLOAT"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"REAL"
argument_list|)
condition|)
block|{
comment|// Skip approx types
continue|continue;
block|}
comment|// Convert from literal to type
name|checkCastToScalarOkay
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|// Overflow test
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"BIGINT"
argument_list|)
condition|)
block|{
comment|// Literal of range
name|checkCastFails
argument_list|(
name|MAX_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|LITERAL_OUT_OF_RANGE_MESSAGE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkCastFails
argument_list|(
name|MIN_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|LITERAL_OUT_OF_RANGE_MESSAGE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkCastFails
argument_list|(
name|MAX_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|checkCastFails
argument_list|(
name|MIN_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
comment|// Convert from string to type
name|checkCastToScalarOkay
argument_list|(
literal|"'"
operator|+
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
operator|+
literal|"'"
argument_list|,
name|type
argument_list|,
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"'"
operator|+
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
operator|+
literal|"'"
argument_list|,
name|type
argument_list|,
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|checkCastFails
argument_list|(
literal|"'"
operator|+
name|MAX_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
operator|+
literal|"'"
argument_list|,
name|type
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|checkCastFails
argument_list|(
literal|"'"
operator|+
name|MIN_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
operator|+
literal|"'"
argument_list|,
name|type
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Convert from type to string
name|checkCastToString
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|checkCastFails
argument_list|(
literal|"'notnumeric'"
argument_list|,
name|type
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastToExactNumeric
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1"
argument_list|,
literal|"BIGINT"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1"
argument_list|,
literal|"SMALLINT"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1"
argument_list|,
literal|"TINYINT"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1"
argument_list|,
literal|"DECIMAL(4, 0)"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1"
argument_list|,
literal|"BIGINT"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1"
argument_list|,
literal|"SMALLINT"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1"
argument_list|,
literal|"TINYINT"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1"
argument_list|,
literal|"DECIMAL(4, 0)"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.234E3"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"1234"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-9.99E2"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"-999"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"'1'"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"' 01 '"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"'-1'"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"' -00 '"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
comment|// string to integer
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast('6543' as integer)"
argument_list|,
literal|"6543"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(' -123 ' as int)"
argument_list|,
literal|"-123"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast('654342432412312' as bigint)"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|,
literal|"654342432412312"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastStringToDecimal
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECIMAL
condition|)
block|{
return|return;
block|}
comment|// string to decimal
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast('1.29' as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"1.3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(' 1.25 ' as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"1.3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast('1.21' as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"1.2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(' -1.29 ' as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"-1.3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast('-1.25' as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"-1.3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(' -1.21 ' as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"-1.2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(' -1.21e' as decimal(2,1))"
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastIntervalToNumeric
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
comment|// interval to decimal
if|if
condition|(
name|DECIMAL
condition|)
block|{
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '1.29' second(1,2) as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"1.3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '1.25' second as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"1.3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '-1.29' second as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"-1.3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '-1.25' second as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"-1.3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '-1.21' second as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"-1.2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '5' minute as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"5.0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '5' hour as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"5.0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '5' day as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"5.0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '5' month as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"5.0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '5' year as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"5.0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '-5' day as decimal(2,1))"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
literal|"-5.0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|INTERVAL
condition|)
block|{
return|return;
block|}
comment|// Interval to bigint
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '1.25' second as bigint)"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '-1.29' second(1,2) as bigint)"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '5' day as bigint)"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
comment|// Interval to integer
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '1.25' second as integer)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '-1.29' second(1,2) as integer)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast(INTERVAL '5' day as integer)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastToInterval
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTERVAL
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(5 as interval second)"
argument_list|,
literal|"+5.000000"
argument_list|,
literal|"INTERVAL SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(5 as interval minute)"
argument_list|,
literal|"+5"
argument_list|,
literal|"INTERVAL MINUTE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(5 as interval hour)"
argument_list|,
literal|"+5"
argument_list|,
literal|"INTERVAL HOUR NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(5 as interval day)"
argument_list|,
literal|"+5"
argument_list|,
literal|"INTERVAL DAY NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(5 as interval month)"
argument_list|,
literal|"+5"
argument_list|,
literal|"INTERVAL MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(5 as interval year)"
argument_list|,
literal|"+5"
argument_list|,
literal|"INTERVAL YEAR NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(5.7 as interval day)"
argument_list|,
literal|"+6"
argument_list|,
literal|"INTERVAL DAY NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(-5.7 as interval day)"
argument_list|,
literal|"-6"
argument_list|,
literal|"INTERVAL DAY NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(3456 as interval month(4))"
argument_list|,
literal|"+3456"
argument_list|,
literal|"INTERVAL MONTH(4) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(-5723 as interval minute(4))"
argument_list|,
literal|"-5723"
argument_list|,
literal|"INTERVAL MINUTE(4) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastIntervalToInterval
parameter_list|()
block|{
if|if
condition|(
operator|!
name|INTERVAL
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(interval '2 5' day to hour as interval hour to minute)"
argument_list|,
literal|"+29:00"
argument_list|,
literal|"INTERVAL HOUR TO MINUTE NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastWithRoundingToScalar
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.25"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.25E0"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|checkCastToScalarOkay
argument_list|(
literal|"1.5"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"5E-1"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.75"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.75E0"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.25"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.25E0"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.5"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"-2"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-5E-1"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.75"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"-2"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.75E0"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"-2"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.23454"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"1.2345"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.23454E0"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"1.2345"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.23455"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"1.2346"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"5E-5"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"0.0001"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.99995"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"2.0000"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"1.99995E0"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"2.0000"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.23454"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"-1.2345"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.23454E0"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"-1.2345"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.23455"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"-1.2346"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-5E-5"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"-0.0001"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.99995"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"-2.0000"
argument_list|)
expr_stmt|;
name|checkCastToScalarOkay
argument_list|(
literal|"-1.99995E0"
argument_list|,
literal|"DECIMAL(8, 4)"
argument_list|,
literal|"-2.0000"
argument_list|)
expr_stmt|;
comment|// 9.99 round to 10.0, should give out of range error
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(9.99 as decimal(2,1))"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastDecimalToDoubleToInteger
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast( cast(1.25 as double) as integer)"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast( cast(-1.25 as double) as integer)"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast( cast(1.75 as double) as integer)"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast( cast(-1.75 as double) as integer)"
argument_list|,
literal|"-2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast( cast(1.5 as double) as integer)"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cast( cast(-1.5 as double) as integer)"
argument_list|,
literal|"-2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastApproxNumericLimits
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
comment|// Test casting for min,max, out of range for approx numeric types
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUMERIC_TYPE_NAMES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|type
init|=
name|NUMERIC_TYPE_NAMES
index|[
name|i
index|]
decl_stmt|;
name|boolean
name|isFloat
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"DOUBLE"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"FLOAT"
argument_list|)
condition|)
block|{
name|isFloat
operator|=
literal|false
expr_stmt|;
block|}
if|else if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"REAL"
argument_list|)
condition|)
block|{
name|isFloat
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// Skip non-approx types
continue|continue;
block|}
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
comment|// Convert from literal to type
name|checkCastToApproxOkay
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|Double
operator|.
name|parseDouble
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|)
argument_list|,
name|isFloat
condition|?
literal|1E32
else|:
literal|0
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|Double
operator|.
name|parseDouble
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFloat
condition|)
block|{
name|checkCastFails
argument_list|(
name|MAX_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Double: Literal out of range
name|checkCastFails
argument_list|(
name|MAX_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|LITERAL_OUT_OF_RANGE_MESSAGE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Underflow: goes to 0
name|checkCastToApproxOkay
argument_list|(
name|MIN_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Convert from string to type
name|checkCastToApproxOkay
argument_list|(
literal|"'"
operator|+
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
operator|+
literal|"'"
argument_list|,
name|type
argument_list|,
name|Double
operator|.
name|parseDouble
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|)
argument_list|,
name|isFloat
condition|?
literal|1E32
else|:
literal|0
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
literal|"'"
operator|+
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
operator|+
literal|"'"
argument_list|,
name|type
argument_list|,
name|Double
operator|.
name|parseDouble
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checkCastFails
argument_list|(
literal|"'"
operator|+
name|MAX_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
operator|+
literal|"'"
argument_list|,
name|type
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Underflow: goes to 0
name|checkCastToApproxOkay
argument_list|(
literal|"'"
operator|+
name|MIN_OVERFLOW_NUMERIC_STRINGS
index|[
name|i
index|]
operator|+
literal|"'"
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Convert from type to string
comment|// Treated as DOUBLE
name|checkCastToString
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
literal|null
argument_list|,
name|isFloat
condition|?
literal|null
else|:
literal|"1.79769313486231E308"
argument_list|)
expr_stmt|;
comment|// TODO: The following tests are slightly different depending on
comment|// whether the java or fennel calc are used.
comment|// Try to make them the same
if|if
condition|(
literal|false
comment|/* fennel calc*/
condition|)
block|{
comment|// Treated as FLOAT or DOUBLE
name|checkCastToString
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
comment|// Treated as DOUBLE
name|isFloat
condition|?
literal|"3.402824E38"
else|:
literal|"1.797693134862316E308"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
literal|null
argument_list|,
comment|// Treated as FLOAT or DOUBLE
name|isFloat
condition|?
literal|null
else|:
literal|"4.940656458412465E-324"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|isFloat
condition|?
literal|"1.401299E-45"
else|:
literal|"4.940656458412465E-324"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
literal|false
comment|/* JavaCalc */
condition|)
block|{
comment|// Treated as FLOAT or DOUBLE
name|checkCastToString
argument_list|(
name|MAX_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
comment|// Treated as DOUBLE
name|isFloat
condition|?
literal|"3.402823E38"
else|:
literal|"1.797693134862316E308"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
literal|null
argument_list|,
name|isFloat
condition|?
literal|null
else|:
literal|null
argument_list|)
expr_stmt|;
comment|// Treated as FLOAT or DOUBLE
name|checkCastToString
argument_list|(
name|MIN_NUMERIC_STRINGS
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|isFloat
condition|?
literal|"1.401298E-45"
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
name|checkCastFails
argument_list|(
literal|"'notnumeric'"
argument_list|,
name|type
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastToApproxNumeric
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
literal|"1"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
literal|"1.0"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
literal|"-2.3"
argument_list|,
literal|"FLOAT"
argument_list|,
operator|-
literal|2.3
argument_list|,
literal|0.000001
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
literal|"'1'"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
literal|"'  -1e-37  '"
argument_list|,
literal|"DOUBLE"
argument_list|,
operator|-
literal|1e-37
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
literal|"1e0"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checkCastToApproxOkay
argument_list|(
literal|"0e0"
argument_list|,
literal|"REAL"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastNull
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
comment|// null
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as integer)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECIMAL
condition|)
block|{
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as decimal(4,3))"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as double)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as varchar(10))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as char(10))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as date)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as time)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as timestamp)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval year to month)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval day to second(3))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as boolean)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastDateTime
parameter_list|()
block|{
comment|// Test cast for date/time/timestamp
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(TIMESTAMP '1945-02-24 12:42:25.34' as TIMESTAMP)"
argument_list|,
literal|"1945-02-24 12:42:25"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(TIME '12:42:25.34' as TIME)"
argument_list|,
literal|"12:42:25"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
comment|// test rounding
if|if
condition|(
name|enable
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(TIME '12:42:25.9' as TIME)"
argument_list|,
literal|"12:42:26"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Bug
operator|.
name|FRG282_FIXED
condition|)
block|{
comment|// test precision
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(TIME '12:42:25.34' as TIME(2))"
argument_list|,
literal|"12:42:25.34"
argument_list|,
literal|"TIME(2) NOT NULL"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(DATE '1945-02-24' as DATE)"
argument_list|,
literal|"1945-02-24"
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
comment|// timestamp<-> time
if|if
condition|(
name|enable
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(TIMESTAMP '1945-02-24 12:42:25.34' as TIME)"
argument_list|,
literal|"12:42:25"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
block|}
comment|// time<-> string
name|checkCastToString
argument_list|(
literal|"TIME '12:42:25'"
argument_list|,
literal|null
argument_list|,
literal|"12:42:25"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TODO
condition|)
block|{
name|checkCastToString
argument_list|(
literal|"TIME '12:42:25.34'"
argument_list|,
literal|null
argument_list|,
literal|"12:42:25.34"
argument_list|)
expr_stmt|;
block|}
comment|// Generate the current date as a string, e.g. "2007-04-18". The value
comment|// is guaranteed to be good for at least 2 minutes, which should give
comment|// us time to run the rest of the tests.
specifier|final
name|String
name|today
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd"
argument_list|)
operator|.
name|format
argument_list|(
name|getCalendarNotTooNear
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|)
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(DATE '1945-02-24' as TIMESTAMP)"
argument_list|,
literal|"1945-02-24 00:00:00"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
comment|// Note: Casting to time(0) should lose date info and fractional
comment|// seconds, then casting back to timestamp should initialize to
comment|// current_date.
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(cast(TIMESTAMP '1945-02-24 12:42:25.34' as TIME) as TIMESTAMP)"
argument_list|,
name|today
operator|+
literal|" 12:42:25"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(TIME '12:42:25.34' as TIMESTAMP)"
argument_list|,
name|today
operator|+
literal|" 12:42:25"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
comment|// timestamp<-> date
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(TIMESTAMP '1945-02-24 12:42:25.34' as DATE)"
argument_list|,
literal|"1945-02-24"
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
comment|// Note: casting to Date discards Time fields
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast(cast(TIMESTAMP '1945-02-24 12:42:25.34' as DATE) as TIMESTAMP)"
argument_list|,
literal|"1945-02-24 00:00:00"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('12:42:25' as TIME)"
argument_list|,
literal|"12:42:25"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('1:42:25' as TIME)"
argument_list|,
literal|"01:42:25"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('1:2:25' as TIME)"
argument_list|,
literal|"01:02:25"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('  12:42:25  ' as TIME)"
argument_list|,
literal|"12:42:25"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('12:42:25.34' as TIME)"
argument_list|,
literal|"12:42:25"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FRG282_FIXED
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('12:42:25.34' as TIME(2))"
argument_list|,
literal|"12:42:25.34"
argument_list|,
literal|"TIME(2) NOT NULL"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('nottime' as TIME)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('1241241' as TIME)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('12:54:78' as TIME)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// timestamp<-> string
name|checkCastToString
argument_list|(
literal|"TIMESTAMP '1945-02-24 12:42:25'"
argument_list|,
literal|null
argument_list|,
literal|"1945-02-24 12:42:25"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TODO
condition|)
block|{
comment|// TODO: casting allows one to discard precision without error
name|checkCastToString
argument_list|(
literal|"TIMESTAMP '1945-02-24 12:42:25.34'"
argument_list|,
literal|null
argument_list|,
literal|"1945-02-24 12:42:25.34"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('1945-02-24 12:42:25' as TIMESTAMP)"
argument_list|,
literal|"1945-02-24 12:42:25"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('1945-2-2 12:2:5' as TIMESTAMP)"
argument_list|,
literal|"1945-02-02 12:02:05"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('  1945-02-24 12:42:25  ' as TIMESTAMP)"
argument_list|,
literal|"1945-02-24 12:42:25"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('1945-02-24 12:42:25.34' as TIMESTAMP)"
argument_list|,
literal|"1945-02-24 12:42:25"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FRG282_FIXED
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('1945-02-24 12:42:25.34' as TIMESTAMP(2))"
argument_list|,
literal|"1945-02-24 12:42:25.34"
argument_list|,
literal|"TIMESTAMP(2) NOT NULL"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('nottime' as TIMESTAMP)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('1241241' as TIMESTAMP)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('1945-20-24 12:42:25.34' as TIMESTAMP)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('1945-01-24 25:42:25.34' as TIMESTAMP)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// date<-> string
name|checkCastToString
argument_list|(
literal|"DATE '1945-02-24'"
argument_list|,
literal|null
argument_list|,
literal|"1945-02-24"
argument_list|)
expr_stmt|;
name|checkCastToString
argument_list|(
literal|"DATE '1945-2-24'"
argument_list|,
literal|null
argument_list|,
literal|"1945-02-24"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('1945-02-24' as DATE)"
argument_list|,
literal|"1945-02-24"
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"cast('  1945-02-24  ' as DATE)"
argument_list|,
literal|"1945-02-24"
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('notdate' as DATE)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('52534253' as DATE)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('1945-30-24' as DATE)"
argument_list|,
name|BAD_DATETIME_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// cast null
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as date)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as timestamp)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as time)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(cast(null as varchar(10)) as time)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(cast(null as varchar(10)) as date)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(cast(null as varchar(10)) as timestamp)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(cast(null as date) as timestamp)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(cast(null as time) as timestamp)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(cast(null as timestamp) as date)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(cast(null as timestamp) as time)"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a Calendar that is the current time, pausing if we are within 2    * minutes of midnight or the top of the hour.    *    * @param timeUnit Time unit    * @return calendar    */
specifier|protected
specifier|static
name|Calendar
name|getCalendarNotTooNear
parameter_list|(
name|int
name|timeUnit
parameter_list|)
block|{
specifier|final
name|Calendar
name|cal
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|cal
operator|.
name|setTimeInMillis
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|timeUnit
condition|)
block|{
case|case
name|Calendar
operator|.
name|DAY_OF_MONTH
case|:
comment|// Within two minutes of the end of the day. Wait in 10s
comment|// increments until calendar moves into the next next day.
if|if
condition|(
operator|(
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|)
operator|==
literal|23
operator|)
operator|&&
operator|(
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|)
operator|>=
literal|58
operator|)
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
name|cal
return|;
case|case
name|Calendar
operator|.
name|HOUR_OF_DAY
case|:
comment|// Within two minutes of the top of the hour. Wait in 10s
comment|// increments until calendar moves into the next next day.
if|if
condition|(
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|)
operator|>=
literal|58
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
name|cal
return|;
default|default:
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"unexpected time unit "
operator|+
name|timeUnit
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastToBoolean
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
comment|// string to boolean
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast('true' as boolean)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast('false' as boolean)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast('  trUe' as boolean)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast('  fALse' as boolean)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast('unknown' as boolean)"
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(cast('true' as varchar(10))  as boolean)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(cast('false' as varchar(10)) as boolean)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(cast('blah' as varchar(10)) as boolean)"
argument_list|,
name|INVALID_CHAR_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCase
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"case when 'a'='a' then 1 end"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"case 2 when 1 then 'a' when 2 then 'bcd' end"
argument_list|,
literal|"bcd"
argument_list|,
literal|"CHAR(3)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"case 1 when 1 then 'a' when 2 then 'bcd' end"
argument_list|,
literal|"a  "
argument_list|,
literal|"CHAR(3)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"case 1 when 1 then cast('a' as varchar(1)) "
operator|+
literal|"when 2 then cast('bcd' as varchar(3)) end"
argument_list|,
literal|"a"
argument_list|,
literal|"VARCHAR(3)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECIMAL
condition|)
block|{
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"case 2 when 1 then 11.2 when 2 then 4.543 else null end"
argument_list|,
literal|"DECIMAL(5, 3)"
argument_list|,
literal|"4.543"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"case 1 when 1 then 11.2 when 2 then 4.543 else null end"
argument_list|,
literal|"DECIMAL(5, 3)"
argument_list|,
literal|"11.200"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"case 'a' when 'a' then 1 end"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"case 1 when 1 then 11.2e0 when 2 then cast(4 as bigint) else 3 end"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|11.2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"case 1 when 1 then 11.2e0 when 2 then 4 else null end"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|11.2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"case 2 when 1 then 11.2e0 when 2 then 4 else null end"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"case 1 when 1 then 11.2e0 when 2 then 4.543 else null end"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|11.2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"case 2 when 1 then 11.2e0 when 2 then 4.543 else null end"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|4.543
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"case 'a' when 'b' then 1 end"
argument_list|)
expr_stmt|;
comment|// Per spec, 'case x when y then ...'
comment|// translates to 'case when x = y then ...'
comment|// so nulls do not match.
comment|// (Unlike Oracle's 'decode(null, null, ...)', by the way.)
name|tester
operator|.
name|checkString
argument_list|(
literal|"case cast(null as int) when cast(null as int) then 'nulls match' else 'nulls do not match' end"
argument_list|,
literal|"nulls do not match"
argument_list|,
literal|"CHAR(18) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"case when 'a'=cast(null as varchar(1)) then 1 else 2 end"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
comment|// equivalent to "nullif('a',cast(null as varchar(1)))"
name|tester
operator|.
name|checkString
argument_list|(
literal|"case when 'a' = cast(null as varchar(1)) then null else 'a' end"
argument_list|,
literal|"a"
argument_list|,
literal|"CHAR(1)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TODO
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"case 1 when 1 then row(1,2) when 2 then row(2,3) end"
argument_list|,
literal|"ROW(INTEGER NOT NULL, INTEGER NOT NULL)"
argument_list|,
literal|"row(1,2)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"case 1 when 1 then row('a','b') when 2 then row('ab','cd') end"
argument_list|,
literal|"ROW(CHAR(2) NOT NULL, CHAR(2) NOT NULL)"
argument_list|,
literal|"row('a ','b ')"
argument_list|)
expr_stmt|;
block|}
comment|// multiple values in some cases (introduced in SQL:2011)
name|tester
operator|.
name|checkString
argument_list|(
literal|"case 1 "
operator|+
literal|"when 1, 2 then '1 or 2' "
operator|+
literal|"when 2 then 'not possible' "
operator|+
literal|"when 3, 2 then '3' "
operator|+
literal|"else 'none of the above' "
operator|+
literal|"end"
argument_list|,
literal|"1 or 2           "
argument_list|,
literal|"CHAR(17) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"case 2 "
operator|+
literal|"when 1, 2 then '1 or 2' "
operator|+
literal|"when 2 then 'not possible' "
operator|+
literal|"when 3, 2 then '3' "
operator|+
literal|"else 'none of the above' "
operator|+
literal|"end"
argument_list|,
literal|"1 or 2           "
argument_list|,
literal|"CHAR(17) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"case 3 "
operator|+
literal|"when 1, 2 then '1 or 2' "
operator|+
literal|"when 2 then 'not possible' "
operator|+
literal|"when 3, 2 then '3' "
operator|+
literal|"else 'none of the above' "
operator|+
literal|"end"
argument_list|,
literal|"3                "
argument_list|,
literal|"CHAR(17) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"case 4 "
operator|+
literal|"when 1, 2 then '1 or 2' "
operator|+
literal|"when 2 then 'not possible' "
operator|+
literal|"when 3, 2 then '3' "
operator|+
literal|"else 'none of the above' "
operator|+
literal|"end"
argument_list|,
literal|"none of the above"
argument_list|,
literal|"CHAR(17) NOT NULL"
argument_list|)
expr_stmt|;
comment|// TODO: Check case with multisets
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCaseType
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CASE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"case 1 when 1 then current_timestamp else null end"
argument_list|,
literal|"TIMESTAMP(0)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"case 1 when 1 then current_timestamp else current_timestamp end"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"case when true then current_timestamp else null end"
argument_list|,
literal|"TIMESTAMP(0)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"case when true then current_timestamp end"
argument_list|,
literal|"TIMESTAMP(0)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"case 'x' when 'a' then 3 when 'b' then null else 4.5 end"
argument_list|,
literal|"DECIMAL(11, 1)"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests support for JDBC functions.    *    *<p>See FRG-97 "Support for JDBC escape syntax is incomplete".    */
annotation|@
name|Test
specifier|public
name|void
name|testJdbcFn
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
operator|new
name|SqlJdbcFunctionCall
argument_list|(
literal|"dummy"
argument_list|)
argument_list|)
expr_stmt|;
comment|// There follows one test for each function in appendix C of the JDBC
comment|// 3.0 specification. The test is 'if-false'd out if the function is
comment|// not implemented or is broken.
comment|// Numeric Functions
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn ABS(-3)}"
argument_list|,
literal|3
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn ACOS(float)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn ASIN(float)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn ATAN(float)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn ATAN2(float1, float2)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn CEILING(-2.6)}"
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn COS(float)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn COT(float)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn DEGREES(number)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"{fn EXP(2)}"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|7.389
argument_list|,
literal|0.001
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn FLOOR(2.6)}"
argument_list|,
literal|2
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"{fn LOG(10)}"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|2.30258
argument_list|,
literal|0.001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"{fn LOG10(100)}"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn MOD(19, 4)}"
argument_list|,
literal|3
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn PI()}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn POWER(2, 3)}"
argument_list|,
literal|8.0
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn RADIANS(number)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn RAND(integer)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn ROUND(number, places)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn SIGN(number)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn SIN(float)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn SQRT(float)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn TAN(float)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn TRUNCATE(number, places)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|// String Functions
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn ASCII(string)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn CHAR(code)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn CONCAT('foo', 'bar')}"
argument_list|,
literal|"foobar"
argument_list|,
literal|"CHAR(6) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn DIFFERENCE(string1, string2)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|// REVIEW: is this result correct? I think it should be "abcCdef"
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn INSERT('abc', 1, 2, 'ABCdef')}"
argument_list|,
literal|"ABCdefc"
argument_list|,
literal|"VARCHAR(9) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn LCASE('foo' || 'bar')}"
argument_list|,
literal|"foobar"
argument_list|,
literal|"CHAR(6) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn LEFT(string, count)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn LENGTH(string)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn LOCATE('ha', 'alphabet')}"
argument_list|,
literal|4
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
comment|// only the 2 arg version of locate is implemented
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn LOCATE(string1, string2[, start])}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|// ltrim is implemented but has a bug in arg checking
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn LTRIM(' xxx  ')}"
argument_list|,
literal|"xxx"
argument_list|,
literal|"VARCHAR(6)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn REPEAT(string, count)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn REPLACE(string1, string2, string3)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn RIGHT(string, count)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|// rtrim is implemented but has a bug in arg checking
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn RTRIM(' xxx  ')}"
argument_list|,
literal|"xxx"
argument_list|,
literal|"VARCHAR(6)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn SOUNDEX(string)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn SPACE(count)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn SUBSTRING('abcdef', 2, 3)}"
argument_list|,
literal|"bcd"
argument_list|,
literal|"VARCHAR(6) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn UCASE('xxx')}"
argument_list|,
literal|"XXX"
argument_list|,
literal|"CHAR(3) NOT NULL"
argument_list|)
expr_stmt|;
comment|// Time and Date Functions
name|tester
operator|.
name|checkType
argument_list|(
literal|"{fn CURDATE()}"
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"{fn CURTIME()}"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn DAYNAME(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn DAYOFMONTH(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn DAYOFWEEK(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn DAYOFYEAR(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn HOUR(time)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn MINUTE(time)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn MONTH(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn MONTHNAME(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkType
argument_list|(
literal|"{fn NOW()}"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn QUARTER(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn SECOND(time)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn TIMESTAMPADD(interval, count, timestamp)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn TIMESTAMPDIFF(interval, timestamp1, timestamp2)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn WEEK(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn YEAR(date)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|// System Functions
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn DATABASE()}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn IFNULL(expression, value)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn USER()}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|// Conversion Functions
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"{fn CONVERT(value, SQLtype)}"
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelect
parameter_list|()
block|{
name|tester
operator|.
name|check
argument_list|(
literal|"select * from (values(1))"
argument_list|,
name|SqlTests
operator|.
name|INTEGER_TYPE_CHECKER
argument_list|,
literal|"1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Check return type on scalar subquery in select list.  Note return
comment|// type is always nullable even if subquery select value is NOT NULL.
comment|// Bug FRG-189 causes this test to fail only in SqlOperatorTest; not
comment|// in subtypes.
if|if
condition|(
name|Bug
operator|.
name|FRG189_FIXED
operator|||
operator|(
name|getClass
argument_list|()
operator|!=
name|SqlOperatorTest
operator|.
name|class
operator|)
operator|&&
name|Bug
operator|.
name|TODO_FIXED
condition|)
block|{
name|tester
operator|.
name|checkType
argument_list|(
literal|"SELECT *,(SELECT * FROM (VALUES(1))) FROM (VALUES(2))"
argument_list|,
literal|"RecordType(INTEGER NOT NULL EXPR$0, INTEGER EXPR$1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"SELECT *,(SELECT * FROM (VALUES(CAST(10 as BIGINT)))) "
operator|+
literal|"FROM (VALUES(CAST(10 as bigint)))"
argument_list|,
literal|"RecordType(BIGINT NOT NULL EXPR$0, BIGINT EXPR$1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|" SELECT *,(SELECT * FROM (VALUES(10.5))) FROM (VALUES(10.5))"
argument_list|,
literal|"RecordType(DECIMAL(3, 1) NOT NULL EXPR$0, DECIMAL(3, 1) EXPR$1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"SELECT *,(SELECT * FROM (VALUES('this is a char'))) "
operator|+
literal|"FROM (VALUES('this is a char too'))"
argument_list|,
literal|"RecordType(CHAR(18) NOT NULL EXPR$0, CHAR(14) EXPR$1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"SELECT *,(SELECT * FROM (VALUES(true))) FROM (values(false))"
argument_list|,
literal|"RecordType(BOOLEAN NOT NULL EXPR$0, BOOLEAN EXPR$1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|" SELECT *,(SELECT * FROM (VALUES(cast('abcd' as varchar(10))))) "
operator|+
literal|"FROM (VALUES(CAST('abcd' as varchar(10))))"
argument_list|,
literal|"RecordType(VARCHAR(10) NOT NULL EXPR$0, VARCHAR(10) EXPR$1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"SELECT *,"
operator|+
literal|"  (SELECT * FROM (VALUES(TIMESTAMP '2006-01-01 12:00:05'))) "
operator|+
literal|"FROM (VALUES(TIMESTAMP '2006-01-01 12:00:05'))"
argument_list|,
literal|"RecordType(TIMESTAMP(0) NOT NULL EXPR$0, TIMESTAMP(0) EXPR$1) NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLiteralChain
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LITERAL_CHAIN
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"'buttered'\n' toast'"
argument_list|,
literal|"buttered toast"
argument_list|,
literal|"CHAR(14) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"'corned'\n' beef'\n' on'\n' rye'"
argument_list|,
literal|"corned beef on rye"
argument_list|,
literal|"CHAR(18) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"_latin1'Spaghetti'\n' all''Amatriciana'"
argument_list|,
literal|"Spaghetti all'Amatriciana"
argument_list|,
literal|"CHAR(25) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"x'1234'\n'abcd' = x'1234abcd'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"x'1234'\n'' = x'1234'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"x''\n'ab' = x'ab'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRow
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ROW
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAndOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true and false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true and true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) and false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false and cast(null as boolean)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as boolean) and true"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true and (not false)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAndOperator2
parameter_list|()
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"case when false then unknown else true end and true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"case when false then cast(null as boolean) else true end and true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"case when false then null else true end and true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAndOperatorLazy
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|)
expr_stmt|;
comment|// lazy eval returns FALSE;
comment|// eager eval executes RHS of AND and throws;
comment|// both are valid
name|tester
operator|.
name|check
argument_list|(
literal|"values 1> 2 and sqrt(-4) = -2"
argument_list|,
name|SqlTests
operator|.
name|BOOLEAN_TYPE_CHECKER
argument_list|,
operator|new
name|ValueOrExceptionResultChecker
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|,
name|INVALID_ARG_FOR_POWER
argument_list|,
name|CODE_2201F
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConcatOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CONCAT
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|" 'a'||'b' "
argument_list|,
literal|"ab"
argument_list|,
literal|"CHAR(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|" 'a' || cast(null as char(2)) "
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|" cast(null as char(2)) || 'b' "
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|" cast(null as char(1)) || cast(null as char(2)) "
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|" x'fe'||x'df' "
argument_list|,
literal|"fedf"
argument_list|,
literal|"BINARY(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"x'ff' || cast(null as varbinary)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDivideOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DIVIDE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"10 / 5"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"-10 / 5"
argument_list|,
literal|"-2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"1 / 3"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|" cast(10.0 as double) / 5"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|2.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|" cast(10.0 as real) / 5"
argument_list|,
literal|"REAL NOT NULL"
argument_list|,
literal|2.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|" 6.0 / cast(10.0 as real) "
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|0.6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"10.0 / 5.0"
argument_list|,
literal|"DECIMAL(9, 6) NOT NULL"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECIMAL
condition|)
block|{
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"1.0 / 3.0"
argument_list|,
literal|"DECIMAL(8, 6) NOT NULL"
argument_list|,
literal|"0.333333"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"100.1 / 0.0001"
argument_list|,
literal|"DECIMAL(14, 7) NOT NULL"
argument_list|,
literal|"1001000.0000000"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"100.1 / 0.00000001"
argument_list|,
literal|"DECIMAL(19, 8) NOT NULL"
argument_list|,
literal|"10010000000.00000000"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkNull
argument_list|(
literal|"1e1 / cast(null as float)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"100.1 / 0.00000000000000001"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDivideOperatorIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '-2:2' hour to minute / 3"
argument_list|,
literal|"-0:41"
argument_list|,
literal|"INTERVAL HOUR TO MINUTE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2:5:12' hour to second / 2 / -3"
argument_list|,
literal|"-0:20:52.000000"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"interval '2' day / cast(null as bigint)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval month) / 2"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTERVAL
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '3-3' year to month / 15e-1"
argument_list|,
literal|"+02-02"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '3-4' year to month / 4.5"
argument_list|,
literal|"+00-08"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEqualsOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1=1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1=1.0"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.34=1.34"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1=1.34"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1e2=100e0"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1e2=101"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(1e2 as real)=cast(101 as bigint)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a'='b'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true = true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true = false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false = true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false = false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast('a' as varchar(30))=cast('a' as varchar(30))"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast('a ' as varchar(30))=cast('a' as varchar(30))"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast('a' as varchar(30))=cast('b' as varchar(30))"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast('a' as varchar(30))=cast('a' as varchar(15))"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as boolean)=cast(null as boolean)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as integer)=1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as varchar(10))='a'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEqualsOperatorInterval
parameter_list|()
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day = interval '1' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day = interval '2' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2:2:2' hour to second = interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval hour) = interval '2' minute"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGreaterThanOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1>2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(-1 as TINYINT)>cast(1 as TINYINT)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(1 as SMALLINT)>cast(1 as SMALLINT)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"2>1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1>1.2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-1.1>-1.2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1>1.1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2>1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1e1>1.2e1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(-1.1 as real)> cast(-1.2 as real)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1e2>1.1e2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e0>1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(1.2e0 as real)>1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true>false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true>true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false>false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false>true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"3.0>cast(null as double)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"DATE '2013-02-23'> DATE '1945-02-24'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"DATE '2013-02-23'> CAST(NULL AS DATE)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGreaterThanOperatorIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day> interval '1' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day> interval '5' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2 2:2:2' day to second> interval '2' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day> interval '2' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day> interval '-2' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day> interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' minute> interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' second> interval '2' minute"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval hour)> interval '2' minute"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"interval '2:2' hour to minute> cast(null as interval second)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsDistinctFromOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_DISTINCT_FROM
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 is distinct from 1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 is distinct from 1.0"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 is distinct from 2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) is distinct from 2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) is distinct from cast(null as integer)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.23 is distinct from 1.23"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.23 is distinct from 5.23"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-23e0 is distinct from -2.3e1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
comment|// IS DISTINCT FROM not implemented for ROW yet
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"row(1,1) is distinct from row(1,1)"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"row(1,1) is distinct from row(1,2)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Intervals
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day is distinct from interval '1' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '10' hour is distinct from interval '10' hour"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNotDistinctFromOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 is not distinct from 1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 is not distinct from 1.0"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 is not distinct from 2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) is not distinct from 2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) is not distinct from cast(null as integer)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.23 is not distinct from 1.23"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.23 is not distinct from 5.23"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-23e0 is not distinct from -2.3e1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// IS NOT DISTINCT FROM not implemented for ROW yet
if|if
condition|(
literal|false
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"row(1,1) is not distinct from row(1,1)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"row(1,1) is not distinct from row(1,2)"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Intervals
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day is not distinct from interval '1' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '10' hour is not distinct from interval '10' hour"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGreaterThanOrEqualOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1>=2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-1>=1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1>=1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"2>=1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1>=1.2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-1.1>=-1.2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1>=1.1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2>=1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e4>=1e5"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e4>=cast(1e5 as real)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2>=cast(1e5 as double)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"120000>=cast(1e5 as real)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true>=false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true>=true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false>=false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false>=true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as real)>=999"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGreaterThanOrEqualOperatorIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day>= interval '1' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day>= interval '5' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2 2:2:2' day to second>= interval '2' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day>= interval '2' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day>= interval '-2' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day>= interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' minute>= interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' second>= interval '2' minute"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval hour)>= interval '2' minute"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"interval '2:2' hour to minute>= cast(null as interval second)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IN
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 in (0, 1, 2)"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"3 in (0, 1, 2)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) in (0, 1, 2)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) in (0, cast(null as integer), 2)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FRG327_FIXED
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) in (0, null, 2)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 in (0, null, 2)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
comment|// AND has lower precedence than IN
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false and true in (false, false)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Bug
operator|.
name|TODO_FIXED
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkFails
argument_list|(
literal|"'foo' in (^)^"
argument_list|,
literal|"(?s).*Encountered \"\\)\" at .*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNotInOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_IN
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 not in (0, 1, 2)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"3 not in (0, 1, 2)"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) not in (0, 1, 2)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) not in (0, cast(null as integer), 2)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FRG327_FIXED
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as integer) not in (0, null, 2)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 not in (0, null, 2)"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// AND has lower precedence than NOT IN
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true and false not in (true, true)"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Bug
operator|.
name|TODO_FIXED
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkFails
argument_list|(
literal|"'foo' not in (^)^"
argument_list|,
literal|"(?s).*Encountered \"\\)\" at .*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOverlapsOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OVERLAPS
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FRG187_FIXED
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(date '1-2-3', date '1-2-3') overlaps (date '1-2-3', interval '1' year)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(date '1-2-3', date '1-2-3') overlaps (date '4-5-6', interval '1' year)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(date '1-2-3', date '4-5-6') overlaps (date '2-2-3', date '3-4-5')"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"(cast(null as date), date '1-2-3') overlaps (date '1-2-3', interval '1' year)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"(date '1-2-3', date '1-2-3') overlaps (date '1-2-3', cast(null as date))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(time '1:2:3', interval '1' second) overlaps (time '23:59:59', time '1:2:3')"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(time '1:2:3', interval '1' second) overlaps (time '23:59:59', time '1:2:2')"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(time '1:2:3', interval '1' second) overlaps (time '23:59:59', interval '2' hour)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"(time '1:2:3', cast(null as time)) overlaps (time '23:59:59', time '1:2:3')"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"(time '1:2:3', interval '1' second) overlaps (time '23:59:59', cast(null as interval hour))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(timestamp '1-2-3 4:5:6', timestamp '1-2-3 4:5:6' ) overlaps (timestamp '1-2-3 4:5:6', interval '1 2:3:4.5' day to second)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(timestamp '1-2-3 4:5:6', timestamp '1-2-3 4:5:6' ) overlaps (timestamp '2-2-3 4:5:6', interval '1 2:3:4.5' day to second)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"(timestamp '1-2-3 4:5:6', cast(null as interval day) ) overlaps (timestamp '1-2-3 4:5:6', interval '1 2:3:4.5' day to second)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"(timestamp '1-2-3 4:5:6', timestamp '1-2-3 4:5:6' ) overlaps (cast(null as timestamp), interval '1 2:3:4.5' day to second)"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLessThanOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1<2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-1<1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1<1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"2<1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1<1.2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-1.1<-1.2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1<1.1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(1.1 as real)<1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(1.1 as real)<1.1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(1.1 as real)<cast(1.2 as real)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-1.1e-1<-1.2e-1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(1.1 as real)<cast(1.1 as double)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true<false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true<true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false<false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false<true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"123<cast(null as bigint)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as tinyint)<123"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as integer)<1.32"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLessThanOperatorInterval
parameter_list|()
block|{
if|if
condition|(
operator|!
name|DECIMAL
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day< interval '1' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day< interval '5' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2 2:2:2' day to second< interval '2' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day< interval '2' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day< interval '-2' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day< interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' minute< interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' second< interval '2' minute"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval hour)< interval '2' minute"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"interval '2:2' hour to minute< cast(null as interval second)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLessThanOrEqualOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1<=2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1<=1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-1<=1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"2<=1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1<=1.2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"-1.1<=-1.2"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1<=1.1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2<=1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1<=cast(1e2 as real)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1000<=cast(1e2 as real)"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e1<=1e2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.2e1<=cast(1e2 as real)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true<=false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true<=true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false<=false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false<=true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as real)<=cast(1 as real)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as integer)<=3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"3<=cast(null as smallint)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as integer)<=1.32"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLessThanOrEqualOperatorInterval
parameter_list|()
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day<= interval '1' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day<= interval '5' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2 2:2:2' day to second<= interval '2' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day<= interval '2' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day<= interval '-2' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day<= interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' minute<= interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' second<= interval '2' minute"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval hour)<= interval '2' minute"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"interval '2:2' hour to minute<= cast(null as interval second)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMinusOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"-2-1"
argument_list|,
literal|"-3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"-2-1-5"
argument_list|,
literal|"-8"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"2-1"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"cast(2.0 as double) -1"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"cast(1 as smallint)-cast(2.0 as real)"
argument_list|,
literal|"REAL NOT NULL"
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"2.4-cast(2.0 as real)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|0.4
argument_list|,
literal|0.00000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"1-2"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"10.0 - 5.0"
argument_list|,
literal|"DECIMAL(4, 1) NOT NULL"
argument_list|,
literal|"5.0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"19.68 - 4.2"
argument_list|,
literal|"DECIMAL(5, 2) NOT NULL"
argument_list|,
literal|"15.48"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"1e1-cast(null as double)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as tinyint) - cast(null as smallint)"
argument_list|)
expr_stmt|;
comment|// TODO: Fix bug
if|if
condition|(
name|Bug
operator|.
name|FNL25_FIXED
condition|)
block|{
comment|// Should throw out of range error
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(100 as tinyint) - cast(-100 as tinyint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(-20000 as smallint) - cast(20000 as smallint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(1.5e9 as integer) - cast(-1.5e9 as integer)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(-5e18 as bigint) - cast(5e18 as bigint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(5e18 as decimal(19,0)) - cast(-5e18 as decimal(19,0))"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(-5e8 as decimal(19,10)) - cast(5e8 as decimal(19,10))"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMinusIntervalOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2' day - interval '1' day"
argument_list|,
literal|"+1"
argument_list|,
literal|"INTERVAL DAY NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2' day - interval '1' minute"
argument_list|,
literal|"+1 23:59"
argument_list|,
literal|"INTERVAL DAY TO MINUTE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2' year - interval '1' month"
argument_list|,
literal|"+1-11"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2' year - interval '1' month - interval '3' year"
argument_list|,
literal|"-1-01"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval day) + interval '2' hour"
argument_list|)
expr_stmt|;
comment|// Datetime minus interval
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"time '12:03:01' - interval '1:1' hour to minute"
argument_list|,
literal|"11:02:01"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTERVAL
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"date '2005-03-02' - interval '5' day"
argument_list|,
literal|"2005-02-25"
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"timestamp '2003-08-02 12:54:01' - interval '-4 2:4' day to minute"
argument_list|,
literal|"2003-08-06 14:58:01"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
comment|// TODO: Tests with interval year months (not supported)
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMinusDateOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MINUS_DATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"(time '12:03:34' - time '11:57:23') minute to second"
argument_list|,
literal|"+6:11"
argument_list|,
literal|"INTERVAL MINUTE TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"(time '12:03:23' - time '11:57:23') minute"
argument_list|,
literal|"+6"
argument_list|,
literal|"INTERVAL MINUTE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"(time '12:03:34' - time '11:57:23') minute"
argument_list|,
literal|"+6"
argument_list|,
literal|"INTERVAL MINUTE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"(timestamp '2004-05-01 12:03:34' - timestamp '2004-04-29 11:57:23') day to second"
argument_list|,
literal|"+2 00:06:11"
argument_list|,
literal|"INTERVAL DAY TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"(timestamp '2004-05-01 12:03:34' - timestamp '2004-04-29 11:57:23') day to hour"
argument_list|,
literal|"+2 00"
argument_list|,
literal|"INTERVAL DAY TO HOUR NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"(date '2004-12-02' - date '2003-12-01') day"
argument_list|,
literal|"+367"
argument_list|,
literal|"INTERVAL DAY NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"(cast(null as date) - date '2003-12-01') day"
argument_list|)
expr_stmt|;
comment|// combine '<datetime> +<interval>' with '<datetime> -<datetime>'
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"timestamp '1969-04-29 0:0:0' +"
operator|+
literal|" (timestamp '2008-07-15 15:28:00' - "
operator|+
literal|"  timestamp '1969-04-29 0:0:0') day to second / 2"
argument_list|,
literal|"1988-12-06 07:44:00"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"date '1969-04-29' +"
operator|+
literal|" (date '2008-07-15' - "
operator|+
literal|"  date '1969-04-29') day / 2"
argument_list|,
literal|"1988-12-06"
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"time '01:23:44' +"
operator|+
literal|" (time '15:28:00' - "
operator|+
literal|"  time '01:23:44') hour to second / 2"
argument_list|,
literal|"08:25:52"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|DT1684_FIXED
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"(date '1969-04-29' +"
operator|+
literal|" (CURRENT_DATE - "
operator|+
literal|"  date '1969-04-29') day / 2) is not null"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Add tests for year month intervals (currently not supported)
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiplyOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MULTIPLY
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"2*3"
argument_list|,
literal|"6"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"2*-3"
argument_list|,
literal|"-6"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"+2*3"
argument_list|,
literal|"6"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"2*0"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"cast(2.0 as float)*3"
argument_list|,
literal|"FLOAT NOT NULL"
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"3*cast(2.0 as real)"
argument_list|,
literal|"REAL NOT NULL"
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"cast(2.0 as real)*3.2"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|6.4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"10.0 * 5.0"
argument_list|,
literal|"DECIMAL(5, 2) NOT NULL"
argument_list|,
literal|"50.00"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"19.68 * 4.2"
argument_list|,
literal|"DECIMAL(6, 3) NOT NULL"
argument_list|,
literal|"82.656"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(1 as real)*cast(null as real)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"2e-3*cast(null as integer)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as tinyint) * cast(4 as smallint)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FNL25_FIXED
condition|)
block|{
comment|// Should throw out of range error
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(100 as tinyint) * cast(-2 as tinyint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(200 as smallint) * cast(200 as smallint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(1.5e9 as integer) * cast(-2 as integer)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(5e9 as bigint) * cast(2e9 as bigint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(2e9 as decimal(19,0)) * cast(-5e9 as decimal(19,0))"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(5e4 as decimal(19,10)) * cast(2e4 as decimal(19,10))"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiplyIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2:2' hour to minute * 3"
argument_list|,
literal|"+6:06"
argument_list|,
literal|"INTERVAL HOUR TO MINUTE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"3 * 2 * interval '2:5:12' hour to second"
argument_list|,
literal|"+12:31:12.000000"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"interval '2' day * cast(null as bigint)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval month) * 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TODO
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '3-2' year to month * 15e-1"
argument_list|,
literal|"+04-09"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '3-4' year to month * 4.5"
argument_list|,
literal|"+15-00"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNotEqualsOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1<>1"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a'<>'A'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1e0<>1e1"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"'a'<>cast(null as varchar(1))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNotEqualsOperatorIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day<> interval '1' day"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2' day<> interval '2' day"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"interval '2:2:2' hour to second<> interval '2' hour"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as interval hour)<> interval '2' minute"
argument_list|)
expr_stmt|;
comment|// "!=" is not an acceptable alternative to "<>"
name|tester
operator|.
name|checkFails
argument_list|(
literal|"1 ^!^= 1"
argument_list|,
literal|"(?s).*Encountered: \"!\" \\(33\\).*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true or false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false or false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true or cast(null as boolean)"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"false or cast(null as boolean)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrOperatorLazy
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|)
expr_stmt|;
comment|// need to evaluate 2nd argument if first evaluates to null, therefore
comment|// get error
name|tester
operator|.
name|check
argument_list|(
literal|"values 1< cast(null as integer) or sqrt(-4) = -2"
argument_list|,
name|SqlTests
operator|.
name|BOOLEAN_TYPE_CHECKER
argument_list|,
operator|new
name|ValueOrExceptionResultChecker
argument_list|(
literal|null
argument_list|,
name|INVALID_ARG_FOR_POWER
argument_list|,
name|CODE_2201F
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do not need to evaluate 2nd argument if first evaluates to true.
comment|// In eager evaluation, get error;
comment|// lazy evaluation returns true;
comment|// both are valid.
name|tester
operator|.
name|check
argument_list|(
literal|"values 1< 2 or sqrt(-4) = -2"
argument_list|,
name|SqlTests
operator|.
name|BOOLEAN_TYPE_CHECKER
argument_list|,
operator|new
name|ValueOrExceptionResultChecker
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|,
name|INVALID_ARG_FOR_POWER
argument_list|,
name|CODE_2201F
argument_list|)
argument_list|)
expr_stmt|;
comment|// NULL OR FALSE --> NULL
comment|// In eager evaluation, get error;
comment|// lazy evaluation returns NULL;
comment|// both are valid.
name|tester
operator|.
name|check
argument_list|(
literal|"values 1< cast(null as integer) or sqrt(4) = -2"
argument_list|,
name|SqlTests
operator|.
name|BOOLEAN_TYPE_CHECKER
argument_list|,
operator|new
name|ValueOrExceptionResultChecker
argument_list|(
literal|null
argument_list|,
name|INVALID_ARG_FOR_POWER
argument_list|,
name|CODE_2201F
argument_list|)
argument_list|)
expr_stmt|;
comment|// NULL OR TRUE --> TRUE
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1< cast(null as integer) or sqrt(4) = 2"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPlusOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"1+2"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"-1+2"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"1+2+3"
argument_list|,
literal|"6"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"1+cast(2.0 as double)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"1+cast(2.0 as double)+cast(6.0 as float)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"10.0 + 5.0"
argument_list|,
literal|"DECIMAL(4, 1) NOT NULL"
argument_list|,
literal|"15.0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"19.68 + 4.2"
argument_list|,
literal|"DECIMAL(5, 2) NOT NULL"
argument_list|,
literal|"23.88"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"19.68 + 4.2 + 6"
argument_list|,
literal|"DECIMAL(13, 2) NOT NULL"
argument_list|,
literal|"29.88"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"19.68 + cast(4.2 as float)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|23.88
argument_list|,
literal|0.02
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"cast(null as tinyint)+1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"1e-2+cast(null as double)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FNL25_FIXED
condition|)
block|{
comment|// Should throw out of range error
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(100 as tinyint) + cast(100 as tinyint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(-20000 as smallint) + cast(-20000 as smallint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(1.5e9 as integer) + cast(1.5e9 as integer)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(5e18 as bigint) + cast(5e18 as bigint)"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(-5e18 as decimal(19,0)) + cast(-5e18 as decimal(19,0))"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"cast(5e8 as decimal(19,10)) + cast(5e8 as decimal(19,10))"
argument_list|,
name|OUT_OF_RANGE_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPlusOperatorAny
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"1+CAST(2 AS ANY)"
argument_list|,
literal|"3"
argument_list|,
literal|"ANY NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPlusIntervalOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PLUS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2' day + interval '1' day"
argument_list|,
literal|"+3"
argument_list|,
literal|"INTERVAL DAY NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2' day + interval '1' minute"
argument_list|,
literal|"+2 00:01"
argument_list|,
literal|"INTERVAL DAY TO MINUTE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2' day + interval '5' minute + interval '-3' second"
argument_list|,
literal|"+2 00:04:57.000000"
argument_list|,
literal|"INTERVAL DAY TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '2' year + interval '1' month"
argument_list|,
literal|"+2-01"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"interval '2' year + cast(null as interval month)"
argument_list|)
expr_stmt|;
comment|// Datetime plus interval
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"time '12:03:01' + interval '1:1' hour to minute"
argument_list|,
literal|"13:04:01"
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTERVAL
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"interval '5' day + date '2005-03-02'"
argument_list|,
literal|"2005-03-07"
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"timestamp '2003-08-02 12:54:01' + interval '-4 2:4' day to minute"
argument_list|,
literal|"2003-07-29 10:50:01"
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
comment|// TODO: Tests with interval year months (not supported)
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDescendingOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DESC
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNotNullOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true is not null"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) is not null"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNullOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true is null"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) is null"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNotTrueOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true is not true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false is not true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) is not true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"select ^'a string' is not true^ from (values (1))"
argument_list|,
literal|"(?s)Cannot apply 'IS NOT TRUE' to arguments of type '<CHAR\\(8\\)> IS NOT TRUE'. Supported form\\(s\\): '<BOOLEAN> IS NOT TRUE'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsTrueOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true is true"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false is true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) is true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNotFalseOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false is not false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true is not false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) is not false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsFalseOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false is false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true is false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) is false"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsNotUnknownOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_UNKNOWN
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false is not unknown"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true is not unknown"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) is not unknown"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"unknown is not unknown"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^'abc' IS NOT UNKNOWN^"
argument_list|,
literal|"(?s).*Cannot apply 'IS NOT UNKNOWN'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsUnknownOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_UNKNOWN
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"false is unknown"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"true is unknown"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as boolean) is unknown"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"unknown is unknown"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"0 = 1 AND ^2 IS UNKNOWN^ AND 3> 4"
argument_list|,
literal|"(?s).*Cannot apply 'IS UNKNOWN'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsASetOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_A_SET
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExistsOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EXISTS
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNotOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"not true"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"not false"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"not unknown"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"not cast(null as boolean)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPrefixMinusOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|UNARY_MINUS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"'a' + ^- 'b'^ + 'c'"
argument_list|,
literal|"(?s)Cannot apply '-' to arguments of type '-<CHAR\\(1\\)>'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"-1"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"-1.23"
argument_list|,
literal|"DECIMAL(3, 2) NOT NULL"
argument_list|,
literal|"-1.23"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"-1.0e0"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"-cast(null as integer)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"-cast(null as tinyint)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPrefixMinusOperatorIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"-interval '-6:2:8' hour to second"
argument_list|,
literal|"+6:02:08.000000"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"- -interval '-6:2:8' hour to second"
argument_list|,
literal|"-6:02:08.000000"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"-interval '5' month"
argument_list|,
literal|"-5"
argument_list|,
literal|"INTERVAL MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"-cast(null as interval day to minute)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPrefixPlusOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|UNARY_PLUS
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"+1"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"+1.23"
argument_list|,
literal|"DECIMAL(3, 2) NOT NULL"
argument_list|,
literal|"1.23"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"+1.0e0"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"+cast(null as integer)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"+cast(null as tinyint)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPrefixPlusOperatorIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"+interval '-6:2:8' hour to second"
argument_list|,
literal|"-6:02:08.000000"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"++interval '-6:2:8' hour to second"
argument_list|,
literal|"-6:02:08.000000"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FRG254_FIXED
condition|)
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"+interval '6:2:8.234' hour to second"
argument_list|,
literal|"+06:02:08.234"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"+interval '5' month"
argument_list|,
literal|"+5"
argument_list|,
literal|"INTERVAL MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"+cast(null as interval day to minute)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExplicitTableOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EXPLICIT_TABLE
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValuesOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VALUES
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|check
argument_list|(
literal|"select 'abc' from (values(true))"
argument_list|,
operator|new
name|SqlTests
operator|.
name|StringTypeChecker
argument_list|(
literal|"CHAR(3) NOT NULL"
argument_list|)
argument_list|,
literal|"abc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNotLikeOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_LIKE
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abc' not like '_b_'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLikeOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LIKE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"''  like ''"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' like 'a'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' like 'b'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' like 'A'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' like 'a_'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' like '_a'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' like '%a'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' like '%a%'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' like 'a%'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab'   like 'a_'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abc'  like 'a_'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd' like 'a%'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab'   like '_b'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd' like '_d'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd' like '%d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNotSimilarToOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT_SIMILAR_TO
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab' not similar to 'a_'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'aabc' not similar to 'ab*c+d'"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab' not similar to 'a' || '_'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab' not similar to 'ba_'"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as varchar(2)) not similar to 'a_'"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as varchar(3)) not similar to cast(null as char(2))"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimilarToOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SIMILAR_TO
argument_list|)
expr_stmt|;
comment|// like LIKE
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"''  similar to ''"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to 'a'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to 'b'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to 'A'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to 'a_'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to '_a'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to '%a'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to '%a%'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to 'a%'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab'   similar to 'a_'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abc'  similar to 'a_'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd' similar to 'a%'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab'   similar to '_b'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd' similar to '_d'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd' similar to '%d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// simple regular expressions
comment|// ab*c+d matches acd, abcd, acccd, abcccd but not abd, aabc
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'acd'    similar to 'ab*c+d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd'   similar to 'ab*c+d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'acccd'  similar to 'ab*c+d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcccd' similar to 'ab*c+d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abd'    similar to 'ab*c+d'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'aabc'   similar to 'ab*c+d'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
comment|// compound regular expressions
comment|// x(ab|c)*y matches xy, xccy, xababcy but not xbcy
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xy'      similar to 'x(ab|c)*y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xccy'    similar to 'x(ab|c)*y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xababcy' similar to 'x(ab|c)*y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xbcy'    similar to 'x(ab|c)*y'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
comment|// x(ab|c)+y matches xccy, xababcy but not xy, xbcy
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xy'      similar to 'x(ab|c)+y'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xccy'    similar to 'x(ab|c)+y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xababcy' similar to 'x(ab|c)+y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xbcy'    similar to 'x(ab|c)+y'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab' similar to 'a%' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to 'a%' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd' similar to 'a_' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abcd' similar to 'a%' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'1a' similar to '_a' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'123aXYZ' similar to '%a%'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'123aXYZ' similar to '_%_a%_' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xy' similar to '(xy)' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abd' similar to '[ab][bcde]d' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'bdd' similar to '[ab][bcde]d' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abd' similar to '[ab]d' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'cd' similar to '[a-e]d' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'amy' similar to 'amy|fred' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'fred' similar to 'amy|fred' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'mike' similar to 'amy|fred' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'acd' similar to 'ab*c+d' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'accccd' similar to 'ab*c+d' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abd' similar to 'ab*c+d' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'aabc' similar to 'ab*c+d' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abb' similar to 'a(b{3})' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abbb' similar to 'a(b{3})' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abbbbb' similar to 'a(b{3})' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abbbbb' similar to 'ab{3,6}' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abbbbbbbb' similar to 'ab{3,6}' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'' similar to 'ab?' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to 'ab?' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a' similar to 'a(b?)' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab' similar to 'ab?' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab' similar to 'a(b?)' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'abb' similar to 'ab?' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab' similar to 'a\\_' ESCAPE '\\' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'ab' similar to 'a\\%' ESCAPE '\\' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a_' similar to 'a\\_' ESCAPE '\\' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a%' similar to 'a\\%' ESCAPE '\\' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a(b{3})' similar to 'a(b{3})' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'a(b{3})' similar to 'a\\(b\\{3\\}\\)' ESCAPE '\\' "
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd' similar to '[a-ey]d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd' similar to '[^a-ey]d'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd' similar to '[^a-ex-z]d'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd' similar to '[a-ex-z]d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd' similar to '[x-za-e]d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd' similar to '[^a-ey]?d'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yyyd' similar to '[a-ey]*d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// range must be specified in []
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd' similar to 'x-zd'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to 'x-z'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'cd' similar to '([a-e])d'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'xy' similar to 'x*?y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to 'x*?y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to '(x?)*y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to 'x+?y'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to 'x?+y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to 'x*+y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
comment|// The following two tests throws exception(They probably should).
comment|// "Dangling meta character '*' near index 2"
if|if
condition|(
name|enable
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to 'x+*y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to 'x?*y'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|// some negative tests
name|tester
operator|.
name|checkFails
argument_list|(
literal|"'yd' similar to '[x-ze-a]d'"
argument_list|,
literal|"Illegal character range near index 6\n"
operator|+
literal|"\\[x-ze-a\\]d\n"
operator|+
literal|"      \\^"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// illegal range
name|tester
operator|.
name|checkFails
argument_list|(
literal|"'yd3223' similar to '[:LOWER:]{2}[:DIGIT:]{,5}'"
argument_list|,
literal|"Illegal repetition near index 20\n"
operator|+
literal|"\\[\\:LOWER\\:\\]\\{2\\}\\[\\:DIGIT\\:\\]\\{,5\\}\n"
operator|+
literal|"                    \\^"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"'cd' similar to '[(a-e)]d' "
argument_list|,
literal|"Invalid regular expression: \\[\\(a-e\\)\\]d at 1"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"'yd' similar to '[(a-e)]d' "
argument_list|,
literal|"Invalid regular expression: \\[\\(a-e\\)\\]d at 1"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// all the following tests wrong results due to missing functionality
comment|// or defect (FRG-375, 377).
if|if
condition|(
name|Bug
operator|.
name|FRG375_FIXED
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'cd' similar to '[a-e^c]d' "
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
comment|// FRG-375
block|}
comment|// following tests use regular character set identifiers.
comment|// Not implemented yet. FRG-377.
if|if
condition|(
name|Bug
operator|.
name|FRG377_FIXED
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'y' similar to '[:ALPHA:]*'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd32' similar to '[:LOWER:]{2}[:DIGIT:]*'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd32' similar to '[:ALNUM:]*'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd32' similar to '[:ALNUM:]*[:DIGIT:]?'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd32' similar to '[:ALNUM:]?[:DIGIT:]*'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd3223' similar to '([:LOWER:]{2})[:DIGIT:]{2,5}'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd3223' similar to '[:LOWER:]{2}[:DIGIT:]{2,}'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd3223' similar to '[:LOWER:]{2}||[:DIGIT:]{4}'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd3223' similar to '[:LOWER:]{2}[:DIGIT:]{3}'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'yd  3223' similar to '[:UPPER:]{2}  [:DIGIT:]{3}'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'YD  3223' similar to '[:UPPER:]{2}  [:DIGIT:]{3}'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'YD  3223' similar to "
operator|+
literal|"'[:UPPER:]{2}||[:WHITESPACE:]*[:DIGIT:]{4}'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'YD\t3223' similar to '[:UPPER:]{2}[:SPACE:]*[:DIGIT:]{4}'"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'YD\t3223' similar to "
operator|+
literal|"'[:UPPER:]{2}[:WHITESPACE:]*[:DIGIT:]{4}'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'YD\t\t3223' similar to "
operator|+
literal|"'([:UPPER:]{2}[:WHITESPACE:]+)||[:DIGIT:]{4}'"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEscapeOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ESCAPE
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testConvertFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CONVERT
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTranslateFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TRANSLATE
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOverlayFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OVERLAY
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"overlay('ABCdef' placing 'abc' from 1)"
argument_list|,
literal|"abcdef"
argument_list|,
literal|"VARCHAR(9) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"overlay('ABCdef' placing 'abc' from 1 for 2)"
argument_list|,
literal|"abcCdef"
argument_list|,
literal|"VARCHAR(9) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|tester
operator|.
name|checkString
argument_list|(
literal|"overlay(cast('ABCdef' as varchar(10)) placing "
operator|+
literal|"cast('abc' as char(5)) from 1 for 2)"
argument_list|,
literal|"abc  Cdef"
argument_list|,
literal|"VARCHAR(15) NOT NULL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enable
condition|)
block|{
name|tester
operator|.
name|checkString
argument_list|(
literal|"overlay(cast('ABCdef' as char(10)) placing "
operator|+
literal|"cast('abc' as char(5)) from 1 for 2)"
argument_list|,
literal|"abc  Cdef    "
argument_list|,
literal|"VARCHAR(15) NOT NULL"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkNull
argument_list|(
literal|"overlay('ABCdef' placing 'abc' from 1 for cast(null as integer))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"overlay(cast(null as varchar(1)) placing 'abc' from 1)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"overlay(x'ABCdef' placing x'abcd' from 1)"
argument_list|,
literal|"abcdef"
argument_list|,
literal|"VARBINARY(5) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"overlay(x'ABCDEF1234' placing x'2345' from 1 for 2)"
argument_list|,
literal|"2345ef1234"
argument_list|,
literal|"VARBINARY(7) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|tester
operator|.
name|checkString
argument_list|(
literal|"overlay(cast(x'ABCdef' as varbinary(5)) placing "
operator|+
literal|"cast(x'abcd' as binary(3)) from 1 for 2)"
argument_list|,
literal|"abc  Cdef"
argument_list|,
literal|"VARBINARY(8) NOT NULL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enable
condition|)
block|{
name|tester
operator|.
name|checkString
argument_list|(
literal|"overlay(cast(x'ABCdef' as binary(5)) placing "
operator|+
literal|"cast(x'abcd' as binary(3)) from 1 for 2)"
argument_list|,
literal|"abc  Cdef    "
argument_list|,
literal|"VARBINARY(8) NOT NULL"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkNull
argument_list|(
literal|"overlay(x'ABCdef' placing x'abcd' from 1 for cast(null as integer))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"overlay(cast(null as varbinary(1)) placing x'abcd' from 1)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"overlay(x'abcd' placing x'abcd' from cast(null as integer))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPositionFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|POSITION
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"position('b' in 'abc')"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"position('' in 'abc')"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
comment|// FRG-211
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"position('tra' in 'fdgjklewrtra')"
argument_list|,
literal|"10"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"position(cast(null as varchar(1)) in '0010')"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"position('a' in cast(null as varchar(1)))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"position(cast('a' as char) in cast('bca' as varchar))"
argument_list|,
literal|0
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCharLengthFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHAR_LENGTH
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"char_length('abc')"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"char_length(cast(null as varchar(1)))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCharacterLengthFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CHARACTER_LENGTH
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"CHARACTER_LENGTH('abc')"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"CHARACTER_LENGTH(cast(null as varchar(1)))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUpperFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|UPPER
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"upper('a')"
argument_list|,
literal|"A"
argument_list|,
literal|"CHAR(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"upper('A')"
argument_list|,
literal|"A"
argument_list|,
literal|"CHAR(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"upper('1')"
argument_list|,
literal|"1"
argument_list|,
literal|"CHAR(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"upper('aa')"
argument_list|,
literal|"AA"
argument_list|,
literal|"CHAR(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"upper(cast(null as varchar(1)))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLowerFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LOWER
argument_list|)
expr_stmt|;
comment|// SQL:2003 6.29.8 The type of lower is the type of its argument
name|tester
operator|.
name|checkString
argument_list|(
literal|"lower('A')"
argument_list|,
literal|"a"
argument_list|,
literal|"CHAR(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"lower('a')"
argument_list|,
literal|"a"
argument_list|,
literal|"CHAR(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"lower('1')"
argument_list|,
literal|"1"
argument_list|,
literal|"CHAR(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"lower('AA')"
argument_list|,
literal|"aa"
argument_list|,
literal|"CHAR(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"lower(cast(null as varchar(1)))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInitcapFunc
parameter_list|()
block|{
comment|// Note: the initcap function is an Oracle defined function and is not
comment|// defined in the SQL:2003 standard
comment|// todo: implement in fennel
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|INITCAP
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"initcap('aA')"
argument_list|,
literal|"Aa"
argument_list|,
literal|"CHAR(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"initcap('Aa')"
argument_list|,
literal|"Aa"
argument_list|,
literal|"CHAR(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"initcap('1a')"
argument_list|,
literal|"1a"
argument_list|,
literal|"CHAR(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"initcap('ab cd Ef 12')"
argument_list|,
literal|"Ab Cd Ef 12"
argument_list|,
literal|"CHAR(11) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"initcap(cast(null as varchar(1)))"
argument_list|)
expr_stmt|;
comment|// dtbug 232
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^initcap(cast(null as date))^"
argument_list|,
literal|"Cannot apply 'INITCAP' to arguments of type 'INITCAP\\(<DATE>\\)'\\. Supported form\\(s\\): 'INITCAP\\(<CHARACTER>\\)'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPowerFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|POWER
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"power(2,-2)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|0.25
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"power(cast(null as integer),2)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"power(2,cast(null as double))"
argument_list|)
expr_stmt|;
comment|// 'pow' is an obsolete form of the 'power' function
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^pow(2,-2)^"
argument_list|,
literal|"No match found for function signature POW\\(<NUMERIC>,<NUMERIC>\\)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSqrtFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SQRT
argument_list|,
name|SqlTester
operator|.
name|VmName
operator|.
name|EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"sqrt(2)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"sqrt(cast(2 as float))"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"sqrt(case when false then 2 else null end)"
argument_list|,
literal|"DOUBLE"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^sqrt('abc')^"
argument_list|,
literal|"Cannot apply 'SQRT' to arguments of type 'SQRT\\(<CHAR\\(3\\)>\\)'\\. Supported form\\(s\\): 'SQRT\\(<NUMERIC>\\)'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"sqrt(2)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|1.4142d
argument_list|,
literal|0.0001d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"sqrt(cast(null as integer))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"sqrt(cast(null as double))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExpFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EXP
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"exp(2)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|7.389056
argument_list|,
literal|0.000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"exp(-2)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|0.1353
argument_list|,
literal|0.0001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"exp(cast(null as integer))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"exp(cast(null as double))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testModFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MOD
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(4,2)"
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(8,5)"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(-12,7)"
argument_list|,
literal|"-5"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(-12,-7)"
argument_list|,
literal|"-5"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(12,-7)"
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(cast(12 as tinyint), cast(-7 as tinyint))"
argument_list|,
literal|"TINYINT NOT NULL"
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(cast(9 as decimal(2, 0)), 7)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(7, cast(9 as decimal(2, 0)))"
argument_list|,
literal|"DECIMAL(2, 0) NOT NULL"
argument_list|,
literal|"7"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"mod(cast(-9 as decimal(2, 0)), cast(7 as decimal(1, 0)))"
argument_list|,
literal|"DECIMAL(1, 0) NOT NULL"
argument_list|,
literal|"-2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"mod(cast(null as integer),2)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"mod(4,cast(null as tinyint))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"mod(4,cast(null as decimal(12,0)))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testModFuncDivByZero
parameter_list|()
block|{
comment|// The extra CASE expression is to fool Janino.  It does constant
comment|// reduction and will throw the divide by zero exception while
comment|// compiling the expression.  The test frame work would then issue
comment|// unexpected exception occurred during "validation".  You cannot
comment|// submit as non-runtime because the janino exception does not have
comment|// error position information and the framework is unhappy with that.
name|tester
operator|.
name|checkFails
argument_list|(
literal|"mod(3,case 'a' when 'a' then 0 end)"
argument_list|,
name|DIVISION_BY_ZERO_MESSAGE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLnFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LN
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"ln(2.71828)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|1.0
argument_list|,
literal|0.000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"ln(2.71828)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|0.999999327
argument_list|,
literal|0.0000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"ln(cast(null as tinyint))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLogFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LOG10
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"log10(10)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|1.0
argument_list|,
literal|0.000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"log10(100.0)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|2.0
argument_list|,
literal|0.000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"log10(cast(10e8 as double))"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|9.0
argument_list|,
literal|0.000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"log10(cast(10e2 as float))"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|3.0
argument_list|,
literal|0.000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"log10(cast(10e-3 as real))"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
operator|-
literal|2.0
argument_list|,
literal|0.000001
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"log10(cast(null as real))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAbsFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ABS
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"abs(-1)"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"abs(cast(10 as TINYINT))"
argument_list|,
literal|"TINYINT NOT NULL"
argument_list|,
literal|"10"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"abs(cast(-20 as SMALLINT))"
argument_list|,
literal|"SMALLINT NOT NULL"
argument_list|,
literal|"20"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"abs(cast(-100 as INT))"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|,
literal|"100"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"abs(cast(1000 as BIGINT))"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|,
literal|"1000"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"abs(54.4)"
argument_list|,
literal|"DECIMAL(3, 1) NOT NULL"
argument_list|,
literal|"54.4"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"abs(-54.4)"
argument_list|,
literal|"DECIMAL(3, 1) NOT NULL"
argument_list|,
literal|"54.4"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"abs(-9.32E-2)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|0.0932
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"abs(cast(-3.5 as double))"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|3.5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"abs(cast(-3.5 as float))"
argument_list|,
literal|"FLOAT NOT NULL"
argument_list|,
literal|3.5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"abs(cast(3.5 as real))"
argument_list|,
literal|"REAL NOT NULL"
argument_list|,
literal|3.5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"abs(cast(null as double))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAbsFuncIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"abs(interval '-2' day)"
argument_list|,
literal|"+2"
argument_list|,
literal|"INTERVAL DAY NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"abs(interval '-5-03' year to month)"
argument_list|,
literal|"+5-03"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"abs(cast(null as interval hour))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNullifFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NULLIF
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"nullif(1,1)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"nullif(1.5, 13.56)"
argument_list|,
literal|"DECIMAL(2, 1)"
argument_list|,
literal|"1.5"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"nullif(13.56, 1.5)"
argument_list|,
literal|"DECIMAL(4, 2)"
argument_list|,
literal|"13.56"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"nullif(1.5, 3)"
argument_list|,
literal|"DECIMAL(2, 1)"
argument_list|,
literal|"1.5"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"nullif(3, 1.5)"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"nullif(1.5e0, 3e0)"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|1.5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"nullif(1.5, cast(3e0 as REAL))"
argument_list|,
literal|"DECIMAL(2, 1)"
argument_list|,
literal|1.5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"nullif(3, 1.5e0)"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"nullif(3, cast(1.5e0 as REAL))"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"nullif(1.5e0, 3.4)"
argument_list|,
literal|"DOUBLE"
argument_list|,
literal|1.5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"nullif(3.4, 1.5e0)"
argument_list|,
literal|"DECIMAL(2, 1)"
argument_list|,
literal|"3.4"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"nullif('a','bc')"
argument_list|,
literal|"a"
argument_list|,
literal|"CHAR(1)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"nullif('a',cast(null as varchar(1)))"
argument_list|,
literal|"a"
argument_list|,
literal|"CHAR(1)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"nullif(cast(null as varchar(1)),'a')"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"nullif(cast(null as numeric(4,3)), 4.3)"
argument_list|)
expr_stmt|;
comment|// Error message reflects the fact that Nullif is expanded before it is
comment|// validated (like a C macro). Not perfect, but good enough.
name|tester
operator|.
name|checkFails
argument_list|(
literal|"1 + ^nullif(1, date '2005-8-4')^ + 2"
argument_list|,
literal|"(?s)Cannot apply '=' to arguments of type '<INTEGER> =<DATE>'\\..*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"1 + ^nullif(1, 2, 3)^ + 2"
argument_list|,
literal|"Invalid number of arguments to function 'NULLIF'\\. Was expecting 2 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testNullIfOperatorIntervals
parameter_list|()
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"nullif(interval '2' month, interval '3' year)"
argument_list|,
literal|"+2"
argument_list|,
literal|"INTERVAL MONTH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTERVAL
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"nullif(interval '2 5' day to hour, interval '5' second)"
argument_list|,
literal|"+2 05"
argument_list|,
literal|"INTERVAL DAY TO HOUR"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"nullif(interval '3' day, interval '3' day)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCoalesceFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COALESCE
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"coalesce('a','b')"
argument_list|,
literal|"a"
argument_list|,
literal|"CHAR(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"coalesce(null,null,3)"
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"1 + ^coalesce('a', 'b', 1, null)^ + 2"
argument_list|,
literal|"Illegal mixing of types in CASE or COALESCE statement"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUserFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|USER
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"USER"
argument_list|,
literal|"sa"
argument_list|,
literal|"VARCHAR(2000) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCurrentUserFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CURRENT_USER
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"CURRENT_USER"
argument_list|,
literal|"sa"
argument_list|,
literal|"VARCHAR(2000) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSessionUserFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SESSION_USER
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"SESSION_USER"
argument_list|,
literal|"sa"
argument_list|,
literal|"VARCHAR(2000) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSystemUserFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SYSTEM_USER
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
name|String
name|user
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
decl_stmt|;
comment|// e.g. "jhyde"
name|tester
operator|.
name|checkString
argument_list|(
literal|"SYSTEM_USER"
argument_list|,
name|user
argument_list|,
literal|"VARCHAR(2000) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCurrentPathFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CURRENT_PATH
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"CURRENT_PATH"
argument_list|,
literal|""
argument_list|,
literal|"VARCHAR(2000) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCurrentRoleFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CURRENT_ROLE
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
comment|// By default, the CURRENT_ROLE function returns
comment|// the empty string because a role has to be set explicitly.
name|tester
operator|.
name|checkString
argument_list|(
literal|"CURRENT_ROLE"
argument_list|,
literal|""
argument_list|,
literal|"VARCHAR(2000) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLocalTimeFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LOCALTIME
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"LOCALTIME"
argument_list|,
name|TIME_PATTERN
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^LOCALTIME()^"
argument_list|,
literal|"No match found for function signature LOCALTIME\\(\\)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"LOCALTIME(1)"
argument_list|,
name|TIME_PATTERN
argument_list|,
literal|"TIME(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST(LOCALTIME AS VARCHAR(30))"
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|currentTimeString
argument_list|(
name|LOCAL_TZ
argument_list|)
operator|.
name|substring
argument_list|(
literal|11
argument_list|)
operator|+
literal|"[0-9][0-9]:[0-9][0-9]"
argument_list|)
argument_list|,
literal|"VARCHAR(30) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"LOCALTIME"
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|currentTimeString
argument_list|(
name|LOCAL_TZ
argument_list|)
operator|.
name|substring
argument_list|(
literal|11
argument_list|)
operator|+
literal|"[0-9][0-9]:[0-9][0-9]"
argument_list|)
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLocalTimestampFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LOCALTIMESTAMP
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"LOCALTIMESTAMP"
argument_list|,
name|TIMESTAMP_PATTERN
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^LOCALTIMESTAMP()^"
argument_list|,
literal|"No match found for function signature LOCALTIMESTAMP\\(\\)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"LOCALTIMESTAMP(^4000000000^)"
argument_list|,
name|LITERAL_OUT_OF_RANGE_MESSAGE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"LOCALTIMESTAMP(1)"
argument_list|,
name|TIMESTAMP_PATTERN
argument_list|,
literal|"TIMESTAMP(1) NOT NULL"
argument_list|)
expr_stmt|;
comment|// Check that timestamp is being generated in the right timezone by
comment|// generating a specific timestamp.
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST(LOCALTIMESTAMP AS VARCHAR(30))"
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|currentTimeString
argument_list|(
name|LOCAL_TZ
argument_list|)
operator|+
literal|"[0-9][0-9]:[0-9][0-9]"
argument_list|)
argument_list|,
literal|"VARCHAR(30) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"LOCALTIMESTAMP"
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|currentTimeString
argument_list|(
name|LOCAL_TZ
argument_list|)
operator|+
literal|"[0-9][0-9]:[0-9][0-9]"
argument_list|)
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCurrentTimeFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CURRENT_TIME
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CURRENT_TIME"
argument_list|,
name|TIME_PATTERN
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^CURRENT_TIME()^"
argument_list|,
literal|"No match found for function signature CURRENT_TIME\\(\\)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CURRENT_TIME(1)"
argument_list|,
name|TIME_PATTERN
argument_list|,
literal|"TIME(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST(CURRENT_TIME AS VARCHAR(30))"
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|currentTimeString
argument_list|(
name|CURRENT_TZ
argument_list|)
operator|.
name|substring
argument_list|(
literal|11
argument_list|)
operator|+
literal|"[0-9][0-9]:[0-9][0-9]"
argument_list|)
argument_list|,
literal|"VARCHAR(30) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CURRENT_TIME"
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|currentTimeString
argument_list|(
name|CURRENT_TZ
argument_list|)
operator|.
name|substring
argument_list|(
literal|11
argument_list|)
operator|+
literal|"[0-9][0-9]:[0-9][0-9]"
argument_list|)
argument_list|,
literal|"TIME(0) NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCurrentTimestampFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CURRENT_TIMESTAMP
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CURRENT_TIMESTAMP"
argument_list|,
name|TIMESTAMP_PATTERN
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^CURRENT_TIMESTAMP()^"
argument_list|,
literal|"No match found for function signature CURRENT_TIMESTAMP\\(\\)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"CURRENT_TIMESTAMP(^4000000000^)"
argument_list|,
name|LITERAL_OUT_OF_RANGE_MESSAGE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CURRENT_TIMESTAMP(1)"
argument_list|,
name|TIMESTAMP_PATTERN
argument_list|,
literal|"TIMESTAMP(1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST(CURRENT_TIMESTAMP AS VARCHAR(30))"
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|currentTimeString
argument_list|(
name|CURRENT_TZ
argument_list|)
operator|+
literal|"[0-9][0-9]:[0-9][0-9]"
argument_list|)
argument_list|,
literal|"VARCHAR(30) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CURRENT_TIMESTAMP"
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|currentTimeString
argument_list|(
name|CURRENT_TZ
argument_list|)
operator|+
literal|"[0-9][0-9]:[0-9][0-9]"
argument_list|)
argument_list|,
literal|"TIMESTAMP(0) NOT NULL"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a time string, in GMT, that will be valid for at least 2 minutes.    *    *<p>For example, at "2005-01-01 12:34:56 PST", returns "2005-01-01 20:".    * At "2005-01-01 12:34:59 PST", waits a minute, then returns "2005-01-01    * 21:".    *    * @param tz Time zone    * @return Time string    */
specifier|protected
specifier|static
name|String
name|currentTimeString
parameter_list|(
name|TimeZone
name|tz
parameter_list|)
block|{
specifier|final
name|Calendar
name|calendar
init|=
name|getCalendarNotTooNear
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|)
decl_stmt|;
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd HH:"
argument_list|)
decl_stmt|;
name|sdf
operator|.
name|setTimeZone
argument_list|(
name|tz
argument_list|)
expr_stmt|;
return|return
name|sdf
operator|.
name|format
argument_list|(
name|calendar
operator|.
name|getTime
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCurrentDateFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CURRENT_DATE
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CURRENT_DATE"
argument_list|,
name|DATE_PATTERN
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"(CURRENT_DATE - CURRENT_DATE) DAY"
argument_list|,
literal|"+0"
argument_list|,
literal|"INTERVAL DAY NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"CURRENT_DATE IS NULL"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"CURRENT_DATE IS NOT NULL"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"NOT (CURRENT_DATE IS NULL)"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^CURRENT_DATE()^"
argument_list|,
literal|"No match found for function signature CURRENT_DATE\\(\\)"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Check the actual value.
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST(CURRENT_DATE AS VARCHAR(30))"
argument_list|,
name|currentTimeString
argument_list|(
name|LOCAL_TZ
argument_list|)
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
argument_list|,
literal|"VARCHAR(30) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CURRENT_DATE"
argument_list|,
name|currentTimeString
argument_list|(
name|LOCAL_TZ
argument_list|)
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
argument_list|,
literal|"DATE NOT NULL"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSubstringFunction
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUBSTRING
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"substring('abc' from 1 for 2)"
argument_list|,
literal|"ab"
argument_list|,
literal|"VARCHAR(3) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"substring('abc' from 2)"
argument_list|,
literal|"bc"
argument_list|,
literal|"VARCHAR(3) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FRG296_FIXED
condition|)
block|{
comment|// substring regexp not supported yet
name|tester
operator|.
name|checkString
argument_list|(
literal|"substring('foobar' from '%#\"o_b#\"%' for'#')"
argument_list|,
literal|"oob"
argument_list|,
literal|"xx"
argument_list|)
expr_stmt|;
block|}
name|tester
operator|.
name|checkNull
argument_list|(
literal|"substring(cast(null as varchar(1)),1,2)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testTrimFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|TRIM
argument_list|)
expr_stmt|;
comment|// SQL:2003 6.29.11 Trimming a CHAR yields a VARCHAR
name|tester
operator|.
name|checkString
argument_list|(
literal|"trim('a' from 'aAa')"
argument_list|,
literal|"A"
argument_list|,
literal|"VARCHAR(3) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"trim(both 'a' from 'aAa')"
argument_list|,
literal|"A"
argument_list|,
literal|"VARCHAR(3) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"trim(leading 'a' from 'aAa')"
argument_list|,
literal|"Aa"
argument_list|,
literal|"VARCHAR(3) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkString
argument_list|(
literal|"trim(trailing 'a' from 'aAa')"
argument_list|,
literal|"aA"
argument_list|,
literal|"VARCHAR(3) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"trim(cast(null as varchar(1)) from 'a')"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"trim('a' from cast(null as varchar(1)))"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bug
operator|.
name|FNL3_FIXED
condition|)
block|{
comment|// SQL:2003 6.29.9: trim string must have length=1. Failure occurs
comment|// at runtime.
comment|//
comment|// TODO: Change message to "Invalid argument\(s\) for
comment|// 'TRIM' function".
comment|// The message should come from a resource file, and should still
comment|// have the SQL error code 22027.
name|tester
operator|.
name|checkFails
argument_list|(
literal|"trim('xy' from 'abcde')"
argument_list|,
literal|"could not calculate results for the following row:\n"
operator|+
literal|"\\[ 0 \\]\n"
operator|+
literal|"Messages:\n"
operator|+
literal|"\\[0\\]:PC=0 Code=22027 "
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"trim('' from 'abcde')"
argument_list|,
literal|"could not calculate results for the following row:\n"
operator|+
literal|"\\[ 0 \\]\n"
operator|+
literal|"Messages:\n"
operator|+
literal|"\\[0\\]:PC=0 Code=22027 "
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWindow
parameter_list|()
block|{
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|check
argument_list|(
literal|"select sum(1) over (order by x) from (select 1 as x, 2 as y from (values (true)))"
argument_list|,
operator|new
name|SqlTests
operator|.
name|StringTypeChecker
argument_list|(
literal|"INTEGER"
argument_list|)
argument_list|,
literal|"1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testElementFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ELEMENT
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
if|if
condition|(
name|TODO
condition|)
block|{
name|tester
operator|.
name|checkString
argument_list|(
literal|"element(multiset['abc']))"
argument_list|,
literal|"abc"
argument_list|,
literal|"char(3) not null"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"element(multiset[cast(null as integer)]))"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCardinalityFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CARDINALITY
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
if|if
condition|(
name|TODO
condition|)
block|{
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cardinality(multiset[cast(null as integer),2]))"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
comment|// applied to array
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cardinality(array['foo', 'bar'])"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
comment|// applied to map
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"cardinality(map['foo', 1, 'bar', 2])"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMemberOfOperator
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MEMBER_OF
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
if|if
condition|(
name|TODO
condition|)
block|{
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1 member of multiset[1]"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"'2' member of multiset['1']"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as double) member of multiset[cast(null as double)]"
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"cast(null as double) member of multiset[1.1]"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"1.1 member of multiset[cast(null as double)]"
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCollectFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COLLECT
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFusionFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|FUSION
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExtractFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EXTRACT
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(day from interval '2 3:4:5.678' day to second)"
argument_list|,
literal|"2"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(day from interval '23456 3:4:5.678' day(5) to second)"
argument_list|,
literal|"23456"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(hour from interval '2 3:4:5.678' day to second)"
argument_list|,
literal|"3"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(minute from interval '2 3:4:5.678' day to second)"
argument_list|,
literal|"4"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
comment|// TODO: Seconds should include precision
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(second from interval '2 3:4:5.678' day to second)"
argument_list|,
literal|"5"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(year from interval '4-2' year to month)"
argument_list|,
literal|"4"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTERVAL
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(month from interval '4-2' year to month)"
argument_list|,
literal|"2"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"extract(month from cast(null as interval year))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testExtractFuncFromDateTime
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EXTRACT
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(year from date '2008-2-23')"
argument_list|,
literal|"2008"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(month from date '2008-2-23')"
argument_list|,
literal|"2"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(month from timestamp '2008-2-23 12:34:56')"
argument_list|,
literal|"2"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(minute from timestamp '2008-2-23 12:34:56')"
argument_list|,
literal|"34"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"extract(minute from time '12:23:34')"
argument_list|,
literal|"23"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"extract(month from cast(null as timestamp))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"extract(month from cast(null as date))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"extract(second from cast(null as time))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testArrayValueConstructor
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ARRAY_VALUE_CONSTRUCTOR
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"Array['foo', 'bar']"
argument_list|,
literal|"[foo, bar]"
argument_list|,
literal|"CHAR(3) NOT NULL ARRAY NOT NULL"
argument_list|)
expr_stmt|;
comment|// empty array is illegal per SQL spec. presumably because one can't
comment|// infer type
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^Array[]^"
argument_list|,
literal|"Require at least 1 argument"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testItemOp
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ITEM
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ARRAY ['foo', 'bar'][1]"
argument_list|,
literal|"foo"
argument_list|,
literal|"CHAR(3)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ARRAY ['foo', 'bar'][0]"
argument_list|,
literal|null
argument_list|,
literal|"CHAR(3)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ARRAY ['foo', 'bar'][2]"
argument_list|,
literal|"bar"
argument_list|,
literal|"CHAR(3)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ARRAY ['foo', 'bar'][3]"
argument_list|,
literal|null
argument_list|,
literal|"CHAR(3)"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"ARRAY ['foo', 'bar'][1 + CAST(NULL AS INTEGER)]"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^ARRAY ['foo', 'bar']['baz']^"
argument_list|,
literal|"Cannot apply 'ITEM' to arguments of type 'ITEM\\(<CHAR\\(3\\) ARRAY>,<CHAR\\(3\\)>\\)'\\. Supported form\\(s\\):<ARRAY>\\[<INTEGER>\\]\n"
operator|+
literal|"<MAP>\\[<VALUE>\\]"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Array of INTEGER NOT NULL is interesting because we might be tempted
comment|// to represent the result as Java "int".
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ARRAY [2, 4, 6][2]"
argument_list|,
literal|"4"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ARRAY [2, 4, 6][4]"
argument_list|,
literal|null
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
comment|// Map item
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"map['foo', 3, 'bar', 7]['bar']"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"7"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"map['foo', CAST(NULL AS INTEGER), 'bar', 7]['bar']"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|"7"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"map['foo', CAST(NULL AS INTEGER), 'bar', 7]['baz']"
argument_list|,
literal|"INTEGER"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMapValueConstructor
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MAP_VALUE_CONSTRUCTOR
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^Map[]^"
argument_list|,
literal|"Map requires at least 2 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^Map[1, 'x', 2]^"
argument_list|,
literal|"Map requires an even number of arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^map[1, 1, 2, 'x']^"
argument_list|,
literal|"Parameters must be of the same type"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"map['washington', 1, 'obama', 44]"
argument_list|,
literal|"(CHAR(10) NOT NULL, INTEGER NOT NULL) MAP NOT NULL"
argument_list|,
literal|"{washington=1, obama=44}"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCeilFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CEIL
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"ceil(10.1e0)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"ceil(cast(-11.2e0 as real))"
argument_list|,
literal|"REAL NOT NULL"
argument_list|,
operator|-
literal|11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"ceil(100)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|,
literal|"100"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"ceil(1.3)"
argument_list|,
literal|"DECIMAL(2, 0) NOT NULL"
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"ceil(-1.7)"
argument_list|,
literal|"DECIMAL(2, 0) NOT NULL"
argument_list|,
literal|"-1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"ceiling(cast(null as decimal(2,0)))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"ceiling(cast(null as double))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCeilFuncInterval
parameter_list|()
block|{
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ceil(interval '3:4:5' hour to second)"
argument_list|,
literal|"+4:00:00.000000"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ceil(interval '-6.3' second)"
argument_list|,
literal|"-6.000000"
argument_list|,
literal|"INTERVAL SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ceil(interval '5-1' year to month)"
argument_list|,
literal|"+6-00"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"ceil(interval '-5-1' year to month)"
argument_list|,
literal|"-5-00"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"ceil(cast(null as interval year))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFloorFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|FLOOR
argument_list|,
name|VM_FENNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"floor(2.5e0)"
argument_list|,
literal|"DOUBLE NOT NULL"
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarApprox
argument_list|(
literal|"floor(cast(-1.2e0 as real))"
argument_list|,
literal|"REAL NOT NULL"
argument_list|,
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"floor(100)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|,
literal|"100"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"floor(1.7)"
argument_list|,
literal|"DECIMAL(2, 0) NOT NULL"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalarExact
argument_list|(
literal|"floor(-1.7)"
argument_list|,
literal|"DECIMAL(2, 0) NOT NULL"
argument_list|,
literal|"-2"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"floor(cast(null as decimal(2,0)))"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"floor(cast(null as real))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFloorFuncInterval
parameter_list|()
block|{
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"floor(interval '3:4:5' hour to second)"
argument_list|,
literal|"+3:00:00.000000"
argument_list|,
literal|"INTERVAL HOUR TO SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"floor(interval '-6.3' second)"
argument_list|,
literal|"-7.000000"
argument_list|,
literal|"INTERVAL SECOND NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"floor(interval '5-1' year to month)"
argument_list|,
literal|"+5-00"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"floor(interval '-5-1' year to month)"
argument_list|,
literal|"-6-00"
argument_list|,
literal|"INTERVAL YEAR TO MONTH NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkNull
argument_list|(
literal|"floor(cast(null as interval year))"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDenseRankFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DENSE_RANK
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPercentRankFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|PERCENT_RANK
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRankFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|RANK
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCumeDistFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CUME_DIST
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRowNumberFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ROW_NUMBER
argument_list|,
name|VM_FENNEL
argument_list|,
name|VM_JAVA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCountFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"count(*)"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"count('name')"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"count(1)"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"count(1.2)"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"COUNT(DISTINCT 'x')"
argument_list|,
literal|"BIGINT NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^COUNT()^"
argument_list|,
literal|"Invalid number of arguments to function 'COUNT'. Was expecting 1 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^COUNT(1, 2)^"
argument_list|,
literal|"Invalid number of arguments to function 'COUNT'. Was expecting 1 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS INTEGER)"
block|,
literal|"1"
block|,
literal|"0"
block|}
decl_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"COUNT(x)"
argument_list|,
name|values
argument_list|,
literal|3
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"COUNT(CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"COUNT(DISTINCT x)"
argument_list|,
name|values
argument_list|,
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|// string values -- note that empty string is not null
specifier|final
name|String
index|[]
name|stringValues
init|=
block|{
literal|"'a'"
block|,
literal|"CAST(NULL AS VARCHAR(1))"
block|,
literal|"''"
block|}
decl_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"COUNT(*)"
argument_list|,
name|stringValues
argument_list|,
literal|3
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"COUNT(x)"
argument_list|,
name|stringValues
argument_list|,
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"COUNT(DISTINCT x)"
argument_list|,
name|stringValues
argument_list|,
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"COUNT(DISTINCT 123)"
argument_list|,
name|stringValues
argument_list|,
literal|1
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSumFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"sum(^*^)"
argument_list|,
literal|"Unknown identifier '\\*'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^sum('name')^"
argument_list|,
literal|"(?s)Cannot apply 'SUM' to arguments of type 'SUM\\(<CHAR\\(4\\)>\\)'\\. Supported form\\(s\\): 'SUM\\(<NUMERIC>\\)'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"sum(1)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"sum(1.2)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"sum(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^sum()^"
argument_list|,
literal|"Invalid number of arguments to function 'SUM'. Was expecting 1 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^sum(1, 2)^"
argument_list|,
literal|"Invalid number of arguments to function 'SUM'. Was expecting 1 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^sum(cast(null as varchar(2)))^"
argument_list|,
literal|"(?s)Cannot apply 'SUM' to arguments of type 'SUM\\(<VARCHAR\\(2\\)>\\)'\\. Supported form\\(s\\): 'SUM\\(<NUMERIC>\\)'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS INTEGER)"
block|,
literal|"2"
block|,
literal|"2"
block|}
decl_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"sum(x)"
argument_list|,
name|values
argument_list|,
literal|4
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Object
name|result1
init|=
operator|-
literal|3
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"sum(CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
name|result1
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Object
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"sum(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
name|result
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"sum(DISTINCT x)"
argument_list|,
name|values
argument_list|,
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/** Very similar to {@code tester.checkType}, but generates inside a SELECT    * with a non-empty GROUP BY. Aggregate functions may be nullable if executed    * in a SELECT with an empty GROUP BY.    *    *<p>Viz: {@code SELECT sum(1) FROM emp} has type "INTEGER",    * {@code SELECT sum(1) FROM emp GROUP BY deptno} has type "INTEGER NOT NULL",    */
specifier|protected
name|void
name|checkAggType
parameter_list|(
name|SqlTester
name|tester
parameter_list|,
name|String
name|expr
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|tester
operator|.
name|checkColumnType
argument_list|(
name|SqlTesterImpl
operator|.
name|buildQueryAgg
argument_list|(
name|expr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAvgFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AVG
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"avg(^*^)"
argument_list|,
literal|"Unknown identifier '\\*'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^avg(cast(null as varchar(2)))^"
argument_list|,
literal|"(?s)Cannot apply 'AVG' to arguments of type 'AVG\\(<VARCHAR\\(2\\)>\\)'\\. Supported form\\(s\\): 'AVG\\(<NUMERIC>\\)'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"AVG(CAST(NULL AS INTEGER))"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"AVG(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"avg(1)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"avg(1.2)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"avg(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS FLOAT)"
block|,
literal|"3"
block|,
literal|"3"
block|}
decl_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"AVG(x)"
argument_list|,
name|values
argument_list|,
literal|2d
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"AVG(DISTINCT x)"
argument_list|,
name|values
argument_list|,
literal|1.5d
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|Object
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"avg(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
name|result
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStddevPopFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|STDDEV_POP
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"stddev_pop(^*^)"
argument_list|,
literal|"Unknown identifier '\\*'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^stddev_pop(cast(null as varchar(2)))^"
argument_list|,
literal|"(?s)Cannot apply 'STDDEV_POP' to arguments of type 'STDDEV_POP\\(<VARCHAR\\(2\\)>\\)'\\. Supported form\\(s\\): 'STDDEV_POP\\(<NUMERIC>\\)'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"stddev_pop(CAST(NULL AS INTEGER))"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"stddev_pop(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS FLOAT)"
block|,
literal|"3"
block|,
literal|"3"
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_pop(x)"
argument_list|,
name|values
argument_list|,
literal|1.414213562373095d
argument_list|,
comment|// verified on Oracle 10g
literal|0.000000000000001d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_pop(DISTINCT x)"
argument_list|,
comment|// Oracle does not allow distinct
name|values
argument_list|,
literal|1.5d
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_pop(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|0
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
comment|// with one value
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_pop(x)"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"5"
block|}
argument_list|,
literal|0
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
comment|// with zero values
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_pop(x)"
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|,
literal|null
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStddevSampFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|STDDEV_SAMP
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"stddev_samp(^*^)"
argument_list|,
literal|"Unknown identifier '\\*'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^stddev_samp(cast(null as varchar(2)))^"
argument_list|,
literal|"(?s)Cannot apply 'STDDEV_SAMP' to arguments of type 'STDDEV_SAMP\\(<VARCHAR\\(2\\)>\\)'\\. Supported form\\(s\\): 'STDDEV_SAMP\\(<NUMERIC>\\)'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"stddev_samp(CAST(NULL AS INTEGER))"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"stddev_samp(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS FLOAT)"
block|,
literal|"3"
block|,
literal|"3"
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_samp(x)"
argument_list|,
name|values
argument_list|,
literal|1.732050807568877d
argument_list|,
comment|// verified on Oracle 10g
literal|0.000000000000001d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_samp(DISTINCT x)"
argument_list|,
comment|// Oracle does not allow distinct
name|values
argument_list|,
literal|2.121320343559642d
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_samp(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|null
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
comment|// with one value
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_samp(x)"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"5"
block|}
argument_list|,
literal|null
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
comment|// with zero values
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"stddev_samp(x)"
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|,
literal|null
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testVarPopFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VAR_POP
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"var_pop(^*^)"
argument_list|,
literal|"Unknown identifier '\\*'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^var_pop(cast(null as varchar(2)))^"
argument_list|,
literal|"(?s)Cannot apply 'VAR_POP' to arguments of type 'VAR_POP\\(<VARCHAR\\(2\\)>\\)'\\. Supported form\\(s\\): 'VAR_POP\\(<NUMERIC>\\)'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"var_pop(CAST(NULL AS INTEGER))"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"var_pop(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS FLOAT)"
block|,
literal|"3"
block|,
literal|"3"
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_pop(x)"
argument_list|,
name|values
argument_list|,
literal|2d
argument_list|,
comment|// verified on Oracle 10g
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_pop(DISTINCT x)"
argument_list|,
comment|// Oracle does not allow distinct
name|values
argument_list|,
literal|2.25d
argument_list|,
literal|0.0001d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_pop(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|0
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
comment|// with one value
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_pop(x)"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"5"
block|}
argument_list|,
literal|0
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
comment|// with zero values
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_pop(x)"
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|,
literal|null
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testVarSampFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VAR_SAMP
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"var_samp(^*^)"
argument_list|,
literal|"Unknown identifier '\\*'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^var_samp(cast(null as varchar(2)))^"
argument_list|,
literal|"(?s)Cannot apply 'VAR_SAMP' to arguments of type 'VAR_SAMP\\(<VARCHAR\\(2\\)>\\)'\\. Supported form\\(s\\): 'VAR_SAMP\\(<NUMERIC>\\)'.*"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"var_samp(CAST(NULL AS INTEGER))"
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|checkAggType
argument_list|(
name|tester
argument_list|,
literal|"var_samp(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS FLOAT)"
block|,
literal|"3"
block|,
literal|"3"
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_samp(x)"
argument_list|,
name|values
argument_list|,
literal|3d
argument_list|,
comment|// verified on Oracle 10g
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_samp(DISTINCT x)"
argument_list|,
comment|// Oracle does not allow distinct
name|values
argument_list|,
literal|4.5d
argument_list|,
literal|0.0001d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_samp(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|null
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
comment|// with one value
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_samp(x)"
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"5"
block|}
argument_list|,
literal|null
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
comment|// with zero values
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"var_samp(x)"
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|,
literal|null
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMinFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MIN
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"min(^*^)"
argument_list|,
literal|"Unknown identifier '\\*'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"min(1)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"min(1.2)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"min(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^min()^"
argument_list|,
literal|"Invalid number of arguments to function 'MIN'. Was expecting 1 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^min(1, 2)^"
argument_list|,
literal|"Invalid number of arguments to function 'MIN'. Was expecting 1 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS INTEGER)"
block|,
literal|"2"
block|,
literal|"2"
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"min(x)"
argument_list|,
name|values
argument_list|,
literal|"0"
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"min(CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|"-1"
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"min(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|"-1"
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"min(DISTINCT x)"
argument_list|,
name|values
argument_list|,
literal|"0"
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMaxFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MAX
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"max(^*^)"
argument_list|,
literal|"Unknown identifier '\\*'"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"max(1)"
argument_list|,
literal|"INTEGER NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"max(1.2)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkType
argument_list|(
literal|"max(DISTINCT 1.5)"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^max()^"
argument_list|,
literal|"Invalid number of arguments to function 'MAX'. Was expecting 1 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkFails
argument_list|(
literal|"^max(1, 2)^"
argument_list|,
literal|"Invalid number of arguments to function 'MAX'. Was expecting 1 arguments"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS INTEGER)"
block|,
literal|"2"
block|,
literal|"2"
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"max(x)"
argument_list|,
name|values
argument_list|,
literal|"2"
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"max(CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|"-1"
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"max(DISTINCT CASE x WHEN 0 THEN NULL ELSE -1 END)"
argument_list|,
name|values
argument_list|,
literal|"-1"
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkAgg
argument_list|(
literal|"max(DISTINCT x)"
argument_list|,
name|values
argument_list|,
literal|"2"
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLastValueFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LAST_VALUE
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS INTEGER)"
block|,
literal|"3"
block|,
literal|"3"
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkWinAgg
argument_list|(
literal|"last_value(x)"
argument_list|,
name|values
argument_list|,
literal|"ROWS 3 PRECEDING"
argument_list|,
literal|"INTEGER"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"3"
argument_list|,
literal|"0"
argument_list|)
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values2
init|=
block|{
literal|"1.6"
block|,
literal|"1.2"
block|}
decl_stmt|;
name|tester
operator|.
name|checkWinAgg
argument_list|(
literal|"last_value(x)"
argument_list|,
name|values2
argument_list|,
literal|"ROWS 3 PRECEDING"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"1.6"
argument_list|,
literal|"1.2"
argument_list|)
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values3
init|=
block|{
literal|"'foo'"
block|,
literal|"'bar'"
block|,
literal|"'name'"
block|}
decl_stmt|;
name|tester
operator|.
name|checkWinAgg
argument_list|(
literal|"last_value(x)"
argument_list|,
name|values3
argument_list|,
literal|"ROWS 3 PRECEDING"
argument_list|,
literal|"CHAR(4) NOT NULL"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"foo "
argument_list|,
literal|"bar "
argument_list|,
literal|"name"
argument_list|)
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFirstValueFunc
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|FIRST_VALUE
argument_list|,
name|VM_EXPAND
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values
init|=
block|{
literal|"0"
block|,
literal|"CAST(null AS INTEGER)"
block|,
literal|"3"
block|,
literal|"3"
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkWinAgg
argument_list|(
literal|"first_value(x)"
argument_list|,
name|values
argument_list|,
literal|"ROWS 3 PRECEDING"
argument_list|,
literal|"INTEGER"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"0"
argument_list|)
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values2
init|=
block|{
literal|"1.6"
block|,
literal|"1.2"
block|}
decl_stmt|;
name|tester
operator|.
name|checkWinAgg
argument_list|(
literal|"first_value(x)"
argument_list|,
name|values2
argument_list|,
literal|"ROWS 3 PRECEDING"
argument_list|,
literal|"DECIMAL(2, 1) NOT NULL"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"1.6"
argument_list|)
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|values3
init|=
block|{
literal|"'foo'"
block|,
literal|"'bar'"
block|,
literal|"'name'"
block|}
decl_stmt|;
name|tester
operator|.
name|checkWinAgg
argument_list|(
literal|"first_value(x)"
argument_list|,
name|values3
argument_list|,
literal|"ROWS 3 PRECEDING"
argument_list|,
literal|"CHAR(4) NOT NULL"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"foo "
argument_list|)
argument_list|,
literal|0d
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that CAST fails when given a value just outside the valid range for    * that type. For example,    *    *<ul>    *<li>CAST(-200 AS TINYINT) fails because the value is less than -128;    *<li>CAST(1E-999 AS FLOAT) fails because the value underflows;    *<li>CAST(123.4567891234567 AS FLOAT) fails because the value loses    * precision.    *</ul>    */
annotation|@
name|Test
specifier|public
name|void
name|testLiteralAtLimit
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
for|for
control|(
name|BasicSqlType
name|type
range|:
name|SqlLimitsTest
operator|.
name|getTypes
argument_list|()
control|)
block|{
for|for
control|(
name|Object
name|o
range|:
name|getValues
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
control|)
block|{
name|SqlLiteral
name|literal
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|createLiteral
argument_list|(
name|o
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|SqlString
name|literalString
init|=
name|literal
operator|.
name|toSqlString
argument_list|(
name|SqlDialect
operator|.
name|DUMMY
argument_list|)
decl_stmt|;
specifier|final
name|String
name|expr
init|=
literal|"CAST("
operator|+
name|literalString
operator|+
literal|" AS "
operator|+
name|type
operator|+
literal|")"
decl_stmt|;
try|try
block|{
name|tester
operator|.
name|checkType
argument_list|(
name|expr
argument_list|,
name|type
operator|.
name|getFullTypeString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BINARY
condition|)
block|{
comment|// Casting a string/binary values may change the value.
comment|// For example, CAST(X'AB' AS BINARY(2)) yields
comment|// X'AB00'.
block|}
else|else
block|{
name|tester
operator|.
name|checkScalar
argument_list|(
name|expr
operator|+
literal|" = "
operator|+
name|literalString
argument_list|,
literal|true
argument_list|,
literal|"BOOLEAN NOT NULL"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Error
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Failed for expr=["
operator|+
name|expr
operator|+
literal|"]"
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Failed for expr=["
operator|+
name|expr
operator|+
literal|"]"
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Tests that CAST fails when given a value just outside the valid range for    * that type. For example,    *    *<ul>    *<li>CAST(-200 AS TINYINT) fails because the value is less than -128;    *<li>CAST(1E-999 AS FLOAT) fails because the value underflows;    *<li>CAST(123.4567891234567 AS FLOAT) fails because the value loses    * precision.    *</ul>    */
annotation|@
name|Test
specifier|public
name|void
name|testLiteralBeyondLimit
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
for|for
control|(
name|BasicSqlType
name|type
range|:
name|SqlLimitsTest
operator|.
name|getTypes
argument_list|()
control|)
block|{
for|for
control|(
name|Object
name|o
range|:
name|getValues
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
control|)
block|{
name|SqlLiteral
name|literal
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|createLiteral
argument_list|(
name|o
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|SqlString
name|literalString
init|=
name|literal
operator|.
name|toSqlString
argument_list|(
name|SqlDialect
operator|.
name|DUMMY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BIGINT
operator|)
operator|||
operator|(
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|DECIMAL
operator|)
operator|&&
operator|(
name|type
operator|.
name|getPrecision
argument_list|()
operator|==
literal|19
operator|)
operator|)
condition|)
block|{
comment|// Values which are too large to be literals fail at
comment|// validate time.
name|tester
operator|.
name|checkFails
argument_list|(
literal|"CAST(^"
operator|+
name|literalString
operator|+
literal|"^ AS "
operator|+
name|type
operator|+
literal|")"
argument_list|,
literal|"Numeric literal '.*' out of range"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CHAR
operator|)
operator|||
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|VARCHAR
operator|)
operator|||
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|BINARY
operator|)
operator|||
operator|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|VARBINARY
operator|)
condition|)
block|{
comment|// Casting overlarge string/binary values do not fail -
comment|// they are truncated. See testCastTruncates().
block|}
else|else
block|{
comment|// Value outside legal bound should fail at runtime (not
comment|// validate time).
comment|//
comment|// NOTE: Because Java and Fennel calcs give
comment|// different errors, the pattern hedges its bets.
name|tester
operator|.
name|checkFails
argument_list|(
literal|"CAST("
operator|+
name|literalString
operator|+
literal|" AS "
operator|+
name|type
operator|+
literal|")"
argument_list|,
literal|"(?s).*(Overflow during calculation or cast\\.|Code=22003).*"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCastTruncates
parameter_list|()
block|{
name|tester
operator|.
name|setFor
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CAST
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST('ABCD' AS CHAR(2))"
argument_list|,
literal|"AB"
argument_list|,
literal|"CHAR(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST('ABCD' AS VARCHAR(2))"
argument_list|,
literal|"AB"
argument_list|,
literal|"VARCHAR(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST(x'ABCDEF12' AS BINARY(2))"
argument_list|,
literal|"abcd"
argument_list|,
literal|"BINARY(2) NOT NULL"
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkScalar
argument_list|(
literal|"CAST(x'ABCDEF12' AS VARBINARY(2))"
argument_list|,
literal|"abcd"
argument_list|,
literal|"VARBINARY(2) NOT NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
return|return;
block|}
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"CAST(X'' AS BINARY(3)) = X'000000'"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tester
operator|.
name|checkBoolean
argument_list|(
literal|"CAST(X'' AS BINARY(3)) = X''"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|getValues
parameter_list|(
name|BasicSqlType
name|type
parameter_list|,
name|boolean
name|inBound
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|boolean
name|sign
range|:
name|FALSE_TRUE
control|)
block|{
for|for
control|(
name|SqlTypeName
operator|.
name|Limit
name|limit
range|:
name|SqlTypeName
operator|.
name|Limit
operator|.
name|values
argument_list|()
control|)
block|{
name|Object
name|o
init|=
name|type
operator|.
name|getLimit
argument_list|(
name|sign
argument_list|,
name|limit
argument_list|,
operator|!
name|inBound
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|values
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|values
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|values
return|;
block|}
comment|// TODO: Test other stuff
comment|/**    * Result checker that considers a test to have succeeded if it throws an    * exception that matches one of a list of patterns.    */
specifier|private
specifier|static
class|class
name|ExceptionResultChecker
implements|implements
name|SqlTester
operator|.
name|ResultChecker
block|{
specifier|private
specifier|final
name|Pattern
index|[]
name|patterns
decl_stmt|;
specifier|public
name|ExceptionResultChecker
parameter_list|(
name|Pattern
modifier|...
name|patterns
parameter_list|)
block|{
name|this
operator|.
name|patterns
operator|=
name|patterns
expr_stmt|;
block|}
specifier|public
name|void
name|checkResult
parameter_list|(
name|ResultSet
name|result
parameter_list|)
throws|throws
name|Exception
block|{
name|Throwable
name|thrown
init|=
literal|null
decl_stmt|;
try|try
block|{
name|result
operator|.
name|next
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"expected exception"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|thrown
operator|=
name|e
expr_stmt|;
block|}
specifier|final
name|String
name|stack
init|=
name|Util
operator|.
name|getStackTrace
argument_list|(
name|thrown
argument_list|)
decl_stmt|;
for|for
control|(
name|Pattern
name|pattern
range|:
name|patterns
control|)
block|{
if|if
condition|(
name|pattern
operator|.
name|matcher
argument_list|(
name|stack
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
name|fail
argument_list|(
literal|"Stack did not match any pattern; "
operator|+
name|stack
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Result checker that considers a test to have succeeded if it returns a    * particular value or throws an exception that matches one of a list of    * patterns.    *    *<p>Sounds peculiar, but is necessary when eager and lazy behaviors are    * both valid.    */
specifier|private
specifier|static
class|class
name|ValueOrExceptionResultChecker
implements|implements
name|SqlTester
operator|.
name|ResultChecker
block|{
specifier|private
specifier|final
name|Object
name|expected
decl_stmt|;
specifier|private
specifier|final
name|Pattern
index|[]
name|patterns
decl_stmt|;
specifier|public
name|ValueOrExceptionResultChecker
parameter_list|(
name|Object
name|expected
parameter_list|,
name|Pattern
modifier|...
name|patterns
parameter_list|)
block|{
name|this
operator|.
name|expected
operator|=
name|expected
expr_stmt|;
name|this
operator|.
name|patterns
operator|=
name|patterns
expr_stmt|;
block|}
specifier|public
name|void
name|checkResult
parameter_list|(
name|ResultSet
name|result
parameter_list|)
throws|throws
name|Exception
block|{
name|Throwable
name|thrown
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|result
operator|.
name|next
argument_list|()
condition|)
block|{
comment|// empty result is OK
return|return;
block|}
specifier|final
name|Object
name|actual
init|=
name|result
operator|.
name|getObject
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
name|thrown
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|thrown
operator|!=
literal|null
condition|)
block|{
specifier|final
name|String
name|stack
init|=
name|Util
operator|.
name|getStackTrace
argument_list|(
name|thrown
argument_list|)
decl_stmt|;
for|for
control|(
name|Pattern
name|pattern
range|:
name|patterns
control|)
block|{
if|if
condition|(
name|pattern
operator|.
name|matcher
argument_list|(
name|stack
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
name|fail
argument_list|(
literal|"Stack did not match any pattern; "
operator|+
name|stack
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Creates a {@link org.eigenbase.sql.test.SqlTester} based on a JDBC    * connection.    */
specifier|public
specifier|static
name|SqlTester
name|tester
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
return|return
operator|new
name|TesterImpl
argument_list|(
name|connection
argument_list|)
return|;
block|}
comment|/**    * Implementation of {@link org.eigenbase.sql.test.SqlTester} based on a    * JDBC connection.    */
specifier|protected
specifier|static
class|class
name|TesterImpl
extends|extends
name|SqlTesterImpl
block|{
specifier|final
name|Connection
name|connection
decl_stmt|;
specifier|public
name|TesterImpl
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|super
argument_list|(
name|DefaultSqlTestFactory
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|check
parameter_list|(
name|String
name|query
parameter_list|,
name|TypeChecker
name|typeChecker
parameter_list|,
name|ResultChecker
name|resultChecker
parameter_list|)
block|{
name|super
operator|.
name|check
argument_list|(
name|query
argument_list|,
name|typeChecker
argument_list|,
name|resultChecker
argument_list|)
expr_stmt|;
name|Statement
name|statement
init|=
literal|null
decl_stmt|;
try|try
block|{
name|statement
operator|=
name|connection
operator|.
name|createStatement
argument_list|()
expr_stmt|;
specifier|final
name|ResultSet
name|resultSet
init|=
name|statement
operator|.
name|executeQuery
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|resultChecker
operator|.
name|checkResult
argument_list|(
name|resultSet
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|statement
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|statement
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SQLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End SqlOperatorBaseTest.java
end_comment

end_unit

