begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|test
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|advise
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|parser
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|type
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|test
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Concrete child class of {@link SqlValidatorTestCase}, containing unit tests  * for SqlAdvisor.  */
end_comment

begin_class
specifier|public
class|class
name|SqlAdvisorTest
extends|extends
name|SqlValidatorTestCase
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|STAR_KEYWORD
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(*)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FROM_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(LATERAL)"
argument_list|,
literal|"KEYWORD(TABLE)"
argument_list|,
literal|"KEYWORD(UNNEST)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|AGG_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(SELECT)"
argument_list|,
literal|"KEYWORD(TABLE)"
argument_list|,
literal|"KEYWORD(VALUES)"
argument_list|,
literal|"KEYWORD())"
argument_list|,
literal|"KEYWORD(*)"
argument_list|,
literal|"KEYWORD(ALL)"
argument_list|,
literal|"KEYWORD(DISTINCT)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SALES_TABLES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EMP)"
argument_list|,
literal|"TABLE(EMP_ADDRESS)"
argument_list|,
literal|"TABLE(DEPT)"
argument_list|,
literal|"TABLE(BONUS)"
argument_list|,
literal|"TABLE(SALGRADE)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SCHEMAS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"SCHEMA(SALES)"
argument_list|,
literal|"SCHEMA(CUSTOMER)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|AB_TABLES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(A)"
argument_list|,
literal|"TABLE(B)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_TABLE
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EMP)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FETCH_OFFSET
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EXPR_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(+)"
argument_list|,
literal|"KEYWORD(-)"
argument_list|,
literal|"KEYWORD(?)"
argument_list|,
literal|"KEYWORD(ABS)"
argument_list|,
literal|"KEYWORD(ARRAY)"
argument_list|,
literal|"KEYWORD(AVG)"
argument_list|,
literal|"KEYWORD(CARDINALITY)"
argument_list|,
literal|"KEYWORD(CASE)"
argument_list|,
literal|"KEYWORD(CAST)"
argument_list|,
literal|"KEYWORD(CEIL)"
argument_list|,
literal|"KEYWORD(CEILING)"
argument_list|,
literal|"KEYWORD(CHARACTER_LENGTH)"
argument_list|,
literal|"KEYWORD(CHAR_LENGTH)"
argument_list|,
literal|"KEYWORD(COALESCE)"
argument_list|,
literal|"KEYWORD(COLLECT)"
argument_list|,
literal|"KEYWORD(CONVERT)"
argument_list|,
literal|"KEYWORD(COUNT)"
argument_list|,
literal|"KEYWORD(COVAR_POP)"
argument_list|,
literal|"KEYWORD(COVAR_SAMP)"
argument_list|,
literal|"KEYWORD(CUME_DIST)"
argument_list|,
literal|"KEYWORD(CURRENT_CATALOG)"
argument_list|,
literal|"KEYWORD(CURRENT_DATE)"
argument_list|,
literal|"KEYWORD(CURRENT_DEFAULT_TRANSFORM_GROUP)"
argument_list|,
literal|"KEYWORD(CURRENT_PATH)"
argument_list|,
literal|"KEYWORD(CURRENT_ROLE)"
argument_list|,
literal|"KEYWORD(CURRENT_SCHEMA)"
argument_list|,
literal|"KEYWORD(CURRENT_TIME)"
argument_list|,
literal|"KEYWORD(CURRENT_TIMESTAMP)"
argument_list|,
literal|"KEYWORD(CURRENT_USER)"
argument_list|,
literal|"KEYWORD(CURSOR)"
argument_list|,
literal|"KEYWORD(DATE)"
argument_list|,
literal|"KEYWORD(DENSE_RANK)"
argument_list|,
literal|"KEYWORD(ELEMENT)"
argument_list|,
literal|"KEYWORD(EXISTS)"
argument_list|,
literal|"KEYWORD(EXP)"
argument_list|,
literal|"KEYWORD(EXTRACT)"
argument_list|,
literal|"KEYWORD(FALSE)"
argument_list|,
literal|"KEYWORD(FIRST_VALUE)"
argument_list|,
literal|"KEYWORD(FLOOR)"
argument_list|,
literal|"KEYWORD(FUSION)"
argument_list|,
literal|"KEYWORD(INTERVAL)"
argument_list|,
literal|"KEYWORD(LAST_VALUE)"
argument_list|,
literal|"KEYWORD(LN)"
argument_list|,
literal|"KEYWORD(LOCALTIME)"
argument_list|,
literal|"KEYWORD(LOCALTIMESTAMP)"
argument_list|,
literal|"KEYWORD(LOWER)"
argument_list|,
literal|"KEYWORD(MAX)"
argument_list|,
literal|"KEYWORD(MIN)"
argument_list|,
literal|"KEYWORD(MOD)"
argument_list|,
literal|"KEYWORD(MULTISET)"
argument_list|,
literal|"KEYWORD(NEW)"
argument_list|,
literal|"KEYWORD(NOT)"
argument_list|,
literal|"KEYWORD(NULL)"
argument_list|,
literal|"KEYWORD(NULLIF)"
argument_list|,
literal|"KEYWORD(OCTET_LENGTH)"
argument_list|,
literal|"KEYWORD(OVERLAY)"
argument_list|,
literal|"KEYWORD(PERCENT_RANK)"
argument_list|,
literal|"KEYWORD(POSITION)"
argument_list|,
literal|"KEYWORD(POWER)"
argument_list|,
literal|"KEYWORD(RANK)"
argument_list|,
literal|"KEYWORD(REGR_SXX)"
argument_list|,
literal|"KEYWORD(REGR_SYY)"
argument_list|,
literal|"KEYWORD(ROW)"
argument_list|,
literal|"KEYWORD(ROW_NUMBER)"
argument_list|,
literal|"KEYWORD(SESSION_USER)"
argument_list|,
literal|"KEYWORD(SPECIFIC)"
argument_list|,
literal|"KEYWORD(SQRT)"
argument_list|,
literal|"KEYWORD(SUBSTRING)"
argument_list|,
literal|"KEYWORD(STDDEV_POP)"
argument_list|,
literal|"KEYWORD(STDDEV_SAMP)"
argument_list|,
literal|"KEYWORD(SUM)"
argument_list|,
literal|"KEYWORD(SYSTEM_USER)"
argument_list|,
literal|"KEYWORD(TIME)"
argument_list|,
literal|"KEYWORD(TIMESTAMP)"
argument_list|,
literal|"KEYWORD(TRANSLATE)"
argument_list|,
literal|"KEYWORD(TRIM)"
argument_list|,
literal|"KEYWORD(TRUE)"
argument_list|,
literal|"KEYWORD(UNKNOWN)"
argument_list|,
literal|"KEYWORD(UPPER)"
argument_list|,
literal|"KEYWORD(USER)"
argument_list|,
literal|"KEYWORD(VAR_POP)"
argument_list|,
literal|"KEYWORD(VAR_SAMP)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SELECT_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(ALL)"
argument_list|,
literal|"KEYWORD(DISTINCT)"
argument_list|,
literal|"KEYWORD(*)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|ORDER_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(,)"
argument_list|,
literal|"KEYWORD(ASC)"
argument_list|,
literal|"KEYWORD(DESC)"
argument_list|,
literal|"KEYWORD(NULLS)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMP_COLUMNS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(EMPNO)"
argument_list|,
literal|"COLUMN(ENAME)"
argument_list|,
literal|"COLUMN(JOB)"
argument_list|,
literal|"COLUMN(MGR)"
argument_list|,
literal|"COLUMN(HIREDATE)"
argument_list|,
literal|"COLUMN(SAL)"
argument_list|,
literal|"COLUMN(COMM)"
argument_list|,
literal|"COLUMN(DEPTNO)"
argument_list|,
literal|"COLUMN(SLACKER)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|DEPT_COLUMNS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(DEPTNO)"
argument_list|,
literal|"COLUMN(NAME)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|PREDICATE_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(()"
argument_list|,
literal|"KEYWORD(*)"
argument_list|,
literal|"KEYWORD(+)"
argument_list|,
literal|"KEYWORD(-)"
argument_list|,
literal|"KEYWORD(.)"
argument_list|,
literal|"KEYWORD(/)"
argument_list|,
literal|"KEYWORD(<)"
argument_list|,
literal|"KEYWORD(<=)"
argument_list|,
literal|"KEYWORD(<>)"
argument_list|,
literal|"KEYWORD(=)"
argument_list|,
literal|"KEYWORD(>)"
argument_list|,
literal|"KEYWORD(>=)"
argument_list|,
literal|"KEYWORD(AND)"
argument_list|,
literal|"KEYWORD(BETWEEN)"
argument_list|,
literal|"KEYWORD(IN)"
argument_list|,
literal|"KEYWORD(IS)"
argument_list|,
literal|"KEYWORD(LIKE)"
argument_list|,
literal|"KEYWORD(MEMBER)"
argument_list|,
literal|"KEYWORD(MULTISET)"
argument_list|,
literal|"KEYWORD(NOT)"
argument_list|,
literal|"KEYWORD(OR)"
argument_list|,
literal|"KEYWORD(SIMILAR)"
argument_list|,
literal|"KEYWORD(SUBMULTISET)"
argument_list|,
literal|"KEYWORD([)"
argument_list|,
literal|"KEYWORD(||)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|WHERE_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(GROUP)"
argument_list|,
literal|"KEYWORD(HAVING)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|,
literal|"KEYWORD(WINDOW)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|A_TABLE
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(A)"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|JOIN_KEYWORDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(FETCH)"
argument_list|,
literal|"KEYWORD(OFFSET)"
argument_list|,
literal|"KEYWORD(LIMIT)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|,
literal|"KEYWORD(FULL)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(AS)"
argument_list|,
literal|"KEYWORD(USING)"
argument_list|,
literal|"KEYWORD(RIGHT)"
argument_list|,
literal|"KEYWORD(GROUP)"
argument_list|,
literal|"KEYWORD(CROSS)"
argument_list|,
literal|"KEYWORD(,)"
argument_list|,
literal|"KEYWORD(NATURAL)"
argument_list|,
literal|"KEYWORD(INNER)"
argument_list|,
literal|"KEYWORD(HAVING)"
argument_list|,
literal|"KEYWORD(LEFT)"
argument_list|,
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(JOIN)"
argument_list|,
literal|"KEYWORD(WINDOW)"
argument_list|,
literal|"KEYWORD(.)"
argument_list|,
literal|"KEYWORD(TABLESAMPLE)"
argument_list|,
literal|"KEYWORD(ON)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(WHERE)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|SETOPS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(EXCEPT)"
argument_list|,
literal|"KEYWORD(INTERSECT)"
argument_list|,
literal|"KEYWORD(ORDER)"
argument_list|,
literal|"KEYWORD(UNION)"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|EMPNO_EMP
init|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"TABLE(EMP)\n"
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|SqlAdvisorTest
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getFromKeywords
parameter_list|()
block|{
return|return
name|FROM_KEYWORDS
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSelectKeywords
parameter_list|()
block|{
return|return
name|SELECT_KEYWORDS
return|;
block|}
comment|/**    * Returns a list of the tables in the SALES schema. Derived classes with    * extended SALES schemas may override.    *    * @return list of tables in the SALES schema    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSalesTables
parameter_list|()
block|{
return|return
name|SALES_TABLES
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getJoinKeywords
parameter_list|()
block|{
return|return
name|JOIN_KEYWORDS
return|;
block|}
specifier|private
name|void
name|assertTokenizesTo
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|SqlSimpleParser
operator|.
name|Tokenizer
name|tokenizer
init|=
operator|new
name|SqlSimpleParser
operator|.
name|Tokenizer
argument_list|(
name|sql
argument_list|,
literal|"xxxxx"
argument_list|)
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|SqlSimpleParser
operator|.
name|Token
name|token
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|buf
operator|.
name|append
argument_list|(
name|token
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertHint
parameter_list|(
name|String
name|sql
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedLists
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|plus
argument_list|(
name|expectedLists
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|expectedList
argument_list|)
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|toString
argument_list|(
name|expectedList
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks that a given SQL statement yields the expected set of completion    * hints.    *    * @param sql             SQL statement    * @param expectedResults Expected list of hints    * @throws Exception on error    */
specifier|protected
name|void
name|assertHint
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expectedResults
parameter_list|)
throws|throws
name|Exception
block|{
name|SqlValidatorWithHints
name|validator
init|=
operator|(
name|SqlValidatorWithHints
operator|)
name|tester
operator|.
name|getValidator
argument_list|()
decl_stmt|;
name|SqlAdvisor
name|advisor
init|=
name|tester
operator|.
name|getFactory
argument_list|()
operator|.
name|createAdvisor
argument_list|(
name|validator
argument_list|)
decl_stmt|;
name|SqlParserUtil
operator|.
name|StringAndPos
name|sap
init|=
name|SqlParserUtil
operator|.
name|findPos
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|results
init|=
name|advisor
operator|.
name|getCompletionHints
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|sap
operator|.
name|pos
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expectedResults
argument_list|,
name|convertCompletionHints
argument_list|(
name|results
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that a given SQL statement simplifies to the salesTables result.    *    * @param sql      SQL statement to simplify. The SQL statement must contain    *                 precisely one caret '^', which marks the location where    *                 completion is to occur.    * @param expected Expected result after simplification.    */
specifier|protected
name|void
name|assertSimplify
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|SqlValidatorWithHints
name|validator
init|=
operator|(
name|SqlValidatorWithHints
operator|)
name|tester
operator|.
name|getValidator
argument_list|()
decl_stmt|;
name|SqlAdvisor
name|advisor
init|=
name|tester
operator|.
name|getFactory
argument_list|()
operator|.
name|createAdvisor
argument_list|(
name|validator
argument_list|)
decl_stmt|;
name|SqlParserUtil
operator|.
name|StringAndPos
name|sap
init|=
name|SqlParserUtil
operator|.
name|findPos
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|String
name|actual
init|=
name|advisor
operator|.
name|simplifySql
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|sap
operator|.
name|cursor
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|String
name|sql
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedResults
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|plus
argument_list|(
name|expectedResults
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|expectedList
argument_list|)
expr_stmt|;
name|String
name|expected
init|=
name|toString
argument_list|(
name|expectedList
argument_list|)
decl_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that a given SQL which may be invalid or incomplete simplifies    * itself and yields the salesTables set of completion hints. This is an    * integration test of {@link #assertHint} and {@link #assertSimplify}.    *    * @param sql             SQL statement    * @param expectedResults Expected list of hints    * @param expectedWord    Word that we expect to be replaced, or null if we    *                        don't care    */
specifier|protected
name|void
name|assertComplete
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|expectedResults
parameter_list|,
name|String
name|expectedWord
parameter_list|)
block|{
name|SqlValidatorWithHints
name|validator
init|=
operator|(
name|SqlValidatorWithHints
operator|)
name|tester
operator|.
name|getValidator
argument_list|()
decl_stmt|;
name|SqlAdvisor
name|advisor
init|=
name|tester
operator|.
name|getFactory
argument_list|()
operator|.
name|createAdvisor
argument_list|(
name|validator
argument_list|)
decl_stmt|;
name|SqlParserUtil
operator|.
name|StringAndPos
name|sap
init|=
name|SqlParserUtil
operator|.
name|findPos
argument_list|(
name|sql
argument_list|)
decl_stmt|;
specifier|final
name|String
index|[]
name|replaced
init|=
block|{
literal|null
block|}
decl_stmt|;
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|results
init|=
name|advisor
operator|.
name|getCompletionHints
argument_list|(
name|sap
operator|.
name|sql
argument_list|,
name|sap
operator|.
name|cursor
argument_list|,
name|replaced
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|replaced
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|results
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expectedResults
argument_list|,
name|convertCompletionHints
argument_list|(
name|results
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedWord
operator|!=
literal|null
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expectedWord
argument_list|,
name|replaced
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|assertEquals
parameter_list|(
name|String
index|[]
name|actualResults
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
modifier|...
name|expectedResults
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|expectedList
init|=
name|plus
argument_list|(
name|expectedResults
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|uniqueResults
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|actualResult
range|:
name|actualResults
control|)
block|{
name|uniqueResults
operator|.
name|put
argument_list|(
name|actualResult
argument_list|,
name|actualResult
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|expectedList
operator|.
name|containsAll
argument_list|(
name|uniqueResults
operator|.
name|values
argument_list|()
argument_list|)
operator|&&
operator|(
name|expectedList
operator|.
name|size
argument_list|()
operator|==
name|uniqueResults
operator|.
name|values
argument_list|()
operator|.
name|size
argument_list|()
operator|)
operator|)
condition|)
block|{
name|fail
argument_list|(
literal|"SqlAdvisorTest: completion hints results not as salesTables:\n"
operator|+
name|uniqueResults
operator|.
name|values
argument_list|()
operator|+
literal|"\nExpected:\n"
operator|+
name|expectedList
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|convertCompletionHints
parameter_list|(
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hints
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlMoniker
name|hint
range|:
name|hints
control|)
block|{
if|if
condition|(
name|hint
operator|.
name|getType
argument_list|()
operator|!=
name|SqlMonikerType
operator|.
name|FUNCTION
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|hint
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|toString
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**    * Converts a list to a string, one item per line.    *    * @param list List    * @return String with one item of the list per line    */
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|toString
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|list
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|list
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|t
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlTester
name|getTester
parameter_list|()
block|{
return|return
operator|new
name|SqlTesterImpl
argument_list|(
operator|new
name|AdvisorTesterFactory
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Concatenates several lists of the same type into a single list.    *    * @param lists Lists to concatenate    * @return Sum list    */
specifier|protected
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|plus
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
modifier|...
name|lists
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|T
argument_list|>
name|list
range|:
name|lists
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFrom
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from ^dummy a, sales.dummy b"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from ^, sales.dummy b"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from ^a"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a, ^sales.dummy b"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFromComplete
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select a.empno, b.deptno from dummy a, sales.^"
decl_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGroup
parameter_list|()
block|{
comment|// This test is hard because the statement is not valid if you replace
comment|// '^' with a dummy identifier.
name|String
name|sql
init|=
literal|"select a.empno, b.deptno from emp group ^"
decl_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"KEYWORD(BY)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^dummy a join sales.dummy b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^ a join sales.dummy b"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// REVIEW: because caret is before 'sales', should it ignore schema
comment|// name and present all schemas and all tables in the default schema?
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join ^sales.dummy b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|getFromKeywords
argument_list|()
argument_list|,
name|SCHEMAS
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ on"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
comment|// join
comment|// unfortunately cannot complete this case: syntax is too broken
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ on a.deptno="
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// join
block|}
annotation|@
name|Test
specifier|public
name|void
name|testJoinKeywords
parameter_list|()
block|{
comment|// variety of keywords possible
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|getJoinKeywords
argument_list|()
decl_stmt|;
name|String
name|sql
init|=
literal|"select * from dummy join sales.emp ^"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
literal|"SELECT * FROM dummy JOIN sales.emp _suggest_"
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOnCondition
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on ^a.deptno=b.dummy where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// on left
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
comment|// on left
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=^b.dummy where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// on right
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.^ where empno=1"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// on right
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// on right
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFromWhere
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where b.deptno=^a.dummy"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where b.deptno=a.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
comment|// where list
comment|// hints contain no columns, only table aliases, because there are>1
comment|// aliases
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// where list
comment|// If there's only one table alias, we allow both the alias and the
comment|// unqualified columns
name|assertComplete
argument_list|(
literal|"select a.empno, a.deptno from sales.emp a "
operator|+
literal|"where ^"
argument_list|,
name|A_TABLE
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testWhereList
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where ^a.dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// where list
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where a.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where a.empno ^ "
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|PREDICATE_KEYWORDS
argument_list|,
name|WHERE_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSelectList
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select ^dummy, b.dummy from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (values (1))"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EXPR$0)"
argument_list|,
literal|"COLUMN(EXPR$0)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^ from (values (1)) as t(c)"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(T)"
argument_list|,
literal|"COLUMN(C)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^, b.dummy from sales.emp a join sales.dept b "
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|SETOPS
argument_list|,
name|AB_TABLES
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, ^b.dummy from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=b.deptno where empno=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|STAR_KEYWORD
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a join sales.dept b on true"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|STAR_KEYWORD
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// REVIEW: Since 'b' is not a valid alias, should it suggest anything?
comment|// We don't get through validation, so the only suggestion, '*', comes
comment|// from the parser.
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^emp.dummy from sales.emp"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(EMP)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.^ from sales.emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrderByList
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^dummy"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EMP_TABLE
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|EMP_TABLE
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno\n"
operator|+
literal|"from sales.emp as e(\n"
operator|+
literal|"  mpno,name,ob,gr,iredate,al,omm,eptno,lacker)\n"
operator|+
literal|"where e.mpno=1 order by ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(MPNO)"
argument_list|,
literal|"COLUMN(NAME)"
argument_list|,
literal|"COLUMN(OB)"
argument_list|,
literal|"COLUMN(GR)"
argument_list|,
literal|"COLUMN(IREDATE)"
argument_list|,
literal|"COLUMN(AL)"
argument_list|,
literal|"COLUMN(OMM)"
argument_list|,
literal|"COLUMN(EPTNO)"
argument_list|,
literal|"COLUMN(LACKER)"
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(E)"
argument_list|)
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by empno ^, deptno"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|PREDICATE_KEYWORDS
argument_list|,
name|ORDER_KEYWORDS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSubQuery
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|xyColumns
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"COLUMN(X)"
argument_list|,
literal|"COLUMN(Y)"
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tTable
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"TABLE(T)"
argument_list|)
decl_stmt|;
name|sql
operator|=
literal|"select ^t.dummy from (select 1 as x, 2 as y from sales.emp) as t where t.dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|xyColumns
argument_list|,
name|tTable
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales.emp) as t"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|xyColumns
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.emp) as t where ^t.dummy=1"
expr_stmt|;
name|assertHint
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.emp) as t where t.^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.emp) as t where ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
comment|// with extra from item, aliases are ambiguous, so columns are not
comment|// offered
name|sql
operator|=
literal|"select a.x from (select 1 as x, 2 as y from sales.emp) as a, dept as b where ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|AB_TABLES
argument_list|)
expr_stmt|;
comment|// note that we get hints even though there's a syntax error in
comment|// select clause ('t.')
name|sql
operator|=
literal|"select t. from (select 1 as x, 2 as y from (select x from sales.emp)) as t where ^"
expr_stmt|;
name|String
name|simplified
init|=
literal|"SELECT * FROM ( SELECT 0 AS x , 0 AS y FROM ( SELECT 0 AS x FROM sales.emp ) ) as t WHERE _suggest_"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|tTable
argument_list|,
name|xyColumns
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.x from (select 1 as x, 2 as y from sales.^) as t"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSalesTables
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSubQueryInWhere
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
comment|// Aliases from enclosing subqueries are inherited: hence A from
comment|// enclosing, B from same scope.
comment|// The raw columns from dept are suggested (because they can
comment|// be used unqualified in the inner scope) but the raw
comment|// columns from emp are not (because they would need to be qualified
comment|// with A).
name|sql
operator|=
literal|"select * from sales.emp a where deptno in ("
operator|+
literal|"select * from sales.dept b where ^)"
expr_stmt|;
name|String
name|simplifiedSql
init|=
literal|"SELECT * FROM sales.emp a WHERE deptno in ("
operator|+
literal|" SELECT * FROM sales.dept b WHERE _suggest_ )"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplifiedSql
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|AB_TABLES
argument_list|,
name|DEPT_COLUMNS
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParserTokenizer
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select"
operator|+
literal|" 12"
operator|+
literal|" "
operator|+
literal|"*"
operator|+
literal|" 1.23e45"
operator|+
literal|" "
operator|+
literal|"("
operator|+
literal|"\"an id\""
operator|+
literal|","
operator|+
literal|" "
operator|+
literal|"\"an id with \"\"quotes' inside\""
operator|+
literal|","
operator|+
literal|" "
operator|+
literal|"/* a comment, with 'quotes', over\nmultiple lines\nand select keyword */"
operator|+
literal|"\n "
operator|+
literal|"("
operator|+
literal|" "
operator|+
literal|"a"
operator|+
literal|" "
operator|+
literal|"different"
operator|+
literal|" "
operator|+
literal|"// comment\n\r"
operator|+
literal|"//and a comment /* containing comment */ and then some more\r"
operator|+
literal|")"
operator|+
literal|" "
operator|+
literal|"from"
operator|+
literal|" "
operator|+
literal|"t"
operator|+
literal|")"
operator|+
literal|")"
operator|+
literal|"/* a comment after close paren */"
operator|+
literal|" "
operator|+
literal|"("
operator|+
literal|"'quoted'"
operator|+
literal|" "
operator|+
literal|"'string with ''single and \"double\"\" quote'"
operator|+
literal|")"
decl_stmt|;
name|String
name|expected
init|=
literal|"SELECT\n"
operator|+
literal|"ID(12)\n"
operator|+
literal|"ID(*)\n"
operator|+
literal|"ID(1.23e45)\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"DQID(\"an id\")\n"
operator|+
literal|"COMMA\n"
operator|+
literal|"DQID(\"an id with \"\"quotes' inside\")\n"
operator|+
literal|"COMMA\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"ID(a)\n"
operator|+
literal|"ID(different)\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"FROM\n"
operator|+
literal|"ID(t)\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"RPAREN\n"
operator|+
literal|"COMMENT\n"
operator|+
literal|"LPAREN\n"
operator|+
literal|"SQID('quoted')\n"
operator|+
literal|"SQID('string with ''single and \"double\"\" quote')\n"
operator|+
literal|"RPAREN\n"
decl_stmt|;
name|assertTokenizesTo
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// Tokenizer should be lenient if input ends mid-token
name|assertTokenizesTo
argument_list|(
literal|"select /* unfinished comment"
argument_list|,
literal|"SELECT\nCOMMENT\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"select // unfinished comment"
argument_list|,
literal|"SELECT\nCOMMENT\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"'starts with string'"
argument_list|,
literal|"SQID('starts with string')\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"'unfinished string"
argument_list|,
literal|"SQID('unfinished string)\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"\"unfinished double-quoted id"
argument_list|,
literal|"DQID(\"unfinished double-quoted id)\n"
argument_list|)
expr_stmt|;
name|assertTokenizesTo
argument_list|(
literal|"123"
argument_list|,
literal|"ID(123)\n"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParser
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
name|String
name|expected
decl_stmt|;
comment|// from
name|sql
operator|=
literal|"select * from ^where"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// from
name|sql
operator|=
literal|"select a.empno, b.deptno from ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// select list
name|sql
operator|=
literal|"select ^ from (values (1))"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM ( values ( 1 ) )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select emp.^ from sales.emp"
expr_stmt|;
name|expected
operator|=
literal|"SELECT emp. _suggest_ FROM sales.emp"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^from sales.emp"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// remove other expressions in select clause
name|sql
operator|=
literal|"select a.empno ,^  from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^, a.empno from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select dummy, b.^ from sales.emp a , sales.dept b"
expr_stmt|;
name|expected
operator|=
literal|"SELECT b. _suggest_ FROM sales.emp a , sales.dept b"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join ^on where empno=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM dummy a JOIN _suggest_ ON TRUE"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// join
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a join sales.^ where empno=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM dummy a JOIN sales. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// on
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a join sales.dept b "
operator|+
literal|"on a.deptno=^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a JOIN sales.dept b "
operator|+
literal|"ON a.deptno= _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// where
name|sql
operator|=
literal|"select a.empno, b.deptno from sales.emp a, sales.dept b "
operator|+
literal|"where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a , sales.dept b WHERE _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// order by
name|sql
operator|=
literal|"select emp.empno from sales.emp where empno=1 order by ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT emp.empno FROM sales.emp ORDER BY _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// subquery in from
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales.emp) as t "
operator|+
literal|"where t.dummy=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT t. _suggest_ "
operator|+
literal|"FROM ( SELECT 0 AS x , 0 AS y FROM sales.emp ) as t"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t. from (select 1 as x, 2 as y from "
operator|+
literal|"(select x from sales.emp)) as t where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT 0 AS x , 0 AS y FROM "
operator|+
literal|"( SELECT 0 AS x FROM sales.emp ) ) as t WHERE _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select ^from (select 1 as x, 2 as y from sales.emp), "
operator|+
literal|"(select 2 as y from (select m from n where)) as t "
operator|+
literal|"where t.dummy=1"
expr_stmt|;
name|expected
operator|=
literal|"SELECT _suggest_ FROM ( SELECT 0 AS x , 0 AS y FROM sales.emp ) "
operator|+
literal|", ( SELECT 0 AS y FROM ( SELECT 0 AS m FROM n ) ) as t"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// Note: completes the missing close paren; wipes out select clause of
comment|// both outer and inner queries since not relevant.
name|sql
operator|=
literal|"select t.x from ( select 1 as x, 2 as y from sales.^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT * FROM sales. _suggest_ )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select t.^ from (select 1 as x, 2 as y from sales)"
expr_stmt|;
name|expected
operator|=
literal|"SELECT t. _suggest_ FROM ( SELECT 0 AS x , 0 AS y FROM sales )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// subquery in where; note that:
comment|// 1. removes the SELECT clause of subquery in WHERE clause;
comment|// 2. keeps SELECT clause of subquery in FROM clause;
comment|// 3. removes GROUP BY clause of subquery in FROM clause;
comment|// 4. removes SELECT clause of outer query.
name|sql
operator|=
literal|"select x + y + 32 from "
operator|+
literal|"(select 1 as x, 2 as y from sales group by invalid stuff) as t "
operator|+
literal|"where x in (select deptno from emp where foo + t.^< 10)"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM ( SELECT 0 AS x , 0 AS y FROM sales ) as t "
operator|+
literal|"WHERE x in ( SELECT * FROM emp WHERE foo + t. _suggest_< 10 )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// if hint is in FROM, can remove other members of FROM clause
name|sql
operator|=
literal|"select a.empno, b.deptno from dummy a, sales.^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// function
name|sql
operator|=
literal|"select count(1) from sales.emp a where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a WHERE _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"select count(1) from sales.emp a "
operator|+
literal|"where substring(a.^ FROM 3 for 6) = '1234'"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a "
operator|+
literal|"WHERE substring ( a. _suggest_ FROM 3 for 6 ) = '1234'"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// missing ')' following subquery
name|sql
operator|=
literal|"select * from sales.emp a where deptno in ("
operator|+
literal|"select * from sales.dept b where ^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM sales.emp a WHERE deptno in ("
operator|+
literal|" SELECT * FROM sales.dept b WHERE _suggest_ )"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// keyword embedded in single and double quoted string should be
comment|// ignored
name|sql
operator|=
literal|"select 'a cat from a king' as foobar, 1 / 2 \"where\" from t "
operator|+
literal|"group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"select /* here is from */ 'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// skip comments
name|sql
operator|=
literal|"select // here is from clause\n 'cat' as foobar, 1 as x from t group by t.^ order by 123"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t GROUP BY t. _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleParserQuotedId
parameter_list|()
block|{
name|String
name|sql
decl_stmt|;
name|String
name|expected
decl_stmt|;
comment|// unclosed double-quote
name|sql
operator|=
literal|"select * from t where \"^"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t WHERE _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// closed double-quote
name|sql
operator|=
literal|"select * from t where \"^\" and x = y"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t WHERE _suggest_ and x = y"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// closed double-quote containing extra stuff
name|sql
operator|=
literal|"select * from t where \"^foo\" and x = y"
expr_stmt|;
name|expected
operator|=
literal|"SELECT * FROM t WHERE _suggest_ and x = y"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPartialIdentifier
parameter_list|()
block|{
name|String
name|sql
init|=
literal|"select * from emp where e^ and emp.deptno = 10"
decl_stmt|;
specifier|final
name|String
name|expected
init|=
literal|"COLUMN(EMPNO)\n"
operator|+
literal|"COLUMN(ENAME)\n"
operator|+
literal|"KEYWORD(ELEMENT)\n"
operator|+
literal|"KEYWORD(EXISTS)\n"
operator|+
literal|"KEYWORD(EXP)\n"
operator|+
literal|"KEYWORD(EXTRACT)\n"
operator|+
literal|"TABLE(EMP)\n"
decl_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
literal|"e"
argument_list|)
expr_stmt|;
comment|// cursor in middle of word and at end
name|sql
operator|=
literal|"select * from emp where e^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|expected
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// longer completion
name|sql
operator|=
literal|"select * from emp where em^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// word after punctuation
name|sql
operator|=
literal|"select deptno,em^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// inside double-quotes, no terminating double-quote.
comment|// Only identifiers should be suggested (no keywords),
comment|// and suggestion should include double-quotes
name|sql
operator|=
literal|"select deptno,\"EM^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|)
expr_stmt|;
comment|// inside double-quotes, match is case-sensitive
name|sql
operator|=
literal|"select deptno,\"em^ from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|"\"em"
argument_list|)
expr_stmt|;
comment|// eat up following double-quote
name|sql
operator|=
literal|"select deptno,\"EM^ps\" from emp where 1+2<3+4"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|)
expr_stmt|;
comment|// closing double-quote is at very end of string
name|sql
operator|=
literal|"select * from emp where 5 = \"EM^xxx\""
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMPNO_EMP
argument_list|,
literal|"\"EM"
argument_list|)
expr_stmt|;
comment|// just before dot
name|sql
operator|=
literal|"select emp.^name from emp"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EMP_COLUMNS
argument_list|,
name|STAR_KEYWORD
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInsert
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|sql
decl_stmt|;
name|sql
operator|=
literal|"insert into emp(empno, mgr) select ^ from dept a"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|getSelectKeywords
argument_list|()
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|A_TABLE
argument_list|,
name|DEPT_COLUMNS
argument_list|,
name|SETOPS
argument_list|,
name|FETCH_OFFSET
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"insert into emp(empno, mgr) values (123, 3 + ^)"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|)
expr_stmt|;
comment|// Wish we could do better here. Parser gives error 'Non-query
comment|// expression encountered in illegal context' and cannot suggest
comment|// possible tokens.
name|sql
operator|=
literal|"insert into emp(empno, mgr) ^"
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUnion
parameter_list|()
throws|throws
name|Exception
block|{
comment|// we simplify set ops such as UNION by removing other queries -
comment|// thereby avoiding validation errors due to mismatched select lists
name|String
name|sql
init|=
literal|"select 1 from emp union select 2 from dept a where ^ and deptno< 5"
decl_stmt|;
name|String
name|simplified
init|=
literal|"SELECT * FROM dept a WHERE _suggest_ and deptno< 5"
decl_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
name|assertComplete
argument_list|(
name|sql
argument_list|,
name|EXPR_KEYWORDS
argument_list|,
name|A_TABLE
argument_list|,
name|DEPT_COLUMNS
argument_list|)
expr_stmt|;
comment|// UNION ALL
name|sql
operator|=
literal|"select 1 from emp union all select 2 from dept a where ^ and deptno< 5"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
comment|// hint is in first query
name|sql
operator|=
literal|"select 1 from emp group by ^ except select 2 from dept a"
expr_stmt|;
name|simplified
operator|=
literal|"SELECT * FROM emp GROUP BY _suggest_"
expr_stmt|;
name|assertSimplify
argument_list|(
name|sql
argument_list|,
name|simplified
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|AdvisorTesterFactory
extends|extends
name|DelegatingSqlTestFactory
block|{
specifier|public
name|AdvisorTesterFactory
parameter_list|()
block|{
name|super
argument_list|(
name|DefaultSqlTestFactory
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlValidator
name|getValidator
parameter_list|(
name|SqlTestFactory
name|factory
parameter_list|)
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
operator|new
name|SqlTypeFactoryImpl
argument_list|(
name|RelDataTypeSystem
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|SqlConformance
name|conformance
init|=
operator|(
name|SqlConformance
operator|)
name|get
argument_list|(
literal|"conformance"
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|caseSensitive
init|=
operator|(
name|Boolean
operator|)
name|factory
operator|.
name|get
argument_list|(
literal|"caseSensitive"
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlAdvisorValidator
argument_list|(
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
argument_list|,
operator|new
name|MockCatalogReader
argument_list|(
name|typeFactory
argument_list|,
name|caseSensitive
argument_list|)
operator|.
name|init
argument_list|()
argument_list|,
name|typeFactory
argument_list|,
name|conformance
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlAdvisor
name|createAdvisor
parameter_list|(
name|SqlValidatorWithHints
name|validator
parameter_list|)
block|{
return|return
operator|new
name|SqlAdvisor
argument_list|(
name|validator
argument_list|)
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End SqlAdvisorTest.java
end_comment

end_unit

