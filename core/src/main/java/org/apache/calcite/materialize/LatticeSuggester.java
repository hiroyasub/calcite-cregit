begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|materialize
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCostImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|FrameworkConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|CompositeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableNullableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|AttributedDirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|CycleDetector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultEdge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|TopologicalOrderIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|IntPair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_comment
comment|/**  * Algorithm that suggests a set of lattices.  */
end_comment

begin_class
specifier|public
class|class
name|LatticeSuggester
block|{
specifier|final
name|LatticeSpace
name|space
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HepProgram
name|PROGRAM
init|=
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|FilterJoinRule
operator|.
name|JOIN
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|/** Lattices, indexed by digest. Uses LinkedHashMap for determinacy. */
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Lattice
argument_list|>
name|latticeMap
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Lattices that have been made obsolete. Key is the obsolete lattice, value    * is the lattice that superseded it. */
specifier|private
specifier|final
name|Map
argument_list|<
name|Lattice
argument_list|,
name|Lattice
argument_list|>
name|obsoleteLatticeMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Whether to try to extend an existing lattice when adding a lattice. */
specifier|private
specifier|final
name|boolean
name|evolve
decl_stmt|;
comment|/** Creates a LatticeSuggester. */
specifier|public
name|LatticeSuggester
parameter_list|(
name|FrameworkConfig
name|config
parameter_list|)
block|{
name|this
operator|.
name|evolve
operator|=
name|config
operator|.
name|isEvolveLattice
argument_list|()
expr_stmt|;
name|space
operator|=
operator|new
name|LatticeSpace
argument_list|(
name|config
operator|.
name|getStatisticProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the minimal set of lattices necessary to cover all of the queries    * seen. Any lattices that are subsumed by other lattices are not included. */
specifier|public
name|Set
argument_list|<
name|Lattice
argument_list|>
name|getLatticeSet
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|Lattice
argument_list|>
name|set
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|latticeMap
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|set
operator|.
name|removeAll
argument_list|(
name|obsoleteLatticeMap
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|set
argument_list|)
return|;
block|}
comment|/** Adds a query.    *    *<p>It may fit within an existing lattice (or lattices). Or it may need a    * new lattice, or an extension to an existing lattice.    *    * @param r Relational expression for a query    *    * @return A list of join graphs: usually 1; more if the query contains a    * cartesian product; zero if the query graph is cyclic    */
specifier|public
name|List
argument_list|<
name|Lattice
argument_list|>
name|addQuery
parameter_list|(
name|RelNode
name|r
parameter_list|)
block|{
comment|// Push filters into joins and towards leaves
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
name|PROGRAM
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|RelOptCostImpl
operator|.
name|FACTORY
argument_list|)
decl_stmt|;
name|planner
operator|.
name|setRoot
argument_list|(
name|r
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|r2
init|=
name|planner
operator|.
name|findBestExp
argument_list|()
decl_stmt|;
specifier|final
name|Query
name|q
init|=
operator|new
name|Query
argument_list|(
name|space
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|frame
argument_list|(
name|q
argument_list|,
name|r2
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|null
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
specifier|final
name|AttributedDirectedGraph
argument_list|<
name|TableRef
argument_list|,
name|StepRef
argument_list|>
name|g
init|=
name|AttributedDirectedGraph
operator|.
name|create
argument_list|(
operator|new
name|StepRef
operator|.
name|Factory
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|Pair
argument_list|<
name|TableRef
argument_list|,
name|TableRef
argument_list|>
argument_list|,
name|IntPair
argument_list|>
name|map
init|=
name|LinkedListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|TableRef
name|tableRef
range|:
name|frame
operator|.
name|tableRefs
control|)
block|{
name|g
operator|.
name|addVertex
argument_list|(
name|tableRef
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Hop
name|hop
range|:
name|frame
operator|.
name|hops
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|hop
operator|.
name|source
operator|.
name|t
argument_list|,
name|hop
operator|.
name|target
operator|.
name|t
argument_list|)
argument_list|,
name|IntPair
operator|.
name|of
argument_list|(
name|hop
operator|.
name|source
operator|.
name|c
argument_list|,
name|hop
operator|.
name|target
operator|.
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Pair
argument_list|<
name|TableRef
argument_list|,
name|TableRef
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|IntPair
argument_list|>
argument_list|>
name|e
range|:
name|map
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|TableRef
name|source
init|=
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|left
decl_stmt|;
specifier|final
name|TableRef
name|target
init|=
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|right
decl_stmt|;
specifier|final
name|StepRef
name|stepRef
init|=
name|q
operator|.
name|stepRef
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|g
operator|.
name|addVertex
argument_list|(
name|stepRef
operator|.
name|source
argument_list|()
argument_list|)
expr_stmt|;
name|g
operator|.
name|addVertex
argument_list|(
name|stepRef
operator|.
name|target
argument_list|()
argument_list|)
expr_stmt|;
name|g
operator|.
name|addEdge
argument_list|(
name|stepRef
operator|.
name|source
argument_list|()
argument_list|,
name|stepRef
operator|.
name|target
argument_list|()
argument_list|,
name|stepRef
operator|.
name|step
argument_list|,
name|stepRef
operator|.
name|ordinalInQuery
argument_list|)
expr_stmt|;
block|}
comment|// If the join graph is cyclic, we can't use it.
specifier|final
name|Set
argument_list|<
name|TableRef
argument_list|>
name|cycles
init|=
operator|new
name|CycleDetector
argument_list|<>
argument_list|(
name|g
argument_list|)
operator|.
name|findCycles
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cycles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
comment|// Translate the query graph to mutable nodes
specifier|final
name|Map
argument_list|<
name|TableRef
argument_list|,
name|MutableNode
argument_list|>
name|nodes
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|List
argument_list|,
name|MutableNode
argument_list|>
name|nodesByParent
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableNode
argument_list|>
name|rootNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TableRef
name|tableRef
range|:
name|TopologicalOrderIterator
operator|.
name|of
argument_list|(
name|g
argument_list|)
control|)
block|{
specifier|final
name|List
argument_list|<
name|StepRef
argument_list|>
name|edges
init|=
name|g
operator|.
name|getInwardEdges
argument_list|(
name|tableRef
argument_list|)
decl_stmt|;
specifier|final
name|MutableNode
name|node
decl_stmt|;
switch|switch
condition|(
name|edges
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|node
operator|=
operator|new
name|MutableNode
argument_list|(
name|tableRef
operator|.
name|table
argument_list|)
expr_stmt|;
name|rootNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
specifier|final
name|StepRef
name|edge
init|=
name|edges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|MutableNode
name|parent
init|=
name|nodes
operator|.
name|get
argument_list|(
name|edge
operator|.
name|source
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
name|key
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|parent
argument_list|,
name|tableRef
operator|.
name|table
argument_list|,
name|edge
operator|.
name|step
operator|.
name|keys
argument_list|)
decl_stmt|;
specifier|final
name|MutableNode
name|existingNode
init|=
name|nodesByParent
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingNode
operator|==
literal|null
condition|)
block|{
name|node
operator|=
operator|new
name|MutableNode
argument_list|(
name|tableRef
operator|.
name|table
argument_list|,
name|parent
argument_list|,
name|edge
operator|.
name|step
argument_list|)
expr_stmt|;
name|nodesByParent
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|existingNode
expr_stmt|;
block|}
break|break;
default|default:
for|for
control|(
name|StepRef
name|edge2
range|:
name|edges
control|)
block|{
specifier|final
name|MutableNode
name|parent2
init|=
name|nodes
operator|.
name|get
argument_list|(
name|edge2
operator|.
name|source
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|MutableNode
name|node2
init|=
operator|new
name|MutableNode
argument_list|(
name|tableRef
operator|.
name|table
argument_list|,
name|parent2
argument_list|,
name|edge2
operator|.
name|step
argument_list|)
decl_stmt|;
name|parent2
operator|.
name|children
operator|.
name|add
argument_list|(
name|node2
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
literal|null
expr_stmt|;
break|break;
block|}
name|nodes
operator|.
name|put
argument_list|(
name|tableRef
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|// Transcribe the hierarchy of mutable nodes to immutable nodes
specifier|final
name|List
argument_list|<
name|Lattice
argument_list|>
name|lattices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|MutableNode
name|rootNode
range|:
name|rootNodes
control|)
block|{
if|if
condition|(
name|rootNode
operator|.
name|isCyclic
argument_list|()
condition|)
block|{
continue|continue;
block|}
specifier|final
name|CalciteSchema
name|rootSchema
init|=
name|CalciteSchema
operator|.
name|createRootSchema
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Lattice
operator|.
name|Builder
name|latticeBuilder
init|=
operator|new
name|Lattice
operator|.
name|Builder
argument_list|(
name|space
argument_list|,
name|rootSchema
argument_list|,
name|rootNode
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableNode
argument_list|>
name|flatNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|rootNode
operator|.
name|flatten
argument_list|(
name|flatNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|MutableMeasure
name|measure
range|:
name|frame
operator|.
name|measures
control|)
block|{
for|for
control|(
name|ColRef
name|arg
range|:
name|measure
operator|.
name|arguments
control|)
block|{
if|if
condition|(
name|arg
operator|==
literal|null
condition|)
block|{
comment|// Cannot handle expressions, e.g. "sum(x + 1)" yet
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
block|}
name|latticeBuilder
operator|.
name|addMeasure
argument_list|(
operator|new
name|Lattice
operator|.
name|Measure
argument_list|(
name|measure
operator|.
name|aggregate
argument_list|,
name|measure
operator|.
name|distinct
argument_list|,
name|measure
operator|.
name|name
argument_list|,
name|Lists
operator|.
name|transform
argument_list|(
name|measure
operator|.
name|arguments
argument_list|,
name|colRef
lambda|->
block|{
specifier|final
name|Lattice
operator|.
name|Column
name|column
decl_stmt|;
if|if
condition|(
name|colRef
operator|instanceof
name|BaseColRef
condition|)
block|{
specifier|final
name|BaseColRef
name|baseColRef
init|=
operator|(
name|BaseColRef
operator|)
name|colRef
decl_stmt|;
specifier|final
name|MutableNode
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|baseColRef
operator|.
name|t
argument_list|)
decl_stmt|;
specifier|final
name|int
name|table
init|=
name|flatNodes
operator|.
name|indexOf
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|column
operator|=
name|latticeBuilder
operator|.
name|column
argument_list|(
name|table
argument_list|,
name|baseColRef
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|colRef
operator|instanceof
name|DerivedColRef
condition|)
block|{
specifier|final
name|DerivedColRef
name|derivedColRef
init|=
operator|(
name|DerivedColRef
operator|)
name|colRef
decl_stmt|;
specifier|final
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|measure
argument_list|,
name|derivedColRef
argument_list|)
decl_stmt|;
name|column
operator|=
name|latticeBuilder
operator|.
name|expression
argument_list|(
name|derivedColRef
operator|.
name|e
argument_list|,
name|alias
argument_list|,
name|derivedColRef
operator|.
name|tableAliases
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"expression in measure"
argument_list|)
throw|;
block|}
name|latticeBuilder
operator|.
name|use
argument_list|(
name|column
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|column
return|;
block|}
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|frame
operator|.
name|columnCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ColRef
name|c
init|=
name|frame
operator|.
name|column
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|instanceof
name|DerivedColRef
condition|)
block|{
specifier|final
name|DerivedColRef
name|derivedColRef
init|=
operator|(
name|DerivedColRef
operator|)
name|c
decl_stmt|;
specifier|final
name|Lattice
operator|.
name|Column
name|expression
init|=
name|latticeBuilder
operator|.
name|expression
argument_list|(
name|derivedColRef
operator|.
name|e
argument_list|,
name|derivedColRef
operator|.
name|alias
argument_list|,
name|derivedColRef
operator|.
name|tableAliases
argument_list|()
argument_list|)
decl_stmt|;
name|latticeBuilder
operator|.
name|use
argument_list|(
name|expression
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Lattice
name|lattice0
init|=
name|latticeBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Lattice
name|lattice1
init|=
name|findMatch
argument_list|(
name|lattice0
argument_list|,
name|rootNode
argument_list|)
decl_stmt|;
name|lattices
operator|.
name|add
argument_list|(
name|lattice1
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|lattices
argument_list|)
return|;
block|}
comment|/** Derives the alias of an expression that is the argument to a measure.    *    *<p>For example, if the measure is called "sum_profit" and the aggregate    * function is "sum", returns "profit".    */
specifier|private
specifier|static
name|String
name|deriveAlias
parameter_list|(
name|MutableMeasure
name|measure
parameter_list|,
name|DerivedColRef
name|derivedColRef
parameter_list|)
block|{
if|if
condition|(
operator|!
name|derivedColRef
operator|.
name|alias
operator|.
name|contains
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
comment|// User specified an alias. Use that.
return|return
name|derivedColRef
operator|.
name|alias
return|;
block|}
name|String
name|alias
init|=
name|measure
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|alias
operator|.
name|contains
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
comment|// User did not specify an alias for the aggregate function, and it got a
comment|// system-generated name like 'EXPR$2'. Don't try to derive anything from
comment|// it.
return|return
name|derivedColRef
operator|.
name|alias
return|;
block|}
specifier|final
name|String
name|aggUpper
init|=
name|measure
operator|.
name|aggregate
operator|.
name|getName
argument_list|()
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
specifier|final
name|String
name|aliasUpper
init|=
name|alias
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliasUpper
operator|.
name|startsWith
argument_list|(
name|aggUpper
operator|+
literal|"_"
argument_list|)
condition|)
block|{
comment|// Convert "sum_profit" to "profit"
return|return
name|alias
operator|.
name|substring
argument_list|(
operator|(
name|aggUpper
operator|+
literal|"_"
operator|)
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|aliasUpper
operator|.
name|startsWith
argument_list|(
name|aggUpper
argument_list|)
condition|)
block|{
comment|// Convert "sumprofit" to "profit"
return|return
name|alias
operator|.
name|substring
argument_list|(
name|aggUpper
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|aliasUpper
operator|.
name|endsWith
argument_list|(
literal|"_"
operator|+
name|aggUpper
argument_list|)
condition|)
block|{
comment|// Convert "profit_sum" to "profit"
return|return
name|alias
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|alias
operator|.
name|length
argument_list|()
operator|-
operator|(
literal|"_"
operator|+
name|aggUpper
operator|)
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|aliasUpper
operator|.
name|endsWith
argument_list|(
name|aggUpper
argument_list|)
condition|)
block|{
comment|// Convert "profitsum" to "profit"
return|return
name|alias
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|alias
operator|.
name|length
argument_list|()
operator|-
name|aggUpper
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|alias
return|;
block|}
block|}
comment|/** Returns the best match for a lattice. If no match, registers the lattice    * and returns it. Never returns null. */
specifier|private
name|Lattice
name|findMatch
parameter_list|(
specifier|final
name|Lattice
name|lattice
parameter_list|,
name|MutableNode
name|mutableNode
parameter_list|)
block|{
specifier|final
name|Lattice
name|lattice1
init|=
name|latticeMap
operator|.
name|get
argument_list|(
name|lattice
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lattice1
operator|!=
literal|null
condition|)
block|{
comment|// Exact match for an existing lattice
return|return
name|lattice1
return|;
block|}
if|if
condition|(
name|evolve
condition|)
block|{
comment|// No exact match. Scan existing lattices for a sub-set.
name|int
name|bestMatchQuality
init|=
literal|0
decl_stmt|;
name|Lattice
name|bestMatch
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Lattice
name|lattice2
range|:
name|latticeMap
operator|.
name|values
argument_list|()
control|)
block|{
name|int
name|q
init|=
name|matchQuality
argument_list|(
name|lattice2
argument_list|,
name|lattice
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|>
name|bestMatchQuality
condition|)
block|{
name|bestMatch
operator|=
name|lattice2
expr_stmt|;
name|bestMatchQuality
operator|=
name|q
expr_stmt|;
block|}
if|else if
condition|(
name|q
operator|==
name|bestMatchQuality
operator|&&
name|bestMatch
operator|!=
literal|null
operator|&&
operator|!
name|lattice2
operator|.
name|rootNode
operator|.
name|paths
operator|.
name|equals
argument_list|(
name|bestMatch
operator|.
name|rootNode
operator|.
name|paths
argument_list|)
operator|&&
name|lattice2
operator|.
name|rootNode
operator|.
name|paths
operator|.
name|containsAll
argument_list|(
name|bestMatch
operator|.
name|rootNode
operator|.
name|paths
argument_list|)
condition|)
block|{
name|bestMatch
operator|=
name|lattice2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bestMatch
operator|!=
literal|null
condition|)
block|{
comment|// Fix up the best batch
for|for
control|(
name|Path
name|path
range|:
name|minus
argument_list|(
name|bestMatch
operator|.
name|rootNode
operator|.
name|paths
argument_list|,
name|lattice
operator|.
name|rootNode
operator|.
name|paths
argument_list|)
control|)
block|{
comment|// TODO: assign alias based on node in bestMatch
name|mutableNode
operator|.
name|addPath
argument_list|(
name|path
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CalciteSchema
name|rootSchema
init|=
name|CalciteSchema
operator|.
name|createRootSchema
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|Lattice
operator|.
name|Builder
name|builder
init|=
operator|new
name|Lattice
operator|.
name|Builder
argument_list|(
name|space
argument_list|,
name|rootSchema
argument_list|,
name|mutableNode
argument_list|)
decl_stmt|;
name|copyMeasures
argument_list|(
name|builder
argument_list|,
name|bestMatch
argument_list|)
expr_stmt|;
name|copyMeasures
argument_list|(
name|builder
argument_list|,
name|lattice
argument_list|)
expr_stmt|;
specifier|final
name|Lattice
name|lattice2
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
name|latticeMap
operator|.
name|remove
argument_list|(
name|bestMatch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|obsoleteLatticeMap
operator|.
name|put
argument_list|(
name|bestMatch
argument_list|,
name|lattice2
argument_list|)
expr_stmt|;
name|latticeMap
operator|.
name|put
argument_list|(
name|lattice2
operator|.
name|toString
argument_list|()
argument_list|,
name|lattice2
argument_list|)
expr_stmt|;
return|return
name|lattice2
return|;
block|}
block|}
comment|// No suitable existing lattice. Register this one.
name|latticeMap
operator|.
name|put
argument_list|(
name|lattice
operator|.
name|toString
argument_list|()
argument_list|,
name|lattice
argument_list|)
expr_stmt|;
return|return
name|lattice
return|;
block|}
comment|/** Copies measures and column usages from an existing lattice into a builder,    * using a mapper to translate old-to-new columns, so that the new lattice can    * inherit from the old. */
specifier|private
name|void
name|copyMeasures
parameter_list|(
name|Lattice
operator|.
name|Builder
name|builder
parameter_list|,
name|Lattice
name|lattice
parameter_list|)
block|{
specifier|final
name|Function
argument_list|<
name|Lattice
operator|.
name|Column
argument_list|,
name|Lattice
operator|.
name|Column
argument_list|>
name|mapper
init|=
parameter_list|(
name|Lattice
operator|.
name|Column
name|c
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|c
operator|instanceof
name|Lattice
operator|.
name|BaseColumn
condition|)
block|{
name|Lattice
operator|.
name|BaseColumn
name|baseColumn
init|=
operator|(
name|Lattice
operator|.
name|BaseColumn
operator|)
name|c
decl_stmt|;
name|Pair
argument_list|<
name|Path
argument_list|,
name|Integer
argument_list|>
name|p
init|=
name|lattice
operator|.
name|columnToPathOffset
argument_list|(
name|baseColumn
argument_list|)
decl_stmt|;
return|return
name|builder
operator|.
name|pathOffsetToColumn
argument_list|(
name|p
operator|.
name|left
argument_list|,
name|p
operator|.
name|right
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|Lattice
operator|.
name|DerivedColumn
name|derivedColumn
init|=
operator|(
name|Lattice
operator|.
name|DerivedColumn
operator|)
name|c
decl_stmt|;
return|return
name|builder
operator|.
name|expression
argument_list|(
name|derivedColumn
operator|.
name|e
argument_list|,
name|derivedColumn
operator|.
name|alias
argument_list|,
name|derivedColumn
operator|.
name|tables
argument_list|)
return|;
block|}
block|}
decl_stmt|;
for|for
control|(
name|Lattice
operator|.
name|Measure
name|measure
range|:
name|lattice
operator|.
name|defaultMeasures
control|)
block|{
name|builder
operator|.
name|addMeasure
argument_list|(
name|measure
operator|.
name|copy
argument_list|(
name|mapper
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Boolean
argument_list|>
name|entry
range|:
name|lattice
operator|.
name|columnUses
operator|.
name|entries
argument_list|()
control|)
block|{
specifier|final
name|Lattice
operator|.
name|Column
name|column
init|=
name|lattice
operator|.
name|columns
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|builder
operator|.
name|use
argument_list|(
name|mapper
operator|.
name|apply
argument_list|(
name|column
argument_list|)
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|matchQuality
parameter_list|(
name|Lattice
name|lattice
parameter_list|,
name|Lattice
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lattice
operator|.
name|rootNode
operator|.
name|table
operator|.
name|equals
argument_list|(
name|target
operator|.
name|rootNode
operator|.
name|table
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|lattice
operator|.
name|rootNode
operator|.
name|paths
operator|.
name|equals
argument_list|(
name|target
operator|.
name|rootNode
operator|.
name|paths
argument_list|)
condition|)
block|{
return|return
literal|3
return|;
block|}
if|if
condition|(
name|lattice
operator|.
name|rootNode
operator|.
name|paths
operator|.
name|containsAll
argument_list|(
name|target
operator|.
name|rootNode
operator|.
name|paths
argument_list|)
condition|)
block|{
return|return
literal|2
return|;
block|}
return|return
literal|1
return|;
block|}
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|Set
argument_list|<
name|E
argument_list|>
name|minus
parameter_list|(
name|Collection
argument_list|<
name|E
argument_list|>
name|c
parameter_list|,
name|Collection
argument_list|<
name|E
argument_list|>
name|c2
parameter_list|)
block|{
specifier|final
name|LinkedHashSet
argument_list|<
name|E
argument_list|>
name|c3
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|c3
operator|.
name|removeAll
argument_list|(
name|c2
argument_list|)
expr_stmt|;
return|return
name|c3
return|;
block|}
specifier|private
name|Frame
name|frame
parameter_list|(
specifier|final
name|Query
name|q
parameter_list|,
name|RelNode
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|Sort
condition|)
block|{
specifier|final
name|Sort
name|sort
init|=
operator|(
name|Sort
operator|)
name|r
decl_stmt|;
return|return
name|frame
argument_list|(
name|q
argument_list|,
name|sort
operator|.
name|getInput
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|r
operator|instanceof
name|Filter
condition|)
block|{
specifier|final
name|Filter
name|filter
init|=
operator|(
name|Filter
operator|)
name|r
decl_stmt|;
return|return
name|frame
argument_list|(
name|q
argument_list|,
name|filter
operator|.
name|getInput
argument_list|()
argument_list|)
return|;
block|}
if|else if
condition|(
name|r
operator|instanceof
name|Aggregate
condition|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|r
decl_stmt|;
specifier|final
name|Frame
name|h
init|=
name|frame
argument_list|(
name|q
argument_list|,
name|aggregate
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|MutableMeasure
argument_list|>
name|measures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|call
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
name|measures
operator|.
name|add
argument_list|(
operator|new
name|MutableMeasure
argument_list|(
name|call
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|call
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|Util
operator|.
name|transform
argument_list|(
name|call
operator|.
name|getArgList
argument_list|()
argument_list|,
name|h
operator|::
name|column
argument_list|)
argument_list|,
name|call
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|fieldCount
init|=
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
return|return
operator|new
name|Frame
argument_list|(
name|fieldCount
argument_list|,
name|h
operator|.
name|hops
argument_list|,
name|measures
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|h
argument_list|)
argument_list|)
block|{
name|ColRef
name|column
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|<
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
condition|)
block|{
return|return
name|h
operator|.
name|column
argument_list|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
comment|// an aggregate function; no direct mapping
block|}
block|}
return|;
block|}
if|else if
condition|(
name|r
operator|instanceof
name|Project
condition|)
block|{
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|r
decl_stmt|;
specifier|final
name|Frame
name|h
init|=
name|frame
argument_list|(
name|q
argument_list|,
name|project
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|fieldCount
init|=
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
return|return
operator|new
name|Frame
argument_list|(
name|fieldCount
argument_list|,
name|h
operator|.
name|hops
argument_list|,
name|h
operator|.
name|measures
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|h
argument_list|)
argument_list|)
block|{
specifier|final
name|List
argument_list|<
name|ColRef
argument_list|>
name|columns
decl_stmt|;
block|{
specifier|final
name|ImmutableNullableList
operator|.
name|Builder
argument_list|<
name|ColRef
argument_list|>
name|columnBuilder
init|=
name|ImmutableNullableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|p
range|:
name|project
operator|.
name|getNamedProjects
argument_list|()
control|)
block|{
name|columnBuilder
operator|.
name|add
argument_list|(
name|toColRef
argument_list|(
name|p
operator|.
name|left
argument_list|,
name|p
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|columns
operator|=
name|columnBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|ColRef
name|column
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
return|return
name|columns
operator|.
name|get
argument_list|(
name|offset
argument_list|)
return|;
block|}
comment|/** Converts an expression to a base or derived column reference.          * The alias is optional, but if the derived column reference becomes          * a dimension or measure, the alias will be used to choose a name. */
specifier|private
name|ColRef
name|toColRef
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
return|return
name|h
operator|.
name|column
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|e
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
specifier|final
name|ImmutableBitSet
name|bits
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|TableRef
argument_list|>
name|tableRefs
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
comment|// offset within lattice of first column in a table
for|for
control|(
name|TableRef
name|tableRef
range|:
name|h
operator|.
name|tableRefs
control|)
block|{
specifier|final
name|int
name|prev
init|=
name|c
decl_stmt|;
name|c
operator|+=
name|tableRef
operator|.
name|table
operator|.
name|t
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|bits
operator|.
name|intersects
argument_list|(
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|prev
argument_list|,
name|c
argument_list|)
argument_list|)
condition|)
block|{
name|tableRefs
operator|.
name|add
argument_list|(
name|tableRef
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|DerivedColRef
argument_list|(
name|tableRefs
operator|.
name|build
argument_list|()
argument_list|,
name|e
argument_list|,
name|alias
argument_list|)
return|;
block|}
block|}
return|;
block|}
if|else if
condition|(
name|r
operator|instanceof
name|Join
condition|)
block|{
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|r
decl_stmt|;
specifier|final
name|int
name|leftCount
init|=
name|join
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|left
init|=
name|frame
argument_list|(
name|q
argument_list|,
name|join
operator|.
name|getLeft
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Frame
name|right
init|=
name|frame
argument_list|(
name|q
argument_list|,
name|join
operator|.
name|getRight
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|==
literal|null
operator|||
name|right
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Hop
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addAll
argument_list|(
name|left
operator|.
name|hops
argument_list|)
expr_stmt|;
for|for
control|(
name|IntPair
name|p
range|:
name|join
operator|.
name|analyzeCondition
argument_list|()
operator|.
name|pairs
argument_list|()
control|)
block|{
specifier|final
name|ColRef
name|source
init|=
name|left
operator|.
name|column
argument_list|(
name|p
operator|.
name|source
argument_list|)
decl_stmt|;
specifier|final
name|ColRef
name|target
init|=
name|right
operator|.
name|column
argument_list|(
name|p
operator|.
name|target
argument_list|)
decl_stmt|;
assert|assert
name|source
operator|instanceof
name|BaseColRef
assert|;
assert|assert
name|target
operator|instanceof
name|BaseColRef
assert|;
name|builder
operator|.
name|add
argument_list|(
operator|new
name|Hop
argument_list|(
operator|(
name|BaseColRef
operator|)
name|source
argument_list|,
operator|(
name|BaseColRef
operator|)
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|addAll
argument_list|(
name|right
operator|.
name|hops
argument_list|)
expr_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
return|return
operator|new
name|Frame
argument_list|(
name|fieldCount
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|,
name|CompositeList
operator|.
name|of
argument_list|(
name|left
operator|.
name|measures
argument_list|,
name|right
operator|.
name|measures
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
block|{
name|ColRef
name|column
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|<
name|leftCount
condition|)
block|{
return|return
name|left
operator|.
name|column
argument_list|(
name|offset
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|right
operator|.
name|column
argument_list|(
name|offset
operator|-
name|leftCount
argument_list|)
return|;
block|}
block|}
block|}
return|;
block|}
if|else if
condition|(
name|r
operator|instanceof
name|TableScan
condition|)
block|{
specifier|final
name|TableScan
name|scan
init|=
operator|(
name|TableScan
operator|)
name|r
decl_stmt|;
specifier|final
name|TableRef
name|tableRef
init|=
name|q
operator|.
name|tableRef
argument_list|(
name|scan
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
return|return
operator|new
name|Frame
argument_list|(
name|fieldCount
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|tableRef
argument_list|)
argument_list|)
block|{
name|ColRef
name|column
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>=
name|scan
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"field "
operator|+
name|offset
operator|+
literal|" out of range in "
operator|+
name|scan
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|BaseColRef
argument_list|(
name|tableRef
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Holds state for a particular query graph. In particular table and step    * references count from zero each query. */
specifier|private
specifier|static
class|class
name|Query
block|{
specifier|final
name|LatticeSpace
name|space
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|TableRef
argument_list|>
name|tableRefs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|stepRefCount
init|=
literal|0
decl_stmt|;
name|Query
parameter_list|(
name|LatticeSpace
name|space
parameter_list|)
block|{
name|this
operator|.
name|space
operator|=
name|space
expr_stmt|;
block|}
name|TableRef
name|tableRef
parameter_list|(
name|TableScan
name|scan
parameter_list|)
block|{
specifier|final
name|TableRef
name|r
init|=
name|tableRefs
operator|.
name|get
argument_list|(
name|scan
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
return|return
name|r
return|;
block|}
specifier|final
name|LatticeTable
name|t
init|=
name|space
operator|.
name|register
argument_list|(
name|scan
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|TableRef
name|r2
init|=
operator|new
name|TableRef
argument_list|(
name|t
argument_list|,
name|tableRefs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|tableRefs
operator|.
name|put
argument_list|(
name|scan
operator|.
name|getId
argument_list|()
argument_list|,
name|r2
argument_list|)
expr_stmt|;
return|return
name|r2
return|;
block|}
name|StepRef
name|stepRef
parameter_list|(
name|TableRef
name|source
parameter_list|,
name|TableRef
name|target
parameter_list|,
name|List
argument_list|<
name|IntPair
argument_list|>
name|keys
parameter_list|)
block|{
name|keys
operator|=
name|LatticeSpace
operator|.
name|sortUnique
argument_list|(
name|keys
argument_list|)
expr_stmt|;
specifier|final
name|Step
name|h
init|=
operator|new
name|Step
argument_list|(
name|source
operator|.
name|table
argument_list|,
name|target
operator|.
name|table
argument_list|,
name|keys
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|.
name|isBackwards
argument_list|(
name|space
operator|.
name|statisticProvider
argument_list|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|IntPair
argument_list|>
name|keys1
init|=
name|LatticeSpace
operator|.
name|swap
argument_list|(
name|h
operator|.
name|keys
argument_list|)
decl_stmt|;
specifier|final
name|Step
name|h2
init|=
name|space
operator|.
name|addEdge
argument_list|(
name|h
operator|.
name|target
argument_list|()
argument_list|,
name|h
operator|.
name|source
argument_list|()
argument_list|,
name|keys1
argument_list|)
decl_stmt|;
return|return
operator|new
name|StepRef
argument_list|(
name|target
argument_list|,
name|source
argument_list|,
name|h2
argument_list|,
name|stepRefCount
operator|++
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|Step
name|h2
init|=
name|space
operator|.
name|addEdge
argument_list|(
name|h
operator|.
name|source
argument_list|()
argument_list|,
name|h
operator|.
name|target
argument_list|()
argument_list|,
name|h
operator|.
name|keys
argument_list|)
decl_stmt|;
return|return
operator|new
name|StepRef
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|h2
argument_list|,
name|stepRefCount
operator|++
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Information about the parent of fields from a relational expression. */
specifier|abstract
specifier|static
class|class
name|Frame
block|{
specifier|final
name|List
argument_list|<
name|Hop
argument_list|>
name|hops
decl_stmt|;
specifier|final
name|List
argument_list|<
name|MutableMeasure
argument_list|>
name|measures
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|TableRef
argument_list|>
name|tableRefs
decl_stmt|;
specifier|final
name|int
name|columnCount
decl_stmt|;
name|Frame
parameter_list|(
name|int
name|columnCount
parameter_list|,
name|List
argument_list|<
name|Hop
argument_list|>
name|hops
parameter_list|,
name|List
argument_list|<
name|MutableMeasure
argument_list|>
name|measures
parameter_list|,
name|Collection
argument_list|<
name|TableRef
argument_list|>
name|tableRefs
parameter_list|)
block|{
name|this
operator|.
name|hops
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|hops
argument_list|)
expr_stmt|;
name|this
operator|.
name|measures
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|measures
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableRefs
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|tableRefs
argument_list|)
expr_stmt|;
name|this
operator|.
name|columnCount
operator|=
name|columnCount
expr_stmt|;
block|}
name|Frame
parameter_list|(
name|int
name|columnCount
parameter_list|,
name|List
argument_list|<
name|Hop
argument_list|>
name|hops
parameter_list|,
name|List
argument_list|<
name|MutableMeasure
argument_list|>
name|measures
parameter_list|,
name|List
argument_list|<
name|Frame
argument_list|>
name|inputs
parameter_list|)
block|{
name|this
argument_list|(
name|columnCount
argument_list|,
name|hops
argument_list|,
name|measures
argument_list|,
name|collectTableRefs
argument_list|(
name|inputs
argument_list|,
name|hops
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|abstract
name|ColRef
name|column
parameter_list|(
name|int
name|offset
parameter_list|)
function_decl|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Frame("
operator|+
name|hops
operator|+
literal|")"
return|;
block|}
specifier|static
name|Set
argument_list|<
name|TableRef
argument_list|>
name|collectTableRefs
parameter_list|(
name|List
argument_list|<
name|Frame
argument_list|>
name|inputs
parameter_list|,
name|List
argument_list|<
name|Hop
argument_list|>
name|hops
parameter_list|)
block|{
specifier|final
name|LinkedHashSet
argument_list|<
name|TableRef
argument_list|>
name|set
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Hop
name|hop
range|:
name|hops
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|hop
operator|.
name|source
operator|.
name|t
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
name|hop
operator|.
name|target
operator|.
name|t
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Frame
name|frame
range|:
name|inputs
control|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|frame
operator|.
name|tableRefs
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
block|}
comment|/** Use of a table within a query. A table can be used more than once. */
specifier|private
specifier|static
class|class
name|TableRef
block|{
specifier|final
name|LatticeTable
name|table
decl_stmt|;
specifier|private
specifier|final
name|int
name|ordinalInQuery
decl_stmt|;
specifier|private
name|TableRef
parameter_list|(
name|LatticeTable
name|table
parameter_list|,
name|int
name|ordinalInQuery
parameter_list|)
block|{
name|this
operator|.
name|table
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|this
operator|.
name|ordinalInQuery
operator|=
name|ordinalInQuery
expr_stmt|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|ordinalInQuery
return|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|this
operator|==
name|obj
operator|||
name|obj
operator|instanceof
name|TableRef
operator|&&
name|ordinalInQuery
operator|==
operator|(
operator|(
name|TableRef
operator|)
name|obj
operator|)
operator|.
name|ordinalInQuery
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|table
operator|+
literal|":"
operator|+
name|ordinalInQuery
return|;
block|}
block|}
comment|/** Use of a step within a query. A step can be used more than once. */
specifier|private
specifier|static
class|class
name|StepRef
extends|extends
name|DefaultEdge
block|{
specifier|final
name|Step
name|step
decl_stmt|;
specifier|private
specifier|final
name|int
name|ordinalInQuery
decl_stmt|;
name|StepRef
parameter_list|(
name|TableRef
name|source
parameter_list|,
name|TableRef
name|target
parameter_list|,
name|Step
name|step
parameter_list|,
name|int
name|ordinalInQuery
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|this
operator|.
name|step
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|step
argument_list|)
expr_stmt|;
name|this
operator|.
name|ordinalInQuery
operator|=
name|ordinalInQuery
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|ordinalInQuery
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|this
operator|==
name|obj
operator|||
name|obj
operator|instanceof
name|StepRef
operator|&&
operator|(
operator|(
name|StepRef
operator|)
name|obj
operator|)
operator|.
name|ordinalInQuery
operator|==
name|ordinalInQuery
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
literal|"StepRef("
argument_list|)
operator|.
name|append
argument_list|(
name|source
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|target
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|IntPair
name|key
range|:
name|step
operator|.
name|keys
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
operator|.
name|append
argument_list|(
name|step
operator|.
name|source
argument_list|()
operator|.
name|field
argument_list|(
name|key
operator|.
name|source
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
operator|.
name|append
argument_list|(
name|step
operator|.
name|target
argument_list|()
operator|.
name|field
argument_list|(
name|key
operator|.
name|target
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|append
argument_list|(
literal|"):"
argument_list|)
operator|.
name|append
argument_list|(
name|ordinalInQuery
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
name|TableRef
name|source
parameter_list|()
block|{
return|return
operator|(
name|TableRef
operator|)
name|source
return|;
block|}
name|TableRef
name|target
parameter_list|()
block|{
return|return
operator|(
name|TableRef
operator|)
name|target
return|;
block|}
comment|/** Creates {@link StepRef} instances. */
specifier|private
specifier|static
class|class
name|Factory
implements|implements
name|AttributedDirectedGraph
operator|.
name|AttributedEdgeFactory
argument_list|<
name|TableRef
argument_list|,
name|StepRef
argument_list|>
block|{
specifier|public
name|StepRef
name|createEdge
parameter_list|(
name|TableRef
name|source
parameter_list|,
name|TableRef
name|target
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|StepRef
name|createEdge
parameter_list|(
name|TableRef
name|source
parameter_list|,
name|TableRef
name|target
parameter_list|,
name|Object
modifier|...
name|attributes
parameter_list|)
block|{
specifier|final
name|Step
name|step
init|=
operator|(
name|Step
operator|)
name|attributes
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|Integer
name|ordinalInQuery
init|=
operator|(
name|Integer
operator|)
name|attributes
index|[
literal|1
index|]
decl_stmt|;
return|return
operator|new
name|StepRef
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|step
argument_list|,
name|ordinalInQuery
argument_list|)
return|;
block|}
block|}
block|}
comment|/** A hop is a join condition. One or more hops between the same source and    * target combine to form a {@link Step}.    *    *<p>The tables are registered but the step is not. After we have gathered    * several join conditions we may discover that the keys are composite: e.g.    *    *<blockquote>    *<pre>    *     x.a = y.a    *     AND x.b = z.b    *     AND x.c = y.c    *</pre>    *</blockquote>    *    *<p>has 3 semi-hops:    *    *<ul>    *<li>x.a = y.a    *<li>x.b = z.b    *<li>x.c = y.c    *</ul>    *    *<p>which turn into 2 steps, the first of which is composite:    *    *<ul>    *<li>x.[a, c] = y.[a, c]    *<li>x.b = z.b    *</ul>    */
specifier|private
specifier|static
class|class
name|Hop
block|{
specifier|final
name|BaseColRef
name|source
decl_stmt|;
specifier|final
name|BaseColRef
name|target
decl_stmt|;
specifier|private
name|Hop
parameter_list|(
name|BaseColRef
name|source
parameter_list|,
name|BaseColRef
name|target
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
block|}
block|}
comment|/** Column reference. */
specifier|private
specifier|abstract
specifier|static
class|class
name|ColRef
block|{   }
comment|/** Reference to a base column. */
specifier|private
specifier|static
class|class
name|BaseColRef
extends|extends
name|ColRef
block|{
specifier|final
name|TableRef
name|t
decl_stmt|;
specifier|final
name|int
name|c
decl_stmt|;
specifier|private
name|BaseColRef
parameter_list|(
name|TableRef
name|t
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|this
operator|.
name|t
operator|=
name|t
expr_stmt|;
name|this
operator|.
name|c
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/** Reference to a derived column (that is, an expression). */
specifier|private
specifier|static
class|class
name|DerivedColRef
extends|extends
name|ColRef
block|{
annotation|@
name|Nonnull
specifier|final
name|List
argument_list|<
name|TableRef
argument_list|>
name|tableRefs
decl_stmt|;
annotation|@
name|Nonnull
specifier|final
name|RexNode
name|e
decl_stmt|;
specifier|final
name|String
name|alias
decl_stmt|;
specifier|private
name|DerivedColRef
parameter_list|(
name|Iterable
argument_list|<
name|TableRef
argument_list|>
name|tableRefs
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|tableRefs
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableRefs
argument_list|)
expr_stmt|;
name|this
operator|.
name|e
operator|=
name|e
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|tableAliases
parameter_list|()
block|{
return|return
name|Util
operator|.
name|transform
argument_list|(
name|tableRefs
argument_list|,
name|tableRef
lambda|->
name|tableRef
operator|.
name|table
operator|.
name|alias
argument_list|)
return|;
block|}
block|}
comment|/** An aggregate call. Becomes a measure in the final lattice. */
specifier|private
specifier|static
class|class
name|MutableMeasure
block|{
specifier|final
name|SqlAggFunction
name|aggregate
decl_stmt|;
specifier|final
name|boolean
name|distinct
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ColRef
argument_list|>
name|arguments
decl_stmt|;
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
name|MutableMeasure
parameter_list|(
name|SqlAggFunction
name|aggregate
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|List
argument_list|<
name|ColRef
argument_list|>
name|arguments
parameter_list|,
annotation|@
name|Nullable
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|aggregate
operator|=
name|aggregate
expr_stmt|;
name|this
operator|.
name|arguments
operator|=
name|arguments
expr_stmt|;
name|this
operator|.
name|distinct
operator|=
name|distinct
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End LatticeSuggester.java
end_comment

end_unit

