begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|materialize
package|;
end_package

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|Schemas
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|MaterializedViewTable
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|impl
operator|.
name|StarTable
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|OptiqPrepare
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|jdbc
operator|.
name|OptiqSchema
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|prepare
operator|.
name|OptiqPrepareImpl
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|runtime
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|graph
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|IntPair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Structure that allows materialized views based upon a star schema to be  * recognized and recommended.  */
end_comment

begin_class
specifier|public
class|class
name|Lattice
block|{
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Column
argument_list|,
name|String
argument_list|>
name|GET_ALIAS
init|=
operator|new
name|Function
argument_list|<
name|Column
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|String
name|apply
parameter_list|(
name|Column
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|alias
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|Column
argument_list|,
name|Integer
argument_list|>
name|GET_ORDINAL
init|=
operator|new
name|Function
argument_list|<
name|Column
argument_list|,
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|Integer
name|apply
parameter_list|(
name|Column
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|ordinal
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Node
argument_list|>
name|nodes
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|columns
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|auto
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|algorithm
decl_stmt|;
specifier|public
specifier|final
name|long
name|algorithmMaxMillis
decl_stmt|;
specifier|public
specifier|final
name|double
name|rowCountEstimate
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Measure
argument_list|>
name|defaultMeasures
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Tile
argument_list|>
name|tiles
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|String
argument_list|>
name|uniqueColumnNames
decl_stmt|;
specifier|private
specifier|final
name|Function
argument_list|<
name|Integer
argument_list|,
name|Column
argument_list|>
name|toColumnFunction
init|=
operator|new
name|Function
argument_list|<
name|Integer
argument_list|,
name|Column
argument_list|>
argument_list|()
block|{
specifier|public
name|Column
name|apply
parameter_list|(
name|Integer
name|input
parameter_list|)
block|{
return|return
name|columns
operator|.
name|get
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|Function
argument_list|<
name|AggregateCall
argument_list|,
name|Measure
argument_list|>
name|toMeasureFunction
init|=
operator|new
name|Function
argument_list|<
name|AggregateCall
argument_list|,
name|Measure
argument_list|>
argument_list|()
block|{
specifier|public
name|Measure
name|apply
parameter_list|(
name|AggregateCall
name|input
parameter_list|)
block|{
return|return
operator|new
name|Measure
argument_list|(
name|input
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|Lists
operator|.
name|transform
argument_list|(
name|input
operator|.
name|getArgList
argument_list|()
argument_list|,
name|toColumnFunction
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|private
name|Lattice
parameter_list|(
name|ImmutableList
argument_list|<
name|Node
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|auto
parameter_list|,
name|boolean
name|algorithm
parameter_list|,
name|long
name|algorithmMaxMillis
parameter_list|,
name|Double
name|rowCountEstimate
parameter_list|,
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|columns
parameter_list|,
name|ImmutableList
argument_list|<
name|Measure
argument_list|>
name|defaultMeasures
parameter_list|,
name|ImmutableList
argument_list|<
name|Tile
argument_list|>
name|tiles
parameter_list|)
block|{
name|this
operator|.
name|nodes
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|this
operator|.
name|columns
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|columns
argument_list|)
expr_stmt|;
name|this
operator|.
name|auto
operator|=
name|auto
expr_stmt|;
name|this
operator|.
name|algorithm
operator|=
name|algorithm
expr_stmt|;
name|this
operator|.
name|algorithmMaxMillis
operator|=
name|algorithmMaxMillis
expr_stmt|;
name|this
operator|.
name|defaultMeasures
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|defaultMeasures
argument_list|)
expr_stmt|;
name|this
operator|.
name|tiles
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
comment|// Validate that nodes form a tree; each node except the first references
comment|// a predecessor.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
assert|assert
name|node
operator|.
name|parent
operator|==
literal|null
assert|;
block|}
else|else
block|{
assert|assert
name|nodes
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
operator|.
name|contains
argument_list|(
name|node
operator|.
name|parent
argument_list|)
assert|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Column
name|column
range|:
name|columns
control|)
block|{
name|nameList
operator|.
name|add
argument_list|(
name|column
operator|.
name|alias
argument_list|)
expr_stmt|;
block|}
name|uniqueColumnNames
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|columns
argument_list|,
name|GET_ALIAS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowCountEstimate
operator|==
literal|null
condition|)
block|{
comment|// We could improve this when we fix
comment|// [CALCITE-429] Add statistics SPI for lattice optimization algorithm
name|rowCountEstimate
operator|=
literal|1000d
expr_stmt|;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rowCountEstimate
operator|>
literal|0d
argument_list|)
expr_stmt|;
name|this
operator|.
name|rowCountEstimate
operator|=
name|rowCountEstimate
expr_stmt|;
block|}
comment|/** Creates a Lattice. */
specifier|public
specifier|static
name|Lattice
name|create
parameter_list|(
name|OptiqSchema
name|schema
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|auto
parameter_list|)
block|{
return|return
name|builder
argument_list|(
name|schema
argument_list|,
name|sql
argument_list|)
operator|.
name|auto
argument_list|(
name|auto
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|populateAliases
parameter_list|(
name|SqlNode
name|from
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|String
name|current
parameter_list|)
block|{
if|if
condition|(
name|from
operator|instanceof
name|SqlJoin
condition|)
block|{
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|from
decl_stmt|;
name|populateAliases
argument_list|(
name|join
operator|.
name|getLeft
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|join
operator|.
name|getRight
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|from
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
condition|)
block|{
name|populateAliases
argument_list|(
name|SqlUtil
operator|.
name|stripAs
argument_list|(
name|from
argument_list|)
argument_list|,
name|aliases
argument_list|,
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|from
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|current
operator|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|from
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|aliases
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|populate
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|nodes
parameter_list|,
name|List
argument_list|<
name|int
index|[]
index|[]
argument_list|>
name|tempLinks
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|rel
operator|instanceof
name|ProjectRel
condition|)
block|{
return|return
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
operator|(
operator|(
name|ProjectRel
operator|)
name|rel
operator|)
operator|.
name|getChild
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|TableAccessRelBase
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|JoinRel
condition|)
block|{
name|JoinRel
name|join
init|=
operator|(
name|JoinRel
operator|)
name|rel
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|!=
name|JoinRelType
operator|.
name|INNER
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"only inner join allowed, but got "
operator|+
name|join
operator|.
name|getJoinType
argument_list|()
argument_list|)
throw|;
block|}
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
name|join
operator|.
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
name|join
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|join
operator|.
name|getCondition
argument_list|()
argument_list|)
control|)
block|{
name|tempLinks
operator|.
name|add
argument_list|(
name|grab
argument_list|(
name|nodes
argument_list|,
name|rex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid node type "
operator|+
name|rel
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" in lattice query"
argument_list|)
throw|;
block|}
comment|/** Converts an "t1.c1 = t2.c2" expression into two (input, field) pairs. */
specifier|private
specifier|static
name|int
index|[]
index|[]
name|grab
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|leaves
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"only equi-join allowed"
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
return|return
operator|new
name|int
index|[]
index|[]
block|{
name|inputField
argument_list|(
name|leaves
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
name|inputField
argument_list|(
name|leaves
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
block|}
return|;
block|}
comment|/** Converts an expression into an (input, field) pair. */
specifier|private
specifier|static
name|int
index|[]
name|inputField
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|leaves
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|rex
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"only equi-join of columns allowed: "
operator|+
name|rex
argument_list|)
throw|;
block|}
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|rex
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaves
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelNode
name|leaf
init|=
name|leaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|start
operator|+
name|leaf
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|<
name|end
condition|)
block|{
return|return
operator|new
name|int
index|[]
block|{
name|i
block|,
name|ref
operator|.
name|getIndex
argument_list|()
operator|-
name|start
block|}
return|;
block|}
name|start
operator|=
name|end
expr_stmt|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"input not found"
argument_list|)
throw|;
block|}
specifier|public
name|String
name|sql
parameter_list|(
name|BitSet
name|groupSet
parameter_list|,
name|List
argument_list|<
name|Measure
argument_list|>
name|aggCallList
parameter_list|)
block|{
specifier|final
name|BitSet
name|columnSet
init|=
operator|(
name|BitSet
operator|)
name|groupSet
operator|.
name|clone
argument_list|()
decl_stmt|;
for|for
control|(
name|Measure
name|call
range|:
name|aggCallList
control|)
block|{
for|for
control|(
name|Column
name|arg
range|:
name|call
operator|.
name|args
control|)
block|{
name|columnSet
operator|.
name|set
argument_list|(
name|arg
operator|.
name|ordinal
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Figure out which nodes are needed. Use a node if its columns are used
comment|// or if has a child whose columns are used.
name|List
argument_list|<
name|Node
argument_list|>
name|usedNodes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|BitSets
operator|.
name|range
argument_list|(
name|node
operator|.
name|startCol
argument_list|,
name|node
operator|.
name|endCol
argument_list|)
operator|.
name|intersects
argument_list|(
name|columnSet
argument_list|)
condition|)
block|{
name|use
argument_list|(
name|usedNodes
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usedNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|usedNodes
operator|.
name|add
argument_list|(
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlDialect
name|dialect
init|=
name|SqlDialect
operator|.
name|DatabaseProduct
operator|.
name|OPTIQ
operator|.
name|getDialect
argument_list|()
decl_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"SELECT "
argument_list|)
decl_stmt|;
specifier|final
name|StringBuilder
name|groupBuf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"\nGROUP BY "
argument_list|)
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|groupSet
argument_list|)
control|)
block|{
if|if
condition|(
name|k
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|groupBuf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Column
name|column
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|column
operator|.
name|identifiers
argument_list|()
argument_list|)
expr_stmt|;
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|groupBuf
argument_list|,
name|column
operator|.
name|identifiers
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|String
name|fieldName
init|=
name|uniqueColumnNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|column
operator|.
name|alias
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" AS "
argument_list|)
expr_stmt|;
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|groupSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|groupBuf
operator|.
name|append
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
block|}
name|int
name|m
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Measure
name|measure
range|:
name|aggCallList
control|)
block|{
if|if
condition|(
name|k
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|measure
operator|.
name|agg
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|measure
operator|.
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|z
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Column
name|arg
range|:
name|measure
operator|.
name|args
control|)
block|{
if|if
condition|(
name|z
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|arg
operator|.
name|identifiers
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|") AS "
argument_list|)
expr_stmt|;
name|String
name|measureName
decl_stmt|;
while|while
condition|(
operator|!
name|columnNames
operator|.
name|add
argument_list|(
name|measureName
operator|=
literal|"m"
operator|+
name|m
argument_list|)
condition|)
block|{
operator|++
name|m
expr_stmt|;
block|}
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|measureName
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"\nFROM "
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|usedNodes
control|)
block|{
if|if
condition|(
name|node
operator|.
name|parent
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\nJOIN "
argument_list|)
expr_stmt|;
block|}
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|node
operator|.
name|scan
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" AS "
argument_list|)
expr_stmt|;
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|node
operator|.
name|alias
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|parent
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" ON "
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|IntPair
name|pair
range|:
name|node
operator|.
name|link
control|)
block|{
if|if
condition|(
name|k
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Column
name|left
init|=
name|columns
operator|.
name|get
argument_list|(
name|node
operator|.
name|parent
operator|.
name|startCol
operator|+
name|pair
operator|.
name|source
argument_list|)
decl_stmt|;
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|left
operator|.
name|identifiers
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
specifier|final
name|Column
name|right
init|=
name|columns
operator|.
name|get
argument_list|(
name|node
operator|.
name|startCol
operator|+
name|pair
operator|.
name|target
argument_list|)
decl_stmt|;
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|right
operator|.
name|identifiers
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|OptiqPrepareImpl
operator|.
name|DEBUG
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Lattice SQL:\n"
operator|+
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|groupBuf
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|use
parameter_list|(
name|List
argument_list|<
name|Node
argument_list|>
name|usedNodes
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|usedNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|parent
operator|!=
literal|null
condition|)
block|{
name|use
argument_list|(
name|usedNodes
argument_list|,
name|node
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
name|usedNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|StarTable
name|createStarTable
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|Table
argument_list|>
name|tables
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
name|tables
operator|.
name|add
argument_list|(
name|node
operator|.
name|scan
operator|.
name|getTable
argument_list|()
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|StarTable
operator|.
name|of
argument_list|(
name|this
argument_list|,
name|tables
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Builder
name|builder
parameter_list|(
name|OptiqSchema
name|optiqSchema
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|(
name|optiqSchema
argument_list|,
name|sql
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|Measure
argument_list|>
name|toMeasures
parameter_list|(
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCallList
parameter_list|)
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|aggCallList
argument_list|,
name|toMeasureFunction
argument_list|)
return|;
block|}
specifier|public
name|Iterable
argument_list|<
name|?
extends|extends
name|Tile
argument_list|>
name|computeTiles
parameter_list|()
block|{
if|if
condition|(
operator|!
name|algorithm
condition|)
block|{
return|return
name|tiles
return|;
block|}
return|return
operator|new
name|TileSuggester
argument_list|(
name|this
argument_list|)
operator|.
name|tiles
argument_list|()
return|;
block|}
comment|/** Returns an estimate of the number of rows in the un-aggregated star. */
specifier|public
name|double
name|getFactRowCount
parameter_list|()
block|{
return|return
name|rowCountEstimate
return|;
block|}
comment|/** Returns an estimate of the number of rows in the tile with the given    * dimensions. */
specifier|public
name|double
name|getRowCount
parameter_list|(
name|List
argument_list|<
name|Column
argument_list|>
name|columns
parameter_list|)
block|{
comment|// The expected number of distinct values when choosing p values
comment|// with replacement from n integers is n . (1 - ((n - 1) / n) ^ p).
comment|//
comment|// If we have several uniformly distributed attributes A1 ... Am
comment|// with N1 ... Nm distinct values, they behave as one uniformly
comment|// distributed attribute with N1 * ... * Nm distinct values.
name|BigInteger
name|n
init|=
name|BigInteger
operator|.
name|ONE
decl_stmt|;
for|for
control|(
name|Column
name|column
range|:
name|columns
control|)
block|{
specifier|final
name|int
name|cardinality
init|=
name|cardinality
argument_list|(
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
name|cardinality
operator|>
literal|1
condition|)
block|{
name|n
operator|=
name|n
operator|.
name|multiply
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|cardinality
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|double
name|nn
init|=
name|n
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
specifier|final
name|double
name|f
init|=
name|getFactRowCount
argument_list|()
decl_stmt|;
specifier|final
name|double
name|a
init|=
operator|(
name|nn
operator|-
literal|1d
operator|)
operator|/
name|nn
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|1d
condition|)
block|{
comment|// A under-flows if nn is large.
return|return
name|f
return|;
block|}
specifier|final
name|double
name|v
init|=
name|nn
operator|*
operator|(
literal|1d
operator|-
name|Math
operator|.
name|pow
argument_list|(
name|a
argument_list|,
name|f
argument_list|)
operator|)
decl_stmt|;
comment|// Cap at fact-row-count, because numerical artifacts can cause it
comment|// to go a few % over.
return|return
name|Math
operator|.
name|min
argument_list|(
name|v
argument_list|,
name|f
argument_list|)
return|;
block|}
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|CARDINALITY_MAP
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Integer
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"brand_name"
argument_list|,
literal|111
argument_list|)
decl|.
name|put
argument_list|(
literal|"cases_per_pallet"
argument_list|,
literal|10
argument_list|)
decl|.
name|put
argument_list|(
literal|"customer_id"
argument_list|,
literal|5581
argument_list|)
decl|.
name|put
argument_list|(
literal|"day_of_month"
argument_list|,
literal|30
argument_list|)
decl|.
name|put
argument_list|(
literal|"fiscal_period"
argument_list|,
literal|0
argument_list|)
decl|.
name|put
argument_list|(
literal|"gross_weight"
argument_list|,
literal|376
argument_list|)
decl|.
name|put
argument_list|(
literal|"low_fat"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"month_of_year"
argument_list|,
literal|12
argument_list|)
decl|.
name|put
argument_list|(
literal|"net_weight"
argument_list|,
literal|332
argument_list|)
decl|.
name|put
argument_list|(
literal|"product_category"
argument_list|,
literal|45
argument_list|)
decl|.
name|put
argument_list|(
literal|"product_class_id"
argument_list|,
literal|102
argument_list|)
decl|.
name|put
argument_list|(
literal|"product_department"
argument_list|,
literal|22
argument_list|)
decl|.
name|put
argument_list|(
literal|"product_family"
argument_list|,
literal|3
argument_list|)
decl|.
name|put
argument_list|(
literal|"product_id"
argument_list|,
literal|1559
argument_list|)
decl|.
name|put
argument_list|(
literal|"product_name"
argument_list|,
literal|1559
argument_list|)
decl|.
name|put
argument_list|(
literal|"product_subcategory"
argument_list|,
literal|102
argument_list|)
decl|.
name|put
argument_list|(
literal|"promotion_id"
argument_list|,
literal|149
argument_list|)
decl|.
name|put
argument_list|(
literal|"quarter"
argument_list|,
literal|4
argument_list|)
decl|.
name|put
argument_list|(
literal|"recyclable_package"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"shelf_depth"
argument_list|,
literal|488
argument_list|)
decl|.
name|put
argument_list|(
literal|"shelf_height"
argument_list|,
literal|524
argument_list|)
decl|.
name|put
argument_list|(
literal|"shelf_width"
argument_list|,
literal|534
argument_list|)
decl|.
name|put
argument_list|(
literal|"SKU"
argument_list|,
literal|1559
argument_list|)
decl|.
name|put
argument_list|(
literal|"SRP"
argument_list|,
literal|315
argument_list|)
decl|.
name|put
argument_list|(
literal|"store_cost"
argument_list|,
literal|10777
argument_list|)
decl|.
name|put
argument_list|(
literal|"store_id"
argument_list|,
literal|13
argument_list|)
decl|.
name|put
argument_list|(
literal|"store_sales"
argument_list|,
literal|1049
argument_list|)
decl|.
name|put
argument_list|(
literal|"the_date"
argument_list|,
literal|323
argument_list|)
decl|.
name|put
argument_list|(
literal|"the_day"
argument_list|,
literal|7
argument_list|)
decl|.
name|put
argument_list|(
literal|"the_month"
argument_list|,
literal|12
argument_list|)
decl|.
name|put
argument_list|(
literal|"the_year"
argument_list|,
literal|1
argument_list|)
decl|.
name|put
argument_list|(
literal|"time_id"
argument_list|,
literal|323
argument_list|)
decl|.
name|put
argument_list|(
literal|"units_per_case"
argument_list|,
literal|36
argument_list|)
decl|.
name|put
argument_list|(
literal|"unit_sales"
argument_list|,
literal|6
argument_list|)
decl|.
name|put
argument_list|(
literal|"week_of_year"
argument_list|,
literal|52
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
name|int
name|cardinality
parameter_list|(
name|Column
name|column
parameter_list|)
block|{
specifier|final
name|Integer
name|integer
init|=
name|CARDINALITY_MAP
operator|.
name|get
argument_list|(
name|column
operator|.
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer
operator|!=
literal|null
operator|&&
name|integer
operator|>
literal|0
condition|)
block|{
return|return
name|integer
return|;
block|}
return|return
name|column
operator|.
name|alias
operator|.
name|length
argument_list|()
return|;
block|}
comment|/** Source relation of a lattice.    *    *<p>Relations form a tree; all relations except the root relation    * (the fact table) have precisely one parent and an equi-join    * condition on one or more pairs of columns linking to it. */
specifier|public
specifier|static
class|class
name|Node
block|{
specifier|public
specifier|final
name|TableAccessRelBase
name|scan
decl_stmt|;
specifier|public
specifier|final
name|Node
name|parent
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|IntPair
argument_list|>
name|link
decl_stmt|;
specifier|public
specifier|final
name|int
name|startCol
decl_stmt|;
specifier|public
specifier|final
name|int
name|endCol
decl_stmt|;
specifier|public
specifier|final
name|String
name|alias
decl_stmt|;
specifier|public
name|Node
parameter_list|(
name|TableAccessRelBase
name|scan
parameter_list|,
name|Node
name|parent
parameter_list|,
name|List
argument_list|<
name|IntPair
argument_list|>
name|link
parameter_list|,
name|int
name|startCol
parameter_list|,
name|int
name|endCol
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|scan
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|link
operator|=
name|link
operator|==
literal|null
condition|?
literal|null
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|link
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|parent
operator|==
literal|null
operator|)
operator|==
operator|(
name|link
operator|==
literal|null
operator|)
assert|;
assert|assert
name|startCol
operator|>=
literal|0
assert|;
assert|assert
name|endCol
operator|>
name|startCol
assert|;
name|this
operator|.
name|startCol
operator|=
name|startCol
expr_stmt|;
name|this
operator|.
name|endCol
operator|=
name|endCol
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
block|}
comment|/** Edge in the temporary graph. */
specifier|private
specifier|static
class|class
name|Edge
extends|extends
name|DefaultEdge
block|{
specifier|public
specifier|static
specifier|final
name|DirectedGraph
operator|.
name|EdgeFactory
argument_list|<
name|RelNode
argument_list|,
name|Edge
argument_list|>
name|FACTORY
init|=
operator|new
name|DirectedGraph
operator|.
name|EdgeFactory
argument_list|<
name|RelNode
argument_list|,
name|Edge
argument_list|>
argument_list|()
block|{
specifier|public
name|Edge
name|createEdge
parameter_list|(
name|RelNode
name|source
parameter_list|,
name|RelNode
name|target
parameter_list|)
block|{
return|return
operator|new
name|Edge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|List
argument_list|<
name|IntPair
argument_list|>
name|pairs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|public
name|Edge
parameter_list|(
name|RelNode
name|source
parameter_list|,
name|RelNode
name|target
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelNode
name|getTarget
parameter_list|()
block|{
return|return
operator|(
name|RelNode
operator|)
name|target
return|;
block|}
specifier|public
name|RelNode
name|getSource
parameter_list|()
block|{
return|return
operator|(
name|RelNode
operator|)
name|source
return|;
block|}
block|}
comment|/** Measure in a lattice. */
specifier|public
specifier|static
class|class
name|Measure
implements|implements
name|Comparable
argument_list|<
name|Measure
argument_list|>
block|{
specifier|public
specifier|final
name|Aggregation
name|agg
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|args
decl_stmt|;
specifier|public
name|Measure
parameter_list|(
name|Aggregation
name|agg
parameter_list|,
name|Iterable
argument_list|<
name|Column
argument_list|>
name|args
parameter_list|)
block|{
name|this
operator|.
name|agg
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|agg
argument_list|)
expr_stmt|;
name|this
operator|.
name|args
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|Measure
name|measure
parameter_list|)
block|{
name|int
name|c
init|=
name|agg
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|measure
operator|.
name|agg
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
name|c
return|;
block|}
return|return
name|compare
argument_list|(
name|args
argument_list|,
name|measure
operator|.
name|args
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Measure: [agg: "
operator|+
name|agg
operator|+
literal|", args: "
operator|+
name|args
operator|+
literal|"]"
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Util
operator|.
name|hashV
argument_list|(
name|agg
argument_list|,
name|args
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|==
name|this
operator|||
name|obj
operator|instanceof
name|Measure
operator|&&
name|this
operator|.
name|agg
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Measure
operator|)
name|obj
operator|)
operator|.
name|agg
argument_list|)
operator|&&
name|this
operator|.
name|args
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Measure
operator|)
name|obj
operator|)
operator|.
name|args
argument_list|)
return|;
block|}
comment|/** Returns the set of distinct argument ordinals. */
specifier|public
name|BitSet
name|argBitSet
parameter_list|()
block|{
specifier|final
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Column
name|arg
range|:
name|args
control|)
block|{
name|bitSet
operator|.
name|set
argument_list|(
name|arg
operator|.
name|ordinal
argument_list|)
expr_stmt|;
block|}
return|return
name|bitSet
return|;
block|}
comment|/** Returns a list of argument ordinals. */
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|argOrdinals
parameter_list|()
block|{
return|return
name|Lists
operator|.
name|transform
argument_list|(
name|args
argument_list|,
name|GET_ORDINAL
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|compare
parameter_list|(
name|List
argument_list|<
name|Column
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|Column
argument_list|>
name|list1
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|list0
operator|.
name|size
argument_list|()
argument_list|,
name|list1
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|o0
init|=
name|list0
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|ordinal
decl_stmt|;
specifier|final
name|int
name|o1
init|=
name|list1
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|ordinal
decl_stmt|;
specifier|final
name|int
name|c
init|=
name|Utilities
operator|.
name|compare
argument_list|(
name|o0
argument_list|,
name|o1
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
name|c
return|;
block|}
block|}
return|return
name|Utilities
operator|.
name|compare
argument_list|(
name|list0
operator|.
name|size
argument_list|()
argument_list|,
name|list1
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Column in a lattice. Columns are identified by table alias and    * column name, and may have an additional alias that is unique    * within the entire lattice. */
specifier|public
specifier|static
class|class
name|Column
implements|implements
name|Comparable
argument_list|<
name|Column
argument_list|>
block|{
specifier|public
specifier|final
name|int
name|ordinal
decl_stmt|;
specifier|public
specifier|final
name|String
name|table
decl_stmt|;
specifier|public
specifier|final
name|String
name|column
decl_stmt|;
specifier|public
specifier|final
name|String
name|alias
decl_stmt|;
specifier|private
name|Column
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|String
name|table
parameter_list|,
name|String
name|column
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|table
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|this
operator|.
name|column
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|column
argument_list|)
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|Column
name|column
parameter_list|)
block|{
return|return
name|Utilities
operator|.
name|compare
argument_list|(
name|ordinal
argument_list|,
name|column
operator|.
name|ordinal
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|ordinal
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|==
name|this
operator|||
name|obj
operator|instanceof
name|Column
operator|&&
name|this
operator|.
name|ordinal
operator|==
operator|(
operator|(
name|Column
operator|)
name|obj
operator|)
operator|.
name|ordinal
return|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|identifiers
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|table
argument_list|,
name|column
argument_list|)
return|;
block|}
block|}
comment|/** Lattice builder. */
specifier|public
specifier|static
class|class
name|Builder
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|columns
decl_stmt|;
specifier|private
specifier|final
name|ImmutableListMultimap
argument_list|<
name|String
argument_list|,
name|Column
argument_list|>
name|columnsByAlias
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Measure
argument_list|>
name|defaultMeasureListBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Tile
argument_list|>
name|tileListBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|algorithm
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|algorithmMaxMillis
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|auto
init|=
literal|true
decl_stmt|;
specifier|private
name|Double
name|rowCountEstimate
decl_stmt|;
specifier|public
name|Builder
parameter_list|(
name|OptiqSchema
name|schema
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|OptiqPrepare
operator|.
name|ConvertResult
name|parsed
init|=
name|Schemas
operator|.
name|convert
argument_list|(
name|MaterializedViewTable
operator|.
name|MATERIALIZATION_CONNECTION
argument_list|,
name|schema
argument_list|,
name|schema
operator|.
name|path
argument_list|(
literal|null
argument_list|)
argument_list|,
name|sql
argument_list|)
decl_stmt|;
comment|// Walk the join tree.
name|List
argument_list|<
name|RelNode
argument_list|>
name|relNodes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|int
index|[]
index|[]
argument_list|>
name|tempLinks
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|populate
argument_list|(
name|relNodes
argument_list|,
name|tempLinks
argument_list|,
name|parsed
operator|.
name|relNode
argument_list|)
expr_stmt|;
comment|// Get aliases.
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|populateAliases
argument_list|(
operator|(
operator|(
name|SqlSelect
operator|)
name|parsed
operator|.
name|sqlNode
operator|)
operator|.
name|getFrom
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Build a graph.
specifier|final
name|DirectedGraph
argument_list|<
name|RelNode
argument_list|,
name|Edge
argument_list|>
name|graph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|(
name|Edge
operator|.
name|FACTORY
argument_list|)
decl_stmt|;
for|for
control|(
name|RelNode
name|node
range|:
name|relNodes
control|)
block|{
name|graph
operator|.
name|addVertex
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
index|[]
index|[]
name|tempLink
range|:
name|tempLinks
control|)
block|{
specifier|final
name|RelNode
name|source
init|=
name|relNodes
operator|.
name|get
argument_list|(
name|tempLink
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|target
init|=
name|relNodes
operator|.
name|get
argument_list|(
name|tempLink
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Edge
name|edge
init|=
name|graph
operator|.
name|getEdge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|==
literal|null
condition|)
block|{
name|edge
operator|=
name|graph
operator|.
name|addEdge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|edge
operator|.
name|pairs
operator|.
name|add
argument_list|(
name|IntPair
operator|.
name|of
argument_list|(
name|tempLink
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|tempLink
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Convert the graph into a tree of nodes, each connected to a parent and
comment|// with a join condition to that parent.
name|Node
name|previous
init|=
literal|null
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelNode
argument_list|,
name|Node
argument_list|>
name|map
init|=
name|Maps
operator|.
name|newIdentityHashMap
argument_list|()
decl_stmt|;
name|int
name|previousColumn
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|relNode
range|:
name|TopologicalOrderIterator
operator|.
name|of
argument_list|(
name|graph
argument_list|)
control|)
block|{
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|edges
init|=
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|relNode
argument_list|)
decl_stmt|;
name|Node
name|node
decl_stmt|;
specifier|final
name|int
name|column
init|=
name|previousColumn
operator|+
name|relNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|edges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"root node must not have relationships: "
operator|+
name|relNode
argument_list|)
throw|;
block|}
name|node
operator|=
operator|new
name|Node
argument_list|(
operator|(
name|TableAccessRelBase
operator|)
name|relNode
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|previousColumn
argument_list|,
name|column
argument_list|,
name|aliases
operator|.
name|get
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|edges
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"child node must have precisely one parent: "
operator|+
name|relNode
argument_list|)
throw|;
block|}
specifier|final
name|Edge
name|edge
init|=
name|edges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|Node
argument_list|(
operator|(
name|TableAccessRelBase
operator|)
name|relNode
argument_list|,
name|map
operator|.
name|get
argument_list|(
name|edge
operator|.
name|getSource
argument_list|()
argument_list|)
argument_list|,
name|edge
operator|.
name|pairs
argument_list|,
name|previousColumn
argument_list|,
name|column
argument_list|,
name|aliases
operator|.
name|get
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|relNode
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|previous
operator|=
name|node
expr_stmt|;
name|previousColumn
operator|=
name|column
expr_stmt|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Column
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableListMultimap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Column
argument_list|>
name|aliasBuilder
init|=
name|ImmutableListMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|node
operator|.
name|scan
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|name
range|:
name|node
operator|.
name|scan
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
specifier|final
name|Column
name|column
init|=
operator|new
name|Column
argument_list|(
name|c
operator|++
argument_list|,
name|node
operator|.
name|alias
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
name|aliasBuilder
operator|.
name|put
argument_list|(
name|column
operator|.
name|alias
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|columns
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
name|columnsByAlias
operator|=
name|aliasBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|/** Sets the "auto" attribute (default true). */
specifier|public
name|Builder
name|auto
parameter_list|(
name|boolean
name|auto
parameter_list|)
block|{
name|this
operator|.
name|auto
operator|=
name|auto
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Sets the "algorithm" attribute (default false). */
specifier|public
name|Builder
name|algorithm
parameter_list|(
name|boolean
name|algorithm
parameter_list|)
block|{
name|this
operator|.
name|algorithm
operator|=
name|algorithm
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Sets the "algorithmMaxMillis" attribute (default -1). */
specifier|public
name|Builder
name|algorithmMaxMillis
parameter_list|(
name|long
name|algorithmMaxMillis
parameter_list|)
block|{
name|this
operator|.
name|algorithmMaxMillis
operator|=
name|algorithmMaxMillis
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Sets the "rowCountEstimate" attribute (default null). */
specifier|public
name|Builder
name|rowCountEstimate
parameter_list|(
name|double
name|rowCountEstimate
parameter_list|)
block|{
name|this
operator|.
name|rowCountEstimate
operator|=
name|rowCountEstimate
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Builds a lattice. */
specifier|public
name|Lattice
name|build
parameter_list|()
block|{
return|return
operator|new
name|Lattice
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|,
name|auto
argument_list|,
name|algorithm
argument_list|,
name|algorithmMaxMillis
argument_list|,
name|rowCountEstimate
argument_list|,
name|columns
argument_list|,
name|defaultMeasureListBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|tileListBuilder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/** Resolves the arguments of a      * {@link net.hydromatic.optiq.model.JsonMeasure}. They must either be null,      * a string, or a list of strings. Throws if the structure is invalid, or if      * any of the columns do not exist in the lattice. */
specifier|public
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|resolveArgs
parameter_list|(
name|Object
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
literal|null
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
if|else if
condition|(
name|args
operator|instanceof
name|String
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|resolveColumnByAlias
argument_list|(
operator|(
name|String
operator|)
name|args
argument_list|)
argument_list|)
return|;
block|}
if|else if
condition|(
name|args
operator|instanceof
name|List
condition|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Column
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
operator|(
name|List
operator|)
name|args
control|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|resolveColumnByAlias
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Measure arguments must be a string or a list of strings; argument: "
operator|+
name|o
argument_list|)
throw|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Measure arguments must be a string or a list of strings"
argument_list|)
throw|;
block|}
block|}
comment|/** Looks up a column in this lattice by alias. The alias must be unique      * within the lattice.      */
specifier|private
name|Column
name|resolveColumnByAlias
parameter_list|(
name|String
name|name
parameter_list|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|list
init|=
name|columnsByAlias
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
operator|||
name|list
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown lattice column '"
operator|+
name|name
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Lattice column alias '"
operator|+
name|name
operator|+
literal|"' is not unique"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Column
name|resolveColumn
parameter_list|(
name|Object
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|instanceof
name|String
condition|)
block|{
return|return
name|resolveColumnByAlias
argument_list|(
operator|(
name|String
operator|)
name|name
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|instanceof
name|List
condition|)
block|{
name|List
name|list
init|=
operator|(
name|List
operator|)
name|name
decl_stmt|;
switch|switch
condition|(
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
specifier|final
name|Object
name|alias
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|instanceof
name|String
condition|)
block|{
return|return
name|resolveColumnByAlias
argument_list|(
operator|(
name|String
operator|)
name|alias
argument_list|)
return|;
block|}
break|break;
case|case
literal|2
case|:
specifier|final
name|Object
name|table
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|column
init|=
name|list
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|instanceof
name|String
operator|&&
name|column
operator|instanceof
name|String
condition|)
block|{
return|return
name|resolveQualifiedColumn
argument_list|(
operator|(
name|String
operator|)
name|table
argument_list|,
operator|(
name|String
operator|)
name|column
argument_list|)
return|;
block|}
break|break;
block|}
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Lattice column reference must be a string or a list of 1 or 2 strings; column: "
operator|+
name|name
argument_list|)
throw|;
block|}
specifier|private
name|Column
name|resolveQualifiedColumn
parameter_list|(
name|String
name|table
parameter_list|,
name|String
name|column
parameter_list|)
block|{
for|for
control|(
name|Column
name|column1
range|:
name|columns
control|)
block|{
if|if
condition|(
name|column1
operator|.
name|table
operator|.
name|equals
argument_list|(
name|table
argument_list|)
operator|&&
name|column1
operator|.
name|column
operator|.
name|equals
argument_list|(
name|column
argument_list|)
condition|)
block|{
return|return
name|column1
return|;
block|}
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown lattice column ["
operator|+
name|table
operator|+
literal|", "
operator|+
name|column
operator|+
literal|"]"
argument_list|)
throw|;
block|}
specifier|public
name|Measure
name|resolveMeasure
parameter_list|(
name|String
name|aggName
parameter_list|,
name|Object
name|args
parameter_list|)
block|{
specifier|final
name|SqlAggFunction
name|agg
init|=
name|resolveAgg
argument_list|(
name|aggName
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|list
init|=
name|resolveArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
return|return
operator|new
name|Measure
argument_list|(
name|agg
argument_list|,
name|list
argument_list|)
return|;
block|}
specifier|private
name|SqlAggFunction
name|resolveAgg
parameter_list|(
name|String
name|aggName
parameter_list|)
block|{
if|if
condition|(
name|aggName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"count"
argument_list|)
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|COUNT
return|;
block|}
if|else if
condition|(
name|aggName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"sum"
argument_list|)
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|SUM
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown lattice aggregate function "
operator|+
name|aggName
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|addMeasure
parameter_list|(
name|Measure
name|measure
parameter_list|)
block|{
name|defaultMeasureListBuilder
operator|.
name|add
argument_list|(
name|measure
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addTile
parameter_list|(
name|Tile
name|tile
parameter_list|)
block|{
name|tileListBuilder
operator|.
name|add
argument_list|(
name|tile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Materialized aggregate within a lattice. */
specifier|public
specifier|static
class|class
name|Tile
block|{
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Measure
argument_list|>
name|measures
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|dimensions
decl_stmt|;
specifier|public
specifier|final
name|BitSet
name|bitSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
specifier|public
name|Tile
parameter_list|(
name|ImmutableList
argument_list|<
name|Measure
argument_list|>
name|measures
parameter_list|,
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|dimensions
parameter_list|)
block|{
name|this
operator|.
name|measures
operator|=
name|measures
expr_stmt|;
name|this
operator|.
name|dimensions
operator|=
name|dimensions
expr_stmt|;
assert|assert
name|Util
operator|.
name|isStrictlySorted
argument_list|(
name|dimensions
argument_list|)
assert|;
assert|assert
name|Util
operator|.
name|isStrictlySorted
argument_list|(
name|measures
argument_list|)
assert|;
for|for
control|(
name|Column
name|dimension
range|:
name|dimensions
control|)
block|{
name|bitSet
operator|.
name|set
argument_list|(
name|dimension
operator|.
name|ordinal
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|TileBuilder
name|builder
parameter_list|()
block|{
return|return
operator|new
name|TileBuilder
argument_list|()
return|;
block|}
specifier|public
name|BitSet
name|bitSet
parameter_list|()
block|{
return|return
name|bitSet
return|;
block|}
block|}
comment|/** Tile builder. */
specifier|public
specifier|static
class|class
name|TileBuilder
block|{
specifier|private
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Measure
argument_list|>
name|measureBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Column
argument_list|>
name|dimensionListBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|public
name|Tile
name|build
parameter_list|()
block|{
return|return
operator|new
name|Tile
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|Util
operator|.
name|sort
argument_list|(
name|measureBuilder
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|Util
operator|.
name|sort
argument_list|(
name|dimensionListBuilder
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|addMeasure
parameter_list|(
name|Measure
name|measure
parameter_list|)
block|{
name|measureBuilder
operator|.
name|add
argument_list|(
name|measure
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addDimension
parameter_list|(
name|Column
name|column
parameter_list|)
block|{
name|dimensionListBuilder
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End Lattice.java
end_comment

end_unit

