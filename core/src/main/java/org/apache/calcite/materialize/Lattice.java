begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|materialize
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|AvaticaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteSystemProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalcitePrepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Primitive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rel2sql
operator|.
name|SqlImplementor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schemas
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|MaterializedViewTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|StarTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|statistic
operator|.
name|MapSqlStatisticProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultDirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultEdge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|TopologicalOrderIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|IntPair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|LinkedHashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|IntFunction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|ParametersAreNonnullByDefault
import|;
end_import

begin_comment
comment|/**  * Structure that allows materialized views based upon a star schema to be  * recognized and recommended.  */
end_comment

begin_class
annotation|@
name|ParametersAreNonnullByDefault
specifier|public
class|class
name|Lattice
block|{
specifier|public
specifier|final
name|CalciteSchema
name|rootSchema
decl_stmt|;
specifier|public
specifier|final
name|LatticeRootNode
name|rootNode
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|columns
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|auto
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|algorithm
decl_stmt|;
specifier|public
specifier|final
name|long
name|algorithmMaxMillis
decl_stmt|;
specifier|public
specifier|final
name|double
name|rowCountEstimate
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Measure
argument_list|>
name|defaultMeasures
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Tile
argument_list|>
name|tiles
decl_stmt|;
specifier|public
specifier|final
name|ImmutableListMultimap
argument_list|<
name|Integer
argument_list|,
name|Boolean
argument_list|>
name|columnUses
decl_stmt|;
specifier|public
specifier|final
name|LatticeStatisticProvider
name|statisticProvider
decl_stmt|;
specifier|private
name|Lattice
parameter_list|(
name|CalciteSchema
name|rootSchema
parameter_list|,
name|LatticeRootNode
name|rootNode
parameter_list|,
name|boolean
name|auto
parameter_list|,
name|boolean
name|algorithm
parameter_list|,
name|long
name|algorithmMaxMillis
parameter_list|,
name|LatticeStatisticProvider
operator|.
name|Factory
name|statisticProviderFactory
parameter_list|,
annotation|@
name|Nullable
name|Double
name|rowCountEstimate
parameter_list|,
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|columns
parameter_list|,
name|ImmutableSortedSet
argument_list|<
name|Measure
argument_list|>
name|defaultMeasures
parameter_list|,
name|ImmutableList
argument_list|<
name|Tile
argument_list|>
name|tiles
parameter_list|,
name|ImmutableListMultimap
argument_list|<
name|Integer
argument_list|,
name|Boolean
argument_list|>
name|columnUses
parameter_list|)
block|{
name|this
operator|.
name|rootSchema
operator|=
name|rootSchema
expr_stmt|;
name|this
operator|.
name|rootNode
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|rootNode
argument_list|)
expr_stmt|;
name|this
operator|.
name|columns
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|columns
argument_list|)
expr_stmt|;
name|this
operator|.
name|auto
operator|=
name|auto
expr_stmt|;
name|this
operator|.
name|algorithm
operator|=
name|algorithm
expr_stmt|;
name|this
operator|.
name|algorithmMaxMillis
operator|=
name|algorithmMaxMillis
expr_stmt|;
name|this
operator|.
name|defaultMeasures
operator|=
name|defaultMeasures
operator|.
name|asList
argument_list|()
expr_stmt|;
comment|// unique and sorted
name|this
operator|.
name|tiles
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|tiles
argument_list|)
expr_stmt|;
name|this
operator|.
name|columnUses
operator|=
name|columnUses
expr_stmt|;
assert|assert
name|isValid
argument_list|(
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
if|if
condition|(
name|rowCountEstimate
operator|==
literal|null
condition|)
block|{
comment|// We could improve this when we fix
comment|// [CALCITE-429] Add statistics SPI for lattice optimization algorithm
name|rowCountEstimate
operator|=
literal|1000d
expr_stmt|;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rowCountEstimate
operator|>
literal|0d
argument_list|)
expr_stmt|;
name|this
operator|.
name|rowCountEstimate
operator|=
name|rowCountEstimate
expr_stmt|;
name|this
operator|.
name|statisticProvider
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|statisticProviderFactory
operator|.
name|apply
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a Lattice. */
specifier|public
specifier|static
name|Lattice
name|create
parameter_list|(
name|CalciteSchema
name|schema
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|auto
parameter_list|)
block|{
return|return
name|builder
argument_list|(
name|schema
argument_list|,
name|sql
argument_list|)
operator|.
name|auto
argument_list|(
name|auto
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|isValid
parameter_list|(
name|Litmus
name|litmus
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rootNode
operator|.
name|isValid
argument_list|(
name|litmus
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Measure
name|measure
range|:
name|defaultMeasures
control|)
block|{
for|for
control|(
name|Column
name|arg
range|:
name|measure
operator|.
name|args
control|)
block|{
if|if
condition|(
name|columns
operator|.
name|get
argument_list|(
name|arg
operator|.
name|ordinal
argument_list|)
operator|!=
name|arg
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"measure argument must be a column registered in"
operator|+
literal|" this lattice: {}"
argument_list|,
name|measure
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|populateAliases
parameter_list|(
name|SqlNode
name|from
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
annotation|@
name|Nullable
name|String
name|current
parameter_list|)
block|{
if|if
condition|(
name|from
operator|instanceof
name|SqlJoin
condition|)
block|{
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|from
decl_stmt|;
name|populateAliases
argument_list|(
name|join
operator|.
name|getLeft
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|join
operator|.
name|getRight
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|from
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
condition|)
block|{
name|populateAliases
argument_list|(
name|SqlUtil
operator|.
name|stripAs
argument_list|(
name|from
argument_list|)
argument_list|,
name|aliases
argument_list|,
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|from
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|current
operator|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|from
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|aliases
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|populate
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|nodes
parameter_list|,
name|List
argument_list|<
name|int
index|[]
index|[]
argument_list|>
name|tempLinks
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|rel
operator|instanceof
name|LogicalProject
condition|)
block|{
return|return
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
operator|(
operator|(
name|LogicalProject
operator|)
name|rel
operator|)
operator|.
name|getInput
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|TableScan
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|rel
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|LogicalJoin
condition|)
block|{
name|LogicalJoin
name|join
init|=
operator|(
name|LogicalJoin
operator|)
name|rel
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|.
name|isOuterJoin
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"only non nulls-generating join allowed, but got "
operator|+
name|join
operator|.
name|getJoinType
argument_list|()
argument_list|)
throw|;
block|}
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
name|join
operator|.
name|getLeft
argument_list|()
argument_list|)
expr_stmt|;
name|populate
argument_list|(
name|nodes
argument_list|,
name|tempLinks
argument_list|,
name|join
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|join
operator|.
name|getCondition
argument_list|()
argument_list|)
control|)
block|{
name|tempLinks
operator|.
name|add
argument_list|(
name|grab
argument_list|(
name|nodes
argument_list|,
name|rex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid node type "
operator|+
name|rel
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" in lattice query"
argument_list|)
throw|;
block|}
comment|/** Converts an "t1.c1 = t2.c2" expression into two (input, field) pairs. */
specifier|private
specifier|static
name|int
index|[]
index|[]
name|grab
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|leaves
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"only equi-join allowed"
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
return|return
operator|new
name|int
index|[]
index|[]
block|{
name|inputField
argument_list|(
name|leaves
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
name|inputField
argument_list|(
name|leaves
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
block|}
return|;
block|}
comment|/** Converts an expression into an (input, field) pair. */
specifier|private
specifier|static
name|int
index|[]
name|inputField
parameter_list|(
name|List
argument_list|<
name|RelNode
argument_list|>
name|leaves
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|rex
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"only equi-join of columns allowed: "
operator|+
name|rex
argument_list|)
throw|;
block|}
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|rex
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leaves
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelNode
name|leaf
init|=
name|leaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|end
init|=
name|start
operator|+
name|leaf
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|<
name|end
condition|)
block|{
return|return
operator|new
name|int
index|[]
block|{
name|i
block|,
name|ref
operator|.
name|getIndex
argument_list|()
operator|-
name|start
block|}
return|;
block|}
name|start
operator|=
name|end
expr_stmt|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"input not found"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|rootNode
operator|+
literal|":"
operator|+
name|defaultMeasures
return|;
block|}
comment|/** Generates a SQL query to populate a tile of the lattice specified by a    * given set of columns and measures. */
specifier|public
name|String
name|sql
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|List
argument_list|<
name|Measure
argument_list|>
name|aggCallList
parameter_list|)
block|{
return|return
name|sql
argument_list|(
name|groupSet
argument_list|,
literal|true
argument_list|,
name|aggCallList
argument_list|)
return|;
block|}
comment|/** Generates a SQL query to populate a tile of the lattice specified by a    * given set of columns and measures, optionally grouping. */
specifier|public
name|String
name|sql
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|boolean
name|group
parameter_list|,
name|List
argument_list|<
name|Measure
argument_list|>
name|aggCallList
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|LatticeNode
argument_list|>
name|usedNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|group
condition|)
block|{
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|columnSetBuilder
init|=
name|groupSet
operator|.
name|rebuild
argument_list|()
decl_stmt|;
for|for
control|(
name|Measure
name|call
range|:
name|aggCallList
control|)
block|{
for|for
control|(
name|Column
name|arg
range|:
name|call
operator|.
name|args
control|)
block|{
name|columnSetBuilder
operator|.
name|set
argument_list|(
name|arg
operator|.
name|ordinal
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|ImmutableBitSet
name|columnSet
init|=
name|columnSetBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// Figure out which nodes are needed. Use a node if its columns are used
comment|// or if has a child whose columns are used.
for|for
control|(
name|LatticeNode
name|node
range|:
name|rootNode
operator|.
name|descendants
control|)
block|{
if|if
condition|(
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|node
operator|.
name|startCol
argument_list|,
name|node
operator|.
name|endCol
argument_list|)
operator|.
name|intersects
argument_list|(
name|columnSet
argument_list|)
condition|)
block|{
name|node
operator|.
name|use
argument_list|(
name|usedNodes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usedNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|usedNodes
operator|.
name|add
argument_list|(
name|rootNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|usedNodes
operator|.
name|addAll
argument_list|(
name|rootNode
operator|.
name|descendants
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlDialect
name|dialect
init|=
name|SqlDialect
operator|.
name|DatabaseProduct
operator|.
name|CALCITE
operator|.
name|getDialect
argument_list|()
decl_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"SELECT "
argument_list|)
decl_stmt|;
specifier|final
name|StringBuilder
name|groupBuf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"\nGROUP BY "
argument_list|)
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|SqlWriter
name|w
init|=
name|createSqlWriter
argument_list|(
name|dialect
argument_list|,
name|buf
argument_list|,
name|f
lambda|->
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupSet
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
range|:
name|groupSet
control|)
block|{
if|if
condition|(
name|k
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|groupBuf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Column
name|column
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|column
operator|.
name|toSql
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|column
operator|.
name|toSql
argument_list|(
name|w
operator|.
name|with
argument_list|(
name|groupBuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|instanceof
name|BaseColumn
condition|)
block|{
name|columnNames
operator|.
name|add
argument_list|(
operator|(
operator|(
name|BaseColumn
operator|)
name|column
operator|)
operator|.
name|column
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|column
operator|.
name|alias
operator|.
name|equals
argument_list|(
name|column
operator|.
name|defaultAlias
argument_list|()
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" AS "
argument_list|)
expr_stmt|;
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|column
operator|.
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|m
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Measure
name|measure
range|:
name|aggCallList
control|)
block|{
if|if
condition|(
name|k
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|measure
operator|.
name|agg
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|measure
operator|.
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|z
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Column
name|arg
range|:
name|measure
operator|.
name|args
control|)
block|{
if|if
condition|(
name|z
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|arg
operator|.
name|toSql
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|") AS "
argument_list|)
expr_stmt|;
name|String
name|measureName
decl_stmt|;
while|while
condition|(
operator|!
name|columnNames
operator|.
name|add
argument_list|(
name|measureName
operator|=
literal|"m"
operator|+
name|m
argument_list|)
condition|)
block|{
operator|++
name|m
expr_stmt|;
block|}
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|measureName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"\nFROM "
argument_list|)
expr_stmt|;
for|for
control|(
name|LatticeNode
name|node
range|:
name|usedNodes
control|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|LatticeChildNode
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\nJOIN "
argument_list|)
expr_stmt|;
block|}
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|node
operator|.
name|table
operator|.
name|t
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" AS "
argument_list|)
expr_stmt|;
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|buf
argument_list|,
name|node
operator|.
name|alias
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|LatticeChildNode
condition|)
block|{
specifier|final
name|LatticeChildNode
name|node1
init|=
operator|(
name|LatticeChildNode
operator|)
name|node
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" ON "
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|IntPair
name|pair
range|:
name|node1
operator|.
name|link
control|)
block|{
if|if
condition|(
name|k
operator|++
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Column
name|left
init|=
name|columns
operator|.
name|get
argument_list|(
name|node1
operator|.
name|parent
operator|.
name|startCol
operator|+
name|pair
operator|.
name|source
argument_list|)
decl_stmt|;
name|left
operator|.
name|toSql
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
specifier|final
name|Column
name|right
init|=
name|columns
operator|.
name|get
argument_list|(
name|node
operator|.
name|startCol
operator|+
name|pair
operator|.
name|target
argument_list|)
decl_stmt|;
name|right
operator|.
name|toSql
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|CalciteSystemProperty
operator|.
name|DEBUG
operator|.
name|value
argument_list|()
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Lattice SQL:\n"
operator|+
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|group
condition|)
block|{
if|if
condition|(
name|groupSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|groupBuf
operator|.
name|append
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|groupBuf
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Creates a context to which SQL can be generated. */
specifier|public
name|SqlWriter
name|createSqlWriter
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|StringBuilder
name|buf
parameter_list|,
name|IntFunction
argument_list|<
name|SqlNode
argument_list|>
name|field
parameter_list|)
block|{
return|return
operator|new
name|SqlWriter
argument_list|(
name|this
argument_list|,
name|dialect
argument_list|,
name|buf
argument_list|,
operator|new
name|SqlImplementor
operator|.
name|SimpleContext
argument_list|(
name|dialect
argument_list|,
name|field
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns a SQL query that counts the number of distinct values of the    * attributes given in {@code groupSet}. */
specifier|public
name|String
name|countSql
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|)
block|{
return|return
literal|"select count(*) as c from ("
operator|+
name|sql
argument_list|(
name|groupSet
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
operator|+
literal|")"
return|;
block|}
specifier|public
name|StarTable
name|createStarTable
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|Table
argument_list|>
name|tables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LatticeNode
name|node
range|:
name|rootNode
operator|.
name|descendants
control|)
block|{
name|tables
operator|.
name|add
argument_list|(
name|node
operator|.
name|table
operator|.
name|t
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|StarTable
operator|.
name|of
argument_list|(
name|this
argument_list|,
name|tables
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Builder
name|builder
parameter_list|(
name|CalciteSchema
name|calciteSchema
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
return|return
name|builder
argument_list|(
operator|new
name|LatticeSpace
argument_list|(
name|MapSqlStatisticProvider
operator|.
name|INSTANCE
argument_list|)
argument_list|,
name|calciteSchema
argument_list|,
name|sql
argument_list|)
return|;
block|}
specifier|static
name|Builder
name|builder
parameter_list|(
name|LatticeSpace
name|space
parameter_list|,
name|CalciteSchema
name|calciteSchema
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
return|return
operator|new
name|Builder
argument_list|(
name|space
argument_list|,
name|calciteSchema
argument_list|,
name|sql
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|Measure
argument_list|>
name|toMeasures
parameter_list|(
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggCallList
parameter_list|)
block|{
return|return
name|Util
operator|.
name|transform
argument_list|(
name|aggCallList
argument_list|,
name|this
operator|::
name|toMeasure
argument_list|)
return|;
block|}
specifier|private
name|Measure
name|toMeasure
parameter_list|(
name|AggregateCall
name|aggCall
parameter_list|)
block|{
return|return
operator|new
name|Measure
argument_list|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|aggCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|aggCall
operator|.
name|name
argument_list|,
name|Util
operator|.
name|transform
argument_list|(
name|aggCall
operator|.
name|getArgList
argument_list|()
argument_list|,
name|columns
operator|::
name|get
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|Iterable
argument_list|<
name|?
extends|extends
name|Tile
argument_list|>
name|computeTiles
parameter_list|()
block|{
if|if
condition|(
operator|!
name|algorithm
condition|)
block|{
return|return
name|tiles
return|;
block|}
return|return
operator|new
name|TileSuggester
argument_list|(
name|this
argument_list|)
operator|.
name|tiles
argument_list|()
return|;
block|}
comment|/** Returns an estimate of the number of rows in the un-aggregated star. */
specifier|public
name|double
name|getFactRowCount
parameter_list|()
block|{
return|return
name|rowCountEstimate
return|;
block|}
comment|/** Returns an estimate of the number of rows in the tile with the given    * dimensions. */
specifier|public
name|double
name|getRowCount
parameter_list|(
name|List
argument_list|<
name|Column
argument_list|>
name|columns
parameter_list|)
block|{
return|return
name|statisticProvider
operator|.
name|cardinality
argument_list|(
name|columns
argument_list|)
return|;
block|}
comment|/** Returns an estimate of the number of rows in the tile with the given    * dimensions. */
specifier|public
specifier|static
name|double
name|getRowCount
parameter_list|(
name|double
name|factCount
parameter_list|,
name|double
modifier|...
name|columnCounts
parameter_list|)
block|{
return|return
name|getRowCount
argument_list|(
name|factCount
argument_list|,
name|Primitive
operator|.
name|asList
argument_list|(
name|columnCounts
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns an estimate of the number of rows in the tile with the given    * dimensions. */
specifier|public
specifier|static
name|double
name|getRowCount
parameter_list|(
name|double
name|factCount
parameter_list|,
name|List
argument_list|<
name|Double
argument_list|>
name|columnCounts
parameter_list|)
block|{
comment|// The expected number of distinct values when choosing p values
comment|// with replacement from n integers is n . (1 - ((n - 1) / n) ^ p).
comment|//
comment|// If we have several uniformly distributed attributes A1 ... Am
comment|// with N1 ... Nm distinct values, they behave as one uniformly
comment|// distributed attribute with N1 * ... * Nm distinct values.
name|double
name|n
init|=
literal|1d
decl_stmt|;
for|for
control|(
name|Double
name|columnCount
range|:
name|columnCounts
control|)
block|{
if|if
condition|(
name|columnCount
operator|>
literal|1d
condition|)
block|{
name|n
operator|*=
name|columnCount
expr_stmt|;
block|}
block|}
specifier|final
name|double
name|a
init|=
operator|(
name|n
operator|-
literal|1d
operator|)
operator|/
name|n
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|1d
condition|)
block|{
comment|// A under-flows if nn is large.
return|return
name|factCount
return|;
block|}
specifier|final
name|double
name|v
init|=
name|n
operator|*
operator|(
literal|1d
operator|-
name|Math
operator|.
name|pow
argument_list|(
name|a
argument_list|,
name|factCount
argument_list|)
operator|)
decl_stmt|;
comment|// Cap at fact-row-count, because numerical artifacts can cause it
comment|// to go a few % over.
return|return
name|Math
operator|.
name|min
argument_list|(
name|v
argument_list|,
name|factCount
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|uniqueColumnNames
parameter_list|()
block|{
return|return
name|Util
operator|.
name|transform
argument_list|(
name|columns
argument_list|,
name|column
lambda|->
name|column
operator|.
name|alias
argument_list|)
return|;
block|}
name|Pair
argument_list|<
name|Path
argument_list|,
name|Integer
argument_list|>
name|columnToPathOffset
parameter_list|(
name|BaseColumn
name|c
parameter_list|)
block|{
for|for
control|(
name|Pair
argument_list|<
name|LatticeNode
argument_list|,
name|Path
argument_list|>
name|p
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|rootNode
operator|.
name|descendants
argument_list|,
name|rootNode
operator|.
name|paths
argument_list|)
control|)
block|{
if|if
condition|(
name|p
operator|.
name|left
operator|.
name|alias
operator|.
name|equals
argument_list|(
name|c
operator|.
name|table
argument_list|)
condition|)
block|{
return|return
name|Pair
operator|.
name|of
argument_list|(
name|p
operator|.
name|right
argument_list|,
name|c
operator|.
name|ordinal
operator|-
name|p
operator|.
name|left
operator|.
name|startCol
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"lattice column not found: "
operator|+
name|c
argument_list|)
throw|;
block|}
comment|/** Returns the set of tables in this lattice. */
specifier|public
name|Set
argument_list|<
name|LatticeTable
argument_list|>
name|tables
parameter_list|()
block|{
return|return
name|rootNode
operator|.
name|descendants
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|n
lambda|->
name|n
operator|.
name|table
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toCollection
argument_list|(
name|LinkedHashSet
operator|::
operator|new
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns the ordinal, within all of the columns in this Lattice, of the    * first column in the table with a given alias.    * Returns -1 if the table is not found. */
specifier|public
name|int
name|firstColumn
parameter_list|(
name|String
name|tableAlias
parameter_list|)
block|{
for|for
control|(
name|Column
name|column
range|:
name|columns
control|)
block|{
if|if
condition|(
name|column
operator|instanceof
name|BaseColumn
operator|&&
operator|(
operator|(
name|BaseColumn
operator|)
name|column
operator|)
operator|.
name|table
operator|.
name|equals
argument_list|(
name|tableAlias
argument_list|)
condition|)
block|{
return|return
name|column
operator|.
name|ordinal
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** Returns whether every use of a column is as an argument to a measure.    *    *<p>For example, in the query    * {@code select sum(x + y), sum(a + b) from t group by x + y}    * the expression "x + y" is used once as an argument to a measure,    * and once as a dimension.    *    *<p>Therefore, in a lattice created from that one query,    * {@code isAlwaysMeasure} for the derived column corresponding to "x + y"    * returns false, and for "a + b" returns true.    *    * @param column Column or derived column    * @return Whether all uses are as arguments to aggregate functions    */
specifier|public
name|boolean
name|isAlwaysMeasure
parameter_list|(
name|Column
name|column
parameter_list|)
block|{
return|return
operator|!
name|columnUses
operator|.
name|get
argument_list|(
name|column
operator|.
name|ordinal
argument_list|)
operator|.
name|contains
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/** Edge in the temporary graph. */
specifier|private
specifier|static
class|class
name|Edge
extends|extends
name|DefaultEdge
block|{
specifier|public
specifier|static
specifier|final
name|DirectedGraph
operator|.
name|EdgeFactory
argument_list|<
name|Vertex
argument_list|,
name|Edge
argument_list|>
name|FACTORY
init|=
name|Edge
operator|::
operator|new
decl_stmt|;
specifier|final
name|List
argument_list|<
name|IntPair
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Edge
parameter_list|(
name|Vertex
name|source
parameter_list|,
name|Vertex
name|target
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|Vertex
name|getTarget
parameter_list|()
block|{
return|return
operator|(
name|Vertex
operator|)
name|target
return|;
block|}
name|Vertex
name|getSource
parameter_list|()
block|{
return|return
operator|(
name|Vertex
operator|)
name|source
return|;
block|}
block|}
comment|/** Vertex in the temporary graph. */
specifier|private
specifier|static
class|class
name|Vertex
block|{
specifier|final
name|LatticeTable
name|table
decl_stmt|;
specifier|final
name|String
name|alias
decl_stmt|;
specifier|private
name|Vertex
parameter_list|(
name|LatticeTable
name|table
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|table
operator|=
name|table
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
block|}
comment|/** A measure within a {@link Lattice}.    *    *<p>It is immutable.    *    *<p>Examples: SUM(products.weight), COUNT() (means "COUNT(*")),    * COUNT(DISTINCT customer.id).    */
specifier|public
specifier|static
class|class
name|Measure
implements|implements
name|Comparable
argument_list|<
name|Measure
argument_list|>
block|{
specifier|public
specifier|final
name|SqlAggFunction
name|agg
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|distinct
decl_stmt|;
annotation|@
name|Nullable
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|args
decl_stmt|;
specifier|public
specifier|final
name|String
name|digest
decl_stmt|;
specifier|public
name|Measure
parameter_list|(
name|SqlAggFunction
name|agg
parameter_list|,
name|boolean
name|distinct
parameter_list|,
annotation|@
name|Nullable
name|String
name|name
parameter_list|,
name|Iterable
argument_list|<
name|Column
argument_list|>
name|args
parameter_list|)
block|{
name|this
operator|.
name|agg
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|agg
argument_list|)
expr_stmt|;
name|this
operator|.
name|distinct
operator|=
name|distinct
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|args
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|args
argument_list|)
expr_stmt|;
specifier|final
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|agg
argument_list|)
operator|.
name|append
argument_list|(
name|distinct
condition|?
literal|"(DISTINCT "
else|:
literal|"("
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|Column
argument_list|>
name|arg
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|this
operator|.
name|args
argument_list|)
control|)
block|{
if|if
condition|(
name|arg
operator|.
name|i
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|.
name|e
operator|instanceof
name|BaseColumn
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
operator|(
operator|(
name|BaseColumn
operator|)
name|arg
operator|.
name|e
operator|)
operator|.
name|table
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
operator|(
operator|(
name|BaseColumn
operator|)
name|arg
operator|.
name|e
operator|)
operator|.
name|column
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
name|arg
operator|.
name|e
operator|.
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|this
operator|.
name|digest
operator|=
name|b
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
annotation|@
name|Nonnull
name|Measure
name|measure
parameter_list|)
block|{
name|int
name|c
init|=
name|compare
argument_list|(
name|args
argument_list|,
name|measure
operator|.
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|agg
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|measure
operator|.
name|agg
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|Boolean
operator|.
name|compare
argument_list|(
name|distinct
argument_list|,
name|measure
operator|.
name|distinct
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|digest
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|agg
argument_list|,
name|args
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|==
name|this
operator|||
name|obj
operator|instanceof
name|Measure
operator|&&
name|this
operator|.
name|agg
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Measure
operator|)
name|obj
operator|)
operator|.
name|agg
argument_list|)
operator|&&
name|this
operator|.
name|args
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Measure
operator|)
name|obj
operator|)
operator|.
name|args
argument_list|)
operator|&&
name|this
operator|.
name|distinct
operator|==
operator|(
operator|(
name|Measure
operator|)
name|obj
operator|)
operator|.
name|distinct
return|;
block|}
comment|/** Returns the set of distinct argument ordinals. */
specifier|public
name|ImmutableBitSet
name|argBitSet
parameter_list|()
block|{
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|bitSet
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Column
name|arg
range|:
name|args
control|)
block|{
name|bitSet
operator|.
name|set
argument_list|(
name|arg
operator|.
name|ordinal
argument_list|)
expr_stmt|;
block|}
return|return
name|bitSet
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns a list of argument ordinals. */
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|argOrdinals
parameter_list|()
block|{
return|return
name|Util
operator|.
name|transform
argument_list|(
name|args
argument_list|,
name|column
lambda|->
name|column
operator|.
name|ordinal
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|compare
parameter_list|(
name|List
argument_list|<
name|Column
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|Column
argument_list|>
name|list1
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|list0
operator|.
name|size
argument_list|()
argument_list|,
name|list1
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|o0
init|=
name|list0
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|ordinal
decl_stmt|;
specifier|final
name|int
name|o1
init|=
name|list1
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|ordinal
decl_stmt|;
specifier|final
name|int
name|c
init|=
name|Utilities
operator|.
name|compare
argument_list|(
name|o0
argument_list|,
name|o1
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
return|return
name|c
return|;
block|}
block|}
return|return
name|Utilities
operator|.
name|compare
argument_list|(
name|list0
operator|.
name|size
argument_list|()
argument_list|,
name|list1
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/** Copies this measure, mapping its arguments using a given function. */
name|Measure
name|copy
parameter_list|(
name|Function
argument_list|<
name|Column
argument_list|,
name|Column
argument_list|>
name|mapper
parameter_list|)
block|{
return|return
operator|new
name|Measure
argument_list|(
name|agg
argument_list|,
name|distinct
argument_list|,
name|name
argument_list|,
name|Util
operator|.
name|transform
argument_list|(
name|args
argument_list|,
name|mapper
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Column in a lattice. May be an a base column or an expression,    * and may have an additional alias that is unique    * within the entire lattice. */
specifier|public
specifier|abstract
specifier|static
class|class
name|Column
implements|implements
name|Comparable
argument_list|<
name|Column
argument_list|>
block|{
comment|/** Ordinal of the column within the lattice. */
specifier|public
specifier|final
name|int
name|ordinal
decl_stmt|;
comment|/** Alias of the column, unique within the lattice. Derived from the column      * name, automatically disambiguated if necessary. */
specifier|public
specifier|final
name|String
name|alias
decl_stmt|;
specifier|private
name|Column
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
comment|/** Converts a list of columns to a bit set of their ordinals. */
specifier|static
name|ImmutableBitSet
name|toBitSet
parameter_list|(
name|List
argument_list|<
name|Column
argument_list|>
name|columns
parameter_list|)
block|{
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|builder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Column
name|column
range|:
name|columns
control|)
block|{
name|builder
operator|.
name|set
argument_list|(
name|column
operator|.
name|ordinal
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Column
name|column
parameter_list|)
block|{
return|return
name|Utilities
operator|.
name|compare
argument_list|(
name|ordinal
argument_list|,
name|column
operator|.
name|ordinal
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|ordinal
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|==
name|this
operator|||
name|obj
operator|instanceof
name|Column
operator|&&
name|this
operator|.
name|ordinal
operator|==
operator|(
operator|(
name|Column
operator|)
name|obj
operator|)
operator|.
name|ordinal
return|;
block|}
specifier|public
specifier|abstract
name|void
name|toSql
parameter_list|(
name|SqlWriter
name|writer
parameter_list|)
function_decl|;
comment|/** The alias that SQL would give to this expression. */
specifier|public
specifier|abstract
name|String
name|defaultAlias
parameter_list|()
function_decl|;
block|}
comment|/** Column in a lattice. Columns are identified by table alias and    * column name, and may have an additional alias that is unique    * within the entire lattice. */
specifier|public
specifier|static
class|class
name|BaseColumn
extends|extends
name|Column
block|{
comment|/** Alias of the table reference that the column belongs to. */
specifier|public
specifier|final
name|String
name|table
decl_stmt|;
comment|/** Name of the column. Unique within the table reference, but not      * necessarily within the lattice. */
annotation|@
name|Nonnull
specifier|public
specifier|final
name|String
name|column
decl_stmt|;
specifier|private
name|BaseColumn
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|String
name|table
parameter_list|,
name|String
name|column
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|super
argument_list|(
name|ordinal
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|this
operator|.
name|table
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|this
operator|.
name|column
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|identifiers
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|identifiers
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|table
argument_list|,
name|column
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|toSql
parameter_list|(
name|SqlWriter
name|writer
parameter_list|)
block|{
name|writer
operator|.
name|dialect
operator|.
name|quoteIdentifier
argument_list|(
name|writer
operator|.
name|buf
argument_list|,
name|identifiers
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|defaultAlias
parameter_list|()
block|{
return|return
name|column
return|;
block|}
block|}
comment|/** Column in a lattice that is based upon a SQL expression. */
specifier|public
specifier|static
class|class
name|DerivedColumn
extends|extends
name|Column
block|{
annotation|@
name|Nonnull
specifier|public
specifier|final
name|RexNode
name|e
decl_stmt|;
annotation|@
name|Nonnull
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tables
decl_stmt|;
specifier|private
name|DerivedColumn
parameter_list|(
name|int
name|ordinal
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tables
parameter_list|)
block|{
name|super
argument_list|(
name|ordinal
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|this
operator|.
name|e
operator|=
name|e
expr_stmt|;
name|this
operator|.
name|tables
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tables
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|toString
argument_list|(
operator|new
name|Object
index|[]
block|{
name|e
block|,
name|alias
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|toSql
parameter_list|(
name|SqlWriter
name|writer
parameter_list|)
block|{
name|writer
operator|.
name|write
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|defaultAlias
parameter_list|()
block|{
comment|// there is no default alias for an expression
return|return
literal|null
return|;
block|}
block|}
comment|/** The information necessary to convert a column to SQL. */
specifier|public
specifier|static
class|class
name|SqlWriter
block|{
specifier|public
specifier|final
name|Lattice
name|lattice
decl_stmt|;
specifier|public
specifier|final
name|StringBuilder
name|buf
decl_stmt|;
specifier|public
specifier|final
name|SqlDialect
name|dialect
decl_stmt|;
specifier|private
specifier|final
name|SqlImplementor
operator|.
name|SimpleContext
name|context
decl_stmt|;
name|SqlWriter
parameter_list|(
name|Lattice
name|lattice
parameter_list|,
name|SqlDialect
name|dialect
parameter_list|,
name|StringBuilder
name|buf
parameter_list|,
name|SqlImplementor
operator|.
name|SimpleContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|lattice
operator|=
name|lattice
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|this
operator|.
name|dialect
operator|=
name|dialect
expr_stmt|;
block|}
comment|/** Re-binds this writer to a different {@link StringBuilder}. */
specifier|public
name|SqlWriter
name|with
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
return|return
operator|new
name|SqlWriter
argument_list|(
name|lattice
argument_list|,
name|dialect
argument_list|,
name|buf
argument_list|,
name|context
argument_list|)
return|;
block|}
comment|/** Writes an expression. */
specifier|public
name|SqlWriter
name|write
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
specifier|final
name|SqlNode
name|node
init|=
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|node
operator|.
name|toSqlString
argument_list|(
name|dialect
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
comment|/** Lattice builder. */
specifier|public
specifier|static
class|class
name|Builder
block|{
specifier|private
specifier|final
name|LatticeRootNode
name|rootNode
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|BaseColumn
argument_list|>
name|baseColumns
decl_stmt|;
specifier|private
specifier|final
name|ImmutableListMultimap
argument_list|<
name|String
argument_list|,
name|Column
argument_list|>
name|columnsByAlias
decl_stmt|;
specifier|private
specifier|final
name|SortedSet
argument_list|<
name|Measure
argument_list|>
name|defaultMeasureSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Tile
argument_list|>
name|tileListBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Boolean
argument_list|>
name|columnUses
init|=
name|LinkedHashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|CalciteSchema
name|rootSchema
decl_stmt|;
specifier|private
name|boolean
name|algorithm
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|algorithmMaxMillis
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|auto
init|=
literal|true
decl_stmt|;
specifier|private
name|Double
name|rowCountEstimate
decl_stmt|;
specifier|private
name|String
name|statisticProvider
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|DerivedColumn
argument_list|>
name|derivedColumnsByName
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|Builder
parameter_list|(
name|LatticeSpace
name|space
parameter_list|,
name|CalciteSchema
name|schema
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
name|this
operator|.
name|rootSchema
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|schema
operator|.
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rootSchema
operator|.
name|isRoot
argument_list|()
argument_list|,
literal|"must be root schema"
argument_list|)
expr_stmt|;
name|CalcitePrepare
operator|.
name|ConvertResult
name|parsed
init|=
name|Schemas
operator|.
name|convert
argument_list|(
name|MaterializedViewTable
operator|.
name|MATERIALIZATION_CONNECTION
argument_list|,
name|schema
argument_list|,
name|schema
operator|.
name|path
argument_list|(
literal|null
argument_list|)
argument_list|,
name|sql
argument_list|)
decl_stmt|;
comment|// Walk the join tree.
name|List
argument_list|<
name|RelNode
argument_list|>
name|relNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|int
index|[]
index|[]
argument_list|>
name|tempLinks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|populate
argument_list|(
name|relNodes
argument_list|,
name|tempLinks
argument_list|,
name|parsed
operator|.
name|root
operator|.
name|rel
argument_list|)
expr_stmt|;
comment|// Get aliases.
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|populateAliases
argument_list|(
operator|(
operator|(
name|SqlSelect
operator|)
name|parsed
operator|.
name|sqlNode
operator|)
operator|.
name|getFrom
argument_list|()
argument_list|,
name|aliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Build a graph.
specifier|final
name|DirectedGraph
argument_list|<
name|Vertex
argument_list|,
name|Edge
argument_list|>
name|graph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|(
name|Edge
operator|.
name|FACTORY
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Vertex
argument_list|>
name|vertices
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|String
argument_list|>
name|p
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|relNodes
argument_list|,
name|aliases
argument_list|)
control|)
block|{
specifier|final
name|LatticeTable
name|table
init|=
name|space
operator|.
name|register
argument_list|(
name|p
operator|.
name|left
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Vertex
name|vertex
init|=
operator|new
name|Vertex
argument_list|(
name|table
argument_list|,
name|p
operator|.
name|right
argument_list|)
decl_stmt|;
name|graph
operator|.
name|addVertex
argument_list|(
name|vertex
argument_list|)
expr_stmt|;
name|vertices
operator|.
name|add
argument_list|(
name|vertex
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
index|[]
index|[]
name|tempLink
range|:
name|tempLinks
control|)
block|{
specifier|final
name|Vertex
name|source
init|=
name|vertices
operator|.
name|get
argument_list|(
name|tempLink
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|Vertex
name|target
init|=
name|vertices
operator|.
name|get
argument_list|(
name|tempLink
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Edge
name|edge
init|=
name|graph
operator|.
name|getEdge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|==
literal|null
condition|)
block|{
name|edge
operator|=
name|graph
operator|.
name|addEdge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|edge
operator|.
name|pairs
operator|.
name|add
argument_list|(
name|IntPair
operator|.
name|of
argument_list|(
name|tempLink
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|tempLink
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Convert the graph into a tree of nodes, each connected to a parent and
comment|// with a join condition to that parent.
name|MutableNode
name|root
init|=
literal|null
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|LatticeTable
argument_list|,
name|MutableNode
argument_list|>
name|map
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Vertex
name|vertex
range|:
name|TopologicalOrderIterator
operator|.
name|of
argument_list|(
name|graph
argument_list|)
control|)
block|{
specifier|final
name|List
argument_list|<
name|Edge
argument_list|>
name|edges
init|=
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|vertex
argument_list|)
decl_stmt|;
name|MutableNode
name|node
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|edges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"root node must not have relationships: "
operator|+
name|vertex
argument_list|)
throw|;
block|}
name|root
operator|=
name|node
operator|=
operator|new
name|MutableNode
argument_list|(
name|vertex
operator|.
name|table
argument_list|)
expr_stmt|;
name|node
operator|.
name|alias
operator|=
name|vertex
operator|.
name|alias
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|edges
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"child node must have precisely one parent: "
operator|+
name|vertex
argument_list|)
throw|;
block|}
specifier|final
name|Edge
name|edge
init|=
name|edges
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|MutableNode
name|parent
init|=
name|map
operator|.
name|get
argument_list|(
name|edge
operator|.
name|getSource
argument_list|()
operator|.
name|table
argument_list|)
decl_stmt|;
specifier|final
name|Step
name|step
init|=
name|Step
operator|.
name|create
argument_list|(
name|edge
operator|.
name|getSource
argument_list|()
operator|.
name|table
argument_list|,
name|edge
operator|.
name|getTarget
argument_list|()
operator|.
name|table
argument_list|,
name|edge
operator|.
name|pairs
argument_list|,
name|space
argument_list|)
decl_stmt|;
name|node
operator|=
operator|new
name|MutableNode
argument_list|(
name|vertex
operator|.
name|table
argument_list|,
name|parent
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|node
operator|.
name|alias
operator|=
name|vertex
operator|.
name|alias
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|vertex
operator|.
name|table
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
assert|assert
name|root
operator|!=
literal|null
assert|;
specifier|final
name|Fixer
name|fixer
init|=
operator|new
name|Fixer
argument_list|()
decl_stmt|;
name|fixer
operator|.
name|fixUp
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|baseColumns
operator|=
name|fixer
operator|.
name|columnList
operator|.
name|build
argument_list|()
expr_stmt|;
name|columnsByAlias
operator|=
name|fixer
operator|.
name|columnAliasList
operator|.
name|build
argument_list|()
expr_stmt|;
name|rootNode
operator|=
operator|new
name|LatticeRootNode
argument_list|(
name|space
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a Builder based upon a mutable node. */
name|Builder
parameter_list|(
name|LatticeSpace
name|space
parameter_list|,
name|CalciteSchema
name|schema
parameter_list|,
name|MutableNode
name|mutableNode
parameter_list|)
block|{
name|this
operator|.
name|rootSchema
operator|=
name|schema
expr_stmt|;
specifier|final
name|Fixer
name|fixer
init|=
operator|new
name|Fixer
argument_list|()
decl_stmt|;
name|fixer
operator|.
name|fixUp
argument_list|(
name|mutableNode
argument_list|)
expr_stmt|;
specifier|final
name|LatticeRootNode
name|node0
init|=
operator|new
name|LatticeRootNode
argument_list|(
name|space
argument_list|,
name|mutableNode
argument_list|)
decl_stmt|;
specifier|final
name|LatticeRootNode
name|node1
init|=
name|space
operator|.
name|nodeMap
operator|.
name|get
argument_list|(
name|node0
operator|.
name|digest
argument_list|)
decl_stmt|;
specifier|final
name|LatticeRootNode
name|node
decl_stmt|;
if|if
condition|(
name|node1
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|node1
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|node0
expr_stmt|;
name|space
operator|.
name|nodeMap
operator|.
name|put
argument_list|(
name|node0
operator|.
name|digest
argument_list|,
name|node0
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|rootNode
operator|=
name|node
expr_stmt|;
name|baseColumns
operator|=
name|fixer
operator|.
name|columnList
operator|.
name|build
argument_list|()
expr_stmt|;
name|columnsByAlias
operator|=
name|fixer
operator|.
name|columnAliasList
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|/** Sets the "auto" attribute (default true). */
specifier|public
name|Builder
name|auto
parameter_list|(
name|boolean
name|auto
parameter_list|)
block|{
name|this
operator|.
name|auto
operator|=
name|auto
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Sets the "algorithm" attribute (default false). */
specifier|public
name|Builder
name|algorithm
parameter_list|(
name|boolean
name|algorithm
parameter_list|)
block|{
name|this
operator|.
name|algorithm
operator|=
name|algorithm
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Sets the "algorithmMaxMillis" attribute (default -1). */
specifier|public
name|Builder
name|algorithmMaxMillis
parameter_list|(
name|long
name|algorithmMaxMillis
parameter_list|)
block|{
name|this
operator|.
name|algorithmMaxMillis
operator|=
name|algorithmMaxMillis
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Sets the "rowCountEstimate" attribute (default null). */
specifier|public
name|Builder
name|rowCountEstimate
parameter_list|(
name|double
name|rowCountEstimate
parameter_list|)
block|{
name|this
operator|.
name|rowCountEstimate
operator|=
name|rowCountEstimate
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Sets the "statisticProvider" attribute.      *      *<p>If not set, the lattice will use {@link Lattices#CACHED_SQL}. */
specifier|public
name|Builder
name|statisticProvider
parameter_list|(
name|String
name|statisticProvider
parameter_list|)
block|{
name|this
operator|.
name|statisticProvider
operator|=
name|statisticProvider
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Builds a lattice. */
specifier|public
name|Lattice
name|build
parameter_list|()
block|{
name|LatticeStatisticProvider
operator|.
name|Factory
name|statisticProvider
init|=
name|this
operator|.
name|statisticProvider
operator|!=
literal|null
condition|?
name|AvaticaUtils
operator|.
name|instantiatePlugin
argument_list|(
name|LatticeStatisticProvider
operator|.
name|Factory
operator|.
name|class
argument_list|,
name|this
operator|.
name|statisticProvider
argument_list|)
else|:
name|Lattices
operator|.
name|CACHED_SQL
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rootSchema
operator|.
name|isRoot
argument_list|()
argument_list|,
literal|"must be root schema"
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Column
argument_list|>
name|columnBuilder
init|=
name|ImmutableList
operator|.
expr|<
name|Column
operator|>
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|baseColumns
argument_list|)
operator|.
name|addAll
argument_list|(
name|derivedColumnsByName
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|Lattice
argument_list|(
name|rootSchema
argument_list|,
name|rootNode
argument_list|,
name|auto
argument_list|,
name|algorithm
argument_list|,
name|algorithmMaxMillis
argument_list|,
name|statisticProvider
argument_list|,
name|rowCountEstimate
argument_list|,
name|columnBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|ImmutableSortedSet
operator|.
name|copyOf
argument_list|(
name|defaultMeasureSet
argument_list|)
argument_list|,
name|tileListBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|ImmutableListMultimap
operator|.
name|copyOf
argument_list|(
name|columnUses
argument_list|)
argument_list|)
return|;
block|}
comment|/** Resolves the arguments of a      * {@link org.apache.calcite.model.JsonMeasure}. They must either be null,      * a string, or a list of strings. Throws if the structure is invalid, or if      * any of the columns do not exist in the lattice. */
specifier|public
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|resolveArgs
parameter_list|(
annotation|@
name|Nullable
name|Object
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
literal|null
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
if|else if
condition|(
name|args
operator|instanceof
name|String
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|resolveColumnByAlias
argument_list|(
operator|(
name|String
operator|)
name|args
argument_list|)
argument_list|)
return|;
block|}
if|else if
condition|(
name|args
operator|instanceof
name|List
condition|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Column
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
operator|(
name|List
operator|)
name|args
control|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|String
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|resolveColumnByAlias
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Measure arguments must be a string or a list of strings; argument: "
operator|+
name|o
argument_list|)
throw|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Measure arguments must be a string or a list of strings"
argument_list|)
throw|;
block|}
block|}
comment|/** Looks up a column in this lattice by alias. The alias must be unique      * within the lattice.      */
specifier|private
name|Column
name|resolveColumnByAlias
parameter_list|(
name|String
name|name
parameter_list|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|list
init|=
name|columnsByAlias
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
operator|||
name|list
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown lattice column '"
operator|+
name|name
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|else if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Lattice column alias '"
operator|+
name|name
operator|+
literal|"' is not unique"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Column
name|resolveColumn
parameter_list|(
name|Object
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|instanceof
name|String
condition|)
block|{
return|return
name|resolveColumnByAlias
argument_list|(
operator|(
name|String
operator|)
name|name
argument_list|)
return|;
block|}
if|if
condition|(
name|name
operator|instanceof
name|List
condition|)
block|{
name|List
name|list
init|=
operator|(
name|List
operator|)
name|name
decl_stmt|;
switch|switch
condition|(
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
specifier|final
name|Object
name|alias
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|instanceof
name|String
condition|)
block|{
return|return
name|resolveColumnByAlias
argument_list|(
operator|(
name|String
operator|)
name|alias
argument_list|)
return|;
block|}
break|break;
case|case
literal|2
case|:
specifier|final
name|Object
name|table
init|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|column
init|=
name|list
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|instanceof
name|String
operator|&&
name|column
operator|instanceof
name|String
condition|)
block|{
return|return
name|resolveQualifiedColumn
argument_list|(
operator|(
name|String
operator|)
name|table
argument_list|,
operator|(
name|String
operator|)
name|column
argument_list|)
return|;
block|}
break|break;
block|}
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Lattice column reference must be a string or a list of 1 or 2 strings; column: "
operator|+
name|name
argument_list|)
throw|;
block|}
specifier|private
name|Column
name|resolveQualifiedColumn
parameter_list|(
name|String
name|table
parameter_list|,
name|String
name|column
parameter_list|)
block|{
for|for
control|(
name|BaseColumn
name|column1
range|:
name|baseColumns
control|)
block|{
if|if
condition|(
name|column1
operator|.
name|table
operator|.
name|equals
argument_list|(
name|table
argument_list|)
operator|&&
name|column1
operator|.
name|column
operator|.
name|equals
argument_list|(
name|column
argument_list|)
condition|)
block|{
return|return
name|column1
return|;
block|}
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown lattice column ["
operator|+
name|table
operator|+
literal|", "
operator|+
name|column
operator|+
literal|"]"
argument_list|)
throw|;
block|}
specifier|public
name|Measure
name|resolveMeasure
parameter_list|(
name|String
name|aggName
parameter_list|,
name|boolean
name|distinct
parameter_list|,
annotation|@
name|Nullable
name|Object
name|args
parameter_list|)
block|{
specifier|final
name|SqlAggFunction
name|agg
init|=
name|resolveAgg
argument_list|(
name|aggName
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|list
init|=
name|resolveArgs
argument_list|(
name|args
argument_list|)
decl_stmt|;
return|return
operator|new
name|Measure
argument_list|(
name|agg
argument_list|,
name|distinct
argument_list|,
name|aggName
argument_list|,
name|list
argument_list|)
return|;
block|}
specifier|private
name|SqlAggFunction
name|resolveAgg
parameter_list|(
name|String
name|aggName
parameter_list|)
block|{
if|if
condition|(
name|aggName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"count"
argument_list|)
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|COUNT
return|;
block|}
if|else if
condition|(
name|aggName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"sum"
argument_list|)
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|SUM
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown lattice aggregate function "
operator|+
name|aggName
argument_list|)
throw|;
block|}
block|}
comment|/** Adds a measure, if it does not already exist.      * Returns false if an identical measure already exists. */
specifier|public
name|boolean
name|addMeasure
parameter_list|(
name|Measure
name|measure
parameter_list|)
block|{
return|return
name|defaultMeasureSet
operator|.
name|add
argument_list|(
name|measure
argument_list|)
return|;
block|}
specifier|public
name|void
name|addTile
parameter_list|(
name|Tile
name|tile
parameter_list|)
block|{
name|tileListBuilder
operator|.
name|add
argument_list|(
name|tile
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Column
name|column
parameter_list|(
name|int
name|table
parameter_list|,
name|int
name|column
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|LatticeNode
name|descendant
range|:
name|rootNode
operator|.
name|descendants
control|)
block|{
if|if
condition|(
name|table
operator|--
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|i
operator|+=
name|descendant
operator|.
name|table
operator|.
name|t
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
name|baseColumns
operator|.
name|get
argument_list|(
name|i
operator|+
name|column
argument_list|)
return|;
block|}
name|Column
name|pathOffsetToColumn
parameter_list|(
name|Path
name|path
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
specifier|final
name|int
name|i
init|=
name|rootNode
operator|.
name|paths
operator|.
name|indexOf
argument_list|(
name|path
argument_list|)
decl_stmt|;
specifier|final
name|LatticeNode
name|node
init|=
name|rootNode
operator|.
name|descendants
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|int
name|c
init|=
name|node
operator|.
name|startCol
operator|+
name|offset
decl_stmt|;
if|if
condition|(
name|c
operator|>=
name|node
operator|.
name|endCol
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
return|return
name|baseColumns
operator|.
name|get
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/** Adds a lattice column based on a SQL expression,      * or returns a column based on the same expression seen previously. */
specifier|public
name|Column
name|expression
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|String
name|alias
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|tableAliases
parameter_list|)
block|{
return|return
name|derivedColumnsByName
operator|.
name|computeIfAbsent
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|k
lambda|->
block|{
specifier|final
name|int
name|derivedOrdinal
init|=
name|derivedColumnsByName
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
name|ordinal
init|=
name|baseColumns
operator|.
name|size
argument_list|()
operator|+
name|derivedOrdinal
decl_stmt|;
return|return
operator|new
name|DerivedColumn
argument_list|(
name|ordinal
argument_list|,
name|Util
operator|.
name|first
argument_list|(
name|alias
argument_list|,
literal|"e$"
operator|+
name|derivedOrdinal
argument_list|)
argument_list|,
name|e
argument_list|,
name|tableAliases
argument_list|)
return|;
block|}
argument_list|)
return|;
block|}
comment|/** Records a use of a column.      *      * @param column Column      * @param measure Whether this use is as an argument to a measure;      *                e.g. "sum(x + y)" is a measure use of the expression      *                "x + y"; "group by x + y" is not      */
specifier|public
name|void
name|use
parameter_list|(
name|Column
name|column
parameter_list|,
name|boolean
name|measure
parameter_list|)
block|{
name|columnUses
operator|.
name|put
argument_list|(
name|column
operator|.
name|ordinal
argument_list|,
name|measure
argument_list|)
expr_stmt|;
block|}
comment|/** Work space for fixing up a tree of mutable nodes. */
specifier|private
specifier|static
class|class
name|Fixer
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|columnAliases
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|MutableNode
argument_list|>
name|seen
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|BaseColumn
argument_list|>
name|columnList
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableListMultimap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Column
argument_list|>
name|columnAliasList
init|=
name|ImmutableListMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|c
decl_stmt|;
name|void
name|fixUp
parameter_list|(
name|MutableNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|seen
operator|.
name|add
argument_list|(
name|node
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cyclic query graph"
argument_list|)
throw|;
block|}
if|if
condition|(
name|node
operator|.
name|alias
operator|==
literal|null
condition|)
block|{
name|node
operator|.
name|alias
operator|=
name|Util
operator|.
name|last
argument_list|(
name|node
operator|.
name|table
operator|.
name|t
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|alias
operator|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|node
operator|.
name|alias
argument_list|,
name|aliases
argument_list|,
name|SqlValidatorUtil
operator|.
name|ATTEMPT_SUGGESTER
argument_list|)
expr_stmt|;
name|node
operator|.
name|startCol
operator|=
name|c
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|node
operator|.
name|table
operator|.
name|t
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
specifier|final
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|name
argument_list|,
name|columnAliases
argument_list|,
name|SqlValidatorUtil
operator|.
name|ATTEMPT_SUGGESTER
argument_list|)
decl_stmt|;
specifier|final
name|BaseColumn
name|column
init|=
operator|new
name|BaseColumn
argument_list|(
name|c
operator|++
argument_list|,
name|node
operator|.
name|alias
argument_list|,
name|name
argument_list|,
name|alias
argument_list|)
decl_stmt|;
name|columnList
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
name|columnAliasList
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|column
argument_list|)
expr_stmt|;
comment|// name before it is made unique
block|}
name|node
operator|.
name|endCol
operator|=
name|c
expr_stmt|;
assert|assert
name|MutableNode
operator|.
name|ORDERING
operator|.
name|isStrictlyOrdered
argument_list|(
name|node
operator|.
name|children
argument_list|)
operator|:
name|node
operator|.
name|children
assert|;
for|for
control|(
name|MutableNode
name|child
range|:
name|node
operator|.
name|children
control|)
block|{
name|fixUp
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Materialized aggregate within a lattice. */
specifier|public
specifier|static
class|class
name|Tile
block|{
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Measure
argument_list|>
name|measures
decl_stmt|;
specifier|public
specifier|final
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|dimensions
decl_stmt|;
specifier|public
specifier|final
name|ImmutableBitSet
name|bitSet
decl_stmt|;
specifier|public
name|Tile
parameter_list|(
name|ImmutableList
argument_list|<
name|Measure
argument_list|>
name|measures
parameter_list|,
name|ImmutableList
argument_list|<
name|Column
argument_list|>
name|dimensions
parameter_list|)
block|{
name|this
operator|.
name|measures
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|measures
argument_list|)
expr_stmt|;
name|this
operator|.
name|dimensions
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|dimensions
argument_list|)
expr_stmt|;
assert|assert
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|isStrictlyOrdered
argument_list|(
name|dimensions
argument_list|)
assert|;
assert|assert
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|isStrictlyOrdered
argument_list|(
name|measures
argument_list|)
assert|;
name|bitSet
operator|=
name|Column
operator|.
name|toBitSet
argument_list|(
name|dimensions
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|TileBuilder
name|builder
parameter_list|()
block|{
return|return
operator|new
name|TileBuilder
argument_list|()
return|;
block|}
specifier|public
name|ImmutableBitSet
name|bitSet
parameter_list|()
block|{
return|return
name|bitSet
return|;
block|}
block|}
comment|/** Tile builder. */
specifier|public
specifier|static
class|class
name|TileBuilder
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Measure
argument_list|>
name|measureBuilder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Column
argument_list|>
name|dimensionListBuilder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|Tile
name|build
parameter_list|()
block|{
return|return
operator|new
name|Tile
argument_list|(
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|immutableSortedCopy
argument_list|(
name|measureBuilder
argument_list|)
argument_list|,
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|immutableSortedCopy
argument_list|(
name|dimensionListBuilder
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|addMeasure
parameter_list|(
name|Measure
name|measure
parameter_list|)
block|{
name|measureBuilder
operator|.
name|add
argument_list|(
name|measure
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addDimension
parameter_list|(
name|Column
name|column
parameter_list|)
block|{
name|dimensionListBuilder
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

