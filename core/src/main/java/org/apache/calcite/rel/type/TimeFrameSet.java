begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnitRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|SqlFunctions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NameMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|fraction
operator|.
name|BigFraction
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|floorDiv
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|floorMod
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/** Set of {@link TimeFrame} definitions.  *  *<p>Every SQL statement has a time frame set, and is accessed via  * {@link RelDataTypeSystem#deriveTimeFrameSet(TimeFrameSet)}. If you want to  * use a custom set of time frames, you should override that method. */
end_comment

begin_class
specifier|public
class|class
name|TimeFrameSet
block|{
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|TimeFrames
operator|.
name|TimeFrameImpl
argument_list|>
name|map
decl_stmt|;
specifier|final
name|ImmutableMultimap
argument_list|<
name|TimeFrames
operator|.
name|TimeFrameImpl
argument_list|,
name|TimeFrames
operator|.
name|TimeFrameImpl
argument_list|>
name|rollupMap
decl_stmt|;
specifier|private
specifier|final
name|NameMap
argument_list|<
name|TimeFrames
operator|.
name|TimeFrameImpl
argument_list|>
name|nameMap
decl_stmt|;
name|TimeFrameSet
parameter_list|(
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|TimeFrames
operator|.
name|TimeFrameImpl
argument_list|>
name|map
parameter_list|,
name|ImmutableMultimap
argument_list|<
name|TimeFrames
operator|.
name|TimeFrameImpl
argument_list|,
name|TimeFrames
operator|.
name|TimeFrameImpl
argument_list|>
name|rollupMap
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|requireNonNull
argument_list|(
name|map
argument_list|,
literal|"map"
argument_list|)
expr_stmt|;
name|this
operator|.
name|nameMap
operator|=
name|NameMap
operator|.
name|immutableCopyOf
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|rollupMap
operator|=
name|requireNonNull
argument_list|(
name|rollupMap
argument_list|,
literal|"rollupMap"
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a Builder. */
specifier|public
specifier|static
name|Builder
name|builder
parameter_list|()
block|{
return|return
operator|new
name|TimeFrames
operator|.
name|BuilderImpl
argument_list|()
return|;
block|}
comment|/** Returns the time frame with the given name (case-insensitive),    * or returns null. */
specifier|public
annotation|@
name|Nullable
name|TimeFrame
name|getOpt
parameter_list|(
name|String
name|name
parameter_list|)
block|{
specifier|final
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|TimeFrames
operator|.
name|TimeFrameImpl
argument_list|>
name|range
init|=
name|nameMap
operator|.
name|range
argument_list|(
name|name
argument_list|,
literal|false
argument_list|)
decl_stmt|;
annotation|@
name|Nullable
name|TimeFrame
name|timeFrame
init|=
name|Iterables
operator|.
name|getFirst
argument_list|(
name|range
operator|.
name|values
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|timeFrame
operator|instanceof
name|TimeFrames
operator|.
name|AliasFrame
condition|)
block|{
name|timeFrame
operator|=
operator|(
operator|(
name|TimeFrames
operator|.
name|AliasFrame
operator|)
name|timeFrame
operator|)
operator|.
name|frame
expr_stmt|;
block|}
return|return
name|timeFrame
return|;
block|}
comment|/** Returns the time frame with the given name,    * or throws {@link IllegalArgumentException} if not found.    * If {@code name} is an alias, resolves to the underlying frame. */
specifier|public
name|TimeFrame
name|get
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|TimeFrame
name|timeFrame
init|=
name|getOpt
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeFrame
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unknown frame: "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|timeFrame
return|;
block|}
comment|/** Returns the time frame with the given name,    * or throws {@link IllegalArgumentException}. */
specifier|public
name|TimeFrame
name|get
parameter_list|(
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|timeUnit
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
comment|/** Computes "FLOOR(date TO frame)", where {@code date} is the number of    * days since UNIX Epoch. */
specifier|public
name|int
name|floorDate
parameter_list|(
name|int
name|date
parameter_list|,
name|TimeFrame
name|frame
parameter_list|)
block|{
return|return
name|floorCeilDate
argument_list|(
name|date
argument_list|,
name|frame
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Computes "FLOOR(date TO frame)", where {@code date} is the number of    * days since UNIX Epoch. */
specifier|public
name|int
name|ceilDate
parameter_list|(
name|int
name|date
parameter_list|,
name|TimeFrame
name|frame
parameter_list|)
block|{
return|return
name|floorCeilDate
argument_list|(
name|date
argument_list|,
name|frame
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Computes "FLOOR(timestamp TO frame)" or "FLOOR(timestamp TO frame)",    * where {@code date} is the number of days since UNIX Epoch. */
specifier|private
name|int
name|floorCeilDate
parameter_list|(
name|int
name|date
parameter_list|,
name|TimeFrame
name|frame
parameter_list|,
name|boolean
name|ceil
parameter_list|)
block|{
specifier|final
name|TimeFrame
name|dayFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|DAY
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perDay
init|=
name|frame
operator|.
name|per
argument_list|(
name|dayFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perDay
operator|!=
literal|null
operator|&&
name|perDay
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|int
name|m
init|=
name|perDay
operator|.
name|getDenominator
argument_list|()
operator|.
name|intValueExact
argument_list|()
decl_stmt|;
comment|// 7 for WEEK
specifier|final
name|int
name|mod
init|=
name|floorMod
argument_list|(
name|date
operator|-
name|frame
operator|.
name|dateEpoch
argument_list|()
argument_list|,
name|m
argument_list|)
decl_stmt|;
return|return
name|date
operator|-
name|mod
operator|+
operator|(
name|ceil
condition|?
name|m
else|:
literal|0
operator|)
return|;
block|}
specifier|final
name|TimeFrame
name|monthFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MONTH
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMonth
init|=
name|frame
operator|.
name|per
argument_list|(
name|monthFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMonth
operator|!=
literal|null
operator|&&
name|perMonth
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|int
name|y2
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|unixDateExtract
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|,
name|date
argument_list|)
decl_stmt|;
specifier|final
name|int
name|m2
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|unixDateExtract
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|,
name|date
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fullMonth
init|=
name|TimeFrames
operator|.
name|fullMonth
argument_list|(
name|y2
argument_list|,
name|m2
argument_list|)
decl_stmt|;
specifier|final
name|int
name|m
init|=
name|perMonth
operator|.
name|getDenominator
argument_list|()
operator|.
name|intValueExact
argument_list|()
decl_stmt|;
comment|// e.g. 12 for YEAR
specifier|final
name|int
name|mod
init|=
name|floorMod
argument_list|(
name|fullMonth
operator|-
name|frame
operator|.
name|monthEpoch
argument_list|()
argument_list|,
name|m
argument_list|)
decl_stmt|;
return|return
name|TimeFrames
operator|.
name|mdToUnixDate
argument_list|(
name|fullMonth
operator|-
name|mod
operator|+
operator|(
name|ceil
condition|?
name|m
else|:
literal|0
operator|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
specifier|final
name|TimeFrame
name|isoYearFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|ISOYEAR
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perIsoYear
init|=
name|frame
operator|.
name|per
argument_list|(
name|isoYearFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perIsoYear
operator|!=
literal|null
operator|&&
name|perIsoYear
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
return|return
name|TimeFrames
operator|.
name|floorCeilIsoYear
argument_list|(
name|date
argument_list|,
name|ceil
argument_list|)
return|;
block|}
return|return
name|date
return|;
block|}
comment|/** Computes "FLOOR(timestamp TO frame)", where {@code ts} is the number of    * milliseconds since UNIX Epoch. */
specifier|public
name|long
name|floorTimestamp
parameter_list|(
name|long
name|ts
parameter_list|,
name|TimeFrame
name|frame
parameter_list|)
block|{
return|return
name|floorCeilTimestamp
argument_list|(
name|ts
argument_list|,
name|frame
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Computes "CEIL(timestamp TO frame)", where {@code ts} is the number of    * milliseconds since UNIX Epoch. */
specifier|public
name|long
name|ceilTimestamp
parameter_list|(
name|long
name|ts
parameter_list|,
name|TimeFrame
name|frame
parameter_list|)
block|{
return|return
name|floorCeilTimestamp
argument_list|(
name|ts
argument_list|,
name|frame
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Computes "FLOOR(ts TO frame)" or "CEIL(ts TO frame)",    * where {@code ts} is the number of milliseconds since UNIX Epoch. */
specifier|private
name|long
name|floorCeilTimestamp
parameter_list|(
name|long
name|ts
parameter_list|,
name|TimeFrame
name|frame
parameter_list|,
name|boolean
name|ceil
parameter_list|)
block|{
specifier|final
name|TimeFrame
name|millisecondFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MILLISECOND
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMillisecond
init|=
name|frame
operator|.
name|per
argument_list|(
name|millisecondFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMillisecond
operator|!=
literal|null
operator|&&
name|perMillisecond
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|long
name|m
init|=
name|perMillisecond
operator|.
name|getDenominator
argument_list|()
operator|.
name|longValue
argument_list|()
decl_stmt|;
comment|// e.g. 60,000 for MINUTE
specifier|final
name|long
name|mod
init|=
name|floorMod
argument_list|(
name|ts
operator|-
name|frame
operator|.
name|timestampEpoch
argument_list|()
argument_list|,
name|m
argument_list|)
decl_stmt|;
return|return
name|ts
operator|-
name|mod
operator|+
operator|(
name|ceil
condition|?
name|m
else|:
literal|0
operator|)
return|;
block|}
specifier|final
name|TimeFrame
name|monthFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MONTH
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMonth
init|=
name|frame
operator|.
name|per
argument_list|(
name|monthFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMonth
operator|!=
literal|null
operator|&&
name|perMonth
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|long
name|ts2
init|=
name|floorTimestamp
argument_list|(
name|ts
argument_list|,
name|get
argument_list|(
name|TimeUnit
operator|.
name|DAY
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|d2
init|=
operator|(
name|int
operator|)
operator|(
name|ts2
operator|/
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
operator|)
decl_stmt|;
specifier|final
name|int
name|y2
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|unixDateExtract
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|,
name|d2
argument_list|)
decl_stmt|;
specifier|final
name|int
name|m2
init|=
operator|(
name|int
operator|)
name|DateTimeUtils
operator|.
name|unixDateExtract
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|,
name|d2
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fullMonth
init|=
name|TimeFrames
operator|.
name|fullMonth
argument_list|(
name|y2
argument_list|,
name|m2
argument_list|)
decl_stmt|;
specifier|final
name|int
name|m
init|=
name|perMonth
operator|.
name|getDenominator
argument_list|()
operator|.
name|intValueExact
argument_list|()
decl_stmt|;
comment|// e.g. 12 for YEAR
specifier|final
name|int
name|mod
init|=
name|floorMod
argument_list|(
name|fullMonth
operator|-
name|frame
operator|.
name|monthEpoch
argument_list|()
argument_list|,
name|m
argument_list|)
decl_stmt|;
return|return
name|TimeFrames
operator|.
name|unixTimestamp
argument_list|(
name|fullMonth
operator|-
name|mod
operator|+
operator|(
name|ceil
condition|?
name|m
else|:
literal|0
operator|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|final
name|TimeFrame
name|isoYearFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|ISOYEAR
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perIsoYear
init|=
name|frame
operator|.
name|per
argument_list|(
name|isoYearFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perIsoYear
operator|!=
literal|null
operator|&&
name|perIsoYear
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|long
name|ts2
init|=
name|floorTimestamp
argument_list|(
name|ts
argument_list|,
name|get
argument_list|(
name|TimeUnit
operator|.
name|DAY
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|d2
init|=
operator|(
name|int
operator|)
operator|(
name|ts2
operator|/
name|DateTimeUtils
operator|.
name|MILLIS_PER_DAY
operator|)
decl_stmt|;
return|return
operator|(
name|long
operator|)
name|TimeFrames
operator|.
name|floorCeilIsoYear
argument_list|(
name|d2
argument_list|,
name|ceil
argument_list|)
operator|*
name|MILLIS_PER_DAY
return|;
block|}
return|return
name|ts
return|;
block|}
comment|/** Returns the time unit that this time frame is based upon, or null. */
specifier|public
annotation|@
name|Nullable
name|TimeUnit
name|getUnit
parameter_list|(
name|TimeFrame
name|timeFrame
parameter_list|)
block|{
specifier|final
name|TimeUnit
name|timeUnit
init|=
name|Util
operator|.
name|enumVal
argument_list|(
name|TimeUnit
operator|.
name|class
argument_list|,
name|timeFrame
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeUnit
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TimeFrame
name|timeFrame1
init|=
name|getOpt
argument_list|(
name|timeUnit
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|timeFrame1
argument_list|,
name|timeFrame
argument_list|)
condition|?
name|timeUnit
else|:
literal|null
return|;
block|}
specifier|public
name|int
name|addDate
parameter_list|(
name|int
name|date
parameter_list|,
name|int
name|interval
parameter_list|,
name|TimeFrame
name|frame
parameter_list|)
block|{
specifier|final
name|TimeFrame
name|dayFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|DAY
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perDay
init|=
name|frame
operator|.
name|per
argument_list|(
name|dayFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perDay
operator|!=
literal|null
operator|&&
name|perDay
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|int
name|m
init|=
name|perDay
operator|.
name|getDenominator
argument_list|()
operator|.
name|intValueExact
argument_list|()
decl_stmt|;
comment|// 7 for WEEK
return|return
name|date
operator|+
name|interval
operator|*
name|m
return|;
block|}
specifier|final
name|TimeFrame
name|monthFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MONTH
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMonth
init|=
name|frame
operator|.
name|per
argument_list|(
name|monthFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMonth
operator|!=
literal|null
operator|&&
name|perMonth
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|int
name|m
init|=
name|perMonth
operator|.
name|getDenominator
argument_list|()
operator|.
name|intValueExact
argument_list|()
decl_stmt|;
comment|// e.g. 12 for YEAR
return|return
name|SqlFunctions
operator|.
name|addMonths
argument_list|(
name|date
argument_list|,
name|interval
operator|*
name|m
argument_list|)
return|;
block|}
comment|// Unknown time frame. Return the original value unchanged.
return|return
name|date
return|;
block|}
specifier|public
name|long
name|addTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|,
name|long
name|interval
parameter_list|,
name|TimeFrame
name|frame
parameter_list|)
block|{
specifier|final
name|TimeFrame
name|msFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MILLISECOND
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMilli
init|=
name|frame
operator|.
name|per
argument_list|(
name|msFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMilli
operator|!=
literal|null
operator|&&
name|perMilli
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
comment|// 1,000 for SECOND, 86,400,000 for DAY
specifier|final
name|long
name|m
init|=
name|perMilli
operator|.
name|getDenominator
argument_list|()
operator|.
name|longValueExact
argument_list|()
decl_stmt|;
return|return
name|timestamp
operator|+
name|interval
operator|*
name|m
return|;
block|}
specifier|final
name|TimeFrame
name|monthFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MONTH
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMonth
init|=
name|frame
operator|.
name|per
argument_list|(
name|monthFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMonth
operator|!=
literal|null
operator|&&
name|perMonth
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|long
name|m
init|=
name|perMonth
operator|.
name|getDenominator
argument_list|()
operator|.
name|longValueExact
argument_list|()
decl_stmt|;
comment|// e.g. 12 for YEAR
return|return
name|SqlFunctions
operator|.
name|addMonths
argument_list|(
name|timestamp
argument_list|,
operator|(
name|int
operator|)
operator|(
name|interval
operator|*
name|m
operator|)
argument_list|)
return|;
block|}
comment|// Unknown time frame. Return the original value unchanged.
return|return
name|timestamp
return|;
block|}
specifier|public
name|int
name|diffDate
parameter_list|(
name|int
name|date
parameter_list|,
name|int
name|date2
parameter_list|,
name|TimeFrame
name|frame
parameter_list|)
block|{
specifier|final
name|TimeFrame
name|dayFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|DAY
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perDay
init|=
name|frame
operator|.
name|per
argument_list|(
name|dayFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perDay
operator|!=
literal|null
operator|&&
name|perDay
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|int
name|m
init|=
name|perDay
operator|.
name|getDenominator
argument_list|()
operator|.
name|intValueExact
argument_list|()
decl_stmt|;
comment|// 7 for WEEK
specifier|final
name|int
name|delta
init|=
name|date2
operator|-
name|date
decl_stmt|;
return|return
name|floorDiv
argument_list|(
name|delta
argument_list|,
name|m
argument_list|)
return|;
block|}
specifier|final
name|TimeFrame
name|monthFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MONTH
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMonth
init|=
name|frame
operator|.
name|per
argument_list|(
name|monthFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMonth
operator|!=
literal|null
operator|&&
name|perMonth
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|int
name|m
init|=
name|perMonth
operator|.
name|getDenominator
argument_list|()
operator|.
name|intValueExact
argument_list|()
decl_stmt|;
comment|// e.g. 12 for YEAR
specifier|final
name|int
name|delta
init|=
name|DateTimeUtils
operator|.
name|subtractMonths
argument_list|(
name|date2
argument_list|,
name|date
argument_list|)
decl_stmt|;
return|return
name|floorDiv
argument_list|(
name|delta
argument_list|,
name|m
argument_list|)
return|;
block|}
comment|// Unknown time frame. Return the original value unchanged.
return|return
name|date
return|;
block|}
specifier|public
name|long
name|diffTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|,
name|long
name|timestamp2
parameter_list|,
name|TimeFrame
name|frame
parameter_list|)
block|{
specifier|final
name|TimeFrame
name|msFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MILLISECOND
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMilli
init|=
name|frame
operator|.
name|per
argument_list|(
name|msFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMilli
operator|!=
literal|null
operator|&&
name|perMilli
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
comment|// 1,000 for SECOND, 86,400,000 for DAY
specifier|final
name|long
name|m
init|=
name|perMilli
operator|.
name|getDenominator
argument_list|()
operator|.
name|longValueExact
argument_list|()
decl_stmt|;
specifier|final
name|long
name|delta
init|=
name|timestamp2
operator|-
name|timestamp
decl_stmt|;
return|return
name|floorDiv
argument_list|(
name|delta
argument_list|,
name|m
argument_list|)
return|;
block|}
specifier|final
name|TimeFrame
name|monthFrame
init|=
name|get
argument_list|(
name|TimeUnit
operator|.
name|MONTH
argument_list|)
decl_stmt|;
specifier|final
name|BigFraction
name|perMonth
init|=
name|frame
operator|.
name|per
argument_list|(
name|monthFrame
argument_list|)
decl_stmt|;
if|if
condition|(
name|perMonth
operator|!=
literal|null
operator|&&
name|perMonth
operator|.
name|getNumerator
argument_list|()
operator|.
name|equals
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|)
condition|)
block|{
specifier|final
name|long
name|m
init|=
name|perMonth
operator|.
name|getDenominator
argument_list|()
operator|.
name|longValueExact
argument_list|()
decl_stmt|;
comment|// e.g. 12 for YEAR
specifier|final
name|long
name|delta
init|=
name|DateTimeUtils
operator|.
name|subtractMonths
argument_list|(
name|timestamp2
argument_list|,
name|timestamp
argument_list|)
decl_stmt|;
return|return
name|floorDiv
argument_list|(
name|delta
argument_list|,
name|m
argument_list|)
return|;
block|}
comment|// Unknown time frame. Return the original value unchanged.
return|return
name|timestamp
return|;
block|}
comment|/** Builds a collection of time frames. */
specifier|public
interface|interface
name|Builder
block|{
comment|/** Creates a {@code TimeFrameSet}. */
name|TimeFrameSet
name|build
parameter_list|()
function_decl|;
comment|/** Defines a core time frame. */
name|Builder
name|addCore
parameter_list|(
name|String
name|name
parameter_list|)
function_decl|;
comment|/** Defines a time frame that is the number of a minor unit within a major      * frame. For example, the "DOY" frame has minor "DAY" and major "YEAR". */
name|Builder
name|addQuotient
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|minorName
parameter_list|,
name|String
name|majorName
parameter_list|)
function_decl|;
comment|/** Defines a time frame that consists of {@code count} instances of      * a base frame. */
name|Builder
name|addMultiple
parameter_list|(
name|String
name|name
parameter_list|,
name|Number
name|count
parameter_list|,
name|String
name|baseName
parameter_list|)
function_decl|;
comment|/** Defines a time frame such that each base frame consists of {@code count}      * instances of the new frame. */
name|Builder
name|addDivision
parameter_list|(
name|String
name|name
parameter_list|,
name|Number
name|count
parameter_list|,
name|String
name|baseName
parameter_list|)
function_decl|;
comment|/** Defines a rollup from one frame to another.      *      *<p>An explicit rollup is not necessary for frames where one is a multiple      * of another (such as {@code MILLISECOND} to {@code HOUR}). Only use this      * method for frames that are not multiples (such as {@code DAY} to      * {@code MONTH}).      *      *<p>How do we automatically roll up from say, "minute15" to "hour7"?      * Because we know the following:      *<ul>      *<li>"minute15" and "hour7" are based on the same core frame (seconds);      *<li>"minute15" is 15 * 60 seconds, "hour7" is 7 * 60 * 60 seconds,      *     and the one divides the other;      *<li>They have the same offset, 1970-01-01 00:00:00. (Different offsets      *     would be OK too, as they are a whole multiple apart.)      *</ul>      *      *<p>A month is not a fixed multiple of days, but a rollup is still      * possible, because the start of a month is always aligned with the start      * of a day. This means that you can compute a month total by adding up the      * day totals for all days in that month. This is useful if you have an      * aggregate table on DAY and you want to answer a query on {@code MONTH}.      *      *<p>There is no rollup from {@code WEEK} to {@code YEAR}, because of a      * lack of alignment: a year does not start on the first day of a week, and      * so you cannot compute the total for, say, the year 2022 by adding the      * totals for all weeks that fall in 2022.      *      *<p>Incidentally, {@code ISOWEEK} and {@code ISOYEAR} are designed so that      * {@code ISOWEEK} can roll up to {@code ISOYEAR}. Every {@code ISOYEAR} and      * {@code ISOWEEK} start on a Monday, so they are aligned. An      * {@code ISOYEAR} consists of either 52 or 53 {@code ISOWEEK} instances,      * but the variable multiple is not a problem; the alignment ensures that      * rollup is valid. */
name|Builder
name|addRollup
parameter_list|(
name|String
name|fromName
parameter_list|,
name|String
name|toName
parameter_list|)
function_decl|;
comment|/** Adds all time frames in {@code timeFrameSet} to this {@code Builder}. */
name|Builder
name|addAll
parameter_list|(
name|TimeFrameSet
name|timeFrameSet
parameter_list|)
function_decl|;
comment|/** Replaces the epoch of the most recently added frame. */
name|Builder
name|withEpoch
parameter_list|(
name|TimestampString
name|epoch
parameter_list|)
function_decl|;
comment|/** Defines an alias for an existing frame.      *      *<p>For example, {@code add("Y", "YEAR")} adds "Y" as an alias for the      * built-in frame {@code YEAR}.      *      * @param name The alias      * @param originalName Name of the existing frame      */
name|Builder
name|addAlias
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|originalName
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

