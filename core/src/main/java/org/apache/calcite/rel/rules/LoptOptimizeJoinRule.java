begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SemiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelColumnOrigin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|IntPair
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_comment
comment|/**  * Planner rule that implements the heuristic planner for determining optimal  * join orderings.  *  *<p>It is triggered by the pattern  * {@link org.apache.calcite.rel.logical.LogicalProject}  * ({@link MultiJoin}).  */
end_comment

begin_class
specifier|public
class|class
name|LoptOptimizeJoinRule
extends|extends
name|RelOptRule
block|{
specifier|public
specifier|static
specifier|final
name|LoptOptimizeJoinRule
name|INSTANCE
init|=
operator|new
name|LoptOptimizeJoinRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Creates a LoptOptimizeJoinRule. */
specifier|public
name|LoptOptimizeJoinRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|MultiJoin
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|LoptOptimizeJoinRule
parameter_list|(
name|RelFactories
operator|.
name|JoinFactory
name|joinFactory
parameter_list|,
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
parameter_list|,
name|RelFactories
operator|.
name|FilterFactory
name|filterFactory
parameter_list|)
block|{
name|this
argument_list|(
name|RelBuilder
operator|.
name|proto
argument_list|(
name|joinFactory
argument_list|,
name|projectFactory
argument_list|,
name|filterFactory
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|MultiJoin
name|multiJoinRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|LoptMultiJoin
name|multiJoin
init|=
operator|new
name|LoptMultiJoin
argument_list|(
name|multiJoinRel
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|call
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
name|findRemovableOuterJoins
argument_list|(
name|mq
argument_list|,
name|multiJoin
argument_list|)
expr_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|multiJoinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|LoptSemiJoinOptimizer
name|semiJoinOpt
init|=
operator|new
name|LoptSemiJoinOptimizer
argument_list|(
name|call
operator|.
name|getMetadataQuery
argument_list|()
argument_list|,
name|multiJoin
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
comment|// determine all possible semijoins
name|semiJoinOpt
operator|.
name|makePossibleSemiJoins
argument_list|(
name|multiJoin
argument_list|)
expr_stmt|;
comment|// select the optimal join filters for semijoin filtering by
comment|// iteratively calling chooseBestSemiJoin; chooseBestSemiJoin will
comment|// apply semijoins in sort order, based on the cost of scanning each
comment|// factor; as it selects semijoins to apply and iterates through the
comment|// loop, the cost of scanning a factor will decrease in accordance
comment|// with the semijoins selected
name|int
name|iterations
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|semiJoinOpt
operator|.
name|chooseBestSemiJoin
argument_list|(
name|multiJoin
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|iterations
operator|++
operator|>
literal|10
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
literal|true
condition|)
do|;
name|multiJoin
operator|.
name|setFactorWeights
argument_list|()
expr_stmt|;
name|findRemovableSelfJoins
argument_list|(
name|mq
argument_list|,
name|multiJoin
argument_list|)
expr_stmt|;
name|findBestOrderings
argument_list|(
name|mq
argument_list|,
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
comment|/**    * Locates all null generating factors whose outer join can be removed. The    * outer join can be removed if the join keys corresponding to the null    * generating factor are unique and no columns are projected from it.    *    * @param multiJoin join factors being optimized    */
specifier|private
name|void
name|findRemovableOuterJoins
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|removalCandidates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|factIdx
init|=
literal|0
init|;
name|factIdx
operator|<
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
condition|;
name|factIdx
operator|++
control|)
block|{
if|if
condition|(
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|factIdx
argument_list|)
condition|)
block|{
name|removalCandidates
operator|.
name|add
argument_list|(
name|factIdx
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|removalCandidates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|retryCandidates
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|outerForLoop
label|:
for|for
control|(
name|int
name|factIdx
range|:
name|removalCandidates
control|)
block|{
comment|// reject the factor if it is referenced in the projection list
name|ImmutableBitSet
name|projFields
init|=
name|multiJoin
operator|.
name|getProjFields
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|projFields
operator|==
literal|null
operator|)
operator|||
operator|(
name|projFields
operator|.
name|cardinality
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
comment|// setup a bitmap containing the equi-join keys corresponding to
comment|// the null generating factor; both operands in the filter must
comment|// be RexInputRefs and only one side corresponds to the null
comment|// generating factor
name|RexNode
name|outerJoinCond
init|=
name|multiJoin
operator|.
name|getOuterJoinCond
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|ojFilters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|decomposeConjunction
argument_list|(
name|outerJoinCond
argument_list|,
name|ojFilters
argument_list|)
expr_stmt|;
name|int
name|numFields
init|=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|joinKeyBuilder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|otherJoinKeyBuilder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|firstFieldNum
init|=
name|multiJoin
operator|.
name|getJoinStart
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
name|int
name|lastFieldNum
init|=
name|firstFieldNum
operator|+
name|numFields
decl_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|ojFilters
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|filter
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
continue|continue;
block|}
name|RexCall
name|filterCall
init|=
operator|(
name|RexCall
operator|)
name|filter
decl_stmt|;
if|if
condition|(
operator|(
name|filterCall
operator|.
name|getOperator
argument_list|()
operator|!=
name|SqlStdOperatorTable
operator|.
name|EQUALS
operator|)
operator|||
operator|!
operator|(
name|filterCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
operator|||
operator|!
operator|(
name|filterCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
continue|continue;
block|}
name|int
name|leftRef
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|filterCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|rightRef
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|filterCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|setJoinKey
argument_list|(
name|joinKeyBuilder
argument_list|,
name|otherJoinKeyBuilder
argument_list|,
name|leftRef
argument_list|,
name|rightRef
argument_list|,
name|firstFieldNum
argument_list|,
name|lastFieldNum
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|joinKeyBuilder
operator|.
name|cardinality
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|// make sure the only join fields referenced are the ones in
comment|// the current outer join
specifier|final
name|ImmutableBitSet
name|joinKeys
init|=
name|joinKeyBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|int
index|[]
name|joinFieldRefCounts
init|=
name|multiJoin
operator|.
name|getJoinFieldRefCounts
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joinFieldRefCounts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|joinFieldRefCounts
index|[
name|i
index|]
operator|>
literal|1
operator|)
operator|||
operator|(
operator|!
name|joinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
name|joinFieldRefCounts
index|[
name|i
index|]
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
continue|continue
name|outerForLoop
continue|;
block|}
block|}
comment|// See if the join keys are unique.  Because the keys are
comment|// part of an equality join condition, nulls are filtered out
comment|// by the join.  So, it's ok if there are nulls in the join
comment|// keys.
if|if
condition|(
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUniqueWhenNullsFiltered
argument_list|(
name|mq
argument_list|,
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|factIdx
argument_list|)
argument_list|,
name|joinKeys
argument_list|)
condition|)
block|{
name|multiJoin
operator|.
name|addRemovableOuterJoinFactor
argument_list|(
name|factIdx
argument_list|)
expr_stmt|;
comment|// Since we are no longer joining this factor,
comment|// decrement the reference counters corresponding to
comment|// the join keys from the other factors that join with
comment|// this one.  Later, in the outermost loop, we'll have
comment|// the opportunity to retry removing those factors.
specifier|final
name|ImmutableBitSet
name|otherJoinKeys
init|=
name|otherJoinKeyBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|otherKey
range|:
name|otherJoinKeys
control|)
block|{
name|int
name|otherFactor
init|=
name|multiJoin
operator|.
name|findRef
argument_list|(
name|otherKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|otherFactor
argument_list|)
condition|)
block|{
name|retryCandidates
operator|.
name|add
argument_list|(
name|otherFactor
argument_list|)
expr_stmt|;
block|}
name|int
index|[]
name|otherJoinFieldRefCounts
init|=
name|multiJoin
operator|.
name|getJoinFieldRefCounts
argument_list|(
name|otherFactor
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|multiJoin
operator|.
name|getJoinStart
argument_list|(
name|otherFactor
argument_list|)
decl_stmt|;
operator|--
name|otherJoinFieldRefCounts
index|[
name|otherKey
operator|-
name|offset
index|]
expr_stmt|;
block|}
block|}
block|}
name|removalCandidates
operator|.
name|clear
argument_list|()
expr_stmt|;
name|removalCandidates
operator|.
name|addAll
argument_list|(
name|retryCandidates
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets a join key if only one of the specified input references corresponds    * to a specified factor as determined by its field numbers. Also keeps    * track of the keys from the other factor.    *    * @param joinKeys join keys to be set if a key is found    * @param otherJoinKeys join keys for the other join factor    * @param ref1 first input reference    * @param ref2 second input reference    * @param firstFieldNum first field number of the factor    * @param lastFieldNum last field number + 1 of the factor    * @param swap if true, check for the desired input reference in the second    * input reference parameter if the first input reference isn't the correct    * one    */
specifier|private
name|void
name|setJoinKey
parameter_list|(
name|ImmutableBitSet
operator|.
name|Builder
name|joinKeys
parameter_list|,
name|ImmutableBitSet
operator|.
name|Builder
name|otherJoinKeys
parameter_list|,
name|int
name|ref1
parameter_list|,
name|int
name|ref2
parameter_list|,
name|int
name|firstFieldNum
parameter_list|,
name|int
name|lastFieldNum
parameter_list|,
name|boolean
name|swap
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ref1
operator|>=
name|firstFieldNum
operator|)
operator|&&
operator|(
name|ref1
operator|<
name|lastFieldNum
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|ref2
operator|>=
name|firstFieldNum
operator|)
operator|&&
operator|(
name|ref2
operator|<
name|lastFieldNum
operator|)
operator|)
condition|)
block|{
name|joinKeys
operator|.
name|set
argument_list|(
name|ref1
operator|-
name|firstFieldNum
argument_list|)
expr_stmt|;
name|otherJoinKeys
operator|.
name|set
argument_list|(
name|ref2
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|swap
condition|)
block|{
name|setJoinKey
argument_list|(
name|joinKeys
argument_list|,
name|otherJoinKeys
argument_list|,
name|ref2
argument_list|,
name|ref1
argument_list|,
name|firstFieldNum
argument_list|,
name|lastFieldNum
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Locates pairs of joins that are self-joins where the join can be removed    * because the join condition between the two factors is an equality join on    * unique keys.    *    * @param multiJoin join factors being optimized    */
specifier|private
name|void
name|findRemovableSelfJoins
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|)
block|{
comment|// Candidates for self-joins must be simple factors
name|Map
argument_list|<
name|Integer
argument_list|,
name|RelOptTable
argument_list|>
name|simpleFactors
init|=
name|getSimpleFactors
argument_list|(
name|mq
argument_list|,
name|multiJoin
argument_list|)
decl_stmt|;
comment|// See if a simple factor is repeated and therefore potentially is
comment|// part of a self-join.  Restrict each factor to at most one
comment|// self-join.
specifier|final
name|List
argument_list|<
name|RelOptTable
argument_list|>
name|repeatedTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|TreeSet
argument_list|<
name|Integer
argument_list|>
name|sortedFactors
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|sortedFactors
operator|.
name|addAll
argument_list|(
name|simpleFactors
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|selfJoinPairs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Integer
index|[]
name|factors
init|=
name|sortedFactors
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|factors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|repeatedTables
operator|.
name|contains
argument_list|(
name|simpleFactors
operator|.
name|get
argument_list|(
name|factors
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|factors
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|int
name|leftFactor
init|=
name|factors
index|[
name|i
index|]
decl_stmt|;
name|int
name|rightFactor
init|=
name|factors
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|simpleFactors
operator|.
name|get
argument_list|(
name|leftFactor
argument_list|)
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|simpleFactors
operator|.
name|get
argument_list|(
name|rightFactor
argument_list|)
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
name|selfJoinPairs
operator|.
name|put
argument_list|(
name|leftFactor
argument_list|,
name|rightFactor
argument_list|)
expr_stmt|;
name|repeatedTables
operator|.
name|add
argument_list|(
name|simpleFactors
operator|.
name|get
argument_list|(
name|leftFactor
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// From the candidate self-join pairs, determine if there is
comment|// the appropriate join condition between the two factors that will
comment|// allow the join to be removed.
for|for
control|(
name|Integer
name|factor1
range|:
name|selfJoinPairs
operator|.
name|keySet
argument_list|()
control|)
block|{
specifier|final
name|int
name|factor2
init|=
name|selfJoinPairs
operator|.
name|get
argument_list|(
name|factor1
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|selfJoinFilters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|filter
range|:
name|multiJoin
operator|.
name|getJoinFilters
argument_list|()
control|)
block|{
name|ImmutableBitSet
name|joinFactors
init|=
name|multiJoin
operator|.
name|getFactorsRefByJoinFilter
argument_list|(
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|joinFactors
operator|.
name|cardinality
argument_list|()
operator|==
literal|2
operator|)
operator|&&
name|joinFactors
operator|.
name|get
argument_list|(
name|factor1
argument_list|)
operator|&&
name|joinFactors
operator|.
name|get
argument_list|(
name|factor2
argument_list|)
condition|)
block|{
name|selfJoinFilters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|selfJoinFilters
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
name|isSelfJoinFilterUnique
argument_list|(
name|mq
argument_list|,
name|multiJoin
argument_list|,
name|factor1
argument_list|,
name|factor2
argument_list|,
name|selfJoinFilters
argument_list|)
condition|)
block|{
name|multiJoin
operator|.
name|addRemovableSelfJoinPair
argument_list|(
name|factor1
argument_list|,
name|factor2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Retrieves join factors that correspond to simple table references. A    * simple table reference is a single table reference with no grouping or    * aggregation.    *    * @param multiJoin join factors being optimized    *    * @return map consisting of the simple factors and the tables they    * correspond    */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|RelOptTable
argument_list|>
name|getSimpleFactors
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RelOptTable
argument_list|>
name|returnList
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Loop through all join factors and locate the ones where each
comment|// column referenced from the factor is not derived and originates
comment|// from the same underlying table.  Also, discard factors that
comment|// are null-generating or will be removed because of semijoins.
if|if
condition|(
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|isFullOuterJoin
argument_list|()
condition|)
block|{
return|return
name|returnList
return|;
block|}
for|for
control|(
name|int
name|factIdx
init|=
literal|0
init|;
name|factIdx
operator|<
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
condition|;
name|factIdx
operator|++
control|)
block|{
if|if
condition|(
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|factIdx
argument_list|)
operator|||
operator|(
name|multiJoin
operator|.
name|getJoinRemovalFactor
argument_list|(
name|factIdx
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|RelNode
name|rel
init|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
specifier|final
name|RelOptTable
name|table
init|=
name|mq
operator|.
name|getTableOrigin
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
name|returnList
operator|.
name|put
argument_list|(
name|factIdx
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|returnList
return|;
block|}
comment|/**    * Determines if the equality join filters between two factors that map to    * the same table consist of unique, identical keys.    *    * @param multiJoin join factors being optimized    * @param leftFactor left factor in the join    * @param rightFactor right factor in the join    * @param joinFilterList list of join filters between the two factors    *    * @return true if the criteria are met    */
specifier|private
name|boolean
name|isSelfJoinFilterUnique
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|int
name|leftFactor
parameter_list|,
name|int
name|rightFactor
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilterList
parameter_list|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelNode
name|leftRel
init|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|leftFactor
argument_list|)
decl_stmt|;
name|RelNode
name|rightRel
init|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|rightFactor
argument_list|)
decl_stmt|;
name|RexNode
name|joinFilters
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|joinFilterList
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Adjust the offsets in the filter by shifting the left factor
comment|// to the left and shifting the right factor to the left and then back
comment|// to the right by the number of fields in the left
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|multiJoin
operator|.
name|getNumTotalFields
argument_list|()
index|]
decl_stmt|;
name|int
name|leftAdjust
init|=
name|multiJoin
operator|.
name|getJoinStart
argument_list|(
name|leftFactor
argument_list|)
decl_stmt|;
name|int
name|nLeftFields
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nLeftFields
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|leftAdjust
operator|+
name|i
index|]
operator|=
operator|-
name|leftAdjust
expr_stmt|;
block|}
name|int
name|rightAdjust
init|=
name|multiJoin
operator|.
name|getJoinStart
argument_list|(
name|rightFactor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|rightAdjust
operator|+
name|i
index|]
operator|=
operator|-
name|rightAdjust
operator|+
name|nLeftFields
expr_stmt|;
block|}
name|joinFilters
operator|=
name|joinFilters
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|multiJoin
operator|.
name|getMultiJoinFields
argument_list|()
argument_list|,
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|areSelfJoinKeysUnique
argument_list|(
name|mq
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|joinFilters
argument_list|)
return|;
block|}
comment|/**    * Generates N optimal join orderings. Each ordering contains each factor as    * the first factor in the ordering.    *    * @param multiJoin join factors being optimized    * @param semiJoinOpt optimal semijoins for each factor    * @param call RelOptRuleCall associated with this rule    */
specifier|private
name|void
name|findBestOrderings
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
comment|// generate the N join orderings
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// first factor cannot be null generating
if|if
condition|(
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|LoptJoinTree
name|joinTree
init|=
name|createOrdering
argument_list|(
name|mq
argument_list|,
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinTree
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|RelNode
name|newProject
init|=
name|createTopProject
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|multiJoin
argument_list|,
name|joinTree
argument_list|,
name|fieldNames
argument_list|)
decl_stmt|;
name|plans
operator|.
name|add
argument_list|(
name|newProject
argument_list|)
expr_stmt|;
block|}
comment|// transform the selected plans; note that we wait till then the end to
comment|// transform everything so any intermediate RelNodes we create are not
comment|// converted to RelSubsets The HEP planner will choose the join subtree
comment|// with the best cumulative cost. Volcano planner keeps the alternative
comment|// join subtrees and cost the final plan to pick the best one.
for|for
control|(
name|RelNode
name|plan
range|:
name|plans
control|)
block|{
name|call
operator|.
name|transformTo
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates the topmost projection that will sit on top of the selected join    * ordering. The projection needs to match the original join ordering. Also,    * places any post-join filters on top of the project.    *    * @param multiJoin join factors being optimized    * @param joinTree selected join ordering    * @param fieldNames field names corresponding to the projection expressions    *    * @return created projection    */
specifier|private
name|RelNode
name|createTopProject
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptJoinTree
name|joinTree
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|newProjExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// create a projection on top of the joins, matching the original
comment|// join order
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|newJoinOrder
init|=
name|joinTree
operator|.
name|getTreeOrder
argument_list|()
decl_stmt|;
name|int
name|nJoinFactors
init|=
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|multiJoin
operator|.
name|getMultiJoinFields
argument_list|()
decl_stmt|;
comment|// create a mapping from each factor to its field offset in the join
comment|// ordering
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|factorToOffsetMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|,
name|fieldStart
init|=
literal|0
init|;
name|pos
operator|<
name|nJoinFactors
condition|;
name|pos
operator|++
control|)
block|{
name|factorToOffsetMap
operator|.
name|put
argument_list|(
name|newJoinOrder
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|,
name|fieldStart
argument_list|)
expr_stmt|;
name|fieldStart
operator|+=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|newJoinOrder
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|currFactor
init|=
literal|0
init|;
name|currFactor
operator|<
name|nJoinFactors
condition|;
name|currFactor
operator|++
control|)
block|{
comment|// if the factor is the right factor in a removable self-join,
comment|// then where possible, remap references to the right factor to
comment|// the corresponding reference in the left factor
name|Integer
name|leftFactor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|multiJoin
operator|.
name|isRightFactorInRemovableSelfJoin
argument_list|(
name|currFactor
argument_list|)
condition|)
block|{
name|leftFactor
operator|=
name|multiJoin
operator|.
name|getOtherSelfJoinFactor
argument_list|(
name|currFactor
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|fieldPos
init|=
literal|0
init|;
name|fieldPos
operator|<
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|currFactor
argument_list|)
condition|;
name|fieldPos
operator|++
control|)
block|{
name|int
name|newOffset
init|=
name|factorToOffsetMap
operator|.
name|get
argument_list|(
name|currFactor
argument_list|)
operator|+
name|fieldPos
decl_stmt|;
if|if
condition|(
name|leftFactor
operator|!=
literal|null
condition|)
block|{
name|Integer
name|leftOffset
init|=
name|multiJoin
operator|.
name|getRightColumnMapping
argument_list|(
name|currFactor
argument_list|,
name|fieldPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftOffset
operator|!=
literal|null
condition|)
block|{
name|newOffset
operator|=
name|factorToOffsetMap
operator|.
name|get
argument_list|(
name|leftFactor
argument_list|)
operator|+
name|leftOffset
expr_stmt|;
block|}
block|}
name|newProjExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|newProjExprs
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|newOffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|joinTree
operator|.
name|getJoinTree
argument_list|()
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|newProjExprs
argument_list|,
name|fieldNames
argument_list|)
expr_stmt|;
comment|// Place the post-join filter (if it exists) on top of the final
comment|// projection.
name|RexNode
name|postJoinFilter
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getPostJoinFilter
argument_list|()
decl_stmt|;
if|if
condition|(
name|postJoinFilter
operator|!=
literal|null
condition|)
block|{
name|relBuilder
operator|.
name|filter
argument_list|(
name|postJoinFilter
argument_list|)
expr_stmt|;
block|}
return|return
name|relBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Computes the cardinality of the join columns from a particular factor,    * when that factor is joined with another join tree.    *    * @param multiJoin join factors being optimized    * @param semiJoinOpt optimal semijoins chosen for each factor    * @param joinTree the join tree that the factor is being joined with    * @param filters possible join filters to select from    * @param factor the factor being added    *    * @return computed cardinality    */
specifier|private
name|Double
name|computeJoinCardinality
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|LoptJoinTree
name|joinTree
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|int
name|factor
parameter_list|)
block|{
specifier|final
name|ImmutableBitSet
name|childFactors
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|joinTree
operator|.
name|getTreeOrder
argument_list|()
argument_list|)
operator|.
name|set
argument_list|(
name|factor
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|int
name|factorStart
init|=
name|multiJoin
operator|.
name|getJoinStart
argument_list|(
name|factor
argument_list|)
decl_stmt|;
name|int
name|nFields
init|=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|factor
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|joinKeys
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// first loop through the inner join filters, picking out the ones
comment|// that reference only the factors in either the join tree or the
comment|// factor that will be added
name|setFactorJoinKeys
argument_list|(
name|multiJoin
argument_list|,
name|filters
argument_list|,
name|childFactors
argument_list|,
name|factorStart
argument_list|,
name|nFields
argument_list|,
name|joinKeys
argument_list|)
expr_stmt|;
comment|// then loop through the outer join filters where the factor being
comment|// added is the null generating factor in the outer join
name|setFactorJoinKeys
argument_list|(
name|multiJoin
argument_list|,
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|multiJoin
operator|.
name|getOuterJoinCond
argument_list|(
name|factor
argument_list|)
argument_list|)
argument_list|,
name|childFactors
argument_list|,
name|factorStart
argument_list|,
name|nFields
argument_list|,
name|joinKeys
argument_list|)
expr_stmt|;
comment|// if the join tree doesn't contain all the necessary factors in
comment|// any of the join filters, then joinKeys will be empty, so return
comment|// null in that case
if|if
condition|(
name|joinKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|semiJoinOpt
operator|.
name|getChosenSemiJoin
argument_list|(
name|factor
argument_list|)
argument_list|,
name|joinKeys
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
comment|/**    * Locates from a list of filters those that correspond to a particular join    * tree. Then, for each of those filters, extracts the fields corresponding    * to a particular factor, setting them in a bitmap.    *    * @param multiJoin join factors being optimized    * @param filters list of join filters    * @param joinFactors bitmap containing the factors in a particular join    * tree    * @param factorStart the initial offset of the factor whose join keys will    * be extracted    * @param nFields the number of fields in the factor whose join keys will be    * extracted    * @param joinKeys the bitmap that will be set with the join keys    */
specifier|private
name|void
name|setFactorJoinKeys
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
parameter_list|,
name|ImmutableBitSet
name|joinFactors
parameter_list|,
name|int
name|factorStart
parameter_list|,
name|int
name|nFields
parameter_list|,
name|ImmutableBitSet
operator|.
name|Builder
name|joinKeys
parameter_list|)
block|{
for|for
control|(
name|RexNode
name|joinFilter
range|:
name|filters
control|)
block|{
name|ImmutableBitSet
name|filterFactors
init|=
name|multiJoin
operator|.
name|getFactorsRefByJoinFilter
argument_list|(
name|joinFilter
argument_list|)
decl_stmt|;
comment|// if all factors in the join filter are in the bitmap containing
comment|// the factors in a join tree, then from that filter, add the
comment|// fields corresponding to the specified factor to the join key
comment|// bitmap; in doing so, adjust the join keys so they start at
comment|// offset 0
if|if
condition|(
name|joinFactors
operator|.
name|contains
argument_list|(
name|filterFactors
argument_list|)
condition|)
block|{
name|ImmutableBitSet
name|joinFields
init|=
name|multiJoin
operator|.
name|getFieldsRefByJoinFilter
argument_list|(
name|joinFilter
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|field
init|=
name|joinFields
operator|.
name|nextSetBit
argument_list|(
name|factorStart
argument_list|)
init|;
operator|(
name|field
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|field
operator|<
operator|(
name|factorStart
operator|+
name|nFields
operator|)
operator|)
condition|;
name|field
operator|=
name|joinFields
operator|.
name|nextSetBit
argument_list|(
name|field
operator|+
literal|1
argument_list|)
control|)
block|{
name|joinKeys
operator|.
name|set
argument_list|(
name|field
operator|-
name|factorStart
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Generates a join tree with a specific factor as the first factor in the    * join tree    *    * @param multiJoin join factors being optimized    * @param semiJoinOpt optimal semijoins for each factor    * @param firstFactor first factor in the tree    *    * @return constructed join tree or null if it is not possible for    * firstFactor to appear as the first factor in the join    */
specifier|private
name|LoptJoinTree
name|createOrdering
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|int
name|firstFactor
parameter_list|)
block|{
name|LoptJoinTree
name|joinTree
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|nJoinFactors
init|=
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|factorsToAdd
init|=
name|BitSets
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|nJoinFactors
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|factorsAdded
init|=
operator|new
name|BitSet
argument_list|(
name|nJoinFactors
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|multiJoin
operator|.
name|getJoinFilters
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|prevFactor
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|factorsToAdd
operator|.
name|cardinality
argument_list|()
operator|>
literal|0
condition|)
block|{
name|int
name|nextFactor
decl_stmt|;
name|boolean
name|selfJoin
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|factorsAdded
operator|.
name|cardinality
argument_list|()
operator|==
literal|0
condition|)
block|{
name|nextFactor
operator|=
name|firstFactor
expr_stmt|;
block|}
else|else
block|{
comment|// If the factor just added is part of a removable self-join
comment|// and the other half of the self-join hasn't been added yet,
comment|// then add it next.  Otherwise, look for the optimal factor
comment|// to add next.
name|Integer
name|selfJoinFactor
init|=
name|multiJoin
operator|.
name|getOtherSelfJoinFactor
argument_list|(
name|prevFactor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|selfJoinFactor
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|factorsAdded
operator|.
name|get
argument_list|(
name|selfJoinFactor
argument_list|)
condition|)
block|{
name|nextFactor
operator|=
name|selfJoinFactor
expr_stmt|;
name|selfJoin
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|nextFactor
operator|=
name|getBestNextFactor
argument_list|(
name|mq
argument_list|,
name|multiJoin
argument_list|,
name|factorsToAdd
argument_list|,
name|factorsAdded
argument_list|,
name|semiJoinOpt
argument_list|,
name|joinTree
argument_list|,
name|filtersToAdd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add the factor; pass in a bitmap representing the factors
comment|// this factor joins with that have already been added to
comment|// the tree
name|BitSet
name|factorsNeeded
init|=
name|multiJoin
operator|.
name|getFactorsRefByFactor
argument_list|(
name|nextFactor
argument_list|)
operator|.
name|toBitSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|nextFactor
argument_list|)
condition|)
block|{
name|factorsNeeded
operator|.
name|or
argument_list|(
name|multiJoin
operator|.
name|getOuterJoinFactors
argument_list|(
name|nextFactor
argument_list|)
operator|.
name|toBitSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|factorsNeeded
operator|.
name|and
argument_list|(
name|factorsAdded
argument_list|)
expr_stmt|;
name|joinTree
operator|=
name|addFactorToTree
argument_list|(
name|mq
argument_list|,
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|joinTree
argument_list|,
name|nextFactor
argument_list|,
name|factorsNeeded
argument_list|,
name|filtersToAdd
argument_list|,
name|selfJoin
argument_list|)
expr_stmt|;
if|if
condition|(
name|joinTree
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|factorsToAdd
operator|.
name|clear
argument_list|(
name|nextFactor
argument_list|)
expr_stmt|;
name|factorsAdded
operator|.
name|set
argument_list|(
name|nextFactor
argument_list|)
expr_stmt|;
name|prevFactor
operator|=
name|nextFactor
expr_stmt|;
block|}
assert|assert
name|filtersToAdd
operator|.
name|size
argument_list|()
operator|==
literal|0
assert|;
return|return
name|joinTree
return|;
block|}
comment|/**    * Determines the best factor to be added next into a join tree.    *    * @param multiJoin join factors being optimized    * @param factorsToAdd factors to choose from to add next    * @param factorsAdded factors that have already been added to the join tree    * @param semiJoinOpt optimal semijoins for each factor    * @param joinTree join tree constructed thus far    * @param filtersToAdd remaining filters that need to be added    *    * @return index of the best factor to add next    */
specifier|private
name|int
name|getBestNextFactor
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|BitSet
name|factorsToAdd
parameter_list|,
name|BitSet
name|factorsAdded
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|LoptJoinTree
name|joinTree
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|)
block|{
comment|// iterate through the remaining factors and determine the
comment|// best one to add next
name|int
name|nextFactor
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bestWeight
init|=
literal|0
decl_stmt|;
name|Double
name|bestCardinality
init|=
literal|null
decl_stmt|;
name|int
index|[]
index|[]
name|factorWeights
init|=
name|multiJoin
operator|.
name|getFactorWeights
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|factor
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|factorsToAdd
argument_list|)
control|)
block|{
comment|// if the factor corresponds to a dimension table whose
comment|// join we can remove, make sure the the corresponding fact
comment|// table is in the current join tree
name|Integer
name|factIdx
init|=
name|multiJoin
operator|.
name|getJoinRemovalFactor
argument_list|(
name|factor
argument_list|)
decl_stmt|;
if|if
condition|(
name|factIdx
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|factorsAdded
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
comment|// can't add a null-generating factor if its dependent,
comment|// non-null generating factors haven't been added yet
if|if
condition|(
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|factor
argument_list|)
operator|&&
operator|!
name|BitSets
operator|.
name|contains
argument_list|(
name|factorsAdded
argument_list|,
name|multiJoin
operator|.
name|getOuterJoinFactors
argument_list|(
name|factor
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// determine the best weight between the current factor
comment|// under consideration and the factors that have already
comment|// been added to the tree
name|int
name|dimWeight
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|prevFactor
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|factorsAdded
argument_list|)
control|)
block|{
if|if
condition|(
name|factorWeights
index|[
name|prevFactor
index|]
index|[
name|factor
index|]
operator|>
name|dimWeight
condition|)
block|{
name|dimWeight
operator|=
name|factorWeights
index|[
name|prevFactor
index|]
index|[
name|factor
index|]
expr_stmt|;
block|}
block|}
comment|// only compute the join cardinality if we know that
comment|// this factor joins with some part of the current join
comment|// tree and is potentially better than other factors
comment|// already considered
name|Double
name|cardinality
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|dimWeight
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|dimWeight
operator|>
name|bestWeight
operator|)
operator|||
operator|(
name|dimWeight
operator|==
name|bestWeight
operator|)
operator|)
condition|)
block|{
name|cardinality
operator|=
name|computeJoinCardinality
argument_list|(
name|mq
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|joinTree
argument_list|,
name|filtersToAdd
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
comment|// if two factors have the same weight, pick the one
comment|// with the higher cardinality join key, relative to
comment|// the join being considered
if|if
condition|(
operator|(
name|dimWeight
operator|>
name|bestWeight
operator|)
operator|||
operator|(
operator|(
name|dimWeight
operator|==
name|bestWeight
operator|)
operator|&&
operator|(
operator|(
name|bestCardinality
operator|==
literal|null
operator|)
operator|||
operator|(
operator|(
name|cardinality
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|cardinality
operator|>
name|bestCardinality
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|nextFactor
operator|=
name|factor
expr_stmt|;
name|bestWeight
operator|=
name|dimWeight
expr_stmt|;
name|bestCardinality
operator|=
name|cardinality
expr_stmt|;
block|}
block|}
return|return
name|nextFactor
return|;
block|}
comment|/**    * Returns whether a RelNode corresponds to a Join that wasn't one of the    * original MultiJoin input factors.    */
specifier|private
name|boolean
name|isJoinTree
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
comment|// full outer joins were already optimized in a prior instantiation
comment|// of this rule; therefore we should never see a join input that's
comment|// a full outer join
if|if
condition|(
name|rel
operator|instanceof
name|Join
condition|)
block|{
assert|assert
operator|(
operator|(
name|Join
operator|)
name|rel
operator|)
operator|.
name|getJoinType
argument_list|()
operator|!=
name|JoinRelType
operator|.
name|FULL
assert|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Adds a new factor into the current join tree. The factor is either pushed    * down into one of the subtrees of the join recursively, or it is added to    * the top of the current tree, whichever yields a better ordering.    *    * @param multiJoin join factors being optimized    * @param semiJoinOpt optimal semijoins for each factor    * @param joinTree current join tree    * @param factorToAdd new factor to be added    * @param factorsNeeded factors that must precede the factor to be added    * @param filtersToAdd filters remaining to be added; filters added to the    * new join tree are removed from the list    * @param selfJoin true if the join being created is a self-join that's    * removable    *    * @return optimal join tree with the new factor added if it is possible to    * add the factor; otherwise, null is returned    */
specifier|private
name|LoptJoinTree
name|addFactorToTree
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|LoptJoinTree
name|joinTree
parameter_list|,
name|int
name|factorToAdd
parameter_list|,
name|BitSet
name|factorsNeeded
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|,
name|boolean
name|selfJoin
parameter_list|)
block|{
comment|// if the factor corresponds to the null generating factor in an outer
comment|// join that can be removed, then create a replacement join
if|if
condition|(
name|multiJoin
operator|.
name|isRemovableOuterJoinFactor
argument_list|(
name|factorToAdd
argument_list|)
condition|)
block|{
return|return
name|createReplacementJoin
argument_list|(
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|joinTree
argument_list|,
operator|-
literal|1
argument_list|,
name|factorToAdd
argument_list|,
name|ImmutableIntList
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|filtersToAdd
argument_list|)
return|;
block|}
comment|// if the factor corresponds to a dimension table whose join we
comment|// can remove, create a replacement join if the corresponding fact
comment|// table is in the current join tree
if|if
condition|(
name|multiJoin
operator|.
name|getJoinRemovalFactor
argument_list|(
name|factorToAdd
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
name|createReplacementSemiJoin
argument_list|(
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|joinTree
argument_list|,
name|factorToAdd
argument_list|,
name|filtersToAdd
argument_list|)
return|;
block|}
comment|// if this is the first factor in the tree, create a join tree with
comment|// the single factor
if|if
condition|(
name|joinTree
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|LoptJoinTree
argument_list|(
name|semiJoinOpt
operator|.
name|getChosenSemiJoin
argument_list|(
name|factorToAdd
argument_list|)
argument_list|,
name|factorToAdd
argument_list|)
return|;
block|}
comment|// Create a temporary copy of the filter list as we may need the
comment|// original list to pass into addToTop().  However, if no tree was
comment|// created by addToTop() because the factor being added is part of
comment|// a self-join, then pass the original filter list so the added
comment|// filters will still be removed from the list.
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|tmpFilters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|filtersToAdd
argument_list|)
decl_stmt|;
name|LoptJoinTree
name|topTree
init|=
name|addToTop
argument_list|(
name|mq
argument_list|,
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|joinTree
argument_list|,
name|factorToAdd
argument_list|,
name|filtersToAdd
argument_list|,
name|selfJoin
argument_list|)
decl_stmt|;
name|LoptJoinTree
name|pushDownTree
init|=
name|pushDownFactor
argument_list|(
name|mq
argument_list|,
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|joinTree
argument_list|,
name|factorToAdd
argument_list|,
name|factorsNeeded
argument_list|,
operator|(
name|topTree
operator|==
literal|null
operator|)
condition|?
name|filtersToAdd
else|:
name|tmpFilters
argument_list|,
name|selfJoin
argument_list|)
decl_stmt|;
comment|// pick the lower cost option, and replace the join ordering with
comment|// the ordering associated with the best option
name|LoptJoinTree
name|bestTree
decl_stmt|;
name|RelOptCost
name|costPushDown
init|=
literal|null
decl_stmt|;
name|RelOptCost
name|costTop
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pushDownTree
operator|!=
literal|null
condition|)
block|{
name|costPushDown
operator|=
name|mq
operator|.
name|getCumulativeCost
argument_list|(
name|pushDownTree
operator|.
name|getJoinTree
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|topTree
operator|!=
literal|null
condition|)
block|{
name|costTop
operator|=
name|mq
operator|.
name|getCumulativeCost
argument_list|(
name|topTree
operator|.
name|getJoinTree
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pushDownTree
operator|==
literal|null
condition|)
block|{
name|bestTree
operator|=
name|topTree
expr_stmt|;
block|}
if|else if
condition|(
name|topTree
operator|==
literal|null
condition|)
block|{
name|bestTree
operator|=
name|pushDownTree
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|costPushDown
operator|.
name|isEqWithEpsilon
argument_list|(
name|costTop
argument_list|)
condition|)
block|{
comment|// if both plans cost the same (with an allowable round-off
comment|// margin of error), favor the one that passes
comment|// around the wider rows further up in the tree
if|if
condition|(
name|rowWidthCost
argument_list|(
name|pushDownTree
operator|.
name|getJoinTree
argument_list|()
argument_list|)
operator|<
name|rowWidthCost
argument_list|(
name|topTree
operator|.
name|getJoinTree
argument_list|()
argument_list|)
condition|)
block|{
name|bestTree
operator|=
name|pushDownTree
expr_stmt|;
block|}
else|else
block|{
name|bestTree
operator|=
name|topTree
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|costPushDown
operator|.
name|isLt
argument_list|(
name|costTop
argument_list|)
condition|)
block|{
name|bestTree
operator|=
name|pushDownTree
expr_stmt|;
block|}
else|else
block|{
name|bestTree
operator|=
name|topTree
expr_stmt|;
block|}
block|}
return|return
name|bestTree
return|;
block|}
comment|/**    * Computes a cost for a join tree based on the row widths of the inputs    * into the join. Joins where the inputs have the fewest number of columns    * lower in the tree are better than equivalent joins where the inputs with    * the larger number of columns are lower in the tree.    *    * @param tree a tree of RelNodes    *    * @return the cost associated with the width of the tree    */
specifier|private
name|int
name|rowWidthCost
parameter_list|(
name|RelNode
name|tree
parameter_list|)
block|{
comment|// The width cost is the width of the tree itself plus the widths
comment|// of its children.  Hence, skinnier rows are better when they're
comment|// lower in the tree since the width of a RelNode contributes to
comment|// the cost of each LogicalJoin that appears above that RelNode.
name|int
name|width
init|=
name|tree
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|isJoinTree
argument_list|(
name|tree
argument_list|)
condition|)
block|{
name|Join
name|joinRel
init|=
operator|(
name|Join
operator|)
name|tree
decl_stmt|;
name|width
operator|+=
name|rowWidthCost
argument_list|(
name|joinRel
operator|.
name|getLeft
argument_list|()
argument_list|)
operator|+
name|rowWidthCost
argument_list|(
name|joinRel
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
comment|/**    * Creates a join tree where the new factor is pushed down one of the    * operands of the current join tree    *    * @param multiJoin join factors being optimized    * @param semiJoinOpt optimal semijoins for each factor    * @param joinTree current join tree    * @param factorToAdd new factor to be added    * @param factorsNeeded factors that must precede the factor to be added    * @param filtersToAdd filters remaining to be added; filters that are added    * to the join tree are removed from the list    * @param selfJoin true if the factor being added is part of a removable    * self-join    *    * @return optimal join tree with the new factor pushed down the current    * join tree if it is possible to do the pushdown; otherwise, null is    * returned    */
specifier|private
name|LoptJoinTree
name|pushDownFactor
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|LoptJoinTree
name|joinTree
parameter_list|,
name|int
name|factorToAdd
parameter_list|,
name|BitSet
name|factorsNeeded
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|,
name|boolean
name|selfJoin
parameter_list|)
block|{
comment|// pushdown option only works if we already have a join tree
if|if
condition|(
operator|!
name|isJoinTree
argument_list|(
name|joinTree
operator|.
name|getJoinTree
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|childNo
init|=
operator|-
literal|1
decl_stmt|;
name|LoptJoinTree
name|left
init|=
name|joinTree
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|LoptJoinTree
name|right
init|=
name|joinTree
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|Join
name|joinRel
init|=
operator|(
name|Join
operator|)
name|joinTree
operator|.
name|getJoinTree
argument_list|()
decl_stmt|;
name|JoinRelType
name|joinType
init|=
name|joinRel
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
comment|// can't push factors pass self-joins because in order to later remove
comment|// them, we need to keep the factors together
if|if
condition|(
name|joinTree
operator|.
name|isRemovableSelfJoin
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// If there are no constraints as to which side the factor must
comment|// be pushed, arbitrarily push to the left.  In the case of a
comment|// self-join, always push to the input that contains the other
comment|// half of the self-join.
if|if
condition|(
name|selfJoin
condition|)
block|{
name|BitSet
name|selfJoinFactor
init|=
operator|new
name|BitSet
argument_list|(
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
argument_list|)
decl_stmt|;
name|selfJoinFactor
operator|.
name|set
argument_list|(
name|multiJoin
operator|.
name|getOtherSelfJoinFactor
argument_list|(
name|factorToAdd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiJoin
operator|.
name|hasAllFactors
argument_list|(
name|left
argument_list|,
name|selfJoinFactor
argument_list|)
condition|)
block|{
name|childNo
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|multiJoin
operator|.
name|hasAllFactors
argument_list|(
name|right
argument_list|,
name|selfJoinFactor
argument_list|)
assert|;
name|childNo
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|else if
condition|(
operator|(
name|factorsNeeded
operator|.
name|cardinality
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|!
name|joinType
operator|.
name|generatesNullsOnLeft
argument_list|()
condition|)
block|{
name|childNo
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// push to the left if the LHS contains all factors that the
comment|// current factor needs and that side is not null-generating;
comment|// same check for RHS
if|if
condition|(
name|multiJoin
operator|.
name|hasAllFactors
argument_list|(
name|left
argument_list|,
name|factorsNeeded
argument_list|)
operator|&&
operator|!
name|joinType
operator|.
name|generatesNullsOnLeft
argument_list|()
condition|)
block|{
name|childNo
operator|=
literal|0
expr_stmt|;
block|}
if|else if
condition|(
name|multiJoin
operator|.
name|hasAllFactors
argument_list|(
name|right
argument_list|,
name|factorsNeeded
argument_list|)
operator|&&
operator|!
name|joinType
operator|.
name|generatesNullsOnRight
argument_list|()
condition|)
block|{
name|childNo
operator|=
literal|1
expr_stmt|;
block|}
comment|// if it couldn't be pushed down to either side, then it can
comment|// only be put on top
block|}
if|if
condition|(
name|childNo
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// remember the original join order before the pushdown so we can
comment|// appropriately adjust any filters already attached to the join
comment|// node
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|origJoinOrder
init|=
name|joinTree
operator|.
name|getTreeOrder
argument_list|()
decl_stmt|;
comment|// recursively pushdown the factor
name|LoptJoinTree
name|subTree
init|=
operator|(
name|childNo
operator|==
literal|0
operator|)
condition|?
name|left
else|:
name|right
decl_stmt|;
name|subTree
operator|=
name|addFactorToTree
argument_list|(
name|mq
argument_list|,
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|subTree
argument_list|,
name|factorToAdd
argument_list|,
name|factorsNeeded
argument_list|,
name|filtersToAdd
argument_list|,
name|selfJoin
argument_list|)
expr_stmt|;
if|if
condition|(
name|childNo
operator|==
literal|0
condition|)
block|{
name|left
operator|=
name|subTree
expr_stmt|;
block|}
else|else
block|{
name|right
operator|=
name|subTree
expr_stmt|;
block|}
comment|// adjust the join condition from the original join tree to reflect
comment|// pushdown of the new factor as well as any swapping that may have
comment|// been done during the pushdown
name|RexNode
name|newCondition
init|=
operator|(
operator|(
name|Join
operator|)
name|joinTree
operator|.
name|getJoinTree
argument_list|()
operator|)
operator|.
name|getCondition
argument_list|()
decl_stmt|;
name|newCondition
operator|=
name|adjustFilter
argument_list|(
name|multiJoin
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|newCondition
argument_list|,
name|factorToAdd
argument_list|,
name|origJoinOrder
argument_list|,
name|joinTree
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
expr_stmt|;
comment|// determine if additional filters apply as a result of adding the
comment|// new factor, provided this isn't a left or right outer join; for
comment|// those cases, the additional filters will be added on top of the
comment|// join in createJoinSubtree
if|if
condition|(
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|&&
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|RIGHT
operator|)
condition|)
block|{
name|RexNode
name|condition
init|=
name|addFilters
argument_list|(
name|multiJoin
argument_list|,
name|left
argument_list|,
operator|-
literal|1
argument_list|,
name|right
argument_list|,
name|filtersToAdd
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|newCondition
operator|=
name|RelOptUtil
operator|.
name|andJoinFilters
argument_list|(
name|rexBuilder
argument_list|,
name|newCondition
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
comment|// create the new join tree with the factor pushed down
return|return
name|createJoinSubtree
argument_list|(
name|mq
argument_list|,
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|newCondition
argument_list|,
name|joinType
argument_list|,
name|filtersToAdd
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Creates a join tree with the new factor added to the top of the tree    *    * @param multiJoin join factors being optimized    * @param semiJoinOpt optimal semijoins for each factor    * @param joinTree current join tree    * @param factorToAdd new factor to be added    * @param filtersToAdd filters remaining to be added; modifies the list to    * remove filters that can be added to the join tree    * @param selfJoin true if the join being created is a self-join that's    * removable    *    * @return new join tree    */
specifier|private
name|LoptJoinTree
name|addToTop
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|LoptJoinTree
name|joinTree
parameter_list|,
name|int
name|factorToAdd
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|,
name|boolean
name|selfJoin
parameter_list|)
block|{
comment|// self-joins can never be created at the top of an existing
comment|// join tree because it needs to be paired directly with the
comment|// other self-join factor
if|if
condition|(
name|selfJoin
operator|&&
name|isJoinTree
argument_list|(
name|joinTree
operator|.
name|getJoinTree
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// if the factor being added is null-generating, create the join
comment|// as a left outer join since it's being added to the RHS side of
comment|// the join; createJoinSubTree may swap the inputs and therefore
comment|// convert the left outer join to a right outer join; if the original
comment|// MultiJoin was a full outer join, these should be the only
comment|// factors in the join, so create the join as a full outer join
name|JoinRelType
name|joinType
decl_stmt|;
if|if
condition|(
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|isFullOuterJoin
argument_list|()
condition|)
block|{
assert|assert
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
operator|==
literal|2
assert|;
name|joinType
operator|=
name|JoinRelType
operator|.
name|FULL
expr_stmt|;
block|}
if|else if
condition|(
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|factorToAdd
argument_list|)
condition|)
block|{
name|joinType
operator|=
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
block|}
else|else
block|{
name|joinType
operator|=
name|JoinRelType
operator|.
name|INNER
expr_stmt|;
block|}
name|LoptJoinTree
name|rightTree
init|=
operator|new
name|LoptJoinTree
argument_list|(
name|semiJoinOpt
operator|.
name|getChosenSemiJoin
argument_list|(
name|factorToAdd
argument_list|)
argument_list|,
name|factorToAdd
argument_list|)
decl_stmt|;
comment|// in the case of a left or right outer join, use the specific
comment|// outer join condition
name|RexNode
name|condition
decl_stmt|;
if|if
condition|(
operator|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|||
operator|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|RIGHT
operator|)
condition|)
block|{
name|condition
operator|=
name|multiJoin
operator|.
name|getOuterJoinCond
argument_list|(
name|factorToAdd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|addFilters
argument_list|(
name|multiJoin
argument_list|,
name|joinTree
argument_list|,
operator|-
literal|1
argument_list|,
name|rightTree
argument_list|,
name|filtersToAdd
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|createJoinSubtree
argument_list|(
name|mq
argument_list|,
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|joinTree
argument_list|,
name|rightTree
argument_list|,
name|condition
argument_list|,
name|joinType
argument_list|,
name|filtersToAdd
argument_list|,
literal|true
argument_list|,
name|selfJoin
argument_list|)
return|;
block|}
comment|/**    * Determines which join filters can be added to the current join tree. Note    * that the join filter still reflects the original join ordering. It will    * only be adjusted to reflect the new join ordering if the "adjust"    * parameter is set to true.    *    * @param multiJoin join factors being optimized    * @param leftTree left subtree of the join tree    * @param leftIdx if&ge; 0, only consider filters that reference leftIdx in    * leftTree; otherwise, consider all filters that reference any factor in    * leftTree    * @param rightTree right subtree of the join tree    * @param filtersToAdd remaining join filters that need to be added; those    * that are added are removed from the list    * @param adjust if true, adjust filter to reflect new join ordering    *    * @return AND'd expression of the join filters that can be added to the    * current join tree    */
specifier|private
name|RexNode
name|addFilters
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptJoinTree
name|leftTree
parameter_list|,
name|int
name|leftIdx
parameter_list|,
name|LoptJoinTree
name|rightTree
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|,
name|boolean
name|adjust
parameter_list|)
block|{
comment|// loop through the remaining filters to be added and pick out the
comment|// ones that reference only the factors in the new join tree
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|childFactorBuilder
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|childFactorBuilder
operator|.
name|addAll
argument_list|(
name|rightTree
operator|.
name|getTreeOrder
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftIdx
operator|>=
literal|0
condition|)
block|{
name|childFactorBuilder
operator|.
name|set
argument_list|(
name|leftIdx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|childFactorBuilder
operator|.
name|addAll
argument_list|(
name|leftTree
operator|.
name|getTreeOrder
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|child
range|:
name|rightTree
operator|.
name|getTreeOrder
argument_list|()
control|)
block|{
name|childFactorBuilder
operator|.
name|set
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableBitSet
name|childFactor
init|=
name|childFactorBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|RexNode
name|condition
init|=
literal|null
decl_stmt|;
specifier|final
name|ListIterator
argument_list|<
name|RexNode
argument_list|>
name|filterIter
init|=
name|filtersToAdd
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|filterIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|joinFilter
init|=
name|filterIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ImmutableBitSet
name|filterBitmap
init|=
name|multiJoin
operator|.
name|getFactorsRefByJoinFilter
argument_list|(
name|joinFilter
argument_list|)
decl_stmt|;
comment|// if all factors in the join filter are in the join tree,
comment|// AND the filter to the current join condition
if|if
condition|(
name|childFactor
operator|.
name|contains
argument_list|(
name|filterBitmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
name|condition
operator|=
name|joinFilter
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|condition
argument_list|,
name|joinFilter
argument_list|)
expr_stmt|;
block|}
name|filterIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adjust
operator|&&
operator|(
name|condition
operator|!=
literal|null
operator|)
condition|)
block|{
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|multiJoin
operator|.
name|getNumTotalFields
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|needsAdjustment
argument_list|(
name|multiJoin
argument_list|,
name|adjustments
argument_list|,
name|leftTree
argument_list|,
name|rightTree
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|condition
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|multiJoin
operator|.
name|getMultiJoinFields
argument_list|()
argument_list|,
name|leftTree
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|rightTree
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
name|condition
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|condition
return|;
block|}
comment|/**    * Adjusts a filter to reflect a newly added factor in the middle of an    * existing join tree    *    * @param multiJoin join factors being optimized    * @param left left subtree of the join    * @param right right subtree of the join    * @param condition current join condition    * @param factorAdded index corresponding to the newly added factor    * @param origJoinOrder original join order, before factor was pushed into    * the tree    * @param origFields fields from the original join before the factor was    * added    *    * @return modified join condition reflecting addition of the new factor    */
specifier|private
name|RexNode
name|adjustFilter
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptJoinTree
name|left
parameter_list|,
name|LoptJoinTree
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|int
name|factorAdded
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|origJoinOrder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|origFields
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|newJoinOrder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|left
operator|.
name|getTreeOrder
argument_list|(
name|newJoinOrder
argument_list|)
expr_stmt|;
name|right
operator|.
name|getTreeOrder
argument_list|(
name|newJoinOrder
argument_list|)
expr_stmt|;
name|int
name|totalFields
init|=
name|left
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|right
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|factorAdded
argument_list|)
decl_stmt|;
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|totalFields
index|]
decl_stmt|;
comment|// go through each factor and adjust relative to the original
comment|// join order
name|boolean
name|needAdjust
init|=
literal|false
decl_stmt|;
name|int
name|nFieldsNew
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|newPos
init|=
literal|0
init|;
name|newPos
operator|<
name|newJoinOrder
operator|.
name|size
argument_list|()
condition|;
name|newPos
operator|++
control|)
block|{
name|int
name|nFieldsOld
init|=
literal|0
decl_stmt|;
comment|// no need to make any adjustments on the newly added factor
name|int
name|factor
init|=
name|newJoinOrder
operator|.
name|get
argument_list|(
name|newPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|factor
operator|!=
name|factorAdded
condition|)
block|{
comment|// locate the position of the factor in the original join
comment|// ordering
for|for
control|(
name|int
name|pos
range|:
name|origJoinOrder
control|)
block|{
if|if
condition|(
name|factor
operator|==
name|pos
condition|)
block|{
break|break;
block|}
name|nFieldsOld
operator|+=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
comment|// fill in the adjustment array for this factor
if|if
condition|(
name|remapJoinReferences
argument_list|(
name|multiJoin
argument_list|,
name|factor
argument_list|,
name|newJoinOrder
argument_list|,
name|newPos
argument_list|,
name|adjustments
argument_list|,
name|nFieldsOld
argument_list|,
name|nFieldsNew
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|needAdjust
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|nFieldsNew
operator|+=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|factor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needAdjust
condition|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|condition
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|origFields
argument_list|,
name|left
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|right
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|condition
return|;
block|}
comment|/**    * Sets an adjustment array based on where column references for a    * particular factor end up as a result of a new join ordering.    *    *<p>If the factor is not the right factor in a removable self-join, then    * it needs to be adjusted as follows:    *    *<ul>    *<li>First subtract, based on where the factor was in the original join    * ordering.    *<li>Then add on the number of fields in the factors that now precede this    * factor in the new join ordering.    *</ul>    *    *<p>If the factor is the right factor in a removable self-join and its    * column reference can be mapped to the left factor in the self-join, then:    *    *<ul>    *<li>First subtract, based on where the column reference is in the new    * join ordering.    *<li>Then, add on the number of fields up to the start of the left factor    * in the self-join in the new join ordering.    *<li>Then, finally add on the offset of the corresponding column from the    * left factor.    *</ul>    *    *<p>Note that this only applies if both factors in the self-join are in the    * join ordering. If they are, then the left factor always precedes the    * right factor in the join ordering.    *    * @param multiJoin join factors being optimized    * @param factor the factor whose references are being adjusted    * @param newJoinOrder the new join ordering containing the factor    * @param newPos the position of the factor in the new join ordering    * @param adjustments the adjustments array that will be set    * @param offset the starting offset within the original join ordering for    * the columns of the factor being adjusted    * @param newOffset the new starting offset in the new join ordering for the    * columns of the factor being adjusted    * @param alwaysUseDefault always use the default adjustment value    * regardless of whether the factor is the right factor in a removable    * self-join    *    * @return true if at least one column from the factor requires adjustment    */
specifier|private
name|boolean
name|remapJoinReferences
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|int
name|factor
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|newJoinOrder
parameter_list|,
name|int
name|newPos
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|newOffset
parameter_list|,
name|boolean
name|alwaysUseDefault
parameter_list|)
block|{
name|boolean
name|needAdjust
init|=
literal|false
decl_stmt|;
name|int
name|defaultAdjustment
init|=
operator|-
name|offset
operator|+
name|newOffset
decl_stmt|;
if|if
condition|(
operator|!
name|alwaysUseDefault
operator|&&
name|multiJoin
operator|.
name|isRightFactorInRemovableSelfJoin
argument_list|(
name|factor
argument_list|)
operator|&&
operator|(
name|newPos
operator|!=
literal|0
operator|)
operator|&&
name|newJoinOrder
operator|.
name|get
argument_list|(
name|newPos
operator|-
literal|1
argument_list|)
operator|.
name|equals
argument_list|(
name|multiJoin
operator|.
name|getOtherSelfJoinFactor
argument_list|(
name|factor
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|nLeftFields
init|=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|newJoinOrder
operator|.
name|get
argument_list|(
name|newPos
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|factor
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|Integer
name|leftOffset
init|=
name|multiJoin
operator|.
name|getRightColumnMapping
argument_list|(
name|factor
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|// if the left factor doesn't reference the column, then
comment|// use the default adjustment value
if|if
condition|(
name|leftOffset
operator|==
literal|null
condition|)
block|{
name|adjustments
index|[
name|i
operator|+
name|offset
index|]
operator|=
name|defaultAdjustment
expr_stmt|;
block|}
else|else
block|{
name|adjustments
index|[
name|i
operator|+
name|offset
index|]
operator|=
operator|-
operator|(
name|offset
operator|+
name|i
operator|)
operator|+
operator|(
name|newOffset
operator|-
name|nLeftFields
operator|)
operator|+
name|leftOffset
expr_stmt|;
block|}
if|if
condition|(
name|adjustments
index|[
name|i
operator|+
name|offset
index|]
operator|!=
literal|0
condition|)
block|{
name|needAdjust
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|defaultAdjustment
operator|!=
literal|0
condition|)
block|{
name|needAdjust
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|newJoinOrder
operator|.
name|get
argument_list|(
name|newPos
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
operator|+
name|offset
index|]
operator|=
name|defaultAdjustment
expr_stmt|;
block|}
block|}
block|}
return|return
name|needAdjust
return|;
block|}
comment|/**    * In the event that a dimension table does not need to be joined because of    * a semijoin, this method creates a join tree that consists of a projection    * on top of an existing join tree. The existing join tree must contain the    * fact table in the semijoin that allows the dimension table to be removed.    *    *<p>The projection created on top of the join tree mimics a join of the    * fact and dimension tables. In order for the dimension table to have been    * removed, the only fields referenced from the dimension table are its    * dimension keys. Therefore, we can replace these dimension fields with the    * fields corresponding to the semijoin keys from the fact table in the    * projection.    *    * @param multiJoin join factors being optimized    * @param semiJoinOpt optimal semijoins for each factor    * @param factTree existing join tree containing the fact table    * @param dimIdx dimension table factor id    * @param filtersToAdd filters remaining to be added; filters added to the    * new join tree are removed from the list    *    * @return created join tree or null if the corresponding fact table has not    * been joined in yet    */
specifier|private
name|LoptJoinTree
name|createReplacementSemiJoin
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|LoptJoinTree
name|factTree
parameter_list|,
name|int
name|dimIdx
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|)
block|{
comment|// if the current join tree doesn't contain the fact table, then
comment|// don't bother trying to create the replacement join just yet
if|if
condition|(
name|factTree
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|factIdx
init|=
name|multiJoin
operator|.
name|getJoinRemovalFactor
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|joinOrder
init|=
name|factTree
operator|.
name|getTreeOrder
argument_list|()
decl_stmt|;
assert|assert
name|joinOrder
operator|.
name|contains
argument_list|(
name|factIdx
argument_list|)
assert|;
comment|// figure out the position of the fact table in the current jointree
name|int
name|adjustment
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Integer
name|factor
range|:
name|joinOrder
control|)
block|{
if|if
condition|(
name|factor
operator|==
name|factIdx
condition|)
block|{
break|break;
block|}
name|adjustment
operator|+=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|factor
argument_list|)
expr_stmt|;
block|}
comment|// map the dimension keys to the corresponding keys from the fact
comment|// table, based on the fact table's position in the current jointree
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|dimFields
init|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|dimIdx
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|nDimFields
init|=
name|dimFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|Integer
index|[]
name|replacementKeys
init|=
operator|new
name|Integer
index|[
name|nDimFields
index|]
decl_stmt|;
name|SemiJoin
name|semiJoin
init|=
name|multiJoin
operator|.
name|getJoinRemovalSemiJoin
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
name|ImmutableIntList
name|dimKeys
init|=
name|semiJoin
operator|.
name|getRightKeys
argument_list|()
decl_stmt|;
name|ImmutableIntList
name|factKeys
init|=
name|semiJoin
operator|.
name|getLeftKeys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dimKeys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|replacementKeys
index|[
name|dimKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|factKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|adjustment
expr_stmt|;
block|}
return|return
name|createReplacementJoin
argument_list|(
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|semiJoinOpt
argument_list|,
name|factTree
argument_list|,
name|factIdx
argument_list|,
name|dimIdx
argument_list|,
name|dimKeys
argument_list|,
name|replacementKeys
argument_list|,
name|filtersToAdd
argument_list|)
return|;
block|}
comment|/**    * Creates a replacement join, projecting either dummy columns or    * replacement keys from the factor that doesn't actually need to be joined.    *    * @param multiJoin join factors being optimized    * @param semiJoinOpt optimal semijoins for each factor    * @param currJoinTree current join tree being added to    * @param leftIdx if&ge; 0, when creating the replacement join, only consider    * filters that reference leftIdx in currJoinTree; otherwise, consider all    * filters that reference any factor in currJoinTree    * @param factorToAdd new factor whose join can be removed    * @param newKeys join keys that need to be replaced    * @param replacementKeys the keys that replace the join keys; null if we're    * removing the null generating factor in an outer join    * @param filtersToAdd filters remaining to be added; filters added to the    * new join tree are removed from the list    *    * @return created join tree with an appropriate projection for the factor    * that can be removed    */
specifier|private
name|LoptJoinTree
name|createReplacementJoin
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptSemiJoinOptimizer
name|semiJoinOpt
parameter_list|,
name|LoptJoinTree
name|currJoinTree
parameter_list|,
name|int
name|leftIdx
parameter_list|,
name|int
name|factorToAdd
parameter_list|,
name|ImmutableIntList
name|newKeys
parameter_list|,
name|Integer
index|[]
name|replacementKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|)
block|{
comment|// create a projection, projecting the fields from the join tree
comment|// containing the current joinRel and the new factor; for fields
comment|// corresponding to join keys, replace them with the corresponding key
comment|// from the replacementKeys passed in; for other fields, just create a
comment|// null expression as a placeholder for the column; this is done so we
comment|// don't have to adjust the offsets of other expressions that reference
comment|// the new factor; the placeholder expression values should never be
comment|// referenced, so that's why it's ok to create these possibly invalid
comment|// expressions
name|RelNode
name|currJoinRel
init|=
name|currJoinTree
operator|.
name|getJoinTree
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|currFields
init|=
name|currJoinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nCurrFields
init|=
name|currFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newFields
init|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|factorToAdd
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nNewFields
init|=
name|newFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|currJoinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|typeFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nCurrFields
condition|;
name|i
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
name|RexNode
operator|)
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|currFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|,
name|currFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nNewFields
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|projExpr
decl_stmt|;
name|RelDataType
name|newType
init|=
name|newFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|newKeys
operator|.
name|contains
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|replacementKeys
operator|==
literal|null
condition|)
block|{
comment|// null generating factor in an outer join; so make the
comment|// type nullable
name|newType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|newType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|projExpr
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|newType
argument_list|,
name|rexBuilder
operator|.
name|constantNull
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RelDataTypeField
name|mappedField
init|=
name|currFields
operator|.
name|get
argument_list|(
name|replacementKeys
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|RexNode
name|mappedInput
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|mappedField
operator|.
name|getType
argument_list|()
argument_list|,
name|replacementKeys
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// if the types aren't the same, create a cast
if|if
condition|(
name|mappedField
operator|.
name|getType
argument_list|()
operator|==
name|newType
condition|)
block|{
name|projExpr
operator|=
name|mappedInput
expr_stmt|;
block|}
else|else
block|{
name|projExpr
operator|=
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|newFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|mappedInput
argument_list|)
expr_stmt|;
block|}
block|}
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|projExpr
argument_list|,
name|newFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|currJoinRel
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
expr_stmt|;
comment|// remove the join conditions corresponding to the join we're removing;
comment|// we don't actually need to use them, but we need to remove them
comment|// from the list since they're no longer needed
name|LoptJoinTree
name|newTree
init|=
operator|new
name|LoptJoinTree
argument_list|(
name|semiJoinOpt
operator|.
name|getChosenSemiJoin
argument_list|(
name|factorToAdd
argument_list|)
argument_list|,
name|factorToAdd
argument_list|)
decl_stmt|;
name|addFilters
argument_list|(
name|multiJoin
argument_list|,
name|currJoinTree
argument_list|,
name|leftIdx
argument_list|,
name|newTree
argument_list|,
name|filtersToAdd
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Filters referencing factors other than leftIdx and factorToAdd
comment|// still do need to be applied.  So, add them into a separate
comment|// LogicalFilter placed on top off the projection created above.
if|if
condition|(
name|leftIdx
operator|>=
literal|0
condition|)
block|{
name|addAdditionalFilters
argument_list|(
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|currJoinTree
argument_list|,
name|newTree
argument_list|,
name|filtersToAdd
argument_list|)
expr_stmt|;
block|}
comment|// finally, create a join tree consisting of the current join's join
comment|// tree with the newly created projection; note that in the factor
comment|// tree, we act as if we're joining in the new factor, even
comment|// though we really aren't; this is needed so we can map the columns
comment|// from the new factor as we go up in the join tree
return|return
operator|new
name|LoptJoinTree
argument_list|(
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|currJoinTree
operator|.
name|getFactorTree
argument_list|()
argument_list|,
name|newTree
operator|.
name|getFactorTree
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a LogicalJoin given left and right operands and a join condition.    * Swaps the operands if beneficial.    *    * @param multiJoin join factors being optimized    * @param left left operand    * @param right right operand    * @param condition join condition    * @param joinType the join type    * @param fullAdjust true if the join condition reflects the original join    * ordering and therefore has not gone through any type of adjustment yet;    * otherwise, the condition has already been partially adjusted and only    * needs to be further adjusted if swapping is done    * @param filtersToAdd additional filters that may be added on top of the    * resulting LogicalJoin, if the join is a left or right outer join    * @param selfJoin true if the join being created is a self-join that's    * removable    *    * @return created LogicalJoin    */
specifier|private
name|LoptJoinTree
name|createJoinSubtree
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptJoinTree
name|left
parameter_list|,
name|LoptJoinTree
name|right
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|JoinRelType
name|joinType
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|,
name|boolean
name|fullAdjust
parameter_list|,
name|boolean
name|selfJoin
parameter_list|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// swap the inputs if beneficial
if|if
condition|(
name|swapInputs
argument_list|(
name|mq
argument_list|,
name|multiJoin
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|selfJoin
argument_list|)
condition|)
block|{
name|LoptJoinTree
name|tmp
init|=
name|right
decl_stmt|;
name|right
operator|=
name|left
expr_stmt|;
name|left
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|fullAdjust
condition|)
block|{
name|condition
operator|=
name|swapFilter
argument_list|(
name|rexBuilder
argument_list|,
name|multiJoin
argument_list|,
name|right
argument_list|,
name|left
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|INNER
operator|)
operator|&&
operator|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|FULL
operator|)
condition|)
block|{
name|joinType
operator|=
operator|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|LEFT
operator|)
condition|?
name|JoinRelType
operator|.
name|RIGHT
else|:
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fullAdjust
condition|)
block|{
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|multiJoin
operator|.
name|getNumTotalFields
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|needsAdjustment
argument_list|(
name|multiJoin
argument_list|,
name|adjustments
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|selfJoin
argument_list|)
condition|)
block|{
name|condition
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|multiJoin
operator|.
name|getMultiJoinFields
argument_list|()
argument_list|,
name|left
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|right
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|relBuilder
operator|.
name|push
argument_list|(
name|left
operator|.
name|getJoinTree
argument_list|()
argument_list|)
operator|.
name|push
argument_list|(
name|right
operator|.
name|getJoinTree
argument_list|()
argument_list|)
operator|.
name|join
argument_list|(
name|joinType
argument_list|,
name|condition
argument_list|)
expr_stmt|;
comment|// if this is a left or right outer join, and additional filters can
comment|// be applied to the resulting join, then they need to be applied
comment|// as a filter on top of the outer join result
if|if
condition|(
operator|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|||
operator|(
name|joinType
operator|==
name|JoinRelType
operator|.
name|RIGHT
operator|)
condition|)
block|{
assert|assert
operator|!
name|selfJoin
assert|;
name|addAdditionalFilters
argument_list|(
name|relBuilder
argument_list|,
name|multiJoin
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|filtersToAdd
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|LoptJoinTree
argument_list|(
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|left
operator|.
name|getFactorTree
argument_list|()
argument_list|,
name|right
operator|.
name|getFactorTree
argument_list|()
argument_list|,
name|selfJoin
argument_list|)
return|;
block|}
comment|/**    * Determines whether any additional filters are applicable to a join tree.    * If there are any, creates a filter node on top of the join tree with the    * additional filters.    *    * @param relBuilder Builder holding current join tree    * @param multiJoin join factors being optimized    * @param left left side of join tree    * @param right right side of join tree    * @param filtersToAdd remaining filters    */
specifier|private
name|void
name|addAdditionalFilters
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptJoinTree
name|left
parameter_list|,
name|LoptJoinTree
name|right
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|filtersToAdd
parameter_list|)
block|{
name|RexNode
name|filterCond
init|=
name|addFilters
argument_list|(
name|multiJoin
argument_list|,
name|left
argument_list|,
operator|-
literal|1
argument_list|,
name|right
argument_list|,
name|filtersToAdd
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filterCond
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// adjust the filter to reflect the outer join output
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|multiJoin
operator|.
name|getNumTotalFields
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|needsAdjustment
argument_list|(
name|multiJoin
argument_list|,
name|adjustments
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|RexBuilder
name|rexBuilder
init|=
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|filterCond
operator|=
name|filterCond
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|multiJoin
operator|.
name|getMultiJoinFields
argument_list|()
argument_list|,
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|filter
argument_list|(
name|filterCond
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Swaps the operands to a join, so the smaller input is on the right. Or,    * if this is a removable self-join, swap so the factor that should be    * preserved when the self-join is removed is put on the left.    *    * @param multiJoin join factors being optimized    * @param left left side of join tree    * @param right right hand side of join tree    * @param selfJoin true if the join is a removable self-join    *    * @return true if swapping should be done    */
specifier|private
name|boolean
name|swapInputs
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptJoinTree
name|left
parameter_list|,
name|LoptJoinTree
name|right
parameter_list|,
name|boolean
name|selfJoin
parameter_list|)
block|{
name|boolean
name|swap
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|selfJoin
condition|)
block|{
return|return
operator|!
name|multiJoin
operator|.
name|isLeftFactorInRemovableSelfJoin
argument_list|(
operator|(
operator|(
name|LoptJoinTree
operator|.
name|Leaf
operator|)
name|left
operator|.
name|getFactorTree
argument_list|()
operator|)
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
specifier|final
name|Double
name|leftRowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|left
operator|.
name|getJoinTree
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Double
name|rightRowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|right
operator|.
name|getJoinTree
argument_list|()
argument_list|)
decl_stmt|;
comment|// The left side is smaller than the right if it has fewer rows,
comment|// or if it has the same number of rows as the right (excluding
comment|// roundoff), but fewer columns.
if|if
condition|(
operator|(
name|leftRowCount
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rightRowCount
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|(
name|leftRowCount
operator|<
name|rightRowCount
operator|)
operator|||
operator|(
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|leftRowCount
operator|-
name|rightRowCount
argument_list|)
operator|<
name|RelOptUtil
operator|.
name|EPSILON
operator|)
operator|&&
operator|(
name|rowWidthCost
argument_list|(
name|left
operator|.
name|getJoinTree
argument_list|()
argument_list|)
operator|<
name|rowWidthCost
argument_list|(
name|right
operator|.
name|getJoinTree
argument_list|()
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|swap
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|swap
return|;
block|}
comment|/**    * Adjusts a filter to reflect swapping of join inputs    *    * @param rexBuilder rexBuilder    * @param multiJoin join factors being optimized    * @param origLeft original LHS of the join tree (before swap)    * @param origRight original RHS of the join tree (before swap)    * @param condition original join condition    *    * @return join condition reflect swap of join inputs    */
specifier|private
name|RexNode
name|swapFilter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LoptJoinTree
name|origLeft
parameter_list|,
name|LoptJoinTree
name|origRight
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
name|int
name|nFieldsOnLeft
init|=
name|origLeft
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|nFieldsOnRight
init|=
name|origRight
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|nFieldsOnLeft
operator|+
name|nFieldsOnRight
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nFieldsOnLeft
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
name|nFieldsOnRight
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|nFieldsOnLeft
init|;
name|i
operator|<
operator|(
name|nFieldsOnLeft
operator|+
name|nFieldsOnRight
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
operator|-
name|nFieldsOnLeft
expr_stmt|;
block|}
name|condition
operator|=
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|multiJoin
operator|.
name|getJoinFields
argument_list|(
name|origLeft
argument_list|,
name|origRight
argument_list|)
argument_list|,
name|multiJoin
operator|.
name|getJoinFields
argument_list|(
name|origRight
argument_list|,
name|origLeft
argument_list|)
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|condition
return|;
block|}
comment|/**    * Sets an array indicating how much each factor in a join tree needs to be    * adjusted to reflect the tree's join ordering    *    * @param multiJoin join factors being optimized    * @param adjustments array to be filled out    * @param joinTree join tree    * @param otherTree null unless joinTree only represents the left side of    * the join tree    * @param selfJoin true if no adjustments need to be made for self-joins    *    * @return true if some adjustment is required; false otherwise    */
specifier|private
name|boolean
name|needsAdjustment
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|,
name|LoptJoinTree
name|joinTree
parameter_list|,
name|LoptJoinTree
name|otherTree
parameter_list|,
name|boolean
name|selfJoin
parameter_list|)
block|{
name|boolean
name|needAdjustment
init|=
literal|false
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|joinOrder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|joinTree
operator|.
name|getTreeOrder
argument_list|(
name|joinOrder
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherTree
operator|!=
literal|null
condition|)
block|{
name|otherTree
operator|.
name|getTreeOrder
argument_list|(
name|joinOrder
argument_list|)
expr_stmt|;
block|}
name|int
name|nFields
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|newPos
init|=
literal|0
init|;
name|newPos
operator|<
name|joinOrder
operator|.
name|size
argument_list|()
condition|;
name|newPos
operator|++
control|)
block|{
name|int
name|origPos
init|=
name|joinOrder
operator|.
name|get
argument_list|(
name|newPos
argument_list|)
decl_stmt|;
name|int
name|joinStart
init|=
name|multiJoin
operator|.
name|getJoinStart
argument_list|(
name|origPos
argument_list|)
decl_stmt|;
comment|// Determine the adjustments needed for join references.  Note
comment|// that if the adjustment is being done for a self-join filter,
comment|// we always use the default adjustment value rather than
comment|// remapping the right factor to reference the left factor.
comment|// Otherwise, we have no way of later identifying that the join is
comment|// self-join.
if|if
condition|(
name|remapJoinReferences
argument_list|(
name|multiJoin
argument_list|,
name|origPos
argument_list|,
name|joinOrder
argument_list|,
name|newPos
argument_list|,
name|adjustments
argument_list|,
name|joinStart
argument_list|,
name|nFields
argument_list|,
name|selfJoin
argument_list|)
condition|)
block|{
name|needAdjustment
operator|=
literal|true
expr_stmt|;
block|}
name|nFields
operator|+=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|origPos
argument_list|)
expr_stmt|;
block|}
return|return
name|needAdjustment
return|;
block|}
comment|/**    * Determines whether a join is a removable self-join. It is if it's an    * inner join between identical, simple factors and the equality portion of    * the join condition consists of the same set of unique keys.    *    * @param joinRel the join    *    * @return true if the join is removable    */
specifier|public
specifier|static
name|boolean
name|isRemovableSelfJoin
parameter_list|(
name|Join
name|joinRel
parameter_list|)
block|{
specifier|final
name|RelNode
name|left
init|=
name|joinRel
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|right
init|=
name|joinRel
operator|.
name|getRight
argument_list|()
decl_stmt|;
if|if
condition|(
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|!=
name|JoinRelType
operator|.
name|INNER
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Make sure the join is between the same simple factor
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|leftTable
init|=
name|mq
operator|.
name|getTableOrigin
argument_list|(
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftTable
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|RelOptTable
name|rightTable
init|=
name|mq
operator|.
name|getTableOrigin
argument_list|(
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightTable
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|leftTable
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|rightTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Determine if the join keys are identical and unique
return|return
name|areSelfJoinKeysUnique
argument_list|(
name|mq
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|joinRel
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Determines if the equality portion of a self-join condition is between    * identical keys that are unique.    *    * @param mq Metadata query    * @param leftRel left side of the join    * @param rightRel right side of the join    * @param joinFilters the join condition    *    * @return true if the equality join keys are the same and unique    */
specifier|private
specifier|static
name|boolean
name|areSelfJoinKeysUnique
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|leftRel
parameter_list|,
name|RelNode
name|rightRel
parameter_list|,
name|RexNode
name|joinFilters
parameter_list|)
block|{
specifier|final
name|JoinInfo
name|joinInfo
init|=
name|JoinInfo
operator|.
name|of
argument_list|(
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|joinFilters
argument_list|)
decl_stmt|;
comment|// Make sure each key on the left maps to the same simple column as the
comment|// corresponding key on the right
for|for
control|(
name|IntPair
name|pair
range|:
name|joinInfo
operator|.
name|pairs
argument_list|()
control|)
block|{
specifier|final
name|RelColumnOrigin
name|leftOrigin
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|leftRel
argument_list|,
name|pair
operator|.
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftOrigin
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|RelColumnOrigin
name|rightOrigin
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|rightRel
argument_list|,
name|pair
operator|.
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightOrigin
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|leftOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
operator|!=
name|rightOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Now that we've verified that the keys are the same, see if they
comment|// are unique.  When removing self-joins, if needed, we'll later add an
comment|// IS NOT NULL filter on the join keys that are nullable.  Therefore,
comment|// it's ok if there are nulls in the unique key.
return|return
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUniqueWhenNullsFiltered
argument_list|(
name|mq
argument_list|,
name|leftRel
argument_list|,
name|joinInfo
operator|.
name|leftSet
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|// End LoptOptimizeJoinRule.java
end_comment

end_unit

