begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|materialize
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleOperand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|SubstitutionVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelReferentialConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultDirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultEdge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashBiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Planner rule that converts a {@link org.apache.calcite.rel.core.Project}  * followed by {@link org.apache.calcite.rel.core.Aggregate} or an  * {@link org.apache.calcite.rel.core.Aggregate} to a scan (and possibly  * other operations) over a materialized view.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|MaterializedViewRule
extends|extends
name|RelOptRule
block|{
comment|//~ Instance fields --------------------------------------------------------
comment|/** Whether to generate rewritings containing union if the query results    * are contained within the view results. */
specifier|protected
specifier|final
name|boolean
name|generateUnionRewriting
decl_stmt|;
comment|/** If we generate union rewriting, we might want to pull up projections    * from the query itself to maximize rewriting opportunities. */
specifier|protected
specifier|final
name|HepProgram
name|unionRewritingPullProgram
decl_stmt|;
comment|/** Whether we should create the rewriting in the minimal subtree of plan    * operators. */
specifier|protected
specifier|final
name|boolean
name|fastBailOut
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/** Creates a AbstractMaterializedViewRule. */
specifier|protected
name|MaterializedViewRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|,
name|boolean
name|fastBailOut
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|this
operator|.
name|generateUnionRewriting
operator|=
name|generateUnionRewriting
expr_stmt|;
name|this
operator|.
name|unionRewritingPullProgram
operator|=
name|unionRewritingPullProgram
expr_stmt|;
name|this
operator|.
name|fastBailOut
operator|=
name|fastBailOut
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
return|return
operator|!
name|call
operator|.
name|getPlanner
argument_list|()
operator|.
name|getMaterializations
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Rewriting logic is based on "Optimizing Queries Using Materialized Views:    * A Practical, Scalable Solution" by Goldstein and Larson.    *    *<p>On the query side, rules matches a Project-node chain or node, where node    * is either an Aggregate or a Join. Subplan rooted at the node operator must    * be composed of one or more of the following operators: TableScan, Project,    * Filter, and Join.    *    *<p>For each join MV, we need to check the following:    *<ol>    *<li> The plan rooted at the Join operator in the view produces all rows    * needed by the plan rooted at the Join operator in the query.</li>    *<li> All columns required by compensating predicates, i.e., predicates that    * need to be enforced over the view, are available at the view output.</li>    *<li> All output expressions can be computed from the output of the view.</li>    *<li> All output rows occur with the correct duplication factor. We might    * rely on existing Unique-Key - Foreign-Key relationships to extract that    * information.</li>    *</ol>    *    *<p>In turn, for each aggregate MV, we need to check the following:    *<ol>    *<li> The plan rooted at the Aggregate operator in the view produces all rows    * needed by the plan rooted at the Aggregate operator in the query.</li>    *<li> All columns required by compensating predicates, i.e., predicates that    * need to be enforced over the view, are available at the view output.</li>    *<li> The grouping columns in the query are a subset of the grouping columns    * in the view.</li>    *<li> All columns required to perform further grouping are available in the    * view output.</li>    *<li> All columns required to compute output expressions are available in the    * view output.</li>    *</ol>    *    *<p>The rule contains multiple extensions compared to the original paper. One of    * them is the possibility of creating rewritings using Union operators, e.g., if    * the result of a query is partially contained in the materialized view.    */
specifier|protected
name|void
name|perform
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|node
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|call
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPlanner
name|planner
init|=
name|call
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|Util
operator|.
name|first
argument_list|(
name|planner
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|RelOptPredicateList
operator|.
name|EMPTY
decl_stmt|;
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|predicates
argument_list|,
name|executor
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
init|=
name|planner
operator|.
name|getMaterializations
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|materializations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// 1. Explore query plan to recognize whether preconditions to
comment|// try to generate a rewriting are met
if|if
condition|(
operator|!
name|isValidPlan
argument_list|(
name|topProject
argument_list|,
name|node
argument_list|,
name|mq
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// 2. Initialize all query related auxiliary data structures
comment|// that will be used throughout query rewriting process
comment|// Generate query table references
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryTableRefs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return;
block|}
comment|// Extract query predicates
specifier|final
name|RelOptPredicateList
name|queryPredicateList
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryPredicateList
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return;
block|}
specifier|final
name|RexNode
name|pred
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|queryPredicateList
operator|.
name|pulledUpPredicates
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|queryPreds
init|=
name|splitPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|pred
argument_list|)
decl_stmt|;
comment|// Extract query equivalence classes. An equivalence class is a set
comment|// of columns in the query output that are known to be equal.
specifier|final
name|EquivalenceClasses
name|qEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|queryPreds
operator|.
name|left
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|qEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. We iterate through all applicable materializations trying to
comment|// rewrite the given query
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|materializations
control|)
block|{
name|RelNode
name|view
init|=
name|materialization
operator|.
name|tableRel
decl_stmt|;
name|Project
name|topViewProject
decl_stmt|;
name|RelNode
name|viewNode
decl_stmt|;
if|if
condition|(
name|materialization
operator|.
name|queryRel
operator|instanceof
name|Project
condition|)
block|{
name|topViewProject
operator|=
operator|(
name|Project
operator|)
name|materialization
operator|.
name|queryRel
expr_stmt|;
name|viewNode
operator|=
name|topViewProject
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|topViewProject
operator|=
literal|null
expr_stmt|;
name|viewNode
operator|=
name|materialization
operator|.
name|queryRel
expr_stmt|;
block|}
comment|// Extract view table references
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|viewNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewTableRefs
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// Filter relevant materializations. Currently, we only check whether
comment|// the materialization contains any table that is used by the query
comment|// TODO: Filtering of relevant materializations can be improved to be more fine-grained.
name|boolean
name|applicable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tableRef
range|:
name|viewTableRefs
control|)
block|{
if|if
condition|(
name|queryTableRefs
operator|.
name|contains
argument_list|(
name|tableRef
argument_list|)
condition|)
block|{
name|applicable
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|applicable
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// 3.1. View checks before proceeding
if|if
condition|(
operator|!
name|isValidPlan
argument_list|(
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|mq
argument_list|)
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// 3.2. Initialize all query related auxiliary data structures
comment|// that will be used throughout query rewriting process
comment|// Extract view predicates
specifier|final
name|RelOptPredicateList
name|viewPredicateList
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|viewNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewPredicateList
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
specifier|final
name|RexNode
name|viewPred
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|viewPredicateList
operator|.
name|pulledUpPredicates
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|viewPreds
init|=
name|splitPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|viewPred
argument_list|)
decl_stmt|;
comment|// Extract view tables
name|MatchModality
name|matchModality
decl_stmt|;
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|compensationEquiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|queryTableRefs
operator|.
name|equals
argument_list|(
name|viewTableRefs
argument_list|)
condition|)
block|{
comment|// We try to compensate, e.g., for join queries it might be
comment|// possible to join missing tables with view to compute result.
comment|// Two supported cases: query tables are subset of view tables (we need to
comment|// check whether they are cardinality-preserving joins), or view tables are
comment|// subset of query tables (add additional tables through joins if possible)
if|if
condition|(
name|viewTableRefs
operator|.
name|containsAll
argument_list|(
name|queryTableRefs
argument_list|)
condition|)
block|{
name|matchModality
operator|=
name|MatchModality
operator|.
name|QUERY_PARTIAL
expr_stmt|;
specifier|final
name|EquivalenceClasses
name|vEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|viewPreds
operator|.
name|left
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|vEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compensatePartial
argument_list|(
name|viewTableRefs
argument_list|,
name|vEC
argument_list|,
name|queryTableRefs
argument_list|,
name|compensationEquiColumns
argument_list|)
condition|)
block|{
comment|// Cannot rewrite, skip it
continue|continue;
block|}
block|}
if|else if
condition|(
name|queryTableRefs
operator|.
name|containsAll
argument_list|(
name|viewTableRefs
argument_list|)
condition|)
block|{
name|matchModality
operator|=
name|MatchModality
operator|.
name|VIEW_PARTIAL
expr_stmt|;
name|ViewPartialRewriting
name|partialRewritingResult
init|=
name|compensateViewPartial
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|view
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|queryTableRefs
argument_list|,
name|qEC
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|viewTableRefs
argument_list|)
decl_stmt|;
if|if
condition|(
name|partialRewritingResult
operator|==
literal|null
condition|)
block|{
comment|// Cannot rewrite, skip it
continue|continue;
block|}
comment|// Rewrite succeeded
name|view
operator|=
name|partialRewritingResult
operator|.
name|newView
expr_stmt|;
name|topViewProject
operator|=
name|partialRewritingResult
operator|.
name|newTopViewProject
expr_stmt|;
name|viewNode
operator|=
name|partialRewritingResult
operator|.
name|newViewNode
expr_stmt|;
block|}
else|else
block|{
comment|// Skip it
continue|continue;
block|}
block|}
else|else
block|{
name|matchModality
operator|=
name|MatchModality
operator|.
name|COMPLETE
expr_stmt|;
block|}
comment|// 4. We map every table in the query to a table with the same qualified
comment|// name (all query tables are contained in the view, thus this is equivalent
comment|// to mapping every table in the query to a view table).
specifier|final
name|Multimap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|multiMapTables
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|queryTableRef1
range|:
name|queryTableRefs
control|)
block|{
for|for
control|(
name|RelTableRef
name|queryTableRef2
range|:
name|queryTableRefs
control|)
block|{
if|if
condition|(
name|queryTableRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|queryTableRef2
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
name|multiMapTables
operator|.
name|put
argument_list|(
name|queryTableRef1
argument_list|,
name|queryTableRef2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If a table is used multiple times, we will create multiple mappings,
comment|// and we will try to rewrite the query using each of the mappings.
comment|// Then, we will try to map every source table (query) to a target
comment|// table (view), and if we are successful, we will try to create
comment|// compensation predicates to filter the view results further
comment|// (if needed).
specifier|final
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|flatListMappings
init|=
name|generateTableMappings
argument_list|(
name|multiMapTables
argument_list|)
decl_stmt|;
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
range|:
name|flatListMappings
control|)
block|{
comment|// TableMapping : mapping query tables -> view tables
comment|// 4.0. If compensation equivalence classes exist, we need to add
comment|// the mapping to the query mapping
specifier|final
name|EquivalenceClasses
name|currQEC
init|=
name|EquivalenceClasses
operator|.
name|copy
argument_list|(
name|qEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchModality
operator|==
name|MatchModality
operator|.
name|QUERY_PARTIAL
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|e
range|:
name|compensationEquiColumns
operator|.
name|entries
argument_list|()
control|)
block|{
comment|// Copy origin
name|RelTableRef
name|queryTableRef
init|=
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|)
decl_stmt|;
name|RexTableInputRef
name|queryColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|queryTableRef
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
comment|// Add to query equivalence classes and table mapping
name|currQEC
operator|.
name|addEquivalenceClass
argument_list|(
name|queryColumnRef
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|queryToViewTableMapping
operator|.
name|put
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|)
expr_stmt|;
comment|// identity
block|}
block|}
comment|// 4.1. Compute compensation predicates, i.e., predicates that need to be
comment|// enforced over the view to retain query semantics. The resulting predicates
comment|// are expressed using {@link RexTableInputRef} over the query.
comment|// First, to establish relationship, we swap column references of the view
comment|// predicates to point to query tables and compute equivalence classes.
specifier|final
name|RexNode
name|viewColumnsEquiPred
init|=
name|RexUtil
operator|.
name|swapTableReferences
argument_list|(
name|rexBuilder
argument_list|,
name|viewPreds
operator|.
name|left
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|EquivalenceClasses
name|queryBasedVEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|viewColumnsEquiPred
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|queryBasedVEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|compensationPreds
init|=
name|computeCompensationPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|currQEC
argument_list|,
name|queryPreds
argument_list|,
name|queryBasedVEC
argument_list|,
name|viewPreds
argument_list|,
name|queryToViewTableMapping
argument_list|)
decl_stmt|;
if|if
condition|(
name|compensationPreds
operator|==
literal|null
operator|&&
name|generateUnionRewriting
condition|)
block|{
comment|// Attempt partial rewriting using union operator. This rewriting
comment|// will read some data from the view and the rest of the data from
comment|// the query computation. The resulting predicates are expressed
comment|// using {@link RexTableInputRef} over the view.
name|compensationPreds
operator|=
name|computeCompensationPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|queryBasedVEC
argument_list|,
name|viewPreds
argument_list|,
name|currQEC
argument_list|,
name|queryPreds
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationPreds
operator|==
literal|null
condition|)
block|{
comment|// This was our last chance to use the view, skip it
continue|continue;
block|}
name|RexNode
name|compensationColumnsEquiPred
init|=
name|compensationPreds
operator|.
name|left
decl_stmt|;
name|RexNode
name|otherCompensationPred
init|=
name|compensationPreds
operator|.
name|right
decl_stmt|;
assert|assert
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
operator|||
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
assert|;
comment|// b. Generate union branch (query).
specifier|final
name|RelNode
name|unionInputQuery
init|=
name|rewriteQuery
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|mq
argument_list|,
name|compensationColumnsEquiPred
argument_list|,
name|otherCompensationPred
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|queryBasedVEC
argument_list|,
name|currQEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|unionInputQuery
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// c. Generate union branch (view).
comment|// We trigger the unifying method. This method will either create a Project
comment|// or an Aggregate operator on top of the view. It will also compute the
comment|// output expressions for the query.
specifier|final
name|RelNode
name|unionInputView
init|=
name|rewriteView
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|mq
argument_list|,
name|matchModality
argument_list|,
literal|true
argument_list|,
name|view
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|currQEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|unionInputView
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// d. Generate final rewriting (union).
specifier|final
name|RelNode
name|result
init|=
name|createUnion
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|rexBuilder
argument_list|,
name|topProject
argument_list|,
name|unionInputQuery
argument_list|,
name|unionInputView
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|compensationPreds
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|compensationColumnsEquiPred
init|=
name|compensationPreds
operator|.
name|left
decl_stmt|;
name|RexNode
name|otherCompensationPred
init|=
name|compensationPreds
operator|.
name|right
decl_stmt|;
comment|// a. Compute final compensation predicate.
if|if
condition|(
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
operator|||
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// All columns required by compensating predicates must be contained
comment|// in the view output (condition 2).
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
init|=
name|topViewProject
operator|==
literal|null
condition|?
name|extractReferences
argument_list|(
name|rexBuilder
argument_list|,
name|view
argument_list|)
else|:
name|topViewProject
operator|.
name|getProjects
argument_list|()
decl_stmt|;
comment|// For compensationColumnsEquiPred, we use the view equivalence classes,
comment|// since we want to enforce the rest
if|if
condition|(
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|compensationColumnsEquiPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|view
argument_list|,
name|viewNode
argument_list|,
name|viewExprs
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|queryBasedVEC
argument_list|,
literal|false
argument_list|,
name|compensationColumnsEquiPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationColumnsEquiPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
block|}
comment|// For the rest, we use the query equivalence classes
if|if
condition|(
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|otherCompensationPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|view
argument_list|,
name|viewNode
argument_list|,
name|viewExprs
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|currQEC
argument_list|,
literal|true
argument_list|,
name|otherCompensationPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherCompensationPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
block|}
block|}
specifier|final
name|RexNode
name|viewCompensationPred
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|compensationColumnsEquiPred
argument_list|,
name|otherCompensationPred
argument_list|)
argument_list|)
decl_stmt|;
comment|// b. Generate final rewriting if possible.
comment|// First, we add the compensation predicate (if any) on top of the view.
comment|// Then, we trigger the unifying method. This method will either create a
comment|// Project or an Aggregate operator on top of the view. It will also compute
comment|// the output expressions for the query.
name|RelBuilder
name|builder
init|=
name|call
operator|.
name|builder
argument_list|()
operator|.
name|transform
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withPruneInputOfAggregate
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|RelNode
name|viewWithFilter
decl_stmt|;
if|if
condition|(
operator|!
name|viewCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|RexNode
name|newPred
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|viewCompensationPred
argument_list|)
decl_stmt|;
name|viewWithFilter
operator|=
name|builder
operator|.
name|push
argument_list|(
name|view
argument_list|)
operator|.
name|filter
argument_list|(
name|newPred
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// No need to do anything if it's a leaf node.
if|if
condition|(
name|viewWithFilter
operator|.
name|getInputs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|call
operator|.
name|transformTo
argument_list|(
name|viewWithFilter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// We add (and push) the filter to the view plan before triggering the rewriting.
comment|// This is useful in case some of the columns can be folded to same value after
comment|// filter is added.
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|pushedNodes
init|=
name|pushFilterToOriginalViewPlan
argument_list|(
name|builder
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|newPred
argument_list|)
decl_stmt|;
name|topViewProject
operator|=
operator|(
name|Project
operator|)
name|pushedNodes
operator|.
name|left
expr_stmt|;
name|viewNode
operator|=
name|pushedNodes
operator|.
name|right
expr_stmt|;
block|}
else|else
block|{
name|viewWithFilter
operator|=
name|builder
operator|.
name|push
argument_list|(
name|view
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RelNode
name|result
init|=
name|rewriteView
argument_list|(
name|builder
argument_list|,
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|mq
argument_list|,
name|matchModality
argument_list|,
literal|false
argument_list|,
name|viewWithFilter
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|currQEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
comment|// end else
block|}
block|}
block|}
block|}
specifier|protected
specifier|abstract
name|boolean
name|isValidPlan
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
function_decl|;
comment|/**    * It checks whether the query can be rewritten using the view even though the    * query uses additional tables.    *    *<p>Rules implementing the method should follow different approaches depending on the    * operators they rewrite.    */
specifier|protected
specifier|abstract
name|ViewPartialRewriting
name|compensateViewPartial
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
parameter_list|)
function_decl|;
comment|/**    * If the view will be used in a union rewriting, this method is responsible for    * rewriting the query branch of the union using the given compensation predicate.    *    *<p>If a rewriting can be produced, we return that rewriting. If it cannot    * be produced, we will return null.    */
specifier|protected
specifier|abstract
name|RelNode
name|rewriteQuery
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|compensationColumnsEquiPred
parameter_list|,
name|RexNode
name|otherCompensationPred
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|viewToQueryTableMapping
parameter_list|,
name|EquivalenceClasses
name|viewEC
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
function_decl|;
comment|/**    * If the view will be used in a union rewriting, this method is responsible for    * generating the union and any other operator needed on top of it, e.g., a Project    * operator.    */
specifier|protected
specifier|abstract
name|RelNode
name|createUnion
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|topProject
parameter_list|,
name|RelNode
name|unionInputQuery
parameter_list|,
name|RelNode
name|unionInputView
parameter_list|)
function_decl|;
comment|/**    * Rewrites the query using the given view query.    *    *<p>The input node is a Scan on the view table and possibly a compensation Filter    * on top. If a rewriting can be produced, we return that rewriting. If it cannot    * be produced, we will return null.    */
specifier|protected
specifier|abstract
name|RelNode
name|rewriteView
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|MatchModality
name|matchModality
parameter_list|,
name|boolean
name|unionRewriting
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
function_decl|;
comment|/**    * Once we create a compensation predicate, this method is responsible for pushing    * the resulting filter through the view nodes. This might be useful for rewritings    * containing Aggregate operators, as some of the grouping columns might be removed,    * which results in additional matching possibilities.    *    *<p>The method will return a pair of nodes: the new top project on the left and    * the new node on the right.    */
specifier|protected
specifier|abstract
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|pushFilterToOriginalViewPlan
parameter_list|(
name|RelBuilder
name|builder
parameter_list|,
name|RelNode
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|RexNode
name|cond
parameter_list|)
function_decl|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * If the node is an Aggregate, it returns a list of references to the grouping columns.    * Otherwise, it returns a list of references to all columns in the node.    * The returned list is immutable.    */
specifier|protected
name|List
argument_list|<
name|RexNode
argument_list|>
name|extractReferences
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|node
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|Aggregate
condition|)
block|{
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|aggregate
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|exprs
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * It will flatten a multimap containing table references to table references,    * producing all possible combinations of mappings. Each of the mappings will    * be bi-directional.    */
specifier|protected
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|generateTableMappings
parameter_list|(
name|Multimap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|multiMapTables
parameter_list|)
block|{
if|if
condition|(
name|multiMapTables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|result
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|HashBiMap
operator|.
name|create
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|RelTableRef
argument_list|,
name|Collection
argument_list|<
name|RelTableRef
argument_list|>
argument_list|>
name|e
range|:
name|multiMapTables
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Only one reference, we can just add it to every map
name|RelTableRef
name|target
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|m
range|:
name|result
control|)
block|{
name|m
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|// Multiple references: flatten
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|newResult
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|target
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|m
range|:
name|result
control|)
block|{
if|if
condition|(
operator|!
name|m
operator|.
name|containsValue
argument_list|(
name|target
argument_list|)
condition|)
block|{
specifier|final
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|newM
init|=
name|HashBiMap
operator|.
name|create
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|newM
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|newResult
operator|.
name|add
argument_list|(
name|newM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|result
operator|=
name|newResult
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** Currently we only support TableScan - Project - Filter - Inner Join */
specifier|protected
name|boolean
name|isValidRelNodePlan
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
specifier|final
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|m
init|=
name|mq
operator|.
name|getNodeTypes
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|RelNode
argument_list|>
argument_list|>
name|e
range|:
name|m
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|c
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|TableScan
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|Project
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|Filter
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
operator|!
name|Join
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
comment|// Skip it
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Join
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
name|RelNode
name|n
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|n
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|!=
name|JoinRelType
operator|.
name|INNER
operator|&&
operator|!
name|join
operator|.
name|isSemiJoin
argument_list|()
condition|)
block|{
comment|// Skip it
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Classifies each of the predicates in the list into one of these two    * categories:    *    *<ul>    *<li> 1-l) column equality predicates, or    *<li> 2-r) residual predicates, all the rest    *</ul>    *    *<p>For each category, it creates the conjunction of the predicates. The    * result is an pair of RexNode objects corresponding to each category.    */
specifier|protected
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|splitPredicates
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|pred
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|equiColumnsPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|residualPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|pred
argument_list|)
control|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
name|RexCall
name|eqCall
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|equiColumnsPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|residualPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|residualPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|equiColumnsPreds
argument_list|)
argument_list|,
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|residualPreds
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * It checks whether the target can be rewritten using the source even though the    * source uses additional tables. In order to do that, we need to double-check    * that every join that exists in the source and is not in the target is a    * cardinality-preserving join, i.e., it only appends columns to the row    * without changing its multiplicity. Thus, the join needs to be:    *<ul>    *<li> Equi-join</li>    *<li> Between all columns in the keys</li>    *<li> Foreign-key columns do not allow NULL values</li>    *<li> Foreign-key</li>    *<li> Unique-key</li>    *</ul>    *    *<p>If it can be rewritten, it returns true. Further, it inserts the missing equi-join    * predicates in the input {@code compensationEquiColumns} multimap if it is provided.    * If it cannot be rewritten, it returns false.    */
specifier|protected
name|boolean
name|compensatePartial
parameter_list|(
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|sourceTableRefs
parameter_list|,
name|EquivalenceClasses
name|sourceEC
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|targetTableRefs
parameter_list|,
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|compensationEquiColumns
parameter_list|)
block|{
comment|// Create UK-FK graph with view tables
specifier|final
name|DirectedGraph
argument_list|<
name|RelTableRef
argument_list|,
name|Edge
argument_list|>
name|graph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|(
name|Edge
operator|::
operator|new
argument_list|)
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelTableRef
argument_list|>
name|tableVNameToTableRefs
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|extraTableRefs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|sourceTableRefs
control|)
block|{
comment|// Add tables in view as vertices
name|graph
operator|.
name|addVertex
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
name|tableVNameToTableRefs
operator|.
name|put
argument_list|(
name|tRef
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|tRef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targetTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// Add to extra tables if table is not part of the query
name|extraTableRefs
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|graph
operator|.
name|vertexSet
argument_list|()
control|)
block|{
comment|// Add edges between tables
name|List
argument_list|<
name|RelReferentialConstraint
argument_list|>
name|constraints
init|=
name|tRef
operator|.
name|getTable
argument_list|()
operator|.
name|getReferentialConstraints
argument_list|()
decl_stmt|;
for|for
control|(
name|RelReferentialConstraint
name|constraint
range|:
name|constraints
control|)
block|{
name|Collection
argument_list|<
name|RelTableRef
argument_list|>
name|parentTableRefs
init|=
name|tableVNameToTableRefs
operator|.
name|get
argument_list|(
name|constraint
operator|.
name|getTargetQualifiedName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RelTableRef
name|parentTRef
range|:
name|parentTableRefs
control|)
block|{
name|boolean
name|canBeRewritten
init|=
literal|true
decl_stmt|;
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|equiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|constraint
operator|.
name|getNumColumns
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|int
name|foreignKeyPos
init|=
name|constraint
operator|.
name|getColumnPairs
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|source
decl_stmt|;
name|RelDataType
name|foreignKeyColumnType
init|=
name|tRef
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|foreignKeyPos
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexTableInputRef
name|foreignKeyColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|tRef
argument_list|,
name|foreignKeyPos
argument_list|,
name|foreignKeyColumnType
argument_list|)
decl_stmt|;
name|int
name|uniqueKeyPos
init|=
name|constraint
operator|.
name|getColumnPairs
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|target
decl_stmt|;
name|RexTableInputRef
name|uniqueKeyColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|parentTRef
argument_list|,
name|uniqueKeyPos
argument_list|,
name|parentTRef
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|uniqueKeyPos
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|foreignKeyColumnType
operator|.
name|isNullable
argument_list|()
operator|&&
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|uniqueKeyColumnRef
argument_list|)
operator|&&
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
operator|.
name|get
argument_list|(
name|uniqueKeyColumnRef
argument_list|)
operator|.
name|contains
argument_list|(
name|foreignKeyColumnRef
argument_list|)
condition|)
block|{
name|equiColumns
operator|.
name|put
argument_list|(
name|foreignKeyColumnRef
argument_list|,
name|uniqueKeyColumnRef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canBeRewritten
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|canBeRewritten
condition|)
block|{
comment|// Add edge FK -> UK
name|Edge
name|edge
init|=
name|graph
operator|.
name|getEdge
argument_list|(
name|tRef
argument_list|,
name|parentTRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|==
literal|null
condition|)
block|{
name|edge
operator|=
name|graph
operator|.
name|addEdge
argument_list|(
name|tRef
argument_list|,
name|parentTRef
argument_list|)
expr_stmt|;
block|}
name|edge
operator|.
name|equiColumns
operator|.
name|putAll
argument_list|(
name|equiColumns
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Try to eliminate tables from graph: if we can do it, it means extra tables in
comment|// view are cardinality-preserving joins
name|boolean
name|done
init|=
literal|false
decl_stmt|;
do|do
block|{
name|List
argument_list|<
name|RelTableRef
argument_list|>
name|nodesToRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|graph
operator|.
name|vertexSet
argument_list|()
control|)
block|{
if|if
condition|(
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|graph
operator|.
name|getOutwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// UK-FK join
name|nodesToRemove
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationEquiColumns
operator|!=
literal|null
operator|&&
name|extraTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// We need to add to compensation columns as the table is not present in the query
name|compensationEquiColumns
operator|.
name|putAll
argument_list|(
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equiColumns
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|nodesToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|graph
operator|.
name|removeAllVertices
argument_list|(
name|nodesToRemove
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
comment|// After removing them, we check whether all the remaining tables in the graph
comment|// are tables present in the query: if they are, we can try to rewrite
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|graph
operator|.
name|vertexSet
argument_list|()
argument_list|,
name|extraTableRefs
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * We check whether the predicates in the source are contained in the predicates    * in the target. The method treats separately the equi-column predicates, the    * range predicates, and the rest of predicates.    *    *<p>If the containment is confirmed, we produce compensation predicates that    * need to be added to the target to produce the results in the source. Thus,    * if source and target expressions are equivalent, those predicates will be the    * true constant.    *    *<p>In turn, if containment cannot be confirmed, the method returns null.    */
specifier|protected
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|computeCompensationPredicates
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|EquivalenceClasses
name|sourceEC
parameter_list|,
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|sourcePreds
parameter_list|,
name|EquivalenceClasses
name|targetEC
parameter_list|,
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|targetPreds
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|sourceToTargetTableMapping
parameter_list|)
block|{
specifier|final
name|RexNode
name|compensationColumnsEquiPred
decl_stmt|;
specifier|final
name|RexNode
name|compensationPred
decl_stmt|;
comment|// 1. Establish relationship between source and target equivalence classes.
comment|// If every target equivalence class is not a subset of a source
comment|// equivalence class, we bail out.
name|compensationColumnsEquiPred
operator|=
name|generateEquivalenceClasses
argument_list|(
name|rexBuilder
argument_list|,
name|sourceEC
argument_list|,
name|targetEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationColumnsEquiPred
operator|==
literal|null
condition|)
block|{
comment|// Cannot rewrite
return|return
literal|null
return|;
block|}
comment|// 2. We check that that residual predicates of the source are satisfied within the target.
comment|// Compute compensating predicates.
specifier|final
name|RexNode
name|queryPred
init|=
name|RexUtil
operator|.
name|swapColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|sourcePreds
operator|.
name|right
argument_list|,
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|viewPred
init|=
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|targetPreds
operator|.
name|right
argument_list|,
name|sourceToTargetTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
name|compensationPred
operator|=
name|SubstitutionVisitor
operator|.
name|splitFilter
argument_list|(
name|simplify
argument_list|,
name|queryPred
argument_list|,
name|viewPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationPred
operator|==
literal|null
condition|)
block|{
comment|// Cannot rewrite
return|return
literal|null
return|;
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|compensationColumnsEquiPred
argument_list|,
name|compensationPred
argument_list|)
return|;
block|}
comment|/**    * Given the equi-column predicates of the source and the target and the    * computed equivalence classes, it extracts possible mappings between    * the equivalence classes.    *    *<p>If there is no mapping, it returns null. If there is a exact match,    * it will return a compensation predicate that evaluates to true.    * Finally, if a compensation predicate needs to be enforced on top of    * the target to make the equivalences classes match, it returns that    * compensation predicate.    */
specifier|protected
name|RexNode
name|generateEquivalenceClasses
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|EquivalenceClasses
name|sourceEC
parameter_list|,
name|EquivalenceClasses
name|targetEC
parameter_list|)
block|{
if|if
condition|(
name|sourceEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|targetEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No column equality predicates in query and view
comment|// Empty mapping and compensation predicate
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|sourceEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|targetEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No column equality predicates in source, but column equality predicates in target
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|sourceEquivalenceClasses
init|=
name|sourceEC
operator|.
name|getEquivalenceClasses
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|targetEquivalenceClasses
init|=
name|targetEC
operator|.
name|getEquivalenceClasses
argument_list|()
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapping
init|=
name|extractPossibleMapping
argument_list|(
name|sourceEquivalenceClasses
argument_list|,
name|targetEquivalenceClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapping
operator|==
literal|null
condition|)
block|{
comment|// Did not find mapping between the equivalence classes,
comment|// bail out
return|return
literal|null
return|;
block|}
comment|// Create the compensation predicate
name|RexNode
name|compensationPredicate
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceEquivalenceClasses
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mapping
operator|.
name|containsKey
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|// Add all predicates
name|Iterator
argument_list|<
name|RexTableInputRef
argument_list|>
name|it
init|=
name|sourceEquivalenceClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|RexTableInputRef
name|e0
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|equals
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|e0
argument_list|,
name|it
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|compensationPredicate
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|compensationPredicate
argument_list|,
name|equals
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Add only predicates that are not there
for|for
control|(
name|int
name|j
range|:
name|mapping
operator|.
name|get
argument_list|(
name|i
argument_list|)
control|)
block|{
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|difference
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|sourceEquivalenceClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|difference
operator|.
name|removeAll
argument_list|(
name|targetEquivalenceClasses
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RexTableInputRef
name|e
range|:
name|difference
control|)
block|{
name|RexNode
name|equals
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|e
argument_list|,
name|targetEquivalenceClasses
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|compensationPredicate
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|compensationPredicate
argument_list|,
name|equals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|compensationPredicate
return|;
block|}
comment|/**    * Given the source and target equivalence classes, it extracts the possible mappings    * from each source equivalence class to each target equivalence class.    *    *<p>If any of the source equivalence classes cannot be mapped to a target equivalence    * class, it returns null.    */
specifier|protected
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|extractPossibleMapping
parameter_list|(
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|sourceEquivalenceClasses
parameter_list|,
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|targetEquivalenceClasses
parameter_list|)
block|{
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapping
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetEquivalenceClasses
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|foundQueryEquivalenceClass
init|=
literal|false
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|viewEquivalenceClass
init|=
name|targetEquivalenceClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|sourceEquivalenceClasses
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|queryEquivalenceClass
init|=
name|sourceEquivalenceClasses
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryEquivalenceClass
operator|.
name|containsAll
argument_list|(
name|viewEquivalenceClass
argument_list|)
condition|)
block|{
name|mapping
operator|.
name|put
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|foundQueryEquivalenceClass
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// end for
if|if
condition|(
operator|!
name|foundQueryEquivalenceClass
condition|)
block|{
comment|// Target equivalence class not found in source equivalence class
return|return
literal|null
return|;
block|}
block|}
comment|// end for
return|return
name|mapping
return|;
block|}
comment|/**    * First, the method takes the node expressions {@code nodeExprs} and swaps the table    * and column references using the table mapping and the equivalence classes.    * If {@code swapTableColumn} is true, it swaps the table reference and then the column reference,    * otherwise it swaps the column reference and then the table reference.    *    *<p>Then, the method will rewrite the input expression {@code exprToRewrite}, replacing the    * {@link RexTableInputRef} by references to the positions in {@code nodeExprs}.    *    *<p>The method will return the rewritten expression. If any of the expressions in the input    * expression cannot be mapped, it will return null.    */
specifier|protected
name|RexNode
name|rewriteExpression
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|targetNode
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeExprs
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|ec
parameter_list|,
name|boolean
name|swapTableColumn
parameter_list|,
name|RexNode
name|exprToRewrite
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
name|rewriteExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|targetNode
argument_list|,
name|node
argument_list|,
name|nodeExprs
argument_list|,
name|tableMapping
argument_list|,
name|ec
argument_list|,
name|swapTableColumn
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|exprToRewrite
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenExprs
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|rewrittenExprs
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|rewrittenExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * First, the method takes the node expressions {@code nodeExprs} and swaps the table    * and column references using the table mapping and the equivalence classes.    * If {@code swapTableColumn} is true, it swaps the table reference and then the column reference,    * otherwise it swaps the column reference and then the table reference.    *    *<p>Then, the method will rewrite the input expressions {@code exprsToRewrite}, replacing the    * {@link RexTableInputRef} by references to the positions in {@code nodeExprs}.    *    *<p>The method will return the rewritten expressions. If any of the subexpressions in the input    * expressions cannot be mapped, it will return null.    */
specifier|protected
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewriteExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|targetNode
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeExprs
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|ec
parameter_list|,
name|boolean
name|swapTableColumn
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprsToRewrite
parameter_list|)
block|{
name|NodeLineage
name|nodeLineage
decl_stmt|;
if|if
condition|(
name|swapTableColumn
condition|)
block|{
name|nodeLineage
operator|=
name|generateSwapTableColumnReferencesLineage
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|node
argument_list|,
name|tableMapping
argument_list|,
name|ec
argument_list|,
name|nodeExprs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeLineage
operator|=
name|generateSwapColumnTableReferencesLineage
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|node
argument_list|,
name|tableMapping
argument_list|,
name|ec
argument_list|,
name|nodeExprs
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprsToRewrite
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|exprToRewrite
range|:
name|exprsToRewrite
control|)
block|{
name|RexNode
name|rewrittenExpr
init|=
name|replaceWithOriginalReferences
argument_list|(
name|rexBuilder
argument_list|,
name|targetNode
argument_list|,
name|nodeLineage
argument_list|,
name|exprToRewrite
argument_list|)
decl_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|containsTableInputRef
argument_list|(
name|rewrittenExpr
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// Some expressions were not present in view output
return|return
literal|null
return|;
block|}
name|rewrittenExprs
operator|.
name|add
argument_list|(
name|rewrittenExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|rewrittenExprs
return|;
block|}
comment|/**    * It swaps the table references and then the column references of the input    * expressions using the table mapping and the equivalence classes.    */
specifier|protected
name|NodeLineage
name|generateSwapTableColumnReferencesLineage
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|ec
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeExprs
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineageLosslessCasts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|nodeExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Next expression
continue|continue;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
assert|assert
name|s
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
comment|// Rewrite expr. First we swap the table references following the table
comment|// mapping, then we take first element from the corresponding equivalence class
specifier|final
name|RexNode
name|e
init|=
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|tableMapping
argument_list|,
name|ec
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|exprsLineageLosslessCasts
operator|.
name|put
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|NodeLineage
argument_list|(
name|exprsLineage
argument_list|,
name|exprsLineageLosslessCasts
argument_list|)
return|;
block|}
comment|/**    * It swaps the column references and then the table references of the input    * expressions using the equivalence classes and the table mapping.    */
specifier|protected
name|NodeLineage
name|generateSwapColumnTableReferencesLineage
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|ec
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeExprs
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineageLosslessCasts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|nodeExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Next expression
continue|continue;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
specifier|final
name|RexNode
name|node2
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Rewrite expr. First we take first element from the corresponding equivalence class,
comment|// then we swap the table references following the table mapping
specifier|final
name|RexNode
name|e
init|=
name|RexUtil
operator|.
name|swapColumnTableReferences
argument_list|(
name|rexBuilder
argument_list|,
name|node2
argument_list|,
name|ec
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|,
name|tableMapping
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|exprsLineageLosslessCasts
operator|.
name|put
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|NodeLineage
argument_list|(
name|exprsLineage
argument_list|,
name|exprsLineageLosslessCasts
argument_list|)
return|;
block|}
comment|/**    * Given the input expression, it will replace (sub)expressions when possible    * using the content of the mapping. In particular, the mapping contains the    * digest of the expression and the index that the replacement input ref should    * point to.    */
specifier|protected
name|RexNode
name|replaceWithOriginalReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RelNode
name|node
parameter_list|,
specifier|final
name|NodeLineage
name|nodeLineage
parameter_list|,
specifier|final
name|RexNode
name|exprToRewrite
parameter_list|)
block|{
comment|// Currently we allow the following:
comment|// 1) compensation pred can be directly map to expression
comment|// 2) all references in compensation pred can be map to expressions
comment|// We support bypassing lossless casts.
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|RexNode
name|rw
init|=
name|replace
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|rw
operator|!=
literal|null
condition|?
name|rw
else|:
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|inputRef
parameter_list|)
block|{
name|RexNode
name|rw
init|=
name|replace
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
return|return
name|rw
operator|!=
literal|null
condition|?
name|rw
else|:
name|super
operator|.
name|visitTableInputRef
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|replace
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
name|Integer
name|pos
init|=
name|nodeLineage
operator|.
name|exprsLineage
operator|.
name|get
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|null
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
return|;
block|}
name|pos
operator|=
name|nodeLineage
operator|.
name|exprsLineageLosslessCasts
operator|.
name|get
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|null
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|exprToRewrite
argument_list|)
return|;
block|}
comment|/**    * Replaces all the input references by the position in the    * input column set. If a reference index cannot be found in    * the input set, then we return null.    */
specifier|protected
name|RexNode
name|shuttleReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|node
parameter_list|,
specifier|final
name|Mapping
name|mapping
parameter_list|)
block|{
try|try
block|{
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|int
name|pos
init|=
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|node
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|ex
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Replaces all the possible sub-expressions by input references    * to the input node.    */
specifier|protected
name|RexNode
name|shuttleReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|expr
parameter_list|,
specifier|final
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
parameter_list|)
block|{
return|return
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|exprsLineage
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Replaces all the possible sub-expressions by input references    * to the input node. If available, it uses the rewriting mapping    * to change the position to reference. Takes the reference type    * from the input node.    */
specifier|protected
name|RexNode
name|shuttleReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|expr
parameter_list|,
specifier|final
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
parameter_list|,
specifier|final
name|RelNode
name|node
parameter_list|,
specifier|final
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|rewritingMapping
parameter_list|)
block|{
try|try
block|{
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|ref
parameter_list|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Cannot map expression
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|int
name|pos
init|=
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|rewritingMapping
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|rewritingMapping
operator|.
name|containsKey
argument_list|(
name|pos
argument_list|)
condition|)
block|{
comment|// Cannot map expression
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|pos
operator|=
name|rewritingMapping
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|ref
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Cannot map expression
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|int
name|pos
init|=
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|rewritingMapping
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|rewritingMapping
operator|.
name|containsKey
argument_list|(
name|pos
argument_list|)
condition|)
block|{
comment|// Cannot map expression
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|pos
operator|=
name|rewritingMapping
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
specifier|final
name|RexCall
name|call
parameter_list|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Cannot map expression
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
name|int
name|pos
init|=
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|rewritingMapping
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|rewritingMapping
operator|.
name|containsKey
argument_list|(
name|pos
argument_list|)
condition|)
block|{
comment|// Cannot map expression
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
name|pos
operator|=
name|rewritingMapping
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|expr
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|ex
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Class representing an equivalence class, i.e., a set of equivalent columns    */
specifier|protected
specifier|static
class|class
name|EquivalenceClasses
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|nodeToEquivalenceClass
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|cacheEquivalenceClassesMap
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|cacheEquivalenceClasses
decl_stmt|;
specifier|protected
name|EquivalenceClasses
parameter_list|()
block|{
name|nodeToEquivalenceClass
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|cacheEquivalenceClassesMap
operator|=
name|ImmutableMap
operator|.
name|of
argument_list|()
expr_stmt|;
name|cacheEquivalenceClasses
operator|=
name|ImmutableList
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|addEquivalenceClass
parameter_list|(
name|RexTableInputRef
name|p1
parameter_list|,
name|RexTableInputRef
name|p2
parameter_list|)
block|{
comment|// Clear cache
name|cacheEquivalenceClassesMap
operator|=
literal|null
expr_stmt|;
name|cacheEquivalenceClasses
operator|=
literal|null
expr_stmt|;
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|c1
init|=
name|nodeToEquivalenceClass
operator|.
name|get
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|c2
init|=
name|nodeToEquivalenceClass
operator|.
name|get
argument_list|(
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|null
operator|&&
name|c2
operator|!=
literal|null
condition|)
block|{
comment|// Both present, we need to merge
if|if
condition|(
name|c1
operator|.
name|size
argument_list|()
operator|<
name|c2
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// We swap them to merge
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|c2Temp
init|=
name|c2
decl_stmt|;
name|c2
operator|=
name|c1
expr_stmt|;
name|c1
operator|=
name|c2Temp
expr_stmt|;
block|}
for|for
control|(
name|RexTableInputRef
name|newRef
range|:
name|c2
control|)
block|{
name|c1
operator|.
name|add
argument_list|(
name|newRef
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|newRef
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|c1
operator|!=
literal|null
condition|)
block|{
comment|// p1 present, we need to merge into it
name|c1
operator|.
name|add
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p2
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|c2
operator|!=
literal|null
condition|)
block|{
comment|// p2 present, we need to merge into it
name|c2
operator|.
name|add
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// None are present, add to same equivalence class
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|equivalenceClass
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|equivalenceClass
operator|.
name|add
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|equivalenceClass
operator|.
name|add
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p1
argument_list|,
name|equivalenceClass
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p2
argument_list|,
name|equivalenceClass
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|getEquivalenceClassesMap
parameter_list|()
block|{
if|if
condition|(
name|cacheEquivalenceClassesMap
operator|==
literal|null
condition|)
block|{
name|cacheEquivalenceClassesMap
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|nodeToEquivalenceClass
argument_list|)
expr_stmt|;
block|}
return|return
name|cacheEquivalenceClassesMap
return|;
block|}
specifier|protected
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|getEquivalenceClasses
parameter_list|()
block|{
if|if
condition|(
name|cacheEquivalenceClasses
operator|==
literal|null
condition|)
block|{
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|set
range|:
name|nodeToEquivalenceClass
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|Collections
operator|.
name|disjoint
argument_list|(
name|visited
argument_list|,
name|set
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|visited
operator|.
name|addAll
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
block|}
name|cacheEquivalenceClasses
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
return|return
name|cacheEquivalenceClasses
return|;
block|}
specifier|protected
specifier|static
name|EquivalenceClasses
name|copy
parameter_list|(
name|EquivalenceClasses
name|ec
parameter_list|)
block|{
specifier|final
name|EquivalenceClasses
name|newEc
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|e
range|:
name|ec
operator|.
name|nodeToEquivalenceClass
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newEc
operator|.
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|Sets
operator|.
name|newLinkedHashSet
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newEc
operator|.
name|cacheEquivalenceClassesMap
operator|=
literal|null
expr_stmt|;
name|newEc
operator|.
name|cacheEquivalenceClasses
operator|=
literal|null
expr_stmt|;
return|return
name|newEc
return|;
block|}
block|}
comment|/** Expression lineage details. */
specifier|protected
specifier|static
class|class
name|NodeLineage
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineageLosslessCasts
decl_stmt|;
specifier|private
name|NodeLineage
parameter_list|(
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineageLosslessCasts
parameter_list|)
block|{
name|this
operator|.
name|exprsLineage
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|exprsLineage
argument_list|)
expr_stmt|;
name|this
operator|.
name|exprsLineageLosslessCasts
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|exprsLineageLosslessCasts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Edge for graph */
specifier|protected
specifier|static
class|class
name|Edge
extends|extends
name|DefaultEdge
block|{
specifier|final
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|equiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|Edge
parameter_list|(
name|RelTableRef
name|source
parameter_list|,
name|RelTableRef
name|target
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{"
operator|+
name|source
operator|+
literal|" -> "
operator|+
name|target
operator|+
literal|"}"
return|;
block|}
block|}
comment|/** View partitioning result */
specifier|protected
specifier|static
class|class
name|ViewPartialRewriting
block|{
specifier|private
specifier|final
name|RelNode
name|newView
decl_stmt|;
specifier|private
specifier|final
name|Project
name|newTopViewProject
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|newViewNode
decl_stmt|;
specifier|private
name|ViewPartialRewriting
parameter_list|(
name|RelNode
name|newView
parameter_list|,
name|Project
name|newTopViewProject
parameter_list|,
name|RelNode
name|newViewNode
parameter_list|)
block|{
name|this
operator|.
name|newView
operator|=
name|newView
expr_stmt|;
name|this
operator|.
name|newTopViewProject
operator|=
name|newTopViewProject
expr_stmt|;
name|this
operator|.
name|newViewNode
operator|=
name|newViewNode
expr_stmt|;
block|}
specifier|protected
specifier|static
name|ViewPartialRewriting
name|of
parameter_list|(
name|RelNode
name|newView
parameter_list|,
name|Project
name|newTopViewProject
parameter_list|,
name|RelNode
name|newViewNode
parameter_list|)
block|{
return|return
operator|new
name|ViewPartialRewriting
argument_list|(
name|newView
argument_list|,
name|newTopViewProject
argument_list|,
name|newViewNode
argument_list|)
return|;
block|}
block|}
comment|/** Complete, view partial, or query partial. */
specifier|protected
enum|enum
name|MatchModality
block|{
name|COMPLETE
block|,
name|VIEW_PARTIAL
block|,
name|QUERY_PARTIAL
block|}
block|}
end_class

end_unit

