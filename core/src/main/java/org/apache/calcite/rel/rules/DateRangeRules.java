begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|DateTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnitRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|SqlFunctions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampWithTimeZoneString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BoundType
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableRangeSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSortedSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Range
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|RangeSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|TreeRangeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|immutables
operator|.
name|value
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Collection of planner rules that convert  * {@code EXTRACT(timeUnit FROM dateTime) = constant},  * {@code FLOOR(dateTime to timeUnit} = constant} and  * {@code CEIL(dateTime to timeUnit} = constant} to  * {@code dateTime BETWEEN lower AND upper}.  *  *<p>The rules allow conversion of queries on time dimension tables, such as  *  *<blockquote>SELECT ... FROM sales JOIN time_by_day USING (time_id)  * WHERE time_by_day.the_year = 1997  * AND time_by_day.the_month IN (4, 5, 6)</blockquote>  *  *<p>into  *  *<blockquote>SELECT ... FROM sales JOIN time_by_day USING (time_id)  * WHERE the_date BETWEEN DATE '2016-04-01' AND DATE '2016-06-30'</blockquote>  *  *<p>and is especially useful for Druid, which has a single timestamp column.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|DateRangeRules
block|{
specifier|private
name|DateRangeRules
parameter_list|()
block|{
block|}
comment|/** Rule that matches a {@link Filter} and converts calls to {@code EXTRACT},    * {@code FLOOR} and {@code CEIL} functions to date ranges (typically using    * the {@code BETWEEN} operator). */
specifier|public
specifier|static
specifier|final
name|RelOptRule
name|FILTER_INSTANCE
init|=
name|FilterDateRangeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|as
argument_list|(
name|FilterDateRangeRule
operator|.
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|TimeUnitRange
argument_list|,
name|Integer
argument_list|>
name|TIME_UNIT_CODES
init|=
name|ImmutableMap
operator|.
expr|<
name|TimeUnitRange
decl_stmt|,
name|Integer
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|,
name|Calendar
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|,
name|Calendar
operator|.
name|MONTH
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|DAY
argument_list|,
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|HOUR
argument_list|,
name|Calendar
operator|.
name|HOUR
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|MINUTE
argument_list|,
name|Calendar
operator|.
name|MINUTE
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|SECOND
argument_list|,
name|Calendar
operator|.
name|SECOND
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|MILLISECOND
argument_list|,
name|Calendar
operator|.
name|MILLISECOND
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|TimeUnitRange
argument_list|,
name|TimeUnitRange
argument_list|>
name|TIME_UNIT_PARENTS
init|=
name|ImmutableMap
operator|.
expr|<
name|TimeUnitRange
decl_stmt|,
name|TimeUnitRange
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|,
name|TimeUnitRange
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|DAY
argument_list|,
name|TimeUnitRange
operator|.
name|MONTH
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|HOUR
argument_list|,
name|TimeUnitRange
operator|.
name|DAY
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|MINUTE
argument_list|,
name|TimeUnitRange
operator|.
name|HOUR
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|SECOND
argument_list|,
name|TimeUnitRange
operator|.
name|MINUTE
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|MILLISECOND
argument_list|,
name|TimeUnitRange
operator|.
name|SECOND
argument_list|)
decl|.
name|put
argument_list|(
name|TimeUnitRange
operator|.
name|MICROSECOND
argument_list|,
name|TimeUnitRange
operator|.
name|SECOND
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|int
name|calendarUnitFor
parameter_list|(
name|TimeUnitRange
name|timeUnitRange
parameter_list|)
block|{
return|return
name|requireNonNull
argument_list|(
name|TIME_UNIT_CODES
operator|.
name|get
argument_list|(
name|timeUnitRange
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"unexpected timeUnitRange: "
operator|+
name|timeUnitRange
operator|+
literal|", the following are supported: "
operator|+
name|TIME_UNIT_CODES
argument_list|)
return|;
block|}
comment|/** Tests whether an expression contains one or more calls to the    * {@code EXTRACT} function, and if so, returns the time units used.    *    *<p>The result is an immutable set in natural order. This is important,    * because code relies on the collection being sorted (so YEAR comes before    * MONTH before HOUR) and unique. A predicate on MONTH is not useful if there    * is no predicate on YEAR. Then when we apply the predicate on DAY it doesn't    * generate hundreds of ranges we'll later throw away. */
specifier|static
name|ImmutableSortedSet
argument_list|<
name|TimeUnitRange
argument_list|>
name|extractTimeUnits
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
try|try
init|(
name|ExtractFinder
name|finder
init|=
name|ExtractFinder
operator|.
name|THREAD_INSTANCES
operator|.
name|get
argument_list|()
init|)
block|{
assert|assert
name|requireNonNull
argument_list|(
name|finder
argument_list|,
literal|"finder"
argument_list|)
operator|.
name|timeUnits
operator|.
name|isEmpty
argument_list|()
operator|&&
name|finder
operator|.
name|opKinds
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"previous user did not clean up"
assert|;
name|e
operator|.
name|accept
argument_list|(
name|finder
argument_list|)
expr_stmt|;
return|return
name|ImmutableSortedSet
operator|.
name|copyOf
argument_list|(
name|finder
operator|.
name|timeUnits
argument_list|)
return|;
block|}
block|}
comment|/** Replaces calls to EXTRACT, FLOOR and CEIL in an expression. */
annotation|@
name|VisibleForTesting
annotation|@
name|SuppressWarnings
argument_list|(
literal|"BetaApi"
argument_list|)
specifier|public
specifier|static
name|RexNode
name|replaceTimeUnits
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|e
parameter_list|,
name|String
name|timeZone
parameter_list|)
block|{
name|ImmutableSortedSet
argument_list|<
name|TimeUnitRange
argument_list|>
name|timeUnits
init|=
name|extractTimeUnits
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|timeUnits
operator|.
name|contains
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|)
condition|)
block|{
comment|// Case when we have FLOOR or CEIL but no extract on YEAR.
comment|// Add YEAR as TimeUnit so that FLOOR gets replaced in first iteration
comment|// with timeUnit YEAR.
name|timeUnits
operator|=
name|ImmutableSortedSet
operator|.
expr|<
name|TimeUnitRange
operator|>
name|naturalOrder
argument_list|()
operator|.
name|addAll
argument_list|(
name|timeUnits
argument_list|)
operator|.
name|add
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
argument_list|>
name|operandRanges
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TimeUnitRange
name|timeUnit
range|:
name|timeUnits
control|)
block|{
name|e
operator|=
name|e
operator|.
name|accept
argument_list|(
operator|new
name|ExtractShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|timeUnit
argument_list|,
name|operandRanges
argument_list|,
name|timeUnits
argument_list|,
name|timeZone
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
comment|/** Rule that converts EXTRACT, FLOOR and CEIL in a {@link Filter} into a date    * range.    *    * @see DateRangeRules#FILTER_INSTANCE */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"WeakerAccess"
argument_list|)
specifier|public
specifier|static
class|class
name|FilterDateRangeRule
extends|extends
name|RelRule
argument_list|<
name|FilterDateRangeRule
operator|.
name|Config
argument_list|>
implements|implements
name|TransformationRule
block|{
comment|/** Creates a FilterDateRangeRule. */
specifier|protected
name|FilterDateRangeRule
parameter_list|(
name|Config
name|config
parameter_list|)
block|{
name|super
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|FilterDateRangeRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|this
argument_list|(
name|Config
operator|.
name|DEFAULT
operator|.
name|withRelBuilderFactory
argument_list|(
name|relBuilderFactory
argument_list|)
operator|.
name|as
argument_list|(
name|Config
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Whether this an EXTRACT of YEAR, or a call to FLOOR or CEIL.      * If none of these, we cannot apply the rule. */
specifier|private
specifier|static
name|boolean
name|containsRoundingExpression
parameter_list|(
name|Filter
name|filter
parameter_list|)
block|{
try|try
init|(
name|ExtractFinder
name|finder
init|=
name|ExtractFinder
operator|.
name|THREAD_INSTANCES
operator|.
name|get
argument_list|()
init|)
block|{
assert|assert
name|requireNonNull
argument_list|(
name|finder
argument_list|,
literal|"finder"
argument_list|)
operator|.
name|timeUnits
operator|.
name|isEmpty
argument_list|()
operator|&&
name|finder
operator|.
name|opKinds
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"previous user did not clean up"
assert|;
name|filter
operator|.
name|getCondition
argument_list|()
operator|.
name|accept
argument_list|(
name|finder
argument_list|)
expr_stmt|;
return|return
name|finder
operator|.
name|timeUnits
operator|.
name|contains
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|)
operator|||
name|finder
operator|.
name|opKinds
operator|.
name|contains
argument_list|(
name|SqlKind
operator|.
name|FLOOR
argument_list|)
operator|||
name|finder
operator|.
name|opKinds
operator|.
name|contains
argument_list|(
name|SqlKind
operator|.
name|CEIL
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|filter
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|String
name|timeZone
init|=
name|filter
operator|.
name|getCluster
argument_list|()
operator|.
name|getPlanner
argument_list|()
operator|.
name|getContext
argument_list|()
operator|.
name|unwrapOrThrow
argument_list|(
name|CalciteConnectionConfig
operator|.
name|class
argument_list|)
operator|.
name|timeZone
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|condition
init|=
name|replaceTimeUnits
argument_list|(
name|rexBuilder
argument_list|,
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|,
name|timeZone
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|.
name|equals
argument_list|(
name|filter
operator|.
name|getCondition
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|RelBuilder
name|relBuilder
init|=
name|relBuilderFactory
operator|.
name|create
argument_list|(
name|filter
operator|.
name|getCluster
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|filter
operator|.
name|getInput
argument_list|()
argument_list|)
operator|.
name|filter
argument_list|(
name|condition
argument_list|)
expr_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Rule configuration. */
annotation|@
name|Value
operator|.
name|Immutable
argument_list|(
name|singleton
operator|=
literal|true
argument_list|)
annotation|@
name|Value
operator|.
name|Style
argument_list|(
name|typeImmutable
operator|=
literal|"ImmutableFilterDateRangeRuleConfig"
argument_list|)
specifier|public
interface|interface
name|Config
extends|extends
name|RelRule
operator|.
name|Config
block|{
name|Config
name|DEFAULT
init|=
name|ImmutableFilterDateRangeRuleConfig
operator|.
name|of
argument_list|()
operator|.
name|withOperandSupplier
argument_list|(
name|b
lambda|->
name|b
operator|.
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|)
operator|.
name|predicate
argument_list|(
name|FilterDateRangeRule
operator|::
name|containsRoundingExpression
argument_list|)
operator|.
name|anyInputs
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|default
name|FilterDateRangeRule
name|toRule
parameter_list|()
block|{
return|return
operator|new
name|FilterDateRangeRule
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Visitor that searches for calls to {@code EXTRACT}, {@code FLOOR} or    * {@code CEIL}, building a list of distinct time units. */
specifier|private
specifier|static
class|class
name|ExtractFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
implements|implements
name|AutoCloseable
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|TimeUnitRange
argument_list|>
name|timeUnits
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|TimeUnitRange
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|SqlKind
argument_list|>
name|opKinds
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|SqlKind
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
annotation|@
name|Nullable
name|ExtractFinder
argument_list|>
name|THREAD_INSTANCES
init|=
name|ThreadLocal
operator|.
name|withInitial
argument_list|(
name|ExtractFinder
operator|::
operator|new
argument_list|)
decl_stmt|;
specifier|private
name|ExtractFinder
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EXTRACT
case|:
specifier|final
name|RexLiteral
name|operand
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|timeUnits
operator|.
name|add
argument_list|(
operator|(
name|TimeUnitRange
operator|)
name|requireNonNull
argument_list|(
name|operand
operator|.
name|getValue
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"timeUnitRange is null for "
operator|+
name|call
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOOR
case|:
case|case
name|CEIL
case|:
comment|// Check that the call to FLOOR/CEIL is on date-time
if|if
condition|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|opKinds
operator|.
name|add
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|timeUnits
operator|.
name|clear
argument_list|()
expr_stmt|;
name|opKinds
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Walks over an expression, replacing calls to    * {@code EXTRACT}, {@code FLOOR} and {@code CEIL} with date ranges. */
annotation|@
name|VisibleForTesting
annotation|@
name|SuppressWarnings
argument_list|(
literal|"BetaApi"
argument_list|)
specifier|static
class|class
name|ExtractShuttle
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
specifier|final
name|TimeUnitRange
name|timeUnit
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
argument_list|>
name|operandRanges
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|RexCall
argument_list|>
name|calls
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSortedSet
argument_list|<
name|TimeUnitRange
argument_list|>
name|timeUnitRanges
decl_stmt|;
specifier|private
specifier|final
name|String
name|timeZone
decl_stmt|;
annotation|@
name|VisibleForTesting
name|ExtractShuttle
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
argument_list|>
name|operandRanges
parameter_list|,
name|ImmutableSortedSet
argument_list|<
name|TimeUnitRange
argument_list|>
name|timeUnitRanges
parameter_list|,
name|String
name|timeZone
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|requireNonNull
argument_list|(
name|rexBuilder
argument_list|,
literal|"rexBuilder"
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeUnit
operator|=
name|requireNonNull
argument_list|(
name|timeUnit
argument_list|,
literal|"timeUnit"
argument_list|)
expr_stmt|;
name|this
operator|.
name|operandRanges
operator|=
name|requireNonNull
argument_list|(
name|operandRanges
argument_list|,
literal|"operandRanges"
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeUnitRanges
operator|=
name|requireNonNull
argument_list|(
name|timeUnitRanges
argument_list|,
literal|"timeUnitRanges"
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeZone
operator|=
name|timeZone
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|LESS_THAN
case|:
specifier|final
name|RexNode
name|op0
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op1
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op0
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
assert|assert
name|op0
operator|instanceof
name|RexLiteral
assert|;
if|if
condition|(
name|isExtractCall
argument_list|(
name|op1
argument_list|)
condition|)
block|{
assert|assert
name|op1
operator|instanceof
name|RexCall
assert|;
specifier|final
name|RexCall
name|subCall
init|=
operator|(
name|RexCall
operator|)
name|op1
decl_stmt|;
name|RexNode
name|operand
init|=
name|subCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|canRewriteExtract
argument_list|(
name|operand
argument_list|)
condition|)
block|{
return|return
name|compareExtract
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|,
name|operand
argument_list|,
operator|(
name|RexLiteral
operator|)
name|op0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|isFloorCeilCall
argument_list|(
name|op1
argument_list|)
condition|)
block|{
assert|assert
name|op1
operator|instanceof
name|RexCall
assert|;
specifier|final
name|RexCall
name|subCall
init|=
operator|(
name|RexCall
operator|)
name|op1
decl_stmt|;
specifier|final
name|RexLiteral
name|flag
init|=
operator|(
name|RexLiteral
operator|)
name|subCall
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|TimeUnitRange
name|timeUnit
init|=
operator|(
name|TimeUnitRange
operator|)
name|requireNonNull
argument_list|(
name|flag
operator|.
name|getValue
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"timeUnit is null for "
operator|+
name|subCall
argument_list|)
decl_stmt|;
return|return
name|compareFloorCeil
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|,
name|subCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexLiteral
operator|)
name|op0
argument_list|,
name|timeUnit
argument_list|,
name|op1
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FLOOR
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|op1
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LITERAL
case|:
assert|assert
name|op1
operator|instanceof
name|RexLiteral
assert|;
if|if
condition|(
name|isExtractCall
argument_list|(
name|op0
argument_list|)
condition|)
block|{
assert|assert
name|op0
operator|instanceof
name|RexCall
assert|;
specifier|final
name|RexCall
name|subCall
init|=
operator|(
name|RexCall
operator|)
name|op0
decl_stmt|;
name|RexNode
name|operand
init|=
name|subCall
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|canRewriteExtract
argument_list|(
name|operand
argument_list|)
condition|)
block|{
return|return
name|compareExtract
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
argument_list|,
name|subCall
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|(
name|RexLiteral
operator|)
name|op1
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|isFloorCeilCall
argument_list|(
name|op0
argument_list|)
condition|)
block|{
specifier|final
name|RexCall
name|subCall
init|=
operator|(
name|RexCall
operator|)
name|op0
decl_stmt|;
specifier|final
name|RexLiteral
name|flag
init|=
operator|(
name|RexLiteral
operator|)
name|subCall
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|TimeUnitRange
name|timeUnit
init|=
operator|(
name|TimeUnitRange
operator|)
name|requireNonNull
argument_list|(
name|flag
operator|.
name|getValue
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"timeUnit is null for "
operator|+
name|subCall
argument_list|)
decl_stmt|;
return|return
name|compareFloorCeil
argument_list|(
name|call
operator|.
name|getKind
argument_list|()
argument_list|,
name|subCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexLiteral
operator|)
name|op1
argument_list|,
name|timeUnit
argument_list|,
name|op0
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FLOOR
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// fall through
default|default:
name|calls
operator|.
name|push
argument_list|(
name|call
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
finally|finally
block|{
name|calls
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|canRewriteExtract
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
comment|// We rely on timeUnits being sorted (so YEAR comes before MONTH
comment|// before HOUR) and unique. If we have seen a predicate on YEAR,
comment|// operandRanges will not be empty. This checks whether we can rewrite
comment|// the "extract" condition. For example, in the condition
comment|//
comment|//   extract(MONTH from time) = someValue
comment|//   OR extract(YEAR from time) = someValue
comment|//
comment|// we cannot rewrite extract on MONTH.
if|if
condition|(
name|timeUnit
operator|==
name|TimeUnitRange
operator|.
name|YEAR
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|final
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
name|calendarRangeSet
init|=
name|operandRanges
operator|.
name|get
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|calendarRangeSet
operator|==
literal|null
operator|||
name|calendarRangeSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Range
argument_list|<
name|Calendar
argument_list|>
name|range
range|:
name|calendarRangeSet
operator|.
name|asRanges
argument_list|()
control|)
block|{
comment|// Cannot reWrite if range does not have an upper or lower bound
if|if
condition|(
operator|!
name|range
operator|.
name|hasUpperBound
argument_list|()
operator|||
operator|!
name|range
operator|.
name|hasLowerBound
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|List
argument_list|<
name|RexNode
argument_list|>
name|visitList
argument_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
argument_list|,
name|boolean
expr|@
name|Nullable
index|[]
name|update
argument_list|)
block|{
if|if
condition|(
name|exprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
comment|// a bit more efficient
block|}
switch|switch
condition|(
name|calls
operator|.
name|getFirst
argument_list|()
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
return|return
name|super
operator|.
name|visitList
argument_list|(
name|exprs
argument_list|,
name|update
argument_list|)
return|;
default|default:
if|if
condition|(
name|timeUnit
operator|!=
name|TimeUnitRange
operator|.
name|YEAR
condition|)
block|{
comment|// Already visited for lower TimeUnit ranges in the loop below.
comment|// Early bail out.
comment|//noinspection unchecked
return|return
operator|(
name|List
argument_list|<
name|RexNode
argument_list|>
operator|)
name|exprs
return|;
block|}
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
argument_list|>
name|save
init|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|operandRanges
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|clonedOperands
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|exprs
control|)
block|{
name|RexNode
name|clonedOperand
init|=
name|operand
decl_stmt|;
for|for
control|(
name|TimeUnitRange
name|timeUnit
range|:
name|timeUnitRanges
control|)
block|{
name|clonedOperand
operator|=
name|clonedOperand
operator|.
name|accept
argument_list|(
operator|new
name|ExtractShuttle
argument_list|(
name|rexBuilder
argument_list|,
name|timeUnit
argument_list|,
name|operandRanges
argument_list|,
name|timeUnitRanges
argument_list|,
name|timeZone
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|clonedOperand
operator|!=
name|operand
operator|)
operator|&&
operator|(
name|update
operator|!=
literal|null
operator|)
condition|)
block|{
name|update
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
block|}
name|clonedOperands
operator|.
name|add
argument_list|(
name|clonedOperand
argument_list|)
expr_stmt|;
comment|// Restore the state. For an operator such as "OR", an argument
comment|// cannot inherit the previous argument's state.
name|operandRanges
operator|.
name|clear
argument_list|()
expr_stmt|;
name|operandRanges
operator|.
name|putAll
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
return|return
name|clonedOperands
operator|.
name|build
argument_list|()
return|;
block|}
block|}
name|boolean
name|isExtractCall
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EXTRACT
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
specifier|final
name|RexLiteral
name|flag
init|=
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|TimeUnitRange
name|timeUnit
init|=
operator|(
name|TimeUnitRange
operator|)
name|flag
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|timeUnit
operator|==
name|this
operator|.
name|timeUnit
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
name|RexNode
name|compareExtract
parameter_list|(
name|SqlKind
name|comparison
parameter_list|,
name|RexNode
name|operand
parameter_list|,
name|RexLiteral
name|literal
parameter_list|)
block|{
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
name|rangeSet
init|=
name|operandRanges
operator|.
name|get
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangeSet
operator|==
literal|null
condition|)
block|{
name|rangeSet
operator|=
name|ImmutableRangeSet
operator|.
expr|<
name|Calendar
operator|>
name|of
argument_list|()
operator|.
name|complement
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
name|s2
init|=
name|TreeRangeSet
operator|.
name|create
argument_list|()
decl_stmt|;
comment|// Calendar.MONTH is 0-based
specifier|final
name|int
name|v
init|=
name|RexLiteral
operator|.
name|intValue
argument_list|(
name|literal
argument_list|)
operator|-
operator|(
name|timeUnit
operator|==
name|TimeUnitRange
operator|.
name|MONTH
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|v
argument_list|,
name|timeUnit
argument_list|)
condition|)
block|{
comment|// Comparison with an invalid value for timeUnit, always false.
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
for|for
control|(
name|Range
argument_list|<
name|Calendar
argument_list|>
name|r
range|:
name|rangeSet
operator|.
name|asRanges
argument_list|()
control|)
block|{
specifier|final
name|Calendar
name|c
decl_stmt|;
switch|switch
condition|(
name|timeUnit
condition|)
block|{
case|case
name|YEAR
case|:
name|c
operator|=
name|Util
operator|.
name|calendar
argument_list|()
expr_stmt|;
name|c
operator|.
name|clear
argument_list|()
expr_stmt|;
name|c
operator|.
name|set
argument_list|(
name|v
argument_list|,
name|Calendar
operator|.
name|JANUARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s2
operator|.
name|add
argument_list|(
name|extractRange
argument_list|(
name|timeUnit
argument_list|,
name|comparison
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONTH
case|:
case|case
name|DAY
case|:
case|case
name|HOUR
case|:
case|case
name|MINUTE
case|:
case|case
name|SECOND
case|:
if|if
condition|(
name|r
operator|.
name|hasLowerBound
argument_list|()
operator|&&
name|r
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
name|c
operator|=
operator|(
name|Calendar
operator|)
name|r
operator|.
name|lowerEndpoint
argument_list|()
operator|.
name|clone
argument_list|()
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|next
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|,
name|v
argument_list|,
name|r
argument_list|,
name|i
operator|++
operator|>
literal|0
argument_list|)
condition|)
block|{
name|s2
operator|.
name|add
argument_list|(
name|extractRange
argument_list|(
name|timeUnit
argument_list|,
name|comparison
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|// Intersect old range set with new.
name|s2
operator|.
name|removeAll
argument_list|(
name|rangeSet
operator|.
name|complement
argument_list|()
argument_list|)
expr_stmt|;
name|operandRanges
operator|.
name|put
argument_list|(
name|operand
argument_list|,
name|ImmutableRangeSet
operator|.
name|copyOf
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Range
argument_list|<
name|Calendar
argument_list|>
name|r
range|:
name|s2
operator|.
name|asRanges
argument_list|()
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|toRex
argument_list|(
name|operand
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|)
return|;
block|}
comment|// Assumes v is a valid value for given timeunit
specifier|private
specifier|static
name|boolean
name|next
parameter_list|(
name|Calendar
name|c
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|,
name|int
name|v
parameter_list|,
name|Range
argument_list|<
name|Calendar
argument_list|>
name|r
parameter_list|,
name|boolean
name|strict
parameter_list|)
block|{
specifier|final
name|Calendar
name|original
init|=
operator|(
name|Calendar
operator|)
name|c
operator|.
name|clone
argument_list|()
decl_stmt|;
specifier|final
name|int
name|code
init|=
name|calendarUnitFor
argument_list|(
name|timeUnit
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|.
name|set
argument_list|(
name|code
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|int
name|v2
init|=
name|c
operator|.
name|get
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|v2
operator|<
name|v
condition|)
block|{
comment|// E.g. when we set DAY=30 on 2014-02-01, we get 2014-02-30 because
comment|// February has 28 days.
continue|continue;
block|}
if|if
condition|(
name|strict
operator|&&
name|original
operator|.
name|compareTo
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|.
name|add
argument_list|(
name|calendarUnitFor
argument_list|(
name|requireNonNull
argument_list|(
name|TIME_UNIT_PARENTS
operator|.
name|get
argument_list|(
name|timeUnit
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"TIME_UNIT_PARENTS.get(timeUnit) is null for "
operator|+
name|timeUnit
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|r
operator|.
name|contains
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isValid
parameter_list|(
name|int
name|v
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|)
block|{
switch|switch
condition|(
name|timeUnit
condition|)
block|{
case|case
name|YEAR
case|:
return|return
name|v
operator|>
literal|0
return|;
case|case
name|MONTH
case|:
return|return
name|v
operator|>=
name|Calendar
operator|.
name|JANUARY
operator|&&
name|v
operator|<=
name|Calendar
operator|.
name|DECEMBER
return|;
case|case
name|DAY
case|:
return|return
name|v
operator|>
literal|0
operator|&&
name|v
operator|<=
literal|31
return|;
case|case
name|HOUR
case|:
return|return
name|v
operator|>=
literal|0
operator|&&
name|v
operator|<=
literal|24
return|;
case|case
name|MINUTE
case|:
case|case
name|SECOND
case|:
return|return
name|v
operator|>=
literal|0
operator|&&
name|v
operator|<=
literal|60
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
specifier|private
name|RexNode
name|toRex
parameter_list|(
name|RexNode
name|operand
parameter_list|,
name|Range
argument_list|<
name|Calendar
argument_list|>
name|r
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|hasLowerBound
argument_list|()
condition|)
block|{
specifier|final
name|SqlBinaryOperator
name|op
init|=
name|r
operator|.
name|lowerBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
condition|?
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
else|:
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|operand
argument_list|,
name|dateTimeLiteral
argument_list|(
name|rexBuilder
argument_list|,
name|r
operator|.
name|lowerEndpoint
argument_list|()
argument_list|,
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|hasUpperBound
argument_list|()
condition|)
block|{
specifier|final
name|SqlBinaryOperator
name|op
init|=
name|r
operator|.
name|upperBoundType
argument_list|()
operator|==
name|BoundType
operator|.
name|CLOSED
condition|?
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
else|:
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op
argument_list|,
name|operand
argument_list|,
name|dateTimeLiteral
argument_list|(
name|rexBuilder
argument_list|,
name|r
operator|.
name|upperEndpoint
argument_list|()
argument_list|,
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|nodes
argument_list|)
return|;
block|}
specifier|private
name|RexLiteral
name|dateTimeLiteral
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|Calendar
name|calendar
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
specifier|final
name|TimestampString
name|ts
decl_stmt|;
specifier|final
name|int
name|p
decl_stmt|;
switch|switch
condition|(
name|operand
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|TIMESTAMP
case|:
name|ts
operator|=
name|TimestampString
operator|.
name|fromCalendarFields
argument_list|(
name|calendar
argument_list|)
expr_stmt|;
name|p
operator|=
name|operand
operator|.
name|getType
argument_list|()
operator|.
name|getPrecision
argument_list|()
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeTimestampLiteral
argument_list|(
name|ts
argument_list|,
name|p
argument_list|)
return|;
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
name|ts
operator|=
name|TimestampString
operator|.
name|fromCalendarFields
argument_list|(
name|calendar
argument_list|)
expr_stmt|;
specifier|final
name|TimeZone
name|tz
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|this
operator|.
name|timeZone
argument_list|)
decl_stmt|;
specifier|final
name|TimestampString
name|localTs
init|=
operator|new
name|TimestampWithTimeZoneString
argument_list|(
name|ts
argument_list|,
name|tz
argument_list|)
operator|.
name|withTimeZone
argument_list|(
name|DateTimeUtils
operator|.
name|UTC_ZONE
argument_list|)
operator|.
name|getLocalTimestampString
argument_list|()
decl_stmt|;
name|p
operator|=
name|operand
operator|.
name|getType
argument_list|()
operator|.
name|getPrecision
argument_list|()
expr_stmt|;
return|return
name|rexBuilder
operator|.
name|makeTimestampWithLocalTimeZoneLiteral
argument_list|(
name|localTs
argument_list|,
name|p
argument_list|)
return|;
case|case
name|DATE
case|:
specifier|final
name|DateString
name|d
init|=
name|DateString
operator|.
name|fromCalendarFields
argument_list|(
name|calendar
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeDateLiteral
argument_list|(
name|d
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|operand
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|Range
argument_list|<
name|Calendar
argument_list|>
name|extractRange
parameter_list|(
name|TimeUnitRange
name|timeUnit
parameter_list|,
name|SqlKind
name|comparison
parameter_list|,
name|Calendar
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|Range
operator|.
name|closedOpen
argument_list|(
name|round
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|,
literal|true
argument_list|)
argument_list|,
name|round
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
case|case
name|LESS_THAN
case|:
return|return
name|Range
operator|.
name|lessThan
argument_list|(
name|round
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|Range
operator|.
name|lessThan
argument_list|(
name|round
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|Range
operator|.
name|atLeast
argument_list|(
name|round
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|Range
operator|.
name|atLeast
argument_list|(
name|round
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|,
literal|true
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|comparison
argument_list|)
throw|;
block|}
block|}
comment|/** Returns a copy of a calendar, optionally rounded up to the next time      * unit. */
specifier|private
specifier|static
name|Calendar
name|round
parameter_list|(
name|Calendar
name|c
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|,
name|boolean
name|down
parameter_list|)
block|{
name|c
operator|=
operator|(
name|Calendar
operator|)
name|c
operator|.
name|clone
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|down
condition|)
block|{
specifier|final
name|Integer
name|code
init|=
name|calendarUnitFor
argument_list|(
name|timeUnit
argument_list|)
decl_stmt|;
specifier|final
name|int
name|v
init|=
name|c
operator|.
name|get
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|c
operator|.
name|set
argument_list|(
name|code
argument_list|,
name|v
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
specifier|private
name|RexNode
name|compareFloorCeil
parameter_list|(
name|SqlKind
name|comparison
parameter_list|,
name|RexNode
name|operand
parameter_list|,
name|RexLiteral
name|timeLiteral
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|,
name|boolean
name|floor
parameter_list|)
block|{
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
name|rangeSet
init|=
name|operandRanges
operator|.
name|get
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangeSet
operator|==
literal|null
condition|)
block|{
name|rangeSet
operator|=
name|ImmutableRangeSet
operator|.
expr|<
name|Calendar
operator|>
name|of
argument_list|()
operator|.
name|complement
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RangeSet
argument_list|<
name|Calendar
argument_list|>
name|s2
init|=
name|TreeRangeSet
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|Calendar
name|c
init|=
name|timestampValue
argument_list|(
name|timeLiteral
argument_list|)
decl_stmt|;
specifier|final
name|Range
argument_list|<
name|Calendar
argument_list|>
name|range
init|=
name|floor
condition|?
name|floorRange
argument_list|(
name|timeUnit
argument_list|,
name|comparison
argument_list|,
name|c
argument_list|)
else|:
name|ceilRange
argument_list|(
name|timeUnit
argument_list|,
name|comparison
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|s2
operator|.
name|add
argument_list|(
name|range
argument_list|)
expr_stmt|;
comment|// Intersect old range set with new.
name|s2
operator|.
name|removeAll
argument_list|(
name|rangeSet
operator|.
name|complement
argument_list|()
argument_list|)
expr_stmt|;
name|operandRanges
operator|.
name|put
argument_list|(
name|operand
argument_list|,
name|ImmutableRangeSet
operator|.
name|copyOf
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|false
argument_list|)
return|;
block|}
return|return
name|toRex
argument_list|(
name|operand
argument_list|,
name|range
argument_list|)
return|;
block|}
specifier|private
name|Calendar
name|timestampValue
parameter_list|(
name|RexLiteral
name|timeLiteral
parameter_list|)
block|{
switch|switch
condition|(
name|timeLiteral
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
specifier|final
name|TimeZone
name|tz
init|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|this
operator|.
name|timeZone
argument_list|)
decl_stmt|;
return|return
name|Util
operator|.
name|calendar
argument_list|(
name|SqlFunctions
operator|.
name|timestampWithLocalTimeZoneToTimestamp
argument_list|(
name|requireNonNull
argument_list|(
name|timeLiteral
operator|.
name|getValueAs
argument_list|(
name|Long
operator|.
name|class
argument_list|)
argument_list|,
literal|"timeLiteral.getValueAs(Long.class)"
argument_list|)
argument_list|,
name|tz
argument_list|)
argument_list|)
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|Util
operator|.
name|calendar
argument_list|(
name|requireNonNull
argument_list|(
name|timeLiteral
operator|.
name|getValueAs
argument_list|(
name|Long
operator|.
name|class
argument_list|)
argument_list|,
literal|"timeLiteral.getValueAs(Long.class)"
argument_list|)
argument_list|)
return|;
case|case
name|DATE
case|:
comment|// Cast date to timestamp with local time zone
specifier|final
name|DateString
name|d
init|=
name|requireNonNull
argument_list|(
name|timeLiteral
operator|.
name|getValueAs
argument_list|(
name|DateString
operator|.
name|class
argument_list|)
argument_list|,
literal|"timeLiteral.getValueAs(DateString.class)"
argument_list|)
decl_stmt|;
return|return
name|Util
operator|.
name|calendar
argument_list|(
name|d
operator|.
name|getMillisSinceEpoch
argument_list|()
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|timeLiteral
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|Range
argument_list|<
name|Calendar
argument_list|>
name|floorRange
parameter_list|(
name|TimeUnitRange
name|timeUnit
parameter_list|,
name|SqlKind
name|comparison
parameter_list|,
name|Calendar
name|c
parameter_list|)
block|{
name|Calendar
name|floor
init|=
name|floor
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|)
decl_stmt|;
name|boolean
name|boundary
init|=
name|floor
operator|.
name|equals
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|Range
operator|.
name|closedOpen
argument_list|(
name|floor
argument_list|,
name|boundary
condition|?
name|increment
argument_list|(
name|floor
argument_list|,
name|timeUnit
argument_list|)
else|:
name|floor
argument_list|)
return|;
case|case
name|LESS_THAN
case|:
return|return
name|boundary
condition|?
name|Range
operator|.
name|lessThan
argument_list|(
name|floor
argument_list|)
else|:
name|Range
operator|.
name|lessThan
argument_list|(
name|increment
argument_list|(
name|floor
argument_list|,
name|timeUnit
argument_list|)
argument_list|)
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|Range
operator|.
name|lessThan
argument_list|(
name|increment
argument_list|(
name|floor
argument_list|,
name|timeUnit
argument_list|)
argument_list|)
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|Range
operator|.
name|atLeast
argument_list|(
name|increment
argument_list|(
name|floor
argument_list|,
name|timeUnit
argument_list|)
argument_list|)
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|boundary
condition|?
name|Range
operator|.
name|atLeast
argument_list|(
name|floor
argument_list|)
else|:
name|Range
operator|.
name|atLeast
argument_list|(
name|increment
argument_list|(
name|floor
argument_list|,
name|timeUnit
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|comparison
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|Range
argument_list|<
name|Calendar
argument_list|>
name|ceilRange
parameter_list|(
name|TimeUnitRange
name|timeUnit
parameter_list|,
name|SqlKind
name|comparison
parameter_list|,
name|Calendar
name|c
parameter_list|)
block|{
specifier|final
name|Calendar
name|ceil
init|=
name|ceil
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|)
decl_stmt|;
name|boolean
name|boundary
init|=
name|ceil
operator|.
name|equals
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|comparison
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|Range
operator|.
name|openClosed
argument_list|(
name|boundary
condition|?
name|decrement
argument_list|(
name|ceil
argument_list|,
name|timeUnit
argument_list|)
else|:
name|ceil
argument_list|,
name|ceil
argument_list|)
return|;
case|case
name|LESS_THAN
case|:
return|return
name|Range
operator|.
name|atMost
argument_list|(
name|decrement
argument_list|(
name|ceil
argument_list|,
name|timeUnit
argument_list|)
argument_list|)
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|boundary
condition|?
name|Range
operator|.
name|atMost
argument_list|(
name|ceil
argument_list|)
else|:
name|Range
operator|.
name|atMost
argument_list|(
name|decrement
argument_list|(
name|ceil
argument_list|,
name|timeUnit
argument_list|)
argument_list|)
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|boundary
condition|?
name|Range
operator|.
name|greaterThan
argument_list|(
name|ceil
argument_list|)
else|:
name|Range
operator|.
name|greaterThan
argument_list|(
name|decrement
argument_list|(
name|ceil
argument_list|,
name|timeUnit
argument_list|)
argument_list|)
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|Range
operator|.
name|greaterThan
argument_list|(
name|decrement
argument_list|(
name|ceil
argument_list|,
name|timeUnit
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|comparison
argument_list|)
throw|;
block|}
block|}
name|boolean
name|isFloorCeilCall
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|FLOOR
case|:
case|case
name|CEIL
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
return|return
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
specifier|private
specifier|static
name|Calendar
name|increment
parameter_list|(
name|Calendar
name|c
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|)
block|{
name|c
operator|=
operator|(
name|Calendar
operator|)
name|c
operator|.
name|clone
argument_list|()
expr_stmt|;
name|c
operator|.
name|add
argument_list|(
name|calendarUnitFor
argument_list|(
name|timeUnit
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
specifier|private
specifier|static
name|Calendar
name|decrement
parameter_list|(
name|Calendar
name|c
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|)
block|{
name|c
operator|=
operator|(
name|Calendar
operator|)
name|c
operator|.
name|clone
argument_list|()
expr_stmt|;
name|c
operator|.
name|add
argument_list|(
name|calendarUnitFor
argument_list|(
name|timeUnit
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
specifier|private
specifier|static
name|Calendar
name|ceil
parameter_list|(
name|Calendar
name|c
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|)
block|{
name|Calendar
name|floor
init|=
name|floor
argument_list|(
name|c
argument_list|,
name|timeUnit
argument_list|)
decl_stmt|;
return|return
name|floor
operator|.
name|equals
argument_list|(
name|c
argument_list|)
condition|?
name|floor
else|:
name|increment
argument_list|(
name|floor
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**      * Computes floor of a calendar to a given time unit.      *      * @return returns a copy of calendar, floored to the given time unit      */
specifier|private
specifier|static
name|Calendar
name|floor
parameter_list|(
name|Calendar
name|c
parameter_list|,
name|TimeUnitRange
name|timeUnit
parameter_list|)
block|{
name|c
operator|=
operator|(
name|Calendar
operator|)
name|c
operator|.
name|clone
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|timeUnit
condition|)
block|{
case|case
name|YEAR
case|:
name|c
operator|.
name|set
argument_list|(
name|calendarUnitFor
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|)
argument_list|,
name|Calendar
operator|.
name|JANUARY
argument_list|)
expr_stmt|;
comment|// fall through; need to zero out lower time units
case|case
name|MONTH
case|:
name|c
operator|.
name|set
argument_list|(
name|calendarUnitFor
argument_list|(
name|TimeUnitRange
operator|.
name|DAY
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// fall through; need to zero out lower time units
case|case
name|DAY
case|:
name|c
operator|.
name|set
argument_list|(
name|calendarUnitFor
argument_list|(
name|TimeUnitRange
operator|.
name|HOUR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// fall through; need to zero out lower time units
case|case
name|HOUR
case|:
name|c
operator|.
name|set
argument_list|(
name|calendarUnitFor
argument_list|(
name|TimeUnitRange
operator|.
name|MINUTE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// fall through; need to zero out lower time units
case|case
name|MINUTE
case|:
name|c
operator|.
name|set
argument_list|(
name|calendarUnitFor
argument_list|(
name|TimeUnitRange
operator|.
name|SECOND
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// fall through; need to zero out lower time units
case|case
name|SECOND
case|:
name|c
operator|.
name|set
argument_list|(
name|calendarUnitFor
argument_list|(
name|TimeUnitRange
operator|.
name|MILLISECOND
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|c
return|;
block|}
block|}
block|}
end_class

end_unit

