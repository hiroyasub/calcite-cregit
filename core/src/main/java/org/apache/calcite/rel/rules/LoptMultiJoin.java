begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelColumnOrigin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Utility class that keeps track of the join factors that  * make up a {@link MultiJoin}.  */
end_comment

begin_class
specifier|public
class|class
name|LoptMultiJoin
block|{
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * The MultiJoin being optimized    */
name|MultiJoin
name|multiJoin
decl_stmt|;
comment|/**    * Join filters associated with the MultiJoin, decomposed into a list.    * Excludes left/right outer join filters.    */
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
decl_stmt|;
comment|/**    * All join filters associated with the MultiJoin, decomposed into a    * list. Includes left/right outer join filters.    */
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|allJoinFilters
decl_stmt|;
comment|/**    * Number of factors into the MultiJoin    */
specifier|private
specifier|final
name|int
name|nJoinFactors
decl_stmt|;
comment|/**    * Total number of fields in the MultiJoin    */
specifier|private
name|int
name|nTotalFields
decl_stmt|;
comment|/**    * Original inputs into the MultiJoin    */
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RelNode
argument_list|>
name|joinFactors
decl_stmt|;
comment|/**    * If a join factor is null generating in a left or right outer join,    * joinTypes indicates the join type corresponding to the factor. Otherwise,    * it is set to INNER.    */
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|JoinRelType
argument_list|>
name|joinTypes
decl_stmt|;
comment|/**    * If a join factor is null generating in a left or right outer join, the    * bitmap contains the non-null generating factors that the null generating    * factor is dependent upon    */
specifier|private
specifier|final
name|ImmutableBitSet
index|[]
name|outerJoinFactors
decl_stmt|;
comment|/**    * Bitmap corresponding to the fields projected from each join factor, after    * row scan processing has completed. This excludes fields referenced in    * join conditions, unless the field appears in the final projection list.    */
specifier|private
name|List
argument_list|<
name|ImmutableBitSet
argument_list|>
name|projFields
decl_stmt|;
comment|/**    * Map containing reference counts of the fields referenced in join    * conditions for each join factor. If a field is only required for a    * semijoin, then it is removed from the reference count. (Hence the need    * for reference counts instead of simply a bitmap.) The map is indexed by    * the factor number.    */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|int
index|[]
argument_list|>
name|joinFieldRefCountsMap
decl_stmt|;
comment|/**    * For each join filter, associates a bitmap indicating all factors    * referenced by the filter    */
specifier|private
name|Map
argument_list|<
name|RexNode
argument_list|,
name|ImmutableBitSet
argument_list|>
name|factorsRefByJoinFilter
decl_stmt|;
comment|/**    * For each join filter, associates a bitmap indicating all fields    * referenced by the filter    */
specifier|private
name|Map
argument_list|<
name|RexNode
argument_list|,
name|ImmutableBitSet
argument_list|>
name|fieldsRefByJoinFilter
decl_stmt|;
comment|/**    * Starting RexInputRef index corresponding to each join factor    */
name|int
index|[]
name|joinStart
decl_stmt|;
comment|/**    * Number of fields in each join factor    */
name|int
index|[]
name|nFieldsInJoinFactor
decl_stmt|;
comment|/**    * Bitmap indicating which factors each factor references in join filters    * that correspond to comparisons    */
name|ImmutableBitSet
index|[]
name|factorsRefByFactor
decl_stmt|;
comment|/**    * Weights of each factor combination    */
name|int
index|[]
index|[]
name|factorWeights
decl_stmt|;
comment|/**    * Type factory    */
specifier|final
name|RelDataTypeFactory
name|factory
decl_stmt|;
comment|/**    * Indicates for each factor whether its join can be removed because it is    * the dimension table in a semijoin. If it can be, the entry indicates the    * factor id of the fact table (corresponding to the dimension table) in the    * semijoin that allows the factor to be removed. If the factor cannot be    * removed, the entry corresponding to the factor is null.    */
name|Integer
index|[]
name|joinRemovalFactors
decl_stmt|;
comment|/**    * The semijoins that allow the join of a dimension table to be removed    */
name|LogicalJoin
index|[]
name|joinRemovalSemiJoins
decl_stmt|;
comment|/**    * Set of null-generating factors whose corresponding outer join can be    * removed from the query plan    */
name|Set
argument_list|<
name|Integer
argument_list|>
name|removableOuterJoinFactors
decl_stmt|;
comment|/**    * Map consisting of all pairs of self-joins where the self-join can be    * removed because the join between the identical factors is an equality    * join on the same set of unique keys. The map is keyed by either factor in    * the self join.    */
name|Map
argument_list|<
name|Integer
argument_list|,
name|RemovableSelfJoin
argument_list|>
name|removableSelfJoinPairs
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|LoptMultiJoin
parameter_list|(
name|MultiJoin
name|multiJoin
parameter_list|)
block|{
name|this
operator|.
name|multiJoin
operator|=
name|multiJoin
expr_stmt|;
name|joinFactors
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|multiJoin
operator|.
name|getInputs
argument_list|()
argument_list|)
expr_stmt|;
name|nJoinFactors
operator|=
name|joinFactors
operator|.
name|size
argument_list|()
expr_stmt|;
name|projFields
operator|=
name|multiJoin
operator|.
name|getProjFields
argument_list|()
expr_stmt|;
name|joinFieldRefCountsMap
operator|=
name|multiJoin
operator|.
name|getCopyJoinFieldRefCountsMap
argument_list|()
expr_stmt|;
name|joinFilters
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|multiJoin
operator|.
name|getJoinFilter
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|allJoinFilters
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|joinFilters
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|outerJoinFilters
init|=
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
name|allJoinFilters
operator|.
name|addAll
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|outerJoinFilters
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|nTotalFields
operator|=
name|multiJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
name|joinStart
operator|=
operator|new
name|int
index|[
name|nJoinFactors
index|]
expr_stmt|;
name|nFieldsInJoinFactor
operator|=
operator|new
name|int
index|[
name|nJoinFactors
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
name|joinStart
index|[
name|i
index|]
operator|=
name|start
expr_stmt|;
name|nFieldsInJoinFactor
index|[
name|i
index|]
operator|=
name|joinFactors
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
name|start
operator|+=
name|nFieldsInJoinFactor
index|[
name|i
index|]
expr_stmt|;
block|}
comment|// Extract outer join information from the join factors, including the type
comment|// of outer join and the factors that a null-generating factor is dependent
comment|// upon.
name|joinTypes
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|multiJoin
operator|.
name|getJoinTypes
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|outerJoinConds
init|=
name|this
operator|.
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
decl_stmt|;
name|outerJoinFactors
operator|=
operator|new
name|ImmutableBitSet
index|[
name|nJoinFactors
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|outerJoinConds
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// set a bitmap containing the factors referenced in the
comment|// ON condition of the outer join; mask off the factor
comment|// corresponding to the factor itself
name|ImmutableBitSet
name|dependentFactors
init|=
name|getJoinFilterFactorBitmap
argument_list|(
name|outerJoinConds
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|dependentFactors
operator|=
name|dependentFactors
operator|.
name|clear
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|outerJoinFactors
index|[
name|i
index|]
operator|=
name|dependentFactors
expr_stmt|;
block|}
block|}
comment|// determine which join factors each join filter references
name|setJoinFilterRefs
argument_list|()
expr_stmt|;
name|factory
operator|=
name|multiJoin
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
expr_stmt|;
name|joinRemovalFactors
operator|=
operator|new
name|Integer
index|[
name|nJoinFactors
index|]
expr_stmt|;
name|joinRemovalSemiJoins
operator|=
operator|new
name|LogicalJoin
index|[
name|nJoinFactors
index|]
expr_stmt|;
name|removableOuterJoinFactors
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
name|removableSelfJoinPairs
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * @return the MultiJoin corresponding to this multijoin    */
specifier|public
name|MultiJoin
name|getMultiJoinRel
parameter_list|()
block|{
return|return
name|multiJoin
return|;
block|}
comment|/**    * @return number of factors in this multijoin    */
specifier|public
name|int
name|getNumJoinFactors
parameter_list|()
block|{
return|return
name|nJoinFactors
return|;
block|}
comment|/**    * @param factIdx factor to be returned    *    * @return factor corresponding to the factor index passed in    */
specifier|public
name|RelNode
name|getJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|joinFactors
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
return|;
block|}
comment|/**    * @return total number of fields in the multijoin    */
specifier|public
name|int
name|getNumTotalFields
parameter_list|()
block|{
return|return
name|nTotalFields
return|;
block|}
comment|/**    * @param factIdx desired factor    *    * @return number of fields in the specified factor    */
specifier|public
name|int
name|getNumFieldsInJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|nFieldsInJoinFactor
index|[
name|factIdx
index|]
return|;
block|}
comment|/**    * @return all non-outer join filters in this multijoin    */
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getJoinFilters
parameter_list|()
block|{
return|return
name|joinFilters
return|;
block|}
comment|/**    * @param joinFilter filter for which information will be returned    *    * @return bitmap corresponding to the factors referenced within the    * specified join filter    */
specifier|public
name|ImmutableBitSet
name|getFactorsRefByJoinFilter
parameter_list|(
name|RexNode
name|joinFilter
parameter_list|)
block|{
return|return
name|factorsRefByJoinFilter
operator|.
name|get
argument_list|(
name|joinFilter
argument_list|)
return|;
block|}
comment|/**    * Returns array of fields contained within the multi-join    */
specifier|public
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|getMultiJoinFields
parameter_list|()
block|{
return|return
name|multiJoin
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
return|;
block|}
comment|/**    * @param joinFilter the filter for which information will be returned    *    * @return bitmap corresponding to the fields referenced by a join filter    */
specifier|public
name|ImmutableBitSet
name|getFieldsRefByJoinFilter
parameter_list|(
name|RexNode
name|joinFilter
parameter_list|)
block|{
return|return
name|fieldsRefByJoinFilter
operator|.
name|get
argument_list|(
name|joinFilter
argument_list|)
return|;
block|}
comment|/**    * @return weights of the different factors relative to one another    */
specifier|public
name|int
index|[]
index|[]
name|getFactorWeights
parameter_list|()
block|{
return|return
name|factorWeights
return|;
block|}
comment|/**    * @param factIdx factor for which information will be returned    *    * @return bitmap corresponding to the factors referenced by the specified    * factor in the various join filters that correspond to comparisons    */
specifier|public
name|ImmutableBitSet
name|getFactorsRefByFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|factorsRefByFactor
index|[
name|factIdx
index|]
return|;
block|}
comment|/**    * @param factIdx factor for which information will be returned    *    * @return starting offset within the multijoin for the specified factor    */
specifier|public
name|int
name|getJoinStart
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|joinStart
index|[
name|factIdx
index|]
return|;
block|}
comment|/**    * @param factIdx factor for which information will be returned    *    * @return whether or not the factor corresponds to a null-generating factor    * in a left or right outer join    */
specifier|public
name|boolean
name|isNullGenerating
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|joinTypes
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
operator|.
name|isOuterJoin
argument_list|()
return|;
block|}
comment|/**    * @param factIdx factor for which information will be returned    *    * @return bitmap containing the factors that a null generating factor is    * dependent upon, if the factor is null generating in a left or right outer    * join; otherwise null is returned    */
specifier|public
name|ImmutableBitSet
name|getOuterJoinFactors
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|outerJoinFactors
index|[
name|factIdx
index|]
return|;
block|}
comment|/**    * @param factIdx factor for which information will be returned    *    * @return outer join conditions associated with the specified null    * generating factor    */
specifier|public
name|RexNode
name|getOuterJoinCond
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|multiJoin
operator|.
name|getOuterJoinConditions
argument_list|()
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
return|;
block|}
comment|/**    * @param factIdx factor for which information will be returned    *    * @return bitmap containing the fields that are projected from a factor    */
specifier|public
name|ImmutableBitSet
name|getProjFields
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|projFields
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
return|;
block|}
comment|/**    * @param factIdx factor for which information will be returned    *    * @return the join field reference counts for a factor    */
specifier|public
name|int
index|[]
name|getJoinFieldRefCounts
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|joinFieldRefCountsMap
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
return|;
block|}
comment|/**    * @param dimIdx the dimension factor for which information will be returned    *    * @return the factor id of the fact table corresponding to a dimension    * table in a semijoin, in the case where the join with the dimension table    * can be removed    */
specifier|public
name|Integer
name|getJoinRemovalFactor
parameter_list|(
name|int
name|dimIdx
parameter_list|)
block|{
return|return
name|joinRemovalFactors
index|[
name|dimIdx
index|]
return|;
block|}
comment|/**    * @param dimIdx the dimension factor for which information will be returned    *    * @return the semijoin that allows the join of a dimension table to be    * removed    */
specifier|public
name|LogicalJoin
name|getJoinRemovalSemiJoin
parameter_list|(
name|int
name|dimIdx
parameter_list|)
block|{
return|return
name|joinRemovalSemiJoins
index|[
name|dimIdx
index|]
return|;
block|}
comment|/**    * Indicates that a dimension factor's join can be removed because of a    * semijoin with a fact table.    *    * @param dimIdx id of the dimension factor    * @param factIdx id of the fact factor    */
specifier|public
name|void
name|setJoinRemovalFactor
parameter_list|(
name|int
name|dimIdx
parameter_list|,
name|int
name|factIdx
parameter_list|)
block|{
name|joinRemovalFactors
index|[
name|dimIdx
index|]
operator|=
name|factIdx
expr_stmt|;
block|}
comment|/**    * Indicates the semijoin that allows the join of a dimension table to be    * removed    *    * @param dimIdx id of the dimension factor    * @param semiJoin the semijoin    */
specifier|public
name|void
name|setJoinRemovalSemiJoin
parameter_list|(
name|int
name|dimIdx
parameter_list|,
name|LogicalJoin
name|semiJoin
parameter_list|)
block|{
name|joinRemovalSemiJoins
index|[
name|dimIdx
index|]
operator|=
name|semiJoin
expr_stmt|;
block|}
comment|/**    * Returns a bitmap representing the factors referenced in a join filter    *    * @param joinFilter the join filter    * @param setFields if true, add the fields referenced by the join filter    * into a map    *    * @return the bitmap containing the factor references    */
name|ImmutableBitSet
name|getJoinFilterFactorBitmap
parameter_list|(
name|RexNode
name|joinFilter
parameter_list|,
name|boolean
name|setFields
parameter_list|)
block|{
name|ImmutableBitSet
name|fieldRefBitmap
init|=
name|fieldBitmap
argument_list|(
name|joinFilter
argument_list|)
decl_stmt|;
if|if
condition|(
name|setFields
condition|)
block|{
name|fieldsRefByJoinFilter
operator|.
name|put
argument_list|(
name|joinFilter
argument_list|,
name|fieldRefBitmap
argument_list|)
expr_stmt|;
block|}
return|return
name|factorBitmap
argument_list|(
name|fieldRefBitmap
argument_list|)
return|;
block|}
specifier|private
name|ImmutableBitSet
name|fieldBitmap
parameter_list|(
name|RexNode
name|joinFilter
parameter_list|)
block|{
specifier|final
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|()
decl_stmt|;
name|joinFilter
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
return|return
name|inputFinder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Sets bitmaps indicating which factors and fields each join filter    * references    */
specifier|private
name|void
name|setJoinFilterRefs
parameter_list|()
block|{
name|fieldsRefByJoinFilter
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|factorsRefByJoinFilter
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|ListIterator
argument_list|<
name|RexNode
argument_list|>
name|filterIter
init|=
name|allJoinFilters
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|filterIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|joinFilter
init|=
name|filterIter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// ignore the literal filter; if necessary, we'll add it back
comment|// later
if|if
condition|(
name|joinFilter
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|filterIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|ImmutableBitSet
name|factorRefBitmap
init|=
name|getJoinFilterFactorBitmap
argument_list|(
name|joinFilter
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|factorsRefByJoinFilter
operator|.
name|put
argument_list|(
name|joinFilter
argument_list|,
name|factorRefBitmap
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets the bitmap indicating which factors a filter references based on    * which fields it references    *    * @param fieldRefBitmap bitmap representing fields referenced    * @return bitmap representing factors referenced that will    * be set by this method    */
specifier|private
name|ImmutableBitSet
name|factorBitmap
parameter_list|(
name|ImmutableBitSet
name|fieldRefBitmap
parameter_list|)
block|{
name|ImmutableBitSet
operator|.
name|Builder
name|factorRefBitmap
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|fieldRefBitmap
control|)
block|{
name|int
name|factor
init|=
name|findRef
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|factorRefBitmap
operator|.
name|set
argument_list|(
name|factor
argument_list|)
expr_stmt|;
block|}
return|return
name|factorRefBitmap
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Determines the join factor corresponding to a RexInputRef    *    * @param rexInputRef rexInputRef index    *    * @return index corresponding to join factor    */
specifier|public
name|int
name|findRef
parameter_list|(
name|int
name|rexInputRef
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rexInputRef
operator|>=
name|joinStart
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|rexInputRef
operator|<
operator|(
name|joinStart
index|[
name|i
index|]
operator|+
name|nFieldsInJoinFactor
index|[
name|i
index|]
operator|)
operator|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|/**    * Sets weighting for each combination of factors, depending on which join    * filters reference which factors. Greater weight is given to equality    * conditions. Also, sets bitmaps indicating which factors are referenced by    * each factor within join filters that are comparisons.    */
specifier|public
name|void
name|setFactorWeights
parameter_list|()
block|{
name|factorWeights
operator|=
operator|new
name|int
index|[
name|nJoinFactors
index|]
index|[
name|nJoinFactors
index|]
expr_stmt|;
name|factorsRefByFactor
operator|=
operator|new
name|ImmutableBitSet
index|[
name|nJoinFactors
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
name|factorsRefByFactor
index|[
name|i
index|]
operator|=
name|ImmutableBitSet
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|RexNode
name|joinFilter
range|:
name|allJoinFilters
control|)
block|{
name|ImmutableBitSet
name|factorRefs
init|=
name|factorsRefByJoinFilter
operator|.
name|get
argument_list|(
name|joinFilter
argument_list|)
decl_stmt|;
comment|// don't give weights to non-comparison expressions
if|if
condition|(
operator|!
operator|(
name|joinFilter
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|joinFilter
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|COMPARISON
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// OR the factors referenced in this join filter into the
comment|// bitmaps corresponding to each of the factors; however,
comment|// exclude the bit corresponding to the factor itself
for|for
control|(
name|int
name|factor
range|:
name|factorRefs
control|)
block|{
name|factorsRefByFactor
index|[
name|factor
index|]
operator|=
name|factorsRefByFactor
index|[
name|factor
index|]
operator|.
name|rebuild
argument_list|()
operator|.
name|addAll
argument_list|(
name|factorRefs
argument_list|)
operator|.
name|clear
argument_list|(
name|factor
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|factorRefs
operator|.
name|cardinality
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|leftFactor
init|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|rightFactor
init|=
name|factorRefs
operator|.
name|nextSetBit
argument_list|(
name|leftFactor
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|joinFilter
decl_stmt|;
name|ImmutableBitSet
name|leftFields
init|=
name|fieldBitmap
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|leftBitmap
init|=
name|factorBitmap
argument_list|(
name|leftFields
argument_list|)
decl_stmt|;
comment|// filter contains only two factor references, one on each
comment|// side of the operator
name|int
name|weight
decl_stmt|;
if|if
condition|(
name|leftBitmap
operator|.
name|cardinality
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// give higher weight to equi-joins
switch|switch
condition|(
name|joinFilter
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
name|weight
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|weight
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// cross product of two tables
name|weight
operator|=
literal|1
expr_stmt|;
block|}
name|setFactorWeight
argument_list|(
name|weight
argument_list|,
name|leftFactor
argument_list|,
name|rightFactor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// multiple factor references -- set a weight for each
comment|// combination of factors referenced within the filter
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|list
init|=
name|ImmutableIntList
operator|.
name|copyOf
argument_list|(
name|factorRefs
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|outer
range|:
name|list
control|)
block|{
for|for
control|(
name|int
name|inner
range|:
name|list
control|)
block|{
if|if
condition|(
name|outer
operator|!=
name|inner
condition|)
block|{
name|setFactorWeight
argument_list|(
literal|1
argument_list|,
name|outer
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Sets an individual weight if the new weight is better than the current    * one    *    * @param weight weight to be set    * @param leftFactor index of left factor    * @param rightFactor index of right factor    */
specifier|private
name|void
name|setFactorWeight
parameter_list|(
name|int
name|weight
parameter_list|,
name|int
name|leftFactor
parameter_list|,
name|int
name|rightFactor
parameter_list|)
block|{
if|if
condition|(
name|factorWeights
index|[
name|leftFactor
index|]
index|[
name|rightFactor
index|]
operator|<
name|weight
condition|)
block|{
name|factorWeights
index|[
name|leftFactor
index|]
index|[
name|rightFactor
index|]
operator|=
name|weight
expr_stmt|;
name|factorWeights
index|[
name|rightFactor
index|]
index|[
name|leftFactor
index|]
operator|=
name|weight
expr_stmt|;
block|}
block|}
comment|/**    * Returns true if a join tree contains all factors required    *    * @param joinTree join tree to be examined    * @param factorsNeeded bitmap of factors required    *    * @return true if join tree contains all required factors    */
specifier|public
name|boolean
name|hasAllFactors
parameter_list|(
name|LoptJoinTree
name|joinTree
parameter_list|,
name|BitSet
name|factorsNeeded
parameter_list|)
block|{
return|return
name|BitSets
operator|.
name|contains
argument_list|(
name|BitSets
operator|.
name|of
argument_list|(
name|joinTree
operator|.
name|getTreeOrder
argument_list|()
argument_list|)
argument_list|,
name|factorsNeeded
argument_list|)
return|;
block|}
comment|/**    * Sets a bitmap indicating all child RelNodes in a join tree    *    * @param joinTree join tree to be examined    * @param childFactors bitmap to be set    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|void
name|getChildFactors
parameter_list|(
name|LoptJoinTree
name|joinTree
parameter_list|,
name|ImmutableBitSet
operator|.
name|Builder
name|childFactors
parameter_list|)
block|{
for|for
control|(
name|int
name|child
range|:
name|joinTree
operator|.
name|getTreeOrder
argument_list|()
control|)
block|{
name|childFactors
operator|.
name|set
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Retrieves the fields corresponding to a join between a left and right    * tree    *    * @param left left hand side of the join    * @param right right hand side of the join    *    * @return fields of the join    */
specifier|public
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|getJoinFields
parameter_list|(
name|LoptJoinTree
name|left
parameter_list|,
name|LoptJoinTree
name|right
parameter_list|)
block|{
name|RelDataType
name|rowType
init|=
name|factory
operator|.
name|createJoinType
argument_list|(
name|left
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|right
operator|.
name|getJoinTree
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|rowType
operator|.
name|getFieldList
argument_list|()
return|;
block|}
comment|/**    * Adds a join factor to the set of factors that can be removed because the    * factor is the null generating factor in an outer join, its join keys are    * unique, and the factor is not projected in the query    *    * @param factIdx join factor    */
specifier|public
name|void
name|addRemovableOuterJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
name|removableOuterJoinFactors
operator|.
name|add
argument_list|(
name|factIdx
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param factIdx factor in question    *    * @return true if the factor corresponds to the null generating factor in    * an outer join that can be removed    */
specifier|public
name|boolean
name|isRemovableOuterJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|removableOuterJoinFactors
operator|.
name|contains
argument_list|(
name|factIdx
argument_list|)
return|;
block|}
comment|/**    * Adds to a map that keeps track of removable self-join pairs.    *    * @param factor1 one of the factors in the self-join    * @param factor2 the second factor in the self-join    */
specifier|public
name|void
name|addRemovableSelfJoinPair
parameter_list|(
name|int
name|factor1
parameter_list|,
name|int
name|factor2
parameter_list|)
block|{
name|int
name|leftFactor
decl_stmt|;
name|int
name|rightFactor
decl_stmt|;
comment|// Put the factor with more fields on the left so it will be
comment|// preserved after the self-join is removed.
if|if
condition|(
name|getNumFieldsInJoinFactor
argument_list|(
name|factor1
argument_list|)
operator|>
name|getNumFieldsInJoinFactor
argument_list|(
name|factor2
argument_list|)
condition|)
block|{
name|leftFactor
operator|=
name|factor1
expr_stmt|;
name|rightFactor
operator|=
name|factor2
expr_stmt|;
block|}
else|else
block|{
name|leftFactor
operator|=
name|factor2
expr_stmt|;
name|rightFactor
operator|=
name|factor1
expr_stmt|;
block|}
comment|// Compute a column mapping such that if a column from the right
comment|// factor is also referenced in the left factor, we will map the
comment|// right reference to the left to avoid redundant references.
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|columnMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// First, locate the originating column for all simple column
comment|// references in the left factor.
specifier|final
name|RelNode
name|left
init|=
name|getJoinFactor
argument_list|(
name|leftFactor
argument_list|)
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|left
operator|.
name|getCluster
argument_list|()
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|leftFactorColMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|left
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelColumnOrigin
name|colOrigin
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|left
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|colOrigin
operator|!=
literal|null
condition|)
block|{
name|leftFactorColMapping
operator|.
name|put
argument_list|(
name|colOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Then, see if the right factor references any of the same columns
comment|// by locating their originating columns.  If there are matches,
comment|// then we want to store the corresponding offset into the left
comment|// factor.
name|RelNode
name|right
init|=
name|getJoinFactor
argument_list|(
name|rightFactor
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelColumnOrigin
name|colOrigin
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|right
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|colOrigin
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|Integer
name|leftOffset
init|=
name|leftFactorColMapping
operator|.
name|get
argument_list|(
name|colOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftOffset
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|columnMapping
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|leftOffset
argument_list|)
expr_stmt|;
block|}
name|RemovableSelfJoin
name|selfJoin
init|=
operator|new
name|RemovableSelfJoin
argument_list|(
name|leftFactor
argument_list|,
name|rightFactor
argument_list|,
name|columnMapping
argument_list|)
decl_stmt|;
name|removableSelfJoinPairs
operator|.
name|put
argument_list|(
name|leftFactor
argument_list|,
name|selfJoin
argument_list|)
expr_stmt|;
name|removableSelfJoinPairs
operator|.
name|put
argument_list|(
name|rightFactor
argument_list|,
name|selfJoin
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the other factor in a self-join pair if the factor passed in is    * a factor in a removable self-join; otherwise, returns null.    *    * @param factIdx one of the factors in a self-join pair    */
specifier|public
name|Integer
name|getOtherSelfJoinFactor
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
name|RemovableSelfJoin
name|selfJoin
init|=
name|removableSelfJoinPairs
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfJoin
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|else if
condition|(
name|selfJoin
operator|.
name|getRightFactor
argument_list|()
operator|==
name|factIdx
condition|)
block|{
return|return
name|selfJoin
operator|.
name|getLeftFactor
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|selfJoin
operator|.
name|getRightFactor
argument_list|()
return|;
block|}
block|}
comment|/**    * @param factIdx factor in a self-join    *    * @return true if the factor is the left factor in a self-join    */
specifier|public
name|boolean
name|isLeftFactorInRemovableSelfJoin
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
name|RemovableSelfJoin
name|selfJoin
init|=
name|removableSelfJoinPairs
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfJoin
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|selfJoin
operator|.
name|getLeftFactor
argument_list|()
operator|==
name|factIdx
return|;
block|}
comment|/**    * @param factIdx factor in a self-join    *    * @return true if the factor is the right factor in a self-join    */
specifier|public
name|boolean
name|isRightFactorInRemovableSelfJoin
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
name|RemovableSelfJoin
name|selfJoin
init|=
name|removableSelfJoinPairs
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfJoin
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|selfJoin
operator|.
name|getRightFactor
argument_list|()
operator|==
name|factIdx
return|;
block|}
comment|/**    * Determines whether there is a mapping from a column in the right factor    * of a self-join to a column from the left factor. Assumes that the right    * factor is a part of a self-join.    *    * @param rightFactor the index of the right factor    * @param rightOffset the column offset of the right factor    *    * @return the offset of the corresponding column in the left factor, if    * such a column mapping exists; otherwise, null is returned    */
specifier|public
name|Integer
name|getRightColumnMapping
parameter_list|(
name|int
name|rightFactor
parameter_list|,
name|int
name|rightOffset
parameter_list|)
block|{
name|RemovableSelfJoin
name|selfJoin
init|=
name|removableSelfJoinPairs
operator|.
name|get
argument_list|(
name|rightFactor
argument_list|)
decl_stmt|;
assert|assert
name|selfJoin
operator|.
name|getRightFactor
argument_list|()
operator|==
name|rightFactor
assert|;
return|return
name|selfJoin
operator|.
name|getColumnMapping
argument_list|()
operator|.
name|get
argument_list|(
name|rightOffset
argument_list|)
return|;
block|}
specifier|public
name|Edge
name|createEdge
parameter_list|(
name|RexNode
name|condition
parameter_list|)
block|{
name|ImmutableBitSet
name|fieldRefBitmap
init|=
name|fieldBitmap
argument_list|(
name|condition
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|factorRefBitmap
init|=
name|factorBitmap
argument_list|(
name|fieldRefBitmap
argument_list|)
decl_stmt|;
return|return
operator|new
name|Edge
argument_list|(
name|condition
argument_list|,
name|factorRefBitmap
argument_list|,
name|fieldRefBitmap
argument_list|)
return|;
block|}
comment|/** Information about a join-condition. */
specifier|static
class|class
name|Edge
block|{
specifier|final
name|ImmutableBitSet
name|factors
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|columns
decl_stmt|;
specifier|final
name|RexNode
name|condition
decl_stmt|;
name|Edge
parameter_list|(
name|RexNode
name|condition
parameter_list|,
name|ImmutableBitSet
name|factors
parameter_list|,
name|ImmutableBitSet
name|columns
parameter_list|)
block|{
name|this
operator|.
name|condition
operator|=
name|condition
expr_stmt|;
name|this
operator|.
name|factors
operator|=
name|factors
expr_stmt|;
name|this
operator|.
name|columns
operator|=
name|columns
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Edge(condition: "
operator|+
name|condition
operator|+
literal|", factors: "
operator|+
name|factors
operator|+
literal|", columns: "
operator|+
name|columns
operator|+
literal|")"
return|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Utility class used to keep track of the factors in a removable self-join.    * The right factor in the self-join is the one that will be removed.    */
specifier|private
class|class
name|RemovableSelfJoin
block|{
comment|/**      * The left factor in a removable self-join      */
specifier|private
name|int
name|leftFactor
decl_stmt|;
comment|/**      * The right factor in a removable self-join, namely the factor that      * will be removed      */
specifier|private
name|int
name|rightFactor
decl_stmt|;
comment|/**      * A mapping that maps references to columns from the right factor to      * columns in the left factor, if the column is referenced in both      * factors      */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|columnMapping
decl_stmt|;
name|RemovableSelfJoin
parameter_list|(
name|int
name|leftFactor
parameter_list|,
name|int
name|rightFactor
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|columnMapping
parameter_list|)
block|{
name|this
operator|.
name|leftFactor
operator|=
name|leftFactor
expr_stmt|;
name|this
operator|.
name|rightFactor
operator|=
name|rightFactor
expr_stmt|;
name|this
operator|.
name|columnMapping
operator|=
name|columnMapping
expr_stmt|;
block|}
specifier|public
name|int
name|getLeftFactor
parameter_list|()
block|{
return|return
name|leftFactor
return|;
block|}
specifier|public
name|int
name|getRightFactor
parameter_list|()
block|{
return|return
name|rightFactor
return|;
block|}
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getColumnMapping
parameter_list|()
block|{
return|return
name|columnMapping
return|;
block|}
block|}
block|}
end_class

end_unit

