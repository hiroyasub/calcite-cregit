begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ViewExpanders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelColumnOrigin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Implements the logic for determining the optimal  * semi-joins to be used in processing joins in a query.  */
end_comment

begin_class
specifier|public
class|class
name|LoptSemiJoinOptimizer
block|{
comment|//~ Static fields/initializers ---------------------------------------------
comment|// minimum score required for a join filter to be considered
specifier|private
specifier|static
specifier|final
name|int
name|THRESHOLD_SCORE
init|=
literal|10
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|private
specifier|final
name|RelMetadataQuery
name|mq
decl_stmt|;
comment|/**    * Semijoins corresponding to each join factor, if they are going to be    * filtered by semijoins. Otherwise, the entry is the original join factor.    */
specifier|private
name|RelNode
index|[]
name|chosenSemiJoins
decl_stmt|;
comment|/**    * Associates potential semijoins with each fact table factor. The first    * parameter in the map corresponds to the fact table. The second    * corresponds to the dimension table and a SemiJoin that captures all    * the necessary semijoin data between that fact and dimension table    */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|LogicalJoin
argument_list|>
argument_list|>
name|possibleSemiJoins
decl_stmt|;
specifier|private
specifier|final
name|Ordering
argument_list|<
name|Integer
argument_list|>
name|factorCostOrdering
init|=
name|Ordering
operator|.
name|from
argument_list|(
operator|new
name|FactorCostComparator
argument_list|()
argument_list|)
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|public
name|LoptSemiJoinOptimizer
parameter_list|(
name|RelMetadataQuery
name|mq
parameter_list|,
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
comment|// there are no semijoins yet, so initialize to the original
comment|// factors
name|this
operator|.
name|mq
operator|=
name|mq
expr_stmt|;
name|int
name|nJoinFactors
init|=
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
decl_stmt|;
name|chosenSemiJoins
operator|=
operator|new
name|RelNode
index|[
name|nJoinFactors
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
name|chosenSemiJoins
index|[
name|i
index|]
operator|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Determines all possible semijoins that can be used by dimension tables to    * filter fact tables. Constructs SemiJoinRels corresponding to potential    * dimension table filters and stores them in the member field    * "possibleSemiJoins"    *    * @param multiJoin join factors being optimized    */
specifier|public
name|void
name|makePossibleSemiJoins
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|)
block|{
name|possibleSemiJoins
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// semijoins can't be used with any type of outer join, including full
if|if
condition|(
name|multiJoin
operator|.
name|getMultiJoinRel
argument_list|()
operator|.
name|isFullOuterJoin
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|nJoinFactors
init|=
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|factIdx
init|=
literal|0
init|;
name|factIdx
operator|<
name|nJoinFactors
condition|;
name|factIdx
operator|++
control|)
block|{
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|dimFilters
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|LogicalJoin
argument_list|>
name|semiJoinMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// loop over all filters and find equality filters that reference
comment|// this factor and one other factor
for|for
control|(
name|RexNode
name|joinFilter
range|:
name|multiJoin
operator|.
name|getJoinFilters
argument_list|()
control|)
block|{
name|int
name|dimIdx
init|=
name|isSuitableFilter
argument_list|(
name|multiJoin
argument_list|,
name|joinFilter
argument_list|,
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|dimIdx
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
comment|// if either the fact or dimension table is null generating,
comment|// we cannot use semijoins
if|if
condition|(
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|factIdx
argument_list|)
operator|||
name|multiJoin
operator|.
name|isNullGenerating
argument_list|(
name|dimIdx
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// if we've already matched against this dimension factor,
comment|// then add the filter to the list associated with
comment|// that dimension factor; otherwise, create a new entry
name|List
argument_list|<
name|RexNode
argument_list|>
name|currDimFilters
init|=
name|dimFilters
operator|.
name|get
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|currDimFilters
operator|==
literal|null
condition|)
block|{
name|currDimFilters
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|currDimFilters
operator|.
name|add
argument_list|(
name|joinFilter
argument_list|)
expr_stmt|;
name|dimFilters
operator|.
name|put
argument_list|(
name|dimIdx
argument_list|,
name|currDimFilters
argument_list|)
expr_stmt|;
block|}
comment|// if there are potential dimension filters, determine if there
comment|// are appropriate indexes
name|Set
argument_list|<
name|Integer
argument_list|>
name|dimIdxes
init|=
name|dimFilters
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|dimIdx
range|:
name|dimIdxes
control|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
init|=
name|dimFilters
operator|.
name|get
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinFilters
operator|!=
literal|null
condition|)
block|{
name|LogicalJoin
name|semiJoin
init|=
name|findSemiJoinIndexByCost
argument_list|(
name|multiJoin
argument_list|,
name|joinFilters
argument_list|,
name|factIdx
argument_list|,
name|dimIdx
argument_list|)
decl_stmt|;
comment|// if an index is available, keep track of it as a
comment|// possible semijoin
if|if
condition|(
name|semiJoin
operator|!=
literal|null
condition|)
block|{
name|semiJoinMap
operator|.
name|put
argument_list|(
name|dimIdx
argument_list|,
name|semiJoin
argument_list|)
expr_stmt|;
name|possibleSemiJoins
operator|.
name|put
argument_list|(
name|factIdx
argument_list|,
name|semiJoinMap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Determines if a join filter can be used with a semijoin against a    * specified fact table. A suitable filter is of the form "factable.col1 =    * dimTable.col2".    *    * @param multiJoin join factors being optimized    * @param joinFilter filter to be analyzed    * @param factIdx index corresponding to the fact table    *    * @return index of corresponding dimension table if the filter is    * appropriate; otherwise -1 is returned    */
specifier|private
name|int
name|isSuitableFilter
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|RexNode
name|joinFilter
parameter_list|,
name|int
name|factIdx
parameter_list|)
block|{
comment|// ignore non-equality filters where the operands are not
comment|// RexInputRefs
switch|switch
condition|(
name|joinFilter
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|RexCall
operator|)
name|joinFilter
operator|)
operator|.
name|getOperands
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
operator|||
operator|!
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// filter is suitable if each side of the filter only contains a
comment|// single factor reference and one side references the fact table and
comment|// the other references the dimension table; since we know this is
comment|// a join filter and we've already verified that the operands are
comment|// RexInputRefs, verify that the factors belong to the fact and
comment|// dimension table
name|ImmutableBitSet
name|joinRefs
init|=
name|multiJoin
operator|.
name|getFactorsRefByJoinFilter
argument_list|(
name|joinFilter
argument_list|)
decl_stmt|;
assert|assert
name|joinRefs
operator|.
name|cardinality
argument_list|()
operator|==
literal|2
assert|;
name|int
name|factor1
init|=
name|joinRefs
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|factor2
init|=
name|joinRefs
operator|.
name|nextSetBit
argument_list|(
name|factor1
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|factor1
operator|==
name|factIdx
condition|)
block|{
return|return
name|factor2
return|;
block|}
if|if
condition|(
name|factor2
operator|==
name|factIdx
condition|)
block|{
return|return
name|factor1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Given a list of possible filters on a fact table, determine if there is    * an index that can be used, provided all the fact table keys originate    * from the same underlying table.    *    * @param multiJoin join factors being optimized    * @param joinFilters filters to be used on the fact table    * @param factIdx index in join factors corresponding to the fact table    * @param dimIdx index in join factors corresponding to the dimension table    *    * @return SemiJoin containing information regarding the semijoin that    * can be used to filter the fact table    */
specifier|private
name|LogicalJoin
name|findSemiJoinIndexByCost
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
parameter_list|,
name|int
name|factIdx
parameter_list|,
name|int
name|dimIdx
parameter_list|)
block|{
comment|// create a SemiJoin with the semi-join condition and keys
name|RexNode
name|semiJoinCondition
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|joinFilters
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|int
name|leftAdjustment
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|factIdx
condition|;
name|i
operator|++
control|)
block|{
name|leftAdjustment
operator|-=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|semiJoinCondition
operator|=
name|adjustSemiJoinCondition
argument_list|(
name|multiJoin
argument_list|,
name|leftAdjustment
argument_list|,
name|semiJoinCondition
argument_list|,
name|factIdx
argument_list|,
name|dimIdx
argument_list|)
expr_stmt|;
name|RelNode
name|factRel
init|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
name|RelNode
name|dimRel
init|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
specifier|final
name|JoinInfo
name|joinInfo
init|=
name|JoinInfo
operator|.
name|of
argument_list|(
name|factRel
argument_list|,
name|dimRel
argument_list|,
name|semiJoinCondition
argument_list|)
decl_stmt|;
assert|assert
name|joinInfo
operator|.
name|leftKeys
operator|.
name|size
argument_list|()
operator|>
literal|0
assert|;
comment|// mutable copies
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|joinInfo
operator|.
name|leftKeys
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|joinInfo
operator|.
name|rightKeys
argument_list|)
decl_stmt|;
comment|// make sure all the fact table keys originate from the same table
comment|// and are simple column references
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|actualLeftKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|LcsTable
name|factTable
init|=
name|validateKeys
argument_list|(
name|factRel
argument_list|,
name|leftKeys
argument_list|,
name|rightKeys
argument_list|,
name|actualLeftKeys
argument_list|)
decl_stmt|;
if|if
condition|(
name|factTable
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// find the best index
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|bestKeyOrder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|LcsTableScan
name|tmpFactRel
init|=
operator|(
name|LcsTableScan
operator|)
name|factTable
operator|.
name|toRel
argument_list|(
name|ViewExpanders
operator|.
name|simpleContext
argument_list|(
name|factRel
operator|.
name|getCluster
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|LcsIndexOptimizer
name|indexOptimizer
init|=
operator|new
name|LcsIndexOptimizer
argument_list|(
name|tmpFactRel
argument_list|)
decl_stmt|;
name|FemLocalIndex
name|bestIndex
init|=
name|indexOptimizer
operator|.
name|findSemiJoinIndexByCost
argument_list|(
name|dimRel
argument_list|,
name|actualLeftKeys
argument_list|,
name|rightKeys
argument_list|,
name|bestKeyOrder
argument_list|)
decl_stmt|;
if|if
condition|(
name|bestIndex
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// if necessary, truncate the keys to reflect the ones that match
comment|// the index and remove the corresponding, unnecessary filters from
comment|// the condition; note that we don't save the actual keys here because
comment|// later when the semijoin is pushed past other RelNodes, the keys will
comment|// be converted
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|truncatedLeftKeys
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|truncatedRightKeys
decl_stmt|;
if|if
condition|(
name|actualLeftKeys
operator|.
name|size
argument_list|()
operator|==
name|bestKeyOrder
operator|.
name|size
argument_list|()
condition|)
block|{
name|truncatedLeftKeys
operator|=
name|leftKeys
expr_stmt|;
name|truncatedRightKeys
operator|=
name|rightKeys
expr_stmt|;
block|}
else|else
block|{
name|truncatedLeftKeys
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|truncatedRightKeys
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|key
range|:
name|bestKeyOrder
control|)
block|{
name|truncatedLeftKeys
operator|.
name|add
argument_list|(
name|leftKeys
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|truncatedRightKeys
operator|.
name|add
argument_list|(
name|rightKeys
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|semiJoinCondition
operator|=
name|removeExtraFilters
argument_list|(
name|truncatedLeftKeys
argument_list|,
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|factIdx
argument_list|)
argument_list|,
name|semiJoinCondition
argument_list|)
expr_stmt|;
block|}
return|return
name|LogicalJoin
operator|.
name|create
argument_list|(
name|factRel
argument_list|,
name|dimRel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|semiJoinCondition
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|SEMI
argument_list|)
return|;
block|}
comment|/**    * Modifies the semijoin condition to reflect the fact that the RHS is now    * the second factor into a join and the LHS is the first.    *    * @param multiJoin join factors being optimized    * @param leftAdjustment amount the left RexInputRefs need to be adjusted by    * @param semiJoinCondition condition to be adjusted    * @param leftIdx index of the join factor corresponding to the LHS of the    * semijoin,    * @param rightIdx index of the join factor corresponding to the RHS of the    * semijoin    *    * @return modified semijoin condition    */
specifier|private
name|RexNode
name|adjustSemiJoinCondition
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|int
name|leftAdjustment
parameter_list|,
name|RexNode
name|semiJoinCondition
parameter_list|,
name|int
name|leftIdx
parameter_list|,
name|int
name|rightIdx
parameter_list|)
block|{
comment|// adjust the semijoin condition to reflect the fact that the
comment|// RHS is now the second factor into the semijoin and the LHS
comment|// is the first
name|int
name|rightAdjustment
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rightIdx
condition|;
name|i
operator|++
control|)
block|{
name|rightAdjustment
operator|-=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|rightStart
init|=
operator|-
name|rightAdjustment
decl_stmt|;
name|int
name|numFieldsLeftIdx
init|=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|leftIdx
argument_list|)
decl_stmt|;
name|int
name|numFieldsRightIdx
init|=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|rightIdx
argument_list|)
decl_stmt|;
name|rightAdjustment
operator|+=
name|numFieldsLeftIdx
expr_stmt|;
comment|// only adjust the filter if adjustments are required
if|if
condition|(
operator|(
name|leftAdjustment
operator|!=
literal|0
operator|)
operator|||
operator|(
name|rightAdjustment
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|multiJoin
operator|.
name|getNumTotalFields
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|leftAdjustment
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
operator|-
name|leftAdjustment
init|;
name|i
operator|<
operator|(
operator|-
name|leftAdjustment
operator|+
name|numFieldsLeftIdx
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
name|leftAdjustment
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rightAdjustment
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|rightStart
init|;
name|i
operator|<
operator|(
name|rightStart
operator|+
name|numFieldsRightIdx
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
name|rightAdjustment
expr_stmt|;
block|}
block|}
return|return
name|semiJoinCondition
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|multiJoin
operator|.
name|getMultiJoinFields
argument_list|()
argument_list|,
name|adjustments
argument_list|)
argument_list|)
return|;
block|}
return|return
name|semiJoinCondition
return|;
block|}
comment|/**    * Validates the candidate semijoin keys corresponding to the fact table.    * Ensure the keys all originate from the same underlying table, and they    * all correspond to simple column references. If unsuitable keys are found,    * they're removed from the key list and a new list corresponding to the    * remaining valid keys is returned.    *    * @param factRel fact table RelNode    * @param leftKeys fact table semijoin keys    * @param rightKeys dimension table semijoin keys    * @param actualLeftKeys the remaining valid fact table semijoin keys    *    * @return the underlying fact table if the semijoin keys are valid;    * otherwise null    */
specifier|private
name|LcsTable
name|validateKeys
parameter_list|(
name|RelNode
name|factRel
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|actualLeftKeys
parameter_list|)
block|{
name|int
name|keyIdx
init|=
literal|0
decl_stmt|;
name|RelOptTable
name|theTable
init|=
literal|null
decl_stmt|;
name|ListIterator
argument_list|<
name|Integer
argument_list|>
name|keyIter
init|=
name|leftKeys
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|keyIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|boolean
name|removeKey
init|=
literal|false
decl_stmt|;
specifier|final
name|RelColumnOrigin
name|colOrigin
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|factRel
argument_list|,
name|keyIter
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
comment|// can't use the rid column as a semijoin key
if|if
condition|(
operator|(
name|colOrigin
operator|==
literal|null
operator|)
operator|||
name|LucidDbSpecialOperators
operator|.
name|isLcsRidColumnId
argument_list|(
name|colOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|)
condition|)
block|{
name|removeKey
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|RelOptTable
name|table
init|=
name|colOrigin
operator|.
name|getOriginTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|theTable
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|table
operator|instanceof
name|LcsTable
operator|)
condition|)
block|{
comment|// not a column store table
name|removeKey
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|theTable
operator|=
name|table
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the tables must match because the column has
comment|// a simple origin
assert|assert
name|table
operator|==
name|theTable
assert|;
block|}
block|}
if|if
condition|(
operator|!
name|removeKey
condition|)
block|{
name|actualLeftKeys
operator|.
name|add
argument_list|(
name|colOrigin
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|)
expr_stmt|;
name|keyIdx
operator|++
expr_stmt|;
block|}
else|else
block|{
name|keyIter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|rightKeys
operator|.
name|remove
argument_list|(
name|keyIdx
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if all keys have been removed, then we don't have any valid semijoin
comment|// keys
if|if
condition|(
name|actualLeftKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|(
name|LcsTable
operator|)
name|theTable
return|;
block|}
block|}
comment|/**    * Removes from an expression any sub-expressions that reference key values    * that aren't contained in a key list passed in. The keys represent join    * keys on one side of a join. The subexpressions are all assumed to be of    * the form "tab1.col1 = tab2.col2".    *    * @param keys join keys from one side of the join    * @param nFields number of fields in the side of the join for which the    * keys correspond    * @param condition original expression    *    * @return modified expression with filters that don't reference specified    * keys removed    */
specifier|private
name|RexNode
name|removeExtraFilters
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|keys
parameter_list|,
name|int
name|nFields
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
comment|// recursively walk the expression; if all sub-expressions are
comment|// removed from one side of the expression, just return what remains
comment|// from the other side
assert|assert
name|condition
operator|instanceof
name|RexCall
assert|;
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|condition
decl_stmt|;
if|if
condition|(
name|condition
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|AND
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
name|RexNode
name|left
init|=
name|removeExtraFilters
argument_list|(
name|keys
argument_list|,
name|nFields
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|right
init|=
name|removeExtraFilters
argument_list|(
name|keys
argument_list|,
name|nFields
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
return|return
name|right
return|;
block|}
if|if
condition|(
name|right
operator|==
literal|null
condition|)
block|{
return|return
name|left
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|// determine which side of the equality filter references the join
comment|// operand we're interested in; then, check if it is contained in
comment|// our key list
assert|assert
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|EQUALS
assert|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperands
argument_list|()
decl_stmt|;
assert|assert
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
assert|;
assert|assert
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
assert|;
name|int
name|idx
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|nFields
condition|)
block|{
if|if
condition|(
operator|!
name|keys
operator|.
name|contains
argument_list|(
name|idx
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|idx
operator|=
operator|(
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getIndex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|keys
operator|.
name|contains
argument_list|(
name|idx
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|condition
return|;
block|}
comment|/**    * Finds the optimal semijoin for filtering the least costly fact table from    * among the remaining possible semijoins to choose from. The chosen    * semijoin is stored in the chosenSemiJoins array    *    * @param multiJoin join factors being optimized    *    * @return true if a suitable semijoin is found; false otherwise    */
specifier|public
name|boolean
name|chooseBestSemiJoin
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|)
block|{
comment|// sort the join factors based on the cost of each factor filtered by
comment|// semijoins, if semijoins have been chosen
name|int
name|nJoinFactors
init|=
name|multiJoin
operator|.
name|getNumJoinFactors
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|sortedFactors
init|=
name|factorCostOrdering
operator|.
name|immutableSortedCopy
argument_list|(
name|Util
operator|.
name|range
argument_list|(
name|nJoinFactors
argument_list|)
argument_list|)
decl_stmt|;
comment|// loop through the factors in sort order, treating the factor as
comment|// a fact table; analyze the possible semijoins associated with
comment|// that fact table
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nJoinFactors
condition|;
name|i
operator|++
control|)
block|{
name|Integer
name|factIdx
init|=
name|sortedFactors
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelNode
name|factRel
init|=
name|chosenSemiJoins
index|[
name|factIdx
index|]
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|LogicalJoin
argument_list|>
name|possibleDimensions
init|=
name|possibleSemiJoins
operator|.
name|get
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|possibleDimensions
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|double
name|bestScore
init|=
literal|0.0
decl_stmt|;
name|int
name|bestDimIdx
init|=
operator|-
literal|1
decl_stmt|;
comment|// loop through each dimension table associated with the current
comment|// fact table and analyze the ones that have semijoins with this
comment|// fact table
name|Set
argument_list|<
name|Integer
argument_list|>
name|dimIdxes
init|=
name|possibleDimensions
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|dimIdx
range|:
name|dimIdxes
control|)
block|{
name|LogicalJoin
name|semiJoin
init|=
name|possibleDimensions
operator|.
name|get
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|semiJoin
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// keep track of the dimension table that has the best score
comment|// for filtering this fact table
name|double
name|score
init|=
name|computeScore
argument_list|(
name|factRel
argument_list|,
name|chosenSemiJoins
index|[
name|dimIdx
index|]
argument_list|,
name|semiJoin
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|score
operator|>
name|THRESHOLD_SCORE
operator|)
operator|&&
operator|(
name|score
operator|>
name|bestScore
operator|)
condition|)
block|{
name|bestDimIdx
operator|=
name|dimIdx
expr_stmt|;
name|bestScore
operator|=
name|score
expr_stmt|;
block|}
block|}
comment|// if a suitable dimension table has been found, associate it
comment|// with the fact table in the chosenSemiJoins array; also remove
comment|// the entry from possibleSemiJoins so we won't chose it again;
comment|// note that we create the SemiJoin using the chosen semijoins
comment|// already created for each factor so any chaining of filters will
comment|// be accounted for
if|if
condition|(
name|bestDimIdx
operator|!=
operator|-
literal|1
condition|)
block|{
name|LogicalJoin
name|semiJoin
init|=
name|possibleDimensions
operator|.
name|get
argument_list|(
name|bestDimIdx
argument_list|)
decl_stmt|;
name|LogicalJoin
name|chosenSemiJoin
init|=
name|LogicalJoin
operator|.
name|create
argument_list|(
name|factRel
argument_list|,
name|chosenSemiJoins
index|[
name|bestDimIdx
index|]
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|semiJoin
operator|.
name|getCondition
argument_list|()
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|SEMI
argument_list|)
decl_stmt|;
name|chosenSemiJoins
index|[
name|factIdx
index|]
operator|=
name|chosenSemiJoin
expr_stmt|;
comment|// determine if the dimension table doesn't need to be joined
comment|// as a result of this semijoin
name|removeJoin
argument_list|(
name|multiJoin
argument_list|,
name|chosenSemiJoin
argument_list|,
name|factIdx
argument_list|,
name|bestDimIdx
argument_list|)
expr_stmt|;
name|removePossibleSemiJoin
argument_list|(
name|possibleDimensions
argument_list|,
name|factIdx
argument_list|,
name|bestDimIdx
argument_list|)
expr_stmt|;
comment|// need to also remove the semijoin from the possible
comment|// semijoins associated with this dimension table, as the
comment|// semijoin can only be used to filter one table, not both
name|removePossibleSemiJoin
argument_list|(
name|possibleSemiJoins
operator|.
name|get
argument_list|(
name|bestDimIdx
argument_list|)
argument_list|,
name|bestDimIdx
argument_list|,
name|factIdx
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// continue searching on the next fact table if we couldn't find
comment|// a semijoin for the current fact table
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Computes a score relevant to applying a set of semijoins on a fact table.    * The higher the score, the better.    *    * @param factRel fact table being filtered    * @param dimRel dimension table that participates in semijoin    * @param semiJoin semijoin between fact and dimension tables    *    * @return computed score of applying the dimension table filters on the    * fact table    */
specifier|private
name|double
name|computeScore
parameter_list|(
name|RelNode
name|factRel
parameter_list|,
name|RelNode
name|dimRel
parameter_list|,
name|LogicalJoin
name|semiJoin
parameter_list|)
block|{
comment|// Estimate savings as a result of applying semijoin filter on fact
comment|// table.  As a heuristic, the selectivity of the semijoin needs to
comment|// be less than half.  There may be instances where an even smaller
comment|// selectivity value is required because of the overhead of
comment|// index lookups on a very large fact table.  Half was chosen as
comment|// a middle ground based on testing that was done with a large
comment|// data set.
specifier|final
name|ImmutableBitSet
name|dimCols
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|semiJoin
operator|.
name|analyzeCondition
argument_list|()
operator|.
name|rightKeys
argument_list|)
decl_stmt|;
specifier|final
name|double
name|selectivity
init|=
name|RelMdUtil
operator|.
name|computeSemiJoinSelectivity
argument_list|(
name|mq
argument_list|,
name|factRel
argument_list|,
name|dimRel
argument_list|,
name|semiJoin
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectivity
operator|>
literal|.5
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|RelOptCost
name|factCost
init|=
name|mq
operator|.
name|getCumulativeCost
argument_list|(
name|factRel
argument_list|)
decl_stmt|;
comment|// if not enough information, return a low score
if|if
condition|(
name|factCost
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|double
name|savings
init|=
operator|(
literal|1.0
operator|-
name|Math
operator|.
name|sqrt
argument_list|(
name|selectivity
argument_list|)
operator|)
operator|*
name|Math
operator|.
name|max
argument_list|(
literal|1.0
argument_list|,
name|factCost
operator|.
name|getRows
argument_list|()
argument_list|)
decl_stmt|;
comment|// Additional savings if the dimension columns are unique.  We can
comment|// ignore nulls since they will be filtered out by the semijoin.
name|boolean
name|uniq
init|=
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUniqueWhenNullsFiltered
argument_list|(
name|mq
argument_list|,
name|dimRel
argument_list|,
name|dimCols
argument_list|)
decl_stmt|;
if|if
condition|(
name|uniq
condition|)
block|{
name|savings
operator|*=
literal|2.0
expr_stmt|;
block|}
comment|// compute the cost of doing an extra scan on the dimension table,
comment|// including the distinct sort on top of the scan; if the dimension
comment|// columns are already unique, no need to add on the dup removal cost
specifier|final
name|Double
name|dimSortCost
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|dimRel
argument_list|)
decl_stmt|;
specifier|final
name|Double
name|dupRemCost
init|=
name|uniq
condition|?
literal|0
else|:
name|dimSortCost
decl_stmt|;
specifier|final
name|RelOptCost
name|dimCost
init|=
name|mq
operator|.
name|getCumulativeCost
argument_list|(
name|dimRel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dimSortCost
operator|==
literal|null
operator|)
operator|||
operator|(
name|dupRemCost
operator|==
literal|null
operator|)
operator|||
operator|(
name|dimCost
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|double
name|dimRows
init|=
name|dimCost
operator|.
name|getRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|dimRows
operator|<
literal|1.0
condition|)
block|{
name|dimRows
operator|=
literal|1.0
expr_stmt|;
block|}
return|return
name|savings
operator|/
name|dimRows
return|;
block|}
comment|/**    * Determines whether a join of the dimension table in a semijoin can be    * removed. It can be if the dimension keys are unique and the only fields    * referenced from the dimension table are its semijoin keys. The semijoin    * keys can be mapped to the corresponding keys from the fact table (because    * of the equality condition associated with the semijoin keys). Therefore,    * that's why the dimension table can be removed even though those fields    * are referenced elsewhere in the query tree.    *    * @param multiJoin join factors being optimized    * @param semiJoin semijoin under consideration    * @param factIdx id of the fact table in the semijoin    * @param dimIdx id of the dimension table in the semijoin    */
specifier|private
name|void
name|removeJoin
parameter_list|(
name|LoptMultiJoin
name|multiJoin
parameter_list|,
name|LogicalJoin
name|semiJoin
parameter_list|,
name|int
name|factIdx
parameter_list|,
name|int
name|dimIdx
parameter_list|)
block|{
comment|// if the dimension can be removed because of another semijoin, then
comment|// no need to proceed any further
if|if
condition|(
name|multiJoin
operator|.
name|getJoinRemovalFactor
argument_list|(
name|dimIdx
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
comment|// Check if the semijoin keys corresponding to the dimension table
comment|// are unique.  The semijoin will filter out the nulls.
specifier|final
name|ImmutableBitSet
name|dimKeys
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|semiJoin
operator|.
name|analyzeCondition
argument_list|()
operator|.
name|rightKeys
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|dimRel
init|=
name|multiJoin
operator|.
name|getJoinFactor
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RelMdUtil
operator|.
name|areColumnsDefinitelyUniqueWhenNullsFiltered
argument_list|(
name|mq
argument_list|,
name|dimRel
argument_list|,
name|dimKeys
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// check that the only fields referenced from the dimension table
comment|// in either its projection or join conditions are the dimension
comment|// keys
name|ImmutableBitSet
name|dimProjRefs
init|=
name|multiJoin
operator|.
name|getProjFields
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|dimProjRefs
operator|==
literal|null
condition|)
block|{
name|int
name|nDimFields
init|=
name|multiJoin
operator|.
name|getNumFieldsInJoinFactor
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
name|dimProjRefs
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|nDimFields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dimKeys
operator|.
name|contains
argument_list|(
name|dimProjRefs
argument_list|)
condition|)
block|{
return|return;
block|}
name|int
index|[]
name|dimJoinRefCounts
init|=
name|multiJoin
operator|.
name|getJoinFieldRefCounts
argument_list|(
name|dimIdx
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dimJoinRefCounts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dimJoinRefCounts
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|dimKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|// criteria met; keep track of the fact table and the semijoin that
comment|// allow the join of this dimension table to be removed
name|multiJoin
operator|.
name|setJoinRemovalFactor
argument_list|(
name|dimIdx
argument_list|,
name|factIdx
argument_list|)
expr_stmt|;
name|multiJoin
operator|.
name|setJoinRemovalSemiJoin
argument_list|(
name|dimIdx
argument_list|,
name|semiJoin
argument_list|)
expr_stmt|;
comment|// if the dimension table doesn't reference anything in its projection
comment|// and the only fields referenced in its joins are the dimension keys
comment|// of this semijoin, then we can decrement the join reference counts
comment|// corresponding to the fact table's semijoin keys, since the
comment|// dimension table doesn't need to use those keys
if|if
condition|(
name|dimProjRefs
operator|.
name|cardinality
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dimJoinRefCounts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dimJoinRefCounts
index|[
name|i
index|]
operator|>
literal|1
condition|)
block|{
return|return;
block|}
if|else if
condition|(
name|dimJoinRefCounts
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|dimKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
name|int
index|[]
name|factJoinRefCounts
init|=
name|multiJoin
operator|.
name|getJoinFieldRefCounts
argument_list|(
name|factIdx
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|key
range|:
name|semiJoin
operator|.
name|analyzeCondition
argument_list|()
operator|.
name|leftKeys
control|)
block|{
name|factJoinRefCounts
index|[
name|key
index|]
operator|--
expr_stmt|;
block|}
block|}
comment|/**    * Removes a dimension table from a fact table's list of possible semi-joins.    *    * @param possibleDimensions possible dimension tables associated with the    * fact table    * @param factIdx index corresponding to fact table    * @param dimIdx index corresponding to dimension table    */
specifier|private
name|void
name|removePossibleSemiJoin
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|LogicalJoin
argument_list|>
name|possibleDimensions
parameter_list|,
name|Integer
name|factIdx
parameter_list|,
name|Integer
name|dimIdx
parameter_list|)
block|{
comment|// dimension table may not have a corresponding semijoin if it
comment|// wasn't indexable
if|if
condition|(
name|possibleDimensions
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|possibleDimensions
operator|.
name|remove
argument_list|(
name|dimIdx
argument_list|)
expr_stmt|;
if|if
condition|(
name|possibleDimensions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|possibleSemiJoins
operator|.
name|remove
argument_list|(
name|factIdx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|possibleSemiJoins
operator|.
name|put
argument_list|(
name|factIdx
argument_list|,
name|possibleDimensions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the optimal semijoin for the specified factor; may be the factor    * itself if semijoins are not chosen for the factor.    *    * @param factIdx Index corresponding to the desired factor    */
specifier|public
name|RelNode
name|getChosenSemiJoin
parameter_list|(
name|int
name|factIdx
parameter_list|)
block|{
return|return
name|chosenSemiJoins
index|[
name|factIdx
index|]
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Compares factors. */
specifier|private
class|class
name|FactorCostComparator
implements|implements
name|Comparator
argument_list|<
name|Integer
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Integer
name|rel1Idx
parameter_list|,
name|Integer
name|rel2Idx
parameter_list|)
block|{
name|RelOptCost
name|c1
init|=
name|mq
operator|.
name|getCumulativeCost
argument_list|(
name|chosenSemiJoins
index|[
name|rel1Idx
index|]
argument_list|)
decl_stmt|;
name|RelOptCost
name|c2
init|=
name|mq
operator|.
name|getCumulativeCost
argument_list|(
name|chosenSemiJoins
index|[
name|rel2Idx
index|]
argument_list|)
decl_stmt|;
comment|// nulls are arbitrarily sorted
if|if
condition|(
operator|(
name|c1
operator|==
literal|null
operator|)
operator|||
operator|(
name|c2
operator|==
literal|null
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|c1
operator|.
name|isLt
argument_list|(
name|c2
argument_list|)
condition|?
operator|-
literal|1
else|:
operator|(
name|c1
operator|.
name|equals
argument_list|(
name|c2
argument_list|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
block|}
comment|/** Dummy class to allow code to compile. */
specifier|private
specifier|abstract
specifier|static
class|class
name|LcsTable
implements|implements
name|RelOptTable
block|{   }
comment|/** Dummy class to allow code to compile. */
specifier|private
specifier|static
class|class
name|LcsTableScan
block|{   }
comment|/** Dummy class to allow code to compile. */
specifier|private
specifier|static
class|class
name|LcsIndexOptimizer
block|{
name|LcsIndexOptimizer
parameter_list|(
name|LcsTableScan
name|rel
parameter_list|)
block|{
block|}
specifier|public
name|FemLocalIndex
name|findSemiJoinIndexByCost
parameter_list|(
name|RelNode
name|dimRel
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|actualLeftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|bestKeyOrder
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Dummy class to allow code to compile. */
specifier|private
specifier|static
class|class
name|FemLocalIndex
block|{ }
comment|/** Dummy class to allow code to compile. */
specifier|private
specifier|static
class|class
name|LucidDbSpecialOperators
block|{
specifier|public
specifier|static
name|boolean
name|isLcsRidColumnId
parameter_list|(
name|int
name|originColumnOrdinal
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

