begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Calc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SetOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCalc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCorrelate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalMatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalSortExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableFunctionScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|materialize
operator|.
name|MaterializedViewRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|StarTable
import|;
end_import

begin_comment
comment|/** Rules that perform logical transformations on relational expressions.  *  * @see MaterializedViewRules */
end_comment

begin_class
specifier|public
class|class
name|CoreRules
block|{
specifier|private
name|CoreRules
parameter_list|()
block|{
block|}
comment|/** Rule that recognizes an {@link Aggregate}    * on top of a {@link Project} and if possible    * aggregates through the Project or removes the Project. */
specifier|public
specifier|static
specifier|final
name|AggregateProjectMergeRule
name|AGGREGATE_PROJECT_MERGE
init|=
name|AggregateProjectMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes constant keys from an {@link Aggregate}. */
specifier|public
specifier|static
specifier|final
name|AggregateProjectPullUpConstantsRule
name|AGGREGATE_PROJECT_PULL_UP_CONSTANTS
init|=
name|AggregateProjectPullUpConstantsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** More general form of {@link #AGGREGATE_PROJECT_PULL_UP_CONSTANTS}    * that matches any relational expression. */
specifier|public
specifier|static
specifier|final
name|AggregateProjectPullUpConstantsRule
name|AGGREGATE_ANY_PULL_UP_CONSTANTS
init|=
name|AggregateProjectPullUpConstantsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withOperandFor
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelNode
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate} on    * a {@link StarTable.StarTableScan}. */
specifier|public
specifier|static
specifier|final
name|AggregateStarTableRule
name|AGGREGATE_STAR_TABLE
init|=
name|AggregateStarTableRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Variant of {@link #AGGREGATE_STAR_TABLE} that accepts a {@link Project}    * between the {@link Aggregate} and its {@link StarTable.StarTableScan}    * input. */
specifier|public
specifier|static
specifier|final
name|AggregateProjectStarTableRule
name|AGGREGATE_PROJECT_STAR_TABLE
init|=
name|AggregateProjectStarTableRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that reduces aggregate functions in    * an {@link Aggregate} to simpler forms. */
specifier|public
specifier|static
specifier|final
name|AggregateReduceFunctionsRule
name|AGGREGATE_REDUCE_FUNCTIONS
init|=
name|AggregateReduceFunctionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate} on an {@link Aggregate},    * and merges into a single Aggregate if the top aggregate's group key is a    * subset of the lower aggregate's group key, and the aggregates are    * expansions of rollups. */
specifier|public
specifier|static
specifier|final
name|AggregateMergeRule
name|AGGREGATE_MERGE
init|=
name|AggregateMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes an {@link Aggregate}    * if it computes no aggregate functions    * (that is, it is implementing {@code SELECT DISTINCT}),    * or all the aggregate functions are splittable,    * and the underlying relational expression is already distinct. */
specifier|public
specifier|static
specifier|final
name|AggregateRemoveRule
name|AGGREGATE_REMOVE
init|=
name|AggregateRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that expands distinct aggregates    * (such as {@code COUNT(DISTINCT x)}) from a    * {@link Aggregate}.    * This instance operates only on logical expressions. */
specifier|public
specifier|static
specifier|final
name|AggregateExpandDistinctAggregatesRule
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
init|=
name|AggregateExpandDistinctAggregatesRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #AGGREGATE_EXPAND_DISTINCT_AGGREGATES} but generates a Join. */
specifier|public
specifier|static
specifier|final
name|AggregateExpandDistinctAggregatesRule
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
init|=
name|AggregateExpandDistinctAggregatesRule
operator|.
name|Config
operator|.
name|JOIN
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate}    * on a {@link Filter} and transposes them,    * pushing the aggregate below the filter. */
specifier|public
specifier|static
specifier|final
name|AggregateFilterTransposeRule
name|AGGREGATE_FILTER_TRANSPOSE
init|=
name|AggregateFilterTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate}    * on a {@link Join} and removes the left input    * of the join provided that the left input is also a left join if    * possible. */
specifier|public
specifier|static
specifier|final
name|AggregateJoinJoinRemoveRule
name|AGGREGATE_JOIN_JOIN_REMOVE
init|=
name|AggregateJoinJoinRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate}    * on a {@link Join} and removes the join    * provided that the join is a left join or right join and it computes no    * aggregate functions or all the aggregate calls have distinct. */
specifier|public
specifier|static
specifier|final
name|AggregateJoinRemoveRule
name|AGGREGATE_JOIN_REMOVE
init|=
name|AggregateJoinRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes an {@link Aggregate}    * past a {@link Join}. */
specifier|public
specifier|static
specifier|final
name|AggregateJoinTransposeRule
name|AGGREGATE_JOIN_TRANSPOSE
init|=
name|AggregateJoinTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #AGGREGATE_JOIN_TRANSPOSE}, but extended to push down aggregate    * functions. */
specifier|public
specifier|static
specifier|final
name|AggregateJoinTransposeRule
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
init|=
name|AggregateJoinTransposeRule
operator|.
name|Config
operator|.
name|EXTENDED
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes an {@link Aggregate}    * past a non-distinct {@link Union}. */
specifier|public
specifier|static
specifier|final
name|AggregateUnionTransposeRule
name|AGGREGATE_UNION_TRANSPOSE
init|=
name|AggregateUnionTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate} whose input is a {@link Union}    * one of whose inputs is an {@code Aggregate}.    *    *<p>Because it matches {@link RelNode} for each input of {@code Union}, it    * will create O(N ^ 2) matches, which may cost too much during the popMatch    * phase in VolcanoPlanner. If efficiency is a concern, we recommend that you    * use {@link #AGGREGATE_UNION_AGGREGATE_FIRST}    * and {@link #AGGREGATE_UNION_AGGREGATE_SECOND} instead. */
specifier|public
specifier|static
specifier|final
name|AggregateUnionAggregateRule
name|AGGREGATE_UNION_AGGREGATE
init|=
name|AggregateUnionAggregateRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #AGGREGATE_UNION_AGGREGATE}, but matches an {@code Aggregate}    * only as the left input of the {@code Union}. */
specifier|public
specifier|static
specifier|final
name|AggregateUnionAggregateRule
name|AGGREGATE_UNION_AGGREGATE_FIRST
init|=
name|AggregateUnionAggregateRule
operator|.
name|Config
operator|.
name|AGG_FIRST
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #AGGREGATE_UNION_AGGREGATE}, but matches an {@code Aggregate}    * only as the right input of the {@code Union}. */
specifier|public
specifier|static
specifier|final
name|AggregateUnionAggregateRule
name|AGGREGATE_UNION_AGGREGATE_SECOND
init|=
name|AggregateUnionAggregateRule
operator|.
name|Config
operator|.
name|AGG_SECOND
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts CASE-style filtered aggregates into true filtered    * aggregates. */
specifier|public
specifier|static
specifier|final
name|AggregateCaseToFilterRule
name|AGGREGATE_CASE_TO_FILTER
init|=
name|AggregateCaseToFilterRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that merges a {@link Calc} onto a {@code Calc}. */
specifier|public
specifier|static
specifier|final
name|CalcMergeRule
name|CALC_MERGE
init|=
name|CalcMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes a trivial {@link LogicalCalc}. */
specifier|public
specifier|static
specifier|final
name|CalcRemoveRule
name|CALC_REMOVE
init|=
name|CalcRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that reduces operations on the DECIMAL type, such as casts or    * arithmetic, into operations involving more primitive types such as BIGINT    * and DOUBLE. */
specifier|public
specifier|static
specifier|final
name|ReduceDecimalsRule
name|CALC_REDUCE_DECIMALS
init|=
name|ReduceDecimalsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link LogicalCalc}.    *    * @see #FILTER_REDUCE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|CalcReduceExpressionsRule
name|CALC_REDUCE_EXPRESSIONS
init|=
name|ReduceExpressionsRule
operator|.
name|CalcReduceExpressionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts a {@link Calc} to a {@link Project} and    * {@link Filter}. */
specifier|public
specifier|static
specifier|final
name|CalcSplitRule
name|CALC_SPLIT
init|=
name|CalcSplitRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that transforms a {@link Calc}    * that contains windowed aggregates to a mixture of    * {@link LogicalWindow} and {@code Calc}. */
specifier|public
specifier|static
specifier|final
name|ProjectToWindowRule
operator|.
name|CalcToWindowRule
name|CALC_TO_WINDOW
init|=
name|ProjectToWindowRule
operator|.
name|CalcToWindowRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pre-casts inputs to a particular type. This can assist operator    * implementations that impose requirements on their input types. */
specifier|public
specifier|static
specifier|final
name|CoerceInputsRule
name|COERCE_INPUTS
init|=
name|CoerceInputsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes constants inside a {@link LogicalExchange}. */
specifier|public
specifier|static
specifier|final
name|ExchangeRemoveConstantKeysRule
name|EXCHANGE_REMOVE_CONSTANT_KEYS
init|=
name|ExchangeRemoveConstantKeysRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes constants inside a {@link LogicalSortExchange}. */
specifier|public
specifier|static
specifier|final
name|ExchangeRemoveConstantKeysRule
name|SORT_EXCHANGE_REMOVE_CONSTANT_KEYS
init|=
name|ExchangeRemoveConstantKeysRule
operator|.
name|Config
operator|.
name|SORT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that tries to push filter expressions into a join    * condition and into the inputs of the join. */
specifier|public
specifier|static
specifier|final
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
name|FILTER_INTO_JOIN
init|=
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Dumber version of {@link #FILTER_INTO_JOIN}. Not intended for production    * use, but keeps some tests working for which {@code FILTER_INTO_JOIN} is too    * smart. */
specifier|public
specifier|static
specifier|final
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
name|FILTER_INTO_JOIN_DUMB
init|=
name|FILTER_INTO_JOIN
operator|.
name|config
operator|.
name|withSmart
argument_list|(
literal|false
argument_list|)
operator|.
name|as
argument_list|(
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
operator|.
name|Config
operator|.
name|class
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that combines two {@link LogicalFilter}s. */
specifier|public
specifier|static
specifier|final
name|FilterMergeRule
name|FILTER_MERGE
init|=
name|FilterMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that merges a {@link Filter} and a {@link LogicalCalc}. The    * result is a {@link LogicalCalc} whose filter condition is the logical AND    * of the two.    *    * @see #PROJECT_CALC_MERGE */
specifier|public
specifier|static
specifier|final
name|FilterCalcMergeRule
name|FILTER_CALC_MERGE
init|=
name|FilterCalcMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts a {@link LogicalFilter} to a {@link LogicalCalc}.    *    * @see #PROJECT_TO_CALC */
specifier|public
specifier|static
specifier|final
name|FilterToCalcRule
name|FILTER_TO_CALC
init|=
name|FilterToCalcRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Filter} past an {@link Aggregate}.    *    * @see #AGGREGATE_FILTER_TRANSPOSE */
specifier|public
specifier|static
specifier|final
name|FilterAggregateTransposeRule
name|FILTER_AGGREGATE_TRANSPOSE
init|=
name|FilterAggregateTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** The default instance of    * {@link org.apache.calcite.rel.rules.FilterProjectTransposeRule}.    *    *<p>It does not allow a Filter to be pushed past the Project if    * {@link RexUtil#containsCorrelation there is a correlation condition})    * anywhere in the Filter, since in some cases it can prevent a    * {@link Correlate} from being de-correlated.    */
specifier|public
specifier|static
specifier|final
name|FilterProjectTransposeRule
name|FILTER_PROJECT_TRANSPOSE
init|=
name|FilterProjectTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link LogicalFilter}    * past a {@link LogicalTableFunctionScan}. */
specifier|public
specifier|static
specifier|final
name|FilterTableFunctionTransposeRule
name|FILTER_TABLE_FUNCTION_TRANSPOSE
init|=
name|FilterTableFunctionTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches a {@link Filter} on a {@link TableScan}. */
specifier|public
specifier|static
specifier|final
name|FilterTableScanRule
name|FILTER_SCAN
init|=
name|FilterTableScanRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches a {@link Filter} on an    * {@link org.apache.calcite.adapter.enumerable.EnumerableInterpreter} on a    * {@link TableScan}. */
specifier|public
specifier|static
specifier|final
name|FilterTableScanRule
name|FILTER_INTERPRETER_SCAN
init|=
name|FilterTableScanRule
operator|.
name|Config
operator|.
name|INTERPRETER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Filter} above a {@link Correlate} into the    * inputs of the {@code Correlate}. */
specifier|public
specifier|static
specifier|final
name|FilterCorrelateRule
name|FILTER_CORRELATE
init|=
name|FilterCorrelateRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that merges a {@link Filter} into a {@link MultiJoin},    * creating a richer {@code MultiJoin}.    *    * @see #PROJECT_MULTI_JOIN_MERGE */
specifier|public
specifier|static
specifier|final
name|FilterMultiJoinMergeRule
name|FILTER_MULTI_JOIN_MERGE
init|=
name|FilterMultiJoinMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that replaces {@code IS NOT DISTINCT FROM}    * in a {@link Filter} with logically equivalent operations. */
specifier|public
specifier|static
specifier|final
name|FilterRemoveIsNotDistinctFromRule
name|FILTER_EXPAND_IS_NOT_DISTINCT_FROM
init|=
name|FilterRemoveIsNotDistinctFromRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Filter} past a {@link SetOp}. */
specifier|public
specifier|static
specifier|final
name|FilterSetOpTransposeRule
name|FILTER_SET_OP_TRANSPOSE
init|=
name|FilterSetOpTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link LogicalFilter}.    *    * @see #JOIN_REDUCE_EXPRESSIONS    * @see #PROJECT_REDUCE_EXPRESSIONS    * @see #CALC_REDUCE_EXPRESSIONS    * @see #WINDOW_REDUCE_EXPRESSIONS    */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|FilterReduceExpressionsRule
name|FILTER_REDUCE_EXPRESSIONS
init|=
name|ReduceExpressionsRule
operator|.
name|FilterReduceExpressionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that flattens an {@link Intersect} on an {@code Intersect}    * into a single {@code Intersect}. */
specifier|public
specifier|static
specifier|final
name|UnionMergeRule
name|INTERSECT_MERGE
init|=
name|UnionMergeRule
operator|.
name|Config
operator|.
name|INTERSECT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that translates a distinct    * {@link Intersect} into a group of operators    * composed of {@link Union}, {@link Aggregate}, etc. */
specifier|public
specifier|static
specifier|final
name|IntersectToDistinctRule
name|INTERSECT_TO_DISTINCT
init|=
name|IntersectToDistinctRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts a {@link LogicalMatch} to the result of calling    * {@link LogicalMatch#copy}. */
specifier|public
specifier|static
specifier|final
name|MatchRule
name|MATCH
init|=
name|MatchRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that flattens a {@link Minus} on a {@code Minus}    * into a single {@code Minus}. */
specifier|public
specifier|static
specifier|final
name|UnionMergeRule
name|MINUS_MERGE
init|=
name|UnionMergeRule
operator|.
name|Config
operator|.
name|MINUS
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches a {@link Project} on an {@link Aggregate},    * projecting away aggregate calls that are not used. */
specifier|public
specifier|static
specifier|final
name|ProjectAggregateMergeRule
name|PROJECT_AGGREGATE_MERGE
init|=
name|ProjectAggregateMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that merges a {@link LogicalProject} and a {@link LogicalCalc}.    *    * @see #FILTER_CALC_MERGE */
specifier|public
specifier|static
specifier|final
name|ProjectCalcMergeRule
name|PROJECT_CALC_MERGE
init|=
name|ProjectCalcMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches a {@link Project} on a {@link Correlate} and    * pushes the projections to the Correlate's left and right inputs. */
specifier|public
specifier|static
specifier|final
name|ProjectCorrelateTransposeRule
name|PROJECT_CORRELATE_TRANSPOSE
init|=
name|ProjectCorrelateTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Project} past a {@link Filter}.    *    * @see #PROJECT_FILTER_TRANSPOSE_WHOLE_PROJECT_EXPRESSIONS    * @see #PROJECT_FILTER_TRANSPOSE_WHOLE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ProjectFilterTransposeRule
name|PROJECT_FILTER_TRANSPOSE
init|=
name|ProjectFilterTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #PROJECT_FILTER_TRANSPOSE}, but pushes down project and filter    * expressions whole, not field references. */
specifier|public
specifier|static
specifier|final
name|ProjectFilterTransposeRule
name|PROJECT_FILTER_TRANSPOSE_WHOLE_EXPRESSIONS
init|=
name|ProjectFilterTransposeRule
operator|.
name|Config
operator|.
name|PROJECT_FILTER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #PROJECT_FILTER_TRANSPOSE},    * pushes down field references for filters,    * but pushes down project expressions whole. */
specifier|public
specifier|static
specifier|final
name|ProjectFilterTransposeRule
name|PROJECT_FILTER_TRANSPOSE_WHOLE_PROJECT_EXPRESSIONS
init|=
name|ProjectFilterTransposeRule
operator|.
name|Config
operator|.
name|PROJECT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link LogicalProject}.    *    * @see #FILTER_REDUCE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|ProjectReduceExpressionsRule
name|PROJECT_REDUCE_EXPRESSIONS
init|=
name|ReduceExpressionsRule
operator|.
name|ProjectReduceExpressionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts sub-queries from project expressions into    * {@link Correlate} instances.    *    * @see #FILTER_SUB_QUERY_TO_CORRELATE    * @see #JOIN_SUB_QUERY_TO_CORRELATE */
specifier|public
specifier|static
specifier|final
name|SubQueryRemoveRule
name|PROJECT_SUB_QUERY_TO_CORRELATE
init|=
name|SubQueryRemoveRule
operator|.
name|Config
operator|.
name|PROJECT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts a sub-queries from filter expressions into    * {@link Correlate} instances.    *    * @see #PROJECT_SUB_QUERY_TO_CORRELATE    * @see #JOIN_SUB_QUERY_TO_CORRELATE */
specifier|public
specifier|static
specifier|final
name|SubQueryRemoveRule
name|FILTER_SUB_QUERY_TO_CORRELATE
init|=
name|SubQueryRemoveRule
operator|.
name|Config
operator|.
name|FILTER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts sub-queries from join expressions into    * {@link Correlate} instances.    *    * @see #PROJECT_SUB_QUERY_TO_CORRELATE    * @see #FILTER_SUB_QUERY_TO_CORRELATE */
specifier|public
specifier|static
specifier|final
name|SubQueryRemoveRule
name|JOIN_SUB_QUERY_TO_CORRELATE
init|=
name|SubQueryRemoveRule
operator|.
name|Config
operator|.
name|JOIN
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that transforms a {@link Project}    *  into a mixture of {@code LogicalProject}    * and {@link LogicalWindow}. */
specifier|public
specifier|static
specifier|final
name|ProjectToWindowRule
operator|.
name|ProjectToLogicalProjectAndWindowRule
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
init|=
name|ProjectToWindowRule
operator|.
name|ProjectToLogicalProjectAndWindowRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that creates a {@link Join#isSemiJoin semi-join} from a    * {@link Project} on top of a {@link Join} with an {@link Aggregate} as its    * right input.    *    * @see #JOIN_TO_SEMI_JOIN */
specifier|public
specifier|static
specifier|final
name|SemiJoinRule
operator|.
name|ProjectToSemiJoinRule
name|PROJECT_TO_SEMI_JOIN
init|=
name|SemiJoinRule
operator|.
name|ProjectToSemiJoinRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Project} on a {@link Join} and removes the    * left input of the join provided that the left input is also a left join. */
specifier|public
specifier|static
specifier|final
name|ProjectJoinJoinRemoveRule
name|PROJECT_JOIN_JOIN_REMOVE
init|=
name|ProjectJoinJoinRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Project} on a {@link Join} and removes the    * join provided that the join is a left join or right join and the join keys    * are unique. */
specifier|public
specifier|static
specifier|final
name|ProjectJoinRemoveRule
name|PROJECT_JOIN_REMOVE
init|=
name|ProjectJoinRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link LogicalProject} past a {@link LogicalJoin}    * by splitting the projection into a projection on top of each child of    * the join. */
specifier|public
specifier|static
specifier|final
name|ProjectJoinTransposeRule
name|PROJECT_JOIN_TRANSPOSE
init|=
name|ProjectJoinTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that merges a {@link Project} into another {@link Project},    * provided the projects are not projecting identical sets of input    * references. */
specifier|public
specifier|static
specifier|final
name|ProjectMergeRule
name|PROJECT_MERGE
init|=
name|ProjectMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link LogicalProject} past a {@link SetOp}.    *    *<p>The children of the {@code SetOp} will project    * only the {@link RexInputRef}s referenced in the original    * {@code LogicalProject}. */
specifier|public
specifier|static
specifier|final
name|ProjectSetOpTransposeRule
name|PROJECT_SET_OP_TRANSPOSE
init|=
name|ProjectSetOpTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Project} into a {@link MultiJoin},    * creating a richer {@code MultiJoin}.    *    * @see #FILTER_MULTI_JOIN_MERGE */
specifier|public
specifier|static
specifier|final
name|ProjectMultiJoinMergeRule
name|PROJECT_MULTI_JOIN_MERGE
init|=
name|ProjectMultiJoinMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that, given a {@link Project} node that merely returns its input,    *  converts the node into its input. */
specifier|public
specifier|static
specifier|final
name|ProjectRemoveRule
name|PROJECT_REMOVE
init|=
name|ProjectRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts a {@link Project} on a {@link TableScan}    * of a {@link org.apache.calcite.schema.ProjectableFilterableTable}    * to a {@link org.apache.calcite.interpreter.Bindables.BindableTableScan}.    *    * @see #PROJECT_INTERPRETER_TABLE_SCAN */
specifier|public
specifier|static
specifier|final
name|ProjectTableScanRule
name|PROJECT_TABLE_SCAN
init|=
name|ProjectTableScanRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #PROJECT_TABLE_SCAN}, but with an intervening    * {@link org.apache.calcite.adapter.enumerable.EnumerableInterpreter}. */
specifier|public
specifier|static
specifier|final
name|ProjectTableScanRule
name|PROJECT_INTERPRETER_TABLE_SCAN
init|=
name|ProjectTableScanRule
operator|.
name|Config
operator|.
name|INTERPRETER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts a {@link LogicalProject} to a {@link LogicalCalc}.    *    * @see #FILTER_TO_CALC */
specifier|public
specifier|static
specifier|final
name|ProjectToCalcRule
name|PROJECT_TO_CALC
init|=
name|ProjectToCalcRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link LogicalProject} past a {@link LogicalWindow}. */
specifier|public
specifier|static
specifier|final
name|ProjectWindowTransposeRule
name|PROJECT_WINDOW_TRANSPOSE
init|=
name|ProjectWindowTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes predicates in a Join into the inputs to the join. */
specifier|public
specifier|static
specifier|final
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
name|JOIN_CONDITION_PUSH
init|=
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule to add a semi-join into a {@link Join}. */
specifier|public
specifier|static
specifier|final
name|JoinAddRedundantSemiJoinRule
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
init|=
name|JoinAddRedundantSemiJoinRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that changes a join based on the associativity rule,    * ((a JOIN b) JOIN c)&rarr; (a JOIN (b JOIN c)). */
specifier|public
specifier|static
specifier|final
name|JoinAssociateRule
name|JOIN_ASSOCIATE
init|=
name|JoinAssociateRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that permutes the inputs to an inner {@link Join}. */
specifier|public
specifier|static
specifier|final
name|JoinCommuteRule
name|JOIN_COMMUTE
init|=
name|JoinCommuteRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #JOIN_COMMUTE} but swaps outer joins as well as inner joins. */
specifier|public
specifier|static
specifier|final
name|JoinCommuteRule
name|JOIN_COMMUTE_OUTER
init|=
name|JoinCommuteRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withSwapOuter
argument_list|(
literal|true
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule to convert an    * {@link LogicalJoin inner join} to a    * {@link LogicalFilter filter} on top of a    * {@link LogicalJoin cartesian inner join}. */
specifier|public
specifier|static
specifier|final
name|JoinExtractFilterRule
name|JOIN_EXTRACT_FILTER
init|=
name|JoinExtractFilterRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches a {@link LogicalJoin} whose inputs are    * {@link LogicalProject}s, and pulls the project expressions up. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_BOTH_TRANSPOSE
init|=
name|JoinProjectTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_BOTH_TRANSPOSE} but only the left input is    * a {@link LogicalProject}. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_LEFT_TRANSPOSE
init|=
name|JoinProjectTransposeRule
operator|.
name|Config
operator|.
name|LEFT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_BOTH_TRANSPOSE} but only the right input is    * a {@link LogicalProject}. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_RIGHT_TRANSPOSE
init|=
name|JoinProjectTransposeRule
operator|.
name|Config
operator|.
name|RIGHT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_BOTH_TRANSPOSE} but match outer as well as    * inner join. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_BOTH_TRANSPOSE_INCLUDE_OUTER
init|=
name|JoinProjectTransposeRule
operator|.
name|Config
operator|.
name|OUTER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_LEFT_TRANSPOSE} but match outer as well as    * inner join. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_LEFT_TRANSPOSE_INCLUDE_OUTER
init|=
name|JoinProjectTransposeRule
operator|.
name|Config
operator|.
name|LEFT_OUTER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_RIGHT_TRANSPOSE} but match outer as well as    * inner join. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
init|=
name|JoinProjectTransposeRule
operator|.
name|Config
operator|.
name|RIGHT_OUTER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches a {@link Join} and pushes down expressions on either    * side of "equal" conditions. */
specifier|public
specifier|static
specifier|final
name|JoinPushExpressionsRule
name|JOIN_PUSH_EXPRESSIONS
init|=
name|JoinPushExpressionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that infers predicates from on a {@link Join} and creates    * {@link Filter}s if those predicates can be pushed to its inputs. */
specifier|public
specifier|static
specifier|final
name|JoinPushTransitivePredicatesRule
name|JOIN_PUSH_TRANSITIVE_PREDICATES
init|=
name|JoinPushTransitivePredicatesRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link Join}.    *    * @see #FILTER_REDUCE_EXPRESSIONS    * @see #PROJECT_REDUCE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|JoinReduceExpressionsRule
name|JOIN_REDUCE_EXPRESSIONS
init|=
name|ReduceExpressionsRule
operator|.
name|JoinReduceExpressionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that converts a {@link LogicalJoin}    * into a {@link LogicalCorrelate}. */
specifier|public
specifier|static
specifier|final
name|JoinToCorrelateRule
name|JOIN_TO_CORRELATE
init|=
name|JoinToCorrelateRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that flattens a tree of {@link LogicalJoin}s    * into a single {@link MultiJoin} with N inputs. */
specifier|public
specifier|static
specifier|final
name|JoinToMultiJoinRule
name|JOIN_TO_MULTI_JOIN
init|=
name|JoinToMultiJoinRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that creates a {@link Join#isSemiJoin semi-join} from a    * {@link Join} with an empty {@link Aggregate} as its right input.    *    * @see #PROJECT_TO_SEMI_JOIN */
specifier|public
specifier|static
specifier|final
name|SemiJoinRule
operator|.
name|JoinToSemiJoinRule
name|JOIN_TO_SEMI_JOIN
init|=
name|SemiJoinRule
operator|.
name|JoinToSemiJoinRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Join}    * past a non-distinct {@link Union} as its left input. */
specifier|public
specifier|static
specifier|final
name|JoinUnionTransposeRule
name|JOIN_LEFT_UNION_TRANSPOSE
init|=
name|JoinUnionTransposeRule
operator|.
name|Config
operator|.
name|LEFT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Join}    * past a non-distinct {@link Union} as its right input. */
specifier|public
specifier|static
specifier|final
name|JoinUnionTransposeRule
name|JOIN_RIGHT_UNION_TRANSPOSE
init|=
name|JoinUnionTransposeRule
operator|.
name|Config
operator|.
name|RIGHT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that re-orders a {@link Join} using a heuristic planner.    *    *<p>It is triggered by the pattern    * {@link LogicalProject} ({@link MultiJoin}).    *    * @see #JOIN_TO_MULTI_JOIN    * @see #MULTI_JOIN_OPTIMIZE_BUSHY */
specifier|public
specifier|static
specifier|final
name|LoptOptimizeJoinRule
name|MULTI_JOIN_OPTIMIZE
init|=
name|LoptOptimizeJoinRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that finds an approximately optimal ordering for join operators    * using a heuristic algorithm and can handle bushy joins.    *    *<p>It is triggered by the pattern    * {@link LogicalProject} ({@link MultiJoin}).    *    * @see #MULTI_JOIN_OPTIMIZE    */
specifier|public
specifier|static
specifier|final
name|MultiJoinOptimizeBushyRule
name|MULTI_JOIN_OPTIMIZE_BUSHY
init|=
name|MultiJoinOptimizeBushyRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches a {@link LogicalJoin} whose inputs are both a    * {@link MultiJoin} with intervening {@link LogicalProject}s,    * and pulls the Projects up above the Join. */
specifier|public
specifier|static
specifier|final
name|MultiJoinProjectTransposeRule
name|MULTI_JOIN_BOTH_PROJECT
init|=
name|MultiJoinProjectTransposeRule
operator|.
name|Config
operator|.
name|BOTH_PROJECT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #MULTI_JOIN_BOTH_PROJECT} but only the left input has    * an intervening Project. */
specifier|public
specifier|static
specifier|final
name|MultiJoinProjectTransposeRule
name|MULTI_JOIN_LEFT_PROJECT
init|=
name|MultiJoinProjectTransposeRule
operator|.
name|Config
operator|.
name|LEFT_PROJECT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #MULTI_JOIN_BOTH_PROJECT} but only the right input has    * an intervening Project. */
specifier|public
specifier|static
specifier|final
name|MultiJoinProjectTransposeRule
name|MULTI_JOIN_RIGHT_PROJECT
init|=
name|MultiJoinProjectTransposeRule
operator|.
name|Config
operator|.
name|RIGHT_PROJECT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Join#isSemiJoin semi-join} down in a tree past    * a {@link Filter}.    *    * @see #SEMI_JOIN_PROJECT_TRANSPOSE    * @see #SEMI_JOIN_JOIN_TRANSPOSE */
specifier|public
specifier|static
specifier|final
name|SemiJoinFilterTransposeRule
name|SEMI_JOIN_FILTER_TRANSPOSE
init|=
name|SemiJoinFilterTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Join#isSemiJoin semi-join} down in a tree past    * a {@link Project}.    *    * @see #SEMI_JOIN_FILTER_TRANSPOSE    * @see #SEMI_JOIN_JOIN_TRANSPOSE */
specifier|public
specifier|static
specifier|final
name|SemiJoinProjectTransposeRule
name|SEMI_JOIN_PROJECT_TRANSPOSE
init|=
name|SemiJoinProjectTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Join#isSemiJoin semi-join} down in a tree past a    * {@link Join}.    *    * @see #SEMI_JOIN_FILTER_TRANSPOSE    * @see #SEMI_JOIN_PROJECT_TRANSPOSE */
specifier|public
specifier|static
specifier|final
name|SemiJoinJoinTransposeRule
name|SEMI_JOIN_JOIN_TRANSPOSE
init|=
name|SemiJoinJoinTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes a {@link Join#isSemiJoin semi-join} from a join tree. */
specifier|public
specifier|static
specifier|final
name|SemiJoinRemoveRule
name|SEMI_JOIN_REMOVE
init|=
name|SemiJoinRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Sort} past a {@link Union}.    *    *<p>This rule instance is for a Union implementation that does not preserve    * the ordering of its inputs. Thus, it makes no sense to match this rule    * if the Sort does not have a limit, i.e., {@link Sort#fetch} is null.    *    * @see #SORT_UNION_TRANSPOSE_MATCH_NULL_FETCH */
specifier|public
specifier|static
specifier|final
name|SortUnionTransposeRule
name|SORT_UNION_TRANSPOSE
init|=
name|SortUnionTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** As {@link #SORT_UNION_TRANSPOSE}, but for a Union implementation that    * preserves the ordering of its inputs. It is still worth applying this rule    * even if the Sort does not have a limit, for the merge of already sorted    * inputs that the Union can do is usually cheap. */
specifier|public
specifier|static
specifier|final
name|SortUnionTransposeRule
name|SORT_UNION_TRANSPOSE_MATCH_NULL_FETCH
init|=
name|SortUnionTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|withMatchNullFetch
argument_list|(
literal|true
argument_list|)
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that copies a {@link Sort} past a {@link Join} without its limit and    * offset. The original {@link Sort} is preserved but can potentially be    * removed by {@link #SORT_REMOVE} if redundant. */
specifier|public
specifier|static
specifier|final
name|SortJoinCopyRule
name|SORT_JOIN_COPY
init|=
name|SortJoinCopyRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes a {@link Sort} if its input is already sorted. */
specifier|public
specifier|static
specifier|final
name|SortRemoveRule
name|SORT_REMOVE
init|=
name|SortRemoveRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes keys from a {@link Sort}    * if those keys are known to be constant, or removes the entire Sort if all    * keys are constant. */
specifier|public
specifier|static
specifier|final
name|SortRemoveConstantKeysRule
name|SORT_REMOVE_CONSTANT_KEYS
init|=
name|SortRemoveConstantKeysRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Sort} past a {@link Join}. */
specifier|public
specifier|static
specifier|final
name|SortJoinTransposeRule
name|SORT_JOIN_TRANSPOSE
init|=
name|SortJoinTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Sort} past a {@link Project}. */
specifier|public
specifier|static
specifier|final
name|SortProjectTransposeRule
name|SORT_PROJECT_TRANSPOSE
init|=
name|SortProjectTransposeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that flattens a {@link Union} on a {@code Union}    * into a single {@code Union}. */
specifier|public
specifier|static
specifier|final
name|UnionMergeRule
name|UNION_MERGE
init|=
name|UnionMergeRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes a {@link Union} if it has only one input.    *    * @see PruneEmptyRules#UNION_INSTANCE */
specifier|public
specifier|static
specifier|final
name|UnionEliminatorRule
name|UNION_REMOVE
init|=
name|UnionEliminatorRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that pulls up constants through a Union operator. */
specifier|public
specifier|static
specifier|final
name|UnionPullUpConstantsRule
name|UNION_PULL_UP_CONSTANTS
init|=
name|UnionPullUpConstantsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that translates a distinct {@link Union}    * (<code>all</code> =<code>false</code>)    * into an {@link Aggregate} on top of a non-distinct {@link Union}    * (<code>all</code> =<code>true</code>). */
specifier|public
specifier|static
specifier|final
name|UnionToDistinctRule
name|UNION_TO_DISTINCT
init|=
name|UnionToDistinctRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that applies an {@link Aggregate} to a {@link Values} (currently just    * an empty {@code Values}). */
specifier|public
specifier|static
specifier|final
name|AggregateValuesRule
name|AGGREGATE_VALUES
init|=
name|AggregateValuesRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that merges a {@link Filter} onto an underlying    * {@link org.apache.calcite.rel.logical.LogicalValues},    * resulting in a {@code Values} with potentially fewer rows. */
specifier|public
specifier|static
specifier|final
name|ValuesReduceRule
name|FILTER_VALUES_MERGE
init|=
name|ValuesReduceRule
operator|.
name|Config
operator|.
name|FILTER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that merges a {@link Project} onto an underlying    * {@link org.apache.calcite.rel.logical.LogicalValues},    * resulting in a {@code Values} with different columns. */
specifier|public
specifier|static
specifier|final
name|ValuesReduceRule
name|PROJECT_VALUES_MERGE
init|=
name|ValuesReduceRule
operator|.
name|Config
operator|.
name|PROJECT
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that merges a {@link Project}    * on top of a {@link Filter} onto an underlying    * {@link org.apache.calcite.rel.logical.LogicalValues},    * resulting in a {@code Values} with different columns    * and potentially fewer rows. */
specifier|public
specifier|static
specifier|final
name|ValuesReduceRule
name|PROJECT_FILTER_VALUES_MERGE
init|=
name|ValuesReduceRule
operator|.
name|Config
operator|.
name|PROJECT_FILTER
operator|.
name|toRule
argument_list|()
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link LogicalWindow}.    *    * @see #FILTER_REDUCE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|WindowReduceExpressionsRule
name|WINDOW_REDUCE_EXPRESSIONS
init|=
name|ReduceExpressionsRule
operator|.
name|WindowReduceExpressionsRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
decl_stmt|;
block|}
end_class

end_unit

