begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableInterpreter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Calc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SetOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCalc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCorrelate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalIntersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalMatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalMinus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalSortExchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalTableFunctionScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalUnion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|materialize
operator|.
name|MaterializedViewRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexOver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|StarTable
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|any
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|none
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|operand
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|operandJ
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
operator|.
name|some
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
operator|.
name|DEFAULT_BLOAT
import|;
end_import

begin_comment
comment|/** Rules that perform logical transformations on relational expressions.  *  * @see MaterializedViewRules */
end_comment

begin_class
specifier|public
class|class
name|CoreRules
block|{
specifier|private
name|CoreRules
parameter_list|()
block|{
block|}
comment|/** Rule that recognizes an {@link Aggregate}    * on top of a {@link Project} and if possible    * aggregates through the Project or removes the Project. */
specifier|public
specifier|static
specifier|final
name|AggregateProjectMergeRule
name|AGGREGATE_PROJECT_MERGE
init|=
operator|new
name|AggregateProjectMergeRule
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|Project
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that removes constant keys from an {@link Aggregate}. */
specifier|public
specifier|static
specifier|final
name|AggregateProjectPullUpConstantsRule
name|AGGREGATE_PROJECT_PULL_UP_CONSTANTS
init|=
operator|new
name|AggregateProjectPullUpConstantsRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalProject
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"AggregateProjectPullUpConstantsRule"
argument_list|)
decl_stmt|;
comment|/** More general form of {@link #AGGREGATE_PROJECT_PULL_UP_CONSTANTS}    * that matches any relational expression. */
specifier|public
specifier|static
specifier|final
name|AggregateProjectPullUpConstantsRule
name|AGGREGATE_ANY_PULL_UP_CONSTANTS
init|=
operator|new
name|AggregateProjectPullUpConstantsRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelNode
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"AggregatePullUpConstantsRule"
argument_list|)
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate} on    * a {@link StarTable.StarTableScan}. */
specifier|public
specifier|static
specifier|final
name|AggregateStarTableRule
name|AGGREGATE_STAR_TABLE
init|=
operator|new
name|AggregateStarTableRule
argument_list|(
name|operandJ
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|Aggregate
operator|::
name|isSimple
argument_list|,
name|some
argument_list|(
name|operand
argument_list|(
name|StarTable
operator|.
name|StarTableScan
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"AggregateStarTableRule"
argument_list|)
decl_stmt|;
comment|/** Variant of {@link #AGGREGATE_STAR_TABLE} that accepts a {@link Project}    * between the {@link Aggregate} and its {@link StarTable.StarTableScan}    * input. */
specifier|public
specifier|static
specifier|final
name|AggregateStarTableRule
name|AGGREGATE_PROJECT_STAR_TABLE
init|=
operator|new
name|AggregateStarTableRule
argument_list|(
name|operandJ
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|Aggregate
operator|::
name|isSimple
argument_list|,
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|StarTable
operator|.
name|StarTableScan
operator|.
name|class
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"AggregateStarTableRule:project"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|StarTable
operator|.
name|StarTableScan
name|scan
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|AggregateProjectMergeRule
operator|.
name|apply
argument_list|(
name|call
argument_list|,
name|aggregate
argument_list|,
name|project
argument_list|)
decl_stmt|;
specifier|final
name|Aggregate
name|aggregate2
decl_stmt|;
specifier|final
name|Project
name|project2
decl_stmt|;
if|if
condition|(
name|rel
operator|instanceof
name|Aggregate
condition|)
block|{
name|project2
operator|=
literal|null
expr_stmt|;
name|aggregate2
operator|=
operator|(
name|Aggregate
operator|)
name|rel
expr_stmt|;
block|}
if|else if
condition|(
name|rel
operator|instanceof
name|Project
condition|)
block|{
name|project2
operator|=
operator|(
name|Project
operator|)
name|rel
expr_stmt|;
name|aggregate2
operator|=
operator|(
name|Aggregate
operator|)
name|project2
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|apply
argument_list|(
name|call
argument_list|,
name|project2
argument_list|,
name|aggregate2
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** Rule that reduces aggregate functions in    * an {@link Aggregate} to simpler forms. */
specifier|public
specifier|static
specifier|final
name|AggregateReduceFunctionsRule
name|AGGREGATE_REDUCE_FUNCTIONS
init|=
operator|new
name|AggregateReduceFunctionsRule
argument_list|(
name|operand
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate} on an {@link Aggregate},    * and merges into a single Aggregate if the top aggregate's group key is a    * subset of the lower aggregate's group key, and the aggregates are    * expansions of rollups. */
specifier|public
specifier|static
specifier|final
name|AggregateMergeRule
name|AGGREGATE_MERGE
init|=
operator|new
name|AggregateMergeRule
argument_list|()
decl_stmt|;
comment|/** Rule that removes an {@link Aggregate}    * if it computes no aggregate functions    * (that is, it is implementing {@code SELECT DISTINCT}),    * or all the aggregate functions are splittable,    * and the underlying relational expression is already distinct. */
specifier|public
specifier|static
specifier|final
name|AggregateRemoveRule
name|AGGREGATE_REMOVE
init|=
operator|new
name|AggregateRemoveRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that expands distinct aggregates    * (such as {@code COUNT(DISTINCT x)}) from a    * {@link Aggregate}.    * This instance operates only on logical expressions. */
specifier|public
specifier|static
specifier|final
name|AggregateExpandDistinctAggregatesRule
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES
init|=
operator|new
name|AggregateExpandDistinctAggregatesRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** As {@link #AGGREGATE_EXPAND_DISTINCT_AGGREGATES} but generates a Join. */
specifier|public
specifier|static
specifier|final
name|AggregateExpandDistinctAggregatesRule
name|AGGREGATE_EXPAND_DISTINCT_AGGREGATES_TO_JOIN
init|=
operator|new
name|AggregateExpandDistinctAggregatesRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
literal|false
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate}    * on a {@link Filter} and transposes them,    * pushing the aggregate below the filter. */
specifier|public
specifier|static
specifier|final
name|AggregateFilterTransposeRule
name|AGGREGATE_FILTER_TRANSPOSE
init|=
operator|new
name|AggregateFilterTransposeRule
argument_list|()
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate}    * on a {@link Join} and removes the left input    * of the join provided that the left input is also a left join if    * possible. */
specifier|public
specifier|static
specifier|final
name|AggregateJoinJoinRemoveRule
name|AGGREGATE_JOIN_JOIN_REMOVE
init|=
operator|new
name|AggregateJoinJoinRemoveRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate}    * on a {@link Join} and removes the join    * provided that the join is a left join or right join and it computes no    * aggregate functions or all the aggregate calls have distinct. */
specifier|public
specifier|static
specifier|final
name|AggregateJoinRemoveRule
name|AGGREGATE_JOIN_REMOVE
init|=
operator|new
name|AggregateJoinRemoveRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes an {@link Aggregate}    * past a {@link Join}. */
specifier|public
specifier|static
specifier|final
name|AggregateJoinTransposeRule
name|AGGREGATE_JOIN_TRANSPOSE
init|=
operator|new
name|AggregateJoinTransposeRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** As {@link #AGGREGATE_JOIN_TRANSPOSE}, but extended to push down aggregate    * functions. */
specifier|public
specifier|static
specifier|final
name|AggregateJoinTransposeRule
name|AGGREGATE_JOIN_TRANSPOSE_EXTENDED
init|=
operator|new
name|AggregateJoinTransposeRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/** Rule that pushes an {@link Aggregate}    * past a non-distinct {@link Union}. */
specifier|public
specifier|static
specifier|final
name|AggregateUnionTransposeRule
name|AGGREGATE_UNION_TRANSPOSE
init|=
operator|new
name|AggregateUnionTransposeRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalUnion
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches an {@link Aggregate} whose input is a {@link Union}    * one of whose inputs is an {@code Aggregate}.    *    *<p>Because it matches {@link RelNode} for each input of {@code Union}, it    * will create O(N ^ 2) matches, which may cost too much during the popMatch    * phase in VolcanoPlanner. If efficiency is a concern, we recommend that you    * use {@link #AGGREGATE_UNION_AGGREGATE_FIRST}    * and {@link #AGGREGATE_UNION_AGGREGATE_SECOND} instead. */
specifier|public
specifier|static
specifier|final
name|AggregateUnionAggregateRule
name|AGGREGATE_UNION_AGGREGATE
init|=
operator|new
name|AggregateUnionAggregateRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalUnion
operator|.
name|class
argument_list|,
name|RelNode
operator|.
name|class
argument_list|,
name|RelNode
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"AggregateUnionAggregateRule"
argument_list|)
decl_stmt|;
comment|/** As {@link #AGGREGATE_UNION_AGGREGATE}, but matches an {@code Aggregate}    * only as the left input of the {@code Union}. */
specifier|public
specifier|static
specifier|final
name|AggregateUnionAggregateRule
name|AGGREGATE_UNION_AGGREGATE_FIRST
init|=
operator|new
name|AggregateUnionAggregateRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalUnion
operator|.
name|class
argument_list|,
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelNode
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"AggregateUnionAggregateRule:first-input-agg"
argument_list|)
decl_stmt|;
comment|/** As {@link #AGGREGATE_UNION_AGGREGATE}, but matches an {@code Aggregate}    * only as the right input of the {@code Union}. */
specifier|public
specifier|static
specifier|final
name|AggregateUnionAggregateRule
name|AGGREGATE_UNION_AGGREGATE_SECOND
init|=
operator|new
name|AggregateUnionAggregateRule
argument_list|(
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|LogicalUnion
operator|.
name|class
argument_list|,
name|RelNode
operator|.
name|class
argument_list|,
name|LogicalAggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"AggregateUnionAggregateRule:second-input-agg"
argument_list|)
decl_stmt|;
comment|/** Rule that converts CASE-style filtered aggregates into true filtered    * aggregates. */
specifier|public
specifier|static
specifier|final
name|AggregateCaseToFilterRule
name|AGGREGATE_CASE_TO_FILTER
init|=
operator|new
name|AggregateCaseToFilterRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|/** Rule that merges a {@link Calc} onto a {@code Calc}. */
specifier|public
specifier|static
specifier|final
name|CalcMergeRule
name|CALC_MERGE
init|=
operator|new
name|CalcMergeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that removes a trivial {@link LogicalCalc}. */
specifier|public
specifier|static
specifier|final
name|CalcRemoveRule
name|CALC_REMOVE
init|=
operator|new
name|CalcRemoveRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that reduces operations on the DECIMAL type, such as casts or    * arithmetic, into operations involving more primitive types such as BIGINT    * and DOUBLE. */
specifier|public
specifier|static
specifier|final
name|ReduceDecimalsRule
name|CALC_REDUCE_DECIMALS
init|=
operator|new
name|ReduceDecimalsRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link LogicalCalc}.    *    * @see #FILTER_REDUCE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|CalcReduceExpressionsRule
name|CALC_REDUCE_EXPRESSIONS
init|=
operator|new
name|ReduceExpressionsRule
operator|.
name|CalcReduceExpressionsRule
argument_list|(
name|LogicalCalc
operator|.
name|class
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that converts a {@link Calc} to a {@link Project} and    * {@link Filter}. */
specifier|public
specifier|static
specifier|final
name|CalcSplitRule
name|CALC_SPLIT
init|=
operator|new
name|CalcSplitRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that transforms a {@link Calc}    * that contains windowed aggregates to a mixture of    * {@link LogicalWindow} and {@code Calc}. */
specifier|public
specifier|static
specifier|final
name|ProjectToWindowRule
operator|.
name|CalcToWindowRule
name|CALC_TO_WINDOW
init|=
operator|new
name|ProjectToWindowRule
operator|.
name|CalcToWindowRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pre-casts inputs to a particular type. This can assist operator    * implementations that impose requirements on their input types. */
specifier|public
specifier|static
specifier|final
name|CoerceInputsRule
name|COERCE_INPUTS
init|=
operator|new
name|CoerceInputsRule
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
literal|false
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that removes constants inside a {@link LogicalExchange}. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
specifier|final
name|ExchangeRemoveConstantKeysRule
name|EXCHANGE_REMOVE_CONSTANT_KEYS
init|=
operator|new
name|ExchangeRemoveConstantKeysRule
argument_list|(
name|LogicalExchange
operator|.
name|class
argument_list|,
literal|"ExchangeRemoveConstantKeysRule"
argument_list|)
decl_stmt|;
comment|/** Rule that removes constants inside a {@link LogicalSortExchange}. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
specifier|final
name|ExchangeRemoveConstantKeysRule
name|SORT_EXCHANGE_REMOVE_CONSTANT_KEYS
init|=
operator|new
name|ExchangeRemoveConstantKeysRule
operator|.
name|SortExchangeRemoveConstantKeysRule
argument_list|(
name|LogicalSortExchange
operator|.
name|class
argument_list|,
literal|"SortExchangeRemoveConstantKeysRule"
argument_list|)
decl_stmt|;
comment|/** Rule that tries to push filter expressions into a join    * condition and into the inputs of the join. */
specifier|public
specifier|static
specifier|final
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
name|FILTER_INTO_JOIN
init|=
operator|new
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
argument_list|(
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
parameter_list|(
name|join
parameter_list|,
name|joinType
parameter_list|,
name|exp
parameter_list|)
lambda|->
literal|true
argument_list|)
decl_stmt|;
comment|/** Dumber version of {@link #FILTER_INTO_JOIN}. Not intended for production    * use, but keeps some tests working for which {@code FILTER_INTO_JOIN} is too    * smart. */
specifier|public
specifier|static
specifier|final
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
name|FILTER_INTO_JOIN_DUMB
init|=
operator|new
name|FilterJoinRule
operator|.
name|FilterIntoJoinRule
argument_list|(
literal|false
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
parameter_list|(
name|join
parameter_list|,
name|joinType
parameter_list|,
name|exp
parameter_list|)
lambda|->
literal|true
argument_list|)
decl_stmt|;
comment|/** Rule that combines two {@link LogicalFilter}s. */
specifier|public
specifier|static
specifier|final
name|FilterMergeRule
name|FILTER_MERGE
init|=
operator|new
name|FilterMergeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that merges a {@link Filter} and a {@link LogicalCalc}. The    * result is a {@link LogicalCalc} whose filter condition is the logical AND    * of the two.    *    * @see #PROJECT_CALC_MERGE */
specifier|public
specifier|static
specifier|final
name|FilterCalcMergeRule
name|FILTER_CALC_MERGE
init|=
operator|new
name|FilterCalcMergeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that converts a {@link LogicalFilter} to a {@link LogicalCalc}.    *    * @see #PROJECT_TO_CALC */
specifier|public
specifier|static
specifier|final
name|FilterToCalcRule
name|FILTER_TO_CALC
init|=
operator|new
name|FilterToCalcRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Filter} past an {@link Aggregate}.    *    * @see #AGGREGATE_FILTER_TRANSPOSE */
specifier|public
specifier|static
specifier|final
name|FilterAggregateTransposeRule
name|FILTER_AGGREGATE_TRANSPOSE
init|=
operator|new
name|FilterAggregateTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** The default instance of    * {@link org.apache.calcite.rel.rules.FilterProjectTransposeRule}.    *    *<p>It does not allow a Filter to be pushed past the Project if    * {@link RexUtil#containsCorrelation there is a correlation condition})    * anywhere in the Filter, since in some cases it can prevent a    * {@link Correlate} from being de-correlated.    */
specifier|public
specifier|static
specifier|final
name|FilterProjectTransposeRule
name|FILTER_PROJECT_TRANSPOSE
init|=
operator|new
name|FilterProjectTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link LogicalFilter}    * past a {@link LogicalTableFunctionScan}. */
specifier|public
specifier|static
specifier|final
name|FilterTableFunctionTransposeRule
name|FILTER_TABLE_FUNCTION_TRANSPOSE
init|=
operator|new
name|FilterTableFunctionTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches a {@link Filter} on a {@link TableScan}. */
specifier|public
specifier|static
specifier|final
name|FilterTableScanRule
name|FILTER_SCAN
init|=
operator|new
name|FilterTableScanRule
argument_list|(
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|operandJ
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|FilterTableScanRule
operator|::
name|test
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"FilterTableScanRule"
argument_list|)
block|{
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|TableScan
name|scan
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|apply
argument_list|(
name|call
argument_list|,
name|filter
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** Rule that matches a {@link Filter} on an    * {@link org.apache.calcite.adapter.enumerable.EnumerableInterpreter} on a    * {@link TableScan}. */
specifier|public
specifier|static
specifier|final
name|FilterTableScanRule
name|FILTER_INTERPRETER_SCAN
init|=
operator|new
name|FilterTableScanRule
argument_list|(
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|EnumerableInterpreter
operator|.
name|class
argument_list|,
name|operandJ
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|FilterTableScanRule
operator|::
name|test
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"FilterTableScanRule:interpreter"
argument_list|)
block|{
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|TableScan
name|scan
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|apply
argument_list|(
name|call
argument_list|,
name|filter
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** Rule that pushes a {@link Filter} above a {@link Correlate} into the    * inputs of the {@code Correlate}. */
specifier|public
specifier|static
specifier|final
name|FilterCorrelateRule
name|FILTER_CORRELATE
init|=
operator|new
name|FilterCorrelateRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that merges a {@link Filter} into a {@link MultiJoin},    * creating a richer {@code MultiJoin}.    *    * @see #PROJECT_MULTI_JOIN_MERGE */
specifier|public
specifier|static
specifier|final
name|FilterMultiJoinMergeRule
name|FILTER_MULTI_JOIN_MERGE
init|=
operator|new
name|FilterMultiJoinMergeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that replaces {@code IS NOT DISTINCT FROM}    * in a {@link Filter} with logically equivalent operations. */
specifier|public
specifier|static
specifier|final
name|FilterRemoveIsNotDistinctFromRule
name|FILTER_EXPAND_IS_NOT_DISTINCT_FROM
init|=
operator|new
name|FilterRemoveIsNotDistinctFromRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Filter} past a {@link SetOp}. */
specifier|public
specifier|static
specifier|final
name|FilterSetOpTransposeRule
name|FILTER_SET_OP_TRANSPOSE
init|=
operator|new
name|FilterSetOpTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link LogicalFilter}.    *    * @see #JOIN_REDUCE_EXPRESSIONS    * @see #PROJECT_REDUCE_EXPRESSIONS    * @see #CALC_REDUCE_EXPRESSIONS    * @see #WINDOW_REDUCE_EXPRESSIONS    */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|FilterReduceExpressionsRule
name|FILTER_REDUCE_EXPRESSIONS
init|=
operator|new
name|ReduceExpressionsRule
operator|.
name|FilterReduceExpressionsRule
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|,
literal|false
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that flattens an {@link Intersect} on an {@code Intersect}    * into a single {@code Intersect}. */
specifier|public
specifier|static
specifier|final
name|UnionMergeRule
name|INTERSECT_MERGE
init|=
operator|new
name|UnionMergeRule
argument_list|(
name|LogicalIntersect
operator|.
name|class
argument_list|,
literal|"IntersectMergeRule"
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that translates a distinct    * {@link Intersect} into a group of operators    * composed of {@link Union}, {@link Aggregate}, etc. */
specifier|public
specifier|static
specifier|final
name|IntersectToDistinctRule
name|INTERSECT_TO_DISTINCT
init|=
operator|new
name|IntersectToDistinctRule
argument_list|(
name|LogicalIntersect
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that converts a {@link LogicalMatch} to the result of calling    * {@link LogicalMatch#copy}. */
specifier|public
specifier|static
specifier|final
name|MatchRule
name|MATCH
init|=
operator|new
name|MatchRule
argument_list|()
decl_stmt|;
comment|/** Rule that flattens a {@link Minus} on a {@code Minus}    * into a single {@code Minus}. */
specifier|public
specifier|static
specifier|final
name|UnionMergeRule
name|MINUS_MERGE
init|=
operator|new
name|UnionMergeRule
argument_list|(
name|LogicalMinus
operator|.
name|class
argument_list|,
literal|"MinusMergeRule"
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that merges a {@link LogicalProject} and a {@link LogicalCalc}.    *    * @see #FILTER_CALC_MERGE */
specifier|public
specifier|static
specifier|final
name|ProjectCalcMergeRule
name|PROJECT_CALC_MERGE
init|=
operator|new
name|ProjectCalcMergeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches a {@link Project} on a {@link Correlate} and    * pushes the projections to the Correlate's left and right inputs. */
specifier|public
specifier|static
specifier|final
name|ProjectCorrelateTransposeRule
name|PROJECT_CORRELATE_TRANSPOSE
init|=
operator|new
name|ProjectCorrelateTransposeRule
argument_list|(
name|expr
lambda|->
operator|!
operator|(
name|expr
operator|instanceof
name|RexOver
operator|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Project} past a {@link Filter}.    *    * @see #PROJECT_FILTER_TRANSPOSE_WHOLE_PROJECT_EXPRESSIONS    * @see #PROJECT_FILTER_TRANSPOSE_WHOLE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ProjectFilterTransposeRule
name|PROJECT_FILTER_TRANSPOSE
init|=
operator|new
name|ProjectFilterTransposeRule
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|LogicalFilter
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|expr
lambda|->
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** As {@link #PROJECT_FILTER_TRANSPOSE}, but pushes down project and filter    * expressions whole, not field references. */
specifier|public
specifier|static
specifier|final
name|ProjectFilterTransposeRule
name|PROJECT_FILTER_TRANSPOSE_WHOLE_EXPRESSIONS
init|=
operator|new
name|ProjectFilterTransposeRule
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|LogicalFilter
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|expr
lambda|->
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/** As {@link #PROJECT_FILTER_TRANSPOSE},    * pushes down field references for filters,    * but pushes down project expressions whole. */
specifier|public
specifier|static
specifier|final
name|ProjectFilterTransposeRule
name|PROJECT_FILTER_TRANSPOSE_WHOLE_PROJECT_EXPRESSIONS
init|=
operator|new
name|ProjectFilterTransposeRule
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|LogicalFilter
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
name|expr
lambda|->
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link LogicalProject}.    *    * @see #FILTER_REDUCE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|ProjectReduceExpressionsRule
name|PROJECT_REDUCE_EXPRESSIONS
init|=
operator|new
name|ReduceExpressionsRule
operator|.
name|ProjectReduceExpressionsRule
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that converts sub-queries from project expressions into    * {@link Correlate} instances.    *    * @see #FILTER_SUB_QUERY_TO_CORRELATE    * @see #JOIN_SUB_QUERY_TO_CORRELATE */
specifier|public
specifier|static
specifier|final
name|SubQueryRemoveRule
name|PROJECT_SUB_QUERY_TO_CORRELATE
init|=
operator|new
name|SubQueryRemoveRule
operator|.
name|SubQueryProjectRemoveRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that converts a sub-queries from filter expressions into    * {@link Correlate} instances.    *    * @see #PROJECT_SUB_QUERY_TO_CORRELATE    * @see #JOIN_SUB_QUERY_TO_CORRELATE */
specifier|public
specifier|static
specifier|final
name|SubQueryRemoveRule
name|FILTER_SUB_QUERY_TO_CORRELATE
init|=
operator|new
name|SubQueryRemoveRule
operator|.
name|SubQueryFilterRemoveRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that converts sub-queries from join expressions into    * {@link Correlate} instances.    *    * @see #PROJECT_SUB_QUERY_TO_CORRELATE    * @see #FILTER_SUB_QUERY_TO_CORRELATE */
specifier|public
specifier|static
specifier|final
name|SubQueryRemoveRule
name|JOIN_SUB_QUERY_TO_CORRELATE
init|=
operator|new
name|SubQueryRemoveRule
operator|.
name|SubQueryJoinRemoveRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that transforms a {@link Project}    *  into a mixture of {@code LogicalProject}    * and {@link LogicalWindow}. */
specifier|public
specifier|static
specifier|final
name|ProjectToWindowRule
operator|.
name|ProjectToLogicalProjectAndWindowRule
name|PROJECT_TO_LOGICAL_PROJECT_AND_WINDOW
init|=
operator|new
name|ProjectToWindowRule
operator|.
name|ProjectToLogicalProjectAndWindowRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that creates a {@link Join#isSemiJoin semi-join} from a    * {@link Project} on top of a {@link Join} with an {@link Aggregate} as its    * right input.    *    * @see #JOIN_TO_SEMI_JOIN */
specifier|public
specifier|static
specifier|final
name|SemiJoinRule
operator|.
name|ProjectToSemiJoinRule
name|PROJECT_TO_SEMI_JOIN
init|=
operator|new
name|SemiJoinRule
operator|.
name|ProjectToSemiJoinRule
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|Join
operator|.
name|class
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"SemiJoinRule:project"
argument_list|)
decl_stmt|;
comment|/** Rule that matches an {@link Project} on a {@link Join} and removes the    * left input of the join provided that the left input is also a left join. */
specifier|public
specifier|static
specifier|final
name|ProjectJoinJoinRemoveRule
name|PROJECT_JOIN_JOIN_REMOVE
init|=
operator|new
name|ProjectJoinJoinRemoveRule
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches an {@link Project} on a {@link Join} and removes the    * join provided that the join is a left join or right join and the join keys    * are unique. */
specifier|public
specifier|static
specifier|final
name|ProjectJoinRemoveRule
name|PROJECT_JOIN_REMOVE
init|=
operator|new
name|ProjectJoinRemoveRule
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link LogicalProject} past a {@link LogicalJoin}    * by splitting the projection into a projection on top of each child of    * the join. */
specifier|public
specifier|static
specifier|final
name|ProjectJoinTransposeRule
name|PROJECT_JOIN_TRANSPOSE
init|=
operator|new
name|ProjectJoinTransposeRule
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|expr
lambda|->
operator|!
operator|(
name|expr
operator|instanceof
name|RexOver
operator|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that merges a {@link Project} into another {@link Project},    * provided the projects are not projecting identical sets of input    * references. */
specifier|public
specifier|static
specifier|final
name|ProjectMergeRule
name|PROJECT_MERGE
init|=
operator|new
name|ProjectMergeRule
argument_list|(
literal|true
argument_list|,
name|DEFAULT_BLOAT
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link LogicalProject} past a {@link SetOp}.    *    *<p>The children of the {@code SetOp} will project    * only the {@link RexInputRef}s referenced in the original    * {@code LogicalProject}. */
specifier|public
specifier|static
specifier|final
name|ProjectSetOpTransposeRule
name|PROJECT_SET_OP_TRANSPOSE
init|=
operator|new
name|ProjectSetOpTransposeRule
argument_list|(
name|expr
lambda|->
operator|!
operator|(
name|expr
operator|instanceof
name|RexOver
operator|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Project} into a {@link MultiJoin},    * creating a richer {@code MultiJoin}.    *    * @see #FILTER_MULTI_JOIN_MERGE */
specifier|public
specifier|static
specifier|final
name|ProjectMultiJoinMergeRule
name|PROJECT_MULTI_JOIN_MERGE
init|=
operator|new
name|ProjectMultiJoinMergeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that, given a {@link Project} node that merely returns its input,    *  converts the node into its input. */
specifier|public
specifier|static
specifier|final
name|ProjectRemoveRule
name|PROJECT_REMOVE
init|=
operator|new
name|ProjectRemoveRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that converts a {@link Project} on a {@link TableScan}    * of a {@link org.apache.calcite.schema.ProjectableFilterableTable}    * to a {@link org.apache.calcite.interpreter.Bindables.BindableTableScan}.    *    * @see #PROJECT_INTERPRETER_TABLE_SCAN */
specifier|public
specifier|static
specifier|final
name|ProjectTableScanRule
name|PROJECT_TABLE_SCAN
init|=
operator|new
name|ProjectTableScanRule
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operandJ
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|ProjectTableScanRule
operator|::
name|test
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"ProjectScanRule"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|TableScan
name|scan
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|apply
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** As {@link #PROJECT_TABLE_SCAN}, but with an intervening    * {@link org.apache.calcite.adapter.enumerable.EnumerableInterpreter}. */
specifier|public
specifier|static
specifier|final
name|ProjectTableScanRule
name|PROJECT_INTERPRETER_TABLE_SCAN
init|=
operator|new
name|ProjectTableScanRule
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|EnumerableInterpreter
operator|.
name|class
argument_list|,
name|operandJ
argument_list|(
name|TableScan
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|ProjectTableScanRule
operator|::
name|test
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"ProjectScanRule:interpreter"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|TableScan
name|scan
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|apply
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** Rule that converts a {@link LogicalProject} to a {@link LogicalCalc}.    *    * @see #FILTER_TO_CALC */
specifier|public
specifier|static
specifier|final
name|ProjectToCalcRule
name|PROJECT_TO_CALC
init|=
operator|new
name|ProjectToCalcRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link LogicalProject} past a {@link LogicalWindow}. */
specifier|public
specifier|static
specifier|final
name|ProjectWindowTransposeRule
name|PROJECT_WINDOW_TRANSPOSE
init|=
operator|new
name|ProjectWindowTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes predicates in a Join into the inputs to the join. */
specifier|public
specifier|static
specifier|final
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
name|JOIN_CONDITION_PUSH
init|=
operator|new
name|FilterJoinRule
operator|.
name|JoinConditionPushRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
parameter_list|(
name|join
parameter_list|,
name|joinType
parameter_list|,
name|exp
parameter_list|)
lambda|->
literal|true
argument_list|)
decl_stmt|;
comment|/** Rule to add a semi-join into a {@link Join}. */
specifier|public
specifier|static
specifier|final
name|JoinAddRedundantSemiJoinRule
name|JOIN_ADD_REDUNDANT_SEMI_JOIN
init|=
operator|new
name|JoinAddRedundantSemiJoinRule
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that changes a join based on the associativity rule,    * ((a JOIN b) JOIN c)&rarr; (a JOIN (b JOIN c)). */
specifier|public
specifier|static
specifier|final
name|JoinAssociateRule
name|JOIN_ASSOCIATE
init|=
operator|new
name|JoinAssociateRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that permutes the inputs to an inner {@link Join}. */
specifier|public
specifier|static
specifier|final
name|JoinCommuteRule
name|JOIN_COMMUTE
init|=
operator|new
name|JoinCommuteRule
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/** As {@link #JOIN_COMMUTE} but swaps outer joins as well as inner joins. */
specifier|public
specifier|static
specifier|final
name|JoinCommuteRule
name|JOIN_COMMUTE_OUTER
init|=
operator|new
name|JoinCommuteRule
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/** Rule to convert an    * {@link LogicalJoin inner join} to a    * {@link LogicalFilter filter} on top of a    * {@link LogicalJoin cartesian inner join}. */
specifier|public
specifier|static
specifier|final
name|JoinExtractFilterRule
name|JOIN_EXTRACT_FILTER
init|=
operator|new
name|JoinExtractFilterRule
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches a {@link LogicalJoin} whose inputs are    * {@link LogicalProject}s, and pulls the project expressions up. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_BOTH_TRANSPOSE
init|=
operator|new
name|JoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"JoinProjectTransposeRule(Project-Project)"
argument_list|)
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_BOTH_TRANSPOSE} but only the left input is    * a {@link LogicalProject}. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_LEFT_TRANSPOSE
init|=
operator|new
name|JoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|some
argument_list|(
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"JoinProjectTransposeRule(Project-Other)"
argument_list|)
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_BOTH_TRANSPOSE} but only the right input is    * a {@link LogicalProject}. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_RIGHT_TRANSPOSE
init|=
operator|new
name|JoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"JoinProjectTransposeRule(Other-Project)"
argument_list|)
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_BOTH_TRANSPOSE} but match outer as well as    * inner join. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_BOTH_TRANSPOSE_INCLUDE_OUTER
init|=
operator|new
name|JoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"Join(IncludingOuter)ProjectTransposeRule(Project-Project)"
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_LEFT_TRANSPOSE} but match outer as well as    * inner join. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_LEFT_TRANSPOSE_INCLUDE_OUTER
init|=
operator|new
name|JoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|some
argument_list|(
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"Join(IncludingOuter)ProjectTransposeRule(Project-Other)"
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** As {@link #JOIN_PROJECT_RIGHT_TRANSPOSE} but match outer as well as    * inner join. */
specifier|public
specifier|static
specifier|final
name|JoinProjectTransposeRule
name|JOIN_PROJECT_RIGHT_TRANSPOSE_INCLUDE_OUTER
init|=
operator|new
name|JoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"Join(IncludingOuter)ProjectTransposeRule(Other-Project)"
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that matches a {@link Join} and pushes down expressions on either    * side of "equal" conditions. */
specifier|public
specifier|static
specifier|final
name|JoinPushExpressionsRule
name|JOIN_PUSH_EXPRESSIONS
init|=
operator|new
name|JoinPushExpressionsRule
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that infers predicates from on a {@link Join} and creates    * {@link Filter}s if those predicates can be pushed to its inputs. */
specifier|public
specifier|static
specifier|final
name|JoinPushTransitivePredicatesRule
name|JOIN_PUSH_TRANSITIVE_PREDICATES
init|=
operator|new
name|JoinPushTransitivePredicatesRule
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link Join}.    *    * @see #FILTER_REDUCE_EXPRESSIONS    * @see #PROJECT_REDUCE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|JoinReduceExpressionsRule
name|JOIN_REDUCE_EXPRESSIONS
init|=
operator|new
name|ReduceExpressionsRule
operator|.
name|JoinReduceExpressionsRule
argument_list|(
name|Join
operator|.
name|class
argument_list|,
literal|false
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that converts a {@link LogicalJoin}    * into a {@link LogicalCorrelate}. */
specifier|public
specifier|static
specifier|final
name|JoinToCorrelateRule
name|JOIN_TO_CORRELATE
init|=
operator|new
name|JoinToCorrelateRule
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"JoinToCorrelateRule"
argument_list|)
decl_stmt|;
comment|/** Rule that flattens a tree of {@link LogicalJoin}s    * into a single {@link MultiJoin} with N inputs. */
specifier|public
specifier|static
specifier|final
name|JoinToMultiJoinRule
name|JOIN_TO_MULTI_JOIN
init|=
operator|new
name|JoinToMultiJoinRule
argument_list|(
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that creates a {@link Join#isSemiJoin semi-join} from a    * {@link Join} with an empty {@link Aggregate} as its right input.    *    * @see #PROJECT_TO_SEMI_JOIN */
specifier|public
specifier|static
specifier|final
name|SemiJoinRule
operator|.
name|JoinToSemiJoinRule
name|JOIN_TO_SEMI_JOIN
init|=
operator|new
name|SemiJoinRule
operator|.
name|JoinToSemiJoinRule
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"SemiJoinRule:join"
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Join}    * past a non-distinct {@link Union} as its left input. */
specifier|public
specifier|static
specifier|final
name|JoinUnionTransposeRule
name|JOIN_LEFT_UNION_TRANSPOSE
init|=
operator|new
name|JoinUnionTransposeRule
argument_list|(
name|operand
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Union
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"JoinUnionTransposeRule(Union-Other)"
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Join}    * past a non-distinct {@link Union} as its right input. */
specifier|public
specifier|static
specifier|final
name|JoinUnionTransposeRule
name|JOIN_RIGHT_UNION_TRANSPOSE
init|=
operator|new
name|JoinUnionTransposeRule
argument_list|(
name|operand
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|Union
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"JoinUnionTransposeRule(Other-Union)"
argument_list|)
decl_stmt|;
comment|/** Rule that re-orders a {@link Join} using a heuristic planner.    *    *<p>It is triggered by the pattern    * {@link LogicalProject} ({@link MultiJoin}).    *    * @see #JOIN_TO_MULTI_JOIN    * @see #MULTI_JOIN_OPTIMIZE_BUSHY */
specifier|public
specifier|static
specifier|final
name|LoptOptimizeJoinRule
name|MULTI_JOIN_OPTIMIZE
init|=
operator|new
name|LoptOptimizeJoinRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that finds an approximately optimal ordering for join operators    * using a heuristic algorithm and can handle bushy joins.    *    *<p>It is triggered by the pattern    * {@link LogicalProject} ({@link MultiJoin}).    *    * @see #MULTI_JOIN_OPTIMIZE    */
specifier|public
specifier|static
specifier|final
name|MultiJoinOptimizeBushyRule
name|MULTI_JOIN_OPTIMIZE_BUSHY
init|=
operator|new
name|MultiJoinOptimizeBushyRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Join#isSemiJoin semi-join} down in a tree past    * a {@link Filter}.    *    * @see #SEMI_JOIN_PROJECT_TRANSPOSE    * @see #SEMI_JOIN_JOIN_TRANSPOSE */
specifier|public
specifier|static
specifier|final
name|SemiJoinFilterTransposeRule
name|SEMI_JOIN_FILTER_TRANSPOSE
init|=
operator|new
name|SemiJoinFilterTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Join#isSemiJoin semi-join} down in a tree past    * a {@link Project}.    *    * @see #SEMI_JOIN_FILTER_TRANSPOSE    * @see #SEMI_JOIN_JOIN_TRANSPOSE */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
specifier|final
name|SemiJoinProjectTransposeRule
name|SEMI_JOIN_PROJECT_TRANSPOSE
init|=
operator|new
name|SemiJoinProjectTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Join#isSemiJoin semi-join} down in a tree past a    * {@link Join}.    *    * @see #SEMI_JOIN_FILTER_TRANSPOSE    * @see #SEMI_JOIN_PROJECT_TRANSPOSE */
specifier|public
specifier|static
specifier|final
name|SemiJoinJoinTransposeRule
name|SEMI_JOIN_JOIN_TRANSPOSE
init|=
operator|new
name|SemiJoinJoinTransposeRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that removes a {@link Join#isSemiJoin semi-join} from a join tree. */
specifier|public
specifier|static
specifier|final
name|SemiJoinRemoveRule
name|SEMI_JOIN_REMOVE
init|=
operator|new
name|SemiJoinRemoveRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Sort} past a {@link Union}.    *    *<p>This rule instance is for a Union implementation that does not preserve    * the ordering of its inputs. Thus, it makes no sense to match this rule    * if the Sort does not have a limit, i.e., {@link Sort#fetch} is null.    *    * @see #SORT_UNION_TRANSPOSE_MATCH_NULL_FETCH */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
specifier|final
name|SortUnionTransposeRule
name|SORT_UNION_TRANSPOSE
init|=
operator|new
name|SortUnionTransposeRule
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/** As {@link #SORT_UNION_TRANSPOSE}, but for a Union implementation that    * preserves the ordering of its inputs. It is still worth applying this rule    * even if the Sort does not have a limit, for the merge of already sorted    * inputs that the Union can do is usually cheap. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
specifier|final
name|SortUnionTransposeRule
name|SORT_UNION_TRANSPOSE_MATCH_NULL_FETCH
init|=
operator|new
name|SortUnionTransposeRule
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/** Rule that copies a {@link Sort} past a {@link Join} without its limit and    * offset. The original {@link Sort} is preserved but can potentially be    * removed by {@link #SORT_REMOVE} if redundant. */
specifier|public
specifier|static
specifier|final
name|SortJoinCopyRule
name|SORT_JOIN_COPY
init|=
operator|new
name|SortJoinCopyRule
argument_list|(
name|LogicalSort
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that removes a {@link Sort} if its input is already sorted. */
specifier|public
specifier|static
specifier|final
name|SortRemoveRule
name|SORT_REMOVE
init|=
operator|new
name|SortRemoveRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that removes keys from a {@link Sort}    * if those keys are known to be constant, or removes the entire Sort if all    * keys are constant. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
specifier|final
name|SortRemoveConstantKeysRule
name|SORT_REMOVE_CONSTANT_KEYS
init|=
operator|new
name|SortRemoveConstantKeysRule
argument_list|()
decl_stmt|;
comment|/** Rule that pushes a {@link Sort} past a {@link Join}. */
specifier|public
specifier|static
specifier|final
name|SortJoinTransposeRule
name|SORT_JOIN_TRANSPOSE
init|=
operator|new
name|SortJoinTransposeRule
argument_list|(
name|LogicalSort
operator|.
name|class
argument_list|,
name|LogicalJoin
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pushes a {@link Sort} past a {@link Project}. */
specifier|public
specifier|static
specifier|final
name|SortProjectTransposeRule
name|SORT_PROJECT_TRANSPOSE
init|=
operator|new
name|SortProjectTransposeRule
argument_list|(
name|Sort
operator|.
name|class
argument_list|,
name|LogicalProject
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|/** Rule that flattens a {@link Union} on a {@code Union}    * into a single {@code Union}. */
specifier|public
specifier|static
specifier|final
name|UnionMergeRule
name|UNION_MERGE
init|=
operator|new
name|UnionMergeRule
argument_list|(
name|LogicalUnion
operator|.
name|class
argument_list|,
literal|"UnionMergeRule"
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that removes a {@link Union} if it has only one input.    *    * @see PruneEmptyRules#UNION_INSTANCE */
specifier|public
specifier|static
specifier|final
name|UnionEliminatorRule
name|UNION_REMOVE
init|=
operator|new
name|UnionEliminatorRule
argument_list|(
name|LogicalUnion
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that pulls up constants through a Union operator. */
specifier|public
specifier|static
specifier|final
name|UnionPullUpConstantsRule
name|UNION_PULL_UP_CONSTANTS
init|=
operator|new
name|UnionPullUpConstantsRule
argument_list|(
name|Union
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that translates a distinct {@link Union}    * (<code>all</code> =<code>false</code>)    * into an {@link Aggregate} on top of a non-distinct {@link Union}    * (<code>all</code> =<code>true</code>). */
specifier|public
specifier|static
specifier|final
name|UnionToDistinctRule
name|UNION_TO_DISTINCT
init|=
operator|new
name|UnionToDistinctRule
argument_list|(
name|LogicalUnion
operator|.
name|class
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that applies an {@link Aggregate} to a {@link Values} (currently just    * an empty {@code Values}). */
specifier|public
specifier|static
specifier|final
name|AggregateValuesRule
name|AGGREGATE_VALUES
init|=
operator|new
name|AggregateValuesRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|/** Rule that merges a {@link Filter} onto an underlying    * {@link org.apache.calcite.rel.logical.LogicalValues},    * resulting in a {@code Values} with potentially fewer rows. */
specifier|public
specifier|static
specifier|final
name|ValuesReduceRule
name|FILTER_VALUES_MERGE
init|=
operator|new
name|ValuesReduceRule
argument_list|(
name|operand
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|,
name|operandJ
argument_list|(
name|LogicalValues
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|Values
operator|::
name|isNotEmpty
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"ValuesReduceRule(Filter)"
argument_list|)
block|{
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|LogicalFilter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|LogicalValues
name|values
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|apply
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** Rule that merges a {@link Project} onto an underlying    * {@link org.apache.calcite.rel.logical.LogicalValues},    * resulting in a {@code Values} with different columns. */
specifier|public
specifier|static
specifier|final
name|ValuesReduceRule
name|PROJECT_VALUES_MERGE
init|=
operator|new
name|ValuesReduceRule
argument_list|(
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|operandJ
argument_list|(
name|LogicalValues
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|Values
operator|::
name|isNotEmpty
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"ValuesReduceRule(Project)"
argument_list|)
block|{
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|LogicalProject
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|LogicalValues
name|values
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|apply
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
literal|null
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** Rule that merges a {@link Project}    * on top of a {@link Filter} onto an underlying    * {@link org.apache.calcite.rel.logical.LogicalValues},    * resulting in a {@code Values} with different columns    * and potentially fewer rows. */
specifier|public
specifier|static
specifier|final
name|ValuesReduceRule
name|PROJECT_FILTER_VALUES_MERGE
init|=
operator|new
name|ValuesReduceRule
argument_list|(
name|operand
argument_list|(
name|LogicalProject
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|LogicalFilter
operator|.
name|class
argument_list|,
name|operandJ
argument_list|(
name|LogicalValues
operator|.
name|class
argument_list|,
literal|null
argument_list|,
name|Values
operator|::
name|isNotEmpty
argument_list|,
name|none
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|"ValuesReduceRule(Project-Filter)"
argument_list|)
block|{
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|LogicalProject
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|LogicalFilter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|LogicalValues
name|values
init|=
name|call
operator|.
name|rel
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|apply
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|filter
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** Rule that reduces constants inside a {@link LogicalWindow}.    *    * @see #FILTER_REDUCE_EXPRESSIONS */
specifier|public
specifier|static
specifier|final
name|ReduceExpressionsRule
operator|.
name|WindowReduceExpressionsRule
name|WINDOW_REDUCE_EXPRESSIONS
init|=
operator|new
name|ReduceExpressionsRule
operator|.
name|WindowReduceExpressionsRule
argument_list|(
name|LogicalWindow
operator|.
name|class
argument_list|,
literal|true
argument_list|,
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
block|}
end_class

end_unit

