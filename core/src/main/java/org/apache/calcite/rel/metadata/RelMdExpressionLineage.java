begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepRelVertex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|RelSubset
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Calc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Exchange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BuiltInMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|KeyFor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * Default implementation of  * {@link RelMetadataQuery#getExpressionLineage} for the standard logical  * algebra.  *  *<p>The goal of this provider is to infer the lineage for the given expression.  *  *<p>The output expressions might contain references to columns produced by  * {@link TableScan} operators ({@link RexTableInputRef}). In turn, each  * TableScan operator is identified uniquely by a {@link RelTableRef} containing  * its qualified name and an identifier.  *  *<p>If the lineage cannot be inferred, we return null.  */
end_comment

begin_class
specifier|public
class|class
name|RelMdExpressionLineage
implements|implements
name|MetadataHandler
argument_list|<
name|BuiltInMetadata
operator|.
name|ExpressionLineage
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|RelMetadataProvider
name|SOURCE
init|=
name|ReflectiveRelMetadataProvider
operator|.
name|reflectiveSource
argument_list|(
name|BuiltInMethod
operator|.
name|EXPRESSION_LINEAGE
operator|.
name|method
argument_list|,
operator|new
name|RelMdExpressionLineage
argument_list|()
argument_list|)
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
specifier|protected
name|RelMdExpressionLineage
parameter_list|()
block|{
block|}
comment|//~ Methods ----------------------------------------------------------------
annotation|@
name|Override
specifier|public
name|MetadataDef
argument_list|<
name|BuiltInMetadata
operator|.
name|ExpressionLineage
argument_list|>
name|getDef
parameter_list|()
block|{
return|return
name|BuiltInMetadata
operator|.
name|ExpressionLineage
operator|.
name|DEF
return|;
block|}
comment|// Catch-all rule when none of the others apply.
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|HepRelVertex
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
return|return
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
operator|.
name|getCurrentRel
argument_list|()
argument_list|,
name|outputExpression
argument_list|)
return|;
block|}
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|RelSubset
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
name|RelNode
name|bestOrOriginal
init|=
name|Util
operator|.
name|first
argument_list|(
name|rel
operator|.
name|getBest
argument_list|()
argument_list|,
name|rel
operator|.
name|getOriginal
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bestOrOriginal
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|bestOrOriginal
argument_list|,
name|outputExpression
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from {@link TableScan}.    *    *<p>We extract the fields referenced by the expression and we express them    * using {@link RexTableInputRef}.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|TableScan
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Extract input fields referenced by expression
specifier|final
name|ImmutableBitSet
name|inputFieldsUsed
init|=
name|extractInputRefs
argument_list|(
name|outputExpression
argument_list|)
decl_stmt|;
comment|// Infer column origin expressions for given references
specifier|final
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
range|:
name|inputFieldsUsed
control|)
block|{
specifier|final
name|RexNode
name|inputRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|RelTableRef
operator|.
name|of
argument_list|(
name|rel
operator|.
name|getTable
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|inputRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Return result
return|return
name|createAllPossibleExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|outputExpression
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from {@link Aggregate}.    *    *<p>If the expression references grouping sets or aggregate function    * results, we cannot extract the lineage and we return null.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|Aggregate
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
specifier|final
name|RelNode
name|input
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Extract input fields referenced by expression
specifier|final
name|ImmutableBitSet
name|inputFieldsUsed
init|=
name|extractInputRefs
argument_list|(
name|outputExpression
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
range|:
name|inputFieldsUsed
control|)
block|{
if|if
condition|(
name|idx
operator|>=
name|rel
operator|.
name|getGroupCount
argument_list|()
condition|)
block|{
comment|// We cannot map origin of this expression.
return|return
literal|null
return|;
block|}
block|}
comment|// Infer column origin expressions for given references
specifier|final
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
range|:
name|inputFieldsUsed
control|)
block|{
specifier|final
name|RexInputRef
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|rel
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|idx
argument_list|)
argument_list|,
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|originalExprs
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|input
argument_list|,
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalExprs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
specifier|final
name|RexInputRef
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|originalExprs
argument_list|)
expr_stmt|;
block|}
comment|// Return result
return|return
name|createAllPossibleExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|outputExpression
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from {@link Join}.    *    *<p>We only extract the lineage for INNER joins.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|Join
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|leftInput
init|=
name|rel
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|rightInput
init|=
name|rel
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nLeftColumns
init|=
name|leftInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Extract input fields referenced by expression
specifier|final
name|ImmutableBitSet
name|inputFieldsUsed
init|=
name|extractInputRefs
argument_list|(
name|outputExpression
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel
operator|.
name|getJoinType
argument_list|()
operator|.
name|isOuterJoin
argument_list|()
condition|)
block|{
comment|// If we reference the inner side, we will bail out
if|if
condition|(
name|rel
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|LEFT
condition|)
block|{
name|ImmutableBitSet
name|rightFields
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nLeftColumns
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputFieldsUsed
operator|.
name|intersects
argument_list|(
name|rightFields
argument_list|)
condition|)
block|{
comment|// We cannot map origin of this expression.
return|return
literal|null
return|;
block|}
block|}
if|else if
condition|(
name|rel
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|RIGHT
condition|)
block|{
name|ImmutableBitSet
name|leftFields
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|nLeftColumns
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputFieldsUsed
operator|.
name|intersects
argument_list|(
name|leftFields
argument_list|)
condition|)
block|{
comment|// We cannot map origin of this expression.
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
comment|// We cannot map origin of this expression.
return|return
literal|null
return|;
block|}
block|}
comment|// Gather table references
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|leftTableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|leftInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftTableRefs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|rightTableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|rightInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightTableRefs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
specifier|final
name|Multimap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelTableRef
argument_list|>
name|qualifiedNamesToRefs
init|=
name|HashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|currentTablesMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|leftRef
range|:
name|leftTableRefs
control|)
block|{
name|qualifiedNamesToRefs
operator|.
name|put
argument_list|(
name|leftRef
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|leftRef
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RelTableRef
name|rightRef
range|:
name|rightTableRefs
control|)
block|{
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|RelTableRef
argument_list|>
name|lRefs
init|=
name|qualifiedNamesToRefs
operator|.
name|get
argument_list|(
name|rightRef
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lRefs
operator|!=
literal|null
condition|)
block|{
name|shift
operator|=
name|lRefs
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|currentTablesMapping
operator|.
name|put
argument_list|(
name|rightRef
argument_list|,
name|RelTableRef
operator|.
name|of
argument_list|(
name|rightRef
operator|.
name|getTable
argument_list|()
argument_list|,
name|shift
operator|+
name|rightRef
operator|.
name|getEntityNumber
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Infer column origin expressions for given references
specifier|final
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
range|:
name|inputFieldsUsed
control|)
block|{
if|if
condition|(
name|idx
operator|<
name|nLeftColumns
condition|)
block|{
specifier|final
name|RexInputRef
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|leftInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|originalExprs
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|leftInput
argument_list|,
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalExprs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// Left input references remain unchanged
name|mapping
operator|.
name|put
argument_list|(
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|,
name|originalExprs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Right input.
specifier|final
name|RexInputRef
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
operator|-
name|nLeftColumns
argument_list|,
name|rightInput
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|originalExprs
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rightInput
argument_list|,
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalExprs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// Right input references might need to be updated if there are
comment|// table names clashes with left input
specifier|final
name|RelDataType
name|fullRowType
init|=
name|SqlValidatorUtil
operator|.
name|createJoinType
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|rel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|rel
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|updatedExprs
init|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|Util
operator|.
name|transform
argument_list|(
name|originalExprs
argument_list|,
name|e
lambda|->
name|RexUtil
operator|.
name|swapTableReferences
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|,
name|currentTablesMapping
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|fullRowType
argument_list|)
argument_list|,
name|updatedExprs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Return result
return|return
name|createAllPossibleExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|outputExpression
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from {@link Union}.    *    *<p>For Union operator, we might be able to extract multiple origins for the    * references in the given expression.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|Union
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Extract input fields referenced by expression
specifier|final
name|ImmutableBitSet
name|inputFieldsUsed
init|=
name|extractInputRefs
argument_list|(
name|outputExpression
argument_list|)
decl_stmt|;
comment|// Infer column origin expressions for given references
specifier|final
name|Multimap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelTableRef
argument_list|>
name|qualifiedNamesToRefs
init|=
name|HashMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|rel
operator|.
name|getInputs
argument_list|()
control|)
block|{
comment|// Gather table references
specifier|final
name|Map
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|currentTablesMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|tableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableRefs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
for|for
control|(
name|RelTableRef
name|tableRef
range|:
name|tableRefs
control|)
block|{
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|RelTableRef
argument_list|>
name|lRefs
init|=
name|qualifiedNamesToRefs
operator|.
name|get
argument_list|(
name|tableRef
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lRefs
operator|!=
literal|null
condition|)
block|{
name|shift
operator|=
name|lRefs
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|currentTablesMapping
operator|.
name|put
argument_list|(
name|tableRef
argument_list|,
name|RelTableRef
operator|.
name|of
argument_list|(
name|tableRef
operator|.
name|getTable
argument_list|()
argument_list|,
name|shift
operator|+
name|tableRef
operator|.
name|getEntityNumber
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Map references
for|for
control|(
name|int
name|idx
range|:
name|inputFieldsUsed
control|)
block|{
specifier|final
name|RexInputRef
name|inputRef
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|originalExprs
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|input
argument_list|,
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalExprs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// References might need to be updated
specifier|final
name|RexInputRef
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|updatedExprs
init|=
name|originalExprs
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|e
lambda|->
name|RexUtil
operator|.
name|swapTableReferences
argument_list|(
name|rexBuilder
argument_list|,
name|e
argument_list|,
name|currentTablesMapping
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toSet
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|set
init|=
name|mapping
operator|.
name|get
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|!=
literal|null
condition|)
block|{
name|set
operator|.
name|addAll
argument_list|(
name|updatedExprs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mapping
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|updatedExprs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add to existing qualified names
for|for
control|(
name|RelTableRef
name|newRef
range|:
name|currentTablesMapping
operator|.
name|values
argument_list|()
control|)
block|{
name|qualifiedNamesToRefs
operator|.
name|put
argument_list|(
name|newRef
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|newRef
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Return result
return|return
name|createAllPossibleExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|outputExpression
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from Project.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|Project
name|rel
parameter_list|,
specifier|final
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
specifier|final
name|RelNode
name|input
init|=
name|rel
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Extract input fields referenced by expression
specifier|final
name|ImmutableBitSet
name|inputFieldsUsed
init|=
name|extractInputRefs
argument_list|(
name|outputExpression
argument_list|)
decl_stmt|;
comment|// Infer column origin expressions for given references
specifier|final
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
range|:
name|inputFieldsUsed
control|)
block|{
specifier|final
name|RexNode
name|inputExpr
init|=
name|rel
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|originalExprs
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|input
argument_list|,
name|inputExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalExprs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
specifier|final
name|RexInputRef
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|originalExprs
argument_list|)
expr_stmt|;
block|}
comment|// Return result
return|return
name|createAllPossibleExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|outputExpression
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from Filter.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|Filter
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
return|return
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
operator|.
name|getInput
argument_list|()
argument_list|,
name|outputExpression
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from Sort.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|Sort
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
return|return
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
operator|.
name|getInput
argument_list|()
argument_list|,
name|outputExpression
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from TableModify.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|TableModify
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
return|return
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
operator|.
name|getInput
argument_list|()
argument_list|,
name|outputExpression
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from Exchange.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|Exchange
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
return|return
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|rel
operator|.
name|getInput
argument_list|()
argument_list|,
name|outputExpression
argument_list|)
return|;
block|}
comment|/**    * Expression lineage from Calc.    */
specifier|public
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|Calc
name|calc
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|outputExpression
parameter_list|)
block|{
specifier|final
name|RelNode
name|input
init|=
name|calc
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|calc
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
comment|// Extract input fields referenced by expression
specifier|final
name|ImmutableBitSet
name|inputFieldsUsed
init|=
name|extractInputRefs
argument_list|(
name|outputExpression
argument_list|)
decl_stmt|;
comment|// Infer column origin expressions for given references
specifier|final
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Pair
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|calcProjectsAndFilter
init|=
name|calc
operator|.
name|getProgram
argument_list|()
operator|.
name|split
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
range|:
name|inputFieldsUsed
control|)
block|{
specifier|final
name|RexNode
name|inputExpr
init|=
name|calcProjectsAndFilter
operator|.
name|getKey
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|originalExprs
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|input
argument_list|,
name|inputExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalExprs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
specifier|final
name|RexInputRef
name|ref
init|=
name|RexInputRef
operator|.
name|of
argument_list|(
name|idx
argument_list|,
name|calc
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|ref
argument_list|,
name|originalExprs
argument_list|)
expr_stmt|;
block|}
comment|// Return result
return|return
name|createAllPossibleExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|outputExpression
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Given an expression, it will create all equivalent expressions resulting    * from replacing all possible combinations of references in the mapping by    * the corresponding expressions.    *    * @param rexBuilder rexBuilder    * @param expr expression    * @param mapping mapping    * @return set of resulting expressions equivalent to the input expression    */
specifier|protected
specifier|static
annotation|@
name|Nullable
name|Set
argument_list|<
name|RexNode
argument_list|>
name|createAllPossibleExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|expr
parameter_list|,
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
parameter_list|)
block|{
comment|// Extract input fields referenced by expression
specifier|final
name|ImmutableBitSet
name|predFieldsUsed
init|=
name|extractInputRefs
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|predFieldsUsed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// The unique expression is the input expression
return|return
name|ImmutableSet
operator|.
name|of
argument_list|(
name|expr
argument_list|)
return|;
block|}
try|try
block|{
return|return
name|createAllPossibleExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|predFieldsUsed
argument_list|,
name|mapping
argument_list|,
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// There may be a RexNode unsupported by RexCopier, just return null
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|RexNode
argument_list|>
name|createAllPossibleExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|expr
parameter_list|,
name|ImmutableBitSet
name|predFieldsUsed
parameter_list|,
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
parameter_list|,
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|RexNode
argument_list|>
name|singleMapping
parameter_list|)
block|{
specifier|final
annotation|@
name|KeyFor
argument_list|(
literal|"mapping"
argument_list|)
name|RexInputRef
name|inputRef
init|=
name|mapping
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|replacements
init|=
name|requireNonNull
argument_list|(
name|mapping
operator|.
name|remove
argument_list|(
name|inputRef
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"mapping.remove(inputRef) is null for "
operator|+
name|inputRef
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RexNode
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|replacements
operator|.
name|isEmpty
argument_list|()
assert|;
if|if
condition|(
name|predFieldsUsed
operator|.
name|indexOf
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|RexNode
name|replacement
range|:
name|replacements
control|)
block|{
name|singleMapping
operator|.
name|put
argument_list|(
name|inputRef
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|createExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|predFieldsUsed
argument_list|,
name|mapping
argument_list|,
name|singleMapping
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|singleMapping
operator|.
name|remove
argument_list|(
name|inputRef
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|createExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|predFieldsUsed
argument_list|,
name|mapping
argument_list|,
name|singleMapping
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|mapping
operator|.
name|put
argument_list|(
name|inputRef
argument_list|,
name|replacements
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|void
name|createExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|expr
parameter_list|,
name|ImmutableBitSet
name|predFieldsUsed
parameter_list|,
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|mapping
parameter_list|,
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|RexNode
argument_list|>
name|singleMapping
parameter_list|,
name|Set
argument_list|<
name|RexNode
argument_list|>
name|result
parameter_list|)
block|{
if|if
condition|(
name|mapping
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|RexReplacer
name|replacer
init|=
operator|new
name|RexReplacer
argument_list|(
name|singleMapping
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|updatedPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|rexBuilder
operator|.
name|copy
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|replacer
operator|.
name|mutate
argument_list|(
name|updatedPreds
argument_list|)
expr_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|updatedPreds
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|addAll
argument_list|(
name|createAllPossibleExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|predFieldsUsed
argument_list|,
name|mapping
argument_list|,
name|singleMapping
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Replaces expressions with their equivalences. Note that we only have to    * look for RexInputRef.    */
specifier|private
specifier|static
class|class
name|RexReplacer
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|RexNode
argument_list|>
name|replacementValues
decl_stmt|;
name|RexReplacer
parameter_list|(
name|Map
argument_list|<
name|RexInputRef
argument_list|,
name|RexNode
argument_list|>
name|replacementValues
parameter_list|)
block|{
name|this
operator|.
name|replacementValues
operator|=
name|replacementValues
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
return|return
name|requireNonNull
argument_list|(
name|replacementValues
operator|.
name|get
argument_list|(
name|inputRef
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"no replacement found for inputRef "
operator|+
name|inputRef
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|ImmutableBitSet
name|extractInputRefs
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputExtraFields
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|inputExtraFields
argument_list|)
decl_stmt|;
name|expr
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
return|return
name|inputFinder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
end_class

end_unit

