begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelDistribution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Proxy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * RelMetadataQuery provides a strongly-typed facade on top of  * {@link RelMetadataProvider} for the set of relational expression metadata  * queries defined as standard within Calcite. The Javadoc on these methods  * serves as their primary specification.  *  *<p>To add a new standard query<code>Xyz</code> to this interface, follow  * these steps:  *  *<ol>  *<li>Add a static method<code>getXyz</code> specification to this class.  *<li>Add unit tests to {@code org.apache.calcite.test.RelMetadataTest}.  *<li>Write a new provider class<code>RelMdXyz</code> in this package. Follow  * the pattern from an existing class such as {@link RelMdColumnOrigins},  * overloading on all of the logical relational expressions to which the query  * applies.  *<li>Add a {@code SOURCE} static member, similar to  *     {@link RelMdColumnOrigins#SOURCE}.  *<li>Register the {@code SOURCE} object in {@link DefaultRelMetadataProvider}.  *<li>Get unit tests working.  *</ol>  *  *<p>Because relational expression metadata is extensible, extension projects  * can define similar facades in order to specify access to custom metadata.  * Please do not add queries here (nor on {@link RelNode}) which lack meaning  * outside of your extension.  *  *<p>Besides adding new metadata queries, extension projects may need to add  * custom providers for the standard queries in order to handle additional  * relational expressions (either logical or physical). In either case, the  * process is the same: write a reflective provider and chain it on to an  * instance of {@link DefaultRelMetadataProvider}, pre-pending it to the default  * providers. Then supply that instance to the planner via the appropriate  * plugin mechanism.  */
end_comment

begin_class
specifier|public
class|class
name|RelMetadataQuery
block|{
comment|/** Set of active metadata queries, and cache of previous results. */
specifier|public
specifier|final
name|Map
argument_list|<
name|List
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|JaninoRelMetadataProvider
name|metadataProvider
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|RelMetadataQuery
name|EMPTY
init|=
operator|new
name|RelMetadataQuery
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|Collation
operator|.
name|Handler
name|collationHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|ColumnOrigin
operator|.
name|Handler
name|columnOriginHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|ExpressionLineage
operator|.
name|Handler
name|expressionLineageHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|TableReferences
operator|.
name|Handler
name|tableReferencesHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|ColumnUniqueness
operator|.
name|Handler
name|columnUniquenessHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|CumulativeCost
operator|.
name|Handler
name|cumulativeCostHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|DistinctRowCount
operator|.
name|Handler
name|distinctRowCountHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|Distribution
operator|.
name|Handler
name|distributionHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|ExplainVisibility
operator|.
name|Handler
name|explainVisibilityHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|MaxRowCount
operator|.
name|Handler
name|maxRowCountHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|MinRowCount
operator|.
name|Handler
name|minRowCountHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|Memory
operator|.
name|Handler
name|memoryHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|NonCumulativeCost
operator|.
name|Handler
name|nonCumulativeCostHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|Parallelism
operator|.
name|Handler
name|parallelismHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|PercentageOriginalRows
operator|.
name|Handler
name|percentageOriginalRowsHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|PopulationSize
operator|.
name|Handler
name|populationSizeHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|Predicates
operator|.
name|Handler
name|predicatesHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|AllPredicates
operator|.
name|Handler
name|allPredicatesHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|NodeTypes
operator|.
name|Handler
name|nodeTypesHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|RowCount
operator|.
name|Handler
name|rowCountHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|Selectivity
operator|.
name|Handler
name|selectivityHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|Size
operator|.
name|Handler
name|sizeHandler
decl_stmt|;
specifier|private
name|BuiltInMetadata
operator|.
name|UniqueKeys
operator|.
name|Handler
name|uniqueKeysHandler
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|JaninoRelMetadataProvider
argument_list|>
name|THREAD_PROVIDERS
init|=
operator|new
name|ThreadLocal
argument_list|<
name|JaninoRelMetadataProvider
argument_list|>
argument_list|()
block|{
specifier|protected
name|JaninoRelMetadataProvider
name|initialValue
parameter_list|()
block|{
return|return
name|JaninoRelMetadataProvider
operator|.
name|DEFAULT
return|;
block|}
block|}
decl_stmt|;
specifier|protected
name|RelMetadataQuery
parameter_list|(
name|JaninoRelMetadataProvider
name|metadataProvider
parameter_list|,
name|RelMetadataQuery
name|prototype
parameter_list|)
block|{
name|this
operator|.
name|metadataProvider
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|metadataProvider
argument_list|)
expr_stmt|;
name|this
operator|.
name|collationHandler
operator|=
name|prototype
operator|.
name|collationHandler
expr_stmt|;
name|this
operator|.
name|columnOriginHandler
operator|=
name|prototype
operator|.
name|columnOriginHandler
expr_stmt|;
name|this
operator|.
name|expressionLineageHandler
operator|=
name|prototype
operator|.
name|expressionLineageHandler
expr_stmt|;
name|this
operator|.
name|tableReferencesHandler
operator|=
name|prototype
operator|.
name|tableReferencesHandler
expr_stmt|;
name|this
operator|.
name|columnUniquenessHandler
operator|=
name|prototype
operator|.
name|columnUniquenessHandler
expr_stmt|;
name|this
operator|.
name|cumulativeCostHandler
operator|=
name|prototype
operator|.
name|cumulativeCostHandler
expr_stmt|;
name|this
operator|.
name|distinctRowCountHandler
operator|=
name|prototype
operator|.
name|distinctRowCountHandler
expr_stmt|;
name|this
operator|.
name|distributionHandler
operator|=
name|prototype
operator|.
name|distributionHandler
expr_stmt|;
name|this
operator|.
name|explainVisibilityHandler
operator|=
name|prototype
operator|.
name|explainVisibilityHandler
expr_stmt|;
name|this
operator|.
name|maxRowCountHandler
operator|=
name|prototype
operator|.
name|maxRowCountHandler
expr_stmt|;
name|this
operator|.
name|minRowCountHandler
operator|=
name|prototype
operator|.
name|minRowCountHandler
expr_stmt|;
name|this
operator|.
name|memoryHandler
operator|=
name|prototype
operator|.
name|memoryHandler
expr_stmt|;
name|this
operator|.
name|nonCumulativeCostHandler
operator|=
name|prototype
operator|.
name|nonCumulativeCostHandler
expr_stmt|;
name|this
operator|.
name|parallelismHandler
operator|=
name|prototype
operator|.
name|parallelismHandler
expr_stmt|;
name|this
operator|.
name|percentageOriginalRowsHandler
operator|=
name|prototype
operator|.
name|percentageOriginalRowsHandler
expr_stmt|;
name|this
operator|.
name|populationSizeHandler
operator|=
name|prototype
operator|.
name|populationSizeHandler
expr_stmt|;
name|this
operator|.
name|predicatesHandler
operator|=
name|prototype
operator|.
name|predicatesHandler
expr_stmt|;
name|this
operator|.
name|allPredicatesHandler
operator|=
name|prototype
operator|.
name|allPredicatesHandler
expr_stmt|;
name|this
operator|.
name|nodeTypesHandler
operator|=
name|prototype
operator|.
name|nodeTypesHandler
expr_stmt|;
name|this
operator|.
name|rowCountHandler
operator|=
name|prototype
operator|.
name|rowCountHandler
expr_stmt|;
name|this
operator|.
name|selectivityHandler
operator|=
name|prototype
operator|.
name|selectivityHandler
expr_stmt|;
name|this
operator|.
name|sizeHandler
operator|=
name|prototype
operator|.
name|sizeHandler
expr_stmt|;
name|this
operator|.
name|uniqueKeysHandler
operator|=
name|prototype
operator|.
name|uniqueKeysHandler
expr_stmt|;
block|}
specifier|protected
specifier|static
parameter_list|<
name|H
parameter_list|>
name|H
name|initialHandler
parameter_list|(
name|Class
argument_list|<
name|H
argument_list|>
name|handlerClass
parameter_list|)
block|{
return|return
name|handlerClass
operator|.
name|cast
argument_list|(
name|Proxy
operator|.
name|newProxyInstance
argument_list|(
name|RelMetadataQuery
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|,
operator|new
name|Class
index|[]
block|{
name|handlerClass
block|}
argument_list|,
operator|new
name|InvocationHandler
argument_list|()
block|{
specifier|public
name|Object
name|invoke
parameter_list|(
name|Object
name|proxy
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
specifier|final
name|RelNode
name|r
init|=
operator|(
name|RelNode
operator|)
name|args
index|[
literal|0
index|]
decl_stmt|;
throw|throw
operator|new
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
argument_list|(
name|r
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
block|}
argument_list|)
argument_list|)
return|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns an instance of RelMetadataQuery. It ensures that cycles do not    * occur while computing metadata.    */
specifier|public
specifier|static
name|RelMetadataQuery
name|instance
parameter_list|()
block|{
return|return
operator|new
name|RelMetadataQuery
argument_list|(
name|THREAD_PROVIDERS
operator|.
name|get
argument_list|()
argument_list|,
name|EMPTY
argument_list|)
return|;
block|}
comment|/** Creates and initializes the instance that will serve as a prototype for    * all other instances. */
specifier|private
name|RelMetadataQuery
parameter_list|(
name|boolean
name|dummy
parameter_list|)
block|{
name|this
operator|.
name|metadataProvider
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|collationHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|Collation
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|columnOriginHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|ColumnOrigin
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|expressionLineageHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|ExpressionLineage
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableReferencesHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|TableReferences
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|columnUniquenessHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|ColumnUniqueness
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|cumulativeCostHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|CumulativeCost
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|distinctRowCountHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|DistinctRowCount
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|distributionHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|Distribution
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|explainVisibilityHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|ExplainVisibility
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRowCountHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|MaxRowCount
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|minRowCountHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|MinRowCount
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|memoryHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|Memory
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|nonCumulativeCostHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|NonCumulativeCost
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|parallelismHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|Parallelism
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|percentageOriginalRowsHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|PercentageOriginalRows
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|populationSizeHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|PopulationSize
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|predicatesHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|Predicates
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|allPredicatesHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|AllPredicates
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeTypesHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|NodeTypes
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|rowCountHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|RowCount
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|selectivityHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|Selectivity
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|sizeHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|Size
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|uniqueKeysHandler
operator|=
name|initialHandler
argument_list|(
name|BuiltInMetadata
operator|.
name|UniqueKeys
operator|.
name|Handler
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/** Re-generates the handler for a given kind of metadata, adding support for    * {@code class_} if it is not already present. */
specifier|protected
parameter_list|<
name|M
extends|extends
name|Metadata
parameter_list|,
name|H
extends|extends
name|MetadataHandler
argument_list|<
name|M
argument_list|>
parameter_list|>
name|H
name|revise
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|class_
parameter_list|,
name|MetadataDef
argument_list|<
name|M
argument_list|>
name|def
parameter_list|)
block|{
return|return
name|metadataProvider
operator|.
name|revise
argument_list|(
name|class_
argument_list|,
name|def
argument_list|)
return|;
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.NodeTypes#getNodeTypes()}    * statistic.    *    * @param rel the relational expression    */
specifier|public
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|getNodeTypes
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|nodeTypesHandler
operator|.
name|getNodeTypes
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|nodeTypesHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|NodeTypes
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.RowCount#getRowCount()}    * statistic.    *    * @param rel the relational expression    * @return estimated row count, or null if no reliable estimate can be    * determined    */
specifier|public
name|Double
name|getRowCount
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
name|Double
name|result
init|=
name|rowCountHandler
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
decl_stmt|;
return|return
name|validateResult
argument_list|(
name|result
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|rowCountHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|RowCount
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.MaxRowCount#getMaxRowCount()}    * statistic.    *    * @param rel the relational expression    * @return max row count    */
specifier|public
name|Double
name|getMaxRowCount
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|maxRowCountHandler
operator|.
name|getMaxRowCount
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|maxRowCountHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|MaxRowCount
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.MinRowCount#getMinRowCount()}    * statistic.    *    * @param rel the relational expression    * @return max row count    */
specifier|public
name|Double
name|getMinRowCount
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|minRowCountHandler
operator|.
name|getMinRowCount
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|minRowCountHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|MinRowCount
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.CumulativeCost#getCumulativeCost()}    * statistic.    *    * @param rel the relational expression    * @return estimated cost, or null if no reliable estimate can be determined    */
specifier|public
name|RelOptCost
name|getCumulativeCost
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|cumulativeCostHandler
operator|.
name|getCumulativeCost
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|cumulativeCostHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|CumulativeCost
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.NonCumulativeCost#getNonCumulativeCost()}    * statistic.    *    * @param rel the relational expression    * @return estimated cost, or null if no reliable estimate can be determined    */
specifier|public
name|RelOptCost
name|getNonCumulativeCost
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|nonCumulativeCostHandler
operator|.
name|getNonCumulativeCost
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|nonCumulativeCostHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|NonCumulativeCost
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.PercentageOriginalRows#getPercentageOriginalRows()}    * statistic.    *    * @param rel the relational expression    * @return estimated percentage (between 0.0 and 1.0), or null if no    * reliable estimate can be determined    */
specifier|public
name|Double
name|getPercentageOriginalRows
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
name|Double
name|result
init|=
name|percentageOriginalRowsHandler
operator|.
name|getPercentageOriginalRows
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
decl_stmt|;
return|return
name|validatePercentage
argument_list|(
name|result
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|percentageOriginalRowsHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|PercentageOriginalRows
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.ColumnOrigin#getColumnOrigins(int)}    * statistic.    *    * @param rel           the relational expression    * @param column 0-based ordinal for output column of interest    * @return set of origin columns, or null if this information cannot be    * determined (whereas empty set indicates definitely no origin columns at    * all)    */
specifier|public
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|getColumnOrigins
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|column
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|columnOriginHandler
operator|.
name|getColumnOrigins
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|column
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|columnOriginHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|ColumnOrigin
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Determines the origin of a column, provided the column maps to a single    * column that isn't derived.    *    * @see #getColumnOrigins(org.apache.calcite.rel.RelNode, int)    *    * @param rel the RelNode of the column    * @param column the offset of the column whose origin we are trying to    * determine    *    * @return the origin of a column provided it's a simple column; otherwise,    * returns null    */
specifier|public
name|RelColumnOrigin
name|getColumnOrigin
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|int
name|column
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|origins
init|=
name|getColumnOrigins
argument_list|(
name|rel
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
name|origins
operator|==
literal|null
operator|||
name|origins
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|RelColumnOrigin
name|origin
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|origins
argument_list|)
decl_stmt|;
return|return
name|origin
operator|.
name|isDerived
argument_list|()
condition|?
literal|null
else|:
name|origin
return|;
block|}
comment|/**    * Determines the origin of a column.    */
specifier|public
name|Set
argument_list|<
name|RexNode
argument_list|>
name|getExpressionLineage
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RexNode
name|expression
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|expressionLineageHandler
operator|.
name|getExpressionLineage
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|expression
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|expressionLineageHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|ExpressionLineage
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Determines the tables used by a plan.    */
specifier|public
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|getTableReferences
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|tableReferencesHandler
operator|.
name|getTableReferences
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|tableReferencesHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|TableReferences
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Determines the origin of a {@link RelNode}, provided it maps to a single    * table, optionally with filtering and projection.    *    * @param rel the RelNode    *    * @return the table, if the RelNode is a simple table; otherwise null    */
specifier|public
name|RelOptTable
name|getTableOrigin
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
comment|// Determine the simple origin of the first column in the
comment|// RelNode.  If it's simple, then that means that the underlying
comment|// table is also simple, even if the column itself is derived.
specifier|final
name|Set
argument_list|<
name|RelColumnOrigin
argument_list|>
name|colOrigins
init|=
name|getColumnOrigins
argument_list|(
name|rel
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|colOrigins
operator|==
literal|null
operator|||
name|colOrigins
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|colOrigins
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getOriginTable
argument_list|()
return|;
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Selectivity#getSelectivity(RexNode)}    * statistic.    *    * @param rel       the relational expression    * @param predicate predicate whose selectivity is to be estimated against    *                  {@code rel}'s output    * @return estimated selectivity (between 0.0 and 1.0), or null if no    * reliable estimate can be determined    */
specifier|public
name|Double
name|getSelectivity
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
name|Double
name|result
init|=
name|selectivityHandler
operator|.
name|getSelectivity
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
name|validatePercentage
argument_list|(
name|result
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|selectivityHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Selectivity
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean)}    * statistic.    *    * @param rel the relational expression    * @return set of keys, or null if this information cannot be determined    * (whereas empty set indicates definitely no keys at all)    */
specifier|public
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|getUniqueKeys
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|getUniqueKeys
argument_list|(
name|rel
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean)}    * statistic.    *    * @param rel         the relational expression    * @param ignoreNulls if true, ignore null values when determining    *                    whether the keys are unique    *    * @return set of keys, or null if this information cannot be determined    * (whereas empty set indicates definitely no keys at all)    */
specifier|public
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|getUniqueKeys
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|uniqueKeysHandler
operator|.
name|getUniqueKeys
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|ignoreNulls
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|uniqueKeysHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|UniqueKeys
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns whether the rows of a given relational expression are distinct.    * This is derived by applying the    * {@link BuiltInMetadata.ColumnUniqueness#areColumnsUnique(org.apache.calcite.util.ImmutableBitSet, boolean)}    * statistic over all columns.    *    * @param rel     the relational expression    *    * @return true or false depending on whether the rows are unique, or    * null if not enough information is available to make that determination    */
specifier|public
name|Boolean
name|areRowsUnique
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|ImmutableBitSet
name|columns
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|columns
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.ColumnUniqueness#areColumnsUnique(ImmutableBitSet, boolean)}    * statistic.    *    * @param rel     the relational expression    * @param columns column mask representing the subset of columns for which    *                uniqueness will be determined    *    * @return true or false depending on whether the columns are unique, or    * null if not enough information is available to make that determination    */
specifier|public
name|Boolean
name|areColumnsUnique
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|ImmutableBitSet
name|columns
parameter_list|)
block|{
return|return
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|columns
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.ColumnUniqueness#areColumnsUnique(ImmutableBitSet, boolean)}    * statistic.    *    * @param rel         the relational expression    * @param columns     column mask representing the subset of columns for which    *                    uniqueness will be determined    * @param ignoreNulls if true, ignore null values when determining column    *                    uniqueness    * @return true or false depending on whether the columns are unique, or    * null if not enough information is available to make that determination    */
specifier|public
name|Boolean
name|areColumnsUnique
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|ImmutableBitSet
name|columns
parameter_list|,
name|boolean
name|ignoreNulls
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|columnUniquenessHandler
operator|.
name|areColumnsUnique
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|columns
argument_list|,
name|ignoreNulls
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|columnUniquenessHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|ColumnUniqueness
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Collation#collations()}    * statistic.    *    * @param rel         the relational expression    * @return List of sorted column combinations, or    * null if not enough information is available to make that determination    */
specifier|public
name|ImmutableList
argument_list|<
name|RelCollation
argument_list|>
name|collations
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|collationHandler
operator|.
name|collations
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|collationHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Collation
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Distribution#distribution()}    * statistic.    *    * @param rel         the relational expression    * @return List of sorted column combinations, or    * null if not enough information is available to make that determination    */
specifier|public
name|RelDistribution
name|distribution
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|distributionHandler
operator|.
name|distribution
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|distributionHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Distribution
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.PopulationSize#getPopulationSize(ImmutableBitSet)}    * statistic.    *    * @param rel      the relational expression    * @param groupKey column mask representing the subset of columns for which    *                 the row count will be determined    * @return distinct row count for the given groupKey, or null if no reliable    * estimate can be determined    *    */
specifier|public
name|Double
name|getPopulationSize
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|ImmutableBitSet
name|groupKey
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
name|Double
name|result
init|=
name|populationSizeHandler
operator|.
name|getPopulationSize
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|groupKey
argument_list|)
decl_stmt|;
return|return
name|validateResult
argument_list|(
name|result
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|populationSizeHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|PopulationSize
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Size#averageRowSize()}    * statistic.    *    * @param rel      the relational expression    * @return average size of a row, in bytes, or null if not known      */
specifier|public
name|Double
name|getAverageRowSize
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|sizeHandler
operator|.
name|averageRowSize
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|sizeHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Size
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Size#averageColumnSizes()}    * statistic.    *    * @param rel      the relational expression    * @return a list containing, for each column, the average size of a column    * value, in bytes. Each value or the entire list may be null if the    * metadata is not available    */
specifier|public
name|List
argument_list|<
name|Double
argument_list|>
name|getAverageColumnSizes
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|sizeHandler
operator|.
name|averageColumnSizes
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|sizeHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Size
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** As {@link #getAverageColumnSizes(org.apache.calcite.rel.RelNode)} but    * never returns a null list, only ever a list of nulls. */
specifier|public
name|List
argument_list|<
name|Double
argument_list|>
name|getAverageColumnSizesNotNull
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Double
argument_list|>
name|averageColumnSizes
init|=
name|getAverageColumnSizes
argument_list|(
name|rel
argument_list|)
decl_stmt|;
return|return
name|averageColumnSizes
operator|==
literal|null
condition|?
name|Collections
operator|.
expr|<
name|Double
operator|>
name|nCopies
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
literal|null
argument_list|)
else|:
name|averageColumnSizes
return|;
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Parallelism#isPhaseTransition()}    * statistic.    *    * @param rel      the relational expression    * @return whether each physical operator implementing this relational    * expression belongs to a different process than its inputs, or null if not    * known    */
specifier|public
name|Boolean
name|isPhaseTransition
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|parallelismHandler
operator|.
name|isPhaseTransition
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|parallelismHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Parallelism
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Parallelism#splitCount()}    * statistic.    *    * @param rel      the relational expression    * @return the number of distinct splits of the data, or null if not known    */
specifier|public
name|Integer
name|splitCount
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|parallelismHandler
operator|.
name|splitCount
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|parallelismHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Parallelism
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Memory#memory()}    * statistic.    *    * @param rel      the relational expression    * @return the expected amount of memory, in bytes, required by a physical    * operator implementing this relational expression, across all splits,    * or null if not known    */
specifier|public
name|Double
name|memory
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|memoryHandler
operator|.
name|memory
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|memoryHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Memory
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Memory#cumulativeMemoryWithinPhase()}    * statistic.    *    * @param rel      the relational expression    * @return the cumulative amount of memory, in bytes, required by the    * physical operator implementing this relational expression, and all other    * operators within the same phase, across all splits, or null if not known    */
specifier|public
name|Double
name|cumulativeMemoryWithinPhase
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|memoryHandler
operator|.
name|cumulativeMemoryWithinPhase
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|memoryHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Memory
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Memory#cumulativeMemoryWithinPhaseSplit()}    * statistic.    *    * @param rel      the relational expression    * @return the expected cumulative amount of memory, in bytes, required by    * the physical operator implementing this relational expression, and all    * operators within the same phase, within each split, or null if not known    */
specifier|public
name|Double
name|cumulativeMemoryWithinPhaseSplit
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|memoryHandler
operator|.
name|cumulativeMemoryWithinPhaseSplit
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|memoryHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Memory
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.DistinctRowCount#getDistinctRowCount(ImmutableBitSet, RexNode)}    * statistic.    *    * @param rel       the relational expression    * @param groupKey  column mask representing group by columns    * @param predicate pre-filtered predicates    * @return distinct row count for groupKey, filtered by predicate, or null    * if no reliable estimate can be determined    */
specifier|public
name|Double
name|getDistinctRowCount
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|ImmutableBitSet
name|groupKey
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
name|Double
name|result
init|=
name|distinctRowCountHandler
operator|.
name|getDistinctRowCount
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|groupKey
argument_list|,
name|predicate
argument_list|)
decl_stmt|;
return|return
name|validateResult
argument_list|(
name|result
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|distinctRowCountHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|DistinctRowCount
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Predicates#getPredicates()}    * statistic.    *    * @param rel the relational expression    * @return Predicates that can be pulled above this RelNode    */
specifier|public
name|RelOptPredicateList
name|getPulledUpPredicates
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|predicatesHandler
operator|.
name|getPredicates
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|predicatesHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|Predicates
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.AllPredicates#getAllPredicates()}    * statistic.    *    * @param rel the relational expression    * @return All predicates within and below this RelNode    */
specifier|public
name|RelOptPredicateList
name|getAllPredicates
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
return|return
name|allPredicatesHandler
operator|.
name|getAllPredicates
argument_list|(
name|rel
argument_list|,
name|this
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|allPredicatesHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|AllPredicates
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.ExplainVisibility#isVisibleInExplain(SqlExplainLevel)}    * statistic.    *    * @param rel          the relational expression    * @param explainLevel level of detail    * @return true for visible, false for invisible; if no metadata is available,    * defaults to true    */
specifier|public
name|boolean
name|isVisibleInExplain
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|SqlExplainLevel
name|explainLevel
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
name|Boolean
name|b
init|=
name|explainVisibilityHandler
operator|.
name|isVisibleInExplain
argument_list|(
name|rel
argument_list|,
name|this
argument_list|,
name|explainLevel
argument_list|)
decl_stmt|;
return|return
name|b
operator|==
literal|null
operator|||
name|b
return|;
block|}
catch|catch
parameter_list|(
name|JaninoRelMetadataProvider
operator|.
name|NoHandler
name|e
parameter_list|)
block|{
name|explainVisibilityHandler
operator|=
name|revise
argument_list|(
name|e
operator|.
name|relClass
argument_list|,
name|BuiltInMetadata
operator|.
name|ExplainVisibility
operator|.
name|DEF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|Double
name|validatePercentage
parameter_list|(
name|Double
name|result
parameter_list|)
block|{
assert|assert
name|isPercentage
argument_list|(
name|result
argument_list|,
literal|true
argument_list|)
assert|;
return|return
name|result
return|;
block|}
comment|/**    * Returns the    * {@link BuiltInMetadata.Distribution#distribution()}    * statistic.    *    * @param rel          the relational expression    *    * @return description of how the rows in the relational expression are    * physically distributed    */
specifier|public
name|RelDistribution
name|getDistribution
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|BuiltInMetadata
operator|.
name|Distribution
name|metadata
init|=
name|rel
operator|.
name|metadata
argument_list|(
name|BuiltInMetadata
operator|.
name|Distribution
operator|.
name|class
argument_list|,
name|this
argument_list|)
decl_stmt|;
return|return
name|metadata
operator|.
name|distribution
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isPercentage
parameter_list|(
name|Double
name|result
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
specifier|final
name|double
name|d
init|=
name|result
decl_stmt|;
if|if
condition|(
name|d
operator|<
literal|0.0
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|>
literal|1.0
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isNonNegative
parameter_list|(
name|Double
name|result
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
specifier|final
name|double
name|d
init|=
name|result
decl_stmt|;
if|if
condition|(
name|d
operator|<
literal|0.0
condition|)
block|{
assert|assert
operator|!
name|fail
assert|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|Double
name|validateResult
parameter_list|(
name|Double
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Never let the result go below 1, as it will result in incorrect
comment|// calculations if the row-count is used as the denominator in a
comment|// division expression.  Also, cap the value at the max double value
comment|// to avoid calculations using infinity.
if|if
condition|(
name|result
operator|.
name|isInfinite
argument_list|()
condition|)
block|{
name|result
operator|=
name|Double
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
assert|assert
name|isNonNegative
argument_list|(
name|result
argument_list|,
literal|true
argument_list|)
assert|;
if|if
condition|(
name|result
operator|<
literal|1.0
condition|)
block|{
name|result
operator|=
literal|1.0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

begin_comment
comment|// End RelMetadataQuery.java
end_comment

end_unit

