begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rel2sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|SingleRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Window
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectConstantToDummyJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeSystemImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexOver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexPatternFieldRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUnknownAs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindowBound
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMatchRecognize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNumericLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOverOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelectKeyword
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSetOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCountAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSumEmptyIsZeroAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFactoryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|RangeSets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Sarg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimeString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Range
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|RangeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|initialization
operator|.
name|qual
operator|.
name|UnknownInitialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|IntFunction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Nullness
operator|.
name|castNonNull
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * State for generating a SQL statement.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlImplementor
block|{
comment|// Always use quoted position, the "isQuoted" info is only used when
comment|// unparsing a SqlIdentifier. For some rex nodes, saying RexInputRef, we have
comment|// no idea about whether it is quoted or not for the original sql statement.
comment|// So we just quote it.
specifier|public
specifier|static
specifier|final
name|SqlParserPos
name|POS
init|=
name|SqlParserPos
operator|.
name|QUOTED_ZERO
decl_stmt|;
comment|/** SQL numeric literal {@code 0}. */
specifier|static
specifier|final
name|SqlNumericLiteral
name|ZERO
init|=
name|SqlNumericLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0"
argument_list|,
name|POS
argument_list|)
decl_stmt|;
comment|/** SQL numeric literal {@code 1}. */
specifier|static
specifier|final
name|SqlNumericLiteral
name|ONE
init|=
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|POS
argument_list|)
decl_stmt|;
specifier|public
specifier|final
name|SqlDialect
name|dialect
decl_stmt|;
specifier|protected
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|aliasSet
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|CorrelationId
argument_list|,
name|Context
argument_list|>
name|correlTableMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Private RexBuilder for short-lived expressions. It has its own    * dedicated type factory, so don't trust the types to be canonized. */
specifier|final
name|RexBuilder
name|rexBuilder
init|=
operator|new
name|RexBuilder
argument_list|(
operator|new
name|SqlTypeFactoryImpl
argument_list|(
name|RelDataTypeSystemImpl
operator|.
name|DEFAULT
argument_list|)
argument_list|)
decl_stmt|;
specifier|protected
name|SqlImplementor
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|)
block|{
name|this
operator|.
name|dialect
operator|=
name|requireNonNull
argument_list|(
name|dialect
argument_list|,
literal|"dialect"
argument_list|)
expr_stmt|;
block|}
comment|/** Visits a relational expression that has no parent. */
specifier|public
specifier|final
name|Result
name|visitRoot
parameter_list|(
name|RelNode
name|r
parameter_list|)
block|{
name|RelNode
name|best
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|dialect
operator|.
name|supportsGroupByLiteral
argument_list|()
condition|)
block|{
name|HepProgramBuilder
name|hepProgramBuilder
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
name|hepProgramBuilder
operator|.
name|addRuleInstance
argument_list|(
name|AggregateProjectConstantToDummyJoinRule
operator|.
name|Config
operator|.
name|DEFAULT
operator|.
name|toRule
argument_list|()
argument_list|)
expr_stmt|;
name|HepPlanner
name|hepPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|hepProgramBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|hepPlanner
operator|.
name|setRoot
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|best
operator|=
name|hepPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|best
operator|=
name|r
expr_stmt|;
block|}
try|try
block|{
return|return
name|visitInput
argument_list|(
name|holder
argument_list|(
name|best
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Error
decl||
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|throwAsRuntime
argument_list|(
literal|"Error while converting RelNode to SqlNode:\n"
operator|+
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|r
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a relational expression that has {@code r} as its input. */
specifier|private
specifier|static
name|RelNode
name|holder
parameter_list|(
name|RelNode
name|r
parameter_list|)
block|{
return|return
operator|new
name|SingleRel
argument_list|(
name|r
operator|.
name|getCluster
argument_list|()
argument_list|,
name|r
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|r
argument_list|)
block|{     }
return|;
block|}
comment|// CHECKSTYLE: IGNORE 1
comment|/** @deprecated Use either {@link #visitRoot(RelNode)} or    * {@link #visitInput(RelNode, int)}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
specifier|final
name|Result
name|visitChild
parameter_list|(
name|int
name|i
parameter_list|,
name|RelNode
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/** Visits an input of the current relational expression,    * deducing {@code anon} using {@link #isAnon()}. */
specifier|public
specifier|final
name|Result
name|visitInput
parameter_list|(
name|RelNode
name|e
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|visitInput
argument_list|(
name|e
argument_list|,
name|i
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Visits an input of the current relational expression,    * with the given expected clauses. */
specifier|public
specifier|final
name|Result
name|visitInput
parameter_list|(
name|RelNode
name|e
parameter_list|,
name|int
name|i
parameter_list|,
name|Clause
modifier|...
name|clauses
parameter_list|)
block|{
return|return
name|visitInput
argument_list|(
name|e
argument_list|,
name|i
argument_list|,
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|clauses
argument_list|)
argument_list|)
return|;
block|}
comment|/** Visits an input of the current relational expression,    * deducing {@code anon} using {@link #isAnon()}. */
specifier|public
specifier|final
name|Result
name|visitInput
parameter_list|(
name|RelNode
name|e
parameter_list|,
name|int
name|i
parameter_list|,
name|Set
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|)
block|{
return|return
name|visitInput
argument_list|(
name|e
argument_list|,
name|i
argument_list|,
name|isAnon
argument_list|()
argument_list|,
literal|false
argument_list|,
name|clauses
argument_list|)
return|;
block|}
comment|/** Visits the {@code i}th input of {@code e}, the current relational    * expression.    *    * @param e Current relational expression    * @param i Ordinal of input within {@code e}    * @param anon Whether to remove trivial aliases such as "EXPR$0"    * @param ignoreClauses Whether to ignore the expected clauses when deciding    *   whether a sub-query is required    * @param expectedClauses Set of clauses that we expect the builder that    *   consumes this result will create    * @return Result    *    * @see #isAnon()    */
specifier|public
specifier|abstract
name|Result
name|visitInput
parameter_list|(
name|RelNode
name|e
parameter_list|,
name|int
name|i
parameter_list|,
name|boolean
name|anon
parameter_list|,
name|boolean
name|ignoreClauses
parameter_list|,
name|Set
argument_list|<
name|Clause
argument_list|>
name|expectedClauses
parameter_list|)
function_decl|;
specifier|public
name|void
name|addSelect
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|String
name|name
init|=
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|selectList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Nullable
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|alias
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
operator|||
operator|!
name|alias
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|node
operator|=
name|as
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|selectList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/** Convenience method for creating column and table aliases.    *    *<p>{@code AS(e, "c")} creates "e AS c";    * {@code AS(e, "t", "c1", "c2"} creates "e AS t (c1, c2)". */
specifier|protected
name|SqlCall
name|as
parameter_list|(
name|SqlNode
name|e
parameter_list|,
name|String
name|alias
parameter_list|,
name|String
modifier|...
name|fieldNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|operandList
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|operandList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|operandList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|fieldName
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operandList
argument_list|)
return|;
block|}
comment|/** Returns whether a list of expressions projects all fields, in order,    * from the input, with the same names. */
specifier|public
specifier|static
name|boolean
name|isStar
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exps
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|,
name|RelDataType
name|projectRowType
parameter_list|)
block|{
assert|assert
name|exps
operator|.
name|size
argument_list|()
operator|==
name|projectRowType
operator|.
name|getFieldCount
argument_list|()
assert|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|ref
range|:
name|exps
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ref
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|else if
condition|(
operator|(
operator|(
name|RexInputRef
operator|)
name|ref
operator|)
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
operator|++
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|i
operator|==
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
operator|&&
name|inputRowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|equals
argument_list|(
name|projectRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isStar
parameter_list|(
name|RexProgram
name|program
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|ref
range|:
name|program
operator|.
name|getProjectList
argument_list|()
control|)
block|{
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
operator|++
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|i
operator|==
name|program
operator|.
name|getInputRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
return|;
block|}
specifier|public
name|Result
name|setOpToSql
parameter_list|(
name|SqlSetOperator
name|operator
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|SqlNode
name|node
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RelNode
argument_list|>
name|input
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|Result
name|result
init|=
name|visitInput
argument_list|(
name|rel
argument_list|,
name|input
operator|.
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|node
operator|=
name|result
operator|.
name|asSelect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|operator
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
name|result
operator|.
name|asSelect
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|node
operator|!=
literal|null
operator|:
literal|"set op must have at least one input, operator = "
operator|+
name|operator
operator|+
literal|", rel = "
operator|+
name|rel
assert|;
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
init|=
name|Expressions
operator|.
name|list
argument_list|(
name|Clause
operator|.
name|SET_OP
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|rel
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Converts a {@link RexNode} condition into a {@link SqlNode}.    *    * @param node            Join condition    * @param leftContext     Left context    * @param rightContext    Right context    *    * @return SqlNode that represents the condition    */
specifier|public
specifier|static
name|SqlNode
name|convertConditionToSqlNode
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|Context
name|leftContext
parameter_list|,
name|Context
name|rightContext
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|true
argument_list|,
name|POS
argument_list|)
return|;
block|}
if|if
condition|(
name|node
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|false
argument_list|,
name|POS
argument_list|)
return|;
block|}
specifier|final
name|Context
name|joinContext
init|=
name|leftContext
operator|.
name|implementor
argument_list|()
operator|.
name|joinContext
argument_list|(
name|leftContext
argument_list|,
name|rightContext
argument_list|)
decl_stmt|;
return|return
name|joinContext
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** Removes cast from string.    *    *<p>For example, {@code x> CAST('2015-01-07' AS DATE)}    * becomes {@code x> '2015-01-07'}.    */
specifier|private
specifier|static
name|RexNode
name|stripCastFromString
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|SqlDialect
name|dialect
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|IS_NOT_DISTINCT_FROM
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|RexNode
name|o0
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|o1
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|o0
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
operator|&&
name|o1
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|CAST
condition|)
block|{
if|if
condition|(
operator|!
name|dialect
operator|.
name|supportsImplicitTypeCoercion
argument_list|(
operator|(
name|RexCall
operator|)
name|o0
argument_list|)
condition|)
block|{
comment|// If the dialect does not support implicit type coercion,
comment|// we definitely can not strip the cast.
return|return
name|node
return|;
block|}
specifier|final
name|RexNode
name|o0b
init|=
operator|(
operator|(
name|RexCall
operator|)
name|o0
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|o0b
argument_list|,
name|o1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|o1
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
operator|&&
name|o0
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|CAST
condition|)
block|{
if|if
condition|(
operator|!
name|dialect
operator|.
name|supportsImplicitTypeCoercion
argument_list|(
operator|(
name|RexCall
operator|)
name|o1
argument_list|)
condition|)
block|{
return|return
name|node
return|;
block|}
specifier|final
name|RexNode
name|o1b
init|=
operator|(
operator|(
name|RexCall
operator|)
name|o1
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|o0
argument_list|,
name|o1b
argument_list|)
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|node
return|;
block|}
specifier|public
specifier|static
name|JoinType
name|joinType
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|)
block|{
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
return|return
name|JoinType
operator|.
name|LEFT
return|;
case|case
name|RIGHT
case|:
return|return
name|JoinType
operator|.
name|RIGHT
return|;
case|case
name|INNER
case|:
return|return
name|JoinType
operator|.
name|INNER
return|;
case|case
name|FULL
case|:
return|return
name|JoinType
operator|.
name|FULL
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|joinType
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a result based on a single relational expression. */
specifier|public
name|Result
name|result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|RelNode
name|rel
parameter_list|,
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
assert|assert
name|aliases
operator|==
literal|null
operator|||
name|aliases
operator|.
name|size
argument_list|()
operator|<
literal|2
operator|||
name|aliases
operator|instanceof
name|LinkedHashMap
operator|||
name|aliases
operator|instanceof
name|ImmutableMap
operator|:
literal|"must use a Map implementation that preserves order"
assert|;
specifier|final
annotation|@
name|Nullable
name|String
name|alias2
init|=
name|SqlValidatorUtil
operator|.
name|alias
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alias3
init|=
name|alias2
operator|!=
literal|null
condition|?
name|alias2
else|:
literal|"t"
decl_stmt|;
specifier|final
name|String
name|alias4
init|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|alias3
argument_list|,
name|aliasSet
argument_list|,
name|SqlValidatorUtil
operator|.
name|EXPR_SUGGESTER
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|adjustedRowType
argument_list|(
name|rel
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliases
operator|!=
literal|null
operator|&&
operator|!
name|aliases
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
operator|||
name|aliases
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
condition|)
block|{
return|return
name|result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|alias4
argument_list|,
name|rowType
argument_list|,
name|aliases
argument_list|)
return|;
block|}
specifier|final
name|String
name|alias5
decl_stmt|;
if|if
condition|(
name|alias2
operator|==
literal|null
operator|||
operator|!
name|alias2
operator|.
name|equals
argument_list|(
name|alias4
argument_list|)
operator|||
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
condition|)
block|{
name|alias5
operator|=
name|alias4
expr_stmt|;
block|}
else|else
block|{
name|alias5
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|alias5
argument_list|,
name|rowType
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
name|alias4
argument_list|,
name|rowType
argument_list|)
argument_list|)
return|;
block|}
comment|/** Factory method for {@link Result}.    *    *<p>Call this method rather than creating a {@code Result} directly,    * because sub-classes may override. */
specifier|protected
name|Result
name|result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
annotation|@
name|Nullable
name|String
name|neededAlias
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|neededType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|neededAlias
argument_list|,
name|neededType
argument_list|,
name|aliases
argument_list|)
return|;
block|}
comment|/** Returns the row type of {@code rel}, adjusting the field names if    * {@code node} is "(query) as tableAlias (fieldAlias, ...)". */
specifier|private
specifier|static
name|RelDataType
name|adjustedRowType
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|builder
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
return|return
name|adjustedRowType
argument_list|(
name|rel
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|SELECT
case|:
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|(
operator|(
name|SqlSelect
operator|)
name|node
operator|)
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
if|if
condition|(
name|selectList
operator|.
name|equals
argument_list|(
name|SqlNodeList
operator|.
name|SINGLETON_STAR
argument_list|)
condition|)
block|{
return|return
name|rowType
return|;
block|}
name|builder
operator|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
expr_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|selectList
argument_list|,
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
parameter_list|(
name|selectItem
parameter_list|,
name|field
parameter_list|)
lambda|->
name|builder
operator|.
name|add
argument_list|(
name|Util
operator|.
name|first
argument_list|(
name|SqlValidatorUtil
operator|.
name|alias
argument_list|(
name|selectItem
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
case|case
name|AS
case|:
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
if|if
condition|(
name|operandList
operator|.
name|size
argument_list|()
operator|<=
literal|2
condition|)
block|{
return|return
name|rowType
return|;
block|}
name|builder
operator|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
expr_stmt|;
name|Pair
operator|.
name|forEach
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|operandList
argument_list|,
literal|2
argument_list|)
argument_list|,
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
parameter_list|(
name|operand
parameter_list|,
name|field
parameter_list|)
lambda|->
name|builder
operator|.
name|add
argument_list|(
name|operand
operator|.
name|toString
argument_list|()
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
default|default:
return|return
name|rowType
return|;
block|}
block|}
comment|/** Creates a result based on a join. (Each join could contain one or more    * relational expressions.) */
specifier|public
name|Result
name|result
parameter_list|(
name|SqlNode
name|join
parameter_list|,
name|Result
name|leftResult
parameter_list|,
name|Result
name|rightResult
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|JOIN
condition|)
block|{
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|collectAliases
argument_list|(
name|builder
argument_list|,
name|join
argument_list|,
name|Iterables
operator|.
name|concat
argument_list|(
name|leftResult
operator|.
name|aliases
operator|.
name|values
argument_list|()
argument_list|,
name|rightResult
operator|.
name|aliases
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
name|aliases
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|aliases
operator|=
name|leftResult
operator|.
name|aliases
expr_stmt|;
block|}
return|return
name|result
argument_list|(
name|join
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|FROM
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|aliases
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|collectAliases
parameter_list|(
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|builder
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|Iterator
argument_list|<
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlJoin
condition|)
block|{
specifier|final
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|node
decl_stmt|;
name|collectAliases
argument_list|(
name|builder
argument_list|,
name|join
operator|.
name|getLeft
argument_list|()
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
name|collectAliases
argument_list|(
name|builder
argument_list|,
name|join
operator|.
name|getRight
argument_list|()
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|String
name|alias
init|=
name|requireNonNull
argument_list|(
name|SqlValidatorUtil
operator|.
name|alias
argument_list|(
name|node
argument_list|)
argument_list|,
literal|"alias"
argument_list|)
decl_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|aliases
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns whether to remove trivial aliases such as "EXPR$0"    * when converting the current relational expression into a SELECT.    *    *<p>For example, INSERT does not care about field names;    * we would prefer to generate without the "EXPR$0" alias:    *    *<pre>{@code INSERT INTO t1 SELECT x, y + 1 FROM t2}</pre>    *    * rather than with it:    *    *<pre>{@code INSERT INTO t1 SELECT x, y + 1 AS EXPR$0 FROM t2}</pre>    *    *<p>But JOIN does care about field names; we have to generate the "EXPR$0"    * alias:    *    *<pre>{@code SELECT *    * FROM emp AS e    * JOIN (SELECT x, y + 1 AS EXPR$0) AS d    * ON e.deptno = d.EXPR$0}    *</pre>    *    *<p>because if we omit "AS EXPR$0" we do not know the field we are joining    * to, and the following is invalid:    *    *<pre>{@code SELECT *    * FROM emp AS e    * JOIN (SELECT x, y + 1) AS d    * ON e.deptno = d.EXPR$0}    *</pre>    */
specifier|protected
name|boolean
name|isAnon
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Wraps a node in a SELECT statement that has no clauses:    *  "SELECT ... FROM (node)". */
name|SqlSelect
name|wrapSelect
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|instanceof
name|SqlJoin
operator|||
name|node
operator|instanceof
name|SqlIdentifier
operator|||
name|node
operator|instanceof
name|SqlMatchRecognize
operator|||
name|node
operator|instanceof
name|SqlTableRef
operator|||
name|node
operator|instanceof
name|SqlCall
operator|&&
operator|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlSetOperator
operator|||
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|AS
operator|||
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|VALUES
operator|)
operator|:
name|node
assert|;
if|if
condition|(
name|requiresAlias
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|node
operator|=
name|as
argument_list|(
name|node
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
name|SqlNodeList
operator|.
name|SINGLETON_STAR
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns whether we need to add an alias if this node is to be the FROM    * clause of a SELECT. */
specifier|private
name|boolean
name|requiresAlias
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dialect
operator|.
name|requiresAliasForFromItems
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IDENTIFIER
case|:
return|return
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
return|;
case|case
name|AS
case|:
case|case
name|JOIN
case|:
case|case
name|EXPLICIT_TABLE
case|:
return|return
literal|false
return|;
default|default:
return|return
literal|true
return|;
block|}
block|}
comment|/** Returns whether a node is a call to an aggregate function. */
specifier|private
specifier|static
name|boolean
name|isAggregate
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
name|node
operator|instanceof
name|SqlCall
operator|&&
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlAggFunction
return|;
block|}
comment|/** Returns whether a node is a call to a windowed aggregate function. */
specifier|private
specifier|static
name|boolean
name|isWindowedAggregate
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
name|node
operator|instanceof
name|SqlCall
operator|&&
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlOverOperator
return|;
block|}
comment|/** Context for translating a {@link RexNode} expression (within a    * {@link RelNode}) into a {@link SqlNode} expression (within a SQL parse    * tree). */
specifier|public
specifier|abstract
specifier|static
class|class
name|Context
block|{
specifier|final
name|SqlDialect
name|dialect
decl_stmt|;
specifier|final
name|int
name|fieldCount
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|ignoreCast
decl_stmt|;
specifier|protected
name|Context
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|int
name|fieldCount
parameter_list|)
block|{
name|this
argument_list|(
name|dialect
argument_list|,
name|fieldCount
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Context
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|int
name|fieldCount
parameter_list|,
name|boolean
name|ignoreCast
parameter_list|)
block|{
name|this
operator|.
name|dialect
operator|=
name|dialect
expr_stmt|;
name|this
operator|.
name|fieldCount
operator|=
name|fieldCount
expr_stmt|;
name|this
operator|.
name|ignoreCast
operator|=
name|ignoreCast
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
function_decl|;
comment|/** Creates a reference to a field to be used in an ORDER BY clause.      *      *<p>By default, it returns the same result as {@link #field}.      *      *<p>If the field has an alias, uses the alias.      * If the field is an unqualified column reference which is the same an      * alias, switches to a qualified column reference.      */
specifier|public
name|SqlNode
name|orderField
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|SqlNode
name|node
init|=
name|field
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlNumericLiteral
operator|&&
name|dialect
operator|.
name|getConformance
argument_list|()
operator|.
name|isSortByOrdinal
argument_list|()
condition|)
block|{
comment|// An integer literal will be wrongly interpreted as a field ordinal.
comment|// Convert it to a character literal, which will have the same effect.
specifier|final
name|String
name|strValue
init|=
operator|(
operator|(
name|SqlNumericLiteral
operator|)
name|node
operator|)
operator|.
name|toValue
argument_list|()
decl_stmt|;
return|return
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
name|strValue
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
comment|/** Converts an expression from {@link RexNode} to {@link SqlNode}      * format.      *      * @param program Required only if {@code rex} contains {@link RexLocalRef}      * @param rex Expression to convert      */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
specifier|final
name|RexSubQuery
name|subQuery
decl_stmt|;
specifier|final
name|SqlNode
name|sqlSubQuery
decl_stmt|;
specifier|final
name|RexLiteral
name|literal
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LOCAL_REF
case|:
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|RexLocalRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
return|return
name|toSql
argument_list|(
name|program
argument_list|,
name|requireNonNull
argument_list|(
name|program
argument_list|,
literal|"program"
argument_list|)
operator|.
name|getExprList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
case|case
name|INPUT_REF
case|:
return|return
name|field
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
case|case
name|FIELD_ACCESS
case|:
specifier|final
name|Deque
argument_list|<
name|RexFieldAccess
argument_list|>
name|accesses
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|RexNode
name|referencedExpr
init|=
name|rex
decl_stmt|;
while|while
condition|(
name|referencedExpr
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FIELD_ACCESS
condition|)
block|{
name|accesses
operator|.
name|offerLast
argument_list|(
operator|(
name|RexFieldAccess
operator|)
name|referencedExpr
argument_list|)
expr_stmt|;
name|referencedExpr
operator|=
operator|(
operator|(
name|RexFieldAccess
operator|)
name|referencedExpr
operator|)
operator|.
name|getReferenceExpr
argument_list|()
expr_stmt|;
block|}
name|SqlIdentifier
name|sqlIdentifier
decl_stmt|;
switch|switch
condition|(
name|referencedExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CORREL_VARIABLE
case|:
specifier|final
name|RexCorrelVariable
name|variable
init|=
operator|(
name|RexCorrelVariable
operator|)
name|referencedExpr
decl_stmt|;
specifier|final
name|Context
name|correlAliasContext
init|=
name|getAliasContext
argument_list|(
name|variable
argument_list|)
decl_stmt|;
specifier|final
name|RexFieldAccess
name|lastAccess
init|=
name|accesses
operator|.
name|pollLast
argument_list|()
decl_stmt|;
assert|assert
name|lastAccess
operator|!=
literal|null
assert|;
name|sqlIdentifier
operator|=
operator|(
name|SqlIdentifier
operator|)
name|correlAliasContext
operator|.
name|field
argument_list|(
name|lastAccess
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROW
case|:
specifier|final
name|SqlNode
name|expr
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|referencedExpr
argument_list|)
decl_stmt|;
name|sqlIdentifier
operator|=
operator|new
name|SqlIdentifier
argument_list|(
name|expr
operator|.
name|toString
argument_list|()
argument_list|,
name|POS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sqlIdentifier
operator|=
operator|(
name|SqlIdentifier
operator|)
name|toSql
argument_list|(
name|program
argument_list|,
name|referencedExpr
argument_list|)
expr_stmt|;
block|}
name|int
name|nameIndex
init|=
name|sqlIdentifier
operator|.
name|names
operator|.
name|size
argument_list|()
decl_stmt|;
name|RexFieldAccess
name|access
decl_stmt|;
while|while
condition|(
operator|(
name|access
operator|=
name|accesses
operator|.
name|pollLast
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|sqlIdentifier
operator|=
name|sqlIdentifier
operator|.
name|add
argument_list|(
name|nameIndex
operator|++
argument_list|,
name|access
operator|.
name|getField
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|POS
argument_list|)
expr_stmt|;
block|}
return|return
name|sqlIdentifier
return|;
case|case
name|PATTERN_INPUT_REF
case|:
specifier|final
name|RexPatternFieldRef
name|ref
init|=
operator|(
name|RexPatternFieldRef
operator|)
name|rex
decl_stmt|;
name|String
name|pv
init|=
name|ref
operator|.
name|getAlpha
argument_list|()
decl_stmt|;
name|SqlNode
name|refNode
init|=
name|field
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|refNode
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return
name|id
operator|.
name|setName
argument_list|(
literal|0
argument_list|,
name|pv
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|SqlIdentifier
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|pv
argument_list|,
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
case|case
name|LITERAL
case|:
return|return
name|SqlImplementor
operator|.
name|toSql
argument_list|(
name|program
argument_list|,
operator|(
name|RexLiteral
operator|)
name|rex
argument_list|)
return|;
case|case
name|CASE
case|:
specifier|final
name|RexCall
name|caseCall
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|caseNodeList
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|caseCall
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|valueNode
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|whenList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|thenList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|elseNode
decl_stmt|;
if|if
condition|(
name|caseNodeList
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
comment|// switched:
comment|//   "case x when v1 then t1 when v2 then t2 ... else e end"
name|valueNode
operator|=
name|caseNodeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|whenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|thenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// other: "case when w1 then t1 when w2 then t2 ... else e end"
name|valueNode
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|whenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|thenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|elseNode
operator|=
name|caseNodeList
operator|.
name|get
argument_list|(
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlCase
argument_list|(
name|POS
argument_list|,
name|valueNode
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|whenList
argument_list|,
name|POS
argument_list|)
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|thenList
argument_list|,
name|POS
argument_list|)
argument_list|,
name|elseNode
argument_list|)
return|;
case|case
name|DYNAMIC_PARAM
case|:
specifier|final
name|RexDynamicParam
name|caseParam
init|=
operator|(
name|RexDynamicParam
operator|)
name|rex
decl_stmt|;
return|return
operator|new
name|SqlDynamicParam
argument_list|(
name|caseParam
operator|.
name|getIndex
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|IN
case|:
name|subQuery
operator|=
operator|(
name|RexSubQuery
operator|)
name|rex
expr_stmt|;
name|sqlSubQuery
operator|=
name|implementor
argument_list|()
operator|.
name|visitRoot
argument_list|(
name|subQuery
operator|.
name|rel
argument_list|)
operator|.
name|asQueryOrValues
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|subQuery
operator|.
name|operands
decl_stmt|;
name|SqlNode
name|op0
decl_stmt|;
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|op0
operator|=
name|toSql
argument_list|(
name|program
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|cols
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|operands
argument_list|)
decl_stmt|;
name|op0
operator|=
operator|new
name|SqlNodeList
argument_list|(
name|cols
argument_list|,
name|POS
argument_list|)
expr_stmt|;
block|}
return|return
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|op0
argument_list|,
name|sqlSubQuery
argument_list|)
return|;
case|case
name|SEARCH
case|:
specifier|final
name|RexCall
name|search
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|search
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL
condition|)
block|{
name|literal
operator|=
operator|(
name|RexLiteral
operator|)
name|search
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|Sarg
name|sarg
init|=
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|Sarg
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
comment|//noinspection unchecked
return|return
name|toSql
argument_list|(
name|program
argument_list|,
name|search
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
argument_list|,
name|sarg
argument_list|)
return|;
block|}
return|return
name|toSql
argument_list|(
name|program
argument_list|,
name|RexUtil
operator|.
name|expandSearch
argument_list|(
name|implementor
argument_list|()
operator|.
name|rexBuilder
argument_list|,
name|program
argument_list|,
name|search
argument_list|)
argument_list|)
return|;
case|case
name|EXISTS
case|:
case|case
name|UNIQUE
case|:
case|case
name|SCALAR_QUERY
case|:
name|subQuery
operator|=
operator|(
name|RexSubQuery
operator|)
name|rex
expr_stmt|;
name|sqlSubQuery
operator|=
name|implementor
argument_list|()
operator|.
name|visitRoot
argument_list|(
name|subQuery
operator|.
name|rel
argument_list|)
operator|.
name|asQueryOrValues
argument_list|()
expr_stmt|;
return|return
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|sqlSubQuery
argument_list|)
return|;
case|case
name|NOT
case|:
name|RexNode
name|operand
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|node
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|operand
argument_list|)
decl_stmt|;
specifier|final
name|SqlOperator
name|inverseOperator
init|=
name|getInverseOperator
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|inverseOperator
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|operand
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IN
case|:
assert|assert
name|operand
operator|instanceof
name|RexSubQuery
operator|:
literal|"scalar IN is no longer allowed in RexCall: "
operator|+
name|rex
assert|;
break|break;
default|default:
break|break;
block|}
return|return
name|inverseOperator
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
return|;
block|}
default|default:
if|if
condition|(
name|rex
operator|instanceof
name|RexOver
condition|)
block|{
return|return
name|toSql
argument_list|(
name|program
argument_list|,
operator|(
name|RexOver
operator|)
name|rex
argument_list|)
return|;
block|}
return|return
name|callToSql
argument_list|(
name|program
argument_list|,
operator|(
name|RexCall
operator|)
name|rex
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
specifier|private
name|SqlNode
name|callToSql
parameter_list|(
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RexCall
name|call0
parameter_list|,
name|boolean
name|not
parameter_list|)
block|{
specifier|final
name|RexCall
name|call1
init|=
name|reverseCall
argument_list|(
name|call0
argument_list|)
decl_stmt|;
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|stripCastFromString
argument_list|(
name|call1
argument_list|,
name|dialect
argument_list|)
decl_stmt|;
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|op
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SUM0
case|:
name|op
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|RexNode
name|operand
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|getInverseOperator
argument_list|(
name|operand
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
name|callToSql
argument_list|(
name|program
argument_list|,
operator|(
name|RexCall
operator|)
name|operand
argument_list|,
operator|!
name|not
argument_list|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|not
condition|)
block|{
name|op
operator|=
name|requireNonNull
argument_list|(
name|getInverseOperator
argument_list|(
name|call
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"unable to negate "
operator|+
name|call
operator|.
name|getKind
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodeList
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
comment|// CURSOR is used inside CAST, like 'CAST ($0): CURSOR NOT NULL',
comment|// convert it to sql call of {@link SqlStdOperatorTable#CURSOR}.
specifier|final
name|RelDataType
name|dataType
init|=
name|call
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CURSOR
condition|)
block|{
specifier|final
name|RexNode
name|operand0
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|operand0
operator|instanceof
name|RexInputRef
assert|;
name|int
name|ordinal
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|operand0
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|SqlNode
name|fieldOperand
init|=
name|field
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|CURSOR
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|fieldOperand
argument_list|)
return|;
block|}
comment|// Ideally the UNKNOWN type would never exist in a fully-formed, validated rel node, but
comment|// it can be useful in certain situations where determining the type of an expression is
comment|// infeasible, such as inserting arbitrary user-provided SQL snippets into an otherwise
comment|// manually-constructed (as opposed to parsed) rel node.
comment|// In such a context, assume that casting anything to UNKNOWN is a no-op.
if|if
condition|(
name|ignoreCast
operator|||
name|call
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|UNKNOWN
condition|)
block|{
assert|assert
name|nodeList
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|nodeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|nodeList
operator|.
name|add
argument_list|(
name|castNonNull
argument_list|(
name|dialect
operator|.
name|getCastSpec
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|SqlUtil
operator|.
name|createCall
argument_list|(
name|op
argument_list|,
name|POS
argument_list|,
name|nodeList
argument_list|)
return|;
block|}
comment|/** Reverses the order of a call, while preserving semantics, if it improves      * readability.      *      *<p>In the base implementation, this method does nothing;      * in a join context, reverses a call such as      * "e.deptno = d.deptno" to      * "d.deptno = e.deptno"      * if "d" is the left input to the join      * and "e" is the right. */
specifier|protected
name|RexCall
name|reverseCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
return|return
name|call
return|;
block|}
comment|/** If {@code node} is a {@link RexCall}, extracts the operator and      * finds the corresponding inverse operator using {@link SqlOperator#not()}.      * Returns null if {@code node} is not a {@link RexCall},      * or if the operator has no logical inverse. */
specifier|private
specifier|static
annotation|@
name|Nullable
name|SqlOperator
name|getInverseOperator
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|RexCall
condition|)
block|{
return|return
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|.
name|not
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Converts a Sarg to SQL, generating "operand IN (c1, c2, ...)" if the      * ranges are all points. */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"BetaApi"
block|,
literal|"UnstableApiUsage"
block|}
argument_list|)
specifier|private
parameter_list|<
name|C
extends|extends
name|Comparable
argument_list|<
name|C
argument_list|>
parameter_list|>
name|SqlNode
name|toSql
parameter_list|(
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RexNode
name|operand
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|Sarg
argument_list|<
name|C
argument_list|>
name|sarg
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|operandSql
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|sarg
operator|.
name|nullAs
operator|==
name|RexUnknownAs
operator|.
name|TRUE
condition|)
block|{
name|orList
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operandSql
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sarg
operator|.
name|isPoints
argument_list|()
condition|)
block|{
comment|// generate 'x = 10' or 'x IN (10, 20, 30)'
name|orList
operator|.
name|add
argument_list|(
name|toIn
argument_list|(
name|operandSql
argument_list|,
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|SqlStdOperatorTable
operator|.
name|IN
argument_list|,
name|program
argument_list|,
name|type
argument_list|,
name|sarg
operator|.
name|rangeSet
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|sarg
operator|.
name|isComplementedPoints
argument_list|()
condition|)
block|{
comment|// generate 'x<> 10' or 'x NOT IN (10, 20, 30)'
name|orList
operator|.
name|add
argument_list|(
name|toIn
argument_list|(
name|operandSql
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT_EQUALS
argument_list|,
name|SqlStdOperatorTable
operator|.
name|NOT_IN
argument_list|,
name|program
argument_list|,
name|type
argument_list|,
name|sarg
operator|.
name|rangeSet
operator|.
name|complement
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|RangeSets
operator|.
name|Consumer
argument_list|<
name|C
argument_list|>
name|consumer
init|=
operator|new
name|RangeToSql
argument_list|<>
argument_list|(
name|operandSql
argument_list|,
name|orList
argument_list|,
name|v
lambda|->
name|toSql
argument_list|(
name|program
argument_list|,
name|implementor
argument_list|()
operator|.
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|v
argument_list|,
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RangeSets
operator|.
name|forEach
argument_list|(
name|sarg
operator|.
name|rangeSet
argument_list|,
name|consumer
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlUtil
operator|.
name|createCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|OR
argument_list|,
name|POS
argument_list|,
name|orList
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"BetaApi"
argument_list|)
specifier|private
parameter_list|<
name|C
extends|extends
name|Comparable
argument_list|<
name|C
argument_list|>
parameter_list|>
name|SqlNode
name|toIn
parameter_list|(
name|SqlNode
name|operandSql
parameter_list|,
name|SqlBinaryOperator
name|eqOp
parameter_list|,
name|SqlBinaryOperator
name|inOp
parameter_list|,
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|RangeSet
argument_list|<
name|C
argument_list|>
name|rangeSet
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|list
init|=
name|rangeSet
operator|.
name|asRanges
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|range
lambda|->
name|toSql
argument_list|(
name|program
argument_list|,
name|implementor
argument_list|()
operator|.
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|range
operator|.
name|lowerEndpoint
argument_list|()
argument_list|,
name|type
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|SqlNode
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
return|return
name|eqOp
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operandSql
argument_list|,
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|inOp
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operandSql
argument_list|,
name|list
argument_list|)
return|;
block|}
block|}
comment|/** Converts an expression from {@link RexWindowBound} to {@link SqlNode}      * format.      *      * @param rexWindowBound Expression to convert      */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|RexWindowBound
name|rexWindowBound
parameter_list|)
block|{
specifier|final
name|SqlNode
name|offsetLiteral
init|=
name|rexWindowBound
operator|.
name|getOffset
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
name|rexWindowBound
operator|.
name|getOffset
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
if|if
condition|(
name|rexWindowBound
operator|.
name|isPreceding
argument_list|()
condition|)
block|{
return|return
name|offsetLiteral
operator|==
literal|null
condition|?
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|POS
argument_list|)
else|:
name|SqlWindow
operator|.
name|createPreceding
argument_list|(
name|offsetLiteral
argument_list|,
name|POS
argument_list|)
return|;
block|}
if|else if
condition|(
name|rexWindowBound
operator|.
name|isFollowing
argument_list|()
condition|)
block|{
return|return
name|offsetLiteral
operator|==
literal|null
condition|?
name|SqlWindow
operator|.
name|createUnboundedFollowing
argument_list|(
name|POS
argument_list|)
else|:
name|SqlWindow
operator|.
name|createFollowing
argument_list|(
name|offsetLiteral
argument_list|,
name|POS
argument_list|)
return|;
block|}
else|else
block|{
assert|assert
name|rexWindowBound
operator|.
name|isCurrentRow
argument_list|()
assert|;
return|return
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|POS
argument_list|)
return|;
block|}
block|}
specifier|public
name|List
argument_list|<
name|SqlNode
argument_list|>
name|toSql
parameter_list|(
name|Window
operator|.
name|Group
name|group
parameter_list|,
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
name|constants
parameter_list|,
name|int
name|inputFieldCount
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|rexOvers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|partitionKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|partition
range|:
name|group
operator|.
name|keys
control|)
block|{
name|partitionKeys
operator|.
name|add
argument_list|(
name|this
operator|.
name|field
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RelFieldCollation
name|collation
range|:
name|group
operator|.
name|orderKeys
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|this
operator|.
name|addOrderItem
argument_list|(
name|orderByKeys
argument_list|,
name|collation
argument_list|)
expr_stmt|;
block|}
name|SqlLiteral
name|isRows
init|=
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
name|group
operator|.
name|isRows
argument_list|,
name|POS
argument_list|)
decl_stmt|;
name|SqlNode
name|lowerBound
init|=
literal|null
decl_stmt|;
name|SqlNode
name|upperBound
init|=
literal|null
decl_stmt|;
specifier|final
name|SqlLiteral
name|allowPartial
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Window
operator|.
name|RexWinAggCall
name|winAggCall
range|:
name|group
operator|.
name|aggCalls
control|)
block|{
name|SqlAggFunction
name|aggFunction
init|=
operator|(
name|SqlAggFunction
operator|)
name|winAggCall
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|SqlWindow
name|sqlWindow
init|=
name|SqlWindow
operator|.
name|create
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|partitionKeys
argument_list|,
name|POS
argument_list|)
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|orderByKeys
argument_list|,
name|POS
argument_list|)
argument_list|,
name|isRows
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|allowPartial
argument_list|,
name|POS
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggFunction
operator|.
name|allowsFraming
argument_list|()
condition|)
block|{
name|lowerBound
operator|=
name|createSqlWindowBound
argument_list|(
name|group
operator|.
name|lowerBound
argument_list|)
expr_stmt|;
name|upperBound
operator|=
name|createSqlWindowBound
argument_list|(
name|group
operator|.
name|upperBound
argument_list|)
expr_stmt|;
name|sqlWindow
operator|.
name|setLowerBound
argument_list|(
name|lowerBound
argument_list|)
expr_stmt|;
name|sqlWindow
operator|.
name|setUpperBound
argument_list|(
name|upperBound
argument_list|)
expr_stmt|;
block|}
name|RexShuttle
name|replaceConstants
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|int
name|index
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|RexNode
name|ref
decl_stmt|;
if|if
condition|(
name|index
operator|>
name|inputFieldCount
operator|-
literal|1
condition|)
block|{
name|ref
operator|=
name|constants
operator|.
name|get
argument_list|(
name|index
operator|-
name|inputFieldCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref
operator|=
name|inputRef
expr_stmt|;
block|}
return|return
name|ref
return|;
block|}
block|}
decl_stmt|;
name|RexCall
name|aggCall
init|=
operator|(
name|RexCall
operator|)
name|winAggCall
operator|.
name|accept
argument_list|(
name|replaceConstants
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|toSql
argument_list|(
literal|null
argument_list|,
name|aggCall
operator|.
name|operands
argument_list|)
decl_stmt|;
name|rexOvers
operator|.
name|add
argument_list|(
name|createOverCall
argument_list|(
name|aggFunction
argument_list|,
name|operands
argument_list|,
name|sqlWindow
argument_list|,
name|winAggCall
operator|.
name|distinct
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexOvers
return|;
block|}
specifier|protected
name|Context
name|getAliasContext
parameter_list|(
name|RexCorrelVariable
name|variable
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|private
name|SqlCall
name|toSql
parameter_list|(
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RexOver
name|rexOver
parameter_list|)
block|{
specifier|final
name|RexWindow
name|rexWindow
init|=
name|rexOver
operator|.
name|getWindow
argument_list|()
decl_stmt|;
specifier|final
name|SqlNodeList
name|partitionList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|toSql
argument_list|(
name|program
argument_list|,
name|rexWindow
operator|.
name|partitionKeys
argument_list|)
argument_list|,
name|POS
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderNodes
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|rexWindow
operator|.
name|orderKeys
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|RexFieldCollation
name|rfc
range|:
name|rexWindow
operator|.
name|orderKeys
control|)
block|{
name|addOrderItem
argument_list|(
name|orderNodes
argument_list|,
name|program
argument_list|,
name|rfc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|SqlNodeList
name|orderList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|orderNodes
argument_list|,
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|isRows
init|=
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
name|rexWindow
operator|.
name|isRows
argument_list|()
argument_list|,
name|POS
argument_list|)
decl_stmt|;
comment|// null defaults to true.
comment|// During parsing the allowPartial == false (e.g. disallow partial)
comment|// is expand into CASE expression and is handled as a such.
comment|// Not sure if we can collapse this CASE expression back into
comment|// "disallow partial" and set the allowPartial = false.
specifier|final
name|SqlLiteral
name|allowPartial
init|=
literal|null
decl_stmt|;
name|SqlAggFunction
name|sqlAggregateFunction
init|=
name|rexOver
operator|.
name|getAggOperator
argument_list|()
decl_stmt|;
name|SqlNode
name|lowerBound
init|=
literal|null
decl_stmt|;
name|SqlNode
name|upperBound
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|sqlAggregateFunction
operator|.
name|allowsFraming
argument_list|()
condition|)
block|{
name|lowerBound
operator|=
name|createSqlWindowBound
argument_list|(
name|rexWindow
operator|.
name|getLowerBound
argument_list|()
argument_list|)
expr_stmt|;
name|upperBound
operator|=
name|createSqlWindowBound
argument_list|(
name|rexWindow
operator|.
name|getUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlWindow
name|sqlWindow
init|=
name|SqlWindow
operator|.
name|create
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|partitionList
argument_list|,
name|orderList
argument_list|,
name|isRows
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|allowPartial
argument_list|,
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodeList
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|rexOver
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|createOverCall
argument_list|(
name|sqlAggregateFunction
argument_list|,
name|nodeList
argument_list|,
name|sqlWindow
argument_list|,
name|rexOver
operator|.
name|isDistinct
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|SqlCall
name|createOverCall
parameter_list|(
name|SqlAggFunction
name|op
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|,
name|SqlWindow
name|window
parameter_list|,
name|boolean
name|isDistinct
parameter_list|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|SqlSumEmptyIsZeroAggFunction
condition|)
block|{
comment|// Rewrite "SUM0(x) OVER w" to "COALESCE(SUM(x) OVER w, 0)"
specifier|final
name|SqlCall
name|node
init|=
name|createOverCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
name|operands
argument_list|,
name|window
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|COALESCE
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
name|ZERO
argument_list|)
return|;
block|}
name|SqlCall
name|aggFunctionCall
decl_stmt|;
if|if
condition|(
name|isDistinct
condition|)
block|{
name|aggFunctionCall
operator|=
name|op
operator|.
name|createCall
argument_list|(
name|SqlSelectKeyword
operator|.
name|DISTINCT
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
argument_list|,
name|POS
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aggFunctionCall
operator|=
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|OVER
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|aggFunctionCall
argument_list|,
name|window
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|toSql
parameter_list|(
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RexFieldCollation
name|rfc
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|rfc
operator|.
name|left
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rfc
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|rfc
operator|.
name|getNullDirection
argument_list|()
operator|!=
name|dialect
operator|.
name|defaultNullDirection
argument_list|(
name|rfc
operator|.
name|getDirection
argument_list|()
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|rfc
operator|.
name|getNullDirection
argument_list|()
condition|)
block|{
case|case
name|FIRST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_FIRST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_LAST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|private
name|SqlNode
name|createSqlWindowBound
parameter_list|(
name|RexWindowBound
name|rexWindowBound
parameter_list|)
block|{
if|if
condition|(
name|rexWindowBound
operator|.
name|isCurrentRow
argument_list|()
condition|)
block|{
return|return
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|POS
argument_list|)
return|;
block|}
if|if
condition|(
name|rexWindowBound
operator|.
name|isPreceding
argument_list|()
condition|)
block|{
if|if
condition|(
name|rexWindowBound
operator|.
name|isUnbounded
argument_list|()
condition|)
block|{
return|return
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|POS
argument_list|)
return|;
block|}
else|else
block|{
name|SqlNode
name|literal
init|=
name|toSql
argument_list|(
literal|null
argument_list|,
name|rexWindowBound
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|SqlWindow
operator|.
name|createPreceding
argument_list|(
name|literal
argument_list|,
name|POS
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|rexWindowBound
operator|.
name|isFollowing
argument_list|()
condition|)
block|{
if|if
condition|(
name|rexWindowBound
operator|.
name|isUnbounded
argument_list|()
condition|)
block|{
return|return
name|SqlWindow
operator|.
name|createUnboundedFollowing
argument_list|(
name|POS
argument_list|)
return|;
block|}
else|else
block|{
name|SqlNode
name|literal
init|=
name|toSql
argument_list|(
literal|null
argument_list|,
name|rexWindowBound
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|SqlWindow
operator|.
name|createFollowing
argument_list|(
name|literal
argument_list|,
name|POS
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unsupported Window bound: "
operator|+
name|rexWindowBound
argument_list|)
throw|;
block|}
specifier|private
name|List
argument_list|<
name|SqlNode
argument_list|>
name|toSql
parameter_list|(
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operandList
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|operandList
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|toSql
argument_list|(
name|program
argument_list|,
name|rex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|public
name|List
argument_list|<
name|SqlNode
argument_list|>
name|fieldList
parameter_list|()
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SqlNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|field
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fieldCount
return|;
block|}
block|}
return|;
block|}
name|void
name|addOrderItem
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
parameter_list|,
name|RelFieldCollation
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|nullDirection
operator|!=
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
condition|)
block|{
specifier|final
name|boolean
name|first
init|=
name|field
operator|.
name|nullDirection
operator|==
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
decl_stmt|;
name|SqlNode
name|nullDirectionNode
init|=
name|dialect
operator|.
name|emulateNullDirection
argument_list|(
name|field
argument_list|(
name|field
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
argument_list|,
name|first
argument_list|,
name|field
operator|.
name|direction
operator|.
name|isDescending
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullDirectionNode
operator|!=
literal|null
condition|)
block|{
name|orderByList
operator|.
name|add
argument_list|(
name|nullDirectionNode
argument_list|)
expr_stmt|;
name|field
operator|=
operator|new
name|RelFieldCollation
argument_list|(
name|field
operator|.
name|getFieldIndex
argument_list|()
argument_list|,
name|field
operator|.
name|getDirection
argument_list|()
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
argument_list|)
expr_stmt|;
block|}
block|}
name|orderByList
operator|.
name|add
argument_list|(
name|toSql
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Converts a RexFieldCollation to an ORDER BY item. */
specifier|private
name|void
name|addOrderItem
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
parameter_list|,
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RexFieldCollation
name|field
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|field
operator|.
name|left
argument_list|)
decl_stmt|;
name|SqlNode
name|nullDirectionNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getNullDirection
argument_list|()
operator|!=
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
condition|)
block|{
specifier|final
name|boolean
name|first
init|=
name|field
operator|.
name|getNullDirection
argument_list|()
operator|==
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
decl_stmt|;
name|nullDirectionNode
operator|=
name|dialect
operator|.
name|emulateNullDirection
argument_list|(
name|node
argument_list|,
name|first
argument_list|,
name|field
operator|.
name|getDirection
argument_list|()
operator|.
name|isDescending
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullDirectionNode
operator|!=
literal|null
condition|)
block|{
name|orderByList
operator|.
name|add
argument_list|(
name|nullDirectionNode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|orderByList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|orderByList
operator|.
name|add
argument_list|(
name|toSql
argument_list|(
name|program
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Converts a call to an aggregate function to an expression. */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|AggregateCall
name|aggCall
parameter_list|)
block|{
return|return
name|toSql
argument_list|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|aggCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|Util
operator|.
name|transform
argument_list|(
name|aggCall
operator|.
name|getArgList
argument_list|()
argument_list|,
name|this
operator|::
name|field
argument_list|)
argument_list|,
name|aggCall
operator|.
name|filterArg
argument_list|,
name|aggCall
operator|.
name|collation
argument_list|,
name|aggCall
operator|.
name|isApproximate
argument_list|()
argument_list|)
return|;
block|}
comment|/** Converts a call to an aggregate function, with a given list of operands,      * to an expression. */
specifier|private
name|SqlCall
name|toSql
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
parameter_list|,
name|int
name|filterArg
parameter_list|,
name|RelCollation
name|collation
parameter_list|,
name|boolean
name|approximate
parameter_list|)
block|{
specifier|final
name|SqlLiteral
name|qualifier
init|=
name|distinct
condition|?
name|SqlSelectKeyword
operator|.
name|DISTINCT
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|SqlSumEmptyIsZeroAggFunction
condition|)
block|{
specifier|final
name|SqlNode
name|node
init|=
name|toSql
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
name|distinct
argument_list|,
name|operandList
argument_list|,
name|filterArg
argument_list|,
name|collation
argument_list|,
name|approximate
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|COALESCE
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
name|ZERO
argument_list|)
return|;
block|}
comment|// Handle filter on dialects that do support FILTER by generating CASE.
if|if
condition|(
name|filterArg
operator|>=
literal|0
operator|&&
operator|!
name|dialect
operator|.
name|supportsAggregateFunctionFilter
argument_list|()
condition|)
block|{
comment|// SUM(x) FILTER(WHERE b)  ==>  SUM(CASE WHEN b THEN x END)
comment|// COUNT(*) FILTER(WHERE b)  ==>  COUNT(CASE WHEN b THEN 1 END)
comment|// COUNT(x) FILTER(WHERE b)  ==>  COUNT(CASE WHEN b THEN x END)
comment|// COUNT(x, y) FILTER(WHERE b)  ==>  COUNT(CASE WHEN b THEN x END, y)
specifier|final
name|SqlNodeList
name|whenList
init|=
name|SqlNodeList
operator|.
name|of
argument_list|(
name|field
argument_list|(
name|filterArg
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|thenList
init|=
name|SqlNodeList
operator|.
name|of
argument_list|(
name|operandList
operator|.
name|isEmpty
argument_list|()
condition|?
name|ONE
else|:
name|operandList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|elseList
init|=
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|SqlCall
name|caseCall
init|=
name|SqlStdOperatorTable
operator|.
name|CASE
operator|.
name|createCall
argument_list|(
literal|null
argument_list|,
name|POS
argument_list|,
literal|null
argument_list|,
name|whenList
argument_list|,
name|thenList
argument_list|,
name|elseList
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|newOperandList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|newOperandList
operator|.
name|add
argument_list|(
name|caseCall
argument_list|)
expr_stmt|;
if|if
condition|(
name|operandList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|newOperandList
operator|.
name|addAll
argument_list|(
name|Util
operator|.
name|skip
argument_list|(
name|operandList
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|toSql
argument_list|(
name|op
argument_list|,
name|distinct
argument_list|,
name|newOperandList
argument_list|,
operator|-
literal|1
argument_list|,
name|collation
argument_list|,
name|approximate
argument_list|)
return|;
block|}
if|if
condition|(
name|op
operator|instanceof
name|SqlCountAggFunction
operator|&&
name|operandList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If there is no parameter in "count" function, add a star identifier
comment|// to it.
name|operandList
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlIdentifier
operator|.
name|STAR
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlCall
name|call
init|=
name|op
operator|.
name|createCall
argument_list|(
name|qualifier
argument_list|,
name|POS
argument_list|,
name|operandList
argument_list|)
decl_stmt|;
comment|// Handle filter by generating FILTER (WHERE ...)
specifier|final
name|SqlCall
name|call2
decl_stmt|;
if|if
condition|(
name|distinct
operator|&&
name|approximate
operator|&&
name|dialect
operator|.
name|supportsApproxCountDistinct
argument_list|()
condition|)
block|{
name|call2
operator|=
name|SqlStdOperatorTable
operator|.
name|APPROX_COUNT_DISTINCT
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operandList
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|filterArg
operator|<
literal|0
condition|)
block|{
name|call2
operator|=
name|call
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|dialect
operator|.
name|supportsAggregateFunctionFilter
argument_list|()
assert|;
comment|// we checked above
name|call2
operator|=
name|SqlStdOperatorTable
operator|.
name|FILTER
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|call
argument_list|,
name|field
argument_list|(
name|filterArg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Handle collation
return|return
name|withOrder
argument_list|(
name|call2
argument_list|,
name|collation
argument_list|)
return|;
block|}
comment|/** Wraps a call in a {@link SqlKind#WITHIN_GROUP} call, if      * {@code collation} is non-empty. */
specifier|private
name|SqlCall
name|withOrder
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|RelCollation
name|collation
parameter_list|)
block|{
if|if
condition|(
name|collation
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|call
return|;
block|}
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|field
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|addOrderItem
argument_list|(
name|orderByList
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|WITHIN_GROUP
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|call
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|orderByList
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
comment|/** Converts a collation to an ORDER BY item. */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|RelFieldCollation
name|collation
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|orderField
argument_list|(
name|collation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|collation
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|collation
operator|.
name|nullDirection
operator|!=
name|dialect
operator|.
name|defaultNullDirection
argument_list|(
name|collation
operator|.
name|direction
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|collation
operator|.
name|nullDirection
condition|)
block|{
case|case
name|FIRST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_FIRST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_LAST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|public
specifier|abstract
name|SqlImplementor
name|implementor
parameter_list|()
function_decl|;
comment|/** Converts a {@link Range} to a SQL expression.      *      * @param<C> Value type */
specifier|private
specifier|static
class|class
name|RangeToSql
parameter_list|<
name|C
extends|extends
name|Comparable
parameter_list|<
name|C
parameter_list|>
parameter_list|>
implements|implements
name|RangeSets
operator|.
name|Consumer
argument_list|<
name|C
argument_list|>
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
decl_stmt|;
specifier|private
specifier|final
name|Function
argument_list|<
name|C
argument_list|,
name|SqlNode
argument_list|>
name|literalFactory
decl_stmt|;
specifier|private
specifier|final
name|SqlNode
name|arg
decl_stmt|;
name|RangeToSql
parameter_list|(
name|SqlNode
name|arg
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
parameter_list|,
name|Function
argument_list|<
name|C
argument_list|,
name|SqlNode
argument_list|>
name|literalFactory
parameter_list|)
block|{
name|this
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
name|this
operator|.
name|literalFactory
operator|=
name|literalFactory
expr_stmt|;
block|}
specifier|private
name|void
name|addAnd
parameter_list|(
name|SqlNode
modifier|...
name|nodes
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
name|SqlUtil
operator|.
name|createCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|POS
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|SqlNode
name|op
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|C
name|value
parameter_list|)
block|{
return|return
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|arg
argument_list|,
name|literalFactory
operator|.
name|apply
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|all
parameter_list|()
block|{
name|list
operator|.
name|add
argument_list|(
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|true
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|atLeast
parameter_list|(
name|C
name|lower
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|lower
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|atMost
parameter_list|(
name|C
name|upper
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|greaterThan
parameter_list|(
name|C
name|lower
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|lower
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|lessThan
parameter_list|(
name|C
name|upper
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|singleton
parameter_list|(
name|C
name|value
parameter_list|)
block|{
name|list
operator|.
name|add
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|closed
parameter_list|(
name|C
name|lower
parameter_list|,
name|C
name|upper
parameter_list|)
block|{
name|addAnd
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|lower
argument_list|)
argument_list|,
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|closedOpen
parameter_list|(
name|C
name|lower
parameter_list|,
name|C
name|upper
parameter_list|)
block|{
name|addAnd
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
name|lower
argument_list|)
argument_list|,
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|openClosed
parameter_list|(
name|C
name|lower
parameter_list|,
name|C
name|upper
parameter_list|)
block|{
name|addAnd
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|lower
argument_list|)
argument_list|,
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|open
parameter_list|(
name|C
name|lower
parameter_list|,
name|C
name|upper
parameter_list|)
block|{
name|addAnd
argument_list|(
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|,
name|lower
argument_list|)
argument_list|,
name|op
argument_list|(
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|,
name|upper
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Converts a {@link RexLiteral} in the context of a {@link RexProgram}    * to a {@link SqlNode}. */
specifier|public
specifier|static
name|SqlNode
name|toSql
parameter_list|(
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RexLiteral
name|literal
parameter_list|)
block|{
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|SYMBOL
case|:
specifier|final
name|Enum
name|symbol
init|=
operator|(
name|Enum
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|SqlLiteral
operator|.
name|createSymbol
argument_list|(
name|symbol
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|ROW
case|:
comment|//noinspection unchecked
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|list
init|=
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|List
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|ROW
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|list
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|e
lambda|->
name|toSql
argument_list|(
name|program
argument_list|,
name|e
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|SARG
case|:
specifier|final
name|Sarg
name|arg
init|=
name|literal
operator|.
name|getValueAs
argument_list|(
name|Sarg
operator|.
name|class
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"sargs ["
operator|+
name|arg
operator|+
literal|"] should be handled as part of predicates, not as literals"
argument_list|)
throw|;
default|default:
return|return
name|toSql
argument_list|(
name|literal
argument_list|)
return|;
block|}
block|}
comment|/** Converts a {@link RexLiteral} to a {@link SqlLiteral}. */
specifier|public
specifier|static
name|SqlNode
name|toSql
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|literal
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|SYMBOL
case|:
specifier|final
name|Enum
name|symbol
init|=
operator|(
name|Enum
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|SqlLiteral
operator|.
name|createSymbol
argument_list|(
name|symbol
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|ROW
case|:
comment|//noinspection unchecked
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|list
init|=
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|List
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|ROW
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|list
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|e
lambda|->
name|toSql
argument_list|(
name|e
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Util
operator|.
name|toImmutableList
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|SARG
case|:
specifier|final
name|Sarg
name|arg
init|=
name|literal
operator|.
name|getValueAs
argument_list|(
name|Sarg
operator|.
name|class
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"sargs ["
operator|+
name|arg
operator|+
literal|"] should be handled as part of predicates, not as literals"
argument_list|)
throw|;
default|default:
break|break;
block|}
name|SqlTypeFamily
name|family
init|=
name|requireNonNull
argument_list|(
name|typeName
operator|.
name|getFamily
argument_list|()
argument_list|,
parameter_list|()
lambda|->
literal|"literal "
operator|+
name|literal
operator|+
literal|" has null SqlTypeFamily, and is SqlTypeName is "
operator|+
name|typeName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|CHARACTER
case|:
return|return
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
operator|(
name|String
operator|)
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValue2
argument_list|()
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|NUMERIC
case|:
case|case
name|EXACT_NUMERIC
case|:
return|return
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
argument_list|)
operator|.
name|toPlainString
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|APPROXIMATE_NUMERIC
case|:
return|return
name|SqlLiteral
operator|.
name|createApproxNumeric
argument_list|(
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
argument_list|)
operator|.
name|toPlainString
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|BOOLEAN
case|:
return|return
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|Boolean
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
specifier|final
name|boolean
name|negative
init|=
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|Boolean
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|SqlLiteral
operator|.
name|createInterval
argument_list|(
name|negative
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|,
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|String
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
name|castNonNull
argument_list|(
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getIntervalQualifier
argument_list|()
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|DATE
case|:
return|return
name|SqlLiteral
operator|.
name|createDate
argument_list|(
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|DateString
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|TIME
case|:
return|return
name|SqlLiteral
operator|.
name|createTime
argument_list|(
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|TimeString
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|SqlLiteral
operator|.
name|createTimestamp
argument_list|(
name|castNonNull
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|TimestampString
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|ANY
case|:
case|case
name|NULL
case|:
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|NULL
case|:
return|return
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|POS
argument_list|)
return|;
default|default:
break|break;
block|}
comment|// fall through
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|literal
operator|+
literal|": "
operator|+
name|typeName
argument_list|)
throw|;
block|}
block|}
comment|/** Simple implementation of {@link Context} that cannot handle sub-queries    * or correlations. Because it is so simple, you do not need to create a    * {@link SqlImplementor} or {@link org.apache.calcite.tools.RelBuilder}    * to use it. It is a good way to convert a {@link RexNode} to SQL text. */
specifier|public
specifier|static
class|class
name|SimpleContext
extends|extends
name|Context
block|{
specifier|private
specifier|final
name|IntFunction
argument_list|<
name|SqlNode
argument_list|>
name|field
decl_stmt|;
specifier|public
name|SimpleContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|IntFunction
argument_list|<
name|SqlNode
argument_list|>
name|field
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlImplementor
name|implementor
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|field
operator|.
name|apply
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link Context} that has an enclosing    * {@link SqlImplementor} and can therefore do non-trivial expressions. */
specifier|protected
specifier|abstract
class|class
name|BaseContext
extends|extends
name|Context
block|{
name|BaseContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|int
name|fieldCount
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|fieldCount
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Context
name|getAliasContext
parameter_list|(
name|RexCorrelVariable
name|variable
parameter_list|)
block|{
return|return
name|requireNonNull
argument_list|(
name|correlTableMap
operator|.
name|get
argument_list|(
name|variable
operator|.
name|id
argument_list|)
argument_list|,
parameter_list|()
lambda|->
literal|"variable "
operator|+
name|variable
operator|.
name|id
operator|+
literal|" is not found"
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlImplementor
name|implementor
parameter_list|()
block|{
return|return
name|SqlImplementor
operator|.
name|this
return|;
block|}
block|}
specifier|private
specifier|static
name|int
name|computeFieldCount
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelDataType
name|type
range|:
name|aliases
operator|.
name|values
argument_list|()
control|)
block|{
name|x
operator|+=
name|type
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
specifier|public
name|Context
name|aliasContext
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|,
name|boolean
name|qualified
parameter_list|)
block|{
return|return
operator|new
name|AliasContext
argument_list|(
name|dialect
argument_list|,
name|aliases
argument_list|,
name|qualified
argument_list|)
return|;
block|}
specifier|public
name|Context
name|joinContext
parameter_list|(
name|Context
name|leftContext
parameter_list|,
name|Context
name|rightContext
parameter_list|)
block|{
return|return
operator|new
name|JoinContext
argument_list|(
name|dialect
argument_list|,
name|leftContext
argument_list|,
name|rightContext
argument_list|)
return|;
block|}
specifier|public
name|Context
name|matchRecognizeContext
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
return|return
operator|new
name|MatchRecognizeContext
argument_list|(
name|dialect
argument_list|,
operator|(
operator|(
name|AliasContext
operator|)
name|context
operator|)
operator|.
name|aliases
argument_list|)
return|;
block|}
specifier|public
name|Context
name|tableFunctionScanContext
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|inputSqlNodes
parameter_list|)
block|{
return|return
operator|new
name|TableFunctionScanContext
argument_list|(
name|dialect
argument_list|,
name|inputSqlNodes
argument_list|)
return|;
block|}
comment|/** Context for translating MATCH_RECOGNIZE clause. */
specifier|public
class|class
name|MatchRecognizeContext
extends|extends
name|AliasContext
block|{
specifier|protected
name|MatchRecognizeContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|aliases
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|toSql
parameter_list|(
annotation|@
name|Nullable
name|RexProgram
name|program
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
name|rex
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL
condition|)
block|{
specifier|final
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
condition|)
block|{
return|return
operator|new
name|SqlIdentifier
argument_list|(
name|castNonNull
argument_list|(
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|literal
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
block|}
return|return
name|super
operator|.
name|toSql
argument_list|(
name|program
argument_list|,
name|rex
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of Context that precedes field references with their    * "table alias" based on the current sub-query's FROM clause. */
specifier|public
class|class
name|AliasContext
extends|extends
name|BaseContext
block|{
specifier|private
specifier|final
name|boolean
name|qualified
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
decl_stmt|;
comment|/** Creates an AliasContext; use {@link #aliasContext(Map, boolean)}. */
specifier|protected
name|AliasContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|,
name|boolean
name|qualified
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|computeFieldCount
argument_list|(
name|aliases
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
name|this
operator|.
name|qualified
operator|=
name|qualified
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|alias
range|:
name|aliases
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|alias
operator|.
name|getValue
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|ordinal
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlIdentifier
argument_list|(
operator|!
name|qualified
condition|?
name|ImmutableList
operator|.
name|of
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
else|:
name|ImmutableList
operator|.
name|of
argument_list|(
name|alias
operator|.
name|getKey
argument_list|()
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
name|ordinal
operator|-=
name|fields
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"field ordinal "
operator|+
name|ordinal
operator|+
literal|" out of range "
operator|+
name|aliases
argument_list|)
throw|;
block|}
block|}
comment|/** Context for translating ON clause of a JOIN from {@link RexNode} to    * {@link SqlNode}. */
class|class
name|JoinContext
extends|extends
name|BaseContext
block|{
specifier|private
specifier|final
name|SqlImplementor
operator|.
name|Context
name|leftContext
decl_stmt|;
specifier|private
specifier|final
name|SqlImplementor
operator|.
name|Context
name|rightContext
decl_stmt|;
comment|/** Creates a JoinContext; use {@link #joinContext(Context, Context)}. */
specifier|private
name|JoinContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|Context
name|leftContext
parameter_list|,
name|Context
name|rightContext
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|leftContext
operator|.
name|fieldCount
operator|+
name|rightContext
operator|.
name|fieldCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|leftContext
operator|=
name|leftContext
expr_stmt|;
name|this
operator|.
name|rightContext
operator|=
name|rightContext
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
if|if
condition|(
name|ordinal
operator|<
name|leftContext
operator|.
name|fieldCount
condition|)
block|{
return|return
name|leftContext
operator|.
name|field
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rightContext
operator|.
name|field
argument_list|(
name|ordinal
operator|-
name|leftContext
operator|.
name|fieldCount
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|RexCall
name|reverseCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|IS_DISTINCT_FROM
case|:
case|case
name|IS_NOT_DISTINCT_FROM
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
assert|assert
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
specifier|final
name|RexNode
name|op0
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|op1
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|instanceof
name|RexInputRef
operator|&&
name|op1
operator|instanceof
name|RexInputRef
operator|&&
operator|(
operator|(
name|RexInputRef
operator|)
name|op1
operator|)
operator|.
name|getIndex
argument_list|()
operator|<
name|leftContext
operator|.
name|fieldCount
operator|&&
operator|(
operator|(
name|RexInputRef
operator|)
name|op0
operator|)
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftContext
operator|.
name|fieldCount
condition|)
block|{
comment|// Arguments were of form 'op1 = op0'
specifier|final
name|SqlOperator
name|op2
init|=
name|requireNonNull
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|reverse
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|RexCall
operator|)
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|op2
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
block|}
comment|// fall through
default|default:
return|return
name|call
return|;
block|}
block|}
block|}
comment|/** Context for translating call of a TableFunctionScan from {@link RexNode} to    * {@link SqlNode}. */
class|class
name|TableFunctionScanContext
extends|extends
name|BaseContext
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|inputSqlNodes
decl_stmt|;
name|TableFunctionScanContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|inputSqlNodes
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|inputSqlNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputSqlNodes
operator|=
name|inputSqlNodes
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|inputSqlNodes
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
block|}
comment|/** Result of implementing a node. */
specifier|public
class|class
name|Result
block|{
specifier|final
name|SqlNode
name|node
decl_stmt|;
specifier|final
annotation|@
name|Nullable
name|String
name|neededAlias
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|RelDataType
name|neededType
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|anon
decl_stmt|;
comment|/** Whether to treat {@link #expectedClauses} as empty for the      * purposes of figuring out whether we need a new sub-query. */
specifier|private
specifier|final
name|boolean
name|ignoreClauses
decl_stmt|;
comment|/** Clauses that will be generated to implement current relational      * expression. */
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Clause
argument_list|>
name|expectedClauses
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|RelNode
name|expectedRel
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|needNew
decl_stmt|;
specifier|public
name|Result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
annotation|@
name|Nullable
name|String
name|neededAlias
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|neededType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
name|this
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|neededAlias
argument_list|,
name|neededType
argument_list|,
name|aliases
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
annotation|@
name|Nullable
name|String
name|neededAlias
parameter_list|,
annotation|@
name|Nullable
name|RelDataType
name|neededType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|,
name|boolean
name|anon
parameter_list|,
name|boolean
name|ignoreClauses
parameter_list|,
name|Set
argument_list|<
name|Clause
argument_list|>
name|expectedClauses
parameter_list|,
annotation|@
name|Nullable
name|RelNode
name|expectedRel
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|neededAlias
operator|=
name|neededAlias
expr_stmt|;
name|this
operator|.
name|neededType
operator|=
name|neededType
expr_stmt|;
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
name|this
operator|.
name|clauses
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
name|this
operator|.
name|anon
operator|=
name|anon
expr_stmt|;
name|this
operator|.
name|ignoreClauses
operator|=
name|ignoreClauses
expr_stmt|;
name|this
operator|.
name|expectedClauses
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|expectedClauses
argument_list|)
expr_stmt|;
name|this
operator|.
name|expectedRel
operator|=
name|expectedRel
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|Clause
argument_list|>
name|clauses2
init|=
name|ignoreClauses
condition|?
name|ImmutableSet
operator|.
name|of
argument_list|()
else|:
name|expectedClauses
decl_stmt|;
name|this
operator|.
name|needNew
operator|=
name|expectedRel
operator|!=
literal|null
operator|&&
name|needNewSubQuery
argument_list|(
name|expectedRel
argument_list|,
name|this
operator|.
name|clauses
argument_list|,
name|clauses2
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a builder for the SQL of the given relational expression,      * using the clauses that you declared when you called      * {@link #visitInput(RelNode, int, Set)}. */
specifier|public
name|Builder
name|builder
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|builder
argument_list|(
name|rel
argument_list|,
name|expectedClauses
argument_list|)
return|;
block|}
comment|// CHECKSTYLE: IGNORE 3
comment|/** @deprecated Provide the expected clauses up-front, when you call      * {@link #visitInput(RelNode, int, Set)}, then create a builder using      * {@link #builder(RelNode)}. */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|Builder
name|builder
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Clause
name|clause
parameter_list|,
name|Clause
modifier|...
name|clauses
parameter_list|)
block|{
return|return
name|builder
argument_list|(
name|rel
argument_list|,
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|Lists
operator|.
name|asList
argument_list|(
name|clause
argument_list|,
name|clauses
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Once you have a Result of implementing a child relational expression,      * call this method to create a Builder to implement the current relational      * expression by adding additional clauses to the SQL query.      *      *<p>You need to declare which clauses you intend to add. If the clauses      * are "later", you can add to the same query. For example, "GROUP BY" comes      * after "WHERE". But if they are the same or earlier, this method will      * start a new SELECT that wraps the previous result.      *      *<p>When you have called      * {@link Builder#setSelect(SqlNodeList)},      * {@link Builder#setWhere(SqlNode)} etc. call      * {@link Builder#result(SqlNode, Collection, RelNode, Map)}      * to fix the new query.      *      * @param rel Relational expression being implemented      * @return A builder      */
specifier|private
name|Builder
name|builder
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Set
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|)
block|{
assert|assert
name|expectedClauses
operator|.
name|containsAll
argument_list|(
name|clauses
argument_list|)
assert|;
assert|assert
name|rel
operator|.
name|equals
argument_list|(
name|expectedRel
argument_list|)
assert|;
specifier|final
name|Set
argument_list|<
name|Clause
argument_list|>
name|clauses2
init|=
name|ignoreClauses
condition|?
name|ImmutableSet
operator|.
name|of
argument_list|()
else|:
name|clauses
decl_stmt|;
specifier|final
name|boolean
name|needNew
init|=
name|needNewSubQuery
argument_list|(
name|rel
argument_list|,
name|this
operator|.
name|clauses
argument_list|,
name|clauses2
argument_list|)
decl_stmt|;
assert|assert
name|needNew
operator|==
name|this
operator|.
name|needNew
assert|;
name|SqlSelect
name|select
decl_stmt|;
name|Expressions
operator|.
name|FluentList
argument_list|<
name|Clause
argument_list|>
name|clauseList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|needNew
condition|)
block|{
name|select
operator|=
name|subSelect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|select
operator|=
name|asSelect
argument_list|()
expr_stmt|;
name|clauseList
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|clauses
argument_list|)
expr_stmt|;
block|}
name|clauseList
operator|.
name|appendAll
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
specifier|final
name|Context
name|newContext
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|newAliases
init|=
literal|null
decl_stmt|;
specifier|final
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|selectList
operator|.
name|equals
argument_list|(
name|SqlNodeList
operator|.
name|SINGLETON_STAR
argument_list|)
condition|)
block|{
specifier|final
name|boolean
name|aliasRef
init|=
name|expectedClauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|HAVING
argument_list|)
operator|&&
name|dialect
operator|.
name|getConformance
argument_list|()
operator|.
name|isHavingAlias
argument_list|()
decl_stmt|;
name|newContext
operator|=
operator|new
name|Context
argument_list|(
name|dialect
argument_list|,
name|selectList
operator|.
name|size
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|SqlImplementor
name|implementor
parameter_list|()
block|{
return|return
name|SqlImplementor
operator|.
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|SqlNode
name|selectItem
init|=
name|selectList
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|selectItem
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
specifier|final
name|SqlCall
name|asCall
init|=
operator|(
name|SqlCall
operator|)
name|selectItem
decl_stmt|;
name|SqlNode
name|alias
init|=
name|asCall
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliasRef
operator|&&
operator|!
name|SqlUtil
operator|.
name|isGeneratedAlias
argument_list|(
operator|(
operator|(
name|SqlIdentifier
operator|)
name|alias
operator|)
operator|.
name|getSimple
argument_list|()
argument_list|)
condition|)
block|{
comment|// For BigQuery, given the query
comment|//   SELECT SUM(x) AS x FROM t HAVING(SUM(t.x)> 0)
comment|// we can generate
comment|//   SELECT SUM(x) AS x FROM t HAVING(x> 0)
comment|// because 'x' in HAVING resolves to the 'AS x' not 't.x'.
return|return
name|alias
return|;
block|}
return|return
name|asCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|selectItem
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|orderField
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
comment|// If the field expression is an unqualified column identifier
comment|// and matches a different alias, use an ordinal.
comment|// For example, given
comment|//    SELECT deptno AS empno, empno AS x FROM emp ORDER BY emp.empno
comment|// we generate
comment|//    SELECT deptno AS empno, empno AS x FROM emp ORDER BY 2
comment|// "ORDER BY empno" would give incorrect result;
comment|// "ORDER BY x" is acceptable but is not preferred.
specifier|final
name|SqlNode
name|node
init|=
name|super
operator|.
name|orderField
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlIdentifier
operator|&&
operator|(
operator|(
name|SqlIdentifier
operator|)
name|node
operator|)
operator|.
name|isSimple
argument_list|()
condition|)
block|{
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|SqlIdentifier
operator|)
name|node
operator|)
operator|.
name|getSimple
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|selectItem
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|selectList
argument_list|)
control|)
block|{
if|if
condition|(
name|selectItem
operator|.
name|i
operator|!=
name|ordinal
condition|)
block|{
specifier|final
annotation|@
name|Nullable
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|alias
argument_list|(
name|selectItem
operator|.
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
name|alias
argument_list|)
condition|)
block|{
return|return
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|ordinal
operator|+
literal|1
argument_list|)
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
name|node
return|;
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|qualified
init|=
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
operator|||
name|aliases
operator|.
name|size
argument_list|()
operator|>
literal|1
decl_stmt|;
comment|// basically, we did a subSelect() since needNew is set and neededAlias is not null
comment|// now, we need to make sure that we need to update the alias context.
comment|// if our aliases map has a single element:<neededAlias, rowType>,
comment|// then we don't need to rewrite the alias but otherwise, it should be updated.
if|if
condition|(
name|needNew
operator|&&
name|neededAlias
operator|!=
literal|null
operator|&&
operator|(
name|aliases
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
operator|!
name|aliases
operator|.
name|containsKey
argument_list|(
name|neededAlias
argument_list|)
operator|)
condition|)
block|{
name|newAliases
operator|=
name|ImmutableMap
operator|.
name|of
argument_list|(
name|neededAlias
argument_list|,
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
name|newContext
operator|=
name|aliasContext
argument_list|(
name|newAliases
argument_list|,
name|qualified
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newContext
operator|=
name|aliasContext
argument_list|(
name|aliases
argument_list|,
name|qualified
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Builder
argument_list|(
name|rel
argument_list|,
name|clauseList
argument_list|,
name|select
argument_list|,
name|newContext
argument_list|,
name|isAnon
argument_list|()
argument_list|,
name|needNew
operator|&&
operator|!
name|aliases
operator|.
name|containsKey
argument_list|(
name|neededAlias
argument_list|)
condition|?
name|newAliases
else|:
name|aliases
argument_list|)
return|;
block|}
comment|/** Returns whether a new sub-query is required. */
specifier|private
name|boolean
name|needNewSubQuery
parameter_list|(
annotation|@
name|UnknownInitialization
name|Result
name|this
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|Set
argument_list|<
name|Clause
argument_list|>
name|expectedClauses
parameter_list|)
block|{
if|if
condition|(
name|clauses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|Clause
name|maxClause
init|=
name|Collections
operator|.
name|max
argument_list|(
name|clauses
argument_list|)
decl_stmt|;
comment|// If old and new clause are equal and belong to below set,
comment|// then new SELECT wrap is not required
specifier|final
name|Set
argument_list|<
name|Clause
argument_list|>
name|nonWrapSet
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|SELECT
argument_list|)
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|expectedClauses
control|)
block|{
if|if
condition|(
name|maxClause
operator|.
name|ordinal
argument_list|()
operator|>
name|clause
operator|.
name|ordinal
argument_list|()
operator|||
operator|(
name|maxClause
operator|==
name|clause
operator|&&
operator|!
name|nonWrapSet
operator|.
name|contains
argument_list|(
name|clause
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|rel
operator|instanceof
name|Project
operator|&&
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|HAVING
argument_list|)
operator|&&
name|dialect
operator|.
name|getConformance
argument_list|()
operator|.
name|isHavingAlias
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|Project
operator|&&
operator|(
operator|(
name|Project
operator|)
name|rel
operator|)
operator|.
name|containsOver
argument_list|()
operator|&&
name|maxClause
operator|==
name|Clause
operator|.
name|SELECT
condition|)
block|{
comment|// Cannot merge a Project that contains windowed functions onto an
comment|// underlying Project
return|return
literal|true
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|Aggregate
condition|)
block|{
specifier|final
name|Aggregate
name|agg
init|=
operator|(
name|Aggregate
operator|)
name|rel
decl_stmt|;
specifier|final
name|boolean
name|hasNestedAgg
init|=
name|hasNested
argument_list|(
name|agg
argument_list|,
name|SqlImplementor
operator|::
name|isAggregate
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|hasNestedWindowedAgg
init|=
name|hasNested
argument_list|(
name|agg
argument_list|,
name|SqlImplementor
operator|::
name|isWindowedAggregate
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dialect
operator|.
name|supportsNestedAggregations
argument_list|()
operator|&&
operator|(
name|hasNestedAgg
operator|||
name|hasNestedWindowedAgg
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|GROUP_BY
argument_list|)
condition|)
block|{
comment|// Avoid losing the distinct attribute of inner aggregate.
return|return
operator|!
name|hasNestedAgg
operator|||
name|Aggregate
operator|.
name|isNotGrandTotal
argument_list|(
name|agg
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns whether an {@link Aggregate} contains nested operands that      * match the predicate.      *      * @param aggregate Aggregate node      * @param operandPredicate Predicate for the nested operands      * @return whether any nested operands matches the predicate */
specifier|private
name|boolean
name|hasNested
parameter_list|(
annotation|@
name|UnknownInitialization
name|Result
name|this
parameter_list|,
name|Aggregate
name|aggregate
parameter_list|,
name|Predicate
argument_list|<
name|SqlNode
argument_list|>
name|operandPredicate
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlSelect
condition|)
block|{
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|(
operator|(
name|SqlSelect
operator|)
name|node
operator|)
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|selectList
operator|.
name|equals
argument_list|(
name|SqlNodeList
operator|.
name|SINGLETON_STAR
argument_list|)
condition|)
block|{
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|aggregatesArgs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
name|aggregatesArgs
operator|.
name|addAll
argument_list|(
name|aggregateCall
operator|.
name|getArgList
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|aggregatesArg
range|:
name|aggregatesArgs
control|)
block|{
if|if
condition|(
name|selectList
operator|.
name|get
argument_list|(
name|aggregatesArg
argument_list|)
operator|instanceof
name|SqlBasicCall
condition|)
block|{
specifier|final
name|SqlBasicCall
name|call
init|=
operator|(
name|SqlBasicCall
operator|)
name|selectList
operator|.
name|get
argument_list|(
name|aggregatesArg
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|!=
literal|null
operator|&&
name|operandPredicate
operator|.
name|test
argument_list|(
name|operand
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns the highest clause that is in use. */
annotation|@
name|Deprecated
specifier|public
name|Clause
name|maxClause
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|max
argument_list|(
name|clauses
argument_list|)
return|;
block|}
comment|/** Returns a node that can be included in the FROM clause or a JOIN. It has      * an alias that is unique within the query. The alias is implicit if it      * can be derived using the usual rules (For example, "SELECT * FROM emp" is      * equivalent to "SELECT * FROM emp AS emp".) */
specifier|public
name|SqlNode
name|asFrom
parameter_list|()
block|{
if|if
condition|(
name|neededAlias
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
condition|)
block|{
comment|// If we already have an AS node, we need to replace the alias
comment|// This is especially relevant for the VALUES clause rendering
name|SqlCall
name|sqlCall
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"assignment.type.incompatible"
argument_list|)
name|SqlNode
index|[]
name|operands
init|=
name|sqlCall
operator|.
name|getOperandList
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|SqlNode
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
operator|new
name|SqlIdentifier
argument_list|(
name|neededAlias
argument_list|,
name|POS
argument_list|)
expr_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operands
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|neededAlias
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|public
name|SqlSelect
name|subSelect
parameter_list|()
block|{
return|return
name|wrapSelect
argument_list|(
name|asFrom
argument_list|()
argument_list|)
return|;
block|}
comment|/** Converts a non-query node into a SELECT node. Set operators (UNION,      * INTERSECT, EXCEPT) remain as is. */
specifier|public
name|SqlSelect
name|asSelect
parameter_list|()
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlSelect
condition|)
block|{
return|return
operator|(
name|SqlSelect
operator|)
name|node
return|;
block|}
if|if
condition|(
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
condition|)
block|{
return|return
name|wrapSelect
argument_list|(
name|asFrom
argument_list|()
argument_list|)
return|;
block|}
return|return
name|wrapSelect
argument_list|(
name|node
argument_list|)
return|;
block|}
specifier|public
name|void
name|stripTrivialAliases
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SELECT
case|:
specifier|final
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlNodeList
name|nodeList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeList
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SqlNode
name|n
init|=
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
condition|)
block|{
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|n
decl_stmt|;
specifier|final
name|SqlIdentifier
name|identifier
init|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlUtil
operator|.
name|isGeneratedAlias
argument_list|(
name|identifier
operator|.
name|getSimple
argument_list|()
argument_list|)
condition|)
block|{
name|nodeList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|INSERT
case|:
case|case
name|UPDATE
case|:
case|case
name|DELETE
case|:
case|case
name|MERGE
case|:
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|!=
literal|null
condition|)
block|{
name|stripTrivialAliases
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/** Strips trivial aliases if anon. */
specifier|private
name|SqlNode
name|maybeStrip
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|anon
condition|)
block|{
name|stripTrivialAliases
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/** Converts a non-query node into a SELECT node. Set operators (UNION,      * INTERSECT, EXCEPT) and DML operators (INSERT, UPDATE, DELETE, MERGE)      * remain as is. */
specifier|public
name|SqlNode
name|asStatement
parameter_list|()
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|INSERT
case|:
case|case
name|UPDATE
case|:
case|case
name|DELETE
case|:
case|case
name|MERGE
case|:
return|return
name|maybeStrip
argument_list|(
name|node
argument_list|)
return|;
default|default:
return|return
name|maybeStrip
argument_list|(
name|asSelect
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Converts a non-query node into a SELECT node. Set operators (UNION,      * INTERSECT, EXCEPT) and VALUES remain as is. */
specifier|public
name|SqlNode
name|asQueryOrValues
parameter_list|()
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|VALUES
case|:
return|return
name|maybeStrip
argument_list|(
name|node
argument_list|)
return|;
default|default:
return|return
name|maybeStrip
argument_list|(
name|asSelect
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Returns a context that always qualifies identifiers. Useful if the      * Context deals with just one arm of a join, yet we wish to generate      * a join condition that qualifies column names to disambiguate them. */
specifier|public
name|Context
name|qualifiedContext
parameter_list|()
block|{
return|return
name|aliasContext
argument_list|(
name|aliases
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * In join, when the left and right nodes have been generated,      * update their alias with 'neededAlias' if not null.      */
specifier|public
name|Result
name|resetAlias
parameter_list|()
block|{
if|if
condition|(
name|neededAlias
operator|==
literal|null
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
return|return
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|neededAlias
argument_list|,
name|neededType
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
name|neededAlias
argument_list|,
name|castNonNull
argument_list|(
name|neededType
argument_list|)
argument_list|)
argument_list|,
name|anon
argument_list|,
name|ignoreClauses
argument_list|,
name|expectedClauses
argument_list|,
name|expectedRel
argument_list|)
return|;
block|}
block|}
comment|/**      * Sets the alias of the join or correlate just created.      *      * @param alias New alias      * @param type type of the node associated with the alias      */
specifier|public
name|Result
name|resetAlias
parameter_list|(
name|String
name|alias
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|alias
argument_list|,
name|neededType
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|type
argument_list|)
argument_list|,
name|anon
argument_list|,
name|ignoreClauses
argument_list|,
name|expectedClauses
argument_list|,
name|expectedRel
argument_list|)
return|;
block|}
comment|/** Returns a copy of this Result, overriding the value of {@code anon}. */
name|Result
name|withAnon
parameter_list|(
name|boolean
name|anon
parameter_list|)
block|{
return|return
name|anon
operator|==
name|this
operator|.
name|anon
condition|?
name|this
else|:
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|neededAlias
argument_list|,
name|neededType
argument_list|,
name|aliases
argument_list|,
name|anon
argument_list|,
name|ignoreClauses
argument_list|,
name|expectedClauses
argument_list|,
name|expectedRel
argument_list|)
return|;
block|}
comment|/** Returns a copy of this Result, overriding the value of      * {@code ignoreClauses} and {@code expectedClauses}. */
name|Result
name|withExpectedClauses
parameter_list|(
name|boolean
name|ignoreClauses
parameter_list|,
name|Set
argument_list|<
name|?
extends|extends
name|Clause
argument_list|>
name|expectedClauses
parameter_list|,
name|RelNode
name|expectedRel
parameter_list|)
block|{
return|return
name|ignoreClauses
operator|==
name|this
operator|.
name|ignoreClauses
operator|&&
name|expectedClauses
operator|.
name|equals
argument_list|(
name|this
operator|.
name|expectedClauses
argument_list|)
operator|&&
name|expectedRel
operator|==
name|this
operator|.
name|expectedRel
condition|?
name|this
else|:
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|neededAlias
argument_list|,
name|neededType
argument_list|,
name|aliases
argument_list|,
name|anon
argument_list|,
name|ignoreClauses
argument_list|,
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|expectedClauses
argument_list|)
argument_list|,
name|expectedRel
argument_list|)
return|;
block|}
block|}
comment|/** Builder. */
specifier|public
class|class
name|Builder
block|{
specifier|private
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
decl_stmt|;
specifier|final
name|SqlSelect
name|select
decl_stmt|;
specifier|public
specifier|final
name|Context
name|context
decl_stmt|;
specifier|final
name|boolean
name|anon
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
decl_stmt|;
specifier|public
name|Builder
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|Context
name|context
parameter_list|,
name|boolean
name|anon
parameter_list|,
annotation|@
name|Nullable
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|requireNonNull
argument_list|(
name|rel
argument_list|,
literal|"rel"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clauses
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
name|this
operator|.
name|select
operator|=
name|requireNonNull
argument_list|(
name|select
argument_list|,
literal|"select"
argument_list|)
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|requireNonNull
argument_list|(
name|context
argument_list|,
literal|"context"
argument_list|)
expr_stmt|;
name|this
operator|.
name|anon
operator|=
name|anon
expr_stmt|;
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
block|}
specifier|public
name|void
name|setSelect
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
name|select
operator|.
name|setSelectList
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setWhere
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|WHERE
argument_list|)
assert|;
name|select
operator|.
name|setWhere
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setGroupBy
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|GROUP_BY
argument_list|)
assert|;
name|select
operator|.
name|setGroupBy
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setHaving
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|HAVING
argument_list|)
assert|;
name|select
operator|.
name|setHaving
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setOrderBy
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|ORDER_BY
argument_list|)
assert|;
name|select
operator|.
name|setOrderBy
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setFetch
parameter_list|(
name|SqlNode
name|fetch
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|FETCH
argument_list|)
assert|;
name|select
operator|.
name|setFetch
argument_list|(
name|fetch
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setOffset
parameter_list|(
name|SqlNode
name|offset
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|OFFSET
argument_list|)
assert|;
name|select
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addOrderItem
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
parameter_list|,
name|RelFieldCollation
name|field
parameter_list|)
block|{
name|context
operator|.
name|addOrderItem
argument_list|(
name|orderByList
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Result
name|result
parameter_list|()
block|{
return|return
name|SqlImplementor
operator|.
name|this
operator|.
name|result
argument_list|(
name|select
argument_list|,
name|clauses
argument_list|,
name|rel
argument_list|,
name|aliases
argument_list|)
operator|.
name|withAnon
argument_list|(
name|anon
argument_list|)
return|;
block|}
block|}
comment|/** Clauses in a SQL query. Ordered by evaluation order.    * SELECT is set only when there is a NON-TRIVIAL SELECT clause. */
specifier|public
enum|enum
name|Clause
block|{
name|FROM
block|,
name|WHERE
block|,
name|GROUP_BY
block|,
name|HAVING
block|,
name|SELECT
block|,
name|SET_OP
block|,
name|ORDER_BY
block|,
name|FETCH
block|,
name|OFFSET
block|}
block|}
end_class

end_unit

