begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rel2sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Window
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexOver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexPatternFieldRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexWindowBound
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMatchRecognize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelectKeyword
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSetOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCountAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSumEmptyIsZeroAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeFamily
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimeString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|IntFunction
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|annotation
operator|.
name|Nonnull
import|;
end_import

begin_comment
comment|/**  * State for generating a SQL statement.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlImplementor
block|{
comment|// Always use quoted position, the "isQuoted" info is only used when
comment|// unparsing a SqlIdentifier. For some rex nodes, saying RexInputRef, we have
comment|// no idea about whether it is quoted or not for the original sql statement.
comment|// So we just quote it.
specifier|public
specifier|static
specifier|final
name|SqlParserPos
name|POS
init|=
name|SqlParserPos
operator|.
name|QUOTED_ZERO
decl_stmt|;
specifier|public
specifier|final
name|SqlDialect
name|dialect
decl_stmt|;
specifier|protected
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|aliasSet
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SqlNode
argument_list|>
name|ordinalMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|CorrelationId
argument_list|,
name|Context
argument_list|>
name|correlTableMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
name|SqlImplementor
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|)
block|{
name|this
operator|.
name|dialect
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|dialect
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|Result
name|visitChild
parameter_list|(
name|int
name|i
parameter_list|,
name|RelNode
name|e
parameter_list|)
function_decl|;
specifier|public
name|void
name|addSelect
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|String
name|name
init|=
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|selectList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|node
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
operator|||
operator|!
name|alias
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|node
operator|=
name|as
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|selectList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/** Convenience method for creating column and table aliases.    *    *<p>{@code AS(e, "c")} creates "e AS c";    * {@code AS(e, "t", "c1", "c2"} creates "e AS t (c1, c2)". */
specifier|protected
name|SqlCall
name|as
parameter_list|(
name|SqlNode
name|e
parameter_list|,
name|String
name|alias
parameter_list|,
name|String
modifier|...
name|fieldNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|operandList
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|operandList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|operandList
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|fieldName
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operandList
argument_list|)
return|;
block|}
comment|/** Returns whether a list of expressions projects all fields, in order,    * from the input, with the same names. */
specifier|public
specifier|static
name|boolean
name|isStar
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exps
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|,
name|RelDataType
name|projectRowType
parameter_list|)
block|{
assert|assert
name|exps
operator|.
name|size
argument_list|()
operator|==
name|projectRowType
operator|.
name|getFieldCount
argument_list|()
assert|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|ref
range|:
name|exps
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ref
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|else if
condition|(
operator|(
operator|(
name|RexInputRef
operator|)
name|ref
operator|)
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
operator|++
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|i
operator|==
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
operator|&&
name|inputRowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|equals
argument_list|(
name|projectRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isStar
parameter_list|(
name|RexProgram
name|program
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|ref
range|:
name|program
operator|.
name|getProjectList
argument_list|()
control|)
block|{
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
operator|++
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|i
operator|==
name|program
operator|.
name|getInputRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
return|;
block|}
specifier|public
name|Result
name|setOpToSql
parameter_list|(
name|SqlSetOperator
name|operator
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|SqlNode
name|node
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RelNode
argument_list|>
name|input
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|Result
name|result
init|=
name|visitChild
argument_list|(
name|input
operator|.
name|i
argument_list|,
name|input
operator|.
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|node
operator|=
name|result
operator|.
name|asSelect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|operator
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
name|result
operator|.
name|asSelect
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
init|=
name|Expressions
operator|.
name|list
argument_list|(
name|Clause
operator|.
name|SET_OP
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|rel
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Converts a {@link RexNode} condition into a {@link SqlNode}.    *    * @param node            Join condition    * @param leftContext     Left context    * @param rightContext    Right context    * @param leftFieldCount  Number of fields on left result    * @return SqlNode that represents the condition    */
specifier|public
specifier|static
name|SqlNode
name|convertConditionToSqlNode
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|Context
name|leftContext
parameter_list|,
name|Context
name|rightContext
parameter_list|,
name|int
name|leftFieldCount
parameter_list|,
name|SqlDialect
name|dialect
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
return|return
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|true
argument_list|,
name|POS
argument_list|)
return|;
block|}
if|if
condition|(
name|node
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|false
argument_list|,
name|POS
argument_list|)
return|;
block|}
if|if
condition|(
name|node
operator|instanceof
name|RexInputRef
condition|)
block|{
name|Context
name|joinContext
init|=
name|leftContext
operator|.
name|implementor
argument_list|()
operator|.
name|joinContext
argument_list|(
name|leftContext
argument_list|,
name|rightContext
argument_list|)
decl_stmt|;
return|return
name|joinContext
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|node
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|node
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
specifier|final
name|SqlOperator
name|op
decl_stmt|;
specifier|final
name|Context
name|joinContext
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|OR
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
name|op
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
expr_stmt|;
name|SqlNode
name|sqlCondition
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|operands
control|)
block|{
name|SqlNode
name|x
init|=
name|convertConditionToSqlNode
argument_list|(
name|operand
argument_list|,
name|leftContext
argument_list|,
name|rightContext
argument_list|,
name|leftFieldCount
argument_list|,
name|dialect
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqlCondition
operator|==
literal|null
condition|)
block|{
name|sqlCondition
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|sqlCondition
operator|=
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|sqlCondition
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sqlCondition
return|;
case|case
name|EQUALS
case|:
case|case
name|IS_NOT_DISTINCT_FROM
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|LIKE
case|:
name|node
operator|=
name|stripCastFromString
argument_list|(
name|node
argument_list|,
name|dialect
argument_list|)
expr_stmt|;
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
name|op
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
expr_stmt|;
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|&&
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|&&
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
condition|)
block|{
specifier|final
name|RexInputRef
name|op0
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|op1
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|&&
name|op1
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
condition|)
block|{
comment|// Arguments were of form 'op0 = op1'
return|return
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|leftContext
operator|.
name|field
argument_list|(
name|op0
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|rightContext
operator|.
name|field
argument_list|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|&&
name|op0
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
condition|)
block|{
comment|// Arguments were of form 'op1 = op0'
return|return
name|reverseOperatorDirection
argument_list|(
name|op
argument_list|)
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|leftContext
operator|.
name|field
argument_list|(
name|op1
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|rightContext
operator|.
name|field
argument_list|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
argument_list|)
return|;
block|}
block|}
name|joinContext
operator|=
name|leftContext
operator|.
name|implementor
argument_list|()
operator|.
name|joinContext
argument_list|(
name|leftContext
argument_list|,
name|rightContext
argument_list|)
expr_stmt|;
return|return
name|joinContext
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|node
argument_list|)
return|;
case|case
name|IS_NULL
case|:
case|case
name|IS_NOT_NULL
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
condition|)
block|{
name|op
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
expr_stmt|;
specifier|final
name|RexInputRef
name|op0
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
condition|)
block|{
return|return
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|leftContext
operator|.
name|field
argument_list|(
name|op0
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|rightContext
operator|.
name|field
argument_list|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
argument_list|)
return|;
block|}
block|}
name|joinContext
operator|=
name|leftContext
operator|.
name|implementor
argument_list|()
operator|.
name|joinContext
argument_list|(
name|leftContext
argument_list|,
name|rightContext
argument_list|)
expr_stmt|;
return|return
name|joinContext
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|node
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|node
argument_list|)
throw|;
block|}
block|}
comment|/** Removes cast from string.    *    *<p>For example, {@code x> CAST('2015-01-07' AS DATE)}    * becomes {@code x> '2015-01-07'}.    */
specifier|private
specifier|static
name|RexNode
name|stripCastFromString
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|SqlDialect
name|dialect
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
case|case
name|IS_NOT_DISTINCT_FROM
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|node
decl_stmt|;
specifier|final
name|RexNode
name|o0
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|o1
init|=
name|call
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|o0
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
operator|&&
name|o1
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|CAST
condition|)
block|{
if|if
condition|(
operator|!
name|dialect
operator|.
name|supportsImplicitTypeCoercion
argument_list|(
operator|(
name|RexCall
operator|)
name|o0
argument_list|)
condition|)
block|{
comment|// If the dialect does not support implicit type coercion,
comment|// we definitely can not strip the cast.
return|return
name|node
return|;
block|}
specifier|final
name|RexNode
name|o0b
init|=
operator|(
operator|(
name|RexCall
operator|)
name|o0
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|o0b
argument_list|,
name|o1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|o1
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CAST
operator|&&
name|o0
operator|.
name|getKind
argument_list|()
operator|!=
name|SqlKind
operator|.
name|CAST
condition|)
block|{
if|if
condition|(
operator|!
name|dialect
operator|.
name|supportsImplicitTypeCoercion
argument_list|(
operator|(
name|RexCall
operator|)
name|o1
argument_list|)
condition|)
block|{
return|return
name|node
return|;
block|}
specifier|final
name|RexNode
name|o1b
init|=
operator|(
operator|(
name|RexCall
operator|)
name|o1
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|call
operator|.
name|clone
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|o0
argument_list|,
name|o1b
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|private
specifier|static
name|SqlOperator
name|reverseOperatorDirection
parameter_list|(
name|SqlOperator
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
operator|.
name|kind
condition|)
block|{
case|case
name|GREATER_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
return|;
case|case
name|EQUALS
case|:
case|case
name|IS_NOT_DISTINCT_FROM
case|:
case|case
name|NOT_EQUALS
case|:
return|return
name|op
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|op
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|JoinType
name|joinType
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|)
block|{
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
return|return
name|JoinType
operator|.
name|LEFT
return|;
case|case
name|RIGHT
case|:
return|return
name|JoinType
operator|.
name|RIGHT
return|;
case|case
name|INNER
case|:
return|return
name|JoinType
operator|.
name|INNER
return|;
case|case
name|FULL
case|:
return|return
name|JoinType
operator|.
name|FULL
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|joinType
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a result based on a single relational expression. */
specifier|public
name|Result
name|result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
assert|assert
name|aliases
operator|==
literal|null
operator|||
name|aliases
operator|.
name|size
argument_list|()
operator|<
literal|2
operator|||
name|aliases
operator|instanceof
name|LinkedHashMap
operator|||
name|aliases
operator|instanceof
name|ImmutableMap
operator|:
literal|"must use a Map implementation that preserves order"
assert|;
specifier|final
name|String
name|alias2
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|node
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alias3
init|=
name|alias2
operator|!=
literal|null
condition|?
name|alias2
else|:
literal|"t"
decl_stmt|;
specifier|final
name|String
name|alias4
init|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|alias3
argument_list|,
name|aliasSet
argument_list|,
name|SqlValidatorUtil
operator|.
name|EXPR_SUGGESTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliases
operator|!=
literal|null
operator|&&
operator|!
name|aliases
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
operator|||
name|aliases
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
condition|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|alias4
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|aliases
argument_list|)
return|;
block|}
specifier|final
name|String
name|alias5
decl_stmt|;
if|if
condition|(
name|alias2
operator|==
literal|null
operator|||
operator|!
name|alias2
operator|.
name|equals
argument_list|(
name|alias4
argument_list|)
operator|||
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
condition|)
block|{
name|alias5
operator|=
name|alias4
expr_stmt|;
block|}
else|else
block|{
name|alias5
operator|=
literal|null
expr_stmt|;
block|}
return|return
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|alias5
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
name|alias4
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a result based on a join. (Each join could contain one or more    * relational expressions.) */
specifier|public
name|Result
name|result
parameter_list|(
name|SqlNode
name|join
parameter_list|,
name|Result
name|leftResult
parameter_list|,
name|Result
name|rightResult
parameter_list|)
block|{
specifier|final
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|builder
init|=
name|ImmutableMap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|collectAliases
argument_list|(
name|builder
argument_list|,
name|join
argument_list|,
name|Iterables
operator|.
name|concat
argument_list|(
name|leftResult
operator|.
name|aliases
operator|.
name|values
argument_list|()
argument_list|,
name|rightResult
operator|.
name|aliases
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|Result
argument_list|(
name|join
argument_list|,
name|Expressions
operator|.
name|list
argument_list|(
name|Clause
operator|.
name|FROM
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|collectAliases
parameter_list|(
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|builder
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|Iterator
argument_list|<
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlJoin
condition|)
block|{
specifier|final
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|node
decl_stmt|;
name|collectAliases
argument_list|(
name|builder
argument_list|,
name|join
operator|.
name|getLeft
argument_list|()
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
name|collectAliases
argument_list|(
name|builder
argument_list|,
name|join
operator|.
name|getRight
argument_list|()
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|node
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
assert|assert
name|alias
operator|!=
literal|null
assert|;
name|builder
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|aliases
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Wraps a node in a SELECT statement that has no clauses:    *  "SELECT ... FROM (node)". */
name|SqlSelect
name|wrapSelect
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|instanceof
name|SqlJoin
operator|||
name|node
operator|instanceof
name|SqlIdentifier
operator|||
name|node
operator|instanceof
name|SqlMatchRecognize
operator|||
name|node
operator|instanceof
name|SqlCall
operator|&&
operator|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlSetOperator
operator|||
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|AS
operator|||
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|VALUES
operator|)
operator|:
name|node
assert|;
if|if
condition|(
name|requiresAlias
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|node
operator|=
name|as
argument_list|(
name|node
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Returns whether we need to add an alias if this node is to be the FROM    * clause of a SELECT. */
specifier|private
name|boolean
name|requiresAlias
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dialect
operator|.
name|requiresAliasForFromItems
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IDENTIFIER
case|:
return|return
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
return|;
case|case
name|AS
case|:
case|case
name|JOIN
case|:
case|case
name|EXPLICIT_TABLE
case|:
return|return
literal|false
return|;
default|default:
return|return
literal|true
return|;
block|}
block|}
comment|/** Context for translating a {@link RexNode} expression (within a    * {@link RelNode}) into a {@link SqlNode} expression (within a SQL parse    * tree). */
specifier|public
specifier|abstract
specifier|static
class|class
name|Context
block|{
specifier|final
name|SqlDialect
name|dialect
decl_stmt|;
specifier|final
name|int
name|fieldCount
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|ignoreCast
decl_stmt|;
specifier|protected
name|Context
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|int
name|fieldCount
parameter_list|)
block|{
name|this
argument_list|(
name|dialect
argument_list|,
name|fieldCount
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Context
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|int
name|fieldCount
parameter_list|,
name|boolean
name|ignoreCast
parameter_list|)
block|{
name|this
operator|.
name|dialect
operator|=
name|dialect
expr_stmt|;
name|this
operator|.
name|fieldCount
operator|=
name|fieldCount
expr_stmt|;
name|this
operator|.
name|ignoreCast
operator|=
name|ignoreCast
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
function_decl|;
comment|/** Creates a reference to a field to be used in an ORDER BY clause.      *      *<p>By default, it returns the same result as {@link #field}.      *      *<p>If the field has an alias, uses the alias.      * If the field is an unqualified column reference which is the same an      * alias, switches to a qualified column reference.      */
specifier|public
name|SqlNode
name|orderField
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|field
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
comment|/** Converts an expression from {@link RexNode} to {@link SqlNode}      * format.      *      * @param program Required only if {@code rex} contains {@link RexLocalRef}      * @param rex Expression to convert      */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
specifier|final
name|RexSubQuery
name|subQuery
decl_stmt|;
specifier|final
name|SqlNode
name|sqlSubQuery
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LOCAL_REF
case|:
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|RexLocalRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
return|return
name|toSql
argument_list|(
name|program
argument_list|,
name|program
operator|.
name|getExprList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
case|case
name|INPUT_REF
case|:
return|return
name|field
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
case|case
name|FIELD_ACCESS
case|:
specifier|final
name|Deque
argument_list|<
name|RexFieldAccess
argument_list|>
name|accesses
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
name|RexNode
name|referencedExpr
init|=
name|rex
decl_stmt|;
while|while
condition|(
name|referencedExpr
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|FIELD_ACCESS
condition|)
block|{
name|accesses
operator|.
name|offerLast
argument_list|(
operator|(
name|RexFieldAccess
operator|)
name|referencedExpr
argument_list|)
expr_stmt|;
name|referencedExpr
operator|=
operator|(
operator|(
name|RexFieldAccess
operator|)
name|referencedExpr
operator|)
operator|.
name|getReferenceExpr
argument_list|()
expr_stmt|;
block|}
name|SqlIdentifier
name|sqlIdentifier
decl_stmt|;
switch|switch
condition|(
name|referencedExpr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CORREL_VARIABLE
case|:
specifier|final
name|RexCorrelVariable
name|variable
init|=
operator|(
name|RexCorrelVariable
operator|)
name|referencedExpr
decl_stmt|;
specifier|final
name|Context
name|correlAliasContext
init|=
name|getAliasContext
argument_list|(
name|variable
argument_list|)
decl_stmt|;
specifier|final
name|RexFieldAccess
name|lastAccess
init|=
name|accesses
operator|.
name|pollLast
argument_list|()
decl_stmt|;
assert|assert
name|lastAccess
operator|!=
literal|null
assert|;
name|sqlIdentifier
operator|=
operator|(
name|SqlIdentifier
operator|)
name|correlAliasContext
operator|.
name|field
argument_list|(
name|lastAccess
operator|.
name|getField
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROW
case|:
specifier|final
name|SqlNode
name|expr
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|referencedExpr
argument_list|)
decl_stmt|;
name|sqlIdentifier
operator|=
operator|new
name|SqlIdentifier
argument_list|(
name|expr
operator|.
name|toString
argument_list|()
argument_list|,
name|POS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sqlIdentifier
operator|=
operator|(
name|SqlIdentifier
operator|)
name|toSql
argument_list|(
name|program
argument_list|,
name|referencedExpr
argument_list|)
expr_stmt|;
block|}
name|int
name|nameIndex
init|=
name|sqlIdentifier
operator|.
name|names
operator|.
name|size
argument_list|()
decl_stmt|;
name|RexFieldAccess
name|access
decl_stmt|;
while|while
condition|(
operator|(
name|access
operator|=
name|accesses
operator|.
name|pollLast
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|sqlIdentifier
operator|=
name|sqlIdentifier
operator|.
name|add
argument_list|(
name|nameIndex
operator|++
argument_list|,
name|access
operator|.
name|getField
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|POS
argument_list|)
expr_stmt|;
block|}
return|return
name|sqlIdentifier
return|;
case|case
name|PATTERN_INPUT_REF
case|:
specifier|final
name|RexPatternFieldRef
name|ref
init|=
operator|(
name|RexPatternFieldRef
operator|)
name|rex
decl_stmt|;
name|String
name|pv
init|=
name|ref
operator|.
name|getAlpha
argument_list|()
decl_stmt|;
name|SqlNode
name|refNode
init|=
name|field
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|refNode
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return
name|id
operator|.
name|setName
argument_list|(
literal|0
argument_list|,
name|pv
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|SqlIdentifier
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|pv
argument_list|,
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
case|case
name|LITERAL
case|:
specifier|final
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|SYMBOL
condition|)
block|{
specifier|final
name|Enum
name|symbol
init|=
operator|(
name|Enum
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|SqlLiteral
operator|.
name|createSymbol
argument_list|(
name|symbol
argument_list|,
name|POS
argument_list|)
return|;
block|}
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
condition|)
block|{
case|case
name|CHARACTER
case|:
return|return
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
operator|(
name|String
operator|)
name|literal
operator|.
name|getValue2
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|NUMERIC
case|:
case|case
name|EXACT_NUMERIC
case|:
return|return
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
operator|.
name|toPlainString
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|APPROXIMATE_NUMERIC
case|:
return|return
name|SqlLiteral
operator|.
name|createApproxNumeric
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|BigDecimal
operator|.
name|class
argument_list|)
operator|.
name|toPlainString
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|BOOLEAN
case|:
return|return
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|Boolean
operator|.
name|class
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
specifier|final
name|boolean
name|negative
init|=
name|literal
operator|.
name|getValueAs
argument_list|(
name|Boolean
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|SqlLiteral
operator|.
name|createInterval
argument_list|(
name|negative
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|,
name|literal
operator|.
name|getValueAs
argument_list|(
name|String
operator|.
name|class
argument_list|)
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getIntervalQualifier
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|DATE
case|:
return|return
name|SqlLiteral
operator|.
name|createDate
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|DateString
operator|.
name|class
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|TIME
case|:
return|return
name|SqlLiteral
operator|.
name|createTime
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|TimeString
operator|.
name|class
argument_list|)
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|SqlLiteral
operator|.
name|createTimestamp
argument_list|(
name|literal
operator|.
name|getValueAs
argument_list|(
name|TimestampString
operator|.
name|class
argument_list|)
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|ANY
case|:
case|case
name|NULL
case|:
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|NULL
case|:
return|return
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|POS
argument_list|)
return|;
comment|// fall through
block|}
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|literal
operator|+
literal|": "
operator|+
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
case|case
name|CASE
case|:
specifier|final
name|RexCall
name|caseCall
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|caseNodeList
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|caseCall
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|valueNode
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|whenList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|thenList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|elseNode
decl_stmt|;
if|if
condition|(
name|caseNodeList
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
comment|// switched:
comment|//   "case x when v1 then t1 when v2 then t2 ... else e end"
name|valueNode
operator|=
name|caseNodeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|whenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|thenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// other: "case when w1 then t1 when w2 then t2 ... else e end"
name|valueNode
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|whenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|thenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|elseNode
operator|=
name|caseNodeList
operator|.
name|get
argument_list|(
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlCase
argument_list|(
name|POS
argument_list|,
name|valueNode
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|whenList
argument_list|,
name|POS
argument_list|)
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|thenList
argument_list|,
name|POS
argument_list|)
argument_list|,
name|elseNode
argument_list|)
return|;
case|case
name|DYNAMIC_PARAM
case|:
specifier|final
name|RexDynamicParam
name|caseParam
init|=
operator|(
name|RexDynamicParam
operator|)
name|rex
decl_stmt|;
return|return
operator|new
name|SqlDynamicParam
argument_list|(
name|caseParam
operator|.
name|getIndex
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|IN
case|:
if|if
condition|(
name|rex
operator|instanceof
name|RexSubQuery
condition|)
block|{
name|subQuery
operator|=
operator|(
name|RexSubQuery
operator|)
name|rex
expr_stmt|;
name|sqlSubQuery
operator|=
name|implementor
argument_list|()
operator|.
name|visitChild
argument_list|(
literal|0
argument_list|,
name|subQuery
operator|.
name|rel
argument_list|)
operator|.
name|asQueryOrValues
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
init|=
name|subQuery
operator|.
name|operands
decl_stmt|;
name|SqlNode
name|op0
decl_stmt|;
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|op0
operator|=
name|toSql
argument_list|(
name|program
argument_list|,
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|cols
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|operands
argument_list|)
decl_stmt|;
name|op0
operator|=
operator|new
name|SqlNodeList
argument_list|(
name|cols
argument_list|,
name|POS
argument_list|)
expr_stmt|;
block|}
return|return
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|op0
argument_list|,
name|sqlSubQuery
argument_list|)
return|;
block|}
else|else
block|{
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|cols
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|call
operator|.
name|operands
argument_list|)
decl_stmt|;
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|cols
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|cols
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
name|cols
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
case|case
name|EXISTS
case|:
case|case
name|SCALAR_QUERY
case|:
name|subQuery
operator|=
operator|(
name|RexSubQuery
operator|)
name|rex
expr_stmt|;
name|sqlSubQuery
operator|=
name|implementor
argument_list|()
operator|.
name|visitChild
argument_list|(
literal|0
argument_list|,
name|subQuery
operator|.
name|rel
argument_list|)
operator|.
name|asQueryOrValues
argument_list|()
expr_stmt|;
return|return
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|sqlSubQuery
argument_list|)
return|;
case|case
name|NOT
case|:
name|RexNode
name|operand
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|node
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|operand
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|operand
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_IN
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
return|;
case|case
name|LIKE
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_LIKE
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
return|;
case|case
name|SIMILAR
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT_SIMILAR_TO
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
argument_list|)
return|;
default|default:
return|return
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
return|;
block|}
default|default:
if|if
condition|(
name|rex
operator|instanceof
name|RexOver
condition|)
block|{
return|return
name|toSql
argument_list|(
name|program
argument_list|,
operator|(
name|RexOver
operator|)
name|rex
argument_list|)
return|;
block|}
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|stripCastFromString
argument_list|(
name|rex
argument_list|,
name|dialect
argument_list|)
decl_stmt|;
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|op
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SUM0
case|:
name|op
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodeList
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
comment|// CURSOR is used inside CAST, like 'CAST ($0): CURSOR NOT NULL',
comment|// convert it to sql call of {@link SqlStdOperatorTable#CURSOR}.
name|RelDataType
name|dataType
init|=
name|rex
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataType
operator|.
name|getSqlTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|CURSOR
condition|)
block|{
name|RexNode
name|operand0
init|=
operator|(
operator|(
name|RexCall
operator|)
name|rex
operator|)
operator|.
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
name|operand0
operator|instanceof
name|RexInputRef
assert|;
name|int
name|ordinal
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|operand0
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|SqlNode
name|fieldOperand
init|=
name|field
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|CURSOR
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|fieldOperand
argument_list|)
return|;
block|}
if|if
condition|(
name|ignoreCast
condition|)
block|{
assert|assert
name|nodeList
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|nodeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|nodeList
operator|.
name|add
argument_list|(
name|dialect
operator|.
name|getCastSpec
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|instanceof
name|SqlBinaryOperator
operator|&&
name|nodeList
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
comment|// In RexNode trees, OR and AND have any number of children;
comment|// SqlCall requires exactly 2. So, convert to a balanced binary
comment|// tree for OR/AND, left-deep binary tree for others.
if|if
condition|(
name|op
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|OR
operator|||
name|op
operator|.
name|kind
operator|==
name|SqlKind
operator|.
name|AND
condition|)
block|{
return|return
name|createBalancedCall
argument_list|(
name|op
argument_list|,
name|nodeList
argument_list|,
literal|0
argument_list|,
name|nodeList
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createLeftCall
argument_list|(
name|op
argument_list|,
name|nodeList
argument_list|)
return|;
block|}
block|}
return|return
name|op
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|nodeList
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Converts an expression from {@link RexWindowBound} to {@link SqlNode}      * format.      *      * @param rexWindowBound Expression to convert      */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|RexWindowBound
name|rexWindowBound
parameter_list|)
block|{
specifier|final
name|SqlNode
name|offsetLiteral
init|=
name|rexWindowBound
operator|.
name|getOffset
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
name|rexWindowBound
operator|.
name|getOffset
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
if|if
condition|(
name|rexWindowBound
operator|.
name|isPreceding
argument_list|()
condition|)
block|{
return|return
name|offsetLiteral
operator|==
literal|null
condition|?
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|POS
argument_list|)
else|:
name|SqlWindow
operator|.
name|createPreceding
argument_list|(
name|offsetLiteral
argument_list|,
name|POS
argument_list|)
return|;
block|}
if|else if
condition|(
name|rexWindowBound
operator|.
name|isFollowing
argument_list|()
condition|)
block|{
return|return
name|offsetLiteral
operator|==
literal|null
condition|?
name|SqlWindow
operator|.
name|createUnboundedFollowing
argument_list|(
name|POS
argument_list|)
else|:
name|SqlWindow
operator|.
name|createFollowing
argument_list|(
name|offsetLiteral
argument_list|,
name|POS
argument_list|)
return|;
block|}
else|else
block|{
assert|assert
name|rexWindowBound
operator|.
name|isCurrentRow
argument_list|()
assert|;
return|return
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|POS
argument_list|)
return|;
block|}
block|}
specifier|public
name|List
argument_list|<
name|SqlNode
argument_list|>
name|toSql
parameter_list|(
name|Window
operator|.
name|Group
name|group
parameter_list|,
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
name|constants
parameter_list|,
name|int
name|inputFieldCount
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|rexOvers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|partitionKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|partition
range|:
name|group
operator|.
name|keys
control|)
block|{
name|partitionKeys
operator|.
name|add
argument_list|(
name|this
operator|.
name|field
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RelFieldCollation
name|collation
range|:
name|group
operator|.
name|orderKeys
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|this
operator|.
name|addOrderItem
argument_list|(
name|orderByKeys
argument_list|,
name|collation
argument_list|)
expr_stmt|;
block|}
name|SqlLiteral
name|isRows
init|=
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
name|group
operator|.
name|isRows
argument_list|,
name|POS
argument_list|)
decl_stmt|;
name|SqlNode
name|lowerBound
init|=
literal|null
decl_stmt|;
name|SqlNode
name|upperBound
init|=
literal|null
decl_stmt|;
specifier|final
name|SqlLiteral
name|allowPartial
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Window
operator|.
name|RexWinAggCall
name|winAggCall
range|:
name|group
operator|.
name|aggCalls
control|)
block|{
name|SqlAggFunction
name|aggFunction
init|=
operator|(
name|SqlAggFunction
operator|)
name|winAggCall
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|SqlWindow
name|sqlWindow
init|=
name|SqlWindow
operator|.
name|create
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|partitionKeys
argument_list|,
name|POS
argument_list|)
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|orderByKeys
argument_list|,
name|POS
argument_list|)
argument_list|,
name|isRows
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|allowPartial
argument_list|,
name|POS
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggFunction
operator|.
name|allowsFraming
argument_list|()
condition|)
block|{
name|lowerBound
operator|=
name|createSqlWindowBound
argument_list|(
name|group
operator|.
name|lowerBound
argument_list|)
expr_stmt|;
name|upperBound
operator|=
name|createSqlWindowBound
argument_list|(
name|group
operator|.
name|upperBound
argument_list|)
expr_stmt|;
name|sqlWindow
operator|.
name|setLowerBound
argument_list|(
name|lowerBound
argument_list|)
expr_stmt|;
name|sqlWindow
operator|.
name|setUpperBound
argument_list|(
name|upperBound
argument_list|)
expr_stmt|;
block|}
name|RexShuttle
name|replaceConstants
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|int
name|index
init|=
name|inputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|RexNode
name|ref
decl_stmt|;
if|if
condition|(
name|index
operator|>
name|inputFieldCount
operator|-
literal|1
condition|)
block|{
name|ref
operator|=
name|constants
operator|.
name|get
argument_list|(
name|index
operator|-
name|inputFieldCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref
operator|=
name|inputRef
expr_stmt|;
block|}
return|return
name|ref
return|;
block|}
block|}
decl_stmt|;
name|RexCall
name|aggCall
init|=
operator|(
name|RexCall
operator|)
name|winAggCall
operator|.
name|accept
argument_list|(
name|replaceConstants
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|toSql
argument_list|(
literal|null
argument_list|,
name|aggCall
operator|.
name|operands
argument_list|)
decl_stmt|;
name|rexOvers
operator|.
name|add
argument_list|(
name|createOverCall
argument_list|(
name|aggFunction
argument_list|,
name|operands
argument_list|,
name|sqlWindow
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rexOvers
return|;
block|}
specifier|protected
name|Context
name|getAliasContext
parameter_list|(
name|RexCorrelVariable
name|variable
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|private
name|SqlCall
name|toSql
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|RexOver
name|rexOver
parameter_list|)
block|{
specifier|final
name|RexWindow
name|rexWindow
init|=
name|rexOver
operator|.
name|getWindow
argument_list|()
decl_stmt|;
specifier|final
name|SqlNodeList
name|partitionList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|toSql
argument_list|(
name|program
argument_list|,
name|rexWindow
operator|.
name|partitionKeys
argument_list|)
argument_list|,
name|POS
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderNodes
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|rexWindow
operator|.
name|orderKeys
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|RexFieldCollation
name|rfc
range|:
name|rexWindow
operator|.
name|orderKeys
control|)
block|{
name|addOrderItem
argument_list|(
name|orderNodes
argument_list|,
name|program
argument_list|,
name|rfc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|SqlNodeList
name|orderList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|orderNodes
argument_list|,
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|isRows
init|=
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
name|rexWindow
operator|.
name|isRows
argument_list|()
argument_list|,
name|POS
argument_list|)
decl_stmt|;
comment|// null defaults to true.
comment|// During parsing the allowPartial == false (e.g. disallow partial)
comment|// is expand into CASE expression and is handled as a such.
comment|// Not sure if we can collapse this CASE expression back into
comment|// "disallow partial" and set the allowPartial = false.
specifier|final
name|SqlLiteral
name|allowPartial
init|=
literal|null
decl_stmt|;
name|SqlAggFunction
name|sqlAggregateFunction
init|=
name|rexOver
operator|.
name|getAggOperator
argument_list|()
decl_stmt|;
name|SqlNode
name|lowerBound
init|=
literal|null
decl_stmt|;
name|SqlNode
name|upperBound
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|sqlAggregateFunction
operator|.
name|allowsFraming
argument_list|()
condition|)
block|{
name|lowerBound
operator|=
name|createSqlWindowBound
argument_list|(
name|rexWindow
operator|.
name|getLowerBound
argument_list|()
argument_list|)
expr_stmt|;
name|upperBound
operator|=
name|createSqlWindowBound
argument_list|(
name|rexWindow
operator|.
name|getUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlWindow
name|sqlWindow
init|=
name|SqlWindow
operator|.
name|create
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|partitionList
argument_list|,
name|orderList
argument_list|,
name|isRows
argument_list|,
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|allowPartial
argument_list|,
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodeList
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|rexOver
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|createOverCall
argument_list|(
name|sqlAggregateFunction
argument_list|,
name|nodeList
argument_list|,
name|sqlWindow
argument_list|)
return|;
block|}
specifier|private
name|SqlCall
name|createOverCall
parameter_list|(
name|SqlAggFunction
name|op
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|,
name|SqlWindow
name|window
parameter_list|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|SqlSumEmptyIsZeroAggFunction
condition|)
block|{
comment|// Rewrite "SUM0(x) OVER w" to "COALESCE(SUM(x) OVER w, 0)"
specifier|final
name|SqlCall
name|node
init|=
name|createOverCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
name|operands
argument_list|,
name|window
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|COALESCE
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0"
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
specifier|final
name|SqlCall
name|aggFunctionCall
init|=
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operands
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|OVER
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|aggFunctionCall
argument_list|,
name|window
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|toSql
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|RexFieldCollation
name|rfc
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|rfc
operator|.
name|left
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rfc
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rfc
operator|.
name|getNullDirection
argument_list|()
operator|!=
name|dialect
operator|.
name|defaultNullDirection
argument_list|(
name|rfc
operator|.
name|getDirection
argument_list|()
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|rfc
operator|.
name|getNullDirection
argument_list|()
condition|)
block|{
case|case
name|FIRST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_FIRST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_LAST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|private
name|SqlNode
name|createSqlWindowBound
parameter_list|(
name|RexWindowBound
name|rexWindowBound
parameter_list|)
block|{
if|if
condition|(
name|rexWindowBound
operator|.
name|isCurrentRow
argument_list|()
condition|)
block|{
return|return
name|SqlWindow
operator|.
name|createCurrentRow
argument_list|(
name|POS
argument_list|)
return|;
block|}
if|if
condition|(
name|rexWindowBound
operator|.
name|isPreceding
argument_list|()
condition|)
block|{
if|if
condition|(
name|rexWindowBound
operator|.
name|isUnbounded
argument_list|()
condition|)
block|{
return|return
name|SqlWindow
operator|.
name|createUnboundedPreceding
argument_list|(
name|POS
argument_list|)
return|;
block|}
else|else
block|{
name|SqlNode
name|literal
init|=
name|toSql
argument_list|(
literal|null
argument_list|,
name|rexWindowBound
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|SqlWindow
operator|.
name|createPreceding
argument_list|(
name|literal
argument_list|,
name|POS
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|rexWindowBound
operator|.
name|isFollowing
argument_list|()
condition|)
block|{
if|if
condition|(
name|rexWindowBound
operator|.
name|isUnbounded
argument_list|()
condition|)
block|{
return|return
name|SqlWindow
operator|.
name|createUnboundedFollowing
argument_list|(
name|POS
argument_list|)
return|;
block|}
else|else
block|{
name|SqlNode
name|literal
init|=
name|toSql
argument_list|(
literal|null
argument_list|,
name|rexWindowBound
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|SqlWindow
operator|.
name|createFollowing
argument_list|(
name|literal
argument_list|,
name|POS
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unsupported Window bound: "
operator|+
name|rexWindowBound
argument_list|)
throw|;
block|}
specifier|private
name|SqlNode
name|createLeftCall
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodeList
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|op
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|nodeList
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|POS
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|nodeList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|op
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|node
argument_list|,
name|nodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/**      * Create a balanced binary call from sql node list,      * start inclusive, end exclusive.      */
specifier|private
name|SqlNode
name|createBalancedCall
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodeList
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
assert|assert
name|start
operator|<
name|end
operator|&&
name|end
operator|<=
name|nodeList
operator|.
name|size
argument_list|()
assert|;
if|if
condition|(
name|start
operator|+
literal|1
operator|==
name|end
condition|)
block|{
return|return
name|nodeList
operator|.
name|get
argument_list|(
name|start
argument_list|)
return|;
block|}
name|int
name|mid
init|=
operator|(
name|end
operator|-
name|start
operator|)
operator|/
literal|2
operator|+
name|start
decl_stmt|;
name|SqlNode
name|leftNode
init|=
name|createBalancedCall
argument_list|(
name|op
argument_list|,
name|nodeList
argument_list|,
name|start
argument_list|,
name|mid
argument_list|)
decl_stmt|;
name|SqlNode
name|rightNode
init|=
name|createBalancedCall
argument_list|(
name|op
argument_list|,
name|nodeList
argument_list|,
name|mid
argument_list|,
name|end
argument_list|)
decl_stmt|;
return|return
name|op
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|leftNode
argument_list|,
name|rightNode
argument_list|)
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|SqlNode
argument_list|>
name|toSql
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operandList
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|operandList
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|toSql
argument_list|(
name|program
argument_list|,
name|rex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|public
name|List
argument_list|<
name|SqlNode
argument_list|>
name|fieldList
parameter_list|()
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
block|{
specifier|public
name|SqlNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|field
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fieldCount
return|;
block|}
block|}
return|;
block|}
name|void
name|addOrderItem
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
parameter_list|,
name|RelFieldCollation
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|nullDirection
operator|!=
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
condition|)
block|{
specifier|final
name|boolean
name|first
init|=
name|field
operator|.
name|nullDirection
operator|==
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
decl_stmt|;
name|SqlNode
name|nullDirectionNode
init|=
name|dialect
operator|.
name|emulateNullDirection
argument_list|(
name|field
argument_list|(
name|field
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
argument_list|,
name|first
argument_list|,
name|field
operator|.
name|direction
operator|.
name|isDescending
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullDirectionNode
operator|!=
literal|null
condition|)
block|{
name|orderByList
operator|.
name|add
argument_list|(
name|nullDirectionNode
argument_list|)
expr_stmt|;
name|field
operator|=
operator|new
name|RelFieldCollation
argument_list|(
name|field
operator|.
name|getFieldIndex
argument_list|()
argument_list|,
name|field
operator|.
name|getDirection
argument_list|()
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
argument_list|)
expr_stmt|;
block|}
block|}
name|orderByList
operator|.
name|add
argument_list|(
name|toSql
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Converts a RexFieldCollation to an ORDER BY item. */
specifier|private
name|void
name|addOrderItem
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
parameter_list|,
name|RexProgram
name|program
parameter_list|,
name|RexFieldCollation
name|field
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|field
operator|.
name|left
argument_list|)
decl_stmt|;
name|SqlNode
name|nullDirectionNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getNullDirection
argument_list|()
operator|!=
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
condition|)
block|{
specifier|final
name|boolean
name|first
init|=
name|field
operator|.
name|getNullDirection
argument_list|()
operator|==
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
decl_stmt|;
name|nullDirectionNode
operator|=
name|dialect
operator|.
name|emulateNullDirection
argument_list|(
name|node
argument_list|,
name|first
argument_list|,
name|field
operator|.
name|getDirection
argument_list|()
operator|.
name|isDescending
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullDirectionNode
operator|!=
literal|null
condition|)
block|{
name|orderByList
operator|.
name|add
argument_list|(
name|nullDirectionNode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|orderByList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|orderByList
operator|.
name|add
argument_list|(
name|toSql
argument_list|(
name|program
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Converts a call to an aggregate function to an expression. */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|AggregateCall
name|aggCall
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|aggCall
operator|.
name|getAggregation
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|arg
range|:
name|aggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|operandList
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|instanceof
name|SqlCountAggFunction
operator|)
operator|&&
name|operandList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If there is no parameter in "count" function, add a star identifier to it
name|operandList
operator|.
name|add
argument_list|(
name|SqlIdentifier
operator|.
name|star
argument_list|(
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlLiteral
name|qualifier
init|=
name|aggCall
operator|.
name|isDistinct
argument_list|()
condition|?
name|SqlSelectKeyword
operator|.
name|DISTINCT
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
else|:
literal|null
decl_stmt|;
specifier|final
name|SqlNode
index|[]
name|operands
init|=
name|operandList
operator|.
name|toArray
argument_list|(
operator|new
name|SqlNode
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|field
range|:
name|aggCall
operator|.
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|addOrderItem
argument_list|(
name|orderByList
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
name|SqlNodeList
name|orderList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|orderByList
argument_list|,
name|POS
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|SqlSumEmptyIsZeroAggFunction
condition|)
block|{
specifier|final
name|SqlNode
name|node
init|=
name|withOrder
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
operator|.
name|createCall
argument_list|(
name|qualifier
argument_list|,
name|POS
argument_list|,
name|operands
argument_list|)
argument_list|,
name|orderList
argument_list|)
decl_stmt|;
return|return
name|SqlStdOperatorTable
operator|.
name|COALESCE
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0"
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|withOrder
argument_list|(
name|op
operator|.
name|createCall
argument_list|(
name|qualifier
argument_list|,
name|POS
argument_list|,
name|operands
argument_list|)
argument_list|,
name|orderList
argument_list|)
return|;
block|}
block|}
comment|/** Wraps a call in a {@link SqlKind#WITHIN_GROUP} call, if      * {@code orderList} is non-empty. */
specifier|private
name|SqlNode
name|withOrder
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlNodeList
name|orderList
parameter_list|)
block|{
if|if
condition|(
name|orderList
operator|==
literal|null
operator|||
name|orderList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|WITHIN_GROUP
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|call
argument_list|,
name|orderList
argument_list|)
return|;
block|}
comment|/** Converts a collation to an ORDER BY item. */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|RelFieldCollation
name|collation
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|orderField
argument_list|(
name|collation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|collation
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collation
operator|.
name|nullDirection
operator|!=
name|dialect
operator|.
name|defaultNullDirection
argument_list|(
name|collation
operator|.
name|direction
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|collation
operator|.
name|nullDirection
condition|)
block|{
case|case
name|FIRST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_FIRST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_LAST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|public
name|SqlImplementor
name|implementor
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|/** Simple implementation of {@link Context} that cannot handle sub-queries    * or correlations. Because it is so simple, you do not need to create a    * {@link SqlImplementor} or {@link org.apache.calcite.tools.RelBuilder}    * to use it. It is a good way to convert a {@link RexNode} to SQL text. */
specifier|public
specifier|static
class|class
name|SimpleContext
extends|extends
name|Context
block|{
annotation|@
name|Nonnull
specifier|private
specifier|final
name|IntFunction
argument_list|<
name|SqlNode
argument_list|>
name|field
decl_stmt|;
specifier|public
name|SimpleContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|IntFunction
argument_list|<
name|SqlNode
argument_list|>
name|field
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|field
operator|=
name|field
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|field
operator|.
name|apply
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link Context} that has an enclosing    * {@link SqlImplementor} and can therefore do non-trivial expressions. */
specifier|protected
specifier|abstract
class|class
name|BaseContext
extends|extends
name|Context
block|{
name|BaseContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|int
name|fieldCount
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|fieldCount
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Context
name|getAliasContext
parameter_list|(
name|RexCorrelVariable
name|variable
parameter_list|)
block|{
return|return
name|correlTableMap
operator|.
name|get
argument_list|(
name|variable
operator|.
name|id
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlImplementor
name|implementor
parameter_list|()
block|{
return|return
name|SqlImplementor
operator|.
name|this
return|;
block|}
block|}
specifier|private
specifier|static
name|int
name|computeFieldCount
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelDataType
name|type
range|:
name|aliases
operator|.
name|values
argument_list|()
control|)
block|{
name|x
operator|+=
name|type
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
specifier|public
name|Context
name|aliasContext
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|,
name|boolean
name|qualified
parameter_list|)
block|{
return|return
operator|new
name|AliasContext
argument_list|(
name|dialect
argument_list|,
name|aliases
argument_list|,
name|qualified
argument_list|)
return|;
block|}
specifier|public
name|Context
name|joinContext
parameter_list|(
name|Context
name|leftContext
parameter_list|,
name|Context
name|rightContext
parameter_list|)
block|{
return|return
operator|new
name|JoinContext
argument_list|(
name|dialect
argument_list|,
name|leftContext
argument_list|,
name|rightContext
argument_list|)
return|;
block|}
specifier|public
name|Context
name|matchRecognizeContext
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
return|return
operator|new
name|MatchRecognizeContext
argument_list|(
name|dialect
argument_list|,
operator|(
operator|(
name|AliasContext
operator|)
name|context
operator|)
operator|.
name|aliases
argument_list|)
return|;
block|}
specifier|public
name|Context
name|tableFunctionScanContext
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|inputSqlNodes
parameter_list|)
block|{
return|return
operator|new
name|TableFunctionScanContext
argument_list|(
name|dialect
argument_list|,
name|inputSqlNodes
argument_list|)
return|;
block|}
comment|/**    * Context for translating MATCH_RECOGNIZE clause    */
specifier|public
class|class
name|MatchRecognizeContext
extends|extends
name|AliasContext
block|{
specifier|protected
name|MatchRecognizeContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|aliases
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
if|if
condition|(
name|rex
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|LITERAL
condition|)
block|{
specifier|final
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
operator|==
name|SqlTypeFamily
operator|.
name|CHARACTER
condition|)
block|{
return|return
operator|new
name|SqlIdentifier
argument_list|(
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|literal
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
block|}
return|return
name|super
operator|.
name|toSql
argument_list|(
name|program
argument_list|,
name|rex
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of Context that precedes field references with their    * "table alias" based on the current sub-query's FROM clause. */
specifier|public
class|class
name|AliasContext
extends|extends
name|BaseContext
block|{
specifier|private
specifier|final
name|boolean
name|qualified
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
decl_stmt|;
comment|/** Creates an AliasContext; use {@link #aliasContext(Map, boolean)}. */
specifier|protected
name|AliasContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|,
name|boolean
name|qualified
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|computeFieldCount
argument_list|(
name|aliases
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
name|this
operator|.
name|qualified
operator|=
name|qualified
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|alias
range|:
name|aliases
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|alias
operator|.
name|getValue
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|ordinal
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|mappedSqlNode
init|=
name|ordinalMap
operator|.
name|get
argument_list|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mappedSqlNode
operator|!=
literal|null
condition|)
block|{
return|return
name|mappedSqlNode
return|;
block|}
return|return
operator|new
name|SqlIdentifier
argument_list|(
operator|!
name|qualified
condition|?
name|ImmutableList
operator|.
name|of
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
else|:
name|ImmutableList
operator|.
name|of
argument_list|(
name|alias
operator|.
name|getKey
argument_list|()
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
name|ordinal
operator|-=
name|fields
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"field ordinal "
operator|+
name|ordinal
operator|+
literal|" out of range "
operator|+
name|aliases
argument_list|)
throw|;
block|}
block|}
comment|/** Context for translating ON clause of a JOIN from {@link RexNode} to    * {@link SqlNode}. */
class|class
name|JoinContext
extends|extends
name|BaseContext
block|{
specifier|private
specifier|final
name|SqlImplementor
operator|.
name|Context
name|leftContext
decl_stmt|;
specifier|private
specifier|final
name|SqlImplementor
operator|.
name|Context
name|rightContext
decl_stmt|;
comment|/** Creates a JoinContext; use {@link #joinContext(Context, Context)}. */
specifier|private
name|JoinContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|Context
name|leftContext
parameter_list|,
name|Context
name|rightContext
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|leftContext
operator|.
name|fieldCount
operator|+
name|rightContext
operator|.
name|fieldCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|leftContext
operator|=
name|leftContext
expr_stmt|;
name|this
operator|.
name|rightContext
operator|=
name|rightContext
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
if|if
condition|(
name|ordinal
operator|<
name|leftContext
operator|.
name|fieldCount
condition|)
block|{
return|return
name|leftContext
operator|.
name|field
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rightContext
operator|.
name|field
argument_list|(
name|ordinal
operator|-
name|leftContext
operator|.
name|fieldCount
argument_list|)
return|;
block|}
block|}
block|}
comment|/** Context for translating call of a TableFunctionScan from {@link RexNode} to    * {@link SqlNode}. */
class|class
name|TableFunctionScanContext
extends|extends
name|BaseContext
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|inputSqlNodes
decl_stmt|;
name|TableFunctionScanContext
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|inputSqlNodes
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|,
name|inputSqlNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputSqlNodes
operator|=
name|inputSqlNodes
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|inputSqlNodes
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
block|}
comment|/** Result of implementing a node. */
specifier|public
class|class
name|Result
block|{
specifier|final
name|SqlNode
name|node
decl_stmt|;
specifier|final
name|String
name|neededAlias
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|neededType
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
decl_stmt|;
specifier|final
name|Expressions
operator|.
name|FluentList
argument_list|<
name|Clause
argument_list|>
name|clauses
decl_stmt|;
specifier|public
name|Result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|String
name|neededAlias
parameter_list|,
name|RelDataType
name|neededType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|neededAlias
operator|=
name|neededAlias
expr_stmt|;
name|this
operator|.
name|neededType
operator|=
name|neededType
expr_stmt|;
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
name|this
operator|.
name|clauses
operator|=
name|Expressions
operator|.
name|list
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
block|}
comment|/** Once you have a Result of implementing a child relational expression,      * call this method to create a Builder to implement the current relational      * expression by adding additional clauses to the SQL query.      *      *<p>You need to declare which clauses you intend to add. If the clauses      * are "later", you can add to the same query. For example, "GROUP BY" comes      * after "WHERE". But if they are the same or earlier, this method will      * start a new SELECT that wraps the previous result.      *      *<p>When you have called      * {@link Builder#setSelect(SqlNodeList)},      * {@link Builder#setWhere(SqlNode)} etc. call      * {@link Builder#result(SqlNode, Collection, RelNode, Map)}      * to fix the new query.      *      * @param rel Relational expression being implemented      * @param clauses Clauses that will be generated to implement current      *                relational expression      * @return A builder      */
specifier|public
name|Builder
name|builder
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Clause
modifier|...
name|clauses
parameter_list|)
block|{
specifier|final
name|boolean
name|needNew
init|=
name|needNewSubQuery
argument_list|(
name|rel
argument_list|,
name|clauses
argument_list|)
decl_stmt|;
name|SqlSelect
name|select
decl_stmt|;
name|Expressions
operator|.
name|FluentList
argument_list|<
name|Clause
argument_list|>
name|clauseList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|needNew
condition|)
block|{
name|select
operator|=
name|subSelect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|select
operator|=
name|asSelect
argument_list|()
expr_stmt|;
name|clauseList
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|clauses
argument_list|)
expr_stmt|;
block|}
name|clauseList
operator|.
name|appendAll
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
specifier|final
name|Context
name|newContext
decl_stmt|;
specifier|final
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
if|if
condition|(
name|selectList
operator|!=
literal|null
condition|)
block|{
name|newContext
operator|=
operator|new
name|Context
argument_list|(
name|dialect
argument_list|,
name|selectList
operator|.
name|size
argument_list|()
argument_list|)
block|{
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|SqlNode
name|selectItem
init|=
name|selectList
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|selectItem
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
return|return
operator|(
operator|(
name|SqlCall
operator|)
name|selectItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|selectItem
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|orderField
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
comment|// If the field expression is an unqualified column identifier
comment|// and matches a different alias, use an ordinal.
comment|// For example, given
comment|//    SELECT deptno AS empno, empno AS x FROM emp ORDER BY emp.empno
comment|// we generate
comment|//    SELECT deptno AS empno, empno AS x FROM emp ORDER BY 2
comment|// "ORDER BY empno" would give incorrect result;
comment|// "ORDER BY x" is acceptable but is not preferred.
specifier|final
name|SqlNode
name|node
init|=
name|field
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlIdentifier
operator|&&
operator|(
operator|(
name|SqlIdentifier
operator|)
name|node
operator|)
operator|.
name|isSimple
argument_list|()
condition|)
block|{
specifier|final
name|String
name|name
init|=
operator|(
operator|(
name|SqlIdentifier
operator|)
name|node
operator|)
operator|.
name|getSimple
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|selectItem
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|selectList
argument_list|)
control|)
block|{
if|if
condition|(
name|selectItem
operator|.
name|i
operator|!=
name|ordinal
condition|)
block|{
specifier|final
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|selectItem
operator|.
name|e
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
name|alias
argument_list|)
condition|)
block|{
return|return
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|ordinal
operator|+
literal|1
argument_list|)
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
name|node
return|;
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|qualified
init|=
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
operator|||
name|aliases
operator|.
name|size
argument_list|()
operator|>
literal|1
decl_stmt|;
comment|// basically, we did a subSelect() since needNew is set and neededAlias is not null
comment|// now, we need to make sure that we need to update the alias context.
comment|// if our aliases map has a single element:<neededAlias, rowType>,
comment|// then we don't need to rewrite the alias but otherwise, it should be updated.
if|if
condition|(
name|needNew
operator|&&
name|neededAlias
operator|!=
literal|null
operator|&&
operator|(
name|aliases
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
operator|!
name|aliases
operator|.
name|containsKey
argument_list|(
name|neededAlias
argument_list|)
operator|)
condition|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|newAliases
init|=
name|ImmutableMap
operator|.
name|of
argument_list|(
name|neededAlias
argument_list|,
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|newContext
operator|=
name|aliasContext
argument_list|(
name|newAliases
argument_list|,
name|qualified
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newContext
operator|=
name|aliasContext
argument_list|(
name|aliases
argument_list|,
name|qualified
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Builder
argument_list|(
name|rel
argument_list|,
name|clauseList
argument_list|,
name|select
argument_list|,
name|newContext
argument_list|,
name|needNew
condition|?
literal|null
else|:
name|aliases
argument_list|)
return|;
block|}
comment|/** Returns whether a new sub-query is required. */
specifier|private
name|boolean
name|needNewSubQuery
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Clause
index|[]
name|clauses
parameter_list|)
block|{
specifier|final
name|Clause
name|maxClause
init|=
name|maxClause
argument_list|()
decl_stmt|;
comment|// If old and new clause are equal and belong to below set,
comment|// then new SELECT wrap is not required
specifier|final
name|Set
argument_list|<
name|Clause
argument_list|>
name|nonWrapSet
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|SELECT
argument_list|)
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
if|if
condition|(
name|maxClause
operator|.
name|ordinal
argument_list|()
operator|>
name|clause
operator|.
name|ordinal
argument_list|()
operator|||
operator|(
name|maxClause
operator|==
name|clause
operator|&&
operator|!
name|nonWrapSet
operator|.
name|contains
argument_list|(
name|clause
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|rel
operator|instanceof
name|Project
operator|&&
name|this
operator|.
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|HAVING
argument_list|)
operator|&&
name|dialect
operator|.
name|getConformance
argument_list|()
operator|.
name|isHavingAlias
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|rel
operator|instanceof
name|Aggregate
condition|)
block|{
specifier|final
name|Aggregate
name|agg
init|=
operator|(
name|Aggregate
operator|)
name|rel
decl_stmt|;
specifier|final
name|boolean
name|hasNestedAgg
init|=
name|hasNestedAggregations
argument_list|(
name|agg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dialect
operator|.
name|supportsNestedAggregations
argument_list|()
operator|&&
name|hasNestedAgg
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|this
operator|.
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|GROUP_BY
argument_list|)
condition|)
block|{
comment|// Avoid losing the distinct attribute of inner aggregate.
return|return
operator|!
name|hasNestedAgg
operator|||
name|Aggregate
operator|.
name|isNotGrandTotal
argument_list|(
name|agg
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|hasNestedAggregations
parameter_list|(
name|Aggregate
name|rel
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlSelect
condition|)
block|{
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|(
operator|(
name|SqlSelect
operator|)
name|node
operator|)
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
if|if
condition|(
name|selectList
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|aggregatesArgs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggregateCall
range|:
name|rel
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
name|aggregatesArgs
operator|.
name|addAll
argument_list|(
name|aggregateCall
operator|.
name|getArgList
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|aggregatesArg
range|:
name|aggregatesArgs
control|)
block|{
if|if
condition|(
name|selectList
operator|.
name|get
argument_list|(
name|aggregatesArg
argument_list|)
operator|instanceof
name|SqlBasicCall
condition|)
block|{
specifier|final
name|SqlBasicCall
name|call
init|=
operator|(
name|SqlBasicCall
operator|)
name|selectList
operator|.
name|get
argument_list|(
name|aggregatesArg
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|instanceof
name|SqlCall
operator|&&
operator|(
operator|(
name|SqlCall
operator|)
name|operand
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlAggFunction
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Clause
name|maxClause
parameter_list|()
block|{
name|Clause
name|maxClause
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
if|if
condition|(
name|maxClause
operator|==
literal|null
operator|||
name|clause
operator|.
name|ordinal
argument_list|()
operator|>
name|maxClause
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|maxClause
operator|=
name|clause
expr_stmt|;
block|}
block|}
assert|assert
name|maxClause
operator|!=
literal|null
assert|;
return|return
name|maxClause
return|;
block|}
comment|/** Returns a node that can be included in the FROM clause or a JOIN. It has      * an alias that is unique within the query. The alias is implicit if it      * can be derived using the usual rules (For example, "SELECT * FROM emp" is      * equivalent to "SELECT * FROM emp AS emp".) */
specifier|public
name|SqlNode
name|asFrom
parameter_list|()
block|{
if|if
condition|(
name|neededAlias
operator|!=
literal|null
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|neededAlias
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
specifier|public
name|SqlSelect
name|subSelect
parameter_list|()
block|{
return|return
name|wrapSelect
argument_list|(
name|asFrom
argument_list|()
argument_list|)
return|;
block|}
comment|/** Converts a non-query node into a SELECT node. Set operators (UNION,      * INTERSECT, EXCEPT) remain as is. */
specifier|public
name|SqlSelect
name|asSelect
parameter_list|()
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlSelect
condition|)
block|{
return|return
operator|(
name|SqlSelect
operator|)
name|node
return|;
block|}
if|if
condition|(
operator|!
name|dialect
operator|.
name|hasImplicitTableAlias
argument_list|()
condition|)
block|{
return|return
name|wrapSelect
argument_list|(
name|asFrom
argument_list|()
argument_list|)
return|;
block|}
return|return
name|wrapSelect
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/** Converts a non-query node into a SELECT node. Set operators (UNION,      * INTERSECT, EXCEPT) and DML operators (INSERT, UPDATE, DELETE, MERGE)      * remain as is. */
specifier|public
name|SqlNode
name|asStatement
parameter_list|()
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|INSERT
case|:
case|case
name|UPDATE
case|:
case|case
name|DELETE
case|:
case|case
name|MERGE
case|:
return|return
name|node
return|;
default|default:
return|return
name|asSelect
argument_list|()
return|;
block|}
block|}
comment|/** Converts a non-query node into a SELECT node. Set operators (UNION,      * INTERSECT, EXCEPT) and VALUES remain as is. */
specifier|public
name|SqlNode
name|asQueryOrValues
parameter_list|()
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|VALUES
case|:
return|return
name|node
return|;
default|default:
return|return
name|asSelect
argument_list|()
return|;
block|}
block|}
comment|/** Returns a context that always qualifies identifiers. Useful if the      * Context deals with just one arm of a join, yet we wish to generate      * a join condition that qualifies column names to disambiguate them. */
specifier|public
name|Context
name|qualifiedContext
parameter_list|()
block|{
return|return
name|aliasContext
argument_list|(
name|aliases
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * In join, when the left and right nodes have been generated,      * update their alias with 'neededAlias' if not null.      */
specifier|public
name|Result
name|resetAlias
parameter_list|()
block|{
if|if
condition|(
name|neededAlias
operator|==
literal|null
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
return|return
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|neededAlias
argument_list|,
name|neededType
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
name|neededAlias
argument_list|,
name|neededType
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Sets the alias of the join or correlate just created.      *      * @param alias New alias      * @param type type of the node associated with the alias      */
specifier|public
name|Result
name|resetAlias
parameter_list|(
name|String
name|alias
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|alias
argument_list|,
name|neededType
argument_list|,
name|ImmutableMap
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Builder. */
specifier|public
class|class
name|Builder
block|{
specifier|private
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
decl_stmt|;
specifier|final
name|SqlSelect
name|select
decl_stmt|;
specifier|public
specifier|final
name|Context
name|context
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
decl_stmt|;
specifier|public
name|Builder
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|Context
name|context
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|clauses
operator|=
name|clauses
expr_stmt|;
name|this
operator|.
name|select
operator|=
name|select
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
block|}
specifier|public
name|void
name|setSelect
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
name|select
operator|.
name|setSelectList
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setWhere
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|WHERE
argument_list|)
assert|;
name|select
operator|.
name|setWhere
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setGroupBy
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|GROUP_BY
argument_list|)
assert|;
name|select
operator|.
name|setGroupBy
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setHaving
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|HAVING
argument_list|)
assert|;
name|select
operator|.
name|setHaving
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setOrderBy
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|ORDER_BY
argument_list|)
assert|;
name|select
operator|.
name|setOrderBy
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setFetch
parameter_list|(
name|SqlNode
name|fetch
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|FETCH
argument_list|)
assert|;
name|select
operator|.
name|setFetch
argument_list|(
name|fetch
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setOffset
parameter_list|(
name|SqlNode
name|offset
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|OFFSET
argument_list|)
assert|;
name|select
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addOrderItem
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
parameter_list|,
name|RelFieldCollation
name|field
parameter_list|)
block|{
name|context
operator|.
name|addOrderItem
argument_list|(
name|orderByList
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Result
name|result
parameter_list|()
block|{
return|return
name|SqlImplementor
operator|.
name|this
operator|.
name|result
argument_list|(
name|select
argument_list|,
name|clauses
argument_list|,
name|rel
argument_list|,
name|aliases
argument_list|)
return|;
block|}
block|}
comment|/** Clauses in a SQL query. Ordered by evaluation order.    * SELECT is set only when there is a NON-TRIVIAL SELECT clause. */
specifier|public
enum|enum
name|Clause
block|{
name|FROM
block|,
name|WHERE
block|,
name|GROUP_BY
block|,
name|HAVING
block|,
name|SELECT
block|,
name|SET_OP
block|,
name|ORDER_BY
block|,
name|FETCH
block|,
name|OFFSET
block|}
block|}
end_class

end_unit

