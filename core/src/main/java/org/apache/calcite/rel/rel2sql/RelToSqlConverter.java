begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rel2sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Calc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinConditionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDataTypeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunctionCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelectKeyword
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSetOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSingleValueAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSumEmptyIsZeroAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|BasicSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|InferTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|OperandTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/**  * Utility to convert RelNodes to SqlNode  */
end_comment

begin_class
specifier|public
class|class
name|RelToSqlConverter
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|RelToSqlConverter
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlParserPos
name|POS
init|=
name|SqlParserPos
operator|.
name|ZERO
decl_stmt|;
specifier|final
name|SqlDialect
name|dialect
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|aliasSet
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SqlNode
argument_list|>
name|ordinalMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|RelToSqlConverter
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|)
block|{
name|this
operator|.
name|dialect
operator|=
name|dialect
expr_stmt|;
block|}
comment|/**    * Creates a result based on a single relational expression.    */
specifier|public
name|Result
name|result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
specifier|final
name|String
name|alias2
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|node
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alias3
init|=
name|alias2
operator|!=
literal|null
condition|?
name|alias2
else|:
literal|"t"
decl_stmt|;
specifier|final
name|String
name|alias4
init|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|alias3
argument_list|,
name|aliasSet
argument_list|,
name|SqlValidatorUtil
operator|.
name|EXPR_SUGGESTER
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alias5
init|=
name|alias2
operator|==
literal|null
operator|||
operator|!
name|alias2
operator|.
name|equals
argument_list|(
name|alias4
argument_list|)
condition|?
name|alias4
else|:
literal|null
decl_stmt|;
return|return
operator|new
name|Result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|alias5
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|alias4
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a result based on a join. (Each join could contain one or more    * relational expressions.)    */
specifier|public
name|Result
name|result
parameter_list|(
name|SqlNode
name|join
parameter_list|,
name|Result
name|leftResult
parameter_list|,
name|Result
name|rightResult
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|list
operator|.
name|addAll
argument_list|(
name|leftResult
operator|.
name|aliases
argument_list|)
expr_stmt|;
name|list
operator|.
name|addAll
argument_list|(
name|rightResult
operator|.
name|aliases
argument_list|)
expr_stmt|;
return|return
operator|new
name|Result
argument_list|(
name|join
argument_list|,
name|Expressions
operator|.
name|list
argument_list|(
name|Clause
operator|.
name|FROM
argument_list|)
argument_list|,
literal|null
argument_list|,
name|list
argument_list|)
return|;
block|}
comment|/**    * Wraps a node in a SELECT statement that has no clauses:    * "SELECT ... FROM (node)".    */
name|SqlSelect
name|wrapSelect
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|instanceof
name|SqlJoin
operator|||
name|node
operator|instanceof
name|SqlIdentifier
operator|||
name|node
operator|instanceof
name|SqlCall
operator|&&
operator|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlSetOperator
operator|||
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|AS
operator|)
operator|:
name|node
assert|;
return|return
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visitChild
parameter_list|(
name|int
name|i
parameter_list|,
name|RelNode
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|Union
condition|)
block|{
return|return
name|visitUnion
argument_list|(
operator|(
name|Union
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|Join
condition|)
block|{
return|return
name|visitJoin
argument_list|(
operator|(
name|Join
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|Filter
condition|)
block|{
return|return
name|visitFilter
argument_list|(
operator|(
name|Filter
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|Project
condition|)
block|{
return|return
name|visitProject
argument_list|(
operator|(
name|Project
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|Aggregate
condition|)
block|{
return|return
name|visitAggregate
argument_list|(
operator|(
name|Aggregate
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|TableScan
condition|)
block|{
return|return
name|visitTableScan
argument_list|(
operator|(
name|TableScan
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|Intersect
condition|)
block|{
return|return
name|visitIntersect
argument_list|(
operator|(
name|Intersect
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|Minus
condition|)
block|{
return|return
name|visitMinus
argument_list|(
operator|(
name|Minus
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|Calc
condition|)
block|{
return|return
name|visitCalc
argument_list|(
operator|(
name|Calc
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|Sort
condition|)
block|{
return|return
name|visitSort
argument_list|(
operator|(
name|Sort
operator|)
name|e
argument_list|)
return|;
block|}
if|else if
condition|(
name|e
operator|instanceof
name|TableModify
condition|)
block|{
return|return
name|visitTableModify
argument_list|(
operator|(
name|TableModify
operator|)
name|e
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Need to Implement for "
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
comment|// TODO:
block|}
block|}
specifier|public
name|Result
name|visitUnion
parameter_list|(
name|Union
name|e
parameter_list|)
block|{
specifier|final
name|SqlSetOperator
name|operator
init|=
name|e
operator|.
name|all
condition|?
name|SqlStdOperatorTable
operator|.
name|UNION_ALL
else|:
name|SqlStdOperatorTable
operator|.
name|UNION
decl_stmt|;
return|return
name|setOpToSql
argument_list|(
name|operator
argument_list|,
name|e
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visitJoin
parameter_list|(
name|Join
name|e
parameter_list|)
block|{
specifier|final
name|Result
name|leftResult
init|=
name|visitChild
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|getLeft
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Result
name|rightResult
init|=
name|visitChild
argument_list|(
literal|1
argument_list|,
name|e
operator|.
name|getRight
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Context
name|leftContext
init|=
name|leftResult
operator|.
name|qualifiedContext
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|rightContext
init|=
name|rightResult
operator|.
name|qualifiedContext
argument_list|()
decl_stmt|;
name|SqlNode
name|sqlCondition
init|=
name|convertConditionToSqlNode
argument_list|(
name|e
operator|.
name|getCondition
argument_list|()
argument_list|,
name|leftContext
argument_list|,
name|rightContext
argument_list|,
name|e
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|SqlNode
name|join
init|=
operator|new
name|SqlJoin
argument_list|(
name|POS
argument_list|,
name|leftResult
operator|.
name|asFrom
argument_list|()
argument_list|,
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|false
argument_list|,
name|POS
argument_list|)
argument_list|,
name|joinType
argument_list|(
name|e
operator|.
name|getJoinType
argument_list|()
argument_list|)
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
argument_list|,
name|rightResult
operator|.
name|asFrom
argument_list|()
argument_list|,
name|JoinConditionType
operator|.
name|ON
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
argument_list|,
name|sqlCondition
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|join
argument_list|,
name|leftResult
argument_list|,
name|rightResult
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visitFilter
parameter_list|(
name|Filter
name|e
parameter_list|)
block|{
name|Result
name|x
init|=
name|visitChild
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|,
name|Clause
operator|.
name|WHERE
argument_list|)
decl_stmt|;
name|builder
operator|.
name|setWhere
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
specifier|public
name|Result
name|visitProject
parameter_list|(
name|Project
name|e
parameter_list|)
block|{
name|Result
name|x
init|=
name|visitChild
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|isStar
argument_list|(
name|e
operator|.
name|getChildExps
argument_list|()
argument_list|,
name|e
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|x
return|;
block|}
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|,
name|Clause
operator|.
name|SELECT
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|ref
range|:
name|e
operator|.
name|getChildExps
argument_list|()
control|)
block|{
name|SqlNode
name|sqlExpr
init|=
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|sqlExpr
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setSelect
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
specifier|public
name|Result
name|visitAggregate
parameter_list|(
name|Aggregate
name|e
parameter_list|)
block|{
comment|// "select a, b, sum(x) from ( ... ) group by a, b"
specifier|final
name|Result
name|x
init|=
name|visitChild
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Builder
name|builder
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Project
condition|)
block|{
name|builder
operator|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|builder
operator|.
name|clauses
operator|.
name|add
argument_list|(
name|Clause
operator|.
name|GROUP_BY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|,
name|Clause
operator|.
name|GROUP_BY
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupByList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|group
range|:
name|e
operator|.
name|getGroupSet
argument_list|()
control|)
block|{
specifier|final
name|SqlNode
name|field
init|=
name|builder
operator|.
name|context
operator|.
name|field
argument_list|(
name|group
argument_list|)
decl_stmt|;
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|field
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
name|groupByList
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|e
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
name|SqlNode
name|aggCallSqlNode
init|=
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
name|aggCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlSingleValueAggFunction
condition|)
block|{
name|aggCallSqlNode
operator|=
name|rewriteSingleValueExpr
argument_list|(
name|aggCallSqlNode
argument_list|,
name|dialect
argument_list|)
expr_stmt|;
block|}
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|aggCallSqlNode
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setSelect
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|groupByList
operator|.
name|isEmpty
argument_list|()
operator|||
name|e
operator|.
name|getAggCallList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Some databases don't support "GROUP BY ()". We can omit it as long
comment|// as there is at least one aggregate function.
name|builder
operator|.
name|setGroupBy
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|groupByList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
specifier|public
name|Result
name|visitTableScan
parameter_list|(
name|TableScan
name|e
parameter_list|)
block|{
return|return
name|result
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|e
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|Clause
operator|.
name|FROM
argument_list|)
argument_list|,
name|e
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visitIntersect
parameter_list|(
name|Intersect
name|e
parameter_list|)
block|{
return|return
name|setOpToSql
argument_list|(
name|e
operator|.
name|all
condition|?
name|SqlStdOperatorTable
operator|.
name|INTERSECT_ALL
else|:
name|SqlStdOperatorTable
operator|.
name|INTERSECT
argument_list|,
name|e
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visitMinus
parameter_list|(
name|Minus
name|e
parameter_list|)
block|{
return|return
name|setOpToSql
argument_list|(
name|e
operator|.
name|all
condition|?
name|SqlStdOperatorTable
operator|.
name|EXCEPT_ALL
else|:
name|SqlStdOperatorTable
operator|.
name|EXCEPT
argument_list|,
name|e
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visitCalc
parameter_list|(
name|Calc
name|e
parameter_list|)
block|{
name|Result
name|x
init|=
name|visitChild
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexProgram
name|program
init|=
name|e
operator|.
name|getProgram
argument_list|()
decl_stmt|;
name|Builder
name|builder
init|=
name|program
operator|.
name|getCondition
argument_list|()
operator|!=
literal|null
condition|?
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|,
name|Clause
operator|.
name|WHERE
argument_list|)
else|:
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isStar
argument_list|(
name|program
argument_list|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|ref
range|:
name|program
operator|.
name|getProjectList
argument_list|()
control|)
block|{
name|SqlNode
name|sqlExpr
init|=
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
name|program
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|sqlExpr
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setSelect
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|program
operator|.
name|getCondition
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setWhere
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
name|program
argument_list|,
name|program
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
specifier|public
name|Result
name|visitValues
parameter_list|(
name|Values
name|e
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|e
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
init|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|Clause
operator|.
name|SELECT
argument_list|)
decl_stmt|;
specifier|final
name|Context
name|context
init|=
operator|new
name|AliasContext
argument_list|(
name|Collections
operator|.
expr|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
operator|>
name|emptyList
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlSelect
argument_list|>
name|selects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|tuple
range|:
name|e
operator|.
name|getTuples
argument_list|()
control|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|RexLiteral
argument_list|,
name|String
argument_list|>
name|literal
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|tuple
argument_list|,
name|fields
argument_list|)
control|)
block|{
name|selectList
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|literal
operator|.
name|left
argument_list|)
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|literal
operator|.
name|right
argument_list|,
name|POS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|selects
operator|.
name|add
argument_list|(
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|query
init|=
literal|null
decl_stmt|;
for|for
control|(
name|SqlSelect
name|select
range|:
name|selects
control|)
block|{
if|if
condition|(
name|query
operator|==
literal|null
condition|)
block|{
name|query
operator|=
name|select
expr_stmt|;
block|}
else|else
block|{
name|query
operator|=
name|SqlStdOperatorTable
operator|.
name|UNION_ALL
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|query
argument_list|,
name|select
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
argument_list|(
name|query
argument_list|,
name|clauses
argument_list|,
name|e
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visitSort
parameter_list|(
name|Sort
name|e
parameter_list|)
block|{
specifier|final
name|Result
name|x
init|=
name|visitChild
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|,
name|Clause
operator|.
name|ORDER_BY
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|e
operator|.
name|getCollation
argument_list|()
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
if|if
condition|(
name|fieldCollation
operator|.
name|nullDirection
operator|!=
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
operator|&&
name|dialect
operator|.
name|getDatabaseProduct
argument_list|()
operator|==
name|SqlDialect
operator|.
name|DatabaseProduct
operator|.
name|MYSQL
condition|)
block|{
name|orderByList
operator|.
name|add
argument_list|(
name|ISNULL_FUNCTION
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|builder
operator|.
name|context
operator|.
name|field
argument_list|(
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fieldCollation
operator|=
operator|new
name|RelFieldCollation
argument_list|(
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|,
name|fieldCollation
operator|.
name|getDirection
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|orderByList
operator|.
name|add
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
name|fieldCollation
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setOrderBy
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|orderByList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
specifier|public
name|Result
name|visitTableModify
parameter_list|(
name|TableModify
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
comment|// TODO:
block|}
comment|/**    * MySQL specific function.    */
specifier|private
specifier|static
specifier|final
name|SqlFunction
name|ISNULL_FUNCTION
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ISNULL"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|,
name|SqlFunctionCategory
operator|.
name|SYSTEM
argument_list|)
decl_stmt|;
comment|/**    * Rewrite SINGLE_VALUE into expression based on database variants    * E.g. HSQLDB, MYSQL, ORACLE, etc    */
specifier|private
name|SqlNode
name|rewriteSingleValueExpr
parameter_list|(
name|SqlNode
name|aggCall
parameter_list|,
name|SqlDialect
name|sqlDialect
parameter_list|)
block|{
specifier|final
name|SqlNode
name|operand
init|=
operator|(
operator|(
name|SqlBasicCall
operator|)
name|aggCall
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|caseOperand
decl_stmt|;
specifier|final
name|SqlNode
name|elseExpr
decl_stmt|;
specifier|final
name|SqlNode
name|countCall
init|=
name|SqlStdOperatorTable
operator|.
name|COUNT
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operand
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|nullLiteral
init|=
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|wrappedOperand
decl_stmt|;
switch|switch
condition|(
name|sqlDialect
operator|.
name|getDatabaseProduct
argument_list|()
condition|)
block|{
case|case
name|MYSQL
case|:
case|case
name|HSQLDB
case|:
name|caseOperand
operator|=
name|countCall
expr_stmt|;
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|nullLiteral
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|unionOperand
decl_stmt|;
switch|switch
condition|(
name|sqlDialect
operator|.
name|getDatabaseProduct
argument_list|()
condition|)
block|{
case|case
name|MYSQL
case|:
name|wrappedOperand
operator|=
name|operand
expr_stmt|;
name|unionOperand
operator|=
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
name|selectList
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wrappedOperand
operator|=
name|SqlStdOperatorTable
operator|.
name|MIN
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|unionOperand
operator|=
name|SqlStdOperatorTable
operator|.
name|VALUES
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|SqlLiteral
operator|.
name|createApproxNumeric
argument_list|(
literal|"0"
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlCall
name|unionAll
init|=
name|SqlStdOperatorTable
operator|.
name|UNION_ALL
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|unionOperand
argument_list|,
name|unionOperand
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|subQuery
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
name|subQuery
operator|.
name|add
argument_list|(
name|unionAll
argument_list|)
expr_stmt|;
specifier|final
name|SqlNodeList
name|selectList2
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
name|selectList2
operator|.
name|add
argument_list|(
name|nullLiteral
argument_list|)
expr_stmt|;
name|elseExpr
operator|=
name|SqlStdOperatorTable
operator|.
name|SCALAR_QUERY
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|subQuery
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOGGER
operator|.
name|info
argument_list|(
literal|"SINGLE_VALUE rewrite not supported for "
operator|+
name|sqlDialect
operator|.
name|getDatabaseProduct
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|aggCall
return|;
block|}
specifier|final
name|SqlNodeList
name|whenList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
name|whenList
operator|.
name|add
argument_list|(
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0"
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
name|whenList
operator|.
name|add
argument_list|(
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SqlNodeList
name|thenList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
name|thenList
operator|.
name|add
argument_list|(
name|nullLiteral
argument_list|)
expr_stmt|;
name|thenList
operator|.
name|add
argument_list|(
name|wrappedOperand
argument_list|)
expr_stmt|;
name|SqlNode
name|caseExpr
init|=
operator|new
name|SqlCase
argument_list|(
name|POS
argument_list|,
name|caseOperand
argument_list|,
name|whenList
argument_list|,
name|thenList
argument_list|,
name|elseExpr
argument_list|)
decl_stmt|;
name|LOGGER
operator|.
name|info
argument_list|(
literal|"SINGLE_VALUE rewritten into ["
operator|+
name|caseExpr
operator|+
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|caseExpr
return|;
block|}
specifier|private
name|void
name|addSelect
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|String
name|name
init|=
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|selectList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|node
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"expr$"
argument_list|)
condition|)
block|{
comment|//Put it in ordinalMap
name|ordinalMap
operator|.
name|put
argument_list|(
name|name
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|alias
operator|==
literal|null
operator|||
operator|!
name|alias
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|name
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|selectList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isStar
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exps
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|ref
range|:
name|exps
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ref
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|else if
condition|(
operator|(
operator|(
name|RexInputRef
operator|)
name|ref
operator|)
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
operator|++
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|i
operator|==
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isStar
parameter_list|(
name|RexProgram
name|program
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|ref
range|:
name|program
operator|.
name|getProjectList
argument_list|()
control|)
block|{
if|if
condition|(
name|ref
operator|.
name|getIndex
argument_list|()
operator|!=
name|i
operator|++
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
name|i
operator|==
name|program
operator|.
name|getInputRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
return|;
block|}
specifier|private
name|Result
name|setOpToSql
parameter_list|(
name|SqlSetOperator
name|operator
parameter_list|,
name|RelNode
name|rel
parameter_list|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RelNode
argument_list|>
name|input
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|rel
operator|.
name|getInputs
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|Result
name|result
init|=
name|this
operator|.
name|visitChild
argument_list|(
name|input
operator|.
name|i
argument_list|,
name|input
operator|.
name|e
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|result
operator|.
name|asSelect
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlCall
name|node
init|=
name|operator
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|list
argument_list|,
name|POS
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
init|=
name|Expressions
operator|.
name|list
argument_list|(
name|Clause
operator|.
name|SET_OP
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|rel
argument_list|)
return|;
block|}
comment|/**    * Convert {@link RexNode} condition into {@link SqlNode}    *    * @param node           condition Node    * @param leftContext    LeftContext    * @param rightContext   RightContext    * @param leftFieldCount Number of field on left result    * @return SqlJoin which represent the condition    */
specifier|private
name|SqlNode
name|convertConditionToSqlNode
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|Context
name|leftContext
parameter_list|,
name|Context
name|rightContext
parameter_list|,
name|int
name|leftFieldCount
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|node
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
specifier|final
name|SqlOperator
name|op
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AND
case|:
case|case
name|OR
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
name|op
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
expr_stmt|;
name|SqlNode
name|sqlCondition
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RexNode
name|operand
range|:
name|operands
control|)
block|{
name|SqlNode
name|x
init|=
name|convertConditionToSqlNode
argument_list|(
name|operand
argument_list|,
name|leftContext
argument_list|,
name|rightContext
argument_list|,
name|leftFieldCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqlCondition
operator|==
literal|null
condition|)
block|{
name|sqlCondition
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|sqlCondition
operator|=
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|sqlCondition
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sqlCondition
return|;
case|case
name|EQUALS
case|:
case|case
name|IS_NOT_DISTINCT_FROM
case|:
case|case
name|NOT_EQUALS
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
name|operands
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
expr_stmt|;
name|op
operator|=
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
expr_stmt|;
if|if
condition|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|RexInputRef
operator|&&
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|RexInputRef
condition|)
block|{
specifier|final
name|RexInputRef
name|op0
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|op1
init|=
operator|(
name|RexInputRef
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|&&
name|op1
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
condition|)
block|{
comment|// Arguments were of form 'op0 = op1'
return|return
name|op
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|leftContext
operator|.
name|field
argument_list|(
name|op0
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|rightContext
operator|.
name|field
argument_list|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|op1
operator|.
name|getIndex
argument_list|()
operator|<
name|leftFieldCount
operator|&&
name|op0
operator|.
name|getIndex
argument_list|()
operator|>=
name|leftFieldCount
condition|)
block|{
comment|// Arguments were of form 'op1 = op0'
return|return
name|reverseOperatorDirection
argument_list|(
name|op
argument_list|)
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|leftContext
operator|.
name|field
argument_list|(
name|op1
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|rightContext
operator|.
name|field
argument_list|(
name|op0
operator|.
name|getIndex
argument_list|()
operator|-
name|leftFieldCount
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
name|node
argument_list|)
throw|;
block|}
specifier|private
specifier|static
name|SqlOperator
name|reverseOperatorDirection
parameter_list|(
name|SqlOperator
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
operator|.
name|kind
condition|)
block|{
case|case
name|GREATER_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|LESS_THAN_OR_EQUAL
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN_OR_EQUAL
return|;
case|case
name|EQUALS
case|:
case|case
name|IS_NOT_DISTINCT_FROM
case|:
case|case
name|NOT_EQUALS
case|:
return|return
name|op
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|op
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|JoinType
name|joinType
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|)
block|{
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
return|return
name|JoinType
operator|.
name|LEFT
return|;
case|case
name|RIGHT
case|:
return|return
name|JoinType
operator|.
name|RIGHT
return|;
case|case
name|INNER
case|:
return|return
name|JoinType
operator|.
name|INNER
return|;
case|case
name|FULL
case|:
return|return
name|JoinType
operator|.
name|FULL
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|joinType
argument_list|)
throw|;
block|}
block|}
comment|/**    * Context for translating a {@link RexNode} expression (within a    * {@link RelNode}) into a {@link SqlNode} expression (within a SQL parse    * tree).    */
specifier|public
specifier|abstract
class|class
name|Context
block|{
specifier|private
specifier|final
name|int
name|fieldCount
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|ignoreCast
decl_stmt|;
specifier|protected
name|Context
parameter_list|(
name|int
name|fieldCount
parameter_list|)
block|{
name|this
argument_list|(
name|fieldCount
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Context
parameter_list|(
name|int
name|fieldCount
parameter_list|,
name|boolean
name|ignoreCast
parameter_list|)
block|{
name|this
operator|.
name|fieldCount
operator|=
name|fieldCount
expr_stmt|;
name|this
operator|.
name|ignoreCast
operator|=
name|ignoreCast
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
function_decl|;
comment|/**      * Converts an expression from {@link RexNode} to {@link SqlNode}      * format.      */
name|SqlNode
name|toSql
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|RexNode
name|rex
parameter_list|)
block|{
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LOCAL_REF
case|:
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|RexLocalRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
return|return
name|toSql
argument_list|(
name|program
argument_list|,
name|program
operator|.
name|getExprList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
case|case
name|INPUT_REF
case|:
return|return
name|field
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
case|case
name|LITERAL
case|:
specifier|final
name|RexLiteral
name|literal
init|=
operator|(
name|RexLiteral
operator|)
name|rex
decl_stmt|;
if|if
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|==
name|SqlTypeName
operator|.
name|SYMBOL
condition|)
block|{
specifier|final
name|SqlLiteral
operator|.
name|SqlSymbol
name|symbol
init|=
operator|(
name|SqlLiteral
operator|.
name|SqlSymbol
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|SqlLiteral
operator|.
name|createSymbol
argument_list|(
name|symbol
argument_list|,
name|POS
argument_list|)
return|;
block|}
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
operator|.
name|getFamily
argument_list|()
condition|)
block|{
case|case
name|CHARACTER
case|:
return|return
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
operator|(
name|String
operator|)
name|literal
operator|.
name|getValue2
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|NUMERIC
case|:
case|case
name|EXACT_NUMERIC
case|:
return|return
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|literal
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|APPROXIMATE_NUMERIC
case|:
return|return
name|SqlLiteral
operator|.
name|createApproxNumeric
argument_list|(
name|literal
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|BOOLEAN
case|:
return|return
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
operator|(
name|Boolean
operator|)
name|literal
operator|.
name|getValue
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|DATE
case|:
return|return
name|SqlLiteral
operator|.
name|createDate
argument_list|(
operator|(
name|Calendar
operator|)
name|literal
operator|.
name|getValue
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|TIME
case|:
return|return
name|SqlLiteral
operator|.
name|createTime
argument_list|(
operator|(
name|Calendar
operator|)
name|literal
operator|.
name|getValue
argument_list|()
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|SqlLiteral
operator|.
name|createTimestamp
argument_list|(
operator|(
name|Calendar
operator|)
name|literal
operator|.
name|getValue
argument_list|()
argument_list|,
name|literal
operator|.
name|getType
argument_list|()
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|ANY
case|:
case|case
name|NULL
case|:
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|NULL
case|:
return|return
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|POS
argument_list|)
return|;
comment|// fall through
block|}
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|literal
operator|+
literal|": "
operator|+
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
case|case
name|CASE
case|:
specifier|final
name|RexCall
name|caseCall
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|caseNodeList
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|caseCall
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|valueNode
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|whenList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|thenList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|elseNode
decl_stmt|;
if|if
condition|(
name|caseNodeList
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
comment|// switched:
comment|//   "case x when v1 then t1 when v2 then t2 ... else e end"
name|valueNode
operator|=
name|caseNodeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|whenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|thenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// other: "case when w1 then t1 when w2 then t2 ... else e end"
name|valueNode
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|whenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|thenList
operator|.
name|add
argument_list|(
name|caseNodeList
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|elseNode
operator|=
name|caseNodeList
operator|.
name|get
argument_list|(
name|caseNodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlCase
argument_list|(
name|POS
argument_list|,
name|valueNode
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|whenList
argument_list|,
name|POS
argument_list|)
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|thenList
argument_list|,
name|POS
argument_list|)
argument_list|,
name|elseNode
argument_list|)
return|;
default|default:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|rex
decl_stmt|;
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodeList
init|=
name|toSql
argument_list|(
name|program
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rex
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|CAST
case|:
if|if
condition|(
operator|!
name|ignoreCast
condition|)
block|{
name|nodeList
operator|.
name|add
argument_list|(
name|toSql
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|nodeList
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|nodeList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|op
operator|instanceof
name|SqlBinaryOperator
operator|&&
name|nodeList
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
comment|// In RexNode trees, OR and AND have any number of children;
comment|// SqlCall requires exactly 2. So, convert to a left-deep binary tree.
return|return
name|createLeftCall
argument_list|(
name|op
argument_list|,
name|nodeList
argument_list|)
return|;
block|}
return|return
name|op
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|nodeList
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|private
name|SqlNode
name|createLeftCall
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodeList
parameter_list|)
block|{
if|if
condition|(
name|nodeList
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
return|return
name|op
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|nodeList
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|butLast
init|=
name|Util
operator|.
name|skipLast
argument_list|(
name|nodeList
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|last
init|=
name|nodeList
operator|.
name|get
argument_list|(
name|nodeList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|call
init|=
name|createLeftCall
argument_list|(
name|op
argument_list|,
name|butLast
argument_list|)
decl_stmt|;
return|return
name|op
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|call
argument_list|,
name|last
argument_list|)
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|toSql
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|dialect
operator|.
name|getDatabaseProduct
argument_list|()
condition|)
block|{
case|case
name|MYSQL
case|:
switch|switch
condition|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
condition|)
block|{
case|case
name|VARCHAR
case|:
comment|// MySQL doesn't have a VARCHAR type, only CHAR.
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
literal|"CHAR"
argument_list|,
name|POS
argument_list|)
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|POS
argument_list|)
return|;
case|case
name|INTEGER
case|:
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
literal|"_UNSIGNED"
argument_list|,
name|POS
argument_list|)
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|POS
argument_list|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|type
operator|instanceof
name|BasicSqlType
condition|)
block|{
return|return
operator|new
name|SqlDataTypeSpec
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|POS
argument_list|)
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|type
operator|.
name|getScale
argument_list|()
argument_list|,
name|type
operator|.
name|getCharset
argument_list|()
operator|!=
literal|null
operator|&&
name|dialect
operator|.
name|supportsCharSet
argument_list|()
condition|?
name|type
operator|.
name|getCharset
argument_list|()
operator|.
name|name
argument_list|()
else|:
literal|null
argument_list|,
literal|null
argument_list|,
name|POS
argument_list|)
return|;
block|}
return|return
name|SqlTypeUtil
operator|.
name|convertTypeToSpec
argument_list|(
name|type
argument_list|)
return|;
comment|//throw new AssertionError(type); // TODO: implement
block|}
specifier|private
name|List
argument_list|<
name|SqlNode
argument_list|>
name|toSql
parameter_list|(
name|RexProgram
name|program
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|operandList
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|rex
range|:
name|operandList
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|toSql
argument_list|(
name|program
argument_list|,
name|rex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|public
name|List
argument_list|<
name|SqlNode
argument_list|>
name|fieldList
parameter_list|()
block|{
return|return
operator|new
name|AbstractList
argument_list|<
name|SqlNode
argument_list|>
argument_list|()
block|{
specifier|public
name|SqlNode
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|field
argument_list|(
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fieldCount
return|;
block|}
block|}
return|;
block|}
comment|/**      * Converts a call to an aggregate function to an expression.      */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|AggregateCall
name|aggCall
parameter_list|)
block|{
name|SqlOperator
name|op
init|=
operator|(
name|SqlAggFunction
operator|)
name|aggCall
operator|.
name|getAggregation
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|SqlSumEmptyIsZeroAggFunction
condition|)
block|{
name|op
operator|=
name|SqlStdOperatorTable
operator|.
name|SUM
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|arg
range|:
name|aggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|operands
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|op
operator|.
name|createCall
argument_list|(
name|aggCall
operator|.
name|isDistinct
argument_list|()
condition|?
name|SqlSelectKeyword
operator|.
name|DISTINCT
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
else|:
literal|null
argument_list|,
name|POS
argument_list|,
name|operands
operator|.
name|toArray
argument_list|(
operator|new
name|SqlNode
index|[
name|operands
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Converts a collation to an ORDER BY item.      */
specifier|public
name|SqlNode
name|toSql
parameter_list|(
name|RelFieldCollation
name|collation
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|field
argument_list|(
name|collation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|collation
operator|.
name|getDirection
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
case|case
name|STRICTLY_DESCENDING
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|DESC
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|collation
operator|.
name|nullDirection
condition|)
block|{
case|case
name|FIRST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_FIRST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|NULLS_LAST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|node
return|;
block|}
block|}
specifier|private
specifier|static
name|int
name|computeFieldCount
parameter_list|(
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|aliases
parameter_list|)
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|alias
range|:
name|aliases
control|)
block|{
name|x
operator|+=
name|alias
operator|.
name|right
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
comment|/**    * Implementation of Context that precedes field references with their    * "table alias" based on the current sub-query's FROM clause.    */
specifier|public
class|class
name|AliasContext
extends|extends
name|Context
block|{
specifier|private
specifier|final
name|boolean
name|qualified
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|aliases
decl_stmt|;
specifier|public
name|AliasContext
parameter_list|(
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|aliases
parameter_list|,
name|boolean
name|qualified
parameter_list|)
block|{
name|super
argument_list|(
name|computeFieldCount
argument_list|(
name|aliases
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
name|this
operator|.
name|qualified
operator|=
name|qualified
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|alias
range|:
name|aliases
control|)
block|{
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
init|=
name|alias
operator|.
name|right
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|ordinal
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|)
block|{
name|RelDataTypeField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|mappedSqlNode
init|=
name|ordinalMap
operator|.
name|get
argument_list|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mappedSqlNode
operator|!=
literal|null
condition|)
block|{
return|return
name|mappedSqlNode
return|;
block|}
else|else
block|{
return|return
operator|new
name|SqlIdentifier
argument_list|(
operator|!
name|qualified
condition|?
name|ImmutableList
operator|.
name|of
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
else|:
name|ImmutableList
operator|.
name|of
argument_list|(
name|alias
operator|.
name|left
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
block|}
name|ordinal
operator|-=
name|fields
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"field ordinal "
operator|+
name|ordinal
operator|+
literal|" out of range "
operator|+
name|aliases
argument_list|)
throw|;
block|}
block|}
comment|/**    * Result of implementing a node.    */
specifier|public
class|class
name|Result
block|{
specifier|final
name|SqlNode
name|node
decl_stmt|;
specifier|private
specifier|final
name|String
name|neededAlias
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|aliases
decl_stmt|;
specifier|final
name|Expressions
operator|.
name|FluentList
argument_list|<
name|Clause
argument_list|>
name|clauses
decl_stmt|;
specifier|private
name|Result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|String
name|neededAlias
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|aliases
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|neededAlias
operator|=
name|neededAlias
expr_stmt|;
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
name|this
operator|.
name|clauses
operator|=
name|Expressions
operator|.
name|list
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
block|}
comment|/**      * Once you have a Result of implementing a child relational expression,      * call this method to create a Builder to implement the current relational      * expression by adding additional clauses to the SQL query.      *      *<p>You need to declare which clauses you intend to add. If the clauses      * are "later", you can add to the same query. For example, "GROUP BY" comes      * after "WHERE". But if they are the same or earlier, this method will      * start a new SELECT that wraps the previous result.      *      *<p>When you have called      * {@link Builder#setSelect(org.apache.calcite.sql.SqlNodeList)},      * {@link Builder#setWhere(org.apache.calcite.sql.SqlNode)} etc. call      * {@link Builder#result(org.apache.calcite.sql.SqlNode, java.util.Collection, org.apache.calcite.rel.RelNode)}      * to fix the new query.      *      * @param rel     Relational expression being implemented      * @param clauses Clauses that will be generated to implement current      *                relational expression      * @return A builder      */
specifier|public
name|Builder
name|builder
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|Clause
modifier|...
name|clauses
parameter_list|)
block|{
specifier|final
name|Clause
name|maxClause
init|=
name|maxClause
argument_list|()
decl_stmt|;
name|boolean
name|needNew
init|=
literal|false
decl_stmt|;
comment|// If old and new clause are equal and belong to below set,
comment|// then new SELECT wrap is not required
name|Set
argument_list|<
name|Clause
argument_list|>
name|nonWrapSet
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|SELECT
argument_list|)
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
if|if
condition|(
name|maxClause
operator|.
name|ordinal
argument_list|()
operator|>
name|clause
operator|.
name|ordinal
argument_list|()
operator|||
operator|(
name|maxClause
operator|.
name|equals
argument_list|(
name|clause
argument_list|)
operator|&&
operator|!
name|nonWrapSet
operator|.
name|contains
argument_list|(
name|clause
argument_list|)
operator|)
condition|)
block|{
name|needNew
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|SqlSelect
name|select
decl_stmt|;
name|Expressions
operator|.
name|FluentList
argument_list|<
name|Clause
argument_list|>
name|clauseList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|needNew
condition|)
block|{
name|select
operator|=
name|subSelect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|select
operator|=
name|asSelect
argument_list|()
expr_stmt|;
name|clauseList
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|clauses
argument_list|)
expr_stmt|;
block|}
name|clauseList
operator|.
name|appendAll
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
name|Context
name|newContext
decl_stmt|;
specifier|final
name|SqlNodeList
name|selectList
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
if|if
condition|(
name|selectList
operator|!=
literal|null
condition|)
block|{
name|newContext
operator|=
operator|new
name|Context
argument_list|(
name|selectList
operator|.
name|size
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|SqlNode
name|field
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
specifier|final
name|SqlNode
name|selectItem
init|=
name|selectList
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|selectItem
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
return|return
operator|(
operator|(
name|SqlCall
operator|)
name|selectItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|selectItem
return|;
block|}
block|}
expr_stmt|;
block|}
else|else
block|{
name|newContext
operator|=
operator|new
name|AliasContext
argument_list|(
name|aliases
argument_list|,
name|aliases
operator|.
name|size
argument_list|()
operator|>
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Builder
argument_list|(
name|rel
argument_list|,
name|clauseList
argument_list|,
name|select
argument_list|,
name|newContext
argument_list|)
return|;
block|}
comment|// make private?
specifier|public
name|Clause
name|maxClause
parameter_list|()
block|{
name|Clause
name|maxClause
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Clause
name|clause
range|:
name|clauses
control|)
block|{
if|if
condition|(
name|maxClause
operator|==
literal|null
operator|||
name|clause
operator|.
name|ordinal
argument_list|()
operator|>
name|maxClause
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|maxClause
operator|=
name|clause
expr_stmt|;
block|}
block|}
assert|assert
name|maxClause
operator|!=
literal|null
assert|;
return|return
name|maxClause
return|;
block|}
comment|/**      * Returns a node that can be included in the FROM clause or a JOIN. It has      * an alias that is unique within the query. The alias is implicit if it      * can be derived using the usual rules (For example, "SELECT * FROM emp" is      * equivalent to "SELECT * FROM emp AS emp".)      */
specifier|public
name|SqlNode
name|asFrom
parameter_list|()
block|{
if|if
condition|(
name|neededAlias
operator|!=
literal|null
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|node
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|neededAlias
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
return|return
name|node
return|;
block|}
specifier|public
name|SqlSelect
name|subSelect
parameter_list|()
block|{
return|return
name|wrapSelect
argument_list|(
name|asFrom
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Converts a non-query node into a SELECT node. Set operators (UNION,      * INTERSECT, EXCEPT) remain as is.      */
name|SqlSelect
name|asSelect
parameter_list|()
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlSelect
condition|)
block|{
return|return
operator|(
name|SqlSelect
operator|)
name|node
return|;
block|}
return|return
name|wrapSelect
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**      * Converts a non-query node into a SELECT node. Set operators (UNION,      * INTERSECT, EXCEPT) remain as is.      */
specifier|public
name|SqlNode
name|asQuery
parameter_list|()
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
operator|&&
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlSetOperator
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|asSelect
argument_list|()
return|;
block|}
comment|/**      * Returns a context that always qualifies identifiers. Useful if the      * Context deals with just one arm of a join, yet we wish to generate      * a join condition that qualifies column names to disambiguate them.      */
specifier|public
name|Context
name|qualifiedContext
parameter_list|()
block|{
return|return
operator|new
name|AliasContext
argument_list|(
name|aliases
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
comment|/**    * Builder.    */
specifier|public
class|class
name|Builder
block|{
specifier|private
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
decl_stmt|;
specifier|private
specifier|final
name|SqlSelect
name|select
decl_stmt|;
specifier|public
specifier|final
name|Context
name|context
decl_stmt|;
specifier|public
name|Builder
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|Context
name|context
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|clauses
operator|=
name|clauses
expr_stmt|;
name|this
operator|.
name|select
operator|=
name|select
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
specifier|public
name|void
name|setSelect
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
name|select
operator|.
name|setSelectList
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setWhere
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|WHERE
argument_list|)
assert|;
name|select
operator|.
name|setWhere
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setGroupBy
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|GROUP_BY
argument_list|)
assert|;
name|select
operator|.
name|setGroupBy
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setOrderBy
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|ORDER_BY
argument_list|)
assert|;
name|select
operator|.
name|setOrderBy
argument_list|(
name|nodeList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setfetch
parameter_list|(
name|SqlNode
name|fetch
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|FETCH
argument_list|)
assert|;
name|select
operator|.
name|setFetch
argument_list|(
name|fetch
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setOffset
parameter_list|(
name|SqlNode
name|offset
parameter_list|)
block|{
assert|assert
name|clauses
operator|.
name|contains
argument_list|(
name|Clause
operator|.
name|OFFSET
argument_list|)
assert|;
name|select
operator|.
name|setOffset
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Result
name|result
parameter_list|()
block|{
return|return
name|RelToSqlConverter
operator|.
name|this
operator|.
name|result
argument_list|(
name|select
argument_list|,
name|clauses
argument_list|,
name|rel
argument_list|)
return|;
block|}
block|}
comment|/**    * Clauses in a SQL query. Ordered by evaluation order.    * SELECT is set only when there is a NON-TRIVIAL SELECT clause.    */
enum|enum
name|Clause
block|{
name|FROM
block|,
name|WHERE
block|,
name|GROUP_BY
block|,
name|HAVING
block|,
name|SELECT
block|,
name|SET_OP
block|,
name|ORDER_BY
block|,
name|FETCH
block|,
name|OFFSET
block|}
block|}
end_class

end_unit

