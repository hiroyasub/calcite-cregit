begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rel2sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|jdbc
operator|.
name|JdbcTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Calc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Intersect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Match
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Minus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableFunctionScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableModify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Uncollect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Union
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Window
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinConditionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDelete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDialect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlInsert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMatchRecognize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUpdate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlRowOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlSingleValueAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Permutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ReflectUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ReflectiveVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Ordering
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_comment
comment|/**  * Utility to convert relational expressions to SQL abstract syntax tree.  */
end_comment

begin_class
specifier|public
class|class
name|RelToSqlConverter
extends|extends
name|SqlImplementor
implements|implements
name|ReflectiveVisitor
block|{
comment|/** Similar to {@link SqlStdOperatorTable#ROW}, but does not print "ROW". */
specifier|private
specifier|static
specifier|final
name|SqlRowOperator
name|ANONYMOUS_ROW
init|=
operator|new
name|SqlRowOperator
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ReflectUtil
operator|.
name|MethodDispatcher
argument_list|<
name|Result
argument_list|>
name|dispatcher
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|Frame
argument_list|>
name|stack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Creates a RelToSqlConverter. */
specifier|public
name|RelToSqlConverter
parameter_list|(
name|SqlDialect
name|dialect
parameter_list|)
block|{
name|super
argument_list|(
name|dialect
argument_list|)
expr_stmt|;
name|dispatcher
operator|=
name|ReflectUtil
operator|.
name|createMethodDispatcher
argument_list|(
name|Result
operator|.
name|class
argument_list|,
name|this
argument_list|,
literal|"visit"
argument_list|,
name|RelNode
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/** Dispatches a call to the {@code visit(Xxx e)} method where {@code Xxx}    * most closely matches the runtime type of the argument. */
specifier|protected
name|Result
name|dispatch
parameter_list|(
name|RelNode
name|e
parameter_list|)
block|{
return|return
name|dispatcher
operator|.
name|invoke
argument_list|(
name|e
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Result
name|visitInput
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|i
parameter_list|,
name|boolean
name|anon
parameter_list|,
name|boolean
name|ignoreClauses
parameter_list|,
name|Set
argument_list|<
name|Clause
argument_list|>
name|expectedClauses
parameter_list|)
block|{
try|try
block|{
specifier|final
name|RelNode
name|e
init|=
name|parent
operator|.
name|getInput
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|parent
argument_list|,
name|i
argument_list|,
name|e
argument_list|,
name|anon
argument_list|,
name|ignoreClauses
argument_list|,
name|expectedClauses
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dispatch
argument_list|(
name|e
argument_list|)
return|;
block|}
finally|finally
block|{
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isAnon
parameter_list|()
block|{
return|return
name|stack
operator|.
name|isEmpty
argument_list|()
operator|||
name|stack
operator|.
name|peek
argument_list|()
operator|.
name|anon
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Result
name|result
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Collection
argument_list|<
name|Clause
argument_list|>
name|clauses
parameter_list|,
name|String
name|neededAlias
parameter_list|,
name|RelDataType
name|neededType
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|aliases
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|stack
operator|.
name|peek
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|super
operator|.
name|result
argument_list|(
name|node
argument_list|,
name|clauses
argument_list|,
name|neededAlias
argument_list|,
name|neededType
argument_list|,
name|aliases
argument_list|)
operator|.
name|withAnon
argument_list|(
name|isAnon
argument_list|()
argument_list|)
operator|.
name|withExpectedClauses
argument_list|(
name|frame
operator|.
name|ignoreClauses
argument_list|,
name|frame
operator|.
name|expectedClauses
argument_list|,
name|frame
operator|.
name|parent
argument_list|)
return|;
block|}
comment|/** Visits a RelNode; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|RelNode
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Need to implement "
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * A SqlShuttle to replace references to a column of a table alias with the expression    * from the select item that is the source of that column.    * ANTI- and SEMI-joins generate an alias for right hand side relation which    * is used in the ON condition. But that alias is never created, so we have to inline references.    */
specifier|private
specifier|static
class|class
name|AliasReplacementShuttle
extends|extends
name|SqlShuttle
block|{
specifier|private
specifier|final
name|String
name|tableAlias
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|tableType
decl_stmt|;
specifier|private
specifier|final
name|SqlNodeList
name|replaceSource
decl_stmt|;
name|AliasReplacementShuttle
parameter_list|(
name|String
name|tableAlias
parameter_list|,
name|RelDataType
name|tableType
parameter_list|,
name|SqlNodeList
name|replaceSource
parameter_list|)
block|{
name|this
operator|.
name|tableAlias
operator|=
name|tableAlias
expr_stmt|;
name|this
operator|.
name|tableType
operator|=
name|tableType
expr_stmt|;
name|this
operator|.
name|replaceSource
operator|=
name|replaceSource
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
if|if
condition|(
name|tableAlias
operator|.
name|equals
argument_list|(
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|index
init|=
name|tableType
operator|.
name|getField
argument_list|(
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|SqlNode
name|selectItem
init|=
name|replaceSource
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectItem
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
condition|)
block|{
name|selectItem
operator|=
operator|(
operator|(
name|SqlCall
operator|)
name|selectItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|selectItem
operator|.
name|clone
argument_list|(
name|id
operator|.
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
return|return
name|id
return|;
block|}
block|}
comment|/** Visits a Join; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Join
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getJoinType
argument_list|()
condition|)
block|{
case|case
name|ANTI
case|:
case|case
name|SEMI
case|:
return|return
name|visitAntiOrSemiJoin
argument_list|(
name|e
argument_list|)
return|;
default|default:
break|break;
block|}
specifier|final
name|Result
name|leftResult
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
operator|.
name|resetAlias
argument_list|()
decl_stmt|;
specifier|final
name|Result
name|rightResult
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
operator|.
name|resetAlias
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|leftContext
init|=
name|leftResult
operator|.
name|qualifiedContext
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|rightContext
init|=
name|rightResult
operator|.
name|qualifiedContext
argument_list|()
decl_stmt|;
name|SqlNode
name|sqlCondition
init|=
literal|null
decl_stmt|;
name|SqlLiteral
name|condType
init|=
name|JoinConditionType
operator|.
name|ON
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
decl_stmt|;
name|JoinType
name|joinType
init|=
name|joinType
argument_list|(
name|e
operator|.
name|getJoinType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCrossJoin
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|joinType
operator|=
name|dialect
operator|.
name|emulateJoinTypeForCrossJoin
argument_list|()
expr_stmt|;
name|condType
operator|=
name|JoinConditionType
operator|.
name|NONE
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqlCondition
operator|=
name|convertConditionToSqlNode
argument_list|(
name|e
operator|.
name|getCondition
argument_list|()
argument_list|,
name|leftContext
argument_list|,
name|rightContext
argument_list|,
name|e
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|dialect
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|join
init|=
operator|new
name|SqlJoin
argument_list|(
name|POS
argument_list|,
name|leftResult
operator|.
name|asFrom
argument_list|()
argument_list|,
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|false
argument_list|,
name|POS
argument_list|)
argument_list|,
name|joinType
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
argument_list|,
name|rightResult
operator|.
name|asFrom
argument_list|()
argument_list|,
name|condType
argument_list|,
name|sqlCondition
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|join
argument_list|,
name|leftResult
argument_list|,
name|rightResult
argument_list|)
return|;
block|}
specifier|protected
name|Result
name|visitAntiOrSemiJoin
parameter_list|(
name|Join
name|e
parameter_list|)
block|{
specifier|final
name|Result
name|leftResult
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
operator|.
name|resetAlias
argument_list|()
decl_stmt|;
specifier|final
name|Result
name|rightResult
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
operator|.
name|resetAlias
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|leftContext
init|=
name|leftResult
operator|.
name|qualifiedContext
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|rightContext
init|=
name|rightResult
operator|.
name|qualifiedContext
argument_list|()
decl_stmt|;
specifier|final
name|SqlSelect
name|sqlSelect
init|=
name|leftResult
operator|.
name|asSelect
argument_list|()
decl_stmt|;
name|SqlNode
name|sqlCondition
init|=
name|convertConditionToSqlNode
argument_list|(
name|e
operator|.
name|getCondition
argument_list|()
argument_list|,
name|leftContext
argument_list|,
name|rightContext
argument_list|,
name|e
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|dialect
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftResult
operator|.
name|neededAlias
operator|!=
literal|null
condition|)
block|{
name|SqlVisitor
argument_list|<
name|SqlNode
argument_list|>
name|visitor
init|=
operator|new
name|AliasReplacementShuttle
argument_list|(
name|leftResult
operator|.
name|neededAlias
argument_list|,
name|e
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|sqlSelect
operator|.
name|getSelectList
argument_list|()
argument_list|)
decl_stmt|;
name|sqlCondition
operator|=
name|sqlCondition
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|fromPart
init|=
name|rightResult
operator|.
name|asFrom
argument_list|()
decl_stmt|;
name|SqlSelect
name|existsSqlSelect
decl_stmt|;
if|if
condition|(
name|fromPart
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|SELECT
condition|)
block|{
name|existsSqlSelect
operator|=
operator|(
name|SqlSelect
operator|)
name|fromPart
expr_stmt|;
name|existsSqlSelect
operator|.
name|setSelectList
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|POS
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|existsSqlSelect
operator|.
name|getWhere
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sqlCondition
operator|=
name|SqlStdOperatorTable
operator|.
name|AND
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|existsSqlSelect
operator|.
name|getWhere
argument_list|()
argument_list|,
name|sqlCondition
argument_list|)
expr_stmt|;
block|}
name|existsSqlSelect
operator|.
name|setWhere
argument_list|(
name|sqlCondition
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|existsSqlSelect
operator|=
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
literal|null
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|POS
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
argument_list|,
name|fromPart
argument_list|,
name|sqlCondition
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|sqlCondition
operator|=
name|SqlStdOperatorTable
operator|.
name|EXISTS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|existsSqlSelect
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|ANTI
condition|)
block|{
name|sqlCondition
operator|=
name|SqlStdOperatorTable
operator|.
name|NOT
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|sqlCondition
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sqlSelect
operator|.
name|getWhere
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sqlCondition
operator|=
name|SqlStdOperatorTable
operator|.
name|AND
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|sqlSelect
operator|.
name|getWhere
argument_list|()
argument_list|,
name|sqlCondition
argument_list|)
expr_stmt|;
block|}
name|sqlSelect
operator|.
name|setWhere
argument_list|(
name|sqlCondition
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|resultNode
init|=
name|leftResult
operator|.
name|neededAlias
operator|==
literal|null
condition|?
name|sqlSelect
else|:
name|as
argument_list|(
name|sqlSelect
argument_list|,
name|leftResult
operator|.
name|neededAlias
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|resultNode
argument_list|,
name|leftResult
argument_list|,
name|rightResult
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isCrossJoin
parameter_list|(
specifier|final
name|Join
name|e
parameter_list|)
block|{
return|return
name|e
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|INNER
operator|&&
name|e
operator|.
name|getCondition
argument_list|()
operator|.
name|isAlwaysTrue
argument_list|()
return|;
block|}
comment|/** Visits a Correlate; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Correlate
name|e
parameter_list|)
block|{
specifier|final
name|Result
name|leftResult
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
operator|.
name|resetAlias
argument_list|(
name|e
operator|.
name|getCorrelVariable
argument_list|()
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
name|parseCorrelTable
argument_list|(
name|e
argument_list|,
name|leftResult
argument_list|)
expr_stmt|;
specifier|final
name|Result
name|rightResult
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|rightLateral
init|=
name|SqlStdOperatorTable
operator|.
name|LATERAL
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|rightResult
operator|.
name|node
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|rightLateralAs
init|=
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|rightLateral
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|rightResult
operator|.
name|neededAlias
argument_list|,
name|POS
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|join
init|=
operator|new
name|SqlJoin
argument_list|(
name|POS
argument_list|,
name|leftResult
operator|.
name|asFrom
argument_list|()
argument_list|,
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|false
argument_list|,
name|POS
argument_list|)
argument_list|,
name|JoinType
operator|.
name|COMMA
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
argument_list|,
name|rightLateralAs
argument_list|,
name|JoinConditionType
operator|.
name|NONE
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|join
argument_list|,
name|leftResult
argument_list|,
name|rightResult
argument_list|)
return|;
block|}
comment|/** Visits a Filter; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Filter
name|e
parameter_list|)
block|{
specifier|final
name|RelNode
name|input
init|=
name|e
operator|.
name|getInput
argument_list|()
decl_stmt|;
if|if
condition|(
name|input
operator|instanceof
name|Aggregate
condition|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|input
decl_stmt|;
specifier|final
name|boolean
name|ignoreClauses
init|=
name|aggregate
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Project
decl_stmt|;
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
name|isAnon
argument_list|()
argument_list|,
name|ignoreClauses
argument_list|,
name|ImmutableSet
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|HAVING
argument_list|)
argument_list|)
decl_stmt|;
name|parseCorrelTable
argument_list|(
name|e
argument_list|,
name|x
argument_list|)
expr_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|builder
operator|.
name|setHaving
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
else|else
block|{
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
name|Clause
operator|.
name|WHERE
argument_list|)
decl_stmt|;
name|parseCorrelTable
argument_list|(
name|e
argument_list|,
name|x
argument_list|)
expr_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|builder
operator|.
name|setWhere
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
block|}
comment|/** Visits a Project; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Project
name|e
parameter_list|)
block|{
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
name|Clause
operator|.
name|SELECT
argument_list|)
decl_stmt|;
name|parseCorrelTable
argument_list|(
name|e
argument_list|,
name|x
argument_list|)
expr_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isStar
argument_list|(
name|e
operator|.
name|getProjects
argument_list|()
argument_list|,
name|e
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|ref
range|:
name|e
operator|.
name|getProjects
argument_list|()
control|)
block|{
name|SqlNode
name|sqlExpr
init|=
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|sqlExpr
argument_list|,
literal|false
argument_list|)
condition|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|e
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|selectList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|sqlExpr
operator|=
name|castNullType
argument_list|(
name|sqlExpr
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|sqlExpr
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setSelect
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
comment|/** Wraps a NULL literal in a CAST operator to a target type.    *    * @param nullLiteral NULL literal    * @param type Target type    *    * @return null literal wrapped in CAST call    */
specifier|private
name|SqlNode
name|castNullType
parameter_list|(
name|SqlNode
name|nullLiteral
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
specifier|final
name|SqlNode
name|typeNode
init|=
name|dialect
operator|.
name|getCastSpec
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeNode
operator|==
literal|null
condition|)
block|{
return|return
name|nullLiteral
return|;
block|}
return|return
name|SqlStdOperatorTable
operator|.
name|CAST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|nullLiteral
argument_list|,
name|typeNode
argument_list|)
return|;
block|}
comment|/** Visits a Window; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Window
name|e
parameter_list|)
block|{
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|e
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|int
name|inputFieldCount
init|=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|rexOvers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Window
operator|.
name|Group
name|group
range|:
name|e
operator|.
name|groups
control|)
block|{
name|rexOvers
operator|.
name|addAll
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
name|group
argument_list|,
name|e
operator|.
name|constants
argument_list|,
name|inputFieldCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|builder
operator|.
name|context
operator|.
name|field
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|rexOver
range|:
name|rexOvers
control|)
block|{
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|rexOver
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setSelect
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
comment|/** Visits an Aggregate; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Aggregate
name|e
parameter_list|)
block|{
specifier|final
name|Builder
name|builder
init|=
name|visitAggregate
argument_list|(
name|e
argument_list|,
name|e
operator|.
name|getGroupSet
argument_list|()
operator|.
name|toList
argument_list|()
argument_list|,
name|Clause
operator|.
name|GROUP_BY
argument_list|)
decl_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
specifier|private
name|Builder
name|visitAggregate
parameter_list|(
name|Aggregate
name|e
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|groupKeyList
parameter_list|,
name|Clause
modifier|...
name|clauses
parameter_list|)
block|{
comment|// "select a, b, sum(x) from ( ... ) group by a, b"
specifier|final
name|boolean
name|ignoreClauses
init|=
name|e
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Project
decl_stmt|;
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
name|isAnon
argument_list|()
argument_list|,
name|ignoreClauses
argument_list|,
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|clauses
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupByList
init|=
name|generateGroupList
argument_list|(
name|builder
argument_list|,
name|selectList
argument_list|,
name|e
argument_list|,
name|groupKeyList
argument_list|)
decl_stmt|;
return|return
name|buildAggregate
argument_list|(
name|e
argument_list|,
name|builder
argument_list|,
name|selectList
argument_list|,
name|groupByList
argument_list|)
return|;
block|}
comment|/**    * Builds the group list for an Aggregate node.    *    * @param e The Aggregate node    * @param builder The SQL builder    * @param groupByList output group list    * @param selectList output select list    */
specifier|protected
name|void
name|buildAggGroupList
parameter_list|(
name|Aggregate
name|e
parameter_list|,
name|Builder
name|builder
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupByList
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
parameter_list|)
block|{
for|for
control|(
name|int
name|group
range|:
name|e
operator|.
name|getGroupSet
argument_list|()
control|)
block|{
specifier|final
name|SqlNode
name|field
init|=
name|builder
operator|.
name|context
operator|.
name|field
argument_list|(
name|group
argument_list|)
decl_stmt|;
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|field
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
name|groupByList
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Builds an aggregate query.    *    * @param e The Aggregate node    * @param builder The SQL builder    * @param selectList The precomputed group list    * @param groupByList The precomputed select list    * @return The aggregate query result    */
specifier|protected
name|Builder
name|buildAggregate
parameter_list|(
name|Aggregate
name|e
parameter_list|,
name|Builder
name|builder
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupByList
parameter_list|)
block|{
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|e
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
name|SqlNode
name|aggCallSqlNode
init|=
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
name|aggCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|instanceof
name|SqlSingleValueAggFunction
condition|)
block|{
name|aggCallSqlNode
operator|=
name|dialect
operator|.
name|rewriteSingleValueExpr
argument_list|(
name|aggCallSqlNode
argument_list|)
expr_stmt|;
block|}
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|aggCallSqlNode
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setSelect
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|groupByList
operator|.
name|isEmpty
argument_list|()
operator|||
name|e
operator|.
name|getAggCallList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Some databases don't support "GROUP BY ()". We can omit it as long
comment|// as there is at least one aggregate function.
name|builder
operator|.
name|setGroupBy
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|groupByList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
comment|/** Generates the GROUP BY items, for example {@code GROUP BY x, y},    * {@code GROUP BY CUBE (x, y)} or {@code GROUP BY ROLLUP (x, y)}.    *    *<p>Also populates the SELECT clause. If the GROUP BY list is simple, the    * SELECT will be identical; if the GROUP BY list contains GROUPING SETS,    * CUBE or ROLLUP, the SELECT clause will contain the distinct leaf    * expressions. */
specifier|private
name|List
argument_list|<
name|SqlNode
argument_list|>
name|generateGroupList
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
parameter_list|,
name|Aggregate
name|aggregate
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|groupList
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|sortedGroupList
init|=
name|Ordering
operator|.
name|natural
argument_list|()
operator|.
name|sortedCopy
argument_list|(
name|groupList
argument_list|)
decl_stmt|;
assert|assert
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|asList
argument_list|()
operator|.
name|equals
argument_list|(
name|sortedGroupList
argument_list|)
operator|:
literal|"groupList "
operator|+
name|groupList
operator|+
literal|" must be equal to groupSet "
operator|+
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|+
literal|", just possibly a different order"
assert|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|key
range|:
name|groupList
control|)
block|{
specifier|final
name|SqlNode
name|field
init|=
name|builder
operator|.
name|context
operator|.
name|field
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|groupKeys
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|key
range|:
name|sortedGroupList
control|)
block|{
specifier|final
name|SqlNode
name|field
init|=
name|builder
operator|.
name|context
operator|.
name|field
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|field
argument_list|,
name|aggregate
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|aggregate
operator|.
name|getGroupType
argument_list|()
condition|)
block|{
case|case
name|SIMPLE
case|:
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupKeys
argument_list|)
return|;
case|case
name|CUBE
case|:
if|if
condition|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlStdOperatorTable
operator|.
name|CUBE
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|groupKeys
argument_list|)
argument_list|)
return|;
block|}
comment|// a singleton CUBE and ROLLUP are the same but we prefer ROLLUP;
comment|// fall through
case|case
name|ROLLUP
case|:
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ROLLUP
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|groupKeys
argument_list|)
argument_list|)
return|;
default|default:
case|case
name|OTHER
case|:
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlStdOperatorTable
operator|.
name|GROUPING_SETS
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|aggregate
operator|.
name|getGroupSets
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|groupSet
lambda|->
name|groupItem
argument_list|(
name|groupKeys
argument_list|,
name|groupSet
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|private
name|SqlNode
name|groupItem
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|groupKeys
parameter_list|,
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|ImmutableBitSet
name|wholeGroupSet
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodes
init|=
name|groupSet
operator|.
name|asList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|key
lambda|->
name|groupKeys
operator|.
name|get
argument_list|(
name|wholeGroupSet
operator|.
name|indexOf
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nodes
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
return|return
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|SqlStdOperatorTable
operator|.
name|ROW
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|nodes
argument_list|)
return|;
block|}
block|}
comment|/** Visits a TableScan; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|TableScan
name|e
parameter_list|)
block|{
specifier|final
name|SqlIdentifier
name|identifier
init|=
name|getSqlTargetTable
argument_list|(
name|e
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|identifier
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|FROM
argument_list|)
argument_list|,
name|e
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Visits a Union; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Union
name|e
parameter_list|)
block|{
return|return
name|setOpToSql
argument_list|(
name|e
operator|.
name|all
condition|?
name|SqlStdOperatorTable
operator|.
name|UNION_ALL
else|:
name|SqlStdOperatorTable
operator|.
name|UNION
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/** Visits an Intersect; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Intersect
name|e
parameter_list|)
block|{
return|return
name|setOpToSql
argument_list|(
name|e
operator|.
name|all
condition|?
name|SqlStdOperatorTable
operator|.
name|INTERSECT_ALL
else|:
name|SqlStdOperatorTable
operator|.
name|INTERSECT
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/** Visits a Minus; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Minus
name|e
parameter_list|)
block|{
return|return
name|setOpToSql
argument_list|(
name|e
operator|.
name|all
condition|?
name|SqlStdOperatorTable
operator|.
name|EXCEPT_ALL
else|:
name|SqlStdOperatorTable
operator|.
name|EXCEPT
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/** Visits a Calc; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Calc
name|e
parameter_list|)
block|{
specifier|final
name|RexProgram
name|program
init|=
name|e
operator|.
name|getProgram
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableSet
argument_list|<
name|Clause
argument_list|>
name|expectedClauses
init|=
name|program
operator|.
name|getCondition
argument_list|()
operator|!=
literal|null
condition|?
name|ImmutableSet
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|WHERE
argument_list|)
else|:
name|ImmutableSet
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
name|expectedClauses
argument_list|)
decl_stmt|;
name|parseCorrelTable
argument_list|(
name|e
argument_list|,
name|x
argument_list|)
expr_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isStar
argument_list|(
name|program
argument_list|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|program
operator|.
name|getProjectList
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|ref
range|:
name|program
operator|.
name|getProjectList
argument_list|()
control|)
block|{
name|SqlNode
name|sqlExpr
init|=
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
name|program
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|sqlExpr
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setSelect
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|program
operator|.
name|getCondition
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setWhere
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
name|program
argument_list|,
name|program
operator|.
name|getCondition
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
comment|/** Visits a Values; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Values
name|e
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Clause
argument_list|>
name|clauses
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|SELECT
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|pairs
init|=
name|ImmutableMap
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|context
init|=
name|aliasContext
argument_list|(
name|pairs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|SqlNode
name|query
decl_stmt|;
specifier|final
name|boolean
name|rename
init|=
name|stack
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|||
operator|!
operator|(
name|Iterables
operator|.
name|get
argument_list|(
name|stack
argument_list|,
literal|1
argument_list|)
operator|.
name|r
operator|instanceof
name|TableModify
operator|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|e
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dialect
operator|.
name|supportsAliasedValues
argument_list|()
operator|&&
name|rename
condition|)
block|{
comment|// Some dialects (such as Oracle and BigQuery) don't support
comment|// "AS t (c1, c2)". So instead of
comment|//   (VALUES (v0, v1), (v2, v3)) AS t (c0, c1)
comment|// we generate
comment|//   SELECT v0 AS c0, v1 AS c1 FROM DUAL
comment|//   UNION ALL
comment|//   SELECT v2 AS c0, v3 AS c1 FROM DUAL
comment|// for Oracle and
comment|//   SELECT v0 AS c0, v1 AS c1
comment|//   UNION ALL
comment|//   SELECT v2 AS c0, v3 AS c1
comment|// for dialects that support SELECT-without-FROM.
name|List
argument_list|<
name|SqlSelect
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|tuple
range|:
name|e
operator|.
name|getTuples
argument_list|()
control|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|values2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|SqlNodeList
name|exprList
init|=
name|exprList
argument_list|(
name|context
argument_list|,
name|tuple
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|SqlNode
argument_list|,
name|String
argument_list|>
name|value
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|exprList
argument_list|,
name|fieldNames
argument_list|)
control|)
block|{
name|values2
operator|.
name|add
argument_list|(
name|as
argument_list|(
name|value
operator|.
name|left
argument_list|,
name|value
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
literal|null
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|values2
argument_list|,
name|POS
argument_list|)
argument_list|,
name|getDual
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// In this case we need to construct the following query:
comment|// SELECT NULL as C0, NULL as C1, NULL as C2 ... FROM DUAL WHERE FALSE
comment|// This would return an empty result set with the same number of columns as the field names.
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nullColumnNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fieldNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|SqlCall
name|nullColumnName
init|=
name|as
argument_list|(
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|POS
argument_list|)
argument_list|,
name|fieldName
argument_list|)
decl_stmt|;
name|nullColumnNames
operator|.
name|add
argument_list|(
name|nullColumnName
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlIdentifier
name|dual
init|=
name|getDual
argument_list|()
decl_stmt|;
if|if
condition|(
name|dual
operator|==
literal|null
condition|)
block|{
name|query
operator|=
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
literal|null
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|nullColumnNames
argument_list|,
name|POS
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Wrap "SELECT 1 AS x"
comment|// as "SELECT * FROM (SELECT 1 AS x) AS t WHERE false"
name|query
operator|=
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
literal|null
argument_list|,
name|SqlNodeList
operator|.
name|SINGLETON_STAR
argument_list|,
name|as
argument_list|(
name|query
argument_list|,
literal|"t"
argument_list|)
argument_list|,
name|createAlwaysFalseCondition
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query
operator|=
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
literal|null
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|nullColumnNames
argument_list|,
name|POS
argument_list|)
argument_list|,
name|dual
argument_list|,
name|createAlwaysFalseCondition
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|query
operator|=
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query
operator|=
name|SqlStdOperatorTable
operator|.
name|UNION_ALL
operator|.
name|createCall
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|list
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Generate ANSI syntax
comment|//   (VALUES (v0, v1), (v2, v3))
comment|// or, if rename is required
comment|//   (VALUES (v0, v1), (v2, v3)) AS t (c0, c1)
specifier|final
name|SqlNodeList
name|selects
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isEmpty
init|=
name|Values
operator|.
name|isEmpty
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|isEmpty
condition|)
block|{
comment|// In case of empty values, we need to build:
comment|// select * from VALUES(NULL, NULL ...) as T (C1, C2 ...)
comment|// where 1=0.
name|selects
operator|.
name|add
argument_list|(
name|ANONYMOUS_ROW
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|Collections
operator|.
name|nCopies
argument_list|(
name|fieldNames
operator|.
name|size
argument_list|()
argument_list|,
name|SqlLiteral
operator|.
name|createNull
argument_list|(
name|POS
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|tuple
range|:
name|e
operator|.
name|getTuples
argument_list|()
control|)
block|{
name|selects
operator|.
name|add
argument_list|(
name|ANONYMOUS_ROW
operator|.
name|createCall
argument_list|(
name|exprList
argument_list|(
name|context
argument_list|,
name|tuple
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|query
operator|=
name|SqlStdOperatorTable
operator|.
name|VALUES
operator|.
name|createCall
argument_list|(
name|selects
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
condition|)
block|{
name|query
operator|=
name|as
argument_list|(
name|query
argument_list|,
literal|"t"
argument_list|,
name|fieldNames
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
condition|)
block|{
if|if
condition|(
operator|!
name|rename
condition|)
block|{
name|query
operator|=
name|as
argument_list|(
name|query
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
block|}
name|query
operator|=
operator|new
name|SqlSelect
argument_list|(
name|POS
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|query
argument_list|,
name|createAlwaysFalseCondition
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
argument_list|(
name|query
argument_list|,
name|clauses
argument_list|,
name|e
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|SqlIdentifier
name|getDual
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|dialect
operator|.
name|getSingleRowTableName
argument_list|()
decl_stmt|;
if|if
condition|(
name|names
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|SqlIdentifier
argument_list|(
name|names
argument_list|,
name|POS
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|createAlwaysFalseCondition
parameter_list|()
block|{
comment|// Building the select query in the form:
comment|// select * from VALUES(NULL,NULL ...) where 1=0
comment|// Use condition 1=0 since "where false" does not seem to be supported
comment|// on some DB vendors.
return|return
name|SqlStdOperatorTable
operator|.
name|EQUALS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"1"
argument_list|,
name|POS
argument_list|)
argument_list|,
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0"
argument_list|,
name|POS
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Visits a Sort; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Sort
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Aggregate
condition|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|e
operator|.
name|getInput
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasTrickyRollup
argument_list|(
name|e
argument_list|,
name|aggregate
argument_list|)
condition|)
block|{
comment|// MySQL 5 does not support standard "GROUP BY ROLLUP(x, y)", only
comment|// the non-standard "GROUP BY x, y WITH ROLLUP".
comment|// It does not allow "WITH ROLLUP" in combination with "ORDER BY",
comment|// but "GROUP BY x, y WITH ROLLUP" implicitly sorts by x, y,
comment|// so skip the ORDER BY.
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|groupList
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fc
range|:
name|e
operator|.
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|groupList
operator|.
name|add
argument_list|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|fc
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|groupList
operator|.
name|addAll
argument_list|(
name|Aggregate
operator|.
name|Group
operator|.
name|getRollup
argument_list|(
name|aggregate
operator|.
name|getGroupSets
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|visitAggregate
argument_list|(
name|aggregate
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupList
argument_list|)
argument_list|,
name|Clause
operator|.
name|GROUP_BY
argument_list|,
name|Clause
operator|.
name|OFFSET
argument_list|,
name|Clause
operator|.
name|FETCH
argument_list|)
decl_stmt|;
name|offsetFetch
argument_list|(
name|e
argument_list|,
name|builder
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
block|}
if|if
condition|(
name|e
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Project
condition|)
block|{
comment|// Deal with the case Sort(Project(Aggregate ...))
comment|// by converting it to Project(Sort(Aggregate ...)).
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|e
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Permutation
name|permutation
init|=
name|project
operator|.
name|getPermutation
argument_list|()
decl_stmt|;
if|if
condition|(
name|permutation
operator|!=
literal|null
operator|&&
name|project
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Aggregate
condition|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|project
operator|.
name|getInput
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasTrickyRollup
argument_list|(
name|e
argument_list|,
name|aggregate
argument_list|)
condition|)
block|{
specifier|final
name|RelCollation
name|collation
init|=
name|RelCollations
operator|.
name|permute
argument_list|(
name|e
operator|.
name|collation
argument_list|,
name|permutation
argument_list|)
decl_stmt|;
specifier|final
name|Sort
name|sort2
init|=
name|LogicalSort
operator|.
name|create
argument_list|(
name|aggregate
argument_list|,
name|collation
argument_list|,
name|e
operator|.
name|offset
argument_list|,
name|e
operator|.
name|fetch
argument_list|)
decl_stmt|;
specifier|final
name|Project
name|project2
init|=
name|LogicalProject
operator|.
name|create
argument_list|(
name|sort2
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|project
operator|.
name|getProjects
argument_list|()
argument_list|,
name|project
operator|.
name|getRowType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|visit
argument_list|(
name|project2
argument_list|)
return|;
block|}
block|}
block|}
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
name|Clause
operator|.
name|ORDER_BY
argument_list|,
name|Clause
operator|.
name|OFFSET
argument_list|,
name|Clause
operator|.
name|FETCH
argument_list|)
decl_stmt|;
specifier|final
name|Builder
name|builder
init|=
name|x
operator|.
name|builder
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|&&
name|builder
operator|.
name|select
operator|.
name|getSelectList
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// Generates explicit column names instead of start(*) for
comment|// non-root order by to avoid ambiguity.
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|e
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|addSelect
argument_list|(
name|selectList
argument_list|,
name|builder
operator|.
name|context
operator|.
name|field
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|,
name|e
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|select
operator|.
name|setSelectList
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|selectList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderByList
init|=
name|Expressions
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|field
range|:
name|e
operator|.
name|getCollation
argument_list|()
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|builder
operator|.
name|addOrderItem
argument_list|(
name|orderByList
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|orderByList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|builder
operator|.
name|setOrderBy
argument_list|(
operator|new
name|SqlNodeList
argument_list|(
name|orderByList
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|offsetFetch
argument_list|(
name|e
argument_list|,
name|builder
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|result
argument_list|()
return|;
block|}
comment|/** Adds OFFSET and FETCH to a builder, if applicable.    * The builder must have been created with OFFSET and FETCH clauses. */
name|void
name|offsetFetch
parameter_list|(
name|Sort
name|e
parameter_list|,
name|Builder
name|builder
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|fetch
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setFetch
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|fetch
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|offset
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setOffset
argument_list|(
name|builder
operator|.
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|hasTrickyRollup
parameter_list|(
name|Sort
name|e
parameter_list|,
name|Aggregate
name|aggregate
parameter_list|)
block|{
return|return
operator|!
name|dialect
operator|.
name|supportsAggregateFunction
argument_list|(
name|SqlKind
operator|.
name|ROLLUP
argument_list|)
operator|&&
name|dialect
operator|.
name|supportsGroupByWithRollup
argument_list|()
operator|&&
operator|(
name|aggregate
operator|.
name|getGroupType
argument_list|()
operator|==
name|Aggregate
operator|.
name|Group
operator|.
name|ROLLUP
operator|||
name|aggregate
operator|.
name|getGroupType
argument_list|()
operator|==
name|Aggregate
operator|.
name|Group
operator|.
name|CUBE
operator|&&
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
operator|==
literal|1
operator|)
operator|&&
name|e
operator|.
name|collation
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|allMatch
argument_list|(
name|fc
lambda|->
name|fc
operator|.
name|getFieldIndex
argument_list|()
operator|<
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|SqlIdentifier
name|getSqlTargetTable
parameter_list|(
name|RelNode
name|e
parameter_list|)
block|{
specifier|final
name|SqlIdentifier
name|sqlTargetTable
decl_stmt|;
specifier|final
name|JdbcTable
name|jdbcTable
init|=
name|e
operator|.
name|getTable
argument_list|()
operator|.
name|unwrap
argument_list|(
name|JdbcTable
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|jdbcTable
operator|!=
literal|null
condition|)
block|{
comment|// Use the foreign catalog, schema and table names, if they exist,
comment|// rather than the qualified name of the shadow table in Calcite.
name|sqlTargetTable
operator|=
name|jdbcTable
operator|.
name|tableName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|qualifiedName
init|=
name|e
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
name|sqlTargetTable
operator|=
operator|new
name|SqlIdentifier
argument_list|(
name|qualifiedName
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
return|return
name|sqlTargetTable
return|;
block|}
comment|/** Visits a TableModify; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|TableModify
name|modify
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|pairs
init|=
name|ImmutableMap
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|Context
name|context
init|=
name|aliasContext
argument_list|(
name|pairs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Target Table Name
specifier|final
name|SqlIdentifier
name|sqlTargetTable
init|=
name|getSqlTargetTable
argument_list|(
name|modify
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|modify
operator|.
name|getOperation
argument_list|()
condition|)
block|{
case|case
name|INSERT
case|:
block|{
comment|// Convert the input to a SELECT query or keep as VALUES. Not all
comment|// dialects support naked VALUES, but all support VALUES inside INSERT.
specifier|final
name|SqlNode
name|sqlSource
init|=
name|visitInput
argument_list|(
name|modify
argument_list|,
literal|0
argument_list|)
operator|.
name|asQueryOrValues
argument_list|()
decl_stmt|;
specifier|final
name|SqlInsert
name|sqlInsert
init|=
operator|new
name|SqlInsert
argument_list|(
name|POS
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|,
name|sqlTargetTable
argument_list|,
name|sqlSource
argument_list|,
name|identifierList
argument_list|(
name|modify
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|sqlInsert
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
name|modify
argument_list|,
literal|null
argument_list|)
return|;
block|}
case|case
name|UPDATE
case|:
block|{
specifier|final
name|Result
name|input
init|=
name|visitInput
argument_list|(
name|modify
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlUpdate
name|sqlUpdate
init|=
operator|new
name|SqlUpdate
argument_list|(
name|POS
argument_list|,
name|sqlTargetTable
argument_list|,
name|identifierList
argument_list|(
name|modify
operator|.
name|getUpdateColumnList
argument_list|()
argument_list|)
argument_list|,
name|exprList
argument_list|(
name|context
argument_list|,
name|modify
operator|.
name|getSourceExpressionList
argument_list|()
argument_list|)
argument_list|,
operator|(
operator|(
name|SqlSelect
operator|)
name|input
operator|.
name|node
operator|)
operator|.
name|getWhere
argument_list|()
argument_list|,
name|input
operator|.
name|asSelect
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|sqlUpdate
argument_list|,
name|input
operator|.
name|clauses
argument_list|,
name|modify
argument_list|,
literal|null
argument_list|)
return|;
block|}
case|case
name|DELETE
case|:
block|{
specifier|final
name|Result
name|input
init|=
name|visitInput
argument_list|(
name|modify
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlDelete
name|sqlDelete
init|=
operator|new
name|SqlDelete
argument_list|(
name|POS
argument_list|,
name|sqlTargetTable
argument_list|,
name|input
operator|.
name|asSelect
argument_list|()
operator|.
name|getWhere
argument_list|()
argument_list|,
name|input
operator|.
name|asSelect
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|sqlDelete
argument_list|,
name|input
operator|.
name|clauses
argument_list|,
name|modify
argument_list|,
literal|null
argument_list|)
return|;
block|}
case|case
name|MERGE
case|:
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"not implemented: "
operator|+
name|modify
argument_list|)
throw|;
block|}
block|}
comment|/** Converts a list of {@link RexNode} expressions to {@link SqlNode}    * expressions. */
specifier|private
name|SqlNodeList
name|exprList
parameter_list|(
specifier|final
name|Context
name|context
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exprs
parameter_list|)
block|{
return|return
operator|new
name|SqlNodeList
argument_list|(
name|Util
operator|.
name|transform
argument_list|(
name|exprs
argument_list|,
name|e
lambda|->
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|e
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
comment|/** Converts a list of names expressions to a list of single-part    * {@link SqlIdentifier}s. */
specifier|private
name|SqlNodeList
name|identifierList
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
block|{
return|return
operator|new
name|SqlNodeList
argument_list|(
name|Util
operator|.
name|transform
argument_list|(
name|names
argument_list|,
name|name
lambda|->
operator|new
name|SqlIdentifier
argument_list|(
name|name
argument_list|,
name|POS
argument_list|)
argument_list|)
argument_list|,
name|POS
argument_list|)
return|;
block|}
comment|/** Visits a Match; called by {@link #dispatch} via reflection. */
specifier|public
name|Result
name|visit
parameter_list|(
name|Match
name|e
parameter_list|)
block|{
specifier|final
name|RelNode
name|input
init|=
name|e
operator|.
name|getInput
argument_list|()
decl_stmt|;
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Context
name|context
init|=
name|matchRecognizeContext
argument_list|(
name|x
operator|.
name|qualifiedContext
argument_list|()
argument_list|)
decl_stmt|;
name|SqlNode
name|tableRef
init|=
name|x
operator|.
name|asQueryOrValues
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|input
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|partitionSqlList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|key
range|:
name|e
operator|.
name|getPartitionKeys
argument_list|()
control|)
block|{
specifier|final
name|RexInputRef
name|ref
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|input
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|SqlNode
name|sqlNode
init|=
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|partitionSqlList
operator|.
name|add
argument_list|(
name|sqlNode
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNodeList
name|partitionList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|partitionSqlList
argument_list|,
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|orderBySqlList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getOrderKeys
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|RelFieldCollation
name|fc
range|:
name|e
operator|.
name|getOrderKeys
argument_list|()
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
if|if
condition|(
name|fc
operator|.
name|nullDirection
operator|!=
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
condition|)
block|{
name|boolean
name|first
init|=
name|fc
operator|.
name|nullDirection
operator|==
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
decl_stmt|;
name|SqlNode
name|nullDirectionNode
init|=
name|dialect
operator|.
name|emulateNullDirection
argument_list|(
name|context
operator|.
name|field
argument_list|(
name|fc
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
argument_list|,
name|first
argument_list|,
name|fc
operator|.
name|direction
operator|.
name|isDescending
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullDirectionNode
operator|!=
literal|null
condition|)
block|{
name|orderBySqlList
operator|.
name|add
argument_list|(
name|nullDirectionNode
argument_list|)
expr_stmt|;
name|fc
operator|=
operator|new
name|RelFieldCollation
argument_list|(
name|fc
operator|.
name|getFieldIndex
argument_list|()
argument_list|,
name|fc
operator|.
name|getDirection
argument_list|()
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|UNSPECIFIED
argument_list|)
expr_stmt|;
block|}
block|}
name|orderBySqlList
operator|.
name|add
argument_list|(
name|context
operator|.
name|toSql
argument_list|(
name|fc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|SqlNodeList
name|orderByList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|orderBySqlList
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|rowsPerMatch
init|=
name|e
operator|.
name|isAllRows
argument_list|()
condition|?
name|SqlMatchRecognize
operator|.
name|RowsPerMatchOption
operator|.
name|ALL_ROWS
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
else|:
name|SqlMatchRecognize
operator|.
name|RowsPerMatchOption
operator|.
name|ONE_ROW
operator|.
name|symbol
argument_list|(
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|after
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getAfter
argument_list|()
operator|instanceof
name|RexLiteral
condition|)
block|{
name|SqlMatchRecognize
operator|.
name|AfterOption
name|value
init|=
operator|(
name|SqlMatchRecognize
operator|.
name|AfterOption
operator|)
operator|(
operator|(
name|RexLiteral
operator|)
name|e
operator|.
name|getAfter
argument_list|()
operator|)
operator|.
name|getValue2
argument_list|()
decl_stmt|;
name|after
operator|=
name|SqlLiteral
operator|.
name|createSymbol
argument_list|(
name|value
argument_list|,
name|POS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|e
operator|.
name|getAfter
argument_list|()
decl_stmt|;
name|String
name|operand
init|=
name|RexLiteral
operator|.
name|stringValue
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|after
operator|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|operand
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|rexPattern
init|=
name|e
operator|.
name|getPattern
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|pattern
init|=
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|rexPattern
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|strictStart
init|=
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
name|e
operator|.
name|isStrictStart
argument_list|()
argument_list|,
name|POS
argument_list|)
decl_stmt|;
specifier|final
name|SqlLiteral
name|strictEnd
init|=
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
name|e
operator|.
name|isStrictEnd
argument_list|()
argument_list|,
name|POS
argument_list|)
decl_stmt|;
name|RexLiteral
name|rexInterval
init|=
operator|(
name|RexLiteral
operator|)
name|e
operator|.
name|getInterval
argument_list|()
decl_stmt|;
name|SqlIntervalLiteral
name|interval
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rexInterval
operator|!=
literal|null
condition|)
block|{
name|interval
operator|=
operator|(
name|SqlIntervalLiteral
operator|)
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|rexInterval
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNodeList
name|subsetList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|SortedSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|e
operator|.
name|getSubsets
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|SqlNode
name|left
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|POS
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|rhl
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|right
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|rhl
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|right
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|subsetList
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|left
argument_list|,
operator|new
name|SqlNodeList
argument_list|(
name|rhl
argument_list|,
name|POS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNodeList
name|measureList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|entry
range|:
name|e
operator|.
name|getMeasures
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|alias
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|sqlNode
init|=
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|measureList
operator|.
name|add
argument_list|(
name|as
argument_list|(
name|sqlNode
argument_list|,
name|alias
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNodeList
name|patternDefList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|POS
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RexNode
argument_list|>
name|entry
range|:
name|e
operator|.
name|getPatternDefinitions
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|alias
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|sqlNode
init|=
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|patternDefList
operator|.
name|add
argument_list|(
name|as
argument_list|(
name|sqlNode
argument_list|,
name|alias
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNode
name|matchRecognize
init|=
operator|new
name|SqlMatchRecognize
argument_list|(
name|POS
argument_list|,
name|tableRef
argument_list|,
name|pattern
argument_list|,
name|strictStart
argument_list|,
name|strictEnd
argument_list|,
name|patternDefList
argument_list|,
name|measureList
argument_list|,
name|after
argument_list|,
name|subsetList
argument_list|,
name|rowsPerMatch
argument_list|,
name|partitionList
argument_list|,
name|orderByList
argument_list|,
name|interval
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|matchRecognize
argument_list|,
name|Expressions
operator|.
name|list
argument_list|(
name|Clause
operator|.
name|FROM
argument_list|)
argument_list|,
name|e
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|SqlCall
name|as
parameter_list|(
name|SqlNode
name|e
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|e
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|POS
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visit
parameter_list|(
name|Uncollect
name|e
parameter_list|)
block|{
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|unnestNode
init|=
name|SqlStdOperatorTable
operator|.
name|UNNEST
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|x
operator|.
name|asStatement
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|createAsFullOperands
argument_list|(
name|e
operator|.
name|getRowType
argument_list|()
argument_list|,
name|unnestNode
argument_list|,
name|x
operator|.
name|neededAlias
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|asNode
init|=
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|POS
argument_list|,
name|operands
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|asNode
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|FROM
argument_list|)
argument_list|,
name|e
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
name|Result
name|visit
parameter_list|(
name|TableFunctionScan
name|e
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|inputSqlNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|inputSize
init|=
name|e
operator|.
name|getInputs
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Result
name|x
init|=
name|visitInput
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|inputSqlNodes
operator|.
name|add
argument_list|(
name|x
operator|.
name|asStatement
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Context
name|context
init|=
name|tableFunctionScanContext
argument_list|(
name|inputSqlNodes
argument_list|)
decl_stmt|;
name|SqlNode
name|callNode
init|=
name|context
operator|.
name|toSql
argument_list|(
literal|null
argument_list|,
name|e
operator|.
name|getCall
argument_list|()
argument_list|)
decl_stmt|;
comment|// Convert to table function call, "TABLE($function_name(xxx))"
name|SqlNode
name|tableCall
init|=
operator|new
name|SqlBasicCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COLLECTION_TABLE
argument_list|,
operator|new
name|SqlNode
index|[]
block|{
name|callNode
block|}
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|SqlNode
name|select
init|=
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|tableCall
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlNodeList
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
return|return
name|result
argument_list|(
name|select
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Clause
operator|.
name|SELECT
argument_list|)
argument_list|,
name|e
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates operands for a full AS operator. Format SqlNode AS alias(col_1, col_2,... ,col_n).    *    * @param rowType Row type of the SqlNode    * @param leftOperand SqlNode    * @param alias alias    */
specifier|public
name|List
argument_list|<
name|SqlNode
argument_list|>
name|createAsFullOperands
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|SqlNode
name|leftOperand
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|leftOperand
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
name|Ord
operator|.
name|forEach
argument_list|(
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
parameter_list|(
name|fieldName
parameter_list|,
name|i
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|fieldName
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"expr$"
argument_list|)
condition|)
block|{
name|fieldName
operator|=
literal|"col_"
operator|+
name|i
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|fieldName
argument_list|,
name|POS
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addSelect
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|String
name|name
init|=
name|rowType
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|selectList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|node
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
operator|||
operator|!
name|alias
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|node
operator|=
name|as
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|selectList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|parseCorrelTable
parameter_list|(
name|RelNode
name|relNode
parameter_list|,
name|Result
name|x
parameter_list|)
block|{
for|for
control|(
name|CorrelationId
name|id
range|:
name|relNode
operator|.
name|getVariablesSet
argument_list|()
control|)
block|{
name|correlTableMap
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|x
operator|.
name|qualifiedContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Stack frame. */
specifier|private
specifier|static
class|class
name|Frame
block|{
specifier|private
specifier|final
name|RelNode
name|parent
decl_stmt|;
specifier|private
specifier|final
name|int
name|ordinalInParent
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|r
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|anon
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|ignoreClauses
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|?
extends|extends
name|Clause
argument_list|>
name|expectedClauses
decl_stmt|;
name|Frame
parameter_list|(
name|RelNode
name|parent
parameter_list|,
name|int
name|ordinalInParent
parameter_list|,
name|RelNode
name|r
parameter_list|,
name|boolean
name|anon
parameter_list|,
name|boolean
name|ignoreClauses
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Clause
argument_list|>
name|expectedClauses
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|this
operator|.
name|ordinalInParent
operator|=
name|ordinalInParent
expr_stmt|;
name|this
operator|.
name|r
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|anon
operator|=
name|anon
expr_stmt|;
name|this
operator|.
name|ignoreClauses
operator|=
name|ignoreClauses
expr_stmt|;
name|this
operator|.
name|expectedClauses
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|expectedClauses
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

