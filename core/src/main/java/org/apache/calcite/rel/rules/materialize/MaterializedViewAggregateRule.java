begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|materialize
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnitRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleOperand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateProjectPullUpConstantsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterAggregateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexPermuteInputsShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
operator|.
name|AggCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|MappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/** Materialized view rewriting for aggregate */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|MaterializedViewAggregateRule
extends|extends
name|MaterializedViewRule
block|{
specifier|protected
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|TimeUnitRange
argument_list|>
name|SUPPORTED_DATE_TIME_ROLLUP_UNITS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|,
name|TimeUnitRange
operator|.
name|QUARTER
argument_list|,
name|TimeUnitRange
operator|.
name|MONTH
argument_list|,
name|TimeUnitRange
operator|.
name|DAY
argument_list|,
name|TimeUnitRange
operator|.
name|HOUR
argument_list|,
name|TimeUnitRange
operator|.
name|MINUTE
argument_list|,
name|TimeUnitRange
operator|.
name|SECOND
argument_list|,
name|TimeUnitRange
operator|.
name|MILLISECOND
argument_list|,
name|TimeUnitRange
operator|.
name|MICROSECOND
argument_list|)
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/** Instance of rule to push filter through project. */
specifier|protected
specifier|final
name|RelOptRule
name|filterProjectTransposeRule
decl_stmt|;
comment|/** Instance of rule to push filter through aggregate. */
specifier|protected
specifier|final
name|RelOptRule
name|filterAggregateTransposeRule
decl_stmt|;
comment|/** Instance of rule to pull up constants into aggregate. */
specifier|protected
specifier|final
name|RelOptRule
name|aggregateProjectPullUpConstantsRule
decl_stmt|;
comment|/** Instance of rule to merge project operators. */
specifier|protected
specifier|final
name|RelOptRule
name|projectMergeRule
decl_stmt|;
comment|/** Creates a MaterializedViewAggregateRule. */
specifier|protected
name|MaterializedViewAggregateRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|)
block|{
name|this
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|,
operator|new
name|FilterProjectTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|relBuilderFactory
argument_list|)
argument_list|,
operator|new
name|FilterAggregateTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|relBuilderFactory
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|)
argument_list|,
operator|new
name|AggregateProjectPullUpConstantsRule
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|Filter
operator|.
name|class
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"AggFilterPullUpConstants"
argument_list|)
argument_list|,
operator|new
name|ProjectMergeRule
argument_list|(
literal|true
argument_list|,
name|ProjectMergeRule
operator|.
name|DEFAULT_BLOAT
argument_list|,
name|relBuilderFactory
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a MaterializedViewAggregateRule. */
specifier|protected
name|MaterializedViewAggregateRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|,
name|RelOptRule
name|filterProjectTransposeRule
parameter_list|,
name|RelOptRule
name|filterAggregateTransposeRule
parameter_list|,
name|RelOptRule
name|aggregateProjectPullUpConstantsRule
parameter_list|,
name|RelOptRule
name|projectMergeRule
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|filterProjectTransposeRule
operator|=
name|filterProjectTransposeRule
expr_stmt|;
name|this
operator|.
name|filterAggregateTransposeRule
operator|=
name|filterAggregateTransposeRule
expr_stmt|;
name|this
operator|.
name|aggregateProjectPullUpConstantsRule
operator|=
name|aggregateProjectPullUpConstantsRule
expr_stmt|;
name|this
operator|.
name|projectMergeRule
operator|=
name|projectMergeRule
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isValidPlan
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|Aggregate
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|aggregate
operator|.
name|getGroupType
argument_list|()
operator|!=
name|Aggregate
operator|.
name|Group
operator|.
name|SIMPLE
condition|)
block|{
comment|// TODO: Rewriting with grouping sets not supported yet
return|return
literal|false
return|;
block|}
return|return
name|isValidRelNodePlan
argument_list|(
name|aggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|mq
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|ViewPartialRewriting
name|compensateViewPartial
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
parameter_list|)
block|{
comment|// Modify view to join with missing tables and add Project on top to reorder columns.
comment|// In turn, modify view plan to join with missing tables before Aggregate operator,
comment|// change Aggregate operator to group by previous grouping columns and columns in
comment|// attached tables, and add a final Project on top.
comment|// We only need to add the missing tables on top of the view and view plan using
comment|// a cartesian product.
comment|// Then the rest of the rewriting algorithm can be executed in the same
comment|// fashion, and if there are predicates between the existing and missing
comment|// tables, the rewriting algorithm will enforce them.
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|extraTableRefs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|queryTableRefs
control|)
block|{
if|if
condition|(
operator|!
name|viewTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// Add to extra tables if table is not part of the view
name|extraTableRefs
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
block|}
block|}
name|Collection
argument_list|<
name|RelNode
argument_list|>
name|tableScanNodes
init|=
name|mq
operator|.
name|getNodeTypes
argument_list|(
name|node
argument_list|)
operator|.
name|get
argument_list|(
name|TableScan
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|extraTableRefs
control|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|relNode
range|:
name|tableScanNodes
control|)
block|{
if|if
condition|(
name|tRef
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|relNode
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|tRef
operator|.
name|getEntityNumber
argument_list|()
operator|==
name|i
operator|++
condition|)
block|{
name|newRels
operator|.
name|add
argument_list|(
name|relNode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
assert|assert
name|extraTableRefs
operator|.
name|size
argument_list|()
operator|==
name|newRels
operator|.
name|size
argument_list|()
assert|;
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|newRel
range|:
name|newRels
control|)
block|{
comment|// Add to the view
name|relBuilder
operator|.
name|push
argument_list|(
name|newRel
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|newView
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Aggregate
name|aggregateViewNode
init|=
operator|(
name|Aggregate
operator|)
name|viewNode
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|aggregateViewNode
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|newRel
range|:
name|newRels
control|)
block|{
comment|// Add to the view plan
name|relBuilder
operator|.
name|push
argument_list|(
name|newRel
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|newRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
comment|// Modify aggregate: add grouping columns
name|ImmutableBitSet
operator|.
name|Builder
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|groupSet
operator|.
name|addAll
argument_list|(
name|aggregateViewNode
operator|.
name|getGroupSet
argument_list|()
argument_list|)
expr_stmt|;
name|groupSet
operator|.
name|addAll
argument_list|(
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|aggregateViewNode
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|aggregateViewNode
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Aggregate
name|newViewNode
init|=
name|aggregateViewNode
operator|.
name|copy
argument_list|(
name|aggregateViewNode
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|groupSet
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|,
name|aggregateViewNode
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|newViewNode
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|topViewProject
operator|!=
literal|null
condition|)
block|{
comment|// Insert existing expressions (and shift aggregation arguments),
comment|// then append rest of columns
name|Mappings
operator|.
name|TargetMapping
name|shiftMapping
init|=
name|Mappings
operator|.
name|createShiftMapping
argument_list|(
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|aggregateViewNode
operator|.
name|getGroupCount
argument_list|()
argument_list|,
name|newViewNode
operator|.
name|getGroupCount
argument_list|()
argument_list|,
name|aggregateViewNode
operator|.
name|getGroupCount
argument_list|()
argument_list|,
name|aggregateViewNode
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
operator|new
name|RexPermuteInputsShuttle
argument_list|(
name|shiftMapping
argument_list|,
name|newViewNode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|topViewProject
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|aggregateViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
init|;
name|i
operator|<
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|i
operator|-
name|aggregateViewNode
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newViewNode
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Original grouping columns, aggregation columns, then new grouping columns
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|aggregateViewNode
operator|.
name|getGroupCount
argument_list|()
condition|)
block|{
name|idx
operator|=
name|i
expr_stmt|;
block|}
if|else if
condition|(
name|i
operator|<
name|aggregateViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
name|idx
operator|=
name|i
operator|+
name|offset
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|i
operator|-
name|aggregateViewNode
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newViewNode
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|relBuilder
operator|.
name|project
argument_list|(
name|nodes
argument_list|,
name|fieldNames
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|Project
name|newTopViewProject
init|=
operator|(
name|Project
operator|)
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|ViewPartialRewriting
operator|.
name|of
argument_list|(
name|newView
argument_list|,
name|newTopViewProject
argument_list|,
name|newViewNode
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|rewriteQuery
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|compensationColumnsEquiPred
parameter_list|,
name|RexNode
name|otherCompensationPred
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
parameter_list|,
name|EquivalenceClasses
name|viewEC
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
block|{
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
comment|// Our target node is the node below the root, which should have the maximum
comment|// number of available expressions in the tree in order to maximize our
comment|// number of rewritings.
comment|// If the program is available, we execute it to maximize rewriting opportunities.
comment|// For instance, a program might pull up all the expressions that are below the
comment|// aggregate so we can introduce compensation filters easily. This is important
comment|// depending on the planner strategy.
name|RelNode
name|newAggregateInput
init|=
name|aggregate
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|target
init|=
name|aggregate
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|unionRewritingPullProgram
operator|!=
literal|null
condition|)
block|{
specifier|final
name|HepPlanner
name|tmpPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|unionRewritingPullProgram
argument_list|)
decl_stmt|;
name|tmpPlanner
operator|.
name|setRoot
argument_list|(
name|newAggregateInput
argument_list|)
expr_stmt|;
name|newAggregateInput
operator|=
name|tmpPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
name|target
operator|=
name|newAggregateInput
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// We need to check that all columns required by compensating predicates
comment|// are contained in the query.
name|List
argument_list|<
name|RexNode
argument_list|>
name|queryExprs
init|=
name|extractReferences
argument_list|(
name|rexBuilder
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|compensationColumnsEquiPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|queryExprs
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|queryEC
argument_list|,
literal|false
argument_list|,
name|compensationColumnsEquiPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationColumnsEquiPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
return|return
literal|null
return|;
block|}
block|}
comment|// For the rest, we use the query equivalence classes
if|if
condition|(
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|otherCompensationPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|queryExprs
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|viewEC
argument_list|,
literal|true
argument_list|,
name|otherCompensationPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherCompensationPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|RexNode
name|queryCompensationPred
init|=
name|RexUtil
operator|.
name|not
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|compensationColumnsEquiPred
argument_list|,
name|otherCompensationPred
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Generate query rewriting.
name|RelNode
name|rewrittenPlan
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|target
argument_list|)
operator|.
name|filter
argument_list|(
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|queryCompensationPred
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|unionRewritingPullProgram
operator|!=
literal|null
condition|)
block|{
return|return
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newAggregateInput
operator|.
name|copy
argument_list|(
name|newAggregateInput
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rewrittenPlan
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rewrittenPlan
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|createUnion
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|topProject
parameter_list|,
name|RelNode
name|unionInputQuery
parameter_list|,
name|RelNode
name|unionInputView
parameter_list|)
block|{
comment|// Union
name|relBuilder
operator|.
name|push
argument_list|(
name|unionInputQuery
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|unionInputView
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|union
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// We can take unionInputQuery as it is query based.
name|RelDataTypeField
name|field
init|=
name|unionInputQuery
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|nameList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|project
argument_list|(
name|exprList
argument_list|,
name|nameList
argument_list|)
expr_stmt|;
comment|// Rollup aggregate
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|unionInputQuery
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|aggregate
operator|.
name|getGroupCount
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|AggregateCall
name|aggCall
init|=
name|aggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
comment|// Cannot ROLLUP distinct
return|return
literal|null
return|;
block|}
name|SqlAggFunction
name|rollupAgg
init|=
name|getRollup
argument_list|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rollupAgg
operator|==
literal|null
condition|)
block|{
comment|// Cannot rollup this aggregate, bail out
return|return
literal|null
return|;
block|}
specifier|final
name|RexInputRef
name|operand
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
decl_stmt|;
name|aggregateCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|rollupAgg
argument_list|,
name|operand
argument_list|)
operator|.
name|distinct
argument_list|(
name|aggCall
operator|.
name|isDistinct
argument_list|()
argument_list|)
operator|.
name|approximate
argument_list|(
name|aggCall
operator|.
name|isApproximate
argument_list|()
argument_list|)
operator|.
name|as
argument_list|(
name|aggCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|prevNode
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|RelNode
name|result
init|=
name|relBuilder
operator|.
name|aggregate
argument_list|(
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|groupSet
argument_list|)
argument_list|,
name|aggregateCalls
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevNode
operator|==
name|result
operator|&&
name|groupSet
operator|.
name|cardinality
argument_list|()
operator|!=
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// Aggregate was not inserted but we need to prune columns
name|result
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|(
name|groupSet
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|topProject
operator|!=
literal|null
condition|)
block|{
comment|// Top project
return|return
name|topProject
operator|.
name|copy
argument_list|(
name|topProject
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
comment|// Result
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|rewriteView
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|MatchModality
name|matchModality
parameter_list|,
name|boolean
name|unionRewriting
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
block|{
specifier|final
name|Aggregate
name|queryAggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
specifier|final
name|Aggregate
name|viewAggregate
init|=
operator|(
name|Aggregate
operator|)
name|viewNode
decl_stmt|;
comment|// Get group by references and aggregate call input references needed
name|ImmutableBitSet
operator|.
name|Builder
name|indexes
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|ImmutableBitSet
name|references
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|topProject
operator|!=
literal|null
operator|&&
operator|!
name|unionRewriting
condition|)
block|{
comment|// We have a Project on top, gather only what is needed
specifier|final
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|topProject
operator|.
name|getChildExps
argument_list|()
control|)
block|{
name|e
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
block|}
name|references
operator|=
name|inputFinder
operator|.
name|inputBitSet
operator|.
name|build
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|inputIdx
range|:
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|inputIdx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// No project on top, all of them are needed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggregateCall
name|queryAggCall
range|:
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
for|for
control|(
name|int
name|inputIdx
range|:
name|queryAggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|inputIdx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Create mapping from query columns to view columns
name|List
argument_list|<
name|RexNode
argument_list|>
name|rollupNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|m
init|=
name|generateMapping
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|mq
argument_list|,
name|queryAggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|viewAggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|indexes
operator|.
name|build
argument_list|()
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|queryEC
argument_list|,
name|rollupNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// We could map all expressions. Create aggregate mapping.
name|int
name|viewAggregateAdditionalFieldCount
init|=
name|rollupNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|viewInputFieldCount
init|=
name|viewAggregate
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|viewInputDifferenceViewFieldCount
init|=
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
name|viewInputFieldCount
decl_stmt|;
name|int
name|viewAggregateTotalFieldCount
init|=
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|rollupNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|forceRollup
init|=
literal|false
decl_stmt|;
name|Mapping
name|aggregateMapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|FUNCTION
argument_list|,
name|queryAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|viewAggregateTotalFieldCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|m
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
range|:
name|c
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|viewAggregate
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// This is one of the rollup columns
name|aggregateMapping
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|j
operator|+
name|viewInputDifferenceViewFieldCount
argument_list|)
expr_stmt|;
name|forceRollup
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|int
name|targetIdx
init|=
name|viewAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|indexOf
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
name|aggregateMapping
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|targetIdx
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// It is not part of group by, we bail out
return|return
literal|null
return|;
block|}
block|}
name|boolean
name|containsDistinctAgg
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|!=
literal|null
operator|&&
operator|!
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|idx
argument_list|)
condition|)
block|{
comment|// Ignore
continue|continue;
block|}
name|AggregateCall
name|queryAggCall
init|=
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryAggCall
operator|.
name|filterArg
operator|>=
literal|0
condition|)
block|{
comment|// Not supported currently
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|queryAggCallIndexes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|aggCallIdx
range|:
name|queryAggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|queryAggCallIndexes
operator|.
name|add
argument_list|(
name|m
operator|.
name|get
argument_list|(
name|aggCallIdx
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|viewAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|AggregateCall
name|viewAggCall
init|=
name|viewAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryAggCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getKind
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getKind
argument_list|()
operator|||
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|isDistinct
argument_list|()
operator|||
name|queryAggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|||
name|queryAggCall
operator|.
name|getType
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getType
argument_list|()
operator|||
name|viewAggCall
operator|.
name|filterArg
operator|>=
literal|0
condition|)
block|{
comment|// Continue
continue|continue;
block|}
if|if
condition|(
operator|!
name|queryAggCallIndexes
operator|.
name|equals
argument_list|(
name|viewAggCall
operator|.
name|getArgList
argument_list|()
argument_list|)
condition|)
block|{
comment|// Continue
continue|continue;
block|}
name|aggregateMapping
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|idx
argument_list|,
name|viewAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|containsDistinctAgg
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|// If we reach here, to simplify things, we create an identity topViewProject
comment|// if not present
if|if
condition|(
name|topViewProject
operator|==
literal|null
condition|)
block|{
name|topViewProject
operator|=
operator|(
name|Project
operator|)
name|relBuilder
operator|.
name|push
argument_list|(
name|viewNode
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// Generate result rewriting
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|additionalViewExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Multimap is required since a column in the materialized view's project
comment|// could map to multiple columns in the target query
name|ImmutableMultimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|rewritingMapping
init|=
literal|null
decl_stmt|;
name|RelNode
name|result
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// We create view expressions that will be used in a Project on top of the
comment|// view in case we need to rollup the expression
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|inputViewExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|inputViewExprs
operator|.
name|addAll
argument_list|(
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|fields
argument_list|()
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|forceRollup
operator|||
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|!=
name|viewAggregate
operator|.
name|getGroupCount
argument_list|()
operator|||
name|matchModality
operator|==
name|MatchModality
operator|.
name|VIEW_PARTIAL
condition|)
block|{
if|if
condition|(
name|containsDistinctAgg
condition|)
block|{
comment|// Cannot rollup DISTINCT aggregate
return|return
literal|null
return|;
block|}
comment|// Target is coarser level of aggregation. Generate an aggregate.
specifier|final
name|ImmutableMultimap
operator|.
name|Builder
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|rewritingMappingB
init|=
name|ImmutableMultimap
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|groupSetB
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|targetIdx
init|=
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No matching group by column, we bail out
return|return
literal|null
return|;
block|}
name|boolean
name|added
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|>=
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
name|RexNode
name|targetNode
init|=
name|rollupNodes
operator|.
name|get
argument_list|(
name|targetIdx
operator|-
name|viewInputFieldCount
operator|-
name|viewInputDifferenceViewFieldCount
argument_list|)
decl_stmt|;
comment|// We need to rollup this expression
specifier|final
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|refs
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|targetNode
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|childTargetIdx
range|:
name|refs
control|)
block|{
name|added
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|added
condition|;
name|k
operator|++
control|)
block|{
name|RexNode
name|n
init|=
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|INPUT_REF
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|int
name|ref
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|n
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|childTargetIdx
condition|)
block|{
name|exprsLineage
operator|.
name|put
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|ref
argument_list|,
name|targetNode
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
comment|// No matching column needed for computed expression, bail out
return|return
literal|null
return|;
block|}
block|}
comment|// We create the new node pointing to the index
name|groupSetB
operator|.
name|set
argument_list|(
name|inputViewExprs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|rewritingMappingB
operator|.
name|put
argument_list|(
name|inputViewExprs
operator|.
name|size
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|additionalViewExprs
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|targetIdx
argument_list|,
name|targetNode
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// We need to create the rollup expression
name|inputViewExprs
operator|.
name|add
argument_list|(
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|targetNode
argument_list|,
name|exprsLineage
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// This expression should be referenced directly
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|added
condition|;
name|k
operator|++
control|)
block|{
name|RexNode
name|n
init|=
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|INPUT_REF
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|ref
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|n
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|targetIdx
condition|)
block|{
name|groupSetB
operator|.
name|set
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|rewritingMappingB
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
comment|// No matching group by column, we bail out
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|groupSetB
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|!=
literal|null
operator|&&
operator|!
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
condition|)
block|{
comment|// Ignore
continue|continue;
block|}
name|int
name|sourceIdx
init|=
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
decl_stmt|;
name|int
name|targetIdx
init|=
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|sourceIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|<
literal|0
condition|)
block|{
comment|// No matching aggregation column, we bail out
return|return
literal|null
return|;
block|}
name|AggregateCall
name|queryAggCall
init|=
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|added
condition|;
name|k
operator|++
control|)
block|{
name|RexNode
name|n
init|=
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|INPUT_REF
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|ref
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|n
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|targetIdx
condition|)
block|{
name|SqlAggFunction
name|rollupAgg
init|=
name|getRollup
argument_list|(
name|queryAggCall
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rollupAgg
operator|==
literal|null
condition|)
block|{
comment|// Cannot rollup this aggregate, bail out
return|return
literal|null
return|;
block|}
name|rewritingMappingB
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|aggregateCalls
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RexInputRef
name|operand
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|input
argument_list|,
name|k
argument_list|)
decl_stmt|;
name|aggregateCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|rollupAgg
argument_list|,
name|operand
argument_list|)
operator|.
name|approximate
argument_list|(
name|queryAggCall
operator|.
name|isApproximate
argument_list|()
argument_list|)
operator|.
name|distinct
argument_list|(
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
argument_list|)
operator|.
name|as
argument_list|(
name|queryAggCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
comment|// No matching aggregation column, we bail out
return|return
literal|null
return|;
block|}
block|}
comment|// Create aggregate on top of input
name|RelNode
name|prevNode
init|=
name|result
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputViewExprs
operator|.
name|size
argument_list|()
operator|!=
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
name|relBuilder
operator|.
name|project
argument_list|(
name|inputViewExprs
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|relBuilder
operator|.
name|aggregate
argument_list|(
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|groupSet
argument_list|)
argument_list|,
name|aggregateCalls
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevNode
operator|==
name|result
operator|&&
name|groupSet
operator|.
name|cardinality
argument_list|()
operator|!=
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// Aggregate was not inserted but we need to prune columns
name|result
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|(
name|groupSet
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// We introduce a project on top, as group by columns order is lost
name|rewritingMapping
operator|=
name|rewritingMappingB
operator|.
name|build
argument_list|()
expr_stmt|;
specifier|final
name|ImmutableMultimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|inverseMapping
init|=
name|rewritingMapping
operator|.
name|inverse
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|addedProjects
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
name|groupSet
operator|.
name|indexOf
argument_list|(
name|inverseMapping
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|addedProjects
operator|.
name|set
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|projects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|result
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ImmutableBitSet
name|projectedCols
init|=
name|addedProjects
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// We add aggregate functions that are present in result to projection list
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|projectedCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|result
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|projects
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// end if queryAggregate.getGroupCount() != viewAggregate.getGroupCount()
comment|// Add query expressions on top. We first map query expressions to view
comment|// expressions. Once we have done that, if the expression is contained
comment|// and we have introduced already an operator on top of the input node,
comment|// we use the mapping to resolve the position of the expression in the
comment|// node.
specifier|final
name|RelDataType
name|topRowType
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|topExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|topProject
operator|!=
literal|null
operator|&&
operator|!
name|unionRewriting
condition|)
block|{
name|topExprs
operator|.
name|addAll
argument_list|(
name|topProject
operator|.
name|getChildExps
argument_list|()
argument_list|)
expr_stmt|;
name|topRowType
operator|=
name|topProject
operator|.
name|getRowType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Add all
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|queryAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|topExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|queryAggregate
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|topRowType
operator|=
name|queryAggregate
operator|.
name|getRowType
argument_list|()
expr_stmt|;
block|}
comment|// Available in view.
specifier|final
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|viewExprs
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|int
name|numberViewExprs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|viewExpr
range|:
name|topViewProject
operator|.
name|getChildExps
argument_list|()
control|)
block|{
name|viewExprs
operator|.
name|put
argument_list|(
name|viewExpr
argument_list|,
name|numberViewExprs
operator|++
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RexNode
name|additionalViewExpr
range|:
name|additionalViewExprs
control|)
block|{
name|viewExprs
operator|.
name|put
argument_list|(
name|additionalViewExpr
argument_list|,
name|numberViewExprs
operator|++
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|topExprs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|topExprs
control|)
block|{
comment|// First map through the aggregate
name|RexNode
name|rewrittenExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|aggregateMapping
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenExpr
operator|==
literal|null
condition|)
block|{
comment|// Cannot map expression
return|return
literal|null
return|;
block|}
comment|// Next map through the last project
name|rewrittenExpr
operator|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|rewrittenExpr
argument_list|,
name|viewExprs
argument_list|,
name|result
argument_list|,
name|rewritingMapping
argument_list|)
expr_stmt|;
if|if
condition|(
name|rewrittenExpr
operator|==
literal|null
condition|)
block|{
comment|// Cannot map expression
return|return
literal|null
return|;
block|}
name|rewrittenExprs
operator|.
name|add
argument_list|(
name|rewrittenExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|rewrittenExprs
argument_list|)
operator|.
name|convert
argument_list|(
name|topRowType
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Mapping from node expressions to target expressions.    *    *<p>If any of the expressions cannot be mapped, we return null.    */
specifier|protected
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|generateMapping
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelNode
name|target
parameter_list|,
name|ImmutableBitSet
name|positions
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|sourceEC
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|additionalExprs
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|additionalExprs
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|m
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|equivalenceClassesMap
init|=
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
decl_stmt|;
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|timestampExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|target
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|target
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Bail out
continue|continue;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
specifier|final
name|RexNode
name|e
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Rewrite expr to be expressed on query tables
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|RexNode
name|expr
init|=
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|simplified
argument_list|,
name|tableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|equivalenceClassesMap
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SqlTypeName
name|sqlTypeName
init|=
name|expr
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|sqlTypeName
operator|==
name|SqlTypeName
operator|.
name|TIMESTAMP
operator|||
name|sqlTypeName
operator|==
name|SqlTypeName
operator|.
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
condition|)
block|{
name|timestampExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If this is a column of TIMESTAMP (WITH LOCAL TIME ZONE)
comment|// type, we add the possible rollup columns too.
comment|// This way we will be able to match FLOOR(ts to HOUR) to
comment|// FLOOR(ts to DAY) via FLOOR(FLOOR(ts to HOUR) to DAY)
for|for
control|(
name|RexNode
name|timestampExpr
range|:
name|timestampExprs
control|)
block|{
for|for
control|(
name|TimeUnitRange
name|value
range|:
name|SUPPORTED_DATE_TIME_ROLLUP_UNITS
control|)
block|{
comment|// CEIL
name|RexNode
name|ceilExpr
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|getCeilSqlFunction
argument_list|(
name|value
argument_list|)
argument_list|,
name|timestampExpr
argument_list|,
name|rexBuilder
operator|.
name|makeFlag
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
comment|// References self-row
name|RexNode
name|rewrittenCeilExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|ceilExpr
argument_list|,
name|exprsLineage
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenCeilExpr
operator|!=
literal|null
condition|)
block|{
comment|// We add the CEIL expression to the additional expressions, replacing the child
comment|// expression by the position that it references
name|additionalExprs
operator|.
name|add
argument_list|(
name|rewrittenCeilExpr
argument_list|)
expr_stmt|;
comment|// Then we simplify the expression and we add it to the expressions lineage so we
comment|// can try to find a match
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|ceilExpr
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|simplified
argument_list|,
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|additionalExprs
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// FLOOR
name|RexNode
name|floorExpr
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|getFloorSqlFunction
argument_list|(
name|value
argument_list|)
argument_list|,
name|timestampExpr
argument_list|,
name|rexBuilder
operator|.
name|makeFlag
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
comment|// References self-row
name|RexNode
name|rewrittenFloorExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|floorExpr
argument_list|,
name|exprsLineage
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenFloorExpr
operator|!=
literal|null
condition|)
block|{
comment|// We add the FLOOR expression to the additional expressions, replacing the child
comment|// expression by the position that it references
name|additionalExprs
operator|.
name|add
argument_list|(
name|rewrittenFloorExpr
argument_list|)
expr_stmt|;
comment|// Then we simplify the expression and we add it to the expressions lineage so we
comment|// can try to find a match
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|floorExpr
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|simplified
argument_list|,
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|additionalExprs
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
range|:
name|positions
control|)
block|{
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
specifier|final
name|RexNode
name|e
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Rewrite expr to be expressed on query tables
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|RexNode
name|targetExpr
init|=
name|RexUtil
operator|.
name|swapColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|simplified
argument_list|,
name|equivalenceClassesMap
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|targetExpr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Integer
name|j
range|:
name|c
control|)
block|{
name|m
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If we did not find the expression, try to navigate it
name|RexNode
name|rewrittenTargetExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|targetExpr
argument_list|,
name|exprsLineage
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenTargetExpr
operator|==
literal|null
condition|)
block|{
comment|// Some expressions were not present
return|return
literal|null
return|;
block|}
name|m
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|additionalExprs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|additionalExprs
operator|.
name|add
argument_list|(
name|rewrittenTargetExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|m
return|;
block|}
comment|/**    * Get ceil function datetime.    */
specifier|protected
name|SqlFunction
name|getCeilSqlFunction
parameter_list|(
name|TimeUnitRange
name|flag
parameter_list|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|CEIL
return|;
block|}
comment|/**    * Get floor function datetime.    */
specifier|protected
name|SqlFunction
name|getFloorSqlFunction
parameter_list|(
name|TimeUnitRange
name|flag
parameter_list|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|FLOOR
return|;
block|}
comment|/**    * Get rollup aggregation function.    */
specifier|protected
name|SqlAggFunction
name|getRollup
parameter_list|(
name|SqlAggFunction
name|aggregation
parameter_list|)
block|{
if|if
condition|(
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|SUM
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|MIN
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|MAX
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|SUM0
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|ANY_VALUE
condition|)
block|{
return|return
name|aggregation
return|;
block|}
if|else if
condition|(
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|COUNT
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|SUM0
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|pushFilterToOriginalViewPlan
parameter_list|(
name|RelBuilder
name|builder
parameter_list|,
name|RelNode
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|RexNode
name|cond
parameter_list|)
block|{
comment|// We add (and push) the filter to the view plan before triggering the rewriting.
comment|// This is useful in case some of the columns can be folded to same value after
comment|// filter is added.
name|HepProgramBuilder
name|pushFiltersProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|topViewProject
operator|!=
literal|null
condition|)
block|{
name|pushFiltersProgram
operator|.
name|addRuleInstance
argument_list|(
name|filterProjectTransposeRule
argument_list|)
expr_stmt|;
block|}
name|pushFiltersProgram
operator|.
name|addRuleInstance
argument_list|(
name|this
operator|.
name|filterAggregateTransposeRule
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|this
operator|.
name|aggregateProjectPullUpConstantsRule
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|this
operator|.
name|projectMergeRule
argument_list|)
expr_stmt|;
specifier|final
name|HepPlanner
name|tmpPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|pushFiltersProgram
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// Now that the planner is created, push the node
name|RelNode
name|topNode
init|=
name|builder
operator|.
name|push
argument_list|(
name|topViewProject
operator|!=
literal|null
condition|?
name|topViewProject
else|:
name|viewNode
argument_list|)
operator|.
name|filter
argument_list|(
name|cond
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|tmpPlanner
operator|.
name|setRoot
argument_list|(
name|topNode
argument_list|)
expr_stmt|;
name|topNode
operator|=
name|tmpPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
name|RelNode
name|resultTopViewProject
init|=
literal|null
decl_stmt|;
name|RelNode
name|resultViewNode
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|topNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|topNode
operator|instanceof
name|Project
condition|)
block|{
if|if
condition|(
name|resultTopViewProject
operator|!=
literal|null
condition|)
block|{
comment|// Both projects could not be merged, we will bail out
return|return
name|Pair
operator|.
name|of
argument_list|(
name|topViewProject
argument_list|,
name|viewNode
argument_list|)
return|;
block|}
name|resultTopViewProject
operator|=
name|topNode
expr_stmt|;
name|topNode
operator|=
name|topNode
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|topNode
operator|instanceof
name|Aggregate
condition|)
block|{
name|resultViewNode
operator|=
name|topNode
expr_stmt|;
name|topNode
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// We move to the child
name|topNode
operator|=
name|topNode
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|resultTopViewProject
argument_list|,
name|resultViewNode
argument_list|)
return|;
block|}
block|}
end_class

end_unit

