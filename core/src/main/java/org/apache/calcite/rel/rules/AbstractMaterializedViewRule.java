begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterializations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleOperand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|SubstitutionVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|VolcanoPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelReferentialConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
operator|.
name|AggCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultDirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultEdge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|IntPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|MappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|ImmutableTriple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashBiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Planner rule that converts a {@link org.apache.calcite.rel.core.Project}  * followed by {@link org.apache.calcite.rel.core.Aggregate} or an  * {@link org.apache.calcite.rel.core.Aggregate} to a scan (and possibly  * other operations) over a materialized view.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|AbstractMaterializedViewRule
extends|extends
name|RelOptRule
block|{
specifier|private
specifier|static
specifier|final
name|CalciteLogger
name|LOGGER
init|=
operator|new
name|CalciteLogger
argument_list|(
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AbstractMaterializedViewRule
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewProjectFilterRule
name|INSTANCE_PROJECT_FILTER
init|=
operator|new
name|MaterializedViewProjectFilterRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewOnlyFilterRule
name|INSTANCE_FILTER
init|=
operator|new
name|MaterializedViewOnlyFilterRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewProjectJoinRule
name|INSTANCE_PROJECT_JOIN
init|=
operator|new
name|MaterializedViewProjectJoinRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewOnlyJoinRule
name|INSTANCE_JOIN
init|=
operator|new
name|MaterializedViewOnlyJoinRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewProjectAggregateRule
name|INSTANCE_PROJECT_AGGREGATE
init|=
operator|new
name|MaterializedViewProjectAggregateRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewOnlyAggregateRule
name|INSTANCE_AGGREGATE
init|=
operator|new
name|MaterializedViewOnlyAggregateRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|)
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/** Creates a AbstractMaterializedViewRule. */
specifier|protected
name|AbstractMaterializedViewRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rewriting logic is based on "Optimizing Queries Using Materialized Views:    * A Practical, Scalable Solution" by Goldstein and Larson.    *    *<p>On the query side, rules matches a Project-node chain or node, where node    * is either an Aggregate or a Join. Subplan rooted at the node operator must    * be composed of one or more of the following operators: TableScan, Project,    * Filter, and Join.    *    *<p>For each join MV, we need to check the following:    *<ol>    *<li> The plan rooted at the Join operator in the view produces all rows    * needed by the plan rooted at the Join operator in the query.</li>    *<li> All columns required by compensating predicates, i.e., predicates that    * need to be enforced over the view, are available at the view output.</li>    *<li> All output expressions can be computed from the output of the view.</li>    *<li> All output rows occur with the correct duplication factor. We might    * rely on existing Unique-Key - Foreign-Key relationships to extract that    * information.</li>    *</ol>    *    *<p>In turn, for each aggregate MV, we need to check the following:    *<ol>    *<li> The plan rooted at the Aggregate operator in the view produces all rows    * needed by the plan rooted at the Aggregate operator in the query.</li>    *<li> All columns required by compensating predicates, i.e., predicates that    * need to be enforced over the view, are available at the view output.</li>    *<li> The grouping columns in the query are a subset of the grouping columns    * in the view.</li>    *<li> All columns required to perform further grouping are available in the    * view output.</li>    *<li> All columns required to compute output expressions are available in the    * view output.</li>    *</ol>    */
specifier|protected
name|void
name|perform
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|node
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|RelMetadataQuery
operator|.
name|instance
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPlanner
name|planner
init|=
name|call
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
literal|true
argument_list|,
name|planner
operator|.
name|getExecutor
argument_list|()
operator|!=
literal|null
condition|?
name|planner
operator|.
name|getExecutor
argument_list|()
else|:
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
init|=
operator|(
name|planner
operator|instanceof
name|VolcanoPlanner
operator|)
condition|?
operator|(
operator|(
name|VolcanoPlanner
operator|)
name|planner
operator|)
operator|.
name|getMaterializations
argument_list|()
else|:
name|ImmutableList
operator|.
expr|<
name|RelOptMaterialization
operator|>
name|of
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|materializations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// 1. Explore query plan to recognize whether preconditions to
comment|// try to generate a rewriting are met
if|if
condition|(
operator|!
name|isValidPlan
argument_list|(
name|topProject
argument_list|,
name|node
argument_list|,
name|mq
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Obtain applicable (filtered) materializations
comment|// TODO: Filtering of relevant materializations needs to be
comment|// improved so we gather only materializations that might
comment|// actually generate a valid rewriting.
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|applicableMaterializations
init|=
name|RelOptMaterializations
operator|.
name|getApplicableMaterializations
argument_list|(
name|node
argument_list|,
name|materializations
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|applicableMaterializations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// 2. Initialize all query related auxiliary data structures
comment|// that will be used throughout query rewriting process
comment|// Generate query table references
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryTableRefs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return;
block|}
comment|// Extract query predicates
specifier|final
name|RelOptPredicateList
name|queryPredicateList
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryPredicateList
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return;
block|}
specifier|final
name|RexNode
name|pred
init|=
name|simplify
operator|.
name|simplify
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|queryPredicateList
operator|.
name|pulledUpPredicates
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Triple
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|queryPreds
init|=
name|splitPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|pred
argument_list|)
decl_stmt|;
comment|// Extract query equivalence classes. An equivalence class is a set
comment|// of columns in the query output that are known to be equal.
specifier|final
name|EquivalenceClasses
name|qEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|queryPreds
operator|.
name|getLeft
argument_list|()
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|qEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. We iterate through all applicable materializations trying to
comment|// rewrite the given query
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|applicableMaterializations
control|)
block|{
specifier|final
name|Project
name|topViewProject
decl_stmt|;
specifier|final
name|RelNode
name|viewNode
decl_stmt|;
if|if
condition|(
name|materialization
operator|.
name|queryRel
operator|instanceof
name|Project
condition|)
block|{
name|topViewProject
operator|=
operator|(
name|Project
operator|)
name|materialization
operator|.
name|queryRel
expr_stmt|;
name|viewNode
operator|=
name|topViewProject
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|topViewProject
operator|=
literal|null
expr_stmt|;
name|viewNode
operator|=
name|materialization
operator|.
name|queryRel
expr_stmt|;
block|}
comment|// 3.1. View checks before proceeding
if|if
condition|(
operator|!
name|isValidPlan
argument_list|(
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|mq
argument_list|)
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// 3.2. Initialize all query related auxiliary data structures
comment|// that will be used throughout query rewriting process
comment|// Extract view predicates
specifier|final
name|RelOptPredicateList
name|viewPredicateList
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|viewNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewPredicateList
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
specifier|final
name|RexNode
name|viewPred
init|=
name|simplify
operator|.
name|simplify
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|viewPredicateList
operator|.
name|pulledUpPredicates
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Triple
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|viewPreds
init|=
name|splitPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|viewPred
argument_list|)
decl_stmt|;
comment|// Extract view table references
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|viewNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewTableRefs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return;
block|}
comment|// Extract view tables
name|MatchModality
name|matchModality
decl_stmt|;
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|compensationEquiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|queryTableRefs
operator|.
name|equals
argument_list|(
name|viewTableRefs
argument_list|)
condition|)
block|{
comment|// We try to compensate, e.g., for join queries it might be
comment|// possible to join missing tables with view to compute result.
comment|// Two supported cases: query tables are subset of view tables (we need to
comment|// check whether they are cardinality-preserving joins), or view tables are
comment|// subset of query tables (add additional tables through joins if possible)
if|if
condition|(
name|viewTableRefs
operator|.
name|containsAll
argument_list|(
name|queryTableRefs
argument_list|)
condition|)
block|{
name|matchModality
operator|=
name|MatchModality
operator|.
name|QUERY_PARTIAL
expr_stmt|;
specifier|final
name|EquivalenceClasses
name|vEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|viewPreds
operator|.
name|getLeft
argument_list|()
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|vEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compensateQueryPartial
argument_list|(
name|compensationEquiColumns
argument_list|,
name|viewTableRefs
argument_list|,
name|vEC
argument_list|,
name|queryTableRefs
argument_list|)
condition|)
block|{
comment|// Cannot rewrite, skip it
continue|continue;
block|}
block|}
if|else if
condition|(
name|queryTableRefs
operator|.
name|containsAll
argument_list|(
name|viewTableRefs
argument_list|)
condition|)
block|{
comment|// TODO: implement latest case
name|matchModality
operator|=
name|MatchModality
operator|.
name|VIEW_PARTIAL
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|// Skip it
continue|continue;
block|}
block|}
else|else
block|{
name|matchModality
operator|=
name|MatchModality
operator|.
name|COMPLETE
expr_stmt|;
block|}
comment|// 4. We map every table in the query to a view table with the same qualified
comment|// name.
specifier|final
name|Multimap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|multiMapTables
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|queryTableRef
range|:
name|queryTableRefs
control|)
block|{
for|for
control|(
name|RelTableRef
name|viewTableRef
range|:
name|viewTableRefs
control|)
block|{
if|if
condition|(
name|queryTableRef
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|viewTableRef
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
name|multiMapTables
operator|.
name|put
argument_list|(
name|queryTableRef
argument_list|,
name|viewTableRef
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If a table is used multiple times, we will create multiple mappings,
comment|// and we will try to rewrite the query using each of the mappings.
comment|// Then, we will try to map every source table (query) to a target
comment|// table (view), and if we are successful, we will try to create
comment|// compensation predicates to filter the view results further
comment|// (if needed).
specifier|final
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|flatListMappings
init|=
name|generateTableMappings
argument_list|(
name|multiMapTables
argument_list|)
decl_stmt|;
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
range|:
name|flatListMappings
control|)
block|{
comment|// 4.0. If compensation equivalence classes exist, we need to add
comment|// the mapping to the query mapping
specifier|final
name|EquivalenceClasses
name|currQEC
init|=
name|EquivalenceClasses
operator|.
name|copy
argument_list|(
name|qEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchModality
operator|==
name|MatchModality
operator|.
name|QUERY_PARTIAL
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|e
range|:
name|compensationEquiColumns
operator|.
name|entries
argument_list|()
control|)
block|{
comment|// Copy origin
name|RelTableRef
name|queryTableRef
init|=
name|tableMapping
operator|.
name|inverse
argument_list|()
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|)
decl_stmt|;
name|RexTableInputRef
name|queryColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|queryTableRef
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
comment|// Add to query equivalence classes and table mapping
name|currQEC
operator|.
name|addEquivalenceClass
argument_list|(
name|queryColumnRef
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|tableMapping
operator|.
name|put
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|)
expr_stmt|;
comment|//identity
block|}
block|}
specifier|final
name|RexNode
name|compensationColumnsEquiPred
decl_stmt|;
specifier|final
name|RexNode
name|compensationRangePred
decl_stmt|;
specifier|final
name|RexNode
name|compensationResidualPred
decl_stmt|;
comment|// 4.1. Establish relationship between view and query equivalence classes.
comment|// If every view equivalence class is not a subset of a query
comment|// equivalence class, we bail out.
comment|// To establish relationship, we swap column references of the view predicates
comment|// to point to query tables. Then, we create the equivalence classes for the
comment|// view predicates and check that every view equivalence class is a subset of a
comment|// query equivalence class: if it is not, we bail out.
specifier|final
name|RexNode
name|viewColumnsEquiPred
init|=
name|RexUtil
operator|.
name|swapTableReferences
argument_list|(
name|rexBuilder
argument_list|,
name|viewPreds
operator|.
name|getLeft
argument_list|()
argument_list|,
name|tableMapping
operator|.
name|inverse
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|EquivalenceClasses
name|queryBasedVEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|viewColumnsEquiPred
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|queryBasedVEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|compensationColumnsEquiPred
operator|=
name|generateEquivalenceClasses
argument_list|(
name|rexBuilder
argument_list|,
name|currQEC
argument_list|,
name|queryBasedVEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationColumnsEquiPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// 4.2. We check that range intervals for the query are contained in the view.
comment|// Compute compensating predicates.
specifier|final
name|RexNode
name|queryRangePred
init|=
name|RexUtil
operator|.
name|swapColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|queryPreds
operator|.
name|getMiddle
argument_list|()
argument_list|,
name|currQEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|viewRangePred
init|=
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|viewPreds
operator|.
name|getMiddle
argument_list|()
argument_list|,
name|tableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|currQEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
name|compensationRangePred
operator|=
name|SubstitutionVisitor
operator|.
name|splitFilter
argument_list|(
name|simplify
argument_list|,
name|queryRangePred
argument_list|,
name|viewRangePred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationRangePred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// 4.3. Finally, we check that residual predicates of the query are satisfied
comment|// within the view.
comment|// Compute compensating predicates.
specifier|final
name|RexNode
name|queryResidualPred
init|=
name|RexUtil
operator|.
name|swapColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|queryPreds
operator|.
name|getRight
argument_list|()
argument_list|,
name|currQEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|viewResidualPred
init|=
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|viewPreds
operator|.
name|getRight
argument_list|()
argument_list|,
name|tableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|currQEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
name|compensationResidualPred
operator|=
name|SubstitutionVisitor
operator|.
name|splitFilter
argument_list|(
name|simplify
argument_list|,
name|queryResidualPred
argument_list|,
name|viewResidualPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationResidualPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// 4.4. Final compensation predicate.
name|RexNode
name|compensationPred
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|compensationColumnsEquiPred
argument_list|,
name|compensationRangePred
argument_list|,
name|compensationResidualPred
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// All columns required by compensating predicates must be contained
comment|// in the view output (condition 2).
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
init|=
name|extractExpressions
argument_list|(
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|compensationPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|viewNode
argument_list|,
name|viewExprs
argument_list|,
name|compensationPred
argument_list|,
name|tableMapping
argument_list|,
name|currQEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|,
name|mq
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
block|}
comment|// 4.5. Generate final rewriting if possible.
comment|// First, we add the compensation predicate (if any) on top of the view.
comment|// Then, we trigger the Aggregate unifying method. This method will either create
comment|// a Project or an Aggregate operator on top of the view. It will also compute the
comment|// output expressions for the query.
name|RelBuilder
name|builder
init|=
name|call
operator|.
name|builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|push
argument_list|(
name|materialization
operator|.
name|tableRel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|builder
operator|.
name|filter
argument_list|(
name|compensationPred
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|result
init|=
name|unify
argument_list|(
name|rexBuilder
argument_list|,
name|builder
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|tableMapping
argument_list|,
name|currQEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|protected
specifier|abstract
name|boolean
name|isValidPlan
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
function_decl|;
specifier|protected
specifier|abstract
name|List
argument_list|<
name|RexNode
argument_list|>
name|extractExpressions
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
function_decl|;
comment|/**    * This method is responsible for rewriting the query using the given view query.    *    *<p>The input node is a Scan on the view table and possibly a compensation Filter    * on top. If a rewriting can be produced, we return that rewriting. If it cannot    * be produced, we will return null.    */
specifier|protected
specifier|abstract
name|RelNode
name|unify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|equivalenceClassesMap
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
function_decl|;
comment|//~ Instances Join ---------------------------------------------------------
comment|/** Materialized view rewriting for join */
specifier|private
specifier|abstract
specifier|static
class|class
name|MaterializedViewJoinRule
extends|extends
name|AbstractMaterializedViewRule
block|{
comment|/** Creates a MaterializedViewJoinRule. */
specifier|protected
name|MaterializedViewJoinRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isValidPlan
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
return|return
name|isValidRexNodePlan
argument_list|(
name|node
argument_list|,
name|mq
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|List
argument_list|<
name|RexNode
argument_list|>
name|extractExpressions
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|topProject
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|RexNode
name|e
range|:
name|topProject
operator|.
name|getChildExps
argument_list|()
control|)
block|{
name|viewExprs
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|viewExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|viewExprs
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|unify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|equivalenceClassesMap
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|extractExpressions
argument_list|(
name|topProject
argument_list|,
name|node
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprsLineage
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
assert|assert
name|s
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|exprsLineage
operator|.
name|add
argument_list|(
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
init|=
name|extractExpressions
argument_list|(
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
name|rewriteExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|viewNode
argument_list|,
name|viewExprs
argument_list|,
name|exprsLineage
argument_list|,
name|tableMapping
argument_list|,
name|equivalenceClassesMap
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenExprs
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
operator|.
name|project
argument_list|(
name|rewrittenExprs
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
comment|/** Rule that matches Project on Join. */
specifier|public
specifier|static
class|class
name|MaterializedViewProjectJoinRule
extends|extends
name|MaterializedViewJoinRule
block|{
specifier|public
name|MaterializedViewProjectJoinRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewJoinRule(Project-Join)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Join
name|join
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|join
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that matches Project on Filter. */
specifier|public
specifier|static
class|class
name|MaterializedViewProjectFilterRule
extends|extends
name|MaterializedViewJoinRule
block|{
specifier|public
name|MaterializedViewProjectFilterRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewJoinRule(Project-Filter)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that matches Join. */
specifier|public
specifier|static
class|class
name|MaterializedViewOnlyJoinRule
extends|extends
name|MaterializedViewJoinRule
block|{
specifier|public
name|MaterializedViewOnlyJoinRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewJoinRule(Join)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Join
name|join
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
name|join
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that matches Filter. */
specifier|public
specifier|static
class|class
name|MaterializedViewOnlyFilterRule
extends|extends
name|MaterializedViewJoinRule
block|{
specifier|public
name|MaterializedViewOnlyFilterRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewJoinRule(Filter)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Instances Aggregate ----------------------------------------------------
comment|/** Materialized view rewriting for aggregate */
specifier|private
specifier|abstract
specifier|static
class|class
name|MaterializedViewAggregateRule
extends|extends
name|AbstractMaterializedViewRule
block|{
comment|/** Creates a MaterializedViewAggregateRule. */
specifier|protected
name|MaterializedViewAggregateRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isValidPlan
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|Aggregate
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|aggregate
operator|.
name|getGroupType
argument_list|()
operator|!=
name|Aggregate
operator|.
name|Group
operator|.
name|SIMPLE
condition|)
block|{
comment|// TODO: Rewriting with grouping sets not supported yet
return|return
literal|false
return|;
block|}
return|return
name|isValidRexNodePlan
argument_list|(
name|aggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|mq
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|List
argument_list|<
name|RexNode
argument_list|>
name|extractExpressions
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|Aggregate
name|viewAggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|topProject
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|RexNode
name|e
range|:
name|topProject
operator|.
name|getChildExps
argument_list|()
control|)
block|{
name|viewExprs
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|viewAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|viewExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|viewAggregate
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|viewExprs
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|unify
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|equivalenceClassesMap
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
specifier|final
name|Aggregate
name|queryAggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
specifier|final
name|Aggregate
name|viewAggregate
init|=
operator|(
name|Aggregate
operator|)
name|viewNode
decl_stmt|;
comment|// Get group by references and aggregate call input references needed
name|ImmutableBitSet
operator|.
name|Builder
name|indexes
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|ImmutableBitSet
name|references
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|topProject
operator|!=
literal|null
condition|)
block|{
comment|// We have a Project on top, gather only what is needed
specifier|final
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
operator|new
name|LinkedHashSet
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|topProject
operator|.
name|getChildExps
argument_list|()
control|)
block|{
name|e
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
block|}
name|references
operator|=
name|inputFinder
operator|.
name|inputBitSet
operator|.
name|build
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|inputIdx
range|:
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|inputIdx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// No project on top, all of them are needed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggregateCall
name|queryAggCall
range|:
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
for|for
control|(
name|int
name|inputIdx
range|:
name|queryAggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|inputIdx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Create mapping from query columns to view columns
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|m
init|=
name|generateMapping
argument_list|(
name|rexBuilder
argument_list|,
name|queryAggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|viewAggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|indexes
operator|.
name|build
argument_list|()
argument_list|,
name|tableMapping
argument_list|,
name|equivalenceClassesMap
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// We could map all expressions. Create aggregate mapping.
name|Mapping
name|aggregateMapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|FUNCTION
argument_list|,
name|queryAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|m
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
range|:
name|c
control|)
block|{
name|int
name|targetIdx
init|=
name|viewAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|indexOf
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
name|aggregateMapping
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|targetIdx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// It is not part of group by, we bail out
return|return
literal|null
return|;
block|}
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|!=
literal|null
operator|&&
operator|!
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|idx
argument_list|)
condition|)
block|{
comment|// Ignore
continue|continue;
block|}
name|AggregateCall
name|queryAggCall
init|=
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|queryAggCallIndexes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|aggCallIdx
range|:
name|queryAggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|queryAggCallIndexes
operator|.
name|add
argument_list|(
name|m
operator|.
name|get
argument_list|(
name|aggCallIdx
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|viewAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|AggregateCall
name|viewAggCall
init|=
name|viewAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryAggCall
operator|.
name|getAggregation
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getAggregation
argument_list|()
operator|||
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|isDistinct
argument_list|()
operator|||
name|queryAggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|||
name|queryAggCall
operator|.
name|getType
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getType
argument_list|()
condition|)
block|{
comment|// Continue
continue|continue;
block|}
if|if
condition|(
operator|!
name|queryAggCallIndexes
operator|.
name|equals
argument_list|(
name|viewAggCall
operator|.
name|getArgList
argument_list|()
argument_list|)
condition|)
block|{
comment|// Continue
continue|continue;
block|}
name|aggregateMapping
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|idx
argument_list|,
name|viewAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// Generate result rewriting
name|Mapping
name|rewritingMapping
init|=
literal|null
decl_stmt|;
name|RelNode
name|result
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|!=
name|viewAggregate
operator|.
name|getGroupCount
argument_list|()
condition|)
block|{
comment|// Target is coarser level of aggregation. Generate an aggregate.
name|rewritingMapping
operator|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|FUNCTION
argument_list|,
name|topViewProject
operator|!=
literal|null
condition|?
name|topViewProject
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
else|:
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|queryAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|groupSetB
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|targetIdx
init|=
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No matching group by column, we bail out
return|return
literal|null
return|;
block|}
if|if
condition|(
name|topViewProject
operator|!=
literal|null
condition|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
name|RexNode
name|n
init|=
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|INPUT_REF
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|ref
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|n
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|targetIdx
condition|)
block|{
name|groupSetB
operator|.
name|set
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|rewritingMapping
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
comment|// No matching group by column, we bail out
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|groupSetB
operator|.
name|set
argument_list|(
name|targetIdx
argument_list|)
expr_stmt|;
name|rewritingMapping
operator|.
name|set
argument_list|(
name|targetIdx
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|groupSetB
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|!=
literal|null
operator|&&
operator|!
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
condition|)
block|{
comment|// Ignore
continue|continue;
block|}
name|int
name|sourceIdx
init|=
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
decl_stmt|;
name|int
name|targetIdx
init|=
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|sourceIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No matching aggregation column, we bail out
return|return
literal|null
return|;
block|}
name|AggregateCall
name|queryAggCall
init|=
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|topViewProject
operator|!=
literal|null
condition|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
name|RexNode
name|n
init|=
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|INPUT_REF
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|ref
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|n
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|targetIdx
condition|)
block|{
name|aggregateCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|SubstitutionVisitor
operator|.
name|getRollup
argument_list|(
name|queryAggCall
operator|.
name|getAggregation
argument_list|()
argument_list|)
argument_list|,
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
literal|null
argument_list|,
name|queryAggCall
operator|.
name|name
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|input
argument_list|,
name|k
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rewritingMapping
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|sourceIdx
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
comment|// No matching aggregation column, we bail out
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|aggregateCalls
operator|.
name|add
argument_list|(
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|SubstitutionVisitor
operator|.
name|getRollup
argument_list|(
name|queryAggCall
operator|.
name|getAggregation
argument_list|()
argument_list|)
argument_list|,
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
literal|null
argument_list|,
name|queryAggCall
operator|.
name|name
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|input
argument_list|,
name|targetIdx
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rewritingMapping
operator|.
name|set
argument_list|(
name|targetIdx
argument_list|,
name|sourceIdx
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|aggregate
argument_list|(
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|groupSet
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
argument_list|,
name|aggregateCalls
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// We introduce a project on top, as group by columns order is lost
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Mapping
name|inverseMapping
init|=
name|rewritingMapping
operator|.
name|inverse
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|result
argument_list|,
name|groupSet
operator|.
name|indexOf
argument_list|(
name|inverseMapping
operator|.
name|getTarget
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|result
argument_list|,
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|projects
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// end if queryAggregate.getGroupCount() != viewAggregate.getGroupCount()
comment|// Add query expressions on top. We first map query expressions to view
comment|// expressions. Once we have done that, if the expression is contained
comment|// and we have introduced already an operator on top of the input node,
comment|// we use the mapping to resolve the position of the expression in the
comment|// node.
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|topExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|topProject
operator|!=
literal|null
condition|)
block|{
name|topExprs
operator|.
name|addAll
argument_list|(
name|topProject
operator|.
name|getChildExps
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Add all
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|queryAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|topExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|queryAggregate
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Available in view.
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|viewExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|topViewProject
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|viewExprs
operator|.
name|add
argument_list|(
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Add all
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|viewExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|viewAggregate
argument_list|,
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|topExprs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|topExprs
control|)
block|{
name|RexNode
name|rewrittenExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|aggregateMapping
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenExpr
operator|==
literal|null
condition|)
block|{
comment|// Cannot map expression
return|return
literal|null
return|;
block|}
name|int
name|pos
init|=
name|viewExprs
operator|.
name|indexOf
argument_list|(
name|rewrittenExpr
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Cannot map expression
return|return
literal|null
return|;
block|}
if|if
condition|(
name|rewritingMapping
operator|!=
literal|null
condition|)
block|{
name|pos
operator|=
name|rewritingMapping
operator|.
name|getTargetOpt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Cannot map expression
return|return
literal|null
return|;
block|}
block|}
name|rewrittenExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|result
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|rewrittenExprs
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
comment|/** Rule that matches Project on Aggregate. */
specifier|public
specifier|static
class|class
name|MaterializedViewProjectAggregateRule
extends|extends
name|MaterializedViewAggregateRule
block|{
specifier|public
name|MaterializedViewProjectAggregateRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewAggregateRule(Project-Aggregate)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that matches Aggregate. */
specifier|public
specifier|static
class|class
name|MaterializedViewOnlyAggregateRule
extends|extends
name|MaterializedViewAggregateRule
block|{
specifier|public
name|MaterializedViewOnlyAggregateRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewAggregateRule(Aggregate)"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * It will flatten a multimap containing table references to table references,    * producing all possible combinations of mappings. Each of the mappings will    * be bi-directional.    */
specifier|private
specifier|static
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|generateTableMappings
parameter_list|(
name|Multimap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|multiMapTables
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|multiMapTables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|result
return|;
block|}
name|result
operator|.
name|add
argument_list|(
name|HashBiMap
operator|.
expr|<
name|RelTableRef
argument_list|,
name|RelTableRef
operator|>
name|create
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|RelTableRef
argument_list|,
name|Collection
argument_list|<
name|RelTableRef
argument_list|>
argument_list|>
name|e
range|:
name|multiMapTables
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RelTableRef
name|target
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|added
condition|)
block|{
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|m
range|:
name|result
control|)
block|{
specifier|final
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|newM
init|=
name|HashBiMap
operator|.
expr|<
name|RelTableRef
decl_stmt|,
name|RelTableRef
decl|>
name|create
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|newM
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|newM
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|m
range|:
name|result
control|)
block|{
name|m
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Mapping needs to exist
assert|assert
name|added
assert|;
block|}
return|return
name|result
return|;
block|}
comment|/** Currently we only support TableScan - Project - Filter - Join */
specifier|private
specifier|static
name|boolean
name|isValidRexNodePlan
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
specifier|final
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|m
init|=
name|mq
operator|.
name|getNodeTypes
argument_list|(
name|node
argument_list|)
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|c
range|:
name|m
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|TableScan
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|Project
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|Filter
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|Join
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|// Skip it
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Classifies each of the predicates in the list into one of these three    * categories:    *<ul>    *<li> 1-l) column equality predicates, or</li>    *<li> 2-m) range predicates, comprising<,<=,>,>=, and = between a reference    * and a constant, or</li>    *<li> 3-r) residual predicates, all the rest</li>    *</ul>    *    *<p>For each category, it creates the conjunction of the predicates. The    * result is an array of three RexNode objects corresponding to each    * category.    */
specifier|private
specifier|static
name|Triple
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|splitPredicates
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|pred
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|equiColumnsPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rangePreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|residualPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|pred
argument_list|)
control|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
name|RexCall
name|eqCall
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|equiColumnsPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isConstant
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isConstant
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rangePreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|residualPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LESS_THAN
case|:
case|case
name|GREATER_THAN
case|:
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|NOT_EQUALS
case|:
name|RexCall
name|rangeCall
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|rangeCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isConstant
argument_list|(
name|rangeCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|rangeCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isConstant
argument_list|(
name|rangeCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rangePreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|residualPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|residualPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ImmutableTriple
operator|.
expr|<
name|RexNode
operator|,
name|RexNode
operator|,
name|RexNode
operator|>
name|of
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|equiColumnsPreds
argument_list|,
literal|false
argument_list|)
argument_list|,
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|rangePreds
argument_list|,
literal|false
argument_list|)
argument_list|,
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|residualPreds
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * It checks whether the query can be rewritten using the view even though the    * view uses additional tables. In order to do that, we need to double-check    * that every join that exists in the view and is not in the query is a    * cardinality-preserving join, i.e., it only appends columns to the row    * without changing its multiplicity. Thus, the join needs to be:    *<ul>    *<li> Equi-join</li>    *<li> Between all columns in the keys</li>    *<li> Foreign-key columns do not allow NULL values</li>    *<li> Foreign-key</li>    *<li> Unique-key</li>    *</ul>    *    *<p>If it can be rewritten, it returns true and it inserts the missing equi-join    * predicates in the input compensationEquiColumns multimap. Otherwise, it returns    * false.    */
specifier|private
specifier|static
name|boolean
name|compensateQueryPartial
parameter_list|(
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|compensationEquiColumns
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
parameter_list|,
name|EquivalenceClasses
name|vEC
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
parameter_list|)
block|{
comment|// Create UK-FK graph with view tables
specifier|final
name|DirectedGraph
argument_list|<
name|RelTableRef
argument_list|,
name|Edge
argument_list|>
name|graph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|(
name|Edge
operator|.
name|FACTORY
argument_list|)
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelTableRef
argument_list|>
name|tableQNameToTableRefs
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|extraTableRefs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|viewTableRefs
control|)
block|{
comment|// Add tables in view as vertices
name|graph
operator|.
name|addVertex
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
name|tableQNameToTableRefs
operator|.
name|put
argument_list|(
name|tRef
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|tRef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queryTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// Add to extra tables if table is not part of the query
name|extraTableRefs
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|graph
operator|.
name|vertexSet
argument_list|()
control|)
block|{
comment|// Add edges between tables
name|List
argument_list|<
name|RelReferentialConstraint
argument_list|>
name|constraints
init|=
name|tRef
operator|.
name|getTable
argument_list|()
operator|.
name|getReferentialConstraints
argument_list|()
decl_stmt|;
for|for
control|(
name|RelReferentialConstraint
name|constraint
range|:
name|constraints
control|)
block|{
name|Collection
argument_list|<
name|RelTableRef
argument_list|>
name|parentTableRefs
init|=
name|tableQNameToTableRefs
operator|.
name|get
argument_list|(
name|constraint
operator|.
name|getTargetQualifiedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentTableRefs
operator|==
literal|null
operator|||
name|parentTableRefs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|RelTableRef
name|parentTRef
range|:
name|parentTableRefs
control|)
block|{
name|boolean
name|canBeRewritten
init|=
literal|true
decl_stmt|;
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|equiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|constraint
operator|.
name|getNumColumns
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|int
name|foreignKeyPos
init|=
name|constraint
operator|.
name|getColumnPairs
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|source
decl_stmt|;
name|RelDataType
name|foreignKeyColumnType
init|=
name|tRef
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|foreignKeyPos
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexTableInputRef
name|foreignKeyColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|tRef
argument_list|,
name|foreignKeyPos
argument_list|,
name|foreignKeyColumnType
argument_list|)
decl_stmt|;
name|int
name|uniqueKeyPos
init|=
name|constraint
operator|.
name|getColumnPairs
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|target
decl_stmt|;
name|RexTableInputRef
name|uniqueKeyColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|parentTRef
argument_list|,
name|uniqueKeyPos
argument_list|,
name|parentTRef
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|uniqueKeyPos
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|foreignKeyColumnType
operator|.
name|isNullable
argument_list|()
operator|&&
name|vEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
operator|.
name|get
argument_list|(
name|uniqueKeyColumnRef
argument_list|)
operator|.
name|contains
argument_list|(
name|foreignKeyColumnRef
argument_list|)
condition|)
block|{
name|equiColumns
operator|.
name|put
argument_list|(
name|foreignKeyColumnRef
argument_list|,
name|uniqueKeyColumnRef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canBeRewritten
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|canBeRewritten
condition|)
block|{
comment|// Add edge FK -> UK
name|Edge
name|edge
init|=
name|graph
operator|.
name|getEdge
argument_list|(
name|tRef
argument_list|,
name|parentTRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|==
literal|null
condition|)
block|{
name|edge
operator|=
name|graph
operator|.
name|addEdge
argument_list|(
name|tRef
argument_list|,
name|parentTRef
argument_list|)
expr_stmt|;
block|}
name|edge
operator|.
name|equiColumns
operator|.
name|putAll
argument_list|(
name|equiColumns
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|// Try to eliminate tables from graph: if we can do it, it means extra tables in
comment|// view are cardinality-preserving joins
name|boolean
name|done
init|=
literal|false
decl_stmt|;
do|do
block|{
name|List
argument_list|<
name|RelTableRef
argument_list|>
name|nodesToRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|graph
operator|.
name|vertexSet
argument_list|()
control|)
block|{
if|if
condition|(
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|graph
operator|.
name|getOutwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// UK-FK join
name|nodesToRemove
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// We need to add to compensation columns as the table is not present in the query
name|compensationEquiColumns
operator|.
name|putAll
argument_list|(
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equiColumns
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|nodesToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|graph
operator|.
name|removeAllVertices
argument_list|(
name|nodesToRemove
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
comment|// After removing them, we check whether all the remaining tables in the graph
comment|// are tables present in the query: if they are, we can try to rewrite
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|graph
operator|.
name|vertexSet
argument_list|()
argument_list|,
name|extraTableRefs
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Given the equi-column predicates of the query and the view and the    * computed equivalence classes, it extracts possible mappings between    * the equivalence classes.    *    *<p>If there is no mapping, it returns null. If there is a exact match,    * it will return a compensation predicate that evaluates to true.    * Finally, if a compensation predicate needs to be enforced on top of    * the view to make the equivalences classes match, it returns that    * compensation predicate    */
specifier|private
specifier|static
name|RexNode
name|generateEquivalenceClasses
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|EquivalenceClasses
name|qEC
parameter_list|,
name|EquivalenceClasses
name|vEC
parameter_list|)
block|{
if|if
condition|(
name|qEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|vEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No column equality predicates in query and view
comment|// Empty mapping and compensation predicate
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|qEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|vEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No column equality predicates in query or view
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|queryEquivalenceClasses
init|=
name|qEC
operator|.
name|getEquivalenceClasses
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|viewEquivalenceClasses
init|=
name|vEC
operator|.
name|getEquivalenceClasses
argument_list|()
decl_stmt|;
specifier|final
name|Mapping
name|mapping
init|=
name|extractPossibleMapping
argument_list|(
name|queryEquivalenceClasses
argument_list|,
name|viewEquivalenceClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapping
operator|==
literal|null
condition|)
block|{
comment|// Did not find mapping between the equivalence classes,
comment|// bail out
return|return
literal|null
return|;
block|}
comment|// Create the compensation predicate
name|RexNode
name|compensationPredicate
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|IntPair
name|pair
range|:
name|mapping
control|)
block|{
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|difference
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|queryEquivalenceClasses
operator|.
name|get
argument_list|(
name|pair
operator|.
name|target
argument_list|)
argument_list|)
decl_stmt|;
name|difference
operator|.
name|removeAll
argument_list|(
name|viewEquivalenceClasses
operator|.
name|get
argument_list|(
name|pair
operator|.
name|source
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RexTableInputRef
name|e
range|:
name|difference
control|)
block|{
name|RexNode
name|equals
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|e
argument_list|,
name|viewEquivalenceClasses
operator|.
name|get
argument_list|(
name|pair
operator|.
name|source
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|compensationPredicate
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|compensationPredicate
argument_list|,
name|equals
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|compensationPredicate
return|;
block|}
comment|/**    * Given the query and view equivalence classes, it extracts the possible mappings    * from each view equivalence class to each query equivalence class.    *    *<p>If any of the view equivalence classes cannot be mapped to a query equivalence    * class, it returns null.    */
specifier|private
specifier|static
name|Mapping
name|extractPossibleMapping
parameter_list|(
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|queryEquivalenceClasses
parameter_list|,
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|viewEquivalenceClasses
parameter_list|)
block|{
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|FUNCTION
argument_list|,
name|viewEquivalenceClasses
operator|.
name|size
argument_list|()
argument_list|,
name|queryEquivalenceClasses
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|viewEquivalenceClasses
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|foundQueryEquivalenceClass
init|=
literal|false
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|viewEquivalenceClass
init|=
name|viewEquivalenceClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|queryEquivalenceClasses
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|queryEquivalenceClass
init|=
name|queryEquivalenceClasses
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryEquivalenceClass
operator|.
name|containsAll
argument_list|(
name|viewEquivalenceClass
argument_list|)
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|foundQueryEquivalenceClass
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// end for
if|if
condition|(
operator|!
name|foundQueryEquivalenceClass
condition|)
block|{
comment|// View equivalence class not found in query equivalence class
return|return
literal|null
return|;
block|}
block|}
comment|// end for
return|return
name|mapping
return|;
block|}
comment|/**    * Given the input expression that references source expressions in the query,    * it will rewrite it to refer to the view output.    *    *<p>If any of the subexpressions in the input expression cannot be mapped to    * the query, it will return null.    */
specifier|private
specifier|static
name|RexNode
name|rewriteExpression
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
parameter_list|,
name|RexNode
name|expr
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|equivalenceClassesMap
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
name|rewriteExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|viewNode
argument_list|,
name|viewExprs
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|expr
argument_list|)
argument_list|,
name|tableMapping
argument_list|,
name|equivalenceClassesMap
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenExprs
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|rewrittenExprs
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|rewrittenExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewriteExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|equivalenceClassesMap
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|viewExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|e
init|=
name|viewExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|viewNode
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Next expression
continue|continue;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
assert|assert
name|s
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
comment|// Rewrite expr to be expressed on query tables
name|exprsLineage
operator|.
name|put
argument_list|(
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|tableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|equivalenceClassesMap
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
name|RexNode
name|rewrittenExpr
init|=
name|replaceWithOriginalReferences
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|exprsLineage
argument_list|)
decl_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|containsTableInputRef
argument_list|(
name|rewrittenExpr
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// Some expressions were not present in view output
return|return
literal|null
return|;
block|}
name|rewrittenExprs
operator|.
name|add
argument_list|(
name|rewrittenExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|rewrittenExprs
return|;
block|}
comment|/**    * Mapping from node expressions to target expressions.    *    *<p>If any of the expressions cannot be mapped, we return null.    */
specifier|private
specifier|static
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|generateMapping
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelNode
name|target
parameter_list|,
name|ImmutableBitSet
name|positions
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|equivalenceClassesMap
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|Multimap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|target
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|target
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Bail out
continue|continue;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
assert|assert
name|s
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
comment|// Rewrite expr to be expressed on query tables
name|exprsLineage
operator|.
name|put
argument_list|(
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|tableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|equivalenceClassesMap
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|m
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|positions
control|)
block|{
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
assert|assert
name|s
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
comment|// Rewrite expr to be expressed on query tables
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|RexUtil
operator|.
name|swapColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|equivalenceClassesMap
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
for|for
control|(
name|Integer
name|j
range|:
name|c
control|)
block|{
name|m
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|m
return|;
block|}
comment|/**    * Given the input expression, it will replace (sub)expressions when possible    * using the content of the mapping. In particular, the mapping contains the    * digest of the expression and the index that the replacement input ref should    * point to.    */
specifier|private
specifier|static
name|RexNode
name|replaceWithOriginalReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|expr
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|mapping
parameter_list|)
block|{
comment|// Currently we allow the following:
comment|// 1) compensation pred can be directly map to expression
comment|// 2) all references in compensation pred can be map to expressions
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|Integer
name|pos
init|=
name|mapping
operator|.
name|get
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|null
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|inputRef
parameter_list|)
block|{
name|Integer
name|pos
init|=
name|mapping
operator|.
name|get
argument_list|(
name|inputRef
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|null
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|visitTableInputRef
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|expr
argument_list|)
return|;
block|}
comment|/**    * Replaces all the input references by the position in the    * input column set. If a reference index cannot be found in    * the input set, then we return null.    */
specifier|private
specifier|static
name|RexNode
name|shuttleReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|node
parameter_list|,
specifier|final
name|Mapping
name|mapping
parameter_list|)
block|{
try|try
block|{
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|int
name|pos
init|=
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|node
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|ex
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Class representing an equivalence class, i.e., a set of equivalent columns.    */
specifier|private
specifier|static
class|class
name|EquivalenceClasses
block|{
specifier|private
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|nodeToEquivalenceClass
decl_stmt|;
specifier|protected
name|EquivalenceClasses
parameter_list|()
block|{
name|nodeToEquivalenceClass
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|addEquivalenceClass
parameter_list|(
name|RexTableInputRef
name|p1
parameter_list|,
name|RexTableInputRef
name|p2
parameter_list|)
block|{
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|c1
init|=
name|nodeToEquivalenceClass
operator|.
name|get
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|c2
init|=
name|nodeToEquivalenceClass
operator|.
name|get
argument_list|(
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|null
operator|&&
name|c2
operator|!=
literal|null
condition|)
block|{
comment|// Both present, we need to merge
if|if
condition|(
name|c1
operator|.
name|size
argument_list|()
operator|<
name|c2
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// We swap them to merge
name|c1
operator|=
name|c2
expr_stmt|;
name|p1
operator|=
name|p2
expr_stmt|;
block|}
for|for
control|(
name|RexTableInputRef
name|newRef
range|:
name|c2
control|)
block|{
name|c1
operator|.
name|add
argument_list|(
name|newRef
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|newRef
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|c1
operator|!=
literal|null
condition|)
block|{
comment|// p1 present, we need to merge into it
name|c1
operator|.
name|add
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p2
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|c2
operator|!=
literal|null
condition|)
block|{
comment|// p2 present, we need to merge into it
name|c2
operator|.
name|add
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// None are present, add to same equivalence class
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|equivalenceClass
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|equivalenceClass
operator|.
name|add
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|equivalenceClass
operator|.
name|add
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p1
argument_list|,
name|equivalenceClass
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p2
argument_list|,
name|equivalenceClass
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|getEquivalenceClassesMap
parameter_list|()
block|{
return|return
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|nodeToEquivalenceClass
argument_list|)
return|;
block|}
specifier|protected
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|getEquivalenceClasses
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodeToEquivalenceClass
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
specifier|static
name|EquivalenceClasses
name|copy
parameter_list|(
name|EquivalenceClasses
name|ec
parameter_list|)
block|{
specifier|final
name|EquivalenceClasses
name|newEc
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|e
range|:
name|ec
operator|.
name|nodeToEquivalenceClass
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newEc
operator|.
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|Sets
operator|.
name|newLinkedHashSet
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newEc
return|;
block|}
block|}
comment|/** Edge for graph */
specifier|private
specifier|static
class|class
name|Edge
extends|extends
name|DefaultEdge
block|{
specifier|public
specifier|static
specifier|final
name|DirectedGraph
operator|.
name|EdgeFactory
argument_list|<
name|RelTableRef
argument_list|,
name|Edge
argument_list|>
name|FACTORY
init|=
operator|new
name|DirectedGraph
operator|.
name|EdgeFactory
argument_list|<
name|RelTableRef
argument_list|,
name|Edge
argument_list|>
argument_list|()
block|{
specifier|public
name|Edge
name|createEdge
parameter_list|(
name|RelTableRef
name|source
parameter_list|,
name|RelTableRef
name|target
parameter_list|)
block|{
return|return
operator|new
name|Edge
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|equiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|public
name|Edge
parameter_list|(
name|RelTableRef
name|source
parameter_list|,
name|RelTableRef
name|target
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Complete, view partial, or query partial. */
specifier|private
enum|enum
name|MatchModality
block|{
name|COMPLETE
block|,
name|VIEW_PARTIAL
block|,
name|QUERY_PARTIAL
block|}
block|}
end_class

begin_comment
comment|// End AbstractMaterializedViewRule.java
end_comment

end_unit

