begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnitRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptMaterialization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPredicateList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleOperand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|SubstitutionVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelReferentialConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexPermuteInputsShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSimplify
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexTableInputRef
operator|.
name|RelTableRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
operator|.
name|AggCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultDirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultEdge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|MappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteLogger
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|BiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashBiMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Planner rule that converts a {@link org.apache.calcite.rel.core.Project}  * followed by {@link org.apache.calcite.rel.core.Aggregate} or an  * {@link org.apache.calcite.rel.core.Aggregate} to a scan (and possibly  * other operations) over a materialized view.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|AbstractMaterializedViewRule
extends|extends
name|RelOptRule
block|{
specifier|private
specifier|static
specifier|final
name|CalciteLogger
name|LOGGER
init|=
operator|new
name|CalciteLogger
argument_list|(
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AbstractMaterializedViewRule
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewProjectFilterRule
name|INSTANCE_PROJECT_FILTER
init|=
operator|new
name|MaterializedViewProjectFilterRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewOnlyFilterRule
name|INSTANCE_FILTER
init|=
operator|new
name|MaterializedViewOnlyFilterRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewProjectJoinRule
name|INSTANCE_PROJECT_JOIN
init|=
operator|new
name|MaterializedViewProjectJoinRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewOnlyJoinRule
name|INSTANCE_JOIN
init|=
operator|new
name|MaterializedViewOnlyJoinRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewProjectAggregateRule
name|INSTANCE_PROJECT_AGGREGATE
init|=
operator|new
name|MaterializedViewProjectAggregateRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|MaterializedViewOnlyAggregateRule
name|INSTANCE_AGGREGATE
init|=
operator|new
name|MaterializedViewOnlyAggregateRule
argument_list|(
name|RelFactories
operator|.
name|LOGICAL_BUILDER
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/** Whether to generate rewritings containing union if the query results    * are contained within the view results. */
specifier|protected
specifier|final
name|boolean
name|generateUnionRewriting
decl_stmt|;
comment|/** If we generate union rewriting, we might want to pull up projections    * from the query itself to maximize rewriting opportunities. */
specifier|protected
specifier|final
name|HepProgram
name|unionRewritingPullProgram
decl_stmt|;
comment|/** Whether we should create the rewriting in the minimal subtree of plan    * operators. */
specifier|protected
specifier|final
name|boolean
name|fastBailOut
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/** Creates a AbstractMaterializedViewRule. */
specifier|protected
name|AbstractMaterializedViewRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|,
name|boolean
name|fastBailOut
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|this
operator|.
name|generateUnionRewriting
operator|=
name|generateUnionRewriting
expr_stmt|;
name|this
operator|.
name|unionRewritingPullProgram
operator|=
name|unionRewritingPullProgram
expr_stmt|;
name|this
operator|.
name|fastBailOut
operator|=
name|fastBailOut
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|matches
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
return|return
operator|!
name|call
operator|.
name|getPlanner
argument_list|()
operator|.
name|getMaterializations
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Rewriting logic is based on "Optimizing Queries Using Materialized Views:    * A Practical, Scalable Solution" by Goldstein and Larson.    *    *<p>On the query side, rules matches a Project-node chain or node, where node    * is either an Aggregate or a Join. Subplan rooted at the node operator must    * be composed of one or more of the following operators: TableScan, Project,    * Filter, and Join.    *    *<p>For each join MV, we need to check the following:    *<ol>    *<li> The plan rooted at the Join operator in the view produces all rows    * needed by the plan rooted at the Join operator in the query.</li>    *<li> All columns required by compensating predicates, i.e., predicates that    * need to be enforced over the view, are available at the view output.</li>    *<li> All output expressions can be computed from the output of the view.</li>    *<li> All output rows occur with the correct duplication factor. We might    * rely on existing Unique-Key - Foreign-Key relationships to extract that    * information.</li>    *</ol>    *    *<p>In turn, for each aggregate MV, we need to check the following:    *<ol>    *<li> The plan rooted at the Aggregate operator in the view produces all rows    * needed by the plan rooted at the Aggregate operator in the query.</li>    *<li> All columns required by compensating predicates, i.e., predicates that    * need to be enforced over the view, are available at the view output.</li>    *<li> The grouping columns in the query are a subset of the grouping columns    * in the view.</li>    *<li> All columns required to perform further grouping are available in the    * view output.</li>    *<li> All columns required to compute output expressions are available in the    * view output.</li>    *</ol>    *    *<p>The rule contains multiple extensions compared to the original paper. One of    * them is the possibility of creating rewritings using Union operators, e.g., if    * the result of a query is partially contained in the materialized view.    */
specifier|protected
name|void
name|perform
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|node
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|RelMetadataQuery
name|mq
init|=
name|call
operator|.
name|getMetadataQuery
argument_list|()
decl_stmt|;
specifier|final
name|RelOptPlanner
name|planner
init|=
name|call
operator|.
name|getPlanner
argument_list|()
decl_stmt|;
specifier|final
name|RexExecutor
name|executor
init|=
name|Util
operator|.
name|first
argument_list|(
name|planner
operator|.
name|getExecutor
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|EXECUTOR
argument_list|)
decl_stmt|;
specifier|final
name|RelOptPredicateList
name|predicates
init|=
name|RelOptPredicateList
operator|.
name|EMPTY
decl_stmt|;
specifier|final
name|RexSimplify
name|simplify
init|=
operator|new
name|RexSimplify
argument_list|(
name|rexBuilder
argument_list|,
name|predicates
argument_list|,
name|executor
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelOptMaterialization
argument_list|>
name|materializations
init|=
name|planner
operator|.
name|getMaterializations
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|materializations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// 1. Explore query plan to recognize whether preconditions to
comment|// try to generate a rewriting are met
if|if
condition|(
operator|!
name|isValidPlan
argument_list|(
name|topProject
argument_list|,
name|node
argument_list|,
name|mq
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// 2. Initialize all query related auxiliary data structures
comment|// that will be used throughout query rewriting process
comment|// Generate query table references
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryTableRefs
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return;
block|}
comment|// Extract query predicates
specifier|final
name|RelOptPredicateList
name|queryPredicateList
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryPredicateList
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return;
block|}
specifier|final
name|RexNode
name|pred
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|queryPredicateList
operator|.
name|pulledUpPredicates
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|queryPreds
init|=
name|splitPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|pred
argument_list|)
decl_stmt|;
comment|// Extract query equivalence classes. An equivalence class is a set
comment|// of columns in the query output that are known to be equal.
specifier|final
name|EquivalenceClasses
name|qEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|queryPreds
operator|.
name|left
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|qEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. We iterate through all applicable materializations trying to
comment|// rewrite the given query
for|for
control|(
name|RelOptMaterialization
name|materialization
range|:
name|materializations
control|)
block|{
name|RelNode
name|view
init|=
name|materialization
operator|.
name|tableRel
decl_stmt|;
name|Project
name|topViewProject
decl_stmt|;
name|RelNode
name|viewNode
decl_stmt|;
if|if
condition|(
name|materialization
operator|.
name|queryRel
operator|instanceof
name|Project
condition|)
block|{
name|topViewProject
operator|=
operator|(
name|Project
operator|)
name|materialization
operator|.
name|queryRel
expr_stmt|;
name|viewNode
operator|=
name|topViewProject
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|topViewProject
operator|=
literal|null
expr_stmt|;
name|viewNode
operator|=
name|materialization
operator|.
name|queryRel
expr_stmt|;
block|}
comment|// Extract view table references
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
init|=
name|mq
operator|.
name|getTableReferences
argument_list|(
name|viewNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewTableRefs
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// Filter relevant materializations. Currently, we only check whether
comment|// the materialization contains any table that is used by the query
comment|// TODO: Filtering of relevant materializations can be improved to be more fine-grained.
name|boolean
name|applicable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tableRef
range|:
name|viewTableRefs
control|)
block|{
if|if
condition|(
name|queryTableRefs
operator|.
name|contains
argument_list|(
name|tableRef
argument_list|)
condition|)
block|{
name|applicable
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|applicable
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// 3.1. View checks before proceeding
if|if
condition|(
operator|!
name|isValidPlan
argument_list|(
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|mq
argument_list|)
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// 3.2. Initialize all query related auxiliary data structures
comment|// that will be used throughout query rewriting process
comment|// Extract view predicates
specifier|final
name|RelOptPredicateList
name|viewPredicateList
init|=
name|mq
operator|.
name|getAllPredicates
argument_list|(
name|viewNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|viewPredicateList
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
specifier|final
name|RexNode
name|viewPred
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|viewPredicateList
operator|.
name|pulledUpPredicates
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|viewPreds
init|=
name|splitPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|viewPred
argument_list|)
decl_stmt|;
comment|// Extract view tables
name|MatchModality
name|matchModality
decl_stmt|;
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|compensationEquiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|queryTableRefs
operator|.
name|equals
argument_list|(
name|viewTableRefs
argument_list|)
condition|)
block|{
comment|// We try to compensate, e.g., for join queries it might be
comment|// possible to join missing tables with view to compute result.
comment|// Two supported cases: query tables are subset of view tables (we need to
comment|// check whether they are cardinality-preserving joins), or view tables are
comment|// subset of query tables (add additional tables through joins if possible)
if|if
condition|(
name|viewTableRefs
operator|.
name|containsAll
argument_list|(
name|queryTableRefs
argument_list|)
condition|)
block|{
name|matchModality
operator|=
name|MatchModality
operator|.
name|QUERY_PARTIAL
expr_stmt|;
specifier|final
name|EquivalenceClasses
name|vEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|viewPreds
operator|.
name|left
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|vEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compensatePartial
argument_list|(
name|viewTableRefs
argument_list|,
name|vEC
argument_list|,
name|queryTableRefs
argument_list|,
name|compensationEquiColumns
argument_list|)
condition|)
block|{
comment|// Cannot rewrite, skip it
continue|continue;
block|}
block|}
if|else if
condition|(
name|queryTableRefs
operator|.
name|containsAll
argument_list|(
name|viewTableRefs
argument_list|)
condition|)
block|{
name|matchModality
operator|=
name|MatchModality
operator|.
name|VIEW_PARTIAL
expr_stmt|;
name|ViewPartialRewriting
name|partialRewritingResult
init|=
name|compensateViewPartial
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|view
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|queryTableRefs
argument_list|,
name|qEC
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|viewTableRefs
argument_list|)
decl_stmt|;
if|if
condition|(
name|partialRewritingResult
operator|==
literal|null
condition|)
block|{
comment|// Cannot rewrite, skip it
continue|continue;
block|}
comment|// Rewrite succeeded
name|view
operator|=
name|partialRewritingResult
operator|.
name|newView
expr_stmt|;
name|topViewProject
operator|=
name|partialRewritingResult
operator|.
name|newTopViewProject
expr_stmt|;
name|viewNode
operator|=
name|partialRewritingResult
operator|.
name|newViewNode
expr_stmt|;
block|}
else|else
block|{
comment|// Skip it
continue|continue;
block|}
block|}
else|else
block|{
name|matchModality
operator|=
name|MatchModality
operator|.
name|COMPLETE
expr_stmt|;
block|}
comment|// 4. We map every table in the query to a table with the same qualified
comment|// name (all query tables are contained in the view, thus this is equivalent
comment|// to mapping every table in the query to a view table).
specifier|final
name|Multimap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|multiMapTables
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|queryTableRef1
range|:
name|queryTableRefs
control|)
block|{
for|for
control|(
name|RelTableRef
name|queryTableRef2
range|:
name|queryTableRefs
control|)
block|{
if|if
condition|(
name|queryTableRef1
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|queryTableRef2
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
name|multiMapTables
operator|.
name|put
argument_list|(
name|queryTableRef1
argument_list|,
name|queryTableRef2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If a table is used multiple times, we will create multiple mappings,
comment|// and we will try to rewrite the query using each of the mappings.
comment|// Then, we will try to map every source table (query) to a target
comment|// table (view), and if we are successful, we will try to create
comment|// compensation predicates to filter the view results further
comment|// (if needed).
specifier|final
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|flatListMappings
init|=
name|generateTableMappings
argument_list|(
name|multiMapTables
argument_list|)
decl_stmt|;
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
range|:
name|flatListMappings
control|)
block|{
comment|// TableMapping : mapping query tables -> view tables
comment|// 4.0. If compensation equivalence classes exist, we need to add
comment|// the mapping to the query mapping
specifier|final
name|EquivalenceClasses
name|currQEC
init|=
name|EquivalenceClasses
operator|.
name|copy
argument_list|(
name|qEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchModality
operator|==
name|MatchModality
operator|.
name|QUERY_PARTIAL
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|e
range|:
name|compensationEquiColumns
operator|.
name|entries
argument_list|()
control|)
block|{
comment|// Copy origin
name|RelTableRef
name|queryTableRef
init|=
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|)
decl_stmt|;
name|RexTableInputRef
name|queryColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|queryTableRef
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
comment|// Add to query equivalence classes and table mapping
name|currQEC
operator|.
name|addEquivalenceClass
argument_list|(
name|queryColumnRef
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|queryToViewTableMapping
operator|.
name|put
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getTableRef
argument_list|()
argument_list|)
expr_stmt|;
comment|// identity
block|}
block|}
comment|// 4.1. Compute compensation predicates, i.e., predicates that need to be
comment|// enforced over the view to retain query semantics. The resulting predicates
comment|// are expressed using {@link RexTableInputRef} over the query.
comment|// First, to establish relationship, we swap column references of the view
comment|// predicates to point to query tables and compute equivalence classes.
specifier|final
name|RexNode
name|viewColumnsEquiPred
init|=
name|RexUtil
operator|.
name|swapTableReferences
argument_list|(
name|rexBuilder
argument_list|,
name|viewPreds
operator|.
name|left
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|EquivalenceClasses
name|queryBasedVEC
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|conj
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|viewColumnsEquiPred
argument_list|)
control|)
block|{
assert|assert
name|conj
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
assert|;
name|RexCall
name|equiCond
init|=
operator|(
name|RexCall
operator|)
name|conj
decl_stmt|;
name|queryBasedVEC
operator|.
name|addEquivalenceClass
argument_list|(
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|RexTableInputRef
operator|)
name|equiCond
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|compensationPreds
init|=
name|computeCompensationPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|currQEC
argument_list|,
name|queryPreds
argument_list|,
name|queryBasedVEC
argument_list|,
name|viewPreds
argument_list|,
name|queryToViewTableMapping
argument_list|)
decl_stmt|;
if|if
condition|(
name|compensationPreds
operator|==
literal|null
operator|&&
name|generateUnionRewriting
condition|)
block|{
comment|// Attempt partial rewriting using union operator. This rewriting
comment|// will read some data from the view and the rest of the data from
comment|// the query computation. The resulting predicates are expressed
comment|// using {@link RexTableInputRef} over the view.
name|compensationPreds
operator|=
name|computeCompensationPredicates
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|queryBasedVEC
argument_list|,
name|viewPreds
argument_list|,
name|currQEC
argument_list|,
name|queryPreds
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationPreds
operator|==
literal|null
condition|)
block|{
comment|// This was our last chance to use the view, skip it
continue|continue;
block|}
name|RexNode
name|compensationColumnsEquiPred
init|=
name|compensationPreds
operator|.
name|left
decl_stmt|;
name|RexNode
name|otherCompensationPred
init|=
name|compensationPreds
operator|.
name|right
decl_stmt|;
assert|assert
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
operator|||
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
assert|;
comment|// b. Generate union branch (query).
specifier|final
name|RelNode
name|unionInputQuery
init|=
name|rewriteQuery
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|mq
argument_list|,
name|compensationColumnsEquiPred
argument_list|,
name|otherCompensationPred
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|queryBasedVEC
argument_list|,
name|currQEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|unionInputQuery
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// c. Generate union branch (view).
comment|// We trigger the unifying method. This method will either create a Project
comment|// or an Aggregate operator on top of the view. It will also compute the
comment|// output expressions for the query.
specifier|final
name|RelNode
name|unionInputView
init|=
name|rewriteView
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|mq
argument_list|,
name|matchModality
argument_list|,
literal|true
argument_list|,
name|view
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|currQEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|unionInputView
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
comment|// d. Generate final rewriting (union).
specifier|final
name|RelNode
name|result
init|=
name|createUnion
argument_list|(
name|call
operator|.
name|builder
argument_list|()
argument_list|,
name|rexBuilder
argument_list|,
name|topProject
argument_list|,
name|unionInputQuery
argument_list|,
name|unionInputView
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|compensationPreds
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|compensationColumnsEquiPred
init|=
name|compensationPreds
operator|.
name|left
decl_stmt|;
name|RexNode
name|otherCompensationPred
init|=
name|compensationPreds
operator|.
name|right
decl_stmt|;
comment|// a. Compute final compensation predicate.
if|if
condition|(
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
operator|||
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
comment|// All columns required by compensating predicates must be contained
comment|// in the view output (condition 2).
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
init|=
name|topViewProject
operator|==
literal|null
condition|?
name|extractReferences
argument_list|(
name|rexBuilder
argument_list|,
name|view
argument_list|)
else|:
name|topViewProject
operator|.
name|getChildExps
argument_list|()
decl_stmt|;
comment|// For compensationColumnsEquiPred, we use the view equivalence classes,
comment|// since we want to enforce the rest
if|if
condition|(
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|compensationColumnsEquiPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|view
argument_list|,
name|viewNode
argument_list|,
name|viewExprs
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|queryBasedVEC
argument_list|,
literal|false
argument_list|,
name|compensationColumnsEquiPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationColumnsEquiPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
block|}
comment|// For the rest, we use the query equivalence classes
if|if
condition|(
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|otherCompensationPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|view
argument_list|,
name|viewNode
argument_list|,
name|viewExprs
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|currQEC
argument_list|,
literal|true
argument_list|,
name|otherCompensationPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherCompensationPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
block|}
block|}
specifier|final
name|RexNode
name|viewCompensationPred
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|compensationColumnsEquiPred
argument_list|,
name|otherCompensationPred
argument_list|)
argument_list|)
decl_stmt|;
comment|// b. Generate final rewriting if possible.
comment|// First, we add the compensation predicate (if any) on top of the view.
comment|// Then, we trigger the unifying method. This method will either create a
comment|// Project or an Aggregate operator on top of the view. It will also compute
comment|// the output expressions for the query.
name|RelBuilder
name|builder
init|=
name|call
operator|.
name|builder
argument_list|()
operator|.
name|transform
argument_list|(
name|c
lambda|->
name|c
operator|.
name|withPruneInputOfAggregate
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|RelNode
name|viewWithFilter
decl_stmt|;
if|if
condition|(
operator|!
name|viewCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|RexNode
name|newPred
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|viewCompensationPred
argument_list|)
decl_stmt|;
name|viewWithFilter
operator|=
name|builder
operator|.
name|push
argument_list|(
name|view
argument_list|)
operator|.
name|filter
argument_list|(
name|newPred
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// No need to do anything if it's a leaf node.
if|if
condition|(
name|viewWithFilter
operator|.
name|getInputs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|call
operator|.
name|transformTo
argument_list|(
name|viewWithFilter
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// We add (and push) the filter to the view plan before triggering the rewriting.
comment|// This is useful in case some of the columns can be folded to same value after
comment|// filter is added.
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|pushedNodes
init|=
name|pushFilterToOriginalViewPlan
argument_list|(
name|builder
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|newPred
argument_list|)
decl_stmt|;
name|topViewProject
operator|=
operator|(
name|Project
operator|)
name|pushedNodes
operator|.
name|left
expr_stmt|;
name|viewNode
operator|=
name|pushedNodes
operator|.
name|right
expr_stmt|;
block|}
else|else
block|{
name|viewWithFilter
operator|=
name|builder
operator|.
name|push
argument_list|(
name|view
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RelNode
name|result
init|=
name|rewriteView
argument_list|(
name|builder
argument_list|,
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|mq
argument_list|,
name|matchModality
argument_list|,
literal|false
argument_list|,
name|viewWithFilter
argument_list|,
name|topProject
argument_list|,
name|node
argument_list|,
name|topViewProject
argument_list|,
name|viewNode
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|currQEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
comment|// Skip it
continue|continue;
block|}
name|call
operator|.
name|transformTo
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
comment|// end else
block|}
block|}
block|}
block|}
specifier|protected
specifier|abstract
name|boolean
name|isValidPlan
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
function_decl|;
comment|/**    * It checks whether the query can be rewritten using the view even though the    * query uses additional tables.    *    *<p>Rules implementing the method should follow different approaches depending on the    * operators they rewrite.    */
specifier|protected
specifier|abstract
name|ViewPartialRewriting
name|compensateViewPartial
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
parameter_list|)
function_decl|;
comment|/**    * If the view will be used in a union rewriting, this method is responsible for    * rewriting the query branch of the union using the given compensation predicate.    *    *<p>If a rewriting can be produced, we return that rewriting. If it cannot    * be produced, we will return null.    */
specifier|protected
specifier|abstract
name|RelNode
name|rewriteQuery
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|compensationColumnsEquiPred
parameter_list|,
name|RexNode
name|otherCompensationPred
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|viewToQueryTableMapping
parameter_list|,
name|EquivalenceClasses
name|viewEC
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
function_decl|;
comment|/**    * If the view will be used in a union rewriting, this method is responsible for    * generating the union and any other operator needed on top of it, e.g., a Project    * operator.    */
specifier|protected
specifier|abstract
name|RelNode
name|createUnion
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|topProject
parameter_list|,
name|RelNode
name|unionInputQuery
parameter_list|,
name|RelNode
name|unionInputView
parameter_list|)
function_decl|;
comment|/**    * Rewrites the query using the given view query.    *    *<p>The input node is a Scan on the view table and possibly a compensation Filter    * on top. If a rewriting can be produced, we return that rewriting. If it cannot    * be produced, we will return null.    */
specifier|protected
specifier|abstract
name|RelNode
name|rewriteView
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|MatchModality
name|matchModality
parameter_list|,
name|boolean
name|unionRewriting
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
function_decl|;
comment|/**    * Once we create a compensation predicate, this method is responsible for pushing    * the resulting filter through the view nodes. This might be useful for rewritings    * containing Aggregate operators, as some of the grouping columns might be removed,    * which results in additional matching possibilities.    *    *<p>The method will return a pair of nodes: the new top project on the left and    * the new node on the right.    */
specifier|protected
specifier|abstract
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|pushFilterToOriginalViewPlan
parameter_list|(
name|RelBuilder
name|builder
parameter_list|,
name|RelNode
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|RexNode
name|cond
parameter_list|)
function_decl|;
comment|//~ Instances Join ---------------------------------------------------------
comment|/** Materialized view rewriting for join */
specifier|private
specifier|abstract
specifier|static
class|class
name|MaterializedViewJoinRule
extends|extends
name|AbstractMaterializedViewRule
block|{
comment|/** Creates a MaterializedViewJoinRule. */
specifier|protected
name|MaterializedViewJoinRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|,
name|boolean
name|fastBailOut
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|,
name|fastBailOut
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isValidPlan
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
return|return
name|isValidRelNodePlan
argument_list|(
name|node
argument_list|,
name|mq
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|ViewPartialRewriting
name|compensateViewPartial
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
parameter_list|)
block|{
comment|// We only create the rewriting in the minimal subtree of plan operators.
comment|// Otherwise we will produce many EQUAL rewritings at different levels of
comment|// the plan.
comment|// View: (A JOIN B) JOIN C
comment|// Query: (((A JOIN B) JOIN D) JOIN C) JOIN E
comment|// We produce it at:
comment|// ((A JOIN B) JOIN D) JOIN C
comment|// But not at:
comment|// (((A JOIN B) JOIN D) JOIN C) JOIN E
if|if
condition|(
name|fastBailOut
condition|)
block|{
for|for
control|(
name|RelNode
name|joinInput
range|:
name|node
operator|.
name|getInputs
argument_list|()
control|)
block|{
if|if
condition|(
name|mq
operator|.
name|getTableReferences
argument_list|(
name|joinInput
argument_list|)
operator|.
name|containsAll
argument_list|(
name|viewTableRefs
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
comment|// Extract tables that are in the query and not in the view
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|extraTableRefs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|queryTableRefs
control|)
block|{
if|if
condition|(
operator|!
name|viewTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// Add to extra tables if table is not part of the view
name|extraTableRefs
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Rewrite the view and the view plan. We only need to add the missing
comment|// tables on top of the view and view plan using a cartesian product.
comment|// Then the rest of the rewriting algorithm can be executed in the same
comment|// fashion, and if there are predicates between the existing and missing
comment|// tables, the rewriting algorithm will enforce them.
name|Collection
argument_list|<
name|RelNode
argument_list|>
name|tableScanNodes
init|=
name|mq
operator|.
name|getNodeTypes
argument_list|(
name|node
argument_list|)
operator|.
name|get
argument_list|(
name|TableScan
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|extraTableRefs
control|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|relNode
range|:
name|tableScanNodes
control|)
block|{
if|if
condition|(
name|tRef
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|relNode
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|tRef
operator|.
name|getEntityNumber
argument_list|()
operator|==
name|i
operator|++
condition|)
block|{
name|newRels
operator|.
name|add
argument_list|(
name|relNode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
assert|assert
name|extraTableRefs
operator|.
name|size
argument_list|()
operator|==
name|newRels
operator|.
name|size
argument_list|()
assert|;
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|newRel
range|:
name|newRels
control|)
block|{
comment|// Add to the view
name|relBuilder
operator|.
name|push
argument_list|(
name|newRel
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|newView
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|topViewProject
operator|!=
literal|null
condition|?
name|topViewProject
else|:
name|viewNode
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|newRel
range|:
name|newRels
control|)
block|{
comment|// Add to the view plan
name|relBuilder
operator|.
name|push
argument_list|(
name|newRel
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|newViewNode
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|ViewPartialRewriting
operator|.
name|of
argument_list|(
name|newView
argument_list|,
literal|null
argument_list|,
name|newViewNode
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|rewriteQuery
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|compensationColumnsEquiPred
parameter_list|,
name|RexNode
name|otherCompensationPred
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|viewToQueryTableMapping
parameter_list|,
name|EquivalenceClasses
name|viewEC
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
block|{
comment|// Our target node is the node below the root, which should have the maximum
comment|// number of available expressions in the tree in order to maximize our
comment|// number of rewritings.
comment|// We create a project on top. If the program is available, we execute
comment|// it to maximize rewriting opportunities. For instance, a program might
comment|// pull up all the expressions that are below the aggregate so we can
comment|// introduce compensation filters easily. This is important depending on
comment|// the planner strategy.
name|RelNode
name|newNode
init|=
name|node
decl_stmt|;
name|RelNode
name|target
init|=
name|node
decl_stmt|;
if|if
condition|(
name|unionRewritingPullProgram
operator|!=
literal|null
condition|)
block|{
specifier|final
name|HepPlanner
name|tmpPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|unionRewritingPullProgram
argument_list|)
decl_stmt|;
name|tmpPlanner
operator|.
name|setRoot
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
name|newNode
operator|=
name|tmpPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
name|target
operator|=
name|newNode
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// All columns required by compensating predicates must be contained
comment|// in the query.
name|List
argument_list|<
name|RexNode
argument_list|>
name|queryExprs
init|=
name|extractReferences
argument_list|(
name|rexBuilder
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|compensationColumnsEquiPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|queryExprs
argument_list|,
name|viewToQueryTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|queryEC
argument_list|,
literal|false
argument_list|,
name|compensationColumnsEquiPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationColumnsEquiPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
return|return
literal|null
return|;
block|}
block|}
comment|// For the rest, we use the query equivalence classes
if|if
condition|(
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|otherCompensationPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|queryExprs
argument_list|,
name|viewToQueryTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|viewEC
argument_list|,
literal|true
argument_list|,
name|otherCompensationPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherCompensationPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|RexNode
name|queryCompensationPred
init|=
name|RexUtil
operator|.
name|not
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|compensationColumnsEquiPred
argument_list|,
name|otherCompensationPred
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Generate query rewriting.
name|RelNode
name|rewrittenPlan
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|target
argument_list|)
operator|.
name|filter
argument_list|(
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|queryCompensationPred
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|unionRewritingPullProgram
operator|!=
literal|null
condition|)
block|{
name|rewrittenPlan
operator|=
name|newNode
operator|.
name|copy
argument_list|(
name|newNode
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rewrittenPlan
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|topProject
operator|!=
literal|null
condition|)
block|{
return|return
name|topProject
operator|.
name|copy
argument_list|(
name|topProject
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rewrittenPlan
argument_list|)
argument_list|)
return|;
block|}
return|return
name|rewrittenPlan
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|createUnion
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|topProject
parameter_list|,
name|RelNode
name|unionInputQuery
parameter_list|,
name|RelNode
name|unionInputView
parameter_list|)
block|{
name|relBuilder
operator|.
name|push
argument_list|(
name|unionInputQuery
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|unionInputView
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|union
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// We can take unionInputQuery as it is query based.
name|RelDataTypeField
name|field
init|=
name|unionInputQuery
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|nameList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|project
argument_list|(
name|exprList
argument_list|,
name|nameList
argument_list|)
expr_stmt|;
return|return
name|relBuilder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|rewriteView
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|MatchModality
name|matchModality
parameter_list|,
name|boolean
name|unionRewriting
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|topProject
operator|==
literal|null
condition|?
name|extractReferences
argument_list|(
name|rexBuilder
argument_list|,
name|node
argument_list|)
else|:
name|topProject
operator|.
name|getChildExps
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprsLineage
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|exprs
control|)
block|{
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
assert|assert
name|s
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
comment|// Rewrite expr. Take first element from the corresponding equivalence class
comment|// (no need to swap the table references following the table mapping)
name|exprsLineage
operator|.
name|add
argument_list|(
name|RexUtil
operator|.
name|swapColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|queryEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|viewExprs
init|=
name|topViewProject
operator|==
literal|null
condition|?
name|extractReferences
argument_list|(
name|rexBuilder
argument_list|,
name|viewNode
argument_list|)
else|:
name|topViewProject
operator|.
name|getChildExps
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
name|rewriteExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|input
argument_list|,
name|viewNode
argument_list|,
name|viewExprs
argument_list|,
name|queryToViewTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|queryEC
argument_list|,
literal|true
argument_list|,
name|exprsLineage
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenExprs
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
operator|.
name|project
argument_list|(
name|rewrittenExprs
argument_list|)
operator|.
name|convert
argument_list|(
name|topProject
operator|!=
literal|null
condition|?
name|topProject
operator|.
name|getRowType
argument_list|()
else|:
name|node
operator|.
name|getRowType
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|pushFilterToOriginalViewPlan
parameter_list|(
name|RelBuilder
name|builder
parameter_list|,
name|RelNode
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|RexNode
name|cond
parameter_list|)
block|{
comment|// Nothing to do
return|return
name|Pair
operator|.
name|of
argument_list|(
name|topViewProject
argument_list|,
name|viewNode
argument_list|)
return|;
block|}
block|}
comment|/** Rule that matches Project on Join. */
specifier|public
specifier|static
class|class
name|MaterializedViewProjectJoinRule
extends|extends
name|MaterializedViewJoinRule
block|{
specifier|public
name|MaterializedViewProjectJoinRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|,
name|boolean
name|fastBailOut
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewJoinRule(Project-Join)"
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|,
name|fastBailOut
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Join
name|join
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|join
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that matches Project on Filter. */
specifier|public
specifier|static
class|class
name|MaterializedViewProjectFilterRule
extends|extends
name|MaterializedViewJoinRule
block|{
specifier|public
name|MaterializedViewProjectFilterRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|,
name|boolean
name|fastBailOut
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewJoinRule(Project-Filter)"
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|,
name|fastBailOut
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that matches Join. */
specifier|public
specifier|static
class|class
name|MaterializedViewOnlyJoinRule
extends|extends
name|MaterializedViewJoinRule
block|{
specifier|public
name|MaterializedViewOnlyJoinRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|,
name|boolean
name|fastBailOut
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Join
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewJoinRule(Join)"
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|,
name|fastBailOut
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Join
name|join
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
name|join
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that matches Filter. */
specifier|public
specifier|static
class|class
name|MaterializedViewOnlyFilterRule
extends|extends
name|MaterializedViewJoinRule
block|{
specifier|public
name|MaterializedViewOnlyFilterRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|,
name|boolean
name|fastBailOut
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewJoinRule(Filter)"
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|,
name|fastBailOut
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Filter
name|filter
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Instances Aggregate ----------------------------------------------------
comment|/** Materialized view rewriting for aggregate */
specifier|private
specifier|abstract
specifier|static
class|class
name|MaterializedViewAggregateRule
extends|extends
name|AbstractMaterializedViewRule
block|{
specifier|private
specifier|static
specifier|final
name|ImmutableList
argument_list|<
name|TimeUnitRange
argument_list|>
name|SUPPORTED_DATE_TIME_ROLLUP_UNITS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|,
name|TimeUnitRange
operator|.
name|QUARTER
argument_list|,
name|TimeUnitRange
operator|.
name|MONTH
argument_list|,
name|TimeUnitRange
operator|.
name|DAY
argument_list|,
name|TimeUnitRange
operator|.
name|HOUR
argument_list|,
name|TimeUnitRange
operator|.
name|MINUTE
argument_list|,
name|TimeUnitRange
operator|.
name|SECOND
argument_list|,
name|TimeUnitRange
operator|.
name|MILLISECOND
argument_list|,
name|TimeUnitRange
operator|.
name|MICROSECOND
argument_list|)
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/** Instance of rule to push filter through project. */
specifier|protected
specifier|final
name|RelOptRule
name|filterProjectTransposeRule
decl_stmt|;
comment|/** Instance of rule to push filter through aggregate. */
specifier|protected
specifier|final
name|RelOptRule
name|filterAggregateTransposeRule
decl_stmt|;
comment|/** Instance of rule to pull up constants into aggregate. */
specifier|protected
specifier|final
name|RelOptRule
name|aggregateProjectPullUpConstantsRule
decl_stmt|;
comment|/** Instance of rule to merge project operators. */
specifier|protected
specifier|final
name|RelOptRule
name|projectMergeRule
decl_stmt|;
comment|/** Creates a MaterializedViewAggregateRule. */
specifier|protected
name|MaterializedViewAggregateRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|String
name|description
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|relBuilderFactory
argument_list|,
name|description
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|filterProjectTransposeRule
operator|=
operator|new
name|FilterProjectTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|Project
operator|.
name|class
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|relBuilderFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|filterAggregateTransposeRule
operator|=
operator|new
name|FilterAggregateTransposeRule
argument_list|(
name|Filter
operator|.
name|class
argument_list|,
name|relBuilderFactory
argument_list|,
name|Aggregate
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|aggregateProjectPullUpConstantsRule
operator|=
operator|new
name|AggregateProjectPullUpConstantsRule
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|Filter
operator|.
name|class
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"AggFilterPullUpConstants"
argument_list|)
expr_stmt|;
name|this
operator|.
name|projectMergeRule
operator|=
operator|new
name|ProjectMergeRule
argument_list|(
literal|true
argument_list|,
name|ProjectMergeRule
operator|.
name|DEFAULT_BLOAT
argument_list|,
name|relBuilderFactory
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isValidPlan
parameter_list|(
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|Aggregate
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|aggregate
operator|.
name|getGroupType
argument_list|()
operator|!=
name|Aggregate
operator|.
name|Group
operator|.
name|SIMPLE
condition|)
block|{
comment|// TODO: Rewriting with grouping sets not supported yet
return|return
literal|false
return|;
block|}
return|return
name|isValidRelNodePlan
argument_list|(
name|aggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|mq
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|ViewPartialRewriting
name|compensateViewPartial
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|queryTableRefs
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|viewTableRefs
parameter_list|)
block|{
comment|// Modify view to join with missing tables and add Project on top to reorder columns.
comment|// In turn, modify view plan to join with missing tables before Aggregate operator,
comment|// change Aggregate operator to group by previous grouping columns and columns in
comment|// attached tables, and add a final Project on top.
comment|// We only need to add the missing tables on top of the view and view plan using
comment|// a cartesian product.
comment|// Then the rest of the rewriting algorithm can be executed in the same
comment|// fashion, and if there are predicates between the existing and missing
comment|// tables, the rewriting algorithm will enforce them.
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|extraTableRefs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|queryTableRefs
control|)
block|{
if|if
condition|(
operator|!
name|viewTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// Add to extra tables if table is not part of the view
name|extraTableRefs
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
block|}
block|}
name|Collection
argument_list|<
name|RelNode
argument_list|>
name|tableScanNodes
init|=
name|mq
operator|.
name|getNodeTypes
argument_list|(
name|node
argument_list|)
operator|.
name|get
argument_list|(
name|TableScan
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newRels
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|extraTableRefs
control|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|relNode
range|:
name|tableScanNodes
control|)
block|{
if|if
condition|(
name|tRef
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|relNode
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|tRef
operator|.
name|getEntityNumber
argument_list|()
operator|==
name|i
operator|++
condition|)
block|{
name|newRels
operator|.
name|add
argument_list|(
name|relNode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
assert|assert
name|extraTableRefs
operator|.
name|size
argument_list|()
operator|==
name|newRels
operator|.
name|size
argument_list|()
assert|;
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
expr_stmt|;
for|for
control|(
name|RelNode
name|newRel
range|:
name|newRels
control|)
block|{
comment|// Add to the view
name|relBuilder
operator|.
name|push
argument_list|(
name|newRel
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|newView
init|=
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Aggregate
name|aggregateViewNode
init|=
operator|(
name|Aggregate
operator|)
name|viewNode
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|aggregateViewNode
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|newRel
range|:
name|newRels
control|)
block|{
comment|// Add to the view plan
name|relBuilder
operator|.
name|push
argument_list|(
name|newRel
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|join
argument_list|(
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|newRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
comment|// Modify aggregate: add grouping columns
name|ImmutableBitSet
operator|.
name|Builder
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|groupSet
operator|.
name|addAll
argument_list|(
name|aggregateViewNode
operator|.
name|getGroupSet
argument_list|()
argument_list|)
expr_stmt|;
name|groupSet
operator|.
name|addAll
argument_list|(
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|aggregateViewNode
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|aggregateViewNode
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|Aggregate
name|newViewNode
init|=
name|aggregateViewNode
operator|.
name|copy
argument_list|(
name|aggregateViewNode
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|relBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|groupSet
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|,
name|aggregateViewNode
operator|.
name|getAggCallList
argument_list|()
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|newViewNode
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|topViewProject
operator|!=
literal|null
condition|)
block|{
comment|// Insert existing expressions (and shift aggregation arguments),
comment|// then append rest of columns
name|Mappings
operator|.
name|TargetMapping
name|shiftMapping
init|=
name|Mappings
operator|.
name|createShiftMapping
argument_list|(
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|aggregateViewNode
operator|.
name|getGroupCount
argument_list|()
argument_list|,
name|newViewNode
operator|.
name|getGroupCount
argument_list|()
argument_list|,
name|aggregateViewNode
operator|.
name|getGroupCount
argument_list|()
argument_list|,
name|aggregateViewNode
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
operator|new
name|RexPermuteInputsShuttle
argument_list|(
name|shiftMapping
argument_list|,
name|newViewNode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|topViewProject
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|aggregateViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
init|;
name|i
operator|<
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|i
operator|-
name|aggregateViewNode
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newViewNode
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Original grouping columns, aggregation columns, then new grouping columns
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|aggregateViewNode
operator|.
name|getGroupCount
argument_list|()
condition|)
block|{
name|idx
operator|=
name|i
expr_stmt|;
block|}
if|else if
condition|(
name|i
operator|<
name|aggregateViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
name|idx
operator|=
name|i
operator|+
name|offset
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|i
operator|-
name|aggregateViewNode
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newViewNode
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|fieldNames
operator|.
name|add
argument_list|(
name|newViewNode
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|relBuilder
operator|.
name|project
argument_list|(
name|nodes
argument_list|,
name|fieldNames
argument_list|,
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|Project
name|newTopViewProject
init|=
operator|(
name|Project
operator|)
name|relBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|ViewPartialRewriting
operator|.
name|of
argument_list|(
name|newView
argument_list|,
name|newTopViewProject
argument_list|,
name|newViewNode
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|rewriteQuery
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RexNode
name|compensationColumnsEquiPred
parameter_list|,
name|RexNode
name|otherCompensationPred
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
parameter_list|,
name|EquivalenceClasses
name|viewEC
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
block|{
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
comment|// Our target node is the node below the root, which should have the maximum
comment|// number of available expressions in the tree in order to maximize our
comment|// number of rewritings.
comment|// If the program is available, we execute it to maximize rewriting opportunities.
comment|// For instance, a program might pull up all the expressions that are below the
comment|// aggregate so we can introduce compensation filters easily. This is important
comment|// depending on the planner strategy.
name|RelNode
name|newAggregateInput
init|=
name|aggregate
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|target
init|=
name|aggregate
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|unionRewritingPullProgram
operator|!=
literal|null
condition|)
block|{
specifier|final
name|HepPlanner
name|tmpPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|unionRewritingPullProgram
argument_list|)
decl_stmt|;
name|tmpPlanner
operator|.
name|setRoot
argument_list|(
name|newAggregateInput
argument_list|)
expr_stmt|;
name|newAggregateInput
operator|=
name|tmpPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
name|target
operator|=
name|newAggregateInput
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// We need to check that all columns required by compensating predicates
comment|// are contained in the query.
name|List
argument_list|<
name|RexNode
argument_list|>
name|queryExprs
init|=
name|extractReferences
argument_list|(
name|rexBuilder
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|compensationColumnsEquiPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|compensationColumnsEquiPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|queryExprs
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|queryEC
argument_list|,
literal|false
argument_list|,
name|compensationColumnsEquiPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationColumnsEquiPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
return|return
literal|null
return|;
block|}
block|}
comment|// For the rest, we use the query equivalence classes
if|if
condition|(
operator|!
name|otherCompensationPred
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
name|otherCompensationPred
operator|=
name|rewriteExpression
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|queryExprs
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|viewEC
argument_list|,
literal|true
argument_list|,
name|otherCompensationPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherCompensationPred
operator|==
literal|null
condition|)
block|{
comment|// Skip it
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|RexNode
name|queryCompensationPred
init|=
name|RexUtil
operator|.
name|not
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|compensationColumnsEquiPred
argument_list|,
name|otherCompensationPred
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Generate query rewriting.
name|RelNode
name|rewrittenPlan
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|target
argument_list|)
operator|.
name|filter
argument_list|(
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|queryCompensationPred
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|unionRewritingPullProgram
operator|!=
literal|null
condition|)
block|{
return|return
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|newAggregateInput
operator|.
name|copy
argument_list|(
name|newAggregateInput
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rewrittenPlan
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
return|return
name|aggregate
operator|.
name|copy
argument_list|(
name|aggregate
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|rewrittenPlan
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|createUnion
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|topProject
parameter_list|,
name|RelNode
name|unionInputQuery
parameter_list|,
name|RelNode
name|unionInputView
parameter_list|)
block|{
comment|// Union
name|relBuilder
operator|.
name|push
argument_list|(
name|unionInputQuery
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|unionInputView
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|union
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relBuilder
operator|.
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// We can take unionInputQuery as it is query based.
name|RelDataTypeField
name|field
init|=
name|unionInputQuery
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|ensureType
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|nameList
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|relBuilder
operator|.
name|project
argument_list|(
name|exprList
argument_list|,
name|nameList
argument_list|)
expr_stmt|;
comment|// Rollup aggregate
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|unionInputQuery
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|aggregate
operator|.
name|getGroupCount
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|AggregateCall
name|aggCall
init|=
name|aggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
comment|// Cannot ROLLUP distinct
return|return
literal|null
return|;
block|}
name|SqlAggFunction
name|rollupAgg
init|=
name|getRollup
argument_list|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rollupAgg
operator|==
literal|null
condition|)
block|{
comment|// Cannot rollup this aggregate, bail out
return|return
literal|null
return|;
block|}
specifier|final
name|RexInputRef
name|operand
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|relBuilder
operator|.
name|peek
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
decl_stmt|;
name|aggregateCalls
operator|.
name|add
argument_list|(
comment|// TODO: handle aggregate ordering
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|rollupAgg
argument_list|,
name|operand
argument_list|)
operator|.
name|distinct
argument_list|(
name|aggCall
operator|.
name|isDistinct
argument_list|()
argument_list|)
operator|.
name|approximate
argument_list|(
name|aggCall
operator|.
name|isApproximate
argument_list|()
argument_list|)
operator|.
name|as
argument_list|(
name|aggCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|prevNode
init|=
name|relBuilder
operator|.
name|peek
argument_list|()
decl_stmt|;
name|RelNode
name|result
init|=
name|relBuilder
operator|.
name|aggregate
argument_list|(
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|groupSet
argument_list|)
argument_list|,
name|aggregateCalls
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevNode
operator|==
name|result
operator|&&
name|groupSet
operator|.
name|cardinality
argument_list|()
operator|!=
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// Aggregate was not inserted but we need to prune columns
name|result
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|(
name|groupSet
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|topProject
operator|!=
literal|null
condition|)
block|{
comment|// Top project
return|return
name|topProject
operator|.
name|copy
argument_list|(
name|topProject
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
block|}
comment|// Result
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|rewriteView
parameter_list|(
name|RelBuilder
name|relBuilder
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|MatchModality
name|matchModality
parameter_list|,
name|boolean
name|unionRewriting
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|Project
name|topProject
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|Project
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|queryToViewTableMapping
parameter_list|,
name|EquivalenceClasses
name|queryEC
parameter_list|)
block|{
specifier|final
name|Aggregate
name|queryAggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
specifier|final
name|Aggregate
name|viewAggregate
init|=
operator|(
name|Aggregate
operator|)
name|viewNode
decl_stmt|;
comment|// Get group by references and aggregate call input references needed
name|ImmutableBitSet
operator|.
name|Builder
name|indexes
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
name|ImmutableBitSet
name|references
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|topProject
operator|!=
literal|null
operator|&&
operator|!
name|unionRewriting
condition|)
block|{
comment|// We have a Project on top, gather only what is needed
specifier|final
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|topProject
operator|.
name|getChildExps
argument_list|()
control|)
block|{
name|e
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
block|}
name|references
operator|=
name|inputFinder
operator|.
name|inputBitSet
operator|.
name|build
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|inputIdx
range|:
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|inputIdx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// No project on top, all of them are needed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggregateCall
name|queryAggCall
range|:
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
for|for
control|(
name|int
name|inputIdx
range|:
name|queryAggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|indexes
operator|.
name|set
argument_list|(
name|inputIdx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Create mapping from query columns to view columns
name|List
argument_list|<
name|RexNode
argument_list|>
name|rollupNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|m
init|=
name|generateMapping
argument_list|(
name|rexBuilder
argument_list|,
name|simplify
argument_list|,
name|mq
argument_list|,
name|queryAggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|viewAggregate
operator|.
name|getInput
argument_list|()
argument_list|,
name|indexes
operator|.
name|build
argument_list|()
argument_list|,
name|queryToViewTableMapping
argument_list|,
name|queryEC
argument_list|,
name|rollupNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// We could map all expressions. Create aggregate mapping.
name|int
name|viewAggregateAdditionalFieldCount
init|=
name|rollupNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|viewInputFieldCount
init|=
name|viewAggregate
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|viewInputDifferenceViewFieldCount
init|=
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|-
name|viewInputFieldCount
decl_stmt|;
name|int
name|viewAggregateTotalFieldCount
init|=
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|rollupNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|forceRollup
init|=
literal|false
decl_stmt|;
name|Mapping
name|aggregateMapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|FUNCTION
argument_list|,
name|queryAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|viewAggregateTotalFieldCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|m
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|nth
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
range|:
name|c
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|viewAggregate
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// This is one of the rollup columns
name|aggregateMapping
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|j
operator|+
name|viewInputDifferenceViewFieldCount
argument_list|)
expr_stmt|;
name|forceRollup
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|int
name|targetIdx
init|=
name|viewAggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|indexOf
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
name|aggregateMapping
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|targetIdx
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// It is not part of group by, we bail out
return|return
literal|null
return|;
block|}
block|}
name|boolean
name|containsDistinctAgg
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|!=
literal|null
operator|&&
operator|!
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|idx
argument_list|)
condition|)
block|{
comment|// Ignore
continue|continue;
block|}
name|AggregateCall
name|queryAggCall
init|=
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryAggCall
operator|.
name|filterArg
operator|>=
literal|0
condition|)
block|{
comment|// Not supported currently
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|queryAggCallIndexes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|aggCallIdx
range|:
name|queryAggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|queryAggCallIndexes
operator|.
name|add
argument_list|(
name|m
operator|.
name|get
argument_list|(
name|aggCallIdx
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|viewAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|AggregateCall
name|viewAggCall
init|=
name|viewAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryAggCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getKind
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getKind
argument_list|()
operator|||
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|isDistinct
argument_list|()
operator|||
name|queryAggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getArgList
argument_list|()
operator|.
name|size
argument_list|()
operator|||
name|queryAggCall
operator|.
name|getType
argument_list|()
operator|!=
name|viewAggCall
operator|.
name|getType
argument_list|()
operator|||
name|viewAggCall
operator|.
name|filterArg
operator|>=
literal|0
condition|)
block|{
comment|// Continue
continue|continue;
block|}
if|if
condition|(
operator|!
name|queryAggCallIndexes
operator|.
name|equals
argument_list|(
name|viewAggCall
operator|.
name|getArgList
argument_list|()
argument_list|)
condition|)
block|{
comment|// Continue
continue|continue;
block|}
name|aggregateMapping
operator|.
name|set
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|idx
argument_list|,
name|viewAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|containsDistinctAgg
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|// If we reach here, to simplify things, we create an identity topViewProject
comment|// if not present
if|if
condition|(
name|topViewProject
operator|==
literal|null
condition|)
block|{
name|topViewProject
operator|=
operator|(
name|Project
operator|)
name|relBuilder
operator|.
name|push
argument_list|(
name|viewNode
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// Generate result rewriting
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|additionalViewExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Mapping
name|rewritingMapping
init|=
literal|null
decl_stmt|;
name|RelNode
name|result
init|=
name|relBuilder
operator|.
name|push
argument_list|(
name|input
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// We create view expressions that will be used in a Project on top of the
comment|// view in case we need to rollup the expression
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|inputViewExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|inputViewExprs
operator|.
name|addAll
argument_list|(
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|fields
argument_list|()
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|forceRollup
operator|||
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|!=
name|viewAggregate
operator|.
name|getGroupCount
argument_list|()
operator|||
name|matchModality
operator|==
name|MatchModality
operator|.
name|VIEW_PARTIAL
condition|)
block|{
if|if
condition|(
name|containsDistinctAgg
condition|)
block|{
comment|// Cannot rollup DISTINCT aggregate
return|return
literal|null
return|;
block|}
comment|// Target is coarser level of aggregation. Generate an aggregate.
name|rewritingMapping
operator|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|FUNCTION
argument_list|,
name|topViewProject
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|viewAggregateAdditionalFieldCount
argument_list|,
name|queryAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableBitSet
operator|.
name|Builder
name|groupSetB
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|targetIdx
init|=
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No matching group by column, we bail out
return|return
literal|null
return|;
block|}
name|boolean
name|added
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|>=
name|viewAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
name|RexNode
name|targetNode
init|=
name|rollupNodes
operator|.
name|get
argument_list|(
name|targetIdx
operator|-
name|viewInputFieldCount
operator|-
name|viewInputDifferenceViewFieldCount
argument_list|)
decl_stmt|;
comment|// We need to rollup this expression
specifier|final
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|refs
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|targetNode
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|childTargetIdx
range|:
name|refs
control|)
block|{
name|added
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|added
condition|;
name|k
operator|++
control|)
block|{
name|RexNode
name|n
init|=
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|INPUT_REF
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|final
name|int
name|ref
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|n
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|childTargetIdx
condition|)
block|{
name|exprsLineage
operator|.
name|put
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|ref
argument_list|,
name|targetNode
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
comment|// No matching column needed for computed expression, bail out
return|return
literal|null
return|;
block|}
block|}
comment|// We create the new node pointing to the index
name|groupSetB
operator|.
name|set
argument_list|(
name|inputViewExprs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|rewritingMapping
operator|.
name|set
argument_list|(
name|inputViewExprs
operator|.
name|size
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|additionalViewExprs
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|targetIdx
argument_list|,
name|targetNode
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// We need to create the rollup expression
name|inputViewExprs
operator|.
name|add
argument_list|(
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|targetNode
argument_list|,
name|exprsLineage
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// This expression should be referenced directly
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|added
condition|;
name|k
operator|++
control|)
block|{
name|RexNode
name|n
init|=
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|INPUT_REF
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|ref
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|n
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|targetIdx
condition|)
block|{
name|groupSetB
operator|.
name|set
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|rewritingMapping
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
comment|// No matching group by column, we bail out
return|return
literal|null
return|;
block|}
block|}
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|groupSetB
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|references
operator|!=
literal|null
operator|&&
operator|!
name|references
operator|.
name|get
argument_list|(
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
argument_list|)
condition|)
block|{
comment|// Ignore
continue|continue;
block|}
name|int
name|sourceIdx
init|=
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|i
decl_stmt|;
name|int
name|targetIdx
init|=
name|aggregateMapping
operator|.
name|getTargetOpt
argument_list|(
name|sourceIdx
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetIdx
operator|<
literal|0
condition|)
block|{
comment|// No matching aggregation column, we bail out
return|return
literal|null
return|;
block|}
name|AggregateCall
name|queryAggCall
init|=
name|queryAggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|added
condition|;
name|k
operator|++
control|)
block|{
name|RexNode
name|n
init|=
name|topViewProject
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|INPUT_REF
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|int
name|ref
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|n
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|targetIdx
condition|)
block|{
name|SqlAggFunction
name|rollupAgg
init|=
name|getRollup
argument_list|(
name|queryAggCall
operator|.
name|getAggregation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rollupAgg
operator|==
literal|null
condition|)
block|{
comment|// Cannot rollup this aggregate, bail out
return|return
literal|null
return|;
block|}
name|rewritingMapping
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
operator|+
name|aggregateCalls
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RexInputRef
name|operand
init|=
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|input
argument_list|,
name|k
argument_list|)
decl_stmt|;
name|aggregateCalls
operator|.
name|add
argument_list|(
comment|// TODO: handle aggregate ordering
name|relBuilder
operator|.
name|aggregateCall
argument_list|(
name|rollupAgg
argument_list|,
name|operand
argument_list|)
operator|.
name|approximate
argument_list|(
name|queryAggCall
operator|.
name|isApproximate
argument_list|()
argument_list|)
operator|.
name|distinct
argument_list|(
name|queryAggCall
operator|.
name|isDistinct
argument_list|()
argument_list|)
operator|.
name|as
argument_list|(
name|queryAggCall
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|added
condition|)
block|{
comment|// No matching aggregation column, we bail out
return|return
literal|null
return|;
block|}
block|}
comment|// Create aggregate on top of input
name|RelNode
name|prevNode
init|=
name|result
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputViewExprs
operator|.
name|size
argument_list|()
operator|!=
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
name|relBuilder
operator|.
name|project
argument_list|(
name|inputViewExprs
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|relBuilder
operator|.
name|aggregate
argument_list|(
name|relBuilder
operator|.
name|groupKey
argument_list|(
name|groupSet
argument_list|)
argument_list|,
name|aggregateCalls
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevNode
operator|==
name|result
operator|&&
name|groupSet
operator|.
name|cardinality
argument_list|()
operator|!=
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
comment|// Aggregate was not inserted but we need to prune columns
name|result
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|relBuilder
operator|.
name|fields
argument_list|(
name|groupSet
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// We introduce a project on top, as group by columns order is lost
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Mapping
name|inverseMapping
init|=
name|rewritingMapping
operator|.
name|inverse
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|result
argument_list|,
name|groupSet
operator|.
name|indexOf
argument_list|(
name|inverseMapping
operator|.
name|getTarget
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// We add aggregate functions that are present in result to projection list
for|for
control|(
name|int
name|i
init|=
name|queryAggregate
operator|.
name|getGroupCount
argument_list|()
init|;
name|i
operator|<
name|result
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|result
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|projects
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// end if queryAggregate.getGroupCount() != viewAggregate.getGroupCount()
comment|// Add query expressions on top. We first map query expressions to view
comment|// expressions. Once we have done that, if the expression is contained
comment|// and we have introduced already an operator on top of the input node,
comment|// we use the mapping to resolve the position of the expression in the
comment|// node.
specifier|final
name|RelDataType
name|topRowType
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|topExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|topProject
operator|!=
literal|null
operator|&&
operator|!
name|unionRewriting
condition|)
block|{
name|topExprs
operator|.
name|addAll
argument_list|(
name|topProject
operator|.
name|getChildExps
argument_list|()
argument_list|)
expr_stmt|;
name|topRowType
operator|=
name|topProject
operator|.
name|getRowType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Add all
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|queryAggregate
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|topExprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|queryAggregate
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|topRowType
operator|=
name|queryAggregate
operator|.
name|getRowType
argument_list|()
expr_stmt|;
block|}
comment|// Available in view.
specifier|final
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|viewExprs
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|int
name|numberViewExprs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RexNode
name|viewExpr
range|:
name|topViewProject
operator|.
name|getChildExps
argument_list|()
control|)
block|{
name|viewExprs
operator|.
name|put
argument_list|(
name|viewExpr
argument_list|,
name|numberViewExprs
operator|++
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RexNode
name|additionalViewExpr
range|:
name|additionalViewExprs
control|)
block|{
name|viewExprs
operator|.
name|put
argument_list|(
name|additionalViewExpr
argument_list|,
name|numberViewExprs
operator|++
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|topExprs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|expr
range|:
name|topExprs
control|)
block|{
comment|// First map through the aggregate
name|RexNode
name|rewrittenExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|aggregateMapping
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenExpr
operator|==
literal|null
condition|)
block|{
comment|// Cannot map expression
return|return
literal|null
return|;
block|}
comment|// Next map through the last project
name|rewrittenExpr
operator|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|rewrittenExpr
argument_list|,
name|viewExprs
argument_list|,
name|result
argument_list|,
name|rewritingMapping
argument_list|)
expr_stmt|;
if|if
condition|(
name|rewrittenExpr
operator|==
literal|null
condition|)
block|{
comment|// Cannot map expression
return|return
literal|null
return|;
block|}
name|rewrittenExprs
operator|.
name|add
argument_list|(
name|rewrittenExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|result
argument_list|)
operator|.
name|project
argument_list|(
name|rewrittenExprs
argument_list|)
operator|.
name|convert
argument_list|(
name|topRowType
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**      * Mapping from node expressions to target expressions.      *      *<p>If any of the expressions cannot be mapped, we return null.      */
specifier|protected
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|generateMapping
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|RelNode
name|target
parameter_list|,
name|ImmutableBitSet
name|positions
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|sourceEC
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|additionalExprs
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|additionalExprs
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|m
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|equivalenceClassesMap
init|=
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
decl_stmt|;
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|timestampExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|target
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|target
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Bail out
continue|continue;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
specifier|final
name|RexNode
name|e
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Rewrite expr to be expressed on query tables
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|RexNode
name|expr
init|=
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|simplified
argument_list|,
name|tableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|equivalenceClassesMap
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SqlTypeName
name|sqlTypeName
init|=
name|expr
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|sqlTypeName
operator|==
name|SqlTypeName
operator|.
name|TIMESTAMP
operator|||
name|sqlTypeName
operator|==
name|SqlTypeName
operator|.
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
condition|)
block|{
name|timestampExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If this is a column of TIMESTAMP (WITH LOCAL TIME ZONE)
comment|// type, we add the possible rollup columns too.
comment|// This way we will be able to match FLOOR(ts to HOUR) to
comment|// FLOOR(ts to DAY) via FLOOR(FLOOR(ts to HOUR) to DAY)
for|for
control|(
name|RexNode
name|timestampExpr
range|:
name|timestampExprs
control|)
block|{
for|for
control|(
name|TimeUnitRange
name|value
range|:
name|SUPPORTED_DATE_TIME_ROLLUP_UNITS
control|)
block|{
comment|// CEIL
name|RexNode
name|ceilExpr
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|getCeilSqlFunction
argument_list|(
name|value
argument_list|)
argument_list|,
name|timestampExpr
argument_list|,
name|rexBuilder
operator|.
name|makeFlag
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
comment|// References self-row
name|RexNode
name|rewrittenCeilExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|ceilExpr
argument_list|,
name|exprsLineage
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenCeilExpr
operator|!=
literal|null
condition|)
block|{
comment|// We add the CEIL expression to the additional expressions, replacing the child
comment|// expression by the position that it references
name|additionalExprs
operator|.
name|add
argument_list|(
name|rewrittenCeilExpr
argument_list|)
expr_stmt|;
comment|// Then we simplify the expression and we add it to the expressions lineage so we
comment|// can try to find a match
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|ceilExpr
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|simplified
argument_list|,
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|additionalExprs
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// FLOOR
name|RexNode
name|floorExpr
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|getFloorSqlFunction
argument_list|(
name|value
argument_list|)
argument_list|,
name|timestampExpr
argument_list|,
name|rexBuilder
operator|.
name|makeFlag
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
comment|// References self-row
name|RexNode
name|rewrittenFloorExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|floorExpr
argument_list|,
name|exprsLineage
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenFloorExpr
operator|!=
literal|null
condition|)
block|{
comment|// We add the FLOOR expression to the additional expressions, replacing the child
comment|// expression by the position that it references
name|additionalExprs
operator|.
name|add
argument_list|(
name|rewrittenFloorExpr
argument_list|)
expr_stmt|;
comment|// Then we simplify the expression and we add it to the expressions lineage so we
comment|// can try to find a match
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|floorExpr
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|simplified
argument_list|,
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|additionalExprs
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
range|:
name|positions
control|)
block|{
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
specifier|final
name|RexNode
name|e
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Rewrite expr to be expressed on query tables
specifier|final
name|RexNode
name|simplified
init|=
name|simplify
operator|.
name|simplifyUnknownAsFalse
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|RexNode
name|targetExpr
init|=
name|RexUtil
operator|.
name|swapColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|simplified
argument_list|,
name|equivalenceClassesMap
argument_list|)
decl_stmt|;
specifier|final
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|targetExpr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Integer
name|j
range|:
name|c
control|)
block|{
name|m
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If we did not find the expression, try to navigate it
name|RexNode
name|rewrittenTargetExpr
init|=
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|targetExpr
argument_list|,
name|exprsLineage
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenTargetExpr
operator|==
literal|null
condition|)
block|{
comment|// Some expressions were not present
return|return
literal|null
return|;
block|}
name|m
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|target
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|additionalExprs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|additionalExprs
operator|.
name|add
argument_list|(
name|rewrittenTargetExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|m
return|;
block|}
comment|/**      * Get ceil function datetime.      */
specifier|protected
name|SqlFunction
name|getCeilSqlFunction
parameter_list|(
name|TimeUnitRange
name|flag
parameter_list|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|CEIL
return|;
block|}
comment|/**      * Get floor function datetime.      */
specifier|protected
name|SqlFunction
name|getFloorSqlFunction
parameter_list|(
name|TimeUnitRange
name|flag
parameter_list|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|FLOOR
return|;
block|}
comment|/**      * Get rollup aggregation function.      */
specifier|protected
name|SqlAggFunction
name|getRollup
parameter_list|(
name|SqlAggFunction
name|aggregation
parameter_list|)
block|{
if|if
condition|(
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|SUM
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|MIN
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|MAX
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|SUM0
operator|||
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|ANY_VALUE
condition|)
block|{
return|return
name|aggregation
return|;
block|}
if|else if
condition|(
name|aggregation
operator|==
name|SqlStdOperatorTable
operator|.
name|COUNT
condition|)
block|{
return|return
name|SqlStdOperatorTable
operator|.
name|SUM0
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|RelNode
argument_list|>
name|pushFilterToOriginalViewPlan
parameter_list|(
name|RelBuilder
name|builder
parameter_list|,
name|RelNode
name|topViewProject
parameter_list|,
name|RelNode
name|viewNode
parameter_list|,
name|RexNode
name|cond
parameter_list|)
block|{
comment|// We add (and push) the filter to the view plan before triggering the rewriting.
comment|// This is useful in case some of the columns can be folded to same value after
comment|// filter is added.
name|HepProgramBuilder
name|pushFiltersProgram
init|=
operator|new
name|HepProgramBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|topViewProject
operator|!=
literal|null
condition|)
block|{
name|pushFiltersProgram
operator|.
name|addRuleInstance
argument_list|(
name|filterProjectTransposeRule
argument_list|)
expr_stmt|;
block|}
name|pushFiltersProgram
operator|.
name|addRuleInstance
argument_list|(
name|this
operator|.
name|filterAggregateTransposeRule
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|this
operator|.
name|aggregateProjectPullUpConstantsRule
argument_list|)
operator|.
name|addRuleInstance
argument_list|(
name|this
operator|.
name|projectMergeRule
argument_list|)
expr_stmt|;
specifier|final
name|HepPlanner
name|tmpPlanner
init|=
operator|new
name|HepPlanner
argument_list|(
name|pushFiltersProgram
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|// Now that the planner is created, push the node
name|RelNode
name|topNode
init|=
name|builder
operator|.
name|push
argument_list|(
name|topViewProject
operator|!=
literal|null
condition|?
name|topViewProject
else|:
name|viewNode
argument_list|)
operator|.
name|filter
argument_list|(
name|cond
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|tmpPlanner
operator|.
name|setRoot
argument_list|(
name|topNode
argument_list|)
expr_stmt|;
name|topNode
operator|=
name|tmpPlanner
operator|.
name|findBestExp
argument_list|()
expr_stmt|;
name|RelNode
name|resultTopViewProject
init|=
literal|null
decl_stmt|;
name|RelNode
name|resultViewNode
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|topNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|topNode
operator|instanceof
name|Project
condition|)
block|{
if|if
condition|(
name|resultTopViewProject
operator|!=
literal|null
condition|)
block|{
comment|// Both projects could not be merged, we will bail out
return|return
name|Pair
operator|.
name|of
argument_list|(
name|topViewProject
argument_list|,
name|viewNode
argument_list|)
return|;
block|}
name|resultTopViewProject
operator|=
name|topNode
expr_stmt|;
name|topNode
operator|=
name|topNode
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|topNode
operator|instanceof
name|Aggregate
condition|)
block|{
name|resultViewNode
operator|=
name|topNode
expr_stmt|;
name|topNode
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// We move to the child
name|topNode
operator|=
name|topNode
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|resultTopViewProject
argument_list|,
name|resultViewNode
argument_list|)
return|;
block|}
block|}
comment|/** Rule that matches Project on Aggregate. */
specifier|public
specifier|static
class|class
name|MaterializedViewProjectAggregateRule
extends|extends
name|MaterializedViewAggregateRule
block|{
specifier|public
name|MaterializedViewProjectAggregateRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Project
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewAggregateRule(Project-Aggregate)"
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Project
name|project
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
name|project
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Rule that matches Aggregate. */
specifier|public
specifier|static
class|class
name|MaterializedViewOnlyAggregateRule
extends|extends
name|MaterializedViewAggregateRule
block|{
specifier|public
name|MaterializedViewOnlyAggregateRule
parameter_list|(
name|RelBuilderFactory
name|relBuilderFactory
parameter_list|,
name|boolean
name|generateUnionRewriting
parameter_list|,
name|HepProgram
name|unionRewritingPullProgram
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|(
name|Aggregate
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|relBuilderFactory
argument_list|,
literal|"MaterializedViewAggregateRule(Aggregate)"
argument_list|,
name|generateUnionRewriting
argument_list|,
name|unionRewritingPullProgram
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
specifier|final
name|Aggregate
name|aggregate
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|perform
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
name|aggregate
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * If the node is an Aggregate, it returns a list of references to the grouping columns.    * Otherwise, it returns a list of references to all columns in the node.    * The returned list is immutable.    */
specifier|private
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|extractReferences
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelNode
name|node
parameter_list|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|Aggregate
condition|)
block|{
name|Aggregate
name|aggregate
init|=
operator|(
name|Aggregate
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregate
operator|.
name|getGroupCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|aggregate
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|exprs
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * It will flatten a multimap containing table references to table references,    * producing all possible combinations of mappings. Each of the mappings will    * be bi-directional.    */
specifier|private
specifier|static
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|generateTableMappings
parameter_list|(
name|Multimap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|multiMapTables
parameter_list|)
block|{
if|if
condition|(
name|multiMapTables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
name|List
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|result
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|HashBiMap
operator|.
name|create
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|RelTableRef
argument_list|,
name|Collection
argument_list|<
name|RelTableRef
argument_list|>
argument_list|>
name|e
range|:
name|multiMapTables
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Only one reference, we can just add it to every map
name|RelTableRef
name|target
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|m
range|:
name|result
control|)
block|{
name|m
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|// Multiple references: flatten
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
argument_list|>
name|newResult
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|target
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
for|for
control|(
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|m
range|:
name|result
control|)
block|{
if|if
condition|(
operator|!
name|m
operator|.
name|containsValue
argument_list|(
name|target
argument_list|)
condition|)
block|{
specifier|final
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|newM
init|=
name|HashBiMap
operator|.
name|create
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|newM
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|newResult
operator|.
name|add
argument_list|(
name|newM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|result
operator|=
name|newResult
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/** Currently we only support TableScan - Project - Filter - Inner Join */
specifier|private
specifier|static
name|boolean
name|isValidRelNodePlan
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
specifier|final
name|Multimap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|m
init|=
name|mq
operator|.
name|getNodeTypes
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
argument_list|,
name|Collection
argument_list|<
name|RelNode
argument_list|>
argument_list|>
name|e
range|:
name|m
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|c
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|TableScan
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|Project
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|Filter
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
operator|!
name|Join
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
comment|// Skip it
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Join
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
name|RelNode
name|n
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
specifier|final
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|n
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|!=
name|JoinRelType
operator|.
name|INNER
operator|&&
operator|!
name|join
operator|.
name|isSemiJoin
argument_list|()
condition|)
block|{
comment|// Skip it
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Classifies each of the predicates in the list into one of these two    * categories:    *    *<ul>    *<li> 1-l) column equality predicates, or    *<li> 2-r) residual predicates, all the rest    *</ul>    *    *<p>For each category, it creates the conjunction of the predicates. The    * result is an pair of RexNode objects corresponding to each category.    */
specifier|private
specifier|static
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|splitPredicates
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexNode
name|pred
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|equiColumnsPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|residualPreds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|e
range|:
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|pred
argument_list|)
control|)
block|{
switch|switch
condition|(
name|e
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EQUALS
case|:
name|RexCall
name|eqCall
init|=
operator|(
name|RexCall
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
operator|&&
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|eqCall
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|equiColumnsPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|residualPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|residualPreds
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|equiColumnsPreds
argument_list|)
argument_list|,
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|residualPreds
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * It checks whether the target can be rewritten using the source even though the    * source uses additional tables. In order to do that, we need to double-check    * that every join that exists in the source and is not in the target is a    * cardinality-preserving join, i.e., it only appends columns to the row    * without changing its multiplicity. Thus, the join needs to be:    *<ul>    *<li> Equi-join</li>    *<li> Between all columns in the keys</li>    *<li> Foreign-key columns do not allow NULL values</li>    *<li> Foreign-key</li>    *<li> Unique-key</li>    *</ul>    *    *<p>If it can be rewritten, it returns true. Further, it inserts the missing equi-join    * predicates in the input {@code compensationEquiColumns} multimap if it is provided.    * If it cannot be rewritten, it returns false.    */
specifier|private
specifier|static
name|boolean
name|compensatePartial
parameter_list|(
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|sourceTableRefs
parameter_list|,
name|EquivalenceClasses
name|sourceEC
parameter_list|,
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|targetTableRefs
parameter_list|,
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|compensationEquiColumns
parameter_list|)
block|{
comment|// Create UK-FK graph with view tables
specifier|final
name|DirectedGraph
argument_list|<
name|RelTableRef
argument_list|,
name|Edge
argument_list|>
name|graph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|(
name|Edge
operator|::
operator|new
argument_list|)
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|RelTableRef
argument_list|>
name|tableVNameToTableRefs
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelTableRef
argument_list|>
name|extraTableRefs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|sourceTableRefs
control|)
block|{
comment|// Add tables in view as vertices
name|graph
operator|.
name|addVertex
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
name|tableVNameToTableRefs
operator|.
name|put
argument_list|(
name|tRef
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|tRef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targetTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// Add to extra tables if table is not part of the query
name|extraTableRefs
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|graph
operator|.
name|vertexSet
argument_list|()
control|)
block|{
comment|// Add edges between tables
name|List
argument_list|<
name|RelReferentialConstraint
argument_list|>
name|constraints
init|=
name|tRef
operator|.
name|getTable
argument_list|()
operator|.
name|getReferentialConstraints
argument_list|()
decl_stmt|;
for|for
control|(
name|RelReferentialConstraint
name|constraint
range|:
name|constraints
control|)
block|{
name|Collection
argument_list|<
name|RelTableRef
argument_list|>
name|parentTableRefs
init|=
name|tableVNameToTableRefs
operator|.
name|get
argument_list|(
name|constraint
operator|.
name|getTargetQualifiedName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RelTableRef
name|parentTRef
range|:
name|parentTableRefs
control|)
block|{
name|boolean
name|canBeRewritten
init|=
literal|true
decl_stmt|;
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|equiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|constraint
operator|.
name|getNumColumns
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|int
name|foreignKeyPos
init|=
name|constraint
operator|.
name|getColumnPairs
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|source
decl_stmt|;
name|RelDataType
name|foreignKeyColumnType
init|=
name|tRef
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|foreignKeyPos
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RexTableInputRef
name|foreignKeyColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|tRef
argument_list|,
name|foreignKeyPos
argument_list|,
name|foreignKeyColumnType
argument_list|)
decl_stmt|;
name|int
name|uniqueKeyPos
init|=
name|constraint
operator|.
name|getColumnPairs
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|target
decl_stmt|;
name|RexTableInputRef
name|uniqueKeyColumnRef
init|=
name|RexTableInputRef
operator|.
name|of
argument_list|(
name|parentTRef
argument_list|,
name|uniqueKeyPos
argument_list|,
name|parentTRef
operator|.
name|getTable
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|uniqueKeyPos
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|foreignKeyColumnType
operator|.
name|isNullable
argument_list|()
operator|&&
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|uniqueKeyColumnRef
argument_list|)
operator|&&
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
operator|.
name|get
argument_list|(
name|uniqueKeyColumnRef
argument_list|)
operator|.
name|contains
argument_list|(
name|foreignKeyColumnRef
argument_list|)
condition|)
block|{
name|equiColumns
operator|.
name|put
argument_list|(
name|foreignKeyColumnRef
argument_list|,
name|uniqueKeyColumnRef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canBeRewritten
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|canBeRewritten
condition|)
block|{
comment|// Add edge FK -> UK
name|Edge
name|edge
init|=
name|graph
operator|.
name|getEdge
argument_list|(
name|tRef
argument_list|,
name|parentTRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|edge
operator|==
literal|null
condition|)
block|{
name|edge
operator|=
name|graph
operator|.
name|addEdge
argument_list|(
name|tRef
argument_list|,
name|parentTRef
argument_list|)
expr_stmt|;
block|}
name|edge
operator|.
name|equiColumns
operator|.
name|putAll
argument_list|(
name|equiColumns
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Try to eliminate tables from graph: if we can do it, it means extra tables in
comment|// view are cardinality-preserving joins
name|boolean
name|done
init|=
literal|false
decl_stmt|;
do|do
block|{
name|List
argument_list|<
name|RelTableRef
argument_list|>
name|nodesToRemove
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelTableRef
name|tRef
range|:
name|graph
operator|.
name|vertexSet
argument_list|()
control|)
block|{
if|if
condition|(
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|graph
operator|.
name|getOutwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// UK-FK join
name|nodesToRemove
operator|.
name|add
argument_list|(
name|tRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationEquiColumns
operator|!=
literal|null
operator|&&
name|extraTableRefs
operator|.
name|contains
argument_list|(
name|tRef
argument_list|)
condition|)
block|{
comment|// We need to add to compensation columns as the table is not present in the query
name|compensationEquiColumns
operator|.
name|putAll
argument_list|(
name|graph
operator|.
name|getInwardEdges
argument_list|(
name|tRef
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equiColumns
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|nodesToRemove
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|graph
operator|.
name|removeAllVertices
argument_list|(
name|nodesToRemove
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
comment|// After removing them, we check whether all the remaining tables in the graph
comment|// are tables present in the query: if they are, we can try to rewrite
if|if
condition|(
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|graph
operator|.
name|vertexSet
argument_list|()
argument_list|,
name|extraTableRefs
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * We check whether the predicates in the source are contained in the predicates    * in the target. The method treats separately the equi-column predicates, the    * range predicates, and the rest of predicates.    *    *<p>If the containment is confirmed, we produce compensation predicates that    * need to be added to the target to produce the results in the source. Thus,    * if source and target expressions are equivalent, those predicates will be the    * true constant.    *    *<p>In turn, if containment cannot be confirmed, the method returns null.    */
specifier|private
specifier|static
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|computeCompensationPredicates
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RexSimplify
name|simplify
parameter_list|,
name|EquivalenceClasses
name|sourceEC
parameter_list|,
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|sourcePreds
parameter_list|,
name|EquivalenceClasses
name|targetEC
parameter_list|,
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|RexNode
argument_list|>
name|targetPreds
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|sourceToTargetTableMapping
parameter_list|)
block|{
specifier|final
name|RexNode
name|compensationColumnsEquiPred
decl_stmt|;
specifier|final
name|RexNode
name|compensationPred
decl_stmt|;
comment|// 1. Establish relationship between source and target equivalence classes.
comment|// If every target equivalence class is not a subset of a source
comment|// equivalence class, we bail out.
name|compensationColumnsEquiPred
operator|=
name|generateEquivalenceClasses
argument_list|(
name|rexBuilder
argument_list|,
name|sourceEC
argument_list|,
name|targetEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationColumnsEquiPred
operator|==
literal|null
condition|)
block|{
comment|// Cannot rewrite
return|return
literal|null
return|;
block|}
comment|// 2. We check that that residual predicates of the source are satisfied within the target.
comment|// Compute compensating predicates.
specifier|final
name|RexNode
name|queryPred
init|=
name|RexUtil
operator|.
name|swapColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|sourcePreds
operator|.
name|right
argument_list|,
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|viewPred
init|=
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|targetPreds
operator|.
name|right
argument_list|,
name|sourceToTargetTableMapping
operator|.
name|inverse
argument_list|()
argument_list|,
name|sourceEC
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
name|compensationPred
operator|=
name|SubstitutionVisitor
operator|.
name|splitFilter
argument_list|(
name|simplify
argument_list|,
name|queryPred
argument_list|,
name|viewPred
argument_list|)
expr_stmt|;
if|if
condition|(
name|compensationPred
operator|==
literal|null
condition|)
block|{
comment|// Cannot rewrite
return|return
literal|null
return|;
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|compensationColumnsEquiPred
argument_list|,
name|compensationPred
argument_list|)
return|;
block|}
comment|/**    * Given the equi-column predicates of the source and the target and the    * computed equivalence classes, it extracts possible mappings between    * the equivalence classes.    *    *<p>If there is no mapping, it returns null. If there is a exact match,    * it will return a compensation predicate that evaluates to true.    * Finally, if a compensation predicate needs to be enforced on top of    * the target to make the equivalences classes match, it returns that    * compensation predicate.    */
specifier|private
specifier|static
name|RexNode
name|generateEquivalenceClasses
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|EquivalenceClasses
name|sourceEC
parameter_list|,
name|EquivalenceClasses
name|targetEC
parameter_list|)
block|{
if|if
condition|(
name|sourceEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|targetEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No column equality predicates in query and view
comment|// Empty mapping and compensation predicate
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
name|sourceEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|targetEC
operator|.
name|getEquivalenceClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No column equality predicates in source, but column equality predicates in target
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|sourceEquivalenceClasses
init|=
name|sourceEC
operator|.
name|getEquivalenceClasses
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|targetEquivalenceClasses
init|=
name|targetEC
operator|.
name|getEquivalenceClasses
argument_list|()
decl_stmt|;
specifier|final
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapping
init|=
name|extractPossibleMapping
argument_list|(
name|sourceEquivalenceClasses
argument_list|,
name|targetEquivalenceClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapping
operator|==
literal|null
condition|)
block|{
comment|// Did not find mapping between the equivalence classes,
comment|// bail out
return|return
literal|null
return|;
block|}
comment|// Create the compensation predicate
name|RexNode
name|compensationPredicate
init|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceEquivalenceClasses
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mapping
operator|.
name|containsKey
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|// Add all predicates
name|Iterator
argument_list|<
name|RexTableInputRef
argument_list|>
name|it
init|=
name|sourceEquivalenceClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|RexTableInputRef
name|e0
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RexNode
name|equals
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|e0
argument_list|,
name|it
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|compensationPredicate
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|compensationPredicate
argument_list|,
name|equals
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Add only predicates that are not there
for|for
control|(
name|int
name|j
range|:
name|mapping
operator|.
name|get
argument_list|(
name|i
argument_list|)
control|)
block|{
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|difference
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|sourceEquivalenceClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|difference
operator|.
name|removeAll
argument_list|(
name|targetEquivalenceClasses
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|RexTableInputRef
name|e
range|:
name|difference
control|)
block|{
name|RexNode
name|equals
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|e
argument_list|,
name|targetEquivalenceClasses
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
name|compensationPredicate
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|compensationPredicate
argument_list|,
name|equals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|compensationPredicate
return|;
block|}
comment|/**    * Given the source and target equivalence classes, it extracts the possible mappings    * from each source equivalence class to each target equivalence class.    *    *<p>If any of the source equivalence classes cannot be mapped to a target equivalence    * class, it returns null.    */
specifier|private
specifier|static
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|extractPossibleMapping
parameter_list|(
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|sourceEquivalenceClasses
parameter_list|,
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|targetEquivalenceClasses
parameter_list|)
block|{
name|Multimap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|mapping
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetEquivalenceClasses
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|foundQueryEquivalenceClass
init|=
literal|false
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|viewEquivalenceClass
init|=
name|targetEquivalenceClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|sourceEquivalenceClasses
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|queryEquivalenceClass
init|=
name|sourceEquivalenceClasses
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryEquivalenceClass
operator|.
name|containsAll
argument_list|(
name|viewEquivalenceClass
argument_list|)
condition|)
block|{
name|mapping
operator|.
name|put
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|foundQueryEquivalenceClass
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// end for
if|if
condition|(
operator|!
name|foundQueryEquivalenceClass
condition|)
block|{
comment|// Target equivalence class not found in source equivalence class
return|return
literal|null
return|;
block|}
block|}
comment|// end for
return|return
name|mapping
return|;
block|}
comment|/**    * First, the method takes the node expressions {@code nodeExprs} and swaps the table    * and column references using the table mapping and the equivalence classes.    * If {@code swapTableColumn} is true, it swaps the table reference and then the column reference,    * otherwise it swaps the column reference and then the table reference.    *    *<p>Then, the method will rewrite the input expression {@code exprToRewrite}, replacing the    * {@link RexTableInputRef} by references to the positions in {@code nodeExprs}.    *    *<p>The method will return the rewritten expression. If any of the expressions in the input    * expression cannot be mapped, it will return null.    */
specifier|private
specifier|static
name|RexNode
name|rewriteExpression
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|targetNode
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeExprs
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|ec
parameter_list|,
name|boolean
name|swapTableColumn
parameter_list|,
name|RexNode
name|exprToRewrite
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
name|rewriteExpressions
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|targetNode
argument_list|,
name|node
argument_list|,
name|nodeExprs
argument_list|,
name|tableMapping
argument_list|,
name|ec
argument_list|,
name|swapTableColumn
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|exprToRewrite
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rewrittenExprs
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|rewrittenExprs
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|rewrittenExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * First, the method takes the node expressions {@code nodeExprs} and swaps the table    * and column references using the table mapping and the equivalence classes.    * If {@code swapTableColumn} is true, it swaps the table reference and then the column reference,    * otherwise it swaps the column reference and then the table reference.    *    *<p>Then, the method will rewrite the input expressions {@code exprsToRewrite}, replacing the    * {@link RexTableInputRef} by references to the positions in {@code nodeExprs}.    *    *<p>The method will return the rewritten expressions. If any of the subexpressions in the input    * expressions cannot be mapped, it will return null.    */
specifier|private
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewriteExpressions
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|targetNode
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeExprs
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|ec
parameter_list|,
name|boolean
name|swapTableColumn
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprsToRewrite
parameter_list|)
block|{
name|NodeLineage
name|nodeLineage
decl_stmt|;
if|if
condition|(
name|swapTableColumn
condition|)
block|{
name|nodeLineage
operator|=
name|generateSwapTableColumnReferencesLineage
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|node
argument_list|,
name|tableMapping
argument_list|,
name|ec
argument_list|,
name|nodeExprs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeLineage
operator|=
name|generateSwapColumnTableReferencesLineage
argument_list|(
name|rexBuilder
argument_list|,
name|mq
argument_list|,
name|node
argument_list|,
name|tableMapping
argument_list|,
name|ec
argument_list|,
name|nodeExprs
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewrittenExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|exprsToRewrite
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|exprToRewrite
range|:
name|exprsToRewrite
control|)
block|{
name|RexNode
name|rewrittenExpr
init|=
name|replaceWithOriginalReferences
argument_list|(
name|rexBuilder
argument_list|,
name|targetNode
argument_list|,
name|nodeLineage
argument_list|,
name|exprToRewrite
argument_list|)
decl_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|containsTableInputRef
argument_list|(
name|rewrittenExpr
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// Some expressions were not present in view output
return|return
literal|null
return|;
block|}
name|rewrittenExprs
operator|.
name|add
argument_list|(
name|rewrittenExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|rewrittenExprs
return|;
block|}
comment|/**    * It swaps the table references and then the column references of the input    * expressions using the table mapping and the equivalence classes.    */
specifier|private
specifier|static
name|NodeLineage
name|generateSwapTableColumnReferencesLineage
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|ec
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeExprs
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineageLosslessCasts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|nodeExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Next expression
continue|continue;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
assert|assert
name|s
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
comment|// Rewrite expr. First we swap the table references following the table
comment|// mapping, then we take first element from the corresponding equivalence class
specifier|final
name|RexNode
name|e
init|=
name|RexUtil
operator|.
name|swapTableColumnReferences
argument_list|(
name|rexBuilder
argument_list|,
name|s
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|tableMapping
argument_list|,
name|ec
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|exprsLineageLosslessCasts
operator|.
name|put
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|NodeLineage
argument_list|(
name|exprsLineage
argument_list|,
name|exprsLineageLosslessCasts
argument_list|)
return|;
block|}
comment|/**    * It swaps the column references and then the table references of the input    * expressions using the equivalence classes and the table mapping.    */
specifier|private
specifier|static
name|NodeLineage
name|generateSwapColumnTableReferencesLineage
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|RelNode
name|node
parameter_list|,
name|BiMap
argument_list|<
name|RelTableRef
argument_list|,
name|RelTableRef
argument_list|>
name|tableMapping
parameter_list|,
name|EquivalenceClasses
name|ec
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|nodeExprs
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineageLosslessCasts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Set
argument_list|<
name|RexNode
argument_list|>
name|s
init|=
name|mq
operator|.
name|getExpressionLineage
argument_list|(
name|node
argument_list|,
name|nodeExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
comment|// Next expression
continue|continue;
block|}
comment|// We only support project - filter - join, thus it should map to
comment|// a single expression
specifier|final
name|RexNode
name|node2
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Rewrite expr. First we take first element from the corresponding equivalence class,
comment|// then we swap the table references following the table mapping
specifier|final
name|RexNode
name|e
init|=
name|RexUtil
operator|.
name|swapColumnTableReferences
argument_list|(
name|rexBuilder
argument_list|,
name|node2
argument_list|,
name|ec
operator|.
name|getEquivalenceClassesMap
argument_list|()
argument_list|,
name|tableMapping
argument_list|)
decl_stmt|;
name|exprsLineage
operator|.
name|put
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|isLosslessCast
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|exprsLineageLosslessCasts
operator|.
name|put
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|e
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|NodeLineage
argument_list|(
name|exprsLineage
argument_list|,
name|exprsLineageLosslessCasts
argument_list|)
return|;
block|}
comment|/**    * Given the input expression, it will replace (sub)expressions when possible    * using the content of the mapping. In particular, the mapping contains the    * digest of the expression and the index that the replacement input ref should    * point to.    */
specifier|private
specifier|static
name|RexNode
name|replaceWithOriginalReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RelNode
name|node
parameter_list|,
specifier|final
name|NodeLineage
name|nodeLineage
parameter_list|,
specifier|final
name|RexNode
name|exprToRewrite
parameter_list|)
block|{
comment|// Currently we allow the following:
comment|// 1) compensation pred can be directly map to expression
comment|// 2) all references in compensation pred can be map to expressions
comment|// We support bypassing lossless casts.
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|RexNode
name|rw
init|=
name|replace
argument_list|(
name|call
argument_list|)
decl_stmt|;
return|return
name|rw
operator|!=
literal|null
condition|?
name|rw
else|:
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|inputRef
parameter_list|)
block|{
name|RexNode
name|rw
init|=
name|replace
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
return|return
name|rw
operator|!=
literal|null
condition|?
name|rw
else|:
name|super
operator|.
name|visitTableInputRef
argument_list|(
name|inputRef
argument_list|)
return|;
block|}
specifier|private
name|RexNode
name|replace
parameter_list|(
name|RexNode
name|e
parameter_list|)
block|{
name|Integer
name|pos
init|=
name|nodeLineage
operator|.
name|exprsLineage
operator|.
name|get
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|null
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
return|;
block|}
name|pos
operator|=
name|nodeLineage
operator|.
name|exprsLineageLosslessCasts
operator|.
name|get
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|null
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeCast
argument_list|(
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|exprToRewrite
argument_list|)
return|;
block|}
comment|/**    * Replaces all the input references by the position in the    * input column set. If a reference index cannot be found in    * the input set, then we return null.    */
specifier|private
specifier|static
name|RexNode
name|shuttleReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|node
parameter_list|,
specifier|final
name|Mapping
name|mapping
parameter_list|)
block|{
try|try
block|{
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|int
name|pos
init|=
name|mapping
operator|.
name|getTargetOpt
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Found it
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|node
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|ex
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Replaces all the possible sub-expressions by input references    * to the input node.    */
specifier|private
specifier|static
name|RexNode
name|shuttleReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|expr
parameter_list|,
specifier|final
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
parameter_list|)
block|{
return|return
name|shuttleReferences
argument_list|(
name|rexBuilder
argument_list|,
name|expr
argument_list|,
name|exprsLineage
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Replaces all the possible sub-expressions by input references    * to the input node. If available, it uses the rewriting mapping    * to change the position to reference. Takes the reference type    * from the input node.    */
specifier|private
specifier|static
name|RexNode
name|shuttleReferences
parameter_list|(
specifier|final
name|RexBuilder
name|rexBuilder
parameter_list|,
specifier|final
name|RexNode
name|expr
parameter_list|,
specifier|final
name|Multimap
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
parameter_list|,
specifier|final
name|RelNode
name|node
parameter_list|,
specifier|final
name|Mapping
name|rewritingMapping
parameter_list|)
block|{
try|try
block|{
name|RexShuttle
name|visitor
init|=
operator|new
name|RexShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|visitTableInputRef
parameter_list|(
name|RexTableInputRef
name|ref
parameter_list|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Cannot map expression
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|int
name|pos
init|=
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|rewritingMapping
operator|!=
literal|null
condition|)
block|{
name|pos
operator|=
name|rewritingMapping
operator|.
name|getTargetOpt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Cannot map expression
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|ref
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|inputRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Cannot map expression
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
name|int
name|pos
init|=
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|rewritingMapping
operator|!=
literal|null
condition|)
block|{
name|pos
operator|=
name|rewritingMapping
operator|.
name|getTargetOpt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Cannot map expression
throw|throw
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
throw|;
block|}
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|inputRef
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
specifier|final
name|RexCall
name|call
parameter_list|)
block|{
name|Collection
argument_list|<
name|Integer
argument_list|>
name|c
init|=
name|exprsLineage
operator|.
name|get
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Cannot map expression
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
name|int
name|pos
init|=
name|c
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|rewritingMapping
operator|!=
literal|null
condition|)
block|{
name|pos
operator|=
name|rewritingMapping
operator|.
name|getTargetOpt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Cannot map expression
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|node
argument_list|,
name|pos
argument_list|)
return|;
block|}
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|visitor
operator|.
name|apply
argument_list|(
name|expr
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Util
operator|.
name|FoundOne
name|ex
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|ex
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Class representing an equivalence class, i.e., a set of equivalent columns    */
specifier|private
specifier|static
class|class
name|EquivalenceClasses
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|nodeToEquivalenceClass
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|cacheEquivalenceClassesMap
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|cacheEquivalenceClasses
decl_stmt|;
specifier|protected
name|EquivalenceClasses
parameter_list|()
block|{
name|nodeToEquivalenceClass
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|cacheEquivalenceClassesMap
operator|=
name|ImmutableMap
operator|.
name|of
argument_list|()
expr_stmt|;
name|cacheEquivalenceClasses
operator|=
name|ImmutableList
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|addEquivalenceClass
parameter_list|(
name|RexTableInputRef
name|p1
parameter_list|,
name|RexTableInputRef
name|p2
parameter_list|)
block|{
comment|// Clear cache
name|cacheEquivalenceClassesMap
operator|=
literal|null
expr_stmt|;
name|cacheEquivalenceClasses
operator|=
literal|null
expr_stmt|;
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|c1
init|=
name|nodeToEquivalenceClass
operator|.
name|get
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|c2
init|=
name|nodeToEquivalenceClass
operator|.
name|get
argument_list|(
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|null
operator|&&
name|c2
operator|!=
literal|null
condition|)
block|{
comment|// Both present, we need to merge
if|if
condition|(
name|c1
operator|.
name|size
argument_list|()
operator|<
name|c2
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// We swap them to merge
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|c2Temp
init|=
name|c2
decl_stmt|;
name|c2
operator|=
name|c1
expr_stmt|;
name|c1
operator|=
name|c2Temp
expr_stmt|;
block|}
for|for
control|(
name|RexTableInputRef
name|newRef
range|:
name|c2
control|)
block|{
name|c1
operator|.
name|add
argument_list|(
name|newRef
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|newRef
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|c1
operator|!=
literal|null
condition|)
block|{
comment|// p1 present, we need to merge into it
name|c1
operator|.
name|add
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p2
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|c2
operator|!=
literal|null
condition|)
block|{
comment|// p2 present, we need to merge into it
name|c2
operator|.
name|add
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// None are present, add to same equivalence class
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|equivalenceClass
init|=
operator|new
name|LinkedHashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|equivalenceClass
operator|.
name|add
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|equivalenceClass
operator|.
name|add
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p1
argument_list|,
name|equivalenceClass
argument_list|)
expr_stmt|;
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|p2
argument_list|,
name|equivalenceClass
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|Map
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|getEquivalenceClassesMap
parameter_list|()
block|{
if|if
condition|(
name|cacheEquivalenceClassesMap
operator|==
literal|null
condition|)
block|{
name|cacheEquivalenceClassesMap
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|nodeToEquivalenceClass
argument_list|)
expr_stmt|;
block|}
return|return
name|cacheEquivalenceClassesMap
return|;
block|}
specifier|protected
name|List
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|getEquivalenceClasses
parameter_list|()
block|{
if|if
condition|(
name|cacheEquivalenceClasses
operator|==
literal|null
condition|)
block|{
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
name|set
range|:
name|nodeToEquivalenceClass
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|Collections
operator|.
name|disjoint
argument_list|(
name|visited
argument_list|,
name|set
argument_list|)
condition|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|visited
operator|.
name|addAll
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
block|}
name|cacheEquivalenceClasses
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
return|return
name|cacheEquivalenceClasses
return|;
block|}
specifier|protected
specifier|static
name|EquivalenceClasses
name|copy
parameter_list|(
name|EquivalenceClasses
name|ec
parameter_list|)
block|{
specifier|final
name|EquivalenceClasses
name|newEc
init|=
operator|new
name|EquivalenceClasses
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|RexTableInputRef
argument_list|,
name|Set
argument_list|<
name|RexTableInputRef
argument_list|>
argument_list|>
name|e
range|:
name|ec
operator|.
name|nodeToEquivalenceClass
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newEc
operator|.
name|nodeToEquivalenceClass
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|Sets
operator|.
name|newLinkedHashSet
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newEc
operator|.
name|cacheEquivalenceClassesMap
operator|=
literal|null
expr_stmt|;
name|newEc
operator|.
name|cacheEquivalenceClasses
operator|=
literal|null
expr_stmt|;
return|return
name|newEc
return|;
block|}
block|}
comment|/** Expression lineage details. */
specifier|private
specifier|static
class|class
name|NodeLineage
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineageLosslessCasts
decl_stmt|;
specifier|private
name|NodeLineage
parameter_list|(
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineage
parameter_list|,
name|Map
argument_list|<
name|RexNode
argument_list|,
name|Integer
argument_list|>
name|exprsLineageLosslessCasts
parameter_list|)
block|{
name|this
operator|.
name|exprsLineage
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|exprsLineage
argument_list|)
expr_stmt|;
name|this
operator|.
name|exprsLineageLosslessCasts
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|exprsLineageLosslessCasts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Edge for graph */
specifier|private
specifier|static
class|class
name|Edge
extends|extends
name|DefaultEdge
block|{
specifier|final
name|Multimap
argument_list|<
name|RexTableInputRef
argument_list|,
name|RexTableInputRef
argument_list|>
name|equiColumns
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
name|Edge
parameter_list|(
name|RelTableRef
name|source
parameter_list|,
name|RelTableRef
name|target
parameter_list|)
block|{
name|super
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{"
operator|+
name|source
operator|+
literal|" -> "
operator|+
name|target
operator|+
literal|"}"
return|;
block|}
block|}
comment|/** View partitioning result */
specifier|private
specifier|static
class|class
name|ViewPartialRewriting
block|{
specifier|private
specifier|final
name|RelNode
name|newView
decl_stmt|;
specifier|private
specifier|final
name|Project
name|newTopViewProject
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|newViewNode
decl_stmt|;
specifier|private
name|ViewPartialRewriting
parameter_list|(
name|RelNode
name|newView
parameter_list|,
name|Project
name|newTopViewProject
parameter_list|,
name|RelNode
name|newViewNode
parameter_list|)
block|{
name|this
operator|.
name|newView
operator|=
name|newView
expr_stmt|;
name|this
operator|.
name|newTopViewProject
operator|=
name|newTopViewProject
expr_stmt|;
name|this
operator|.
name|newViewNode
operator|=
name|newViewNode
expr_stmt|;
block|}
specifier|protected
specifier|static
name|ViewPartialRewriting
name|of
parameter_list|(
name|RelNode
name|newView
parameter_list|,
name|Project
name|newTopViewProject
parameter_list|,
name|RelNode
name|newViewNode
parameter_list|)
block|{
return|return
operator|new
name|ViewPartialRewriting
argument_list|(
name|newView
argument_list|,
name|newTopViewProject
argument_list|,
name|newViewNode
argument_list|)
return|;
block|}
block|}
comment|/** Complete, view partial, or query partial. */
specifier|private
enum|enum
name|MatchModality
block|{
name|COMPLETE
block|,
name|VIEW_PARTIAL
block|,
name|QUERY_PARTIAL
block|}
block|}
end_class

end_unit

