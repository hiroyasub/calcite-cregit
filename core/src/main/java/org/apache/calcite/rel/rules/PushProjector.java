begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Strong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Correlate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SetOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|IntStream
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_comment
comment|/**  * PushProjector is a utility class used to perform operations used in push  * projection rules.  *  *<p>Pushing is particularly interesting in the case of join, because there  * are multiple inputs. Generally an expression can be pushed down to a  * particular input if it depends upon no other inputs. If it can be pushed  * down to both sides, it is pushed down to the left.  *  *<p>Sometimes an expression needs to be split before it can be pushed down.  * To flag that an expression cannot be split, specify a rule that it must be  *<dfn>preserved</dfn>. Such an expression will be pushed down intact to one  * of the inputs, or not pushed down at all.</p>  */
end_comment

begin_class
specifier|public
class|class
name|PushProjector
block|{
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
annotation|@
name|Nullable
name|Project
name|origProj
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|RexNode
name|origFilter
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|childRel
decl_stmt|;
specifier|private
specifier|final
name|ExprCondition
name|preserveExprCondition
decl_stmt|;
specifier|private
specifier|final
name|RelBuilder
name|relBuilder
decl_stmt|;
comment|/**    * Original projection expressions.    */
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|origProjExprs
decl_stmt|;
comment|/**    * Fields from the RelNode that the projection is being pushed past.    */
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|childFields
decl_stmt|;
comment|/**    * Number of fields in the RelNode that the projection is being pushed past.    */
specifier|final
name|int
name|nChildFields
decl_stmt|;
comment|/**    * Bitmap containing the references in the original projection.    */
specifier|final
name|BitSet
name|projRefs
decl_stmt|;
comment|/**    * Bitmap containing the fields in the RelNode that the projection is being    * pushed past, if the RelNode is not a join. If the RelNode is a join, then    * the fields correspond to the left hand side of the join.    */
specifier|final
name|ImmutableBitSet
name|childBitmap
decl_stmt|;
comment|/**    * Bitmap containing the fields in the right hand side of a join, in the    * case where the projection is being pushed past a join. Not used    * otherwise.    */
specifier|final
annotation|@
name|Nullable
name|ImmutableBitSet
name|rightBitmap
decl_stmt|;
comment|/**    * Bitmap containing the fields that should be strong, i.e. when preserving expressions    * we can only preserve them if the expressions if it is null when these fields are null.    */
specifier|final
annotation|@
name|Nullable
name|ImmutableBitSet
name|strongBitmap
decl_stmt|;
comment|/**    * Number of fields in the RelNode that the projection is being pushed past,    * if the RelNode is not a join. If the RelNode is a join, then this is the    * number of fields in the left hand side of the join.    *    *<p>The identity    * {@code nChildFields == nSysFields + nFields + nFieldsRight}    * holds. {@code nFields} does not include {@code nSysFields}.    * The output of a join looks like this:    *    *<blockquote><pre>    * | nSysFields | nFields | nFieldsRight |    *</pre></blockquote>    *    *<p>The output of a single-input rel looks like this:    *    *<blockquote><pre>    * | nSysFields | nFields |    *</pre></blockquote>    */
specifier|final
name|int
name|nFields
decl_stmt|;
comment|/**    * Number of fields in the right hand side of a join, in the case where the    * projection is being pushed past a join. Always 0 otherwise.    */
specifier|final
name|int
name|nFieldsRight
decl_stmt|;
comment|/**    * Number of system fields. System fields appear at the start of a join,    * before the first field from the left input.    */
specifier|private
specifier|final
name|int
name|nSysFields
decl_stmt|;
comment|/**    * Expressions referenced in the projection/filter that should be preserved.    * In the case where the projection is being pushed past a join, then the    * list only contains the expressions corresponding to the left hand side of    * the join.    */
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|childPreserveExprs
decl_stmt|;
comment|/**    * Expressions referenced in the projection/filter that should be preserved,    * corresponding to expressions on the right hand side of the join, if the    * projection is being pushed past a join. Empty list otherwise.    */
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightPreserveExprs
decl_stmt|;
comment|/**    * Number of system fields being projected.    */
name|int
name|nSystemProject
decl_stmt|;
comment|/**    * Number of fields being projected. In the case where the projection is    * being pushed past a join, the number of fields being projected from the    * left hand side of the join.    */
name|int
name|nProject
decl_stmt|;
comment|/**    * Number of fields being projected from the right hand side of a join, in    * the case where the projection is being pushed past a join. 0 otherwise.    */
name|int
name|nRightProject
decl_stmt|;
comment|/**    * Rex builder used to create new expressions.    */
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a PushProjector object for pushing projects past a RelNode.    *    * @param origProj              the original projection that is being pushed;    *                              may be null if the projection is implied as a    *                              result of a projection having been trivially    *                              removed    * @param origFilter            the filter that the projection must also be    *                              pushed past, if applicable    * @param childRel              the RelNode that the projection is being    *                              pushed past    * @param preserveExprCondition condition for whether an expression should    *                              be preserved in the projection    */
specifier|public
name|PushProjector
parameter_list|(
annotation|@
name|Nullable
name|Project
name|origProj
parameter_list|,
annotation|@
name|Nullable
name|RexNode
name|origFilter
parameter_list|,
name|RelNode
name|childRel
parameter_list|,
name|ExprCondition
name|preserveExprCondition
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|)
block|{
name|this
operator|.
name|origProj
operator|=
name|origProj
expr_stmt|;
name|this
operator|.
name|origFilter
operator|=
name|origFilter
expr_stmt|;
name|this
operator|.
name|childRel
operator|=
name|childRel
expr_stmt|;
name|this
operator|.
name|preserveExprCondition
operator|=
name|preserveExprCondition
expr_stmt|;
name|this
operator|.
name|relBuilder
operator|=
name|requireNonNull
argument_list|(
name|relBuilder
argument_list|)
expr_stmt|;
if|if
condition|(
name|origProj
operator|==
literal|null
condition|)
block|{
name|origProjExprs
operator|=
name|ImmutableList
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|origProjExprs
operator|=
name|origProj
operator|.
name|getProjects
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|childRel
operator|instanceof
name|Join
condition|)
block|{
name|Join
name|join
init|=
operator|(
name|Join
operator|)
name|childRel
decl_stmt|;
name|childFields
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|join
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
expr_stmt|;
name|childFields
operator|.
name|addAll
argument_list|(
name|join
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|childFields
operator|=
name|childRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
expr_stmt|;
block|}
name|nChildFields
operator|=
name|childFields
operator|.
name|size
argument_list|()
expr_stmt|;
name|projRefs
operator|=
operator|new
name|BitSet
argument_list|(
name|nChildFields
argument_list|)
expr_stmt|;
if|if
condition|(
name|childRel
operator|instanceof
name|Join
condition|)
block|{
name|Join
name|joinRel
init|=
operator|(
name|Join
operator|)
name|childRel
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
name|joinRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
name|joinRel
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|nFields
operator|=
name|leftFields
operator|.
name|size
argument_list|()
expr_stmt|;
name|nFieldsRight
operator|=
name|rightFields
operator|.
name|size
argument_list|()
expr_stmt|;
name|nSysFields
operator|=
name|joinRel
operator|.
name|getSystemFieldList
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
name|childBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nFields
operator|+
name|nSysFields
argument_list|)
expr_stmt|;
name|rightBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nFields
operator|+
name|nSysFields
argument_list|,
name|nChildFields
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|joinRel
operator|.
name|getJoinType
argument_list|()
condition|)
block|{
case|case
name|INNER
case|:
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|of
argument_list|()
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
comment|// All the left-input's columns must be strong
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nFields
operator|+
name|nSysFields
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT
case|:
comment|// All the right-input's columns must be strong
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nFields
operator|+
name|nSysFields
argument_list|,
name|nChildFields
argument_list|)
expr_stmt|;
break|break;
case|case
name|FULL
case|:
default|default:
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
argument_list|,
name|nChildFields
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|childRel
operator|instanceof
name|Correlate
condition|)
block|{
name|Correlate
name|corrRel
init|=
operator|(
name|Correlate
operator|)
name|childRel
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
name|corrRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|rightFields
init|=
name|corrRel
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|nFields
operator|=
name|leftFields
operator|.
name|size
argument_list|()
expr_stmt|;
name|JoinRelType
name|joinType
init|=
name|corrRel
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|SEMI
case|:
case|case
name|ANTI
case|:
name|nFieldsRight
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|nFieldsRight
operator|=
name|rightFields
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|nSysFields
operator|=
literal|0
expr_stmt|;
name|childBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|nFields
argument_list|)
expr_stmt|;
name|rightBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nFields
argument_list|,
name|nChildFields
argument_list|)
expr_stmt|;
comment|// Required columns need to be included in project
name|projRefs
operator|.
name|or
argument_list|(
name|BitSets
operator|.
name|of
argument_list|(
name|corrRel
operator|.
name|getRequiredColumns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|INNER
case|:
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|of
argument_list|()
expr_stmt|;
break|break;
case|case
name|ANTI
case|:
case|case
name|SEMI
case|:
comment|// All the left-input's columns must be strong
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|nFields
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT
case|:
comment|// All the right-input's columns must be strong
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nFields
argument_list|,
name|nChildFields
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|nChildFields
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nFields
operator|=
name|nChildFields
expr_stmt|;
name|nFieldsRight
operator|=
literal|0
expr_stmt|;
name|childBitmap
operator|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nChildFields
argument_list|)
expr_stmt|;
name|rightBitmap
operator|=
literal|null
expr_stmt|;
name|nSysFields
operator|=
literal|0
expr_stmt|;
name|strongBitmap
operator|=
name|ImmutableBitSet
operator|.
name|of
argument_list|()
expr_stmt|;
block|}
assert|assert
name|nChildFields
operator|==
name|nSysFields
operator|+
name|nFields
operator|+
name|nFieldsRight
assert|;
name|childPreserveExprs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|rightPreserveExprs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|rexBuilder
operator|=
name|childRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Decomposes a projection to the input references referenced by a    * projection and a filter, either of which is optional. If both are    * provided, the filter is underneath the project.    *    *<p>Creates a projection containing all input references as well as    * preserving any special expressions. Converts the original projection    * and/or filter to reference the new projection. Then, finally puts on top,    * a final projection corresponding to the original projection.    *    * @param defaultExpr expression to be used in the projection if no fields    *                    or special columns are selected    * @return the converted projection if it makes sense to push elements of    * the projection; otherwise returns null    */
specifier|public
annotation|@
name|Nullable
name|RelNode
name|convertProject
parameter_list|(
annotation|@
name|Nullable
name|RexNode
name|defaultExpr
parameter_list|)
block|{
comment|// locate all fields referenced in the projection and filter
name|locateAllRefs
argument_list|()
expr_stmt|;
comment|// if all columns are being selected (either explicitly in the
comment|// projection) or via a "select *", then there needs to be some
comment|// special expressions to preserve in the projection; otherwise,
comment|// there's no point in proceeding any further
if|if
condition|(
name|origProj
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|childPreserveExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// even though there is no projection, this is the same as
comment|// selecting all fields
if|if
condition|(
name|nChildFields
operator|>
literal|0
condition|)
block|{
comment|// Calling with nChildFields == 0 should be safe but hits
comment|// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6222207
name|projRefs
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|nChildFields
argument_list|)
expr_stmt|;
block|}
name|nProject
operator|=
name|nChildFields
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|projRefs
operator|.
name|cardinality
argument_list|()
operator|==
name|nChildFields
operator|)
operator|&&
operator|(
name|childPreserveExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// if nothing is being selected from the underlying rel, just
comment|// project the default expression passed in as a parameter or the
comment|// first column if there is no default expression
if|if
condition|(
operator|(
name|projRefs
operator|.
name|cardinality
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|childPreserveExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|defaultExpr
operator|!=
literal|null
condition|)
block|{
name|childPreserveExprs
operator|.
name|add
argument_list|(
name|defaultExpr
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|nChildFields
operator|==
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|projRefs
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nProject
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|// create a new projection referencing all fields referenced in
comment|// either the project or the filter
name|RelNode
name|newProject
init|=
name|createProjectRefsAndExprs
argument_list|(
name|childRel
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
index|[]
name|adjustments
init|=
name|getAdjustments
argument_list|()
decl_stmt|;
comment|// if a filter was passed in, convert it to reference the projected
comment|// columns, placing it on top of the project just created
name|RelNode
name|projChild
decl_stmt|;
if|if
condition|(
name|origFilter
operator|!=
literal|null
condition|)
block|{
name|RexNode
name|newFilter
init|=
name|convertRefsAndExprs
argument_list|(
name|origFilter
argument_list|,
name|newProject
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|adjustments
argument_list|)
decl_stmt|;
name|relBuilder
operator|.
name|push
argument_list|(
name|newProject
argument_list|)
expr_stmt|;
name|relBuilder
operator|.
name|filter
argument_list|(
name|newFilter
argument_list|)
expr_stmt|;
name|projChild
operator|=
name|relBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|projChild
operator|=
name|newProject
expr_stmt|;
block|}
comment|// put the original project on top of the filter/project, converting
comment|// it to reference the modified projection list; otherwise, create
comment|// a projection that essentially selects all fields
return|return
name|createNewProject
argument_list|(
name|projChild
argument_list|,
name|adjustments
argument_list|)
return|;
block|}
comment|/**    * Locates all references found in either the projection expressions a    * filter, as well as references to expressions that should be preserved.    * Based on that, determines whether pushing the projection makes sense.    *    * @return true if all inputs from the child that the projection is being    * pushed past are referenced in the projection/filter and no special    * preserve expressions are referenced; in that case, it does not make sense    * to push the projection    */
specifier|public
name|boolean
name|locateAllRefs
parameter_list|()
block|{
name|RexUtil
operator|.
name|apply
argument_list|(
operator|new
name|InputSpecialOpFinder
argument_list|(
name|projRefs
argument_list|,
name|childBitmap
argument_list|,
name|rightBitmap
argument_list|,
name|requireNonNull
argument_list|(
name|strongBitmap
argument_list|,
literal|"strongBitmap"
argument_list|)
argument_list|,
name|preserveExprCondition
argument_list|,
name|childPreserveExprs
argument_list|,
name|rightPreserveExprs
argument_list|)
argument_list|,
name|origProjExprs
argument_list|,
name|origFilter
argument_list|)
expr_stmt|;
comment|// The system fields of each child are always used by the join, even if
comment|// they are not projected out of it.
name|projRefs
operator|.
name|set
argument_list|(
name|nSysFields
argument_list|,
name|nSysFields
operator|+
name|nSysFields
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|projRefs
operator|.
name|set
argument_list|(
name|nSysFields
operator|+
name|nFields
argument_list|,
name|nSysFields
operator|+
name|nFields
operator|+
name|nSysFields
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Count how many fields are projected.
name|nSystemProject
operator|=
literal|0
expr_stmt|;
name|nProject
operator|=
literal|0
expr_stmt|;
name|nRightProject
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|projRefs
argument_list|)
control|)
block|{
if|if
condition|(
name|bit
operator|<
name|nSysFields
condition|)
block|{
name|nSystemProject
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|bit
operator|<
name|nSysFields
operator|+
name|nFields
condition|)
block|{
name|nProject
operator|++
expr_stmt|;
block|}
else|else
block|{
name|nRightProject
operator|++
expr_stmt|;
block|}
block|}
assert|assert
name|nSystemProject
operator|+
name|nProject
operator|+
name|nRightProject
operator|==
name|projRefs
operator|.
name|cardinality
argument_list|()
assert|;
if|if
condition|(
operator|(
name|childRel
operator|instanceof
name|Join
operator|)
operator|||
operator|(
name|childRel
operator|instanceof
name|SetOp
operator|)
condition|)
block|{
comment|// if nothing is projected from the children, arbitrarily project
comment|// the first columns; this is necessary since Fennel doesn't
comment|// handle 0-column projections
if|if
condition|(
operator|(
name|nProject
operator|==
literal|0
operator|)
operator|&&
operator|(
name|childPreserveExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|projRefs
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nProject
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|childRel
operator|instanceof
name|Join
condition|)
block|{
if|if
condition|(
operator|(
name|nRightProject
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rightPreserveExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|projRefs
operator|.
name|set
argument_list|(
name|nFields
argument_list|)
expr_stmt|;
name|nRightProject
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|// no need to push projections if all children fields are being
comment|// referenced and there are no special preserve expressions; note
comment|// that we need to do this check after we've handled the 0-column
comment|// project cases
name|boolean
name|allFieldsReferenced
init|=
name|IntStream
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|nChildFields
argument_list|)
operator|.
name|allMatch
argument_list|(
name|i
lambda|->
name|projRefs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|allFieldsReferenced
operator|&&
name|childPreserveExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|rightPreserveExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Creates a projection based on the inputs specified in a bitmap and the    * expressions that need to be preserved. The expressions are appended after    * the input references.    *    * @param projChild child that the projection will be created on top of    * @param adjust    if true, need to create new projection expressions;    *                  otherwise, the existing ones are reused    * @param rightSide if true, creating a projection for the right hand side    *                  of a join    * @return created projection    */
specifier|public
name|Project
name|createProjectRefsAndExprs
parameter_list|(
name|RelNode
name|projChild
parameter_list|,
name|boolean
name|adjust
parameter_list|,
name|boolean
name|rightSide
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveExprs
decl_stmt|;
name|int
name|nInputRefs
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|rightSide
condition|)
block|{
name|preserveExprs
operator|=
name|rightPreserveExprs
expr_stmt|;
name|nInputRefs
operator|=
name|nRightProject
expr_stmt|;
name|offset
operator|=
name|nSysFields
operator|+
name|nFields
expr_stmt|;
block|}
else|else
block|{
name|preserveExprs
operator|=
name|childPreserveExprs
expr_stmt|;
name|nInputRefs
operator|=
name|nProject
expr_stmt|;
name|offset
operator|=
name|nSysFields
expr_stmt|;
block|}
name|int
name|refIdx
init|=
name|offset
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|newProjects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
init|=
name|projChild
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// add on the input references
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nInputRefs
condition|;
name|i
operator|++
control|)
block|{
name|refIdx
operator|=
name|projRefs
operator|.
name|nextSetBit
argument_list|(
name|refIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
assert|assert
name|refIdx
operator|>=
literal|0
assert|;
specifier|final
name|RelDataTypeField
name|destField
init|=
name|destFields
operator|.
name|get
argument_list|(
name|refIdx
operator|-
name|offset
argument_list|)
decl_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|destField
operator|.
name|getType
argument_list|()
argument_list|,
name|refIdx
operator|-
name|offset
argument_list|)
argument_list|,
name|destField
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// add on the expressions that need to be preserved, converting the
comment|// arguments to reference the projected columns (if necessary)
name|int
index|[]
name|adjustments
init|=
block|{}
decl_stmt|;
if|if
condition|(
operator|(
name|preserveExprs
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
name|adjust
condition|)
block|{
name|adjustments
operator|=
operator|new
name|int
index|[
name|childFields
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
name|offset
init|;
name|idx
operator|<
name|childFields
operator|.
name|size
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|adjustments
index|[
name|idx
index|]
operator|=
operator|-
name|offset
expr_stmt|;
block|}
block|}
for|for
control|(
name|RexNode
name|projExpr
range|:
name|preserveExprs
control|)
block|{
name|RexNode
name|newExpr
decl_stmt|;
if|if
condition|(
name|adjust
condition|)
block|{
name|newExpr
operator|=
name|projExpr
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|childFields
argument_list|,
name|destFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newExpr
operator|=
name|projExpr
expr_stmt|;
block|}
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
init|=
name|projChild
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|field
lambda|->
name|field
operator|.
name|getType
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|RexUtil
operator|.
name|FixNullabilityShuttle
name|fixer
init|=
operator|new
name|RexUtil
operator|.
name|FixNullabilityShuttle
argument_list|(
name|projChild
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|typeList
argument_list|)
decl_stmt|;
name|newExpr
operator|=
name|newExpr
operator|.
name|accept
argument_list|(
name|fixer
argument_list|)
expr_stmt|;
name|newProjects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|newExpr
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|projExpr
operator|)
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Project
operator|)
name|relBuilder
operator|.
name|push
argument_list|(
name|projChild
argument_list|)
operator|.
name|projectNamed
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|newProjects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|newProjects
argument_list|)
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Determines how much each input reference needs to be adjusted as a result    * of projection.    *    * @return array indicating how much each input needs to be adjusted by    */
specifier|public
name|int
index|[]
name|getAdjustments
parameter_list|()
block|{
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|nChildFields
index|]
decl_stmt|;
name|int
name|newIdx
init|=
literal|0
decl_stmt|;
name|int
name|rightOffset
init|=
name|childPreserveExprs
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|projRefs
argument_list|)
control|)
block|{
name|adjustments
index|[
name|pos
index|]
operator|=
operator|-
operator|(
name|pos
operator|-
name|newIdx
operator|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|nSysFields
operator|+
name|nFields
condition|)
block|{
name|adjustments
index|[
name|pos
index|]
operator|+=
name|rightOffset
expr_stmt|;
block|}
name|newIdx
operator|++
expr_stmt|;
block|}
return|return
name|adjustments
return|;
block|}
comment|/**    * Clones an expression tree and walks through it, adjusting each    * RexInputRef index by some amount, and converting expressions that need to    * be preserved to field references.    *    * @param rex         the expression    * @param destFields  fields that the new expressions will be referencing    * @param adjustments the amount each input reference index needs to be    *                    adjusted by    * @return modified expression tree    */
specifier|public
name|RexNode
name|convertRefsAndExprs
parameter_list|(
name|RexNode
name|rex
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
return|return
name|rex
operator|.
name|accept
argument_list|(
operator|new
name|RefAndExprConverter
argument_list|(
name|rexBuilder
argument_list|,
name|childFields
argument_list|,
name|destFields
argument_list|,
name|adjustments
argument_list|,
name|childPreserveExprs
argument_list|,
name|nProject
argument_list|,
name|rightPreserveExprs
argument_list|,
name|nProject
operator|+
name|childPreserveExprs
operator|.
name|size
argument_list|()
operator|+
name|nRightProject
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a new projection based on the original projection, adjusting all    * input refs using an adjustment array passed in. If there was no original    * projection, create a new one that selects every field from the underlying    * rel.    *    *<p>If the resulting projection would be trivial, return the child.    *    * @param projChild   child of the new project    * @param adjustments array indicating how much each input reference should    *                    be adjusted by    * @return the created projection    */
specifier|public
name|RelNode
name|createNewProject
parameter_list|(
name|RelNode
name|projChild
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|origProj
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|p
range|:
name|origProj
operator|.
name|getNamedProjects
argument_list|()
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|convertRefsAndExprs
argument_list|(
name|p
operator|.
name|left
argument_list|,
name|projChild
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|adjustments
argument_list|)
argument_list|,
name|p
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|Ord
argument_list|<
name|RelDataTypeField
argument_list|>
name|field
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|childFields
argument_list|)
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|e
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|i
argument_list|)
argument_list|,
name|field
operator|.
name|e
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|relBuilder
operator|.
name|push
argument_list|(
name|projChild
argument_list|)
operator|.
name|project
argument_list|(
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Visitor which builds a bitmap of the inputs used by an expressions, as    * well as locating expressions corresponding to special operators.    */
specifier|private
specifier|static
class|class
name|InputSpecialOpFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|BitSet
name|rexRefs
decl_stmt|;
specifier|private
specifier|final
name|ImmutableBitSet
name|leftFields
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|ImmutableBitSet
name|rightFields
decl_stmt|;
specifier|private
specifier|final
name|ImmutableBitSet
name|strongFields
decl_stmt|;
specifier|private
specifier|final
name|ExprCondition
name|preserveExprCondition
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveLeft
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveRight
decl_stmt|;
specifier|private
specifier|final
name|Strong
name|strong
decl_stmt|;
name|InputSpecialOpFinder
parameter_list|(
name|BitSet
name|rexRefs
parameter_list|,
name|ImmutableBitSet
name|leftFields
parameter_list|,
annotation|@
name|Nullable
name|ImmutableBitSet
name|rightFields
parameter_list|,
specifier|final
name|ImmutableBitSet
name|strongFields
parameter_list|,
name|ExprCondition
name|preserveExprCondition
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveLeft
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveRight
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|rexRefs
operator|=
name|rexRefs
expr_stmt|;
name|this
operator|.
name|leftFields
operator|=
name|leftFields
expr_stmt|;
name|this
operator|.
name|rightFields
operator|=
name|rightFields
expr_stmt|;
name|this
operator|.
name|preserveExprCondition
operator|=
name|preserveExprCondition
expr_stmt|;
name|this
operator|.
name|preserveLeft
operator|=
name|preserveLeft
expr_stmt|;
name|this
operator|.
name|preserveRight
operator|=
name|preserveRight
expr_stmt|;
name|this
operator|.
name|strongFields
operator|=
name|strongFields
expr_stmt|;
name|this
operator|.
name|strong
operator|=
name|Strong
operator|.
name|of
argument_list|(
name|strongFields
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
name|preserve
argument_list|(
name|call
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|boolean
name|isStrong
parameter_list|(
specifier|final
name|ImmutableBitSet
name|exprArgs
parameter_list|,
specifier|final
name|RexNode
name|call
parameter_list|)
block|{
comment|// If the expressions do not use any of the inputs that require output to be null,
comment|// no need to check.  Otherwise, check that the expression is null.
comment|// For example, in an "left outer join", we don't require that expressions
comment|// pushed down into the left input to be strong.  On the other hand,
comment|// expressions pushed into the right input must be.  In that case,
comment|// strongFields == right input fields.
return|return
operator|!
name|strongFields
operator|.
name|intersects
argument_list|(
name|exprArgs
argument_list|)
operator|||
name|strong
operator|.
name|isNull
argument_list|(
name|call
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|preserve
parameter_list|(
name|RexNode
name|call
parameter_list|)
block|{
if|if
condition|(
name|preserveExprCondition
operator|.
name|test
argument_list|(
name|call
argument_list|)
condition|)
block|{
comment|// if the arguments of the expression only reference the
comment|// left hand side, preserve it on the left; similarly, if
comment|// it only references expressions on the right
specifier|final
name|ImmutableBitSet
name|exprArgs
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprArgs
operator|.
name|cardinality
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|leftFields
operator|.
name|contains
argument_list|(
name|exprArgs
argument_list|)
operator|&&
name|isStrong
argument_list|(
name|exprArgs
argument_list|,
name|call
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|preserveLeft
operator|.
name|contains
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|preserveLeft
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|else if
condition|(
name|requireNonNull
argument_list|(
name|rightFields
argument_list|,
literal|"rightFields"
argument_list|)
operator|.
name|contains
argument_list|(
name|exprArgs
argument_list|)
operator|&&
name|isStrong
argument_list|(
name|exprArgs
argument_list|,
name|call
argument_list|)
condition|)
block|{
assert|assert
name|preserveRight
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|preserveRight
operator|.
name|contains
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|preserveRight
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|// if the expression arguments reference both the left and
comment|// right, fall through and don't attempt to preserve the
comment|// expression, but instead locate references and special
comment|// ops in the call operands
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
name|rexRefs
operator|.
name|set
argument_list|(
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Walks an expression tree, replacing input refs with new values to reflect    * projection and converting special expressions to field references.    */
specifier|private
specifier|static
class|class
name|RefAndExprConverter
extends|extends
name|RelOptUtil
operator|.
name|RexInputConverter
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveLeft
decl_stmt|;
specifier|private
specifier|final
name|int
name|firstLeftRef
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveRight
decl_stmt|;
specifier|private
specifier|final
name|int
name|firstRightRef
decl_stmt|;
name|RefAndExprConverter
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|srcFields
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|destFields
parameter_list|,
name|int
index|[]
name|adjustments
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveLeft
parameter_list|,
name|int
name|firstLeftRef
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|preserveRight
parameter_list|,
name|int
name|firstRightRef
parameter_list|)
block|{
name|super
argument_list|(
name|rexBuilder
argument_list|,
name|srcFields
argument_list|,
name|destFields
argument_list|,
name|adjustments
argument_list|)
expr_stmt|;
name|this
operator|.
name|preserveLeft
operator|=
name|preserveLeft
expr_stmt|;
name|this
operator|.
name|firstLeftRef
operator|=
name|firstLeftRef
expr_stmt|;
name|this
operator|.
name|preserveRight
operator|=
name|preserveRight
expr_stmt|;
name|this
operator|.
name|firstRightRef
operator|=
name|firstRightRef
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|RexNode
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
comment|// if the expression corresponds to one that needs to be preserved,
comment|// convert it to a field reference; otherwise, convert the entire
comment|// expression
name|int
name|match
init|=
name|findExprInLists
argument_list|(
name|call
argument_list|,
name|preserveLeft
argument_list|,
name|firstLeftRef
argument_list|,
name|preserveRight
argument_list|,
name|firstRightRef
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|>=
literal|0
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|requireNonNull
argument_list|(
name|destFields
argument_list|,
literal|"destFields"
argument_list|)
operator|.
name|get
argument_list|(
name|match
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|match
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|visitCall
argument_list|(
name|call
argument_list|)
return|;
block|}
comment|/**      * Looks for a matching RexNode from among two lists of RexNodes and      * returns the offset into the list corresponding to the match, adjusted      * by an amount, depending on whether the match was from the first or      * second list.      *      * @param rex      RexNode that is being matched against      * @param rexList1 first list of RexNodes      * @param adjust1  adjustment if match occurred in first list      * @param rexList2 second list of RexNodes      * @param adjust2  adjustment if match occurred in the second list      * @return index in the list corresponding to the matching RexNode; -1      * if no match      */
specifier|private
name|int
name|findExprInLists
parameter_list|(
name|RexNode
name|rex
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList1
parameter_list|,
name|int
name|adjust1
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rexList2
parameter_list|,
name|int
name|adjust2
parameter_list|)
block|{
name|int
name|match
init|=
name|rexList1
operator|.
name|indexOf
argument_list|(
name|rex
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|>=
literal|0
condition|)
block|{
return|return
name|match
operator|+
name|adjust1
return|;
block|}
if|if
condition|(
name|rexList2
operator|!=
literal|null
condition|)
block|{
name|match
operator|=
name|rexList2
operator|.
name|indexOf
argument_list|(
name|rex
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|>=
literal|0
condition|)
block|{
return|return
name|match
operator|+
name|adjust2
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * A functor that replies true or false for a given expression.    *    * @see org.apache.calcite.rel.rules.PushProjector.OperatorExprCondition    */
specifier|public
interface|interface
name|ExprCondition
extends|extends
name|Predicate
argument_list|<
name|RexNode
argument_list|>
block|{
comment|/**      * Evaluates a condition for a given expression.      *      * @param expr Expression      * @return result of evaluating the condition      */
annotation|@
name|Override
name|boolean
name|test
parameter_list|(
name|RexNode
name|expr
parameter_list|)
function_decl|;
comment|/**      * Constant condition that replies {@code false} for all expressions.      */
name|ExprCondition
name|FALSE
init|=
name|expr
lambda|->
literal|false
decl_stmt|;
comment|/**      * Constant condition that replies {@code true} for all expressions.      */
name|ExprCondition
name|TRUE
init|=
name|expr
lambda|->
literal|true
decl_stmt|;
block|}
comment|/**    * An expression condition that evaluates to true if the expression is    * a call to one of a set of operators.    */
specifier|static
class|class
name|OperatorExprCondition
implements|implements
name|ExprCondition
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|SqlOperator
argument_list|>
name|operatorSet
decl_stmt|;
comment|/**      * Creates an OperatorExprCondition.      *      * @param operatorSet Set of operators      */
name|OperatorExprCondition
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|SqlOperator
argument_list|>
name|operatorSet
parameter_list|)
block|{
name|this
operator|.
name|operatorSet
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|operatorSet
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|test
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
return|return
name|expr
operator|instanceof
name|RexCall
operator|&&
name|operatorSet
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

