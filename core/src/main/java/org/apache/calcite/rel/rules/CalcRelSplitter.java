begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Calc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|logical
operator|.
name|LogicalCalc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexFieldAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|IntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultDirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DefaultEdge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|DirectedGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|graph
operator|.
name|TopologicalOrderIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/**  * CalcRelSplitter operates on a  * {@link org.apache.calcite.rel.core.Calc} with multiple {@link RexCall}  * sub-expressions that cannot all be implemented by a single concrete  * {@link RelNode}.  *  *<p>For example, the Java and Fennel calculator do not implement an identical  * set of operators. The Calc can be used to split a single Calc with  * mixed Java- and Fennel-only operators into a tree of Calc object that can  * each be individually implemented by either Java or Fennel.and splits it into  * several Calc instances.  *  *<p>Currently the splitter is only capable of handling two "rel types". That  * is, it can deal with Java vs. Fennel Calcs, but not Java vs. Fennel vs.  * some other type of Calc.  *  *<p>See {@link ProjectToWindowRule}  * for an example of how this class is used.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|CalcRelSplitter
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|private
specifier|static
specifier|final
name|Logger
name|RULE_LOGGER
init|=
name|RelOptPlanner
operator|.
name|LOGGER
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|protected
specifier|final
name|RexProgram
name|program
decl_stmt|;
specifier|private
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|private
specifier|final
name|RelType
index|[]
name|relTypes
decl_stmt|;
specifier|private
specifier|final
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|private
specifier|final
name|RelTraitSet
name|traits
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|child
decl_stmt|;
specifier|protected
specifier|final
name|RelBuilder
name|relBuilder
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Constructs a CalcRelSplitter.    *    * @param calc     Calc to split    * @param relTypes Array of rel types, e.g. {Java, Fennel}. Must be    *                 distinct.    */
name|CalcRelSplitter
parameter_list|(
name|Calc
name|calc
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|RelType
index|[]
name|relTypes
parameter_list|)
block|{
name|this
operator|.
name|relBuilder
operator|=
name|relBuilder
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relTypes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
assert|assert
name|relTypes
index|[
name|i
index|]
operator|!=
literal|null
assert|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
assert|assert
name|relTypes
index|[
name|i
index|]
operator|!=
name|relTypes
index|[
name|j
index|]
operator|:
literal|"Rel types must be distinct"
assert|;
block|}
block|}
name|this
operator|.
name|program
operator|=
name|calc
operator|.
name|getProgram
argument_list|()
expr_stmt|;
name|this
operator|.
name|cluster
operator|=
name|calc
operator|.
name|getCluster
argument_list|()
expr_stmt|;
name|this
operator|.
name|traits
operator|=
name|calc
operator|.
name|getTraitSet
argument_list|()
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|calc
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
expr_stmt|;
name|this
operator|.
name|child
operator|=
name|calc
operator|.
name|getInput
argument_list|()
expr_stmt|;
name|this
operator|.
name|relTypes
operator|=
name|relTypes
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
name|RelNode
name|execute
parameter_list|()
block|{
comment|// Check that program is valid. In particular, this means that every
comment|// expression is trivial (either an atom, or a function applied to
comment|// references to atoms) and every expression depends only on
comment|// expressions to the left.
assert|assert
name|program
operator|.
name|isValid
argument_list|(
name|Litmus
operator|.
name|THROW
argument_list|)
assert|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
name|program
operator|.
name|getExprList
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
index|[]
name|exprs
init|=
name|exprList
operator|.
name|toArray
argument_list|(
operator|new
name|RexNode
index|[
name|exprList
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
assert|assert
operator|!
name|RexUtil
operator|.
name|containComplexExprs
argument_list|(
name|exprList
argument_list|)
assert|;
comment|// Figure out what level each expression belongs to.
name|int
index|[]
name|exprLevels
init|=
operator|new
name|int
index|[
name|exprs
operator|.
name|length
index|]
decl_stmt|;
comment|// The type of a level is given by
comment|// relTypes[levelTypeOrdinals[level]].
name|int
index|[]
name|levelTypeOrdinals
init|=
operator|new
name|int
index|[
name|exprs
operator|.
name|length
index|]
decl_stmt|;
name|int
name|levelCount
init|=
name|chooseLevels
argument_list|(
name|exprs
argument_list|,
operator|-
literal|1
argument_list|,
name|exprLevels
argument_list|,
name|levelTypeOrdinals
argument_list|)
decl_stmt|;
comment|// For each expression, figure out which is the highest level where it
comment|// is used.
name|int
index|[]
name|exprMaxUsingLevelOrdinals
init|=
operator|new
name|HighestUsageFinder
argument_list|(
name|exprs
argument_list|,
name|exprLevels
argument_list|)
operator|.
name|getMaxUsingLevelOrdinals
argument_list|()
decl_stmt|;
comment|// If expressions are used as outputs, mark them as higher than that.
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefList
init|=
name|program
operator|.
name|getProjectList
argument_list|()
decl_stmt|;
specifier|final
name|RexLocalRef
name|conditionRef
init|=
name|program
operator|.
name|getCondition
argument_list|()
decl_stmt|;
for|for
control|(
name|RexLocalRef
name|projectRef
range|:
name|projectRefList
control|)
block|{
name|exprMaxUsingLevelOrdinals
index|[
name|projectRef
operator|.
name|getIndex
argument_list|()
index|]
operator|=
name|levelCount
expr_stmt|;
block|}
if|if
condition|(
name|conditionRef
operator|!=
literal|null
condition|)
block|{
name|exprMaxUsingLevelOrdinals
index|[
name|conditionRef
operator|.
name|getIndex
argument_list|()
index|]
operator|=
name|levelCount
expr_stmt|;
block|}
comment|// Print out what we've got.
if|if
condition|(
name|RULE_LOGGER
operator|.
name|isLoggable
argument_list|(
name|Level
operator|.
name|FINER
argument_list|)
condition|)
block|{
name|traceLevelExpressions
argument_list|(
name|exprs
argument_list|,
name|exprLevels
argument_list|,
name|levelTypeOrdinals
argument_list|,
name|levelCount
argument_list|)
expr_stmt|;
block|}
comment|// Now build the calcs.
name|RelNode
name|rel
init|=
name|child
decl_stmt|;
specifier|final
name|int
name|inputFieldCount
init|=
name|program
operator|.
name|getInputRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
index|[]
name|inputExprOrdinals
init|=
name|identityArray
argument_list|(
name|inputFieldCount
argument_list|)
decl_stmt|;
name|boolean
name|doneCondition
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
specifier|final
name|int
index|[]
name|projectExprOrdinals
decl_stmt|;
specifier|final
name|RelDataType
name|outputRowType
decl_stmt|;
if|if
condition|(
name|level
operator|==
operator|(
name|levelCount
operator|-
literal|1
operator|)
condition|)
block|{
name|outputRowType
operator|=
name|program
operator|.
name|getOutputRowType
argument_list|()
expr_stmt|;
name|projectExprOrdinals
operator|=
operator|new
name|int
index|[
name|projectRefList
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projectExprOrdinals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|projectExprOrdinals
index|[
name|i
index|]
operator|=
name|projectRefList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getIndex
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|outputRowType
operator|=
literal|null
expr_stmt|;
comment|// Project the expressions which are computed at this level or
comment|// before, and will be used at later levels.
name|IntList
name|projectExprOrdinalList
init|=
operator|new
name|IntList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|RexLiteral
condition|)
block|{
comment|// Don't project literals. They are always created in
comment|// the level where they are used.
name|exprLevels
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|exprLevels
index|[
name|i
index|]
operator|<=
name|level
operator|)
operator|&&
operator|(
name|exprMaxUsingLevelOrdinals
index|[
name|i
index|]
operator|>
name|level
operator|)
condition|)
block|{
name|projectExprOrdinalList
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|projectExprOrdinals
operator|=
name|projectExprOrdinalList
operator|.
name|toIntArray
argument_list|()
expr_stmt|;
block|}
specifier|final
name|RelType
name|relType
init|=
name|relTypes
index|[
name|levelTypeOrdinals
index|[
name|level
index|]
index|]
decl_stmt|;
comment|// Can we do the condition this level?
name|int
name|conditionExprOrdinal
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|conditionRef
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|doneCondition
condition|)
block|{
name|conditionExprOrdinal
operator|=
name|conditionRef
operator|.
name|getIndex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|exprLevels
index|[
name|conditionExprOrdinal
index|]
operator|>
name|level
operator|)
operator|||
operator|!
name|relType
operator|.
name|supportsCondition
argument_list|()
condition|)
block|{
comment|// stand down -- we're not ready to do the condition yet
name|conditionExprOrdinal
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|doneCondition
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|RexProgram
name|program1
init|=
name|createProgramForLevel
argument_list|(
name|level
argument_list|,
name|levelCount
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|exprs
argument_list|,
name|exprLevels
argument_list|,
name|inputExprOrdinals
argument_list|,
name|projectExprOrdinals
argument_list|,
name|conditionExprOrdinal
argument_list|,
name|outputRowType
argument_list|)
decl_stmt|;
name|rel
operator|=
name|relType
operator|.
name|makeRel
argument_list|(
name|cluster
argument_list|,
name|traits
argument_list|,
name|relBuilder
argument_list|,
name|rel
argument_list|,
name|program1
argument_list|)
expr_stmt|;
comment|// Sometimes a level's program merely projects its inputs. We don't
comment|// want these. They cause an explosion in the search space.
if|if
condition|(
name|rel
operator|instanceof
name|LogicalCalc
operator|&&
operator|(
operator|(
name|LogicalCalc
operator|)
name|rel
operator|)
operator|.
name|getProgram
argument_list|()
operator|.
name|isTrivial
argument_list|()
condition|)
block|{
name|rel
operator|=
name|rel
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|rel
operator|=
name|handle
argument_list|(
name|rel
argument_list|)
expr_stmt|;
comment|// The outputs of this level will be the inputs to the next level.
name|inputExprOrdinals
operator|=
name|projectExprOrdinals
expr_stmt|;
block|}
name|Util
operator|.
name|permAssert
argument_list|(
name|doneCondition
operator|||
operator|(
name|conditionRef
operator|==
literal|null
operator|)
argument_list|,
literal|"unhandled condition"
argument_list|)
expr_stmt|;
return|return
name|rel
return|;
block|}
comment|/**    * Opportunity to further refine the relational expression created for a    * given level. The default implementation returns the relational expression    * unchanged.    */
specifier|protected
name|RelNode
name|handle
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|rel
return|;
block|}
comment|/**    * Figures out which expressions to calculate at which level.    *    * @param exprs             Array of expressions    * @param conditionOrdinal  Ordinal of the condition expression, or -1 if no    *                          condition    * @param exprLevels        Level ordinal for each expression (output)    * @param levelTypeOrdinals The type of each level (output)    * @return Number of levels required    */
specifier|private
name|int
name|chooseLevels
parameter_list|(
specifier|final
name|RexNode
index|[]
name|exprs
parameter_list|,
name|int
name|conditionOrdinal
parameter_list|,
name|int
index|[]
name|exprLevels
parameter_list|,
name|int
index|[]
name|levelTypeOrdinals
parameter_list|)
block|{
specifier|final
name|int
name|inputFieldCount
init|=
name|program
operator|.
name|getInputRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|levelCount
init|=
literal|0
decl_stmt|;
specifier|final
name|MaxInputFinder
name|maxInputFinder
init|=
operator|new
name|MaxInputFinder
argument_list|(
name|exprLevels
argument_list|)
decl_stmt|;
name|boolean
index|[]
name|relTypesPossibleForTopLevel
init|=
operator|new
name|boolean
index|[
name|relTypes
operator|.
name|length
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|relTypesPossibleForTopLevel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Compute the order in which to visit expressions.
specifier|final
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|cohorts
init|=
name|getCohorts
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|permutation
init|=
name|computeTopologicalOrdering
argument_list|(
name|exprs
argument_list|,
name|cohorts
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|permutation
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|boolean
name|condition
init|=
name|i
operator|==
name|conditionOrdinal
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|inputFieldCount
condition|)
block|{
assert|assert
name|expr
operator|instanceof
name|RexInputRef
assert|;
name|exprLevels
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
comment|// Deduce the minimum level of the expression. An expression must
comment|// be at a level greater than or equal to all of its inputs.
name|int
name|level
init|=
name|maxInputFinder
operator|.
name|maxInputFor
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|// If the expression is in a cohort, it can occur no lower than the
comment|// levels of other expressions in the same cohort.
name|Set
argument_list|<
name|Integer
argument_list|>
name|cohort
init|=
name|findCohort
argument_list|(
name|cohorts
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cohort
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Integer
name|exprOrdinal
range|:
name|cohort
control|)
block|{
if|if
condition|(
name|exprOrdinal
operator|==
name|i
condition|)
block|{
comment|// Already did this member of the cohort. It's a waste
comment|// of effort to repeat.
continue|continue;
block|}
specifier|final
name|RexNode
name|cohortExpr
init|=
name|exprs
index|[
name|exprOrdinal
index|]
decl_stmt|;
name|int
name|cohortLevel
init|=
name|maxInputFinder
operator|.
name|maxInputFor
argument_list|(
name|cohortExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cohortLevel
operator|>
name|level
condition|)
block|{
name|level
operator|=
name|cohortLevel
expr_stmt|;
block|}
block|}
block|}
comment|// Try to implement this expression at this level.
comment|// If that is not possible, try to implement it at higher levels.
name|levelLoop
label|:
for|for
control|(
init|;
condition|;
operator|++
name|level
control|)
block|{
if|if
condition|(
name|level
operator|>=
name|levelCount
condition|)
block|{
comment|// This is a new level. We can use any type we like.
for|for
control|(
name|int
name|relTypeOrdinal
init|=
literal|0
init|;
name|relTypeOrdinal
operator|<
name|relTypes
operator|.
name|length
condition|;
name|relTypeOrdinal
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|relTypesPossibleForTopLevel
index|[
name|relTypeOrdinal
index|]
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|relTypes
index|[
name|relTypeOrdinal
index|]
operator|.
name|canImplement
argument_list|(
name|expr
argument_list|,
name|condition
argument_list|)
condition|)
block|{
comment|// Success. We have found a type where we can
comment|// implement this expression.
name|exprLevels
index|[
name|i
index|]
operator|=
name|level
expr_stmt|;
name|levelTypeOrdinals
index|[
name|level
index|]
operator|=
name|relTypeOrdinal
expr_stmt|;
assert|assert
operator|(
name|level
operator|==
literal|0
operator|)
operator|||
operator|(
name|levelTypeOrdinals
index|[
name|level
operator|-
literal|1
index|]
operator|!=
name|levelTypeOrdinals
index|[
name|level
index|]
operator|)
operator|:
literal|"successive levels of same type"
assert|;
comment|// Figure out which of the other reltypes are
comment|// still possible for this level.
comment|// Previous reltypes are not possible.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|relTypeOrdinal
condition|;
operator|++
name|j
control|)
block|{
name|relTypesPossibleForTopLevel
index|[
name|j
index|]
operator|=
literal|false
expr_stmt|;
block|}
comment|// Successive reltypes may be possible.
for|for
control|(
name|int
name|j
init|=
name|relTypeOrdinal
operator|+
literal|1
init|;
name|j
operator|<
name|relTypes
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|relTypesPossibleForTopLevel
index|[
name|j
index|]
condition|)
block|{
name|relTypesPossibleForTopLevel
index|[
name|j
index|]
operator|=
name|relTypes
index|[
name|j
index|]
operator|.
name|canImplement
argument_list|(
name|expr
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Move to next level.
name|levelTypeOrdinals
index|[
name|levelCount
index|]
operator|=
name|firstSet
argument_list|(
name|relTypesPossibleForTopLevel
argument_list|)
expr_stmt|;
operator|++
name|levelCount
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|relTypesPossibleForTopLevel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break
name|levelLoop
break|;
block|}
block|}
comment|// None of the reltypes still active for this level could
comment|// implement expr. But maybe we could succeed with a new
comment|// level, with all options open?
if|if
condition|(
name|count
argument_list|(
name|relTypesPossibleForTopLevel
argument_list|)
operator|>=
name|relTypes
operator|.
name|length
condition|)
block|{
comment|// Cannot implement for any type.
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"cannot implement "
operator|+
name|expr
argument_list|)
throw|;
block|}
name|levelTypeOrdinals
index|[
name|levelCount
index|]
operator|=
name|firstSet
argument_list|(
name|relTypesPossibleForTopLevel
argument_list|)
expr_stmt|;
operator|++
name|levelCount
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|relTypesPossibleForTopLevel
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|levelTypeOrdinal
init|=
name|levelTypeOrdinals
index|[
name|level
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|relTypes
index|[
name|levelTypeOrdinal
index|]
operator|.
name|canImplement
argument_list|(
name|expr
argument_list|,
name|condition
argument_list|)
condition|)
block|{
comment|// Cannot implement this expression in this type;
comment|// continue to next level.
continue|continue;
block|}
name|exprLevels
index|[
name|i
index|]
operator|=
name|level
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|levelCount
operator|>
literal|0
condition|)
block|{
comment|// The latest level should be CalcRelType otherwise literals cannot be
comment|// implemented.
assert|assert
literal|"CalcRelType"
operator|.
name|equals
argument_list|(
name|relTypes
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
operator|:
literal|"The first RelType should be CalcRelType for proper RexLiteral"
operator|+
literal|" implementation at the last level, got "
operator|+
name|relTypes
index|[
literal|0
index|]
operator|.
name|name
assert|;
if|if
condition|(
name|levelTypeOrdinals
index|[
name|levelCount
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|levelCount
operator|++
expr_stmt|;
block|}
block|}
return|return
name|levelCount
return|;
block|}
comment|/**    * Computes the order in which to visit expressions, so that we decide the    * level of an expression only after the levels of lower expressions have    * been decided.    *    *<p>First, we need to ensure that an expression is visited after all of    * its inputs.    *    *<p>Further, if the expression is a member of a cohort, we need to visit    * it after the inputs of all other expressions in that cohort. With this    * condition, expressions in the same cohort will very likely end up in the    * same level.    *    *<p>Note that if there are no cohorts, the expressions from the    * {@link RexProgram} are already in a suitable order. We perform the    * topological sort just to ensure that the code path is well-trodden.    *    * @param exprs   Expressions    * @param cohorts List of cohorts, each of which is a set of expr ordinals    * @return Expression ordinals in topological order    */
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|computeTopologicalOrdering
parameter_list|(
name|RexNode
index|[]
name|exprs
parameter_list|,
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|cohorts
parameter_list|)
block|{
specifier|final
name|DirectedGraph
argument_list|<
name|Integer
argument_list|,
name|DefaultEdge
argument_list|>
name|graph
init|=
name|DefaultDirectedGraph
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|graph
operator|.
name|addVertex
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RexNode
name|expr
init|=
name|exprs
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|cohort
init|=
name|findCohort
argument_list|(
name|cohorts
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|targets
decl_stmt|;
if|if
condition|(
name|cohort
operator|==
literal|null
condition|)
block|{
name|targets
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targets
operator|=
name|cohort
expr_stmt|;
block|}
name|expr
operator|.
name|accept
argument_list|(
operator|new
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
argument_list|(
literal|true
argument_list|)
block|{
specifier|public
name|Void
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
for|for
control|(
name|Integer
name|target
range|:
name|targets
control|)
block|{
name|graph
operator|.
name|addEdge
argument_list|(
name|localRef
operator|.
name|getIndex
argument_list|()
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|TopologicalOrderIterator
argument_list|<
name|Integer
argument_list|,
name|DefaultEdge
argument_list|>
name|iter
init|=
operator|new
name|TopologicalOrderIterator
argument_list|<>
argument_list|(
name|graph
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|permutation
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|permutation
operator|.
name|add
argument_list|(
name|iter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|permutation
return|;
block|}
comment|/**    * Finds the cohort that contains the given integer, or returns null.    *    * @param cohorts List of cohorts, each a set of integers    * @param ordinal Integer to search for    * @return Cohort that contains the integer, or null if not found    */
specifier|private
specifier|static
name|Set
argument_list|<
name|Integer
argument_list|>
name|findCohort
parameter_list|(
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|cohorts
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
for|for
control|(
name|Set
argument_list|<
name|Integer
argument_list|>
name|cohort
range|:
name|cohorts
control|)
block|{
if|if
condition|(
name|cohort
operator|.
name|contains
argument_list|(
name|ordinal
argument_list|)
condition|)
block|{
return|return
name|cohort
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|int
index|[]
name|identityArray
parameter_list|(
name|int
name|length
parameter_list|)
block|{
specifier|final
name|int
index|[]
name|ints
init|=
operator|new
name|int
index|[
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ints
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ints
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
return|return
name|ints
return|;
block|}
comment|/**    * Creates a program containing the expressions for a given level.    *    *<p>The expression list of the program will consist of all entries in the    * expression list<code>allExprs[i]</code> for which the corresponding    * level ordinal<code>exprLevels[i]</code> is equal to<code>level</code>.    * Expressions are mapped according to<code>inputExprOrdinals</code>.    *    * @param level                Level ordinal    * @param levelCount           Number of levels    * @param inputRowType         Input row type    * @param allExprs             Array of all expressions    * @param exprLevels           Array of the level ordinal of each expression    * @param inputExprOrdinals    Ordinals in the expression list of input    *                             expressions. Input expression<code>i</code>    *                             will be found at position    *<code>inputExprOrdinals[i]</code>.    * @param projectExprOrdinals  Ordinals of the expressions to be output this    *                             level.    * @param conditionExprOrdinal Ordinal of the expression to form the    *                             condition for this level, or -1 if there is no    *                             condition.    * @param outputRowType        Output row type    * @return Relational expression    */
specifier|private
name|RexProgram
name|createProgramForLevel
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|levelCount
parameter_list|,
name|RelDataType
name|inputRowType
parameter_list|,
name|RexNode
index|[]
name|allExprs
parameter_list|,
name|int
index|[]
name|exprLevels
parameter_list|,
name|int
index|[]
name|inputExprOrdinals
parameter_list|,
specifier|final
name|int
index|[]
name|projectExprOrdinals
parameter_list|,
name|int
name|conditionExprOrdinal
parameter_list|,
name|RelDataType
name|outputRowType
parameter_list|)
block|{
comment|// Build a list of expressions to form the calc.
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// exprInverseOrdinals describes where an expression in allExprs comes
comment|// from -- from an input, from a calculated expression, or -1 if not
comment|// available at this level.
name|int
index|[]
name|exprInverseOrdinals
init|=
operator|new
name|int
index|[
name|allExprs
operator|.
name|length
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|exprInverseOrdinals
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
comment|// First populate the inputs. They were computed at some previous level
comment|// and are used here.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputExprOrdinals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|inputExprOrdinal
init|=
name|inputExprOrdinals
index|[
name|i
index|]
decl_stmt|;
name|exprs
operator|.
name|add
argument_list|(
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|allExprs
index|[
name|inputExprOrdinal
index|]
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|exprInverseOrdinals
index|[
name|inputExprOrdinal
index|]
operator|=
name|j
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
comment|// Next populate the computed expressions.
specifier|final
name|RexShuttle
name|shuttle
init|=
operator|new
name|InputToCommonExprConverter
argument_list|(
name|exprInverseOrdinals
argument_list|,
name|exprLevels
argument_list|,
name|level
argument_list|,
name|inputExprOrdinals
argument_list|,
name|allExprs
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allExprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|exprLevels
index|[
name|i
index|]
operator|==
name|level
operator|||
name|exprLevels
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|&&
name|level
operator|==
operator|(
name|levelCount
operator|-
literal|1
operator|)
operator|&&
name|allExprs
index|[
name|i
index|]
operator|instanceof
name|RexLiteral
condition|)
block|{
name|RexNode
name|expr
init|=
name|allExprs
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|RexNode
name|translatedExpr
init|=
name|expr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
name|exprs
operator|.
name|add
argument_list|(
name|translatedExpr
argument_list|)
expr_stmt|;
assert|assert
name|exprInverseOrdinals
index|[
name|i
index|]
operator|==
operator|-
literal|1
assert|;
name|exprInverseOrdinals
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
comment|// Form the projection and condition list. Project and condition
comment|// ordinals are offsets into allExprs, so we need to map them into
comment|// exprs.
specifier|final
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projectRefs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|projectExprOrdinals
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|projectExprOrdinals
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projectExprOrdinals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|projectExprOrdinal
init|=
name|projectExprOrdinals
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|index
init|=
name|exprInverseOrdinals
index|[
name|projectExprOrdinal
index|]
decl_stmt|;
assert|assert
name|index
operator|>=
literal|0
assert|;
name|RexNode
name|expr
init|=
name|allExprs
index|[
name|projectExprOrdinal
index|]
decl_stmt|;
name|projectRefs
operator|.
name|add
argument_list|(
operator|new
name|RexLocalRef
argument_list|(
name|index
argument_list|,
name|expr
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Inherit meaningful field name if possible.
name|fieldNames
operator|.
name|add
argument_list|(
name|deriveFieldName
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexLocalRef
name|conditionRef
decl_stmt|;
if|if
condition|(
name|conditionExprOrdinal
operator|>=
literal|0
condition|)
block|{
specifier|final
name|int
name|index
init|=
name|exprInverseOrdinals
index|[
name|conditionExprOrdinal
index|]
decl_stmt|;
name|conditionRef
operator|=
operator|new
name|RexLocalRef
argument_list|(
name|index
argument_list|,
name|allExprs
index|[
name|conditionExprOrdinal
index|]
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conditionRef
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|outputRowType
operator|==
literal|null
condition|)
block|{
name|outputRowType
operator|=
name|RexUtil
operator|.
name|createStructType
argument_list|(
name|typeFactory
argument_list|,
name|projectRefs
argument_list|,
name|fieldNames
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexProgram
name|program
init|=
operator|new
name|RexProgram
argument_list|(
name|inputRowType
argument_list|,
name|exprs
argument_list|,
name|projectRefs
argument_list|,
name|conditionRef
argument_list|,
name|outputRowType
argument_list|)
decl_stmt|;
comment|// Program is NOT normalized here (e.g. can contain literals in
comment|// call operands), since literals should be inlined.
return|return
name|program
return|;
block|}
specifier|private
name|String
name|deriveFieldName
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|RexInputRef
condition|)
block|{
name|int
name|inputIndex
init|=
operator|(
operator|(
name|RexInputRef
operator|)
name|expr
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|String
name|fieldName
init|=
name|child
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|inputIndex
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Don't inherit field names like '$3' from child: that's
comment|// confusing.
if|if
condition|(
operator|!
name|fieldName
operator|.
name|startsWith
argument_list|(
literal|"$"
argument_list|)
operator|||
name|fieldName
operator|.
name|startsWith
argument_list|(
literal|"$EXPR"
argument_list|)
condition|)
block|{
return|return
name|fieldName
return|;
block|}
block|}
return|return
literal|"$"
operator|+
name|ordinal
return|;
block|}
comment|/**    * Traces the given array of level expression lists at the finer level.    *    * @param exprs             Array expressions    * @param exprLevels        For each expression, the ordinal of its level    * @param levelTypeOrdinals For each level, the ordinal of its type in    *                          the {@link #relTypes} array    * @param levelCount        The number of levels    */
specifier|private
name|void
name|traceLevelExpressions
parameter_list|(
name|RexNode
index|[]
name|exprs
parameter_list|,
name|int
index|[]
name|exprLevels
parameter_list|,
name|int
index|[]
name|levelTypeOrdinals
parameter_list|,
name|int
name|levelCount
parameter_list|)
block|{
name|StringWriter
name|traceMsg
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|PrintWriter
name|traceWriter
init|=
operator|new
name|PrintWriter
argument_list|(
name|traceMsg
argument_list|)
decl_stmt|;
name|traceWriter
operator|.
name|println
argument_list|(
literal|"FarragoAutoCalcRule result expressions for: "
argument_list|)
expr_stmt|;
name|traceWriter
operator|.
name|println
argument_list|(
name|program
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|levelCount
condition|;
name|level
operator|++
control|)
block|{
name|traceWriter
operator|.
name|println
argument_list|(
literal|"Rel Level "
operator|+
name|level
operator|+
literal|", type "
operator|+
name|relTypes
index|[
name|levelTypeOrdinals
index|[
name|level
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|expr
init|=
name|exprs
index|[
name|i
index|]
decl_stmt|;
assert|assert
operator|(
name|exprLevels
index|[
name|i
index|]
operator|>=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|exprLevels
index|[
name|i
index|]
operator|<
name|levelCount
operator|)
operator|:
literal|"expression's level is out of range"
assert|;
if|if
condition|(
name|exprLevels
index|[
name|i
index|]
operator|==
name|level
condition|)
block|{
name|traceWriter
operator|.
name|println
argument_list|(
literal|"\t"
operator|+
name|i
operator|+
literal|": "
operator|+
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
name|traceWriter
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
name|String
name|msg
init|=
name|traceMsg
operator|.
name|toString
argument_list|()
decl_stmt|;
name|RULE_LOGGER
operator|.
name|finer
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the number of bits set in an array.    */
specifier|private
specifier|static
name|int
name|count
parameter_list|(
name|boolean
index|[]
name|booleans
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|boolean
name|b
range|:
name|booleans
control|)
block|{
if|if
condition|(
name|b
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**    * Returns the index of the first set bit in an array.    */
specifier|private
specifier|static
name|int
name|firstSet
parameter_list|(
name|boolean
index|[]
name|booleans
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|booleans
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|booleans
index|[
name|i
index|]
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Searches for a value in a map, and returns the position where it was    * found, or -1.    *    * @param value Value to search for    * @param map   Map to search in    * @return Ordinal of value in map, or -1 if not found    */
specifier|private
specifier|static
name|int
name|indexOf
parameter_list|(
name|int
name|value
parameter_list|,
name|int
index|[]
name|map
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|map
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|value
operator|==
name|map
index|[
name|i
index|]
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * Returns whether a relational expression can be implemented solely in a    * given {@link RelType}.    *    * @param rel         Calculation relational expression    * @param relTypeName Name of a {@link RelType}    * @return Whether relational expression can be implemented    */
specifier|protected
name|boolean
name|canImplement
parameter_list|(
name|LogicalCalc
name|rel
parameter_list|,
name|String
name|relTypeName
parameter_list|)
block|{
for|for
control|(
name|RelType
name|relType
range|:
name|relTypes
control|)
block|{
if|if
condition|(
name|relType
operator|.
name|name
operator|.
name|equals
argument_list|(
name|relTypeName
argument_list|)
condition|)
block|{
return|return
name|relType
operator|.
name|canImplement
argument_list|(
name|rel
operator|.
name|getProgram
argument_list|()
argument_list|)
return|;
block|}
block|}
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"unknown type "
operator|+
name|relTypeName
argument_list|)
throw|;
block|}
comment|/**    * Returns a list of sets of expressions that should be on the same level.    *    *<p>For example, if this method returns { {3, 5}, {4, 7} }, it means that    * expressions 3 and 5, should be on the same level, and expressions 4 and 7    * should be on the same level. The two cohorts do not need to be on the    * same level.    *    *<p>The list is best effort. If it is not possible to arrange that the    * expressions in a cohort are on the same level, the {@link #execute()}    * method will still succeed.    *    *<p>The default implementation of this method returns the empty list;    * expressions will be put on the most suitable level. This is generally    * the lowest possible level, except for literals, which are placed at the    * level where they are used.    *    * @return List of cohorts, that is sets of expressions, that the splitting    * algorithm should attempt to place on the same level    */
specifier|protected
name|List
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|getCohorts
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Type of relational expression. Determines which kinds of    * expressions it can handle. */
specifier|public
specifier|abstract
specifier|static
class|class
name|RelType
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|public
name|RelType
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
specifier|protected
specifier|abstract
name|boolean
name|canImplement
parameter_list|(
name|RexFieldAccess
name|field
parameter_list|)
function_decl|;
specifier|protected
specifier|abstract
name|boolean
name|canImplement
parameter_list|(
name|RexDynamicParam
name|param
parameter_list|)
function_decl|;
specifier|protected
specifier|abstract
name|boolean
name|canImplement
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
function_decl|;
specifier|protected
specifier|abstract
name|boolean
name|canImplement
parameter_list|(
name|RexCall
name|call
parameter_list|)
function_decl|;
specifier|protected
name|boolean
name|supportsCondition
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|protected
name|RelNode
name|makeRel
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelTraitSet
name|traitSet
parameter_list|,
name|RelBuilder
name|relBuilder
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|RexProgram
name|program
parameter_list|)
block|{
return|return
name|LogicalCalc
operator|.
name|create
argument_list|(
name|input
argument_list|,
name|program
argument_list|)
return|;
block|}
comment|/**      * Returns whether this<code>RelType</code> can implement a given      * expression.      *      * @param expr      Expression      * @param condition Whether expression is a condition      * @return Whether this<code>RelType</code> can implement a given      * expression.      */
specifier|public
name|boolean
name|canImplement
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|boolean
name|condition
parameter_list|)
block|{
if|if
condition|(
name|condition
operator|&&
operator|!
name|supportsCondition
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|expr
operator|.
name|accept
argument_list|(
operator|new
name|ImplementTester
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|CannotImplement
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Returns whether this tester's<code>RelType</code> can implement a      * given program.      *      * @param program Program      * @return Whether this tester's<code>RelType</code> can implement a      * given program.      */
specifier|public
name|boolean
name|canImplement
parameter_list|(
name|RexProgram
name|program
parameter_list|)
block|{
if|if
condition|(
operator|(
name|program
operator|.
name|getCondition
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|canImplement
argument_list|(
name|program
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|RexNode
name|expr
range|:
name|program
operator|.
name|getExprList
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|canImplement
argument_list|(
name|expr
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Visitor which returns whether an expression can be implemented in a given    * type of relational expression.    */
specifier|private
specifier|static
class|class
name|ImplementTester
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|RelType
name|relType
decl_stmt|;
specifier|public
name|ImplementTester
parameter_list|(
name|RelType
name|relType
parameter_list|)
block|{
name|super
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|relType
operator|=
name|relType
expr_stmt|;
block|}
specifier|public
name|Void
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
operator|!
name|relType
operator|.
name|canImplement
argument_list|(
name|call
argument_list|)
condition|)
block|{
throw|throw
name|CannotImplement
operator|.
name|INSTANCE
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Void
name|visitDynamicParam
parameter_list|(
name|RexDynamicParam
name|dynamicParam
parameter_list|)
block|{
if|if
condition|(
operator|!
name|relType
operator|.
name|canImplement
argument_list|(
name|dynamicParam
argument_list|)
condition|)
block|{
throw|throw
name|CannotImplement
operator|.
name|INSTANCE
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Void
name|visitFieldAccess
parameter_list|(
name|RexFieldAccess
name|fieldAccess
parameter_list|)
block|{
if|if
condition|(
operator|!
name|relType
operator|.
name|canImplement
argument_list|(
name|fieldAccess
argument_list|)
condition|)
block|{
throw|throw
name|CannotImplement
operator|.
name|INSTANCE
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|Void
name|visitLiteral
parameter_list|(
name|RexLiteral
name|literal
parameter_list|)
block|{
if|if
condition|(
operator|!
name|relType
operator|.
name|canImplement
argument_list|(
name|literal
argument_list|)
condition|)
block|{
throw|throw
name|CannotImplement
operator|.
name|INSTANCE
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Control exception for {@link ImplementTester}.    */
specifier|private
specifier|static
class|class
name|CannotImplement
extends|extends
name|RuntimeException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThrowableInstanceNeverThrown"
argument_list|)
specifier|static
specifier|final
name|CannotImplement
name|INSTANCE
init|=
operator|new
name|CannotImplement
argument_list|()
decl_stmt|;
block|}
comment|/**    * Shuttle which converts every reference to an input field in an expression    * to a reference to a common sub-expression.    */
specifier|private
specifier|static
class|class
name|InputToCommonExprConverter
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|int
index|[]
name|exprInverseOrdinals
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|exprLevels
decl_stmt|;
specifier|private
specifier|final
name|int
name|level
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|inputExprOrdinals
decl_stmt|;
specifier|private
specifier|final
name|RexNode
index|[]
name|allExprs
decl_stmt|;
specifier|public
name|InputToCommonExprConverter
parameter_list|(
name|int
index|[]
name|exprInverseOrdinals
parameter_list|,
name|int
index|[]
name|exprLevels
parameter_list|,
name|int
name|level
parameter_list|,
name|int
index|[]
name|inputExprOrdinals
parameter_list|,
name|RexNode
index|[]
name|allExprs
parameter_list|)
block|{
name|this
operator|.
name|exprInverseOrdinals
operator|=
name|exprInverseOrdinals
expr_stmt|;
name|this
operator|.
name|exprLevels
operator|=
name|exprLevels
expr_stmt|;
name|this
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|this
operator|.
name|inputExprOrdinals
operator|=
name|inputExprOrdinals
expr_stmt|;
name|this
operator|.
name|allExprs
operator|=
name|allExprs
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|input
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|exprInverseOrdinals
index|[
name|input
operator|.
name|getIndex
argument_list|()
index|]
decl_stmt|;
assert|assert
name|index
operator|>=
literal|0
assert|;
return|return
operator|new
name|RexLocalRef
argument_list|(
name|index
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|local
parameter_list|)
block|{
comment|// A reference to a local variable becomes a reference to an input
comment|// if the local was computed at a previous level.
specifier|final
name|int
name|localIndex
init|=
name|local
operator|.
name|getIndex
argument_list|()
decl_stmt|;
specifier|final
name|int
name|exprLevel
init|=
name|exprLevels
index|[
name|localIndex
index|]
decl_stmt|;
if|if
condition|(
name|exprLevel
operator|<
name|level
condition|)
block|{
if|if
condition|(
name|allExprs
index|[
name|localIndex
index|]
operator|instanceof
name|RexLiteral
condition|)
block|{
comment|// Expression is to be inlined. Use the original expression.
return|return
name|allExprs
index|[
name|localIndex
index|]
return|;
block|}
name|int
name|inputIndex
init|=
name|indexOf
argument_list|(
name|localIndex
argument_list|,
name|inputExprOrdinals
argument_list|)
decl_stmt|;
assert|assert
name|inputIndex
operator|>=
literal|0
assert|;
return|return
operator|new
name|RexLocalRef
argument_list|(
name|inputIndex
argument_list|,
name|local
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// It's a reference to what was a local expression at the
comment|// previous level, and was then projected.
specifier|final
name|int
name|exprIndex
init|=
name|exprInverseOrdinals
index|[
name|localIndex
index|]
decl_stmt|;
return|return
operator|new
name|RexLocalRef
argument_list|(
name|exprIndex
argument_list|,
name|local
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Finds the highest level used by any of the inputs of a given expression.    */
specifier|private
specifier|static
class|class
name|MaxInputFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
name|int
name|level
decl_stmt|;
specifier|private
specifier|final
name|int
index|[]
name|exprLevels
decl_stmt|;
name|MaxInputFinder
parameter_list|(
name|int
index|[]
name|exprLevels
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|exprLevels
operator|=
name|exprLevels
expr_stmt|;
block|}
specifier|public
name|Void
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|localRef
parameter_list|)
block|{
name|int
name|inputLevel
init|=
name|exprLevels
index|[
name|localRef
operator|.
name|getIndex
argument_list|()
index|]
decl_stmt|;
name|level
operator|=
name|Math
operator|.
name|max
argument_list|(
name|level
argument_list|,
name|inputLevel
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**      * Returns the highest level of any of the inputs of an expression.      */
specifier|public
name|int
name|maxInputFor
parameter_list|(
name|RexNode
name|expr
parameter_list|)
block|{
name|level
operator|=
literal|0
expr_stmt|;
name|expr
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|level
return|;
block|}
block|}
comment|/**    * Builds an array of the highest level which contains an expression which    * uses each expression as an input.    */
specifier|private
specifier|static
class|class
name|HighestUsageFinder
extends|extends
name|RexVisitorImpl
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
specifier|final
name|int
index|[]
name|maxUsingLevelOrdinals
decl_stmt|;
specifier|private
name|int
name|currentLevel
decl_stmt|;
specifier|public
name|HighestUsageFinder
parameter_list|(
name|RexNode
index|[]
name|exprs
parameter_list|,
name|int
index|[]
name|exprLevels
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxUsingLevelOrdinals
operator|=
operator|new
name|int
index|[
name|exprs
operator|.
name|length
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|maxUsingLevelOrdinals
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|exprs
index|[
name|i
index|]
operator|instanceof
name|RexLiteral
condition|)
block|{
comment|// Literals are always used directly. It never makes sense
comment|// to compute them at a lower level and project them to
comment|// where they are used.
name|maxUsingLevelOrdinals
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|currentLevel
operator|=
name|exprLevels
index|[
name|i
index|]
expr_stmt|;
name|exprs
index|[
name|i
index|]
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|int
index|[]
name|getMaxUsingLevelOrdinals
parameter_list|()
block|{
return|return
name|maxUsingLevelOrdinals
return|;
block|}
specifier|public
name|Void
name|visitLocalRef
parameter_list|(
name|RexLocalRef
name|ref
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|ref
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|maxUsingLevelOrdinals
index|[
name|index
index|]
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxUsingLevelOrdinals
index|[
name|index
index|]
argument_list|,
name|currentLevel
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End CalcRelSplitter.java
end_comment

end_unit

