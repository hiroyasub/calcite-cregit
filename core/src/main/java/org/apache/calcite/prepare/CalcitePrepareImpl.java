begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|DataContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableBindable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableCalc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableInterpretable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableInterpreterRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|EnumerableRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|enumerable
operator|.
name|RexToLixTranslator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|adapter
operator|.
name|java
operator|.
name|JavaTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|AvaticaParameter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|ColumnMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|Meta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|CalciteConnectionConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|interpreter
operator|.
name|BindableConvention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|interpreter
operator|.
name|Bindables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|interpreter
operator|.
name|Interpreters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalcitePrepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteSchema
operator|.
name|LatticeEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Enumerable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Linq4j
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Queryable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|BinaryExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|BlockStatement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Blocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ConstantExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|Expressions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|MemberExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|MethodCallExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|NewExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|tree
operator|.
name|ParameterExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|materialize
operator|.
name|MaterializationService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Contexts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Convention
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|ConventionTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCostFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|volcano
operator|.
name|VolcanoPlanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollationTraitDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelRoot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AbstractMaterializedViewRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateExpandDistinctAggregatesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateReduceFunctionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateStarTableRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|AggregateValuesRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterAggregateTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|FilterTableScanRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinAssociateRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinCommuteRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinPushExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinPushThroughJoinRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|MaterializedViewFilterScanRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectFilterTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectMergeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectTableScanRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ProjectWindowTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ReduceExpressionsRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortJoinTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|SortUnionTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|TableScanRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|ValuesReduceRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|stream
operator|.
name|StreamRules
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Bindable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Typed
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Schemas
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|server
operator|.
name|CalciteServerStatement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExecutableStatement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplainLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserImplFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ExtraSqlTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|ChainedSqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlConformance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlRexConvertletTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|SqlToRelConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|StandardConvertletTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|DatabaseMetaData
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * Shit just got real.  *  *<p>This class is public so that projects that create their own JDBC driver  * and server can fine-tune preferences. However, this class and its methods are  * subject to change without notice.</p>  */
end_comment

begin_class
specifier|public
class|class
name|CalcitePrepareImpl
implements|implements
name|CalcitePrepare
block|{
specifier|public
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
name|Util
operator|.
name|getBooleanProperty
argument_list|(
literal|"calcite.debug"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|COMMUTE
init|=
name|Util
operator|.
name|getBooleanProperty
argument_list|(
literal|"calcite.enable.join.commute"
argument_list|)
decl_stmt|;
comment|/** Whether to enable the collation trait. Some extra optimizations are    * possible if enabled, but queries should work either way. At some point    * this will become a preference, or we will run multiple phases: first    * disabled, then enabled. */
specifier|private
specifier|static
specifier|final
name|boolean
name|ENABLE_COLLATION_TRAIT
init|=
literal|true
decl_stmt|;
comment|/** Whether the bindable convention should be the root convention of any    * plan. If not, enumerable convention is the default. */
specifier|public
specifier|final
name|boolean
name|enableBindable
init|=
name|Hook
operator|.
name|ENABLE_BINDABLE
operator|.
name|get
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/** Whether the enumerable convention is enabled. */
specifier|public
specifier|static
specifier|final
name|boolean
name|ENABLE_ENUMERABLE
init|=
literal|true
decl_stmt|;
comment|/** Whether the streaming is enabled. */
specifier|public
specifier|static
specifier|final
name|boolean
name|ENABLE_STREAM
init|=
literal|true
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|SIMPLE_SQLS
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"SELECT 1"
argument_list|,
literal|"select 1"
argument_list|,
literal|"SELECT 1 FROM DUAL"
argument_list|,
literal|"select 1 from dual"
argument_list|,
literal|"values 1"
argument_list|,
literal|"VALUES 1"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|ENUMERABLE_RULES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|EnumerableRules
operator|.
name|ENUMERABLE_JOIN_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_MERGE_JOIN_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_SEMI_JOIN_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_CORRELATE_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_PROJECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_FILTER_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_AGGREGATE_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_SORT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_LIMIT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_COLLECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_UNCOLLECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_UNION_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_INTERSECT_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_MINUS_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_TABLE_MODIFICATION_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_VALUES_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_WINDOW_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_TABLE_SCAN_RULE
argument_list|,
name|EnumerableRules
operator|.
name|ENUMERABLE_TABLE_FUNCTION_SCAN_RULE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|DEFAULT_RULES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|AggregateStarTableRule
operator|.
name|INSTANCE
argument_list|,
name|AggregateStarTableRule
operator|.
name|INSTANCE2
argument_list|,
name|TableScanRule
operator|.
name|INSTANCE
argument_list|,
name|COMMUTE
condition|?
name|JoinAssociateRule
operator|.
name|INSTANCE
else|:
name|ProjectMergeRule
operator|.
name|INSTANCE
argument_list|,
name|FilterTableScanRule
operator|.
name|INSTANCE
argument_list|,
name|ProjectFilterTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|FilterProjectTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|FilterJoinRule
operator|.
name|FILTER_ON_JOIN
argument_list|,
name|JoinPushExpressionsRule
operator|.
name|INSTANCE
argument_list|,
name|AggregateExpandDistinctAggregatesRule
operator|.
name|INSTANCE
argument_list|,
name|AggregateReduceFunctionsRule
operator|.
name|INSTANCE
argument_list|,
name|FilterAggregateTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|ProjectWindowTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|JoinCommuteRule
operator|.
name|INSTANCE
argument_list|,
name|JoinPushThroughJoinRule
operator|.
name|RIGHT
argument_list|,
name|JoinPushThroughJoinRule
operator|.
name|LEFT
argument_list|,
name|SortProjectTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|SortJoinTransposeRule
operator|.
name|INSTANCE
argument_list|,
name|SortUnionTransposeRule
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|RelOptRule
argument_list|>
name|CONSTANT_REDUCTION_RULES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|ReduceExpressionsRule
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|FILTER_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|CALC_INSTANCE
argument_list|,
name|ReduceExpressionsRule
operator|.
name|JOIN_INSTANCE
argument_list|,
name|ValuesReduceRule
operator|.
name|FILTER_INSTANCE
argument_list|,
name|ValuesReduceRule
operator|.
name|PROJECT_FILTER_INSTANCE
argument_list|,
name|ValuesReduceRule
operator|.
name|PROJECT_INSTANCE
argument_list|,
name|AggregateValuesRule
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
specifier|public
name|CalcitePrepareImpl
parameter_list|()
block|{
block|}
specifier|public
name|ParseResult
name|parse
parameter_list|(
name|Context
name|context
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
return|return
name|parse_
argument_list|(
name|context
argument_list|,
name|sql
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|ConvertResult
name|convert
parameter_list|(
name|Context
name|context
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
return|return
operator|(
name|ConvertResult
operator|)
name|parse_
argument_list|(
name|context
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|AnalyzeViewResult
name|analyzeView
parameter_list|(
name|Context
name|context
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
return|return
operator|(
name|AnalyzeViewResult
operator|)
name|parse_
argument_list|(
name|context
argument_list|,
name|sql
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|fail
argument_list|)
return|;
block|}
comment|/** Shared implementation for {@link #parse}, {@link #convert} and    * {@link #analyzeView}. */
specifier|private
name|ParseResult
name|parse_
parameter_list|(
name|Context
name|context
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|convert
parameter_list|,
name|boolean
name|analyze
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
specifier|final
name|JavaTypeFactory
name|typeFactory
init|=
name|context
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|CalciteCatalogReader
name|catalogReader
init|=
operator|new
name|CalciteCatalogReader
argument_list|(
name|context
operator|.
name|getRootSchema
argument_list|()
argument_list|,
name|context
operator|.
name|getDefaultSchemaPath
argument_list|()
argument_list|,
name|typeFactory
argument_list|,
name|context
operator|.
name|config
argument_list|()
argument_list|)
decl_stmt|;
name|SqlParser
name|parser
init|=
name|createParser
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|sqlNode
decl_stmt|;
try|try
block|{
name|sqlNode
operator|=
name|parser
operator|.
name|parseStmt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"parse failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|SqlValidator
name|validator
init|=
name|createSqlValidator
argument_list|(
name|context
argument_list|,
name|catalogReader
argument_list|)
decl_stmt|;
name|SqlNode
name|sqlNode1
init|=
name|validator
operator|.
name|validate
argument_list|(
name|sqlNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|convert
condition|)
block|{
return|return
name|convert_
argument_list|(
name|context
argument_list|,
name|sql
argument_list|,
name|analyze
argument_list|,
name|fail
argument_list|,
name|catalogReader
argument_list|,
name|validator
argument_list|,
name|sqlNode1
argument_list|)
return|;
block|}
return|return
operator|new
name|ParseResult
argument_list|(
name|this
argument_list|,
name|validator
argument_list|,
name|sql
argument_list|,
name|sqlNode1
argument_list|,
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode1
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|ParseResult
name|convert_
parameter_list|(
name|Context
name|context
parameter_list|,
name|String
name|sql
parameter_list|,
name|boolean
name|analyze
parameter_list|,
name|boolean
name|fail
parameter_list|,
name|CalciteCatalogReader
name|catalogReader
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|SqlNode
name|sqlNode1
parameter_list|)
block|{
specifier|final
name|JavaTypeFactory
name|typeFactory
init|=
name|context
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|Convention
name|resultConvention
init|=
name|enableBindable
condition|?
name|BindableConvention
operator|.
name|INSTANCE
else|:
name|EnumerableConvention
operator|.
name|INSTANCE
decl_stmt|;
specifier|final
name|HepPlanner
name|planner
init|=
operator|new
name|HepPlanner
argument_list|(
operator|new
name|HepProgramBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
specifier|final
name|SqlToRelConverter
operator|.
name|ConfigBuilder
name|configBuilder
init|=
name|SqlToRelConverter
operator|.
name|configBuilder
argument_list|()
operator|.
name|withTrimUnusedFields
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|analyze
condition|)
block|{
name|configBuilder
operator|.
name|withConvertTableAccess
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CalcitePreparingStmt
name|preparingStmt
init|=
operator|new
name|CalcitePreparingStmt
argument_list|(
name|this
argument_list|,
name|context
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|context
operator|.
name|getRootSchema
argument_list|()
argument_list|,
literal|null
argument_list|,
name|planner
argument_list|,
name|resultConvention
argument_list|,
name|createConvertletTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlToRelConverter
name|converter
init|=
name|preparingStmt
operator|.
name|getSqlToRelConverter
argument_list|(
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|configBuilder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelRoot
name|root
init|=
name|converter
operator|.
name|convertQuery
argument_list|(
name|sqlNode1
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|analyze
condition|)
block|{
return|return
name|analyze_
argument_list|(
name|validator
argument_list|,
name|sql
argument_list|,
name|sqlNode1
argument_list|,
name|root
argument_list|,
name|fail
argument_list|)
return|;
block|}
return|return
operator|new
name|ConvertResult
argument_list|(
name|this
argument_list|,
name|validator
argument_list|,
name|sql
argument_list|,
name|sqlNode1
argument_list|,
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode1
argument_list|)
argument_list|,
name|root
argument_list|)
return|;
block|}
specifier|private
name|AnalyzeViewResult
name|analyze_
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|String
name|sql
parameter_list|,
name|SqlNode
name|sqlNode
parameter_list|,
name|RelRoot
name|root
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|root
operator|.
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelNode
name|rel
init|=
name|root
operator|.
name|rel
decl_stmt|;
specifier|final
name|RelNode
name|viewRel
init|=
name|rel
decl_stmt|;
name|Project
name|project
decl_stmt|;
if|if
condition|(
name|rel
operator|instanceof
name|Project
condition|)
block|{
name|project
operator|=
operator|(
name|Project
operator|)
name|rel
expr_stmt|;
name|rel
operator|=
name|project
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|project
operator|=
literal|null
expr_stmt|;
block|}
name|Filter
name|filter
decl_stmt|;
if|if
condition|(
name|rel
operator|instanceof
name|Filter
condition|)
block|{
name|filter
operator|=
operator|(
name|Filter
operator|)
name|rel
expr_stmt|;
name|rel
operator|=
name|filter
operator|.
name|getInput
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|filter
operator|=
literal|null
expr_stmt|;
block|}
name|TableScan
name|scan
decl_stmt|;
if|if
condition|(
name|rel
operator|instanceof
name|TableScan
condition|)
block|{
name|scan
operator|=
operator|(
name|TableScan
operator|)
name|rel
expr_stmt|;
block|}
else|else
block|{
name|scan
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|sqlNode
argument_list|,
name|RESOURCE
operator|.
name|modifiableViewMustBeBasedOnSingleTable
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|AnalyzeViewResult
argument_list|(
name|this
argument_list|,
name|validator
argument_list|,
name|sql
argument_list|,
name|sqlNode
argument_list|,
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode
argument_list|)
argument_list|,
name|root
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|final
name|RelOptTable
name|targetRelTable
init|=
name|scan
operator|.
name|getTable
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|targetRelTable
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|Table
name|table
init|=
name|targetRelTable
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|tablePath
init|=
name|targetRelTable
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
assert|assert
name|table
operator|!=
literal|null
assert|;
name|List
argument_list|<
name|Integer
argument_list|>
name|columnMapping
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|projectMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|project
operator|==
literal|null
condition|)
block|{
name|columnMapping
operator|=
name|ImmutableIntList
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|targetRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|columnMapping
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|node
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|node
operator|.
name|e
operator|instanceof
name|RexInputRef
condition|)
block|{
name|RexInputRef
name|rexInputRef
init|=
operator|(
name|RexInputRef
operator|)
name|node
operator|.
name|e
decl_stmt|;
name|int
name|index
init|=
name|rexInputRef
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|projectMap
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|sqlNode
argument_list|,
name|RESOURCE
operator|.
name|moreThanOneMappedColumn
argument_list|(
name|targetRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|tablePath
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|AnalyzeViewResult
argument_list|(
name|this
argument_list|,
name|validator
argument_list|,
name|sql
argument_list|,
name|sqlNode
argument_list|,
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode
argument_list|)
argument_list|,
name|root
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|projectMap
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|viewRel
argument_list|,
name|node
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|columnMapping
operator|.
name|add
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|columnMapping
operator|.
name|add
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|RexNode
name|constraint
decl_stmt|;
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
name|constraint
operator|=
name|filter
operator|.
name|getCondition
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|constraint
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// If we put a constraint in projectMap above, then filters will not be empty despite
comment|// being a modifiable view.
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|filters2
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|retry
init|=
literal|false
decl_stmt|;
name|RelOptUtil
operator|.
name|inferViewPredicates
argument_list|(
name|projectMap
argument_list|,
name|filters
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
operator|&&
operator|!
name|filters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|projectMap2
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|inferViewPredicates
argument_list|(
name|projectMap2
argument_list|,
name|filters2
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filters2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|sqlNode
argument_list|,
name|RESOURCE
operator|.
name|modifiableViewMustHaveOnlyEqualityPredicates
argument_list|()
argument_list|)
throw|;
block|}
name|retry
operator|=
literal|true
expr_stmt|;
block|}
comment|// Check that all columns that are not projected have a constant value
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|targetRowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
specifier|final
name|int
name|x
init|=
name|columnMapping
operator|.
name|indexOf
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
block|{
assert|assert
name|Util
operator|.
name|skip
argument_list|(
name|columnMapping
argument_list|,
name|x
operator|+
literal|1
argument_list|)
operator|.
name|indexOf
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|<
literal|0
operator|:
literal|"column projected more than once; should have checked above"
assert|;
continue|continue;
comment|// target column is projected
block|}
if|if
condition|(
name|projectMap
operator|.
name|get
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
continue|continue;
comment|// constant expression
block|}
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
continue|continue;
comment|// don't need expression for nullable columns; NULL suffices
block|}
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|sqlNode
argument_list|,
name|RESOURCE
operator|.
name|noValueSuppliedForViewColumn
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|tablePath
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|AnalyzeViewResult
argument_list|(
name|this
argument_list|,
name|validator
argument_list|,
name|sql
argument_list|,
name|sqlNode
argument_list|,
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode
argument_list|)
argument_list|,
name|root
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|final
name|boolean
name|modifiable
init|=
name|filters
operator|.
name|isEmpty
argument_list|()
operator|||
name|retry
operator|&&
name|filters2
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
return|return
operator|new
name|AnalyzeViewResult
argument_list|(
name|this
argument_list|,
name|validator
argument_list|,
name|sql
argument_list|,
name|sqlNode
argument_list|,
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode
argument_list|)
argument_list|,
name|root
argument_list|,
name|modifiable
condition|?
name|table
else|:
literal|null
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tablePath
argument_list|)
argument_list|,
name|constraint
argument_list|,
name|ImmutableIntList
operator|.
name|copyOf
argument_list|(
name|columnMapping
argument_list|)
argument_list|,
name|modifiable
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|executeDdl
parameter_list|(
name|Context
name|context
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlExecutableStatement
condition|)
block|{
name|SqlExecutableStatement
name|statement
init|=
operator|(
name|SqlExecutableStatement
operator|)
name|node
decl_stmt|;
name|statement
operator|.
name|execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/** Factory method for default SQL parser. */
specifier|protected
name|SqlParser
name|createParser
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
return|return
name|createParser
argument_list|(
name|sql
argument_list|,
name|createParserConfig
argument_list|()
argument_list|)
return|;
block|}
comment|/** Factory method for SQL parser with a given configuration. */
specifier|protected
name|SqlParser
name|createParser
parameter_list|(
name|String
name|sql
parameter_list|,
name|SqlParser
operator|.
name|ConfigBuilder
name|parserConfig
parameter_list|)
block|{
return|return
name|SqlParser
operator|.
name|create
argument_list|(
name|sql
argument_list|,
name|parserConfig
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/** Factory method for SQL parser configuration. */
specifier|protected
name|SqlParser
operator|.
name|ConfigBuilder
name|createParserConfig
parameter_list|()
block|{
return|return
name|SqlParser
operator|.
name|configBuilder
argument_list|()
return|;
block|}
comment|/** Factory method for default convertlet table. */
specifier|protected
name|SqlRexConvertletTable
name|createConvertletTable
parameter_list|()
block|{
return|return
name|StandardConvertletTable
operator|.
name|INSTANCE
return|;
block|}
comment|/** Factory method for cluster. */
specifier|protected
name|RelOptCluster
name|createCluster
parameter_list|(
name|RelOptPlanner
name|planner
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
return|return
name|RelOptCluster
operator|.
name|create
argument_list|(
name|planner
argument_list|,
name|rexBuilder
argument_list|)
return|;
block|}
comment|/** Creates a collection of planner factories.    *    *<p>The collection must have at least one factory, and each factory must    * create a planner. If the collection has more than one planner, Calcite will    * try each planner in turn.</p>    *    *<p>One of the things you can do with this mechanism is to try a simpler,    * faster, planner with a smaller rule set first, then fall back to a more    * complex planner for complex and costly queries.</p>    *    *<p>The default implementation returns a factory that calls    * {@link #createPlanner(org.apache.calcite.jdbc.CalcitePrepare.Context)}.</p>    */
specifier|protected
name|List
argument_list|<
name|Function1
argument_list|<
name|Context
argument_list|,
name|RelOptPlanner
argument_list|>
argument_list|>
name|createPlannerFactories
parameter_list|()
block|{
return|return
name|Collections
operator|.
expr|<
name|Function1
argument_list|<
name|Context
argument_list|,
name|RelOptPlanner
argument_list|>
operator|>
name|singletonList
argument_list|(
operator|new
name|Function1
argument_list|<
name|Context
argument_list|,
name|RelOptPlanner
argument_list|>
argument_list|()
block|{
specifier|public
name|RelOptPlanner
name|apply
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
return|return
name|createPlanner
argument_list|(
name|context
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/** Creates a query planner and initializes it with a default set of    * rules. */
specifier|protected
name|RelOptPlanner
name|createPlanner
parameter_list|(
name|CalcitePrepare
operator|.
name|Context
name|prepareContext
parameter_list|)
block|{
return|return
name|createPlanner
argument_list|(
name|prepareContext
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Creates a query planner and initializes it with a default set of    * rules. */
specifier|protected
name|RelOptPlanner
name|createPlanner
parameter_list|(
specifier|final
name|CalcitePrepare
operator|.
name|Context
name|prepareContext
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
name|externalContext
parameter_list|,
name|RelOptCostFactory
name|costFactory
parameter_list|)
block|{
if|if
condition|(
name|externalContext
operator|==
literal|null
condition|)
block|{
name|externalContext
operator|=
name|Contexts
operator|.
name|of
argument_list|(
name|prepareContext
operator|.
name|config
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|VolcanoPlanner
name|planner
init|=
operator|new
name|VolcanoPlanner
argument_list|(
name|costFactory
argument_list|,
name|externalContext
argument_list|)
decl_stmt|;
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|ConventionTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENABLE_COLLATION_TRAIT
condition|)
block|{
name|planner
operator|.
name|addRelTraitDef
argument_list|(
name|RelCollationTraitDef
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|registerAbstractRelationalRules
argument_list|()
expr_stmt|;
block|}
name|RelOptUtil
operator|.
name|registerAbstractRels
argument_list|(
name|planner
argument_list|)
expr_stmt|;
for|for
control|(
name|RelOptRule
name|rule
range|:
name|DEFAULT_RULES
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prepareContext
operator|.
name|config
argument_list|()
operator|.
name|materializationsEnabled
argument_list|()
condition|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|MaterializedViewFilterScanRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|AbstractMaterializedViewRule
operator|.
name|INSTANCE_PROJECT_FILTER
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|AbstractMaterializedViewRule
operator|.
name|INSTANCE_FILTER
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|AbstractMaterializedViewRule
operator|.
name|INSTANCE_PROJECT_JOIN
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|AbstractMaterializedViewRule
operator|.
name|INSTANCE_JOIN
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|AbstractMaterializedViewRule
operator|.
name|INSTANCE_PROJECT_AGGREGATE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|AbstractMaterializedViewRule
operator|.
name|INSTANCE_AGGREGATE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enableBindable
condition|)
block|{
for|for
control|(
name|RelOptRule
name|rule
range|:
name|Bindables
operator|.
name|RULES
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
name|planner
operator|.
name|addRule
argument_list|(
name|Bindables
operator|.
name|BINDABLE_TABLE_SCAN_RULE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|ProjectTableScanRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|planner
operator|.
name|addRule
argument_list|(
name|ProjectTableScanRule
operator|.
name|INTERPRETER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENABLE_ENUMERABLE
condition|)
block|{
for|for
control|(
name|RelOptRule
name|rule
range|:
name|ENUMERABLE_RULES
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableInterpreterRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enableBindable
operator|&&
name|ENABLE_ENUMERABLE
condition|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|EnumerableBindable
operator|.
name|EnumerableToBindableConverterRule
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ENABLE_STREAM
condition|)
block|{
for|for
control|(
name|RelOptRule
name|rule
range|:
name|StreamRules
operator|.
name|RULES
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Change the below to enable constant-reduction.
if|if
condition|(
literal|false
condition|)
block|{
for|for
control|(
name|RelOptRule
name|rule
range|:
name|CONSTANT_REDUCTION_RULES
control|)
block|{
name|planner
operator|.
name|addRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|SparkHandler
name|spark
init|=
name|prepareContext
operator|.
name|spark
argument_list|()
decl_stmt|;
if|if
condition|(
name|spark
operator|.
name|enabled
argument_list|()
condition|)
block|{
name|spark
operator|.
name|registerRules
argument_list|(
operator|new
name|SparkHandler
operator|.
name|RuleSetBuilder
argument_list|()
block|{
specifier|public
name|void
name|addRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
comment|// TODO:
block|}
specifier|public
name|void
name|removeRule
parameter_list|(
name|RelOptRule
name|rule
parameter_list|)
block|{
comment|// TODO:
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|Hook
operator|.
name|PLANNER
operator|.
name|run
argument_list|(
name|planner
argument_list|)
expr_stmt|;
comment|// allow test to add or remove rules
return|return
name|planner
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|CalciteSignature
argument_list|<
name|T
argument_list|>
name|prepareQueryable
parameter_list|(
name|Context
name|context
parameter_list|,
name|Queryable
argument_list|<
name|T
argument_list|>
name|queryable
parameter_list|)
block|{
return|return
name|prepare_
argument_list|(
name|context
argument_list|,
name|Query
operator|.
name|of
argument_list|(
name|queryable
argument_list|)
argument_list|,
name|queryable
operator|.
name|getElementType
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|CalciteSignature
argument_list|<
name|T
argument_list|>
name|prepareSql
parameter_list|(
name|Context
name|context
parameter_list|,
name|Query
argument_list|<
name|T
argument_list|>
name|query
parameter_list|,
name|Type
name|elementType
parameter_list|,
name|long
name|maxRowCount
parameter_list|)
block|{
return|return
name|prepare_
argument_list|(
name|context
argument_list|,
name|query
argument_list|,
name|elementType
argument_list|,
name|maxRowCount
argument_list|)
return|;
block|}
parameter_list|<
name|T
parameter_list|>
name|CalciteSignature
argument_list|<
name|T
argument_list|>
name|prepare_
parameter_list|(
name|Context
name|context
parameter_list|,
name|Query
argument_list|<
name|T
argument_list|>
name|query
parameter_list|,
name|Type
name|elementType
parameter_list|,
name|long
name|maxRowCount
parameter_list|)
block|{
if|if
condition|(
name|SIMPLE_SQLS
operator|.
name|contains
argument_list|(
name|query
operator|.
name|sql
argument_list|)
condition|)
block|{
return|return
name|simplePrepare
argument_list|(
name|context
argument_list|,
name|query
operator|.
name|sql
argument_list|)
return|;
block|}
specifier|final
name|JavaTypeFactory
name|typeFactory
init|=
name|context
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|CalciteCatalogReader
name|catalogReader
init|=
operator|new
name|CalciteCatalogReader
argument_list|(
name|context
operator|.
name|getRootSchema
argument_list|()
argument_list|,
name|context
operator|.
name|getDefaultSchemaPath
argument_list|()
argument_list|,
name|typeFactory
argument_list|,
name|context
operator|.
name|config
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Function1
argument_list|<
name|Context
argument_list|,
name|RelOptPlanner
argument_list|>
argument_list|>
name|plannerFactories
init|=
name|createPlannerFactories
argument_list|()
decl_stmt|;
if|if
condition|(
name|plannerFactories
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"no planner factories"
argument_list|)
throw|;
block|}
name|RuntimeException
name|exception
init|=
name|Util
operator|.
name|FoundOne
operator|.
name|NULL
decl_stmt|;
for|for
control|(
name|Function1
argument_list|<
name|Context
argument_list|,
name|RelOptPlanner
argument_list|>
name|plannerFactory
range|:
name|plannerFactories
control|)
block|{
specifier|final
name|RelOptPlanner
name|planner
init|=
name|plannerFactory
operator|.
name|apply
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|planner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"factory returned null planner"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|prepare2_
argument_list|(
name|context
argument_list|,
name|query
argument_list|,
name|elementType
argument_list|,
name|maxRowCount
argument_list|,
name|catalogReader
argument_list|,
name|planner
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RelOptPlanner
operator|.
name|CannotPlanException
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
block|}
throw|throw
name|exception
throw|;
block|}
comment|/** Quickly prepares a simple SQL statement, circumventing the usual    * preparation process. */
specifier|private
parameter_list|<
name|T
parameter_list|>
name|CalciteSignature
argument_list|<
name|T
argument_list|>
name|simplePrepare
parameter_list|(
name|Context
name|context
parameter_list|,
name|String
name|sql
parameter_list|)
block|{
specifier|final
name|JavaTypeFactory
name|typeFactory
init|=
name|context
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|x
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SqlTypeName
operator|.
name|INTEGER
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|(
name|List
operator|)
name|ImmutableList
operator|.
name|of
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|origin
init|=
literal|null
decl_stmt|;
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|origins
init|=
name|Collections
operator|.
name|nCopies
argument_list|(
name|x
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|origin
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ColumnMetaData
argument_list|>
name|columns
init|=
name|getColumnMetaDataList
argument_list|(
name|typeFactory
argument_list|,
name|x
argument_list|,
name|x
argument_list|,
name|origins
argument_list|)
decl_stmt|;
specifier|final
name|Meta
operator|.
name|CursorFactory
name|cursorFactory
init|=
name|Meta
operator|.
name|CursorFactory
operator|.
name|deduce
argument_list|(
name|columns
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|CalciteSignature
argument_list|<>
argument_list|(
name|sql
argument_list|,
name|ImmutableList
operator|.
expr|<
name|AvaticaParameter
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableMap
operator|.
expr|<
name|String
argument_list|,
name|Object
operator|>
name|of
argument_list|()
argument_list|,
name|x
argument_list|,
name|columns
argument_list|,
name|cursorFactory
argument_list|,
name|context
operator|.
name|getRootSchema
argument_list|()
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelCollation
operator|>
name|of
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
operator|new
name|Bindable
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
specifier|public
name|Enumerable
argument_list|<
name|T
argument_list|>
name|bind
parameter_list|(
name|DataContext
name|dataContext
parameter_list|)
block|{
return|return
name|Linq4j
operator|.
name|asEnumerable
argument_list|(
name|list
argument_list|)
return|;
block|}
block|}
argument_list|,
name|Meta
operator|.
name|StatementType
operator|.
name|SELECT
argument_list|)
return|;
block|}
comment|/**    * Deduces the broad type of statement.    * Currently returns SELECT for most statement types, but this may change.    *    * @param kind Kind of statement    */
specifier|private
name|Meta
operator|.
name|StatementType
name|getStatementType
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|INSERT
case|:
case|case
name|DELETE
case|:
case|case
name|UPDATE
case|:
return|return
name|Meta
operator|.
name|StatementType
operator|.
name|IS_DML
return|;
default|default:
return|return
name|Meta
operator|.
name|StatementType
operator|.
name|SELECT
return|;
block|}
block|}
comment|/**    * Deduces the broad type of statement for a prepare result.    * Currently returns SELECT for most statement types, but this may change.    *    * @param preparedResult Prepare result    */
specifier|private
name|Meta
operator|.
name|StatementType
name|getStatementType
parameter_list|(
name|Prepare
operator|.
name|PreparedResult
name|preparedResult
parameter_list|)
block|{
if|if
condition|(
name|preparedResult
operator|.
name|isDml
argument_list|()
condition|)
block|{
return|return
name|Meta
operator|.
name|StatementType
operator|.
name|IS_DML
return|;
block|}
else|else
block|{
return|return
name|Meta
operator|.
name|StatementType
operator|.
name|SELECT
return|;
block|}
block|}
parameter_list|<
name|T
parameter_list|>
name|CalciteSignature
argument_list|<
name|T
argument_list|>
name|prepare2_
parameter_list|(
name|Context
name|context
parameter_list|,
name|Query
argument_list|<
name|T
argument_list|>
name|query
parameter_list|,
name|Type
name|elementType
parameter_list|,
name|long
name|maxRowCount
parameter_list|,
name|CalciteCatalogReader
name|catalogReader
parameter_list|,
name|RelOptPlanner
name|planner
parameter_list|)
block|{
specifier|final
name|JavaTypeFactory
name|typeFactory
init|=
name|context
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|EnumerableRel
operator|.
name|Prefer
name|prefer
decl_stmt|;
if|if
condition|(
name|elementType
operator|==
name|Object
index|[]
operator|.
name|class
condition|)
block|{
name|prefer
operator|=
name|EnumerableRel
operator|.
name|Prefer
operator|.
name|ARRAY
expr_stmt|;
block|}
else|else
block|{
name|prefer
operator|=
name|EnumerableRel
operator|.
name|Prefer
operator|.
name|CUSTOM
expr_stmt|;
block|}
specifier|final
name|Convention
name|resultConvention
init|=
name|enableBindable
condition|?
name|BindableConvention
operator|.
name|INSTANCE
else|:
name|EnumerableConvention
operator|.
name|INSTANCE
decl_stmt|;
specifier|final
name|CalcitePreparingStmt
name|preparingStmt
init|=
operator|new
name|CalcitePreparingStmt
argument_list|(
name|this
argument_list|,
name|context
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|context
operator|.
name|getRootSchema
argument_list|()
argument_list|,
name|prefer
argument_list|,
name|planner
argument_list|,
name|resultConvention
argument_list|,
name|createConvertletTable
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|x
decl_stmt|;
specifier|final
name|Prepare
operator|.
name|PreparedResult
name|preparedResult
decl_stmt|;
specifier|final
name|Meta
operator|.
name|StatementType
name|statementType
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|sql
operator|!=
literal|null
condition|)
block|{
specifier|final
name|CalciteConnectionConfig
name|config
init|=
name|context
operator|.
name|config
argument_list|()
decl_stmt|;
specifier|final
name|SqlParser
operator|.
name|ConfigBuilder
name|parserConfig
init|=
name|createParserConfig
argument_list|()
operator|.
name|setQuotedCasing
argument_list|(
name|config
operator|.
name|quotedCasing
argument_list|()
argument_list|)
operator|.
name|setUnquotedCasing
argument_list|(
name|config
operator|.
name|unquotedCasing
argument_list|()
argument_list|)
operator|.
name|setQuoting
argument_list|(
name|config
operator|.
name|quoting
argument_list|()
argument_list|)
operator|.
name|setConformance
argument_list|(
name|config
operator|.
name|conformance
argument_list|()
argument_list|)
operator|.
name|setCaseSensitive
argument_list|(
name|config
operator|.
name|caseSensitive
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlParserImplFactory
name|parserFactory
init|=
name|config
operator|.
name|parserFactory
argument_list|(
name|SqlParserImplFactory
operator|.
name|class
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|parserFactory
operator|!=
literal|null
condition|)
block|{
name|parserConfig
operator|.
name|setParserFactory
argument_list|(
name|parserFactory
argument_list|)
expr_stmt|;
block|}
name|SqlParser
name|parser
init|=
name|createParser
argument_list|(
name|query
operator|.
name|sql
argument_list|,
name|parserConfig
argument_list|)
decl_stmt|;
name|SqlNode
name|sqlNode
decl_stmt|;
try|try
block|{
name|sqlNode
operator|=
name|parser
operator|.
name|parseStmt
argument_list|()
expr_stmt|;
name|statementType
operator|=
name|getStatementType
argument_list|(
name|sqlNode
operator|.
name|getKind
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"parse failed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Hook
operator|.
name|PARSE_TREE
operator|.
name|run
argument_list|(
operator|new
name|Object
index|[]
block|{
name|query
operator|.
name|sql
block|,
name|sqlNode
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlNode
operator|.
name|getKind
argument_list|()
operator|.
name|belongsTo
argument_list|(
name|SqlKind
operator|.
name|DDL
argument_list|)
condition|)
block|{
name|executeDdl
argument_list|(
name|context
argument_list|,
name|sqlNode
argument_list|)
expr_stmt|;
return|return
operator|new
name|CalciteSignature
argument_list|<>
argument_list|(
name|query
operator|.
name|sql
argument_list|,
name|ImmutableList
operator|.
expr|<
name|AvaticaParameter
operator|>
name|of
argument_list|()
argument_list|,
name|ImmutableMap
operator|.
expr|<
name|String
argument_list|,
name|Object
operator|>
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
expr|<
name|ColumnMetaData
operator|>
name|of
argument_list|()
argument_list|,
name|Meta
operator|.
name|CursorFactory
operator|.
name|OBJECT
argument_list|,
literal|null
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelCollation
operator|>
name|of
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|Meta
operator|.
name|StatementType
operator|.
name|OTHER_DDL
argument_list|)
return|;
block|}
specifier|final
name|SqlValidator
name|validator
init|=
name|createSqlValidator
argument_list|(
name|context
argument_list|,
name|catalogReader
argument_list|)
decl_stmt|;
name|validator
operator|.
name|setIdentifierExpansion
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|validator
operator|.
name|setDefaultNullCollation
argument_list|(
name|config
operator|.
name|defaultNullCollation
argument_list|()
argument_list|)
expr_stmt|;
name|preparedResult
operator|=
name|preparingStmt
operator|.
name|prepareSql
argument_list|(
name|sqlNode
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|validator
argument_list|,
literal|true
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sqlNode
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INSERT
case|:
case|case
name|DELETE
case|:
case|case
name|UPDATE
case|:
case|case
name|EXPLAIN
case|:
comment|// FIXME: getValidatedNodeType is wrong for DML
name|x
operator|=
name|RelOptUtil
operator|.
name|createDmlRowType
argument_list|(
name|sqlNode
operator|.
name|getKind
argument_list|()
argument_list|,
name|typeFactory
argument_list|)
expr_stmt|;
break|break;
default|default:
name|x
operator|=
name|validator
operator|.
name|getValidatedNodeType
argument_list|(
name|sqlNode
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|query
operator|.
name|queryable
operator|!=
literal|null
condition|)
block|{
name|x
operator|=
name|context
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createType
argument_list|(
name|elementType
argument_list|)
expr_stmt|;
name|preparedResult
operator|=
name|preparingStmt
operator|.
name|prepareQueryable
argument_list|(
name|query
operator|.
name|queryable
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|statementType
operator|=
name|getStatementType
argument_list|(
name|preparedResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|query
operator|.
name|rel
operator|!=
literal|null
assert|;
name|x
operator|=
name|query
operator|.
name|rel
operator|.
name|getRowType
argument_list|()
expr_stmt|;
name|preparedResult
operator|=
name|preparingStmt
operator|.
name|prepareRel
argument_list|(
name|query
operator|.
name|rel
argument_list|)
expr_stmt|;
name|statementType
operator|=
name|getStatementType
argument_list|(
name|preparedResult
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|AvaticaParameter
argument_list|>
name|parameters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|parameterRowType
init|=
name|preparedResult
operator|.
name|getParameterRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|parameterRowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|RelDataType
name|type
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
name|parameters
operator|.
name|add
argument_list|(
operator|new
name|AvaticaParameter
argument_list|(
literal|false
argument_list|,
name|getPrecision
argument_list|(
name|type
argument_list|)
argument_list|,
name|getScale
argument_list|(
name|type
argument_list|)
argument_list|,
name|getTypeOrdinal
argument_list|(
name|type
argument_list|)
argument_list|,
name|getTypeName
argument_list|(
name|type
argument_list|)
argument_list|,
name|getClassName
argument_list|(
name|type
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|jdbcType
init|=
name|makeStruct
argument_list|(
name|typeFactory
argument_list|,
name|x
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|originList
init|=
name|preparedResult
operator|.
name|getFieldOrigins
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ColumnMetaData
argument_list|>
name|columns
init|=
name|getColumnMetaDataList
argument_list|(
name|typeFactory
argument_list|,
name|x
argument_list|,
name|jdbcType
argument_list|,
name|originList
argument_list|)
decl_stmt|;
name|Class
name|resultClazz
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|preparedResult
operator|instanceof
name|Typed
condition|)
block|{
name|resultClazz
operator|=
operator|(
name|Class
operator|)
operator|(
operator|(
name|Typed
operator|)
name|preparedResult
operator|)
operator|.
name|getElementType
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Meta
operator|.
name|CursorFactory
name|cursorFactory
init|=
name|preparingStmt
operator|.
name|resultConvention
operator|==
name|BindableConvention
operator|.
name|INSTANCE
condition|?
name|Meta
operator|.
name|CursorFactory
operator|.
name|ARRAY
else|:
name|Meta
operator|.
name|CursorFactory
operator|.
name|deduce
argument_list|(
name|columns
argument_list|,
name|resultClazz
argument_list|)
decl_stmt|;
comment|//noinspection unchecked
specifier|final
name|Bindable
argument_list|<
name|T
argument_list|>
name|bindable
init|=
name|preparedResult
operator|.
name|getBindable
argument_list|(
name|cursorFactory
argument_list|)
decl_stmt|;
return|return
operator|new
name|CalciteSignature
argument_list|<>
argument_list|(
name|query
operator|.
name|sql
argument_list|,
name|parameters
argument_list|,
name|preparingStmt
operator|.
name|internalParameters
argument_list|,
name|jdbcType
argument_list|,
name|columns
argument_list|,
name|cursorFactory
argument_list|,
name|context
operator|.
name|getRootSchema
argument_list|()
argument_list|,
name|preparedResult
operator|instanceof
name|Prepare
operator|.
name|PreparedResultImpl
condition|?
operator|(
operator|(
name|Prepare
operator|.
name|PreparedResultImpl
operator|)
name|preparedResult
operator|)
operator|.
name|collations
else|:
name|ImmutableList
operator|.
expr|<
name|RelCollation
operator|>
name|of
argument_list|()
argument_list|,
name|maxRowCount
argument_list|,
name|bindable
argument_list|,
name|statementType
argument_list|)
return|;
block|}
specifier|private
name|SqlValidator
name|createSqlValidator
parameter_list|(
name|Context
name|context
parameter_list|,
name|CalciteCatalogReader
name|catalogReader
parameter_list|)
block|{
specifier|final
name|SqlOperatorTable
name|opTab0
init|=
name|context
operator|.
name|config
argument_list|()
operator|.
name|fun
argument_list|(
name|SqlOperatorTable
operator|.
name|class
argument_list|,
name|SqlStdOperatorTable
operator|.
name|instance
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|SqlOperatorTable
name|opTab
init|=
name|ChainedSqlOperatorTable
operator|.
name|of
argument_list|(
name|opTab0
argument_list|,
name|catalogReader
argument_list|)
decl_stmt|;
specifier|final
name|JavaTypeFactory
name|typeFactory
init|=
name|context
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|SqlConformance
name|conformance
init|=
name|context
operator|.
name|config
argument_list|()
operator|.
name|conformance
argument_list|()
decl_stmt|;
return|return
operator|new
name|CalciteSqlValidator
argument_list|(
name|opTab
argument_list|,
name|catalogReader
argument_list|,
name|typeFactory
argument_list|,
name|conformance
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|ColumnMetaData
argument_list|>
name|getColumnMetaDataList
parameter_list|(
name|JavaTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|x
parameter_list|,
name|RelDataType
name|jdbcType
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|originList
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ColumnMetaData
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|jdbcType
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|pair
operator|.
name|e
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|field
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|fieldType
init|=
name|x
operator|.
name|isStruct
argument_list|()
condition|?
name|x
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|pair
operator|.
name|i
argument_list|)
operator|.
name|getType
argument_list|()
else|:
name|type
decl_stmt|;
name|columns
operator|.
name|add
argument_list|(
name|metaData
argument_list|(
name|typeFactory
argument_list|,
name|columns
operator|.
name|size
argument_list|()
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|type
argument_list|,
name|fieldType
argument_list|,
name|originList
operator|.
name|get
argument_list|(
name|pair
operator|.
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|columns
return|;
block|}
specifier|private
name|ColumnMetaData
name|metaData
parameter_list|(
name|JavaTypeFactory
name|typeFactory
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|RelDataType
name|fieldType
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|origins
parameter_list|)
block|{
specifier|final
name|ColumnMetaData
operator|.
name|AvaticaType
name|avaticaType
init|=
name|avaticaType
argument_list|(
name|typeFactory
argument_list|,
name|type
argument_list|,
name|fieldType
argument_list|)
decl_stmt|;
return|return
operator|new
name|ColumnMetaData
argument_list|(
name|ordinal
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|type
operator|.
name|isNullable
argument_list|()
condition|?
name|DatabaseMetaData
operator|.
name|columnNullable
else|:
name|DatabaseMetaData
operator|.
name|columnNoNulls
argument_list|,
literal|true
argument_list|,
name|type
operator|.
name|getPrecision
argument_list|()
argument_list|,
name|fieldName
argument_list|,
name|origin
argument_list|(
name|origins
argument_list|,
literal|0
argument_list|)
argument_list|,
name|origin
argument_list|(
name|origins
argument_list|,
literal|2
argument_list|)
argument_list|,
name|getPrecision
argument_list|(
name|type
argument_list|)
argument_list|,
name|getScale
argument_list|(
name|type
argument_list|)
argument_list|,
name|origin
argument_list|(
name|origins
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|null
argument_list|,
name|avaticaType
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|avaticaType
operator|.
name|columnClassName
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|ColumnMetaData
operator|.
name|AvaticaType
name|avaticaType
parameter_list|(
name|JavaTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|,
name|RelDataType
name|fieldType
parameter_list|)
block|{
specifier|final
name|String
name|typeName
init|=
name|getTypeName
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getComponentType
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|ColumnMetaData
operator|.
name|AvaticaType
name|componentType
init|=
name|avaticaType
argument_list|(
name|typeFactory
argument_list|,
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|Type
name|clazz
init|=
name|typeFactory
operator|.
name|getJavaClass
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ColumnMetaData
operator|.
name|Rep
name|rep
init|=
name|ColumnMetaData
operator|.
name|Rep
operator|.
name|of
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
assert|assert
name|rep
operator|!=
literal|null
assert|;
return|return
name|ColumnMetaData
operator|.
name|array
argument_list|(
name|componentType
argument_list|,
name|typeName
argument_list|,
name|rep
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|typeOrdinal
init|=
name|getTypeOrdinal
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|typeOrdinal
condition|)
block|{
case|case
name|Types
operator|.
name|STRUCT
case|:
specifier|final
name|List
argument_list|<
name|ColumnMetaData
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|type
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|columns
operator|.
name|add
argument_list|(
name|metaData
argument_list|(
name|typeFactory
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ColumnMetaData
operator|.
name|struct
argument_list|(
name|columns
argument_list|)
return|;
case|case
name|ExtraSqlTypes
operator|.
name|GEOMETRY
case|:
name|typeOrdinal
operator|=
name|Types
operator|.
name|VARCHAR
expr_stmt|;
comment|// fall through
default|default:
specifier|final
name|Type
name|clazz
init|=
name|typeFactory
operator|.
name|getJavaClass
argument_list|(
name|Util
operator|.
name|first
argument_list|(
name|fieldType
argument_list|,
name|type
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ColumnMetaData
operator|.
name|Rep
name|rep
init|=
name|ColumnMetaData
operator|.
name|Rep
operator|.
name|of
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
assert|assert
name|rep
operator|!=
literal|null
assert|;
return|return
name|ColumnMetaData
operator|.
name|scalar
argument_list|(
name|typeOrdinal
argument_list|,
name|typeName
argument_list|,
name|rep
argument_list|)
return|;
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|origin
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|origins
parameter_list|,
name|int
name|offsetFromEnd
parameter_list|)
block|{
return|return
name|origins
operator|==
literal|null
operator|||
name|offsetFromEnd
operator|>=
name|origins
operator|.
name|size
argument_list|()
condition|?
literal|null
else|:
name|origins
operator|.
name|get
argument_list|(
name|origins
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|-
name|offsetFromEnd
argument_list|)
return|;
block|}
specifier|private
name|int
name|getTypeOrdinal
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getSqlTypeName
argument_list|()
operator|.
name|getJdbcOrdinal
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|String
name|getClassName
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|int
name|getScale
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getScale
argument_list|()
operator|==
name|RelDataType
operator|.
name|SCALE_NOT_SPECIFIED
condition|?
literal|0
else|:
name|type
operator|.
name|getScale
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|int
name|getPrecision
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
operator|.
name|getPrecision
argument_list|()
operator|==
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
condition|?
literal|0
else|:
name|type
operator|.
name|getPrecision
argument_list|()
return|;
block|}
comment|/** Returns the type name in string form. Does not include precision, scale    * or whether nulls are allowed. Example: "DECIMAL" not "DECIMAL(7, 2)";    * "INTEGER" not "JavaType(int)". */
specifier|private
specifier|static
name|String
name|getTypeName
parameter_list|(
name|RelDataType
name|type
parameter_list|)
block|{
specifier|final
name|SqlTypeName
name|sqlTypeName
init|=
name|type
operator|.
name|getSqlTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|sqlTypeName
condition|)
block|{
case|case
name|ARRAY
case|:
case|case
name|MULTISET
case|:
case|case
name|MAP
case|:
case|case
name|ROW
case|:
return|return
name|type
operator|.
name|toString
argument_list|()
return|;
comment|// e.g. "INTEGER ARRAY"
case|case
name|INTERVAL_YEAR_MONTH
case|:
return|return
literal|"INTERVAL_YEAR_TO_MONTH"
return|;
case|case
name|INTERVAL_DAY_HOUR
case|:
return|return
literal|"INTERVAL_DAY_TO_HOUR"
return|;
case|case
name|INTERVAL_DAY_MINUTE
case|:
return|return
literal|"INTERVAL_DAY_TO_MINUTE"
return|;
case|case
name|INTERVAL_DAY_SECOND
case|:
return|return
literal|"INTERVAL_DAY_TO_SECOND"
return|;
case|case
name|INTERVAL_HOUR_MINUTE
case|:
return|return
literal|"INTERVAL_HOUR_TO_MINUTE"
return|;
case|case
name|INTERVAL_HOUR_SECOND
case|:
return|return
literal|"INTERVAL_HOUR_TO_SECOND"
return|;
case|case
name|INTERVAL_MINUTE_SECOND
case|:
return|return
literal|"INTERVAL_MINUTE_TO_SECOND"
return|;
default|default:
return|return
name|sqlTypeName
operator|.
name|getName
argument_list|()
return|;
comment|// e.g. "DECIMAL", "INTERVAL_YEAR_MONTH"
block|}
block|}
specifier|protected
name|void
name|populateMaterializations
parameter_list|(
name|Context
name|context
parameter_list|,
name|RelOptPlanner
name|planner
parameter_list|,
name|Prepare
operator|.
name|Materialization
name|materialization
parameter_list|)
block|{
comment|// REVIEW: initialize queryRel and tableRel inside MaterializationService,
comment|// not here?
try|try
block|{
specifier|final
name|CalciteSchema
name|schema
init|=
name|materialization
operator|.
name|materializedTable
operator|.
name|schema
decl_stmt|;
name|CalciteCatalogReader
name|catalogReader
init|=
operator|new
name|CalciteCatalogReader
argument_list|(
name|schema
operator|.
name|root
argument_list|()
argument_list|,
name|materialization
operator|.
name|viewSchemaPath
argument_list|,
name|context
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|context
operator|.
name|config
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|CalciteMaterializer
name|materializer
init|=
operator|new
name|CalciteMaterializer
argument_list|(
name|this
argument_list|,
name|context
argument_list|,
name|catalogReader
argument_list|,
name|schema
argument_list|,
name|planner
argument_list|,
name|createConvertletTable
argument_list|()
argument_list|)
decl_stmt|;
name|materializer
operator|.
name|populate
argument_list|(
name|materialization
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"While populating materialization "
operator|+
name|materialization
operator|.
name|materializedTable
operator|.
name|path
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|RelDataType
name|makeStruct
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isStruct
argument_list|()
condition|)
block|{
return|return
name|type
return|;
block|}
return|return
name|typeFactory
operator|.
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"$0"
argument_list|,
name|type
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Executes a prepare action. */
specifier|public
parameter_list|<
name|R
parameter_list|>
name|R
name|perform
parameter_list|(
name|CalciteServerStatement
name|statement
parameter_list|,
name|Frameworks
operator|.
name|PrepareAction
argument_list|<
name|R
argument_list|>
name|action
parameter_list|)
block|{
specifier|final
name|CalcitePrepare
operator|.
name|Context
name|prepareContext
init|=
name|statement
operator|.
name|createPrepareContext
argument_list|()
decl_stmt|;
specifier|final
name|JavaTypeFactory
name|typeFactory
init|=
name|prepareContext
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|CalciteSchema
name|schema
init|=
name|action
operator|.
name|getConfig
argument_list|()
operator|.
name|getDefaultSchema
argument_list|()
operator|!=
literal|null
condition|?
name|CalciteSchema
operator|.
name|from
argument_list|(
name|action
operator|.
name|getConfig
argument_list|()
operator|.
name|getDefaultSchema
argument_list|()
argument_list|)
else|:
name|prepareContext
operator|.
name|getRootSchema
argument_list|()
decl_stmt|;
name|CalciteCatalogReader
name|catalogReader
init|=
operator|new
name|CalciteCatalogReader
argument_list|(
name|schema
operator|.
name|root
argument_list|()
argument_list|,
name|schema
operator|.
name|path
argument_list|(
literal|null
argument_list|)
argument_list|,
name|typeFactory
argument_list|,
name|prepareContext
operator|.
name|config
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
operator|new
name|RexBuilder
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|RelOptPlanner
name|planner
init|=
name|createPlanner
argument_list|(
name|prepareContext
argument_list|,
name|action
operator|.
name|getConfig
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|action
operator|.
name|getConfig
argument_list|()
operator|.
name|getCostFactory
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelOptCluster
name|cluster
init|=
name|createCluster
argument_list|(
name|planner
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
return|return
name|action
operator|.
name|apply
argument_list|(
name|cluster
argument_list|,
name|catalogReader
argument_list|,
name|prepareContext
operator|.
name|getRootSchema
argument_list|()
operator|.
name|plus
argument_list|()
argument_list|,
name|statement
argument_list|)
return|;
block|}
comment|/** Holds state for the process of preparing a SQL statement. */
specifier|static
class|class
name|CalcitePreparingStmt
extends|extends
name|Prepare
implements|implements
name|RelOptTable
operator|.
name|ViewExpander
block|{
specifier|protected
specifier|final
name|RelOptPlanner
name|planner
decl_stmt|;
specifier|protected
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
specifier|protected
specifier|final
name|CalcitePrepareImpl
name|prepare
decl_stmt|;
specifier|protected
specifier|final
name|CalciteSchema
name|schema
decl_stmt|;
specifier|protected
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
specifier|protected
specifier|final
name|SqlRexConvertletTable
name|convertletTable
decl_stmt|;
specifier|private
specifier|final
name|EnumerableRel
operator|.
name|Prefer
name|prefer
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|internalParameters
init|=
name|Maps
operator|.
name|newLinkedHashMap
argument_list|()
decl_stmt|;
specifier|private
name|int
name|expansionDepth
decl_stmt|;
specifier|private
name|SqlValidator
name|sqlValidator
decl_stmt|;
name|CalcitePreparingStmt
parameter_list|(
name|CalcitePrepareImpl
name|prepare
parameter_list|,
name|Context
name|context
parameter_list|,
name|CatalogReader
name|catalogReader
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|CalciteSchema
name|schema
parameter_list|,
name|EnumerableRel
operator|.
name|Prefer
name|prefer
parameter_list|,
name|RelOptPlanner
name|planner
parameter_list|,
name|Convention
name|resultConvention
parameter_list|,
name|SqlRexConvertletTable
name|convertletTable
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|,
name|catalogReader
argument_list|,
name|resultConvention
argument_list|)
expr_stmt|;
name|this
operator|.
name|prepare
operator|=
name|prepare
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|prefer
operator|=
name|prefer
expr_stmt|;
name|this
operator|.
name|planner
operator|=
name|planner
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|typeFactory
expr_stmt|;
name|this
operator|.
name|convertletTable
operator|=
name|convertletTable
expr_stmt|;
name|this
operator|.
name|rexBuilder
operator|=
operator|new
name|RexBuilder
argument_list|(
name|typeFactory
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|init
parameter_list|(
name|Class
name|runtimeContextClass
parameter_list|)
block|{
block|}
specifier|public
name|PreparedResult
name|prepareQueryable
parameter_list|(
specifier|final
name|Queryable
name|queryable
parameter_list|,
name|RelDataType
name|resultType
parameter_list|)
block|{
return|return
name|prepare_
argument_list|(
operator|new
name|Supplier
argument_list|<
name|RelNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RelNode
name|get
parameter_list|()
block|{
specifier|final
name|RelOptCluster
name|cluster
init|=
name|prepare
operator|.
name|createCluster
argument_list|(
name|planner
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
return|return
operator|new
name|LixToRelTranslator
argument_list|(
name|cluster
argument_list|,
name|CalcitePreparingStmt
operator|.
name|this
argument_list|)
operator|.
name|translate
argument_list|(
name|queryable
argument_list|)
return|;
block|}
block|}
argument_list|,
name|resultType
argument_list|)
return|;
block|}
specifier|public
name|PreparedResult
name|prepareRel
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
return|return
name|prepare_
argument_list|(
operator|new
name|Supplier
argument_list|<
name|RelNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RelNode
name|get
parameter_list|()
block|{
return|return
name|rel
return|;
block|}
block|}
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|PreparedResult
name|prepare_
parameter_list|(
name|Supplier
argument_list|<
name|RelNode
argument_list|>
name|fn
parameter_list|,
name|RelDataType
name|resultType
parameter_list|)
block|{
name|Class
name|runtimeContextClass
init|=
name|Object
operator|.
name|class
decl_stmt|;
name|init
argument_list|(
name|runtimeContextClass
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|rel
init|=
name|fn
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|fields
init|=
name|Pair
operator|.
name|zip
argument_list|(
name|ImmutableIntList
operator|.
name|identity
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|,
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelCollation
name|collation
init|=
name|rel
operator|instanceof
name|Sort
condition|?
operator|(
operator|(
name|Sort
operator|)
name|rel
operator|)
operator|.
name|collation
else|:
name|RelCollations
operator|.
name|EMPTY
decl_stmt|;
name|RelRoot
name|root
init|=
operator|new
name|RelRoot
argument_list|(
name|rel
argument_list|,
name|resultType
argument_list|,
name|SqlKind
operator|.
name|SELECT
argument_list|,
name|fields
argument_list|,
name|collation
argument_list|)
decl_stmt|;
if|if
condition|(
name|timingTracer
operator|!=
literal|null
condition|)
block|{
name|timingTracer
operator|.
name|traceTime
argument_list|(
literal|"end sql2rel"
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|jdbcType
init|=
name|makeStruct
argument_list|(
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|resultType
argument_list|)
decl_stmt|;
name|fieldOrigins
operator|=
name|Collections
operator|.
name|nCopies
argument_list|(
name|jdbcType
operator|.
name|getFieldCount
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|parameterRowType
operator|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// Structured type flattening, view expansion, and plugging in
comment|// physical storage.
name|root
operator|=
name|root
operator|.
name|withRel
argument_list|(
name|flattenTypes
argument_list|(
name|root
operator|.
name|rel
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// Trim unused fields.
name|root
operator|=
name|trimUnusedFields
argument_list|(
name|root
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Materialization
argument_list|>
name|materializations
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|CalciteSchema
operator|.
name|LatticeEntry
argument_list|>
name|lattices
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
name|root
operator|=
name|optimize
argument_list|(
name|root
argument_list|,
name|materializations
argument_list|,
name|lattices
argument_list|)
expr_stmt|;
if|if
condition|(
name|timingTracer
operator|!=
literal|null
condition|)
block|{
name|timingTracer
operator|.
name|traceTime
argument_list|(
literal|"end optimization"
argument_list|)
expr_stmt|;
block|}
return|return
name|implement
argument_list|(
name|root
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|SqlToRelConverter
name|getSqlToRelConverter
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|CatalogReader
name|catalogReader
parameter_list|,
name|SqlToRelConverter
operator|.
name|Config
name|config
parameter_list|)
block|{
specifier|final
name|RelOptCluster
name|cluster
init|=
name|prepare
operator|.
name|createCluster
argument_list|(
name|planner
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlToRelConverter
argument_list|(
name|this
argument_list|,
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|cluster
argument_list|,
name|convertletTable
argument_list|,
name|config
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelNode
name|flattenTypes
parameter_list|(
name|RelNode
name|rootRel
parameter_list|,
name|boolean
name|restructure
parameter_list|)
block|{
specifier|final
name|SparkHandler
name|spark
init|=
name|context
operator|.
name|spark
argument_list|()
decl_stmt|;
if|if
condition|(
name|spark
operator|.
name|enabled
argument_list|()
condition|)
block|{
return|return
name|spark
operator|.
name|flattenTypes
argument_list|(
name|planner
argument_list|,
name|rootRel
argument_list|,
name|restructure
argument_list|)
return|;
block|}
return|return
name|rootRel
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RelNode
name|decorrelate
parameter_list|(
name|SqlToRelConverter
name|sqlToRelConverter
parameter_list|,
name|SqlNode
name|query
parameter_list|,
name|RelNode
name|rootRel
parameter_list|)
block|{
return|return
name|sqlToRelConverter
operator|.
name|decorrelate
argument_list|(
name|query
argument_list|,
name|rootRel
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RelRoot
name|expandView
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|String
name|queryString
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|schemaPath
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|viewPath
parameter_list|)
block|{
name|expansionDepth
operator|++
expr_stmt|;
name|SqlParser
name|parser
init|=
name|prepare
operator|.
name|createParser
argument_list|(
name|queryString
argument_list|)
decl_stmt|;
name|SqlNode
name|sqlNode
decl_stmt|;
try|try
block|{
name|sqlNode
operator|=
name|parser
operator|.
name|parseQuery
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"parse failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// View may have different schema path than current connection.
specifier|final
name|CatalogReader
name|catalogReader
init|=
name|this
operator|.
name|catalogReader
operator|.
name|withSchemaPath
argument_list|(
name|schemaPath
argument_list|)
decl_stmt|;
name|SqlValidator
name|validator
init|=
name|createSqlValidator
argument_list|(
name|catalogReader
argument_list|)
decl_stmt|;
name|SqlNode
name|sqlNode1
init|=
name|validator
operator|.
name|validate
argument_list|(
name|sqlNode
argument_list|)
decl_stmt|;
specifier|final
name|SqlToRelConverter
operator|.
name|Config
name|config
init|=
name|SqlToRelConverter
operator|.
name|configBuilder
argument_list|()
operator|.
name|withTrimUnusedFields
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|SqlToRelConverter
name|sqlToRelConverter
init|=
name|getSqlToRelConverter
argument_list|(
name|validator
argument_list|,
name|catalogReader
argument_list|,
name|config
argument_list|)
decl_stmt|;
name|RelRoot
name|root
init|=
name|sqlToRelConverter
operator|.
name|convertQuery
argument_list|(
name|sqlNode1
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
operator|--
name|expansionDepth
expr_stmt|;
return|return
name|root
return|;
block|}
specifier|protected
name|SqlValidator
name|createSqlValidator
parameter_list|(
name|CatalogReader
name|catalogReader
parameter_list|)
block|{
return|return
name|prepare
operator|.
name|createSqlValidator
argument_list|(
name|context
argument_list|,
operator|(
name|CalciteCatalogReader
operator|)
name|catalogReader
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|SqlValidator
name|getSqlValidator
parameter_list|()
block|{
if|if
condition|(
name|sqlValidator
operator|==
literal|null
condition|)
block|{
name|sqlValidator
operator|=
name|createSqlValidator
argument_list|(
name|catalogReader
argument_list|)
expr_stmt|;
block|}
return|return
name|sqlValidator
return|;
block|}
annotation|@
name|Override
specifier|protected
name|PreparedResult
name|createPreparedExplanation
parameter_list|(
name|RelDataType
name|resultType
parameter_list|,
name|RelDataType
name|parameterRowType
parameter_list|,
name|RelRoot
name|root
parameter_list|,
name|SqlExplainFormat
name|format
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
return|return
operator|new
name|CalcitePreparedExplain
argument_list|(
name|resultType
argument_list|,
name|parameterRowType
argument_list|,
name|root
argument_list|,
name|format
argument_list|,
name|detailLevel
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|PreparedResult
name|implement
parameter_list|(
name|RelRoot
name|root
parameter_list|)
block|{
name|RelDataType
name|resultType
init|=
name|root
operator|.
name|rel
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|boolean
name|isDml
init|=
name|root
operator|.
name|kind
operator|.
name|belongsTo
argument_list|(
name|SqlKind
operator|.
name|DML
argument_list|)
decl_stmt|;
specifier|final
name|Bindable
name|bindable
decl_stmt|;
if|if
condition|(
name|resultConvention
operator|==
name|BindableConvention
operator|.
name|INSTANCE
condition|)
block|{
name|bindable
operator|=
name|Interpreters
operator|.
name|bindable
argument_list|(
name|root
operator|.
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EnumerableRel
name|enumerable
init|=
operator|(
name|EnumerableRel
operator|)
name|root
operator|.
name|rel
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|.
name|isRefTrivial
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|enumerable
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|Pair
operator|.
name|left
argument_list|(
name|root
operator|.
name|fields
argument_list|)
control|)
block|{
name|projects
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|enumerable
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexProgram
name|program
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|enumerable
operator|.
name|getRowType
argument_list|()
argument_list|,
name|projects
argument_list|,
literal|null
argument_list|,
name|root
operator|.
name|validatedRowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|enumerable
operator|=
name|EnumerableCalc
operator|.
name|create
argument_list|(
name|enumerable
argument_list|,
name|program
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|CatalogReader
operator|.
name|THREAD_LOCAL
operator|.
name|set
argument_list|(
name|catalogReader
argument_list|)
expr_stmt|;
name|bindable
operator|=
name|EnumerableInterpretable
operator|.
name|toBindable
argument_list|(
name|internalParameters
argument_list|,
name|context
operator|.
name|spark
argument_list|()
argument_list|,
name|enumerable
argument_list|,
name|prefer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|CatalogReader
operator|.
name|THREAD_LOCAL
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timingTracer
operator|!=
literal|null
condition|)
block|{
name|timingTracer
operator|.
name|traceTime
argument_list|(
literal|"end codegen"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timingTracer
operator|!=
literal|null
condition|)
block|{
name|timingTracer
operator|.
name|traceTime
argument_list|(
literal|"end compilation"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|PreparedResultImpl
argument_list|(
name|resultType
argument_list|,
name|parameterRowType
argument_list|,
name|fieldOrigins
argument_list|,
name|root
operator|.
name|collation
operator|.
name|getFieldCollations
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
name|ImmutableList
operator|.
expr|<
name|RelCollation
operator|>
name|of
argument_list|()
else|:
name|ImmutableList
operator|.
name|of
argument_list|(
name|root
operator|.
name|collation
argument_list|)
argument_list|,
name|root
operator|.
name|rel
argument_list|,
name|mapTableModOp
argument_list|(
name|isDml
argument_list|,
name|root
operator|.
name|kind
argument_list|)
argument_list|,
name|isDml
argument_list|)
block|{
specifier|public
name|String
name|getCode
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|Bindable
name|getBindable
parameter_list|(
name|Meta
operator|.
name|CursorFactory
name|cursorFactory
parameter_list|)
block|{
return|return
name|bindable
return|;
block|}
specifier|public
name|Type
name|getElementType
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Typed
operator|)
name|bindable
operator|)
operator|.
name|getElementType
argument_list|()
return|;
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|protected
name|List
argument_list|<
name|Materialization
argument_list|>
name|getMaterializations
parameter_list|()
block|{
specifier|final
name|List
argument_list|<
name|Prepare
operator|.
name|Materialization
argument_list|>
name|materializations
init|=
name|context
operator|.
name|config
argument_list|()
operator|.
name|materializationsEnabled
argument_list|()
condition|?
name|MaterializationService
operator|.
name|instance
argument_list|()
operator|.
name|query
argument_list|(
name|schema
argument_list|)
else|:
name|ImmutableList
operator|.
expr|<
name|Prepare
operator|.
name|Materialization
operator|>
name|of
argument_list|()
decl_stmt|;
for|for
control|(
name|Prepare
operator|.
name|Materialization
name|materialization
range|:
name|materializations
control|)
block|{
name|prepare
operator|.
name|populateMaterializations
argument_list|(
name|context
argument_list|,
name|planner
argument_list|,
name|materialization
argument_list|)
expr_stmt|;
block|}
return|return
name|materializations
return|;
block|}
annotation|@
name|Override
specifier|protected
name|List
argument_list|<
name|LatticeEntry
argument_list|>
name|getLattices
parameter_list|()
block|{
return|return
name|Schemas
operator|.
name|getLatticeEntries
argument_list|(
name|schema
argument_list|)
return|;
block|}
block|}
comment|/** An {@code EXPLAIN} statement, prepared and ready to execute. */
specifier|private
specifier|static
class|class
name|CalcitePreparedExplain
extends|extends
name|Prepare
operator|.
name|PreparedExplain
block|{
name|CalcitePreparedExplain
parameter_list|(
name|RelDataType
name|resultType
parameter_list|,
name|RelDataType
name|parameterRowType
parameter_list|,
name|RelRoot
name|root
parameter_list|,
name|SqlExplainFormat
name|format
parameter_list|,
name|SqlExplainLevel
name|detailLevel
parameter_list|)
block|{
name|super
argument_list|(
name|resultType
argument_list|,
name|parameterRowType
argument_list|,
name|root
argument_list|,
name|format
argument_list|,
name|detailLevel
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Bindable
name|getBindable
parameter_list|(
specifier|final
name|Meta
operator|.
name|CursorFactory
name|cursorFactory
parameter_list|)
block|{
specifier|final
name|String
name|explanation
init|=
name|getCode
argument_list|()
decl_stmt|;
return|return
operator|new
name|Bindable
argument_list|()
block|{
specifier|public
name|Enumerable
name|bind
parameter_list|(
name|DataContext
name|dataContext
parameter_list|)
block|{
switch|switch
condition|(
name|cursorFactory
operator|.
name|style
condition|)
block|{
case|case
name|ARRAY
case|:
return|return
name|Linq4j
operator|.
name|singletonEnumerable
argument_list|(
operator|new
name|String
index|[]
block|{
name|explanation
block|}
argument_list|)
return|;
case|case
name|OBJECT
case|:
default|default:
return|return
name|Linq4j
operator|.
name|singletonEnumerable
argument_list|(
name|explanation
argument_list|)
return|;
block|}
block|}
block|}
return|;
block|}
block|}
comment|/** Translator from Java AST to {@link RexNode}. */
interface|interface
name|ScalarTranslator
block|{
name|RexNode
name|toRex
parameter_list|(
name|BlockStatement
name|statement
parameter_list|)
function_decl|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|toRexList
parameter_list|(
name|BlockStatement
name|statement
parameter_list|)
function_decl|;
name|RexNode
name|toRex
parameter_list|(
name|Expression
name|expression
parameter_list|)
function_decl|;
name|ScalarTranslator
name|bind
parameter_list|(
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterList
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|values
parameter_list|)
function_decl|;
block|}
comment|/** Basic translator. */
specifier|static
class|class
name|EmptyScalarTranslator
implements|implements
name|ScalarTranslator
block|{
specifier|private
specifier|final
name|RexBuilder
name|rexBuilder
decl_stmt|;
name|EmptyScalarTranslator
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|)
block|{
name|this
operator|.
name|rexBuilder
operator|=
name|rexBuilder
expr_stmt|;
block|}
specifier|public
specifier|static
name|ScalarTranslator
name|empty
parameter_list|(
name|RexBuilder
name|builder
parameter_list|)
block|{
return|return
operator|new
name|EmptyScalarTranslator
argument_list|(
name|builder
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|toRexList
parameter_list|(
name|BlockStatement
name|statement
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Expression
argument_list|>
name|simpleList
init|=
name|simpleList
argument_list|(
name|statement
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Expression
name|expression1
range|:
name|simpleList
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|toRex
argument_list|(
name|expression1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|public
name|RexNode
name|toRex
parameter_list|(
name|BlockStatement
name|statement
parameter_list|)
block|{
return|return
name|toRex
argument_list|(
name|Blocks
operator|.
name|simple
argument_list|(
name|statement
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Expression
argument_list|>
name|simpleList
parameter_list|(
name|BlockStatement
name|statement
parameter_list|)
block|{
name|Expression
name|simple
init|=
name|Blocks
operator|.
name|simple
argument_list|(
name|statement
argument_list|)
decl_stmt|;
if|if
condition|(
name|simple
operator|instanceof
name|NewExpression
condition|)
block|{
name|NewExpression
name|newExpression
init|=
operator|(
name|NewExpression
operator|)
name|simple
decl_stmt|;
return|return
name|newExpression
operator|.
name|arguments
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|simple
argument_list|)
return|;
block|}
block|}
specifier|public
name|RexNode
name|toRex
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
switch|switch
condition|(
name|expression
operator|.
name|getNodeType
argument_list|()
condition|)
block|{
case|case
name|MemberAccess
case|:
comment|// Case-sensitive name match because name was previously resolved.
return|return
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|toRex
argument_list|(
operator|(
operator|(
name|MemberExpression
operator|)
name|expression
operator|)
operator|.
name|expression
argument_list|)
argument_list|,
operator|(
operator|(
name|MemberExpression
operator|)
name|expression
operator|)
operator|.
name|field
operator|.
name|getName
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
case|case
name|GreaterThan
case|:
return|return
name|binary
argument_list|(
name|expression
argument_list|,
name|SqlStdOperatorTable
operator|.
name|GREATER_THAN
argument_list|)
return|;
case|case
name|LessThan
case|:
return|return
name|binary
argument_list|(
name|expression
argument_list|,
name|SqlStdOperatorTable
operator|.
name|LESS_THAN
argument_list|)
return|;
case|case
name|Parameter
case|:
return|return
name|parameter
argument_list|(
operator|(
name|ParameterExpression
operator|)
name|expression
argument_list|)
return|;
case|case
name|Call
case|:
name|MethodCallExpression
name|call
init|=
operator|(
name|MethodCallExpression
operator|)
name|expression
decl_stmt|;
name|SqlOperator
name|operator
init|=
name|RexToLixTranslator
operator|.
name|JAVA_TO_SQL_METHOD_MAP
operator|.
name|get
argument_list|(
name|call
operator|.
name|method
argument_list|)
decl_stmt|;
if|if
condition|(
name|operator
operator|!=
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|(
name|call
argument_list|)
argument_list|,
name|operator
argument_list|,
name|toRex
argument_list|(
name|Expressions
operator|.
expr|<
name|Expression
operator|>
name|list
argument_list|()
operator|.
name|appendIfNotNull
argument_list|(
name|call
operator|.
name|targetExpression
argument_list|)
operator|.
name|appendAll
argument_list|(
name|call
operator|.
name|expressions
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could translate call to method "
operator|+
name|call
operator|.
name|method
argument_list|)
throw|;
case|case
name|Constant
case|:
specifier|final
name|ConstantExpression
name|constant
init|=
operator|(
name|ConstantExpression
operator|)
name|expression
decl_stmt|;
name|Object
name|value
init|=
name|constant
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|Number
name|number
init|=
operator|(
name|Number
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Double
operator|||
name|value
operator|instanceof
name|Float
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|number
operator|.
name|doubleValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|BigDecimal
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|number
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
name|constant
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"unknown expression type "
operator|+
name|expression
operator|.
name|getNodeType
argument_list|()
operator|+
literal|" "
operator|+
name|expression
argument_list|)
throw|;
block|}
block|}
specifier|private
name|RexNode
name|binary
parameter_list|(
name|Expression
name|expression
parameter_list|,
name|SqlBinaryOperator
name|op
parameter_list|)
block|{
name|BinaryExpression
name|call
init|=
operator|(
name|BinaryExpression
operator|)
name|expression
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|(
name|call
argument_list|)
argument_list|,
name|op
argument_list|,
name|toRex
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|call
operator|.
name|expression0
argument_list|,
name|call
operator|.
name|expression1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|toRex
parameter_list|(
name|List
argument_list|<
name|Expression
argument_list|>
name|expressions
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Expression
name|expression
range|:
name|expressions
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|toRex
argument_list|(
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
specifier|protected
name|RelDataType
name|type
parameter_list|(
name|Expression
name|expression
parameter_list|)
block|{
specifier|final
name|Type
name|type
init|=
name|expression
operator|.
name|getType
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|JavaTypeFactory
operator|)
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|)
operator|.
name|createType
argument_list|(
name|type
argument_list|)
return|;
block|}
specifier|public
name|ScalarTranslator
name|bind
parameter_list|(
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterList
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|values
parameter_list|)
block|{
return|return
operator|new
name|LambdaScalarTranslator
argument_list|(
name|rexBuilder
argument_list|,
name|parameterList
argument_list|,
name|values
argument_list|)
return|;
block|}
specifier|public
name|RexNode
name|parameter
parameter_list|(
name|ParameterExpression
name|param
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown parameter "
operator|+
name|param
argument_list|)
throw|;
block|}
block|}
comment|/** Translator that looks for parameters. */
specifier|private
specifier|static
class|class
name|LambdaScalarTranslator
extends|extends
name|EmptyScalarTranslator
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterList
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|values
decl_stmt|;
name|LambdaScalarTranslator
parameter_list|(
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|ParameterExpression
argument_list|>
name|parameterList
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|values
parameter_list|)
block|{
name|super
argument_list|(
name|rexBuilder
argument_list|)
expr_stmt|;
name|this
operator|.
name|parameterList
operator|=
name|parameterList
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
block|}
specifier|public
name|RexNode
name|parameter
parameter_list|(
name|ParameterExpression
name|param
parameter_list|)
block|{
name|int
name|i
init|=
name|parameterList
operator|.
name|indexOf
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
return|return
name|values
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown parameter "
operator|+
name|param
argument_list|)
throw|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End CalcitePrepareImpl.java
end_comment

end_unit

