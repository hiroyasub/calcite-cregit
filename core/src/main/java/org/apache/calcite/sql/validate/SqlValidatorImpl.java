begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|config
operator|.
name|NullCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|jdbc
operator|.
name|CalciteSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|function
operator|.
name|Function2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|prepare
operator|.
name|Prepare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|DynamicRecordType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelRecordType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexPatternFieldRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteContextException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Feature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|impl
operator|.
name|ModifiableViewTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinConditionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|JoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAccessEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCallBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDataTypeSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDelete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlDynamicParam
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlExplain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunctionCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlInsert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMatchRecognize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlMerge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNodeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOrderBy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSampleSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelectKeyword
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSyntax
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUnresolvedFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUpdate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWithItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|AssignableOperandTypeChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlOperandTypeInference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlBasicVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|InitializerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BitString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Bug
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableNullableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteTrace
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
operator|.
name|stripAs
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * Default implementation of {@link SqlValidator}.  */
end_comment

begin_class
specifier|public
class|class
name|SqlValidatorImpl
implements|implements
name|SqlValidatorWithHints
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|public
specifier|static
specifier|final
name|Logger
name|TRACER
init|=
name|CalciteTrace
operator|.
name|PARSER_LOGGER
decl_stmt|;
comment|/**    * Alias generated for the source table when rewriting UPDATE to MERGE.    */
specifier|public
specifier|static
specifier|final
name|String
name|UPDATE_SRC_ALIAS
init|=
literal|"SYS$SRC"
decl_stmt|;
comment|/**    * Alias generated for the target table when rewriting UPDATE to MERGE if no    * alias was specified by the user.    */
specifier|public
specifier|static
specifier|final
name|String
name|UPDATE_TGT_ALIAS
init|=
literal|"SYS$TGT"
decl_stmt|;
comment|/**    * Alias prefix generated for source columns when rewriting UPDATE to MERGE.    */
specifier|public
specifier|static
specifier|final
name|String
name|UPDATE_ANON_PREFIX
init|=
literal|"SYS$ANON"
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|SqlOperatorTable
name|opTab
decl_stmt|;
specifier|final
name|SqlValidatorCatalogReader
name|catalogReader
decl_stmt|;
comment|/**    * Maps ParsePosition strings to the {@link SqlIdentifier} identifier    * objects at these positions    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|IdInfo
argument_list|>
name|idPositions
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Maps {@link SqlNode query node} objects to the {@link SqlValidatorScope}    * scope created from them.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|SqlValidatorScope
argument_list|>
name|scopes
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node to the scope used by its WHERE and HAVING    * clauses.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|whereScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node to the scope used by its GROUP BY clause.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|groupByScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node to the scope used by its SELECT and HAVING    * clauses.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|selectScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node to the scope used by its ORDER BY clause.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|orderScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Maps a {@link SqlSelect} node that is the argument to a CURSOR    * constructor to the scope of the result of that select node    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlSelect
argument_list|,
name|SqlValidatorScope
argument_list|>
name|cursorScopes
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The name-resolution scope of a LATERAL TABLE clause.    */
specifier|private
name|TableScope
name|tableScope
init|=
literal|null
decl_stmt|;
comment|/**    * Maps a {@link SqlNode node} to the    * {@link SqlValidatorNamespace namespace} which describes what columns they    * contain.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|SqlValidatorNamespace
argument_list|>
name|namespaces
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Set of select expressions used as cursor definitions. In standard SQL,    * only the top-level SELECT is a cursor; Calcite extends this with    * cursors as inputs to table functions.    */
specifier|private
specifier|final
name|Set
argument_list|<
name|SqlNode
argument_list|>
name|cursorSet
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
comment|/**    * Stack of objects that maintain information about function calls. A stack    * is needed to handle nested function calls. The function call currently    * being validated is at the top of the stack.    */
specifier|protected
specifier|final
name|Deque
argument_list|<
name|FunctionParamInfo
argument_list|>
name|functionCallStack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nextGeneratedId
decl_stmt|;
specifier|protected
specifier|final
name|RelDataTypeFactory
name|typeFactory
decl_stmt|;
comment|/** The type of dynamic parameters until a type is imposed on them. */
specifier|protected
specifier|final
name|RelDataType
name|unknownType
decl_stmt|;
specifier|private
specifier|final
name|RelDataType
name|booleanType
decl_stmt|;
comment|/**    * Map of derived RelDataType for each node. This is an IdentityHashMap    * since in some cases (such as null literals) we need to discriminate by    * instance.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|RelDataType
argument_list|>
name|nodeToTypeMap
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AggFinder
name|aggFinder
decl_stmt|;
specifier|private
specifier|final
name|AggFinder
name|aggOrOverFinder
decl_stmt|;
specifier|private
specifier|final
name|AggFinder
name|aggOrOverOrGroupFinder
decl_stmt|;
specifier|private
specifier|final
name|AggFinder
name|groupFinder
decl_stmt|;
specifier|private
specifier|final
name|AggFinder
name|overFinder
decl_stmt|;
specifier|private
specifier|final
name|SqlConformance
name|conformance
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|SqlNode
argument_list|,
name|SqlNode
argument_list|>
name|originalExprs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|SqlNode
name|top
decl_stmt|;
comment|// REVIEW jvs 30-June-2006: subclasses may override shouldExpandIdentifiers
comment|// in a way that ignores this; we should probably get rid of the protected
comment|// method and always use this variable (or better, move preferences like
comment|// this to a separate "parameter" class)
specifier|protected
name|boolean
name|expandIdentifiers
decl_stmt|;
specifier|protected
name|boolean
name|expandColumnReferences
decl_stmt|;
specifier|private
name|boolean
name|rewriteCalls
decl_stmt|;
specifier|private
name|NullCollation
name|nullCollation
init|=
name|NullCollation
operator|.
name|HIGH
decl_stmt|;
comment|// TODO jvs 11-Dec-2008:  make this local to performUnconditionalRewrites
comment|// if it's OK to expand the signature of that method.
specifier|private
name|boolean
name|validatingSqlMerge
decl_stmt|;
specifier|private
name|boolean
name|inWindow
decl_stmt|;
comment|// Allow nested aggregates
specifier|private
specifier|final
name|SqlValidatorImpl
operator|.
name|ValidationErrorFunction
name|validationErrorFunction
init|=
operator|new
name|SqlValidatorImpl
operator|.
name|ValidationErrorFunction
argument_list|()
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a validator.    *    * @param opTab         Operator table    * @param catalogReader Catalog reader    * @param typeFactory   Type factory    * @param conformance   Compatibility mode    */
specifier|protected
name|SqlValidatorImpl
parameter_list|(
name|SqlOperatorTable
name|opTab
parameter_list|,
name|SqlValidatorCatalogReader
name|catalogReader
parameter_list|,
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|SqlConformance
name|conformance
parameter_list|)
block|{
name|this
operator|.
name|opTab
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|opTab
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogReader
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|catalogReader
argument_list|)
expr_stmt|;
name|this
operator|.
name|typeFactory
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|typeFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|conformance
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|conformance
argument_list|)
expr_stmt|;
name|unknownType
operator|=
name|typeFactory
operator|.
name|createUnknownType
argument_list|()
expr_stmt|;
name|booleanType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|)
expr_stmt|;
name|rewriteCalls
operator|=
literal|true
expr_stmt|;
name|expandColumnReferences
operator|=
literal|true
expr_stmt|;
name|aggFinder
operator|=
operator|new
name|AggFinder
argument_list|(
name|opTab
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|aggOrOverFinder
operator|=
operator|new
name|AggFinder
argument_list|(
name|opTab
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|overFinder
operator|=
operator|new
name|AggFinder
argument_list|(
name|opTab
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|aggOrOverFinder
argument_list|)
expr_stmt|;
name|groupFinder
operator|=
operator|new
name|AggFinder
argument_list|(
name|opTab
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|aggOrOverOrGroupFinder
operator|=
operator|new
name|AggFinder
argument_list|(
name|opTab
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|public
name|SqlConformance
name|getConformance
parameter_list|()
block|{
return|return
name|conformance
return|;
block|}
specifier|public
name|SqlValidatorCatalogReader
name|getCatalogReader
parameter_list|()
block|{
return|return
name|catalogReader
return|;
block|}
specifier|public
name|SqlOperatorTable
name|getOperatorTable
parameter_list|()
block|{
return|return
name|opTab
return|;
block|}
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|typeFactory
return|;
block|}
specifier|public
name|RelDataType
name|getUnknownType
parameter_list|()
block|{
return|return
name|unknownType
return|;
block|}
specifier|public
name|SqlNodeList
name|expandStar
parameter_list|(
name|SqlNodeList
name|selectList
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|boolean
name|includeSystemVars
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|SqlNode
name|selectItem
init|=
name|selectList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|expandSelectItem
argument_list|(
name|selectItem
argument_list|,
name|select
argument_list|,
name|unknownType
argument_list|,
name|list
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
condition|?
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
argument_list|,
name|types
argument_list|,
name|includeSystemVars
argument_list|)
expr_stmt|;
block|}
name|getRawSelectScope
argument_list|(
name|select
argument_list|)
operator|.
name|setExpandedSelectList
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlNodeList
argument_list|(
name|list
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|declareCursor
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlValidatorScope
name|parentScope
parameter_list|)
block|{
name|cursorSet
operator|.
name|add
argument_list|(
name|select
argument_list|)
expr_stmt|;
comment|// add the cursor to a map that maps the cursor to its select based on
comment|// the position of the cursor relative to other cursors in that call
name|FunctionParamInfo
name|funcParamInfo
init|=
name|functionCallStack
operator|.
name|peek
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|SqlSelect
argument_list|>
name|cursorMap
init|=
name|funcParamInfo
operator|.
name|cursorPosToSelectMap
decl_stmt|;
name|int
name|numCursors
init|=
name|cursorMap
operator|.
name|size
argument_list|()
decl_stmt|;
name|cursorMap
operator|.
name|put
argument_list|(
name|numCursors
argument_list|,
name|select
argument_list|)
expr_stmt|;
comment|// create a namespace associated with the result of the select
comment|// that is the argument to the cursor constructor; register it
comment|// with a scope corresponding to the cursor
name|SelectScope
name|cursorScope
init|=
operator|new
name|SelectScope
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|cursorScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|cursorScope
argument_list|)
expr_stmt|;
specifier|final
name|SelectNamespace
name|selectNs
init|=
name|createSelectNamespace
argument_list|(
name|select
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|select
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|cursorScope
argument_list|,
name|alias
argument_list|,
name|selectNs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|pushFunctionCall
parameter_list|()
block|{
name|FunctionParamInfo
name|funcInfo
init|=
operator|new
name|FunctionParamInfo
argument_list|()
decl_stmt|;
name|functionCallStack
operator|.
name|push
argument_list|(
name|funcInfo
argument_list|)
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|popFunctionCall
parameter_list|()
block|{
name|functionCallStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|String
name|getParentCursor
parameter_list|(
name|String
name|columnListParamName
parameter_list|)
block|{
name|FunctionParamInfo
name|funcParamInfo
init|=
name|functionCallStack
operator|.
name|peek
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|parentCursorMap
init|=
name|funcParamInfo
operator|.
name|columnListParamToParentCursorMap
decl_stmt|;
return|return
name|parentCursorMap
operator|.
name|get
argument_list|(
name|columnListParamName
argument_list|)
return|;
block|}
comment|/**    * If<code>selectItem</code> is "*" or "TABLE.*", expands it and returns    * true; otherwise writes the unexpanded item.    *    * @param selectItem        Select-list item    * @param select            Containing select clause    * @param selectItems       List that expanded items are written to    * @param aliases           Set of aliases    * @param types             List of data types in alias order    * @param includeSystemVars If true include system vars in lists    * @return Whether the node was expanded    */
specifier|private
name|boolean
name|expandSelectItem
parameter_list|(
specifier|final
name|SqlNode
name|selectItem
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|RelDataType
name|targetType
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectItems
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|types
parameter_list|,
specifier|final
name|boolean
name|includeSystemVars
parameter_list|)
block|{
specifier|final
name|SelectScope
name|scope
init|=
operator|(
name|SelectScope
operator|)
name|getWhereScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|expandStar
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|includeSystemVars
argument_list|,
name|scope
argument_list|,
name|selectItem
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Expand the select item: fully-qualify columns, and convert
comment|// parentheses-free functions such as LOCALTIME into explicit function
comment|// calls.
name|SqlNode
name|expanded
init|=
name|expand
argument_list|(
name|selectItem
argument_list|,
name|scope
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|selectItem
argument_list|,
name|aliases
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// If expansion has altered the natural alias, supply an explicit 'AS'.
specifier|final
name|SqlValidatorScope
name|selectScope
init|=
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|expanded
operator|!=
name|selectItem
condition|)
block|{
name|String
name|newAlias
init|=
name|deriveAlias
argument_list|(
name|expanded
argument_list|,
name|aliases
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newAlias
operator|.
name|equals
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|expanded
operator|=
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|selectItem
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|expanded
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|deriveTypeImpl
argument_list|(
name|selectScope
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
block|}
block|}
name|selectItems
operator|.
name|add
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
name|aliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|inferUnknownTypes
argument_list|(
name|targetType
argument_list|,
name|scope
argument_list|,
name|expanded
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|selectScope
argument_list|,
name|expanded
argument_list|)
decl_stmt|;
name|setValidatedNodeType
argument_list|(
name|expanded
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|expandStar
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectItems
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|types
parameter_list|,
name|boolean
name|includeSystemVars
parameter_list|,
name|SelectScope
name|scope
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|SqlIdentifier
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|SqlIdentifier
name|identifier
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|identifier
operator|.
name|isStar
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|SqlParserPos
name|startPosition
init|=
name|identifier
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|identifier
operator|.
name|names
operator|.
name|size
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
for|for
control|(
name|ScopeChild
name|child
range|:
name|scope
operator|.
name|children
control|)
block|{
specifier|final
name|int
name|before
init|=
name|types
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|namespace
operator|.
name|getRowType
argument_list|()
operator|.
name|isDynamicStruct
argument_list|()
condition|)
block|{
comment|// don't expand star if the underneath table is dynamic.
comment|// Treat this star as a special field in validation/conversion and
comment|// wait until execution time to expand this star.
specifier|final
name|SqlNode
name|exp
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|child
operator|.
name|name
argument_list|,
name|DynamicRecordType
operator|.
name|DYNAMIC_STAR_PREFIX
argument_list|)
argument_list|,
name|startPosition
argument_list|)
decl_stmt|;
name|addToSelectList
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|exp
argument_list|,
name|scope
argument_list|,
name|includeSystemVars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SqlNode
name|from
init|=
name|child
operator|.
name|namespace
operator|.
name|getNode
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|fromNs
init|=
name|getNamespace
argument_list|(
name|from
argument_list|,
name|scope
argument_list|)
decl_stmt|;
assert|assert
name|fromNs
operator|!=
literal|null
assert|;
specifier|final
name|RelDataType
name|rowType
init|=
name|fromNs
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|String
name|columnName
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// TODO: do real implicit collation here
specifier|final
name|SqlIdentifier
name|exp
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|child
operator|.
name|name
argument_list|,
name|columnName
argument_list|)
argument_list|,
name|startPosition
argument_list|)
decl_stmt|;
comment|// Don't add expanded rolled up columns
if|if
condition|(
operator|!
name|isRolledUpColumn
argument_list|(
name|exp
argument_list|,
name|scope
argument_list|)
condition|)
block|{
name|addOrExpandField
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|includeSystemVars
argument_list|,
name|scope
argument_list|,
name|exp
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|child
operator|.
name|nullable
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|before
init|;
name|i
operator|<
name|types
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|entry
init|=
name|types
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|types
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|type
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
default|default:
specifier|final
name|SqlIdentifier
name|prefixId
init|=
name|identifier
operator|.
name|skipLast
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|scope
operator|.
name|validator
operator|.
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolve
argument_list|(
name|prefixId
operator|.
name|names
argument_list|,
name|nameMatcher
argument_list|,
literal|true
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// e.g. "select s.t.* from e"
comment|// or "select r.* from e"
throw|throw
name|newValidationError
argument_list|(
name|prefixId
argument_list|,
name|RESOURCE
operator|.
name|unknownIdentifier
argument_list|(
name|prefixId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|RelDataType
name|rowType
init|=
name|resolved
operator|.
name|only
argument_list|()
operator|.
name|rowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowType
operator|.
name|isDynamicStruct
argument_list|()
condition|)
block|{
comment|// don't expand star if the underneath table is dynamic.
name|addToSelectList
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|prefixId
operator|.
name|plus
argument_list|(
name|DynamicRecordType
operator|.
name|DYNAMIC_STAR_PREFIX
argument_list|,
name|startPosition
argument_list|)
argument_list|,
name|scope
argument_list|,
name|includeSystemVars
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|rowType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|String
name|columnName
init|=
name|field
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// TODO: do real implicit collation here
name|addOrExpandField
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|includeSystemVars
argument_list|,
name|scope
argument_list|,
name|prefixId
operator|.
name|plus
argument_list|(
name|columnName
argument_list|,
name|startPosition
argument_list|)
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
name|newValidationError
argument_list|(
name|prefixId
argument_list|,
name|RESOURCE
operator|.
name|starRequiresRecordType
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
name|boolean
name|addOrExpandField
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectItems
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|types
parameter_list|,
name|boolean
name|includeSystemVars
parameter_list|,
name|SelectScope
name|scope
parameter_list|,
name|SqlIdentifier
name|id
parameter_list|,
name|RelDataTypeField
name|field
parameter_list|)
block|{
switch|switch
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|.
name|getStructKind
argument_list|()
condition|)
block|{
case|case
name|PEEK_FIELDS
case|:
case|case
name|PEEK_FIELDS_DEFAULT
case|:
specifier|final
name|SqlNode
name|starExp
init|=
name|id
operator|.
name|plusStar
argument_list|()
decl_stmt|;
name|expandStar
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|includeSystemVars
argument_list|,
name|scope
argument_list|,
name|starExp
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
name|addToSelectList
argument_list|(
name|selectItems
argument_list|,
name|aliases
argument_list|,
name|types
argument_list|,
name|id
argument_list|,
name|scope
argument_list|,
name|includeSystemVars
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|SqlNode
name|validate
parameter_list|(
name|SqlNode
name|topNode
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
operator|new
name|EmptyScope
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|scope
operator|=
operator|new
name|CatalogScope
argument_list|(
name|scope
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"CATALOG"
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|topNode2
init|=
name|validateScopedExpression
argument_list|(
name|topNode
argument_list|,
name|scope
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|getValidatedNodeType
argument_list|(
name|topNode2
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|topNode2
return|;
block|}
specifier|public
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|lookupHints
parameter_list|(
name|SqlNode
name|topNode
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
operator|new
name|EmptyScope
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|SqlNode
name|outermostNode
init|=
name|performUnconditionalRewrites
argument_list|(
name|topNode
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cursorSet
operator|.
name|add
argument_list|(
name|outermostNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|outermostNode
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|TOP_LEVEL
argument_list|)
condition|)
block|{
name|registerQuery
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|outermostNode
argument_list|,
name|outermostNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|outermostNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Not a query: "
operator|+
name|outermostNode
argument_list|)
throw|;
block|}
name|Collection
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
init|=
name|Sets
operator|.
name|newTreeSet
argument_list|(
name|SqlMoniker
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
name|lookupSelectHints
argument_list|(
name|ns
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|hintList
argument_list|)
return|;
block|}
specifier|public
name|SqlMoniker
name|lookupQualifiedName
parameter_list|(
name|SqlNode
name|topNode
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
specifier|final
name|String
name|posString
init|=
name|pos
operator|.
name|toString
argument_list|()
decl_stmt|;
name|IdInfo
name|info
init|=
name|idPositions
operator|.
name|get
argument_list|(
name|posString
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
specifier|final
name|SqlQualified
name|qualified
init|=
name|info
operator|.
name|scope
operator|.
name|fullyQualify
argument_list|(
name|info
operator|.
name|id
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlIdentifierMoniker
argument_list|(
name|qualified
operator|.
name|identifier
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Looks up completion hints for a syntactically correct select SQL that has    * been parsed into an expression tree.    *    * @param select   the Select node of the parsed expression tree    * @param pos      indicates the position in the sql statement we want to get    *                 completion hints for    * @param hintList list of {@link SqlMoniker} (sql identifiers) that can    *                 fill in at the indicated position    */
name|void
name|lookupSelectHints
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|Collection
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
name|IdInfo
name|info
init|=
name|idPositions
operator|.
name|get
argument_list|(
name|pos
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|info
operator|==
literal|null
operator|)
operator|||
operator|(
name|info
operator|.
name|scope
operator|==
literal|null
operator|)
condition|)
block|{
name|SqlNode
name|fromNode
init|=
name|select
operator|.
name|getFrom
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|fromScope
init|=
name|getFromScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|lookupFromHints
argument_list|(
name|fromNode
argument_list|,
name|fromScope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lookupNameCompletionHints
argument_list|(
name|info
operator|.
name|scope
argument_list|,
name|info
operator|.
name|id
operator|.
name|names
argument_list|,
name|info
operator|.
name|id
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|lookupSelectHints
parameter_list|(
name|SqlValidatorNamespace
name|ns
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|Collection
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
specifier|final
name|SqlNode
name|node
init|=
name|ns
operator|.
name|getNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlSelect
condition|)
block|{
name|lookupSelectHints
argument_list|(
operator|(
name|SqlSelect
operator|)
name|node
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|lookupFromHints
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|Collection
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|.
name|isWrapperFor
argument_list|(
name|IdentifierNamespace
operator|.
name|class
argument_list|)
condition|)
block|{
name|IdentifierNamespace
name|idNs
init|=
name|ns
operator|.
name|unwrap
argument_list|(
name|IdentifierNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|SqlIdentifier
name|id
init|=
name|idNs
operator|.
name|getId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pos
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|id
operator|.
name|getComponent
argument_list|(
name|i
argument_list|)
operator|.
name|getParserPosition
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|objNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SqlValidatorUtil
operator|.
name|getSchemaObjectMonikers
argument_list|(
name|getCatalogReader
argument_list|()
argument_list|,
name|id
operator|.
name|names
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|objNames
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlMoniker
name|objName
range|:
name|objNames
control|)
block|{
if|if
condition|(
name|objName
operator|.
name|getType
argument_list|()
operator|!=
name|SqlMonikerType
operator|.
name|FUNCTION
condition|)
block|{
name|hintList
operator|.
name|add
argument_list|(
name|objName
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
block|}
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|JOIN
case|:
name|lookupJoinHints
argument_list|(
operator|(
name|SqlJoin
operator|)
name|node
argument_list|,
name|scope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lookupSelectHints
argument_list|(
name|ns
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|void
name|lookupJoinHints
parameter_list|(
name|SqlJoin
name|join
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|Collection
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
name|SqlNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|SqlNode
name|right
init|=
name|join
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|SqlNode
name|condition
init|=
name|join
operator|.
name|getCondition
argument_list|()
decl_stmt|;
name|lookupFromHints
argument_list|(
name|left
argument_list|,
name|scope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
if|if
condition|(
name|hintList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|lookupFromHints
argument_list|(
name|right
argument_list|,
name|scope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
if|if
condition|(
name|hintList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return;
block|}
specifier|final
name|JoinConditionType
name|conditionType
init|=
name|join
operator|.
name|getConditionType
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|joinScope
init|=
name|scopes
operator|.
name|get
argument_list|(
name|join
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|conditionType
condition|)
block|{
case|case
name|ON
case|:
name|condition
operator|.
name|findValidOptions
argument_list|(
name|this
argument_list|,
name|joinScope
argument_list|,
name|pos
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|// No suggestions.
comment|// Not supporting hints for other types such as 'Using' yet.
return|return;
block|}
block|}
comment|/**    * Populates a list of all the valid alternatives for an identifier.    *    * @param scope    Validation scope    * @param names    Components of the identifier    * @param pos      position    * @param hintList a list of valid options    */
specifier|public
specifier|final
name|void
name|lookupNameCompletionHints
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|Collection
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
comment|// Remove the last part of name - it is a dummy
name|List
argument_list|<
name|String
argument_list|>
name|subNames
init|=
name|Util
operator|.
name|skipLast
argument_list|(
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|subNames
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// If there's a prefix, resolve it to a namespace.
name|SqlValidatorNamespace
name|ns
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|subNames
control|)
block|{
if|if
condition|(
name|ns
operator|==
literal|null
condition|)
block|{
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolve
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|name
argument_list|)
argument_list|,
name|nameMatcher
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|ns
operator|=
name|resolved
operator|.
name|only
argument_list|()
operator|.
name|namespace
expr_stmt|;
block|}
block|}
else|else
block|{
name|ns
operator|=
name|ns
operator|.
name|lookupChild
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ns
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
name|RelDataType
name|rowType
init|=
name|ns
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|hintList
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlMonikerType
operator|.
name|COLUMN
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// builtin function names are valid completion hints when the
comment|// identifier has only 1 name part
name|findAllValidFunctionNames
argument_list|(
name|names
argument_list|,
name|this
argument_list|,
name|hintList
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No prefix; use the children of the current scope (that is,
comment|// the aliases in the FROM clause)
name|scope
operator|.
name|findAliases
argument_list|(
name|hintList
argument_list|)
expr_stmt|;
comment|// If there's only one alias, add all child columns
name|SelectScope
name|selectScope
init|=
name|SqlValidatorUtil
operator|.
name|getEnclosingSelectScope
argument_list|(
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|selectScope
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|selectScope
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
name|RelDataType
name|rowType
init|=
name|selectScope
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|hintList
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlMonikerType
operator|.
name|COLUMN
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|findAllValidUdfNames
argument_list|(
name|names
argument_list|,
name|this
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|findAllValidUdfNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|Collection
argument_list|<
name|SqlMoniker
argument_list|>
name|result
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|objNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SqlValidatorUtil
operator|.
name|getSchemaObjectMonikers
argument_list|(
name|validator
operator|.
name|getCatalogReader
argument_list|()
argument_list|,
name|names
argument_list|,
name|objNames
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlMoniker
name|objName
range|:
name|objNames
control|)
block|{
if|if
condition|(
name|objName
operator|.
name|getType
argument_list|()
operator|==
name|SqlMonikerType
operator|.
name|FUNCTION
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|objName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|findAllValidFunctionNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|Collection
argument_list|<
name|SqlMoniker
argument_list|>
name|result
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
comment|// a function name can only be 1 part
if|if
condition|(
name|names
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return;
block|}
for|for
control|(
name|SqlOperator
name|op
range|:
name|validator
operator|.
name|getOperatorTable
argument_list|()
operator|.
name|getOperatorList
argument_list|()
control|)
block|{
name|SqlIdentifier
name|curOpId
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|,
name|pos
argument_list|)
decl_stmt|;
specifier|final
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|validator
operator|.
name|getOperatorTable
argument_list|()
argument_list|,
name|curOpId
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlMonikerType
operator|.
name|FUNCTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|op
operator|.
name|getSyntax
argument_list|()
operator|==
name|SqlSyntax
operator|.
name|FUNCTION
operator|)
operator|||
operator|(
name|op
operator|.
name|getSyntax
argument_list|()
operator|==
name|SqlSyntax
operator|.
name|PREFIX
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getOperandTypeChecker
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|sig
init|=
name|op
operator|.
name|getAllowedSignatures
argument_list|()
decl_stmt|;
name|sig
operator|=
name|sig
operator|.
name|replaceAll
argument_list|(
literal|"'"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|sig
argument_list|,
name|SqlMonikerType
operator|.
name|FUNCTION
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|result
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlMonikerType
operator|.
name|FUNCTION
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|SqlNode
name|validateParameterizedExpression
parameter_list|(
name|SqlNode
name|topNode
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|nameToTypeMap
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
operator|new
name|ParameterScope
argument_list|(
name|this
argument_list|,
name|nameToTypeMap
argument_list|)
decl_stmt|;
return|return
name|validateScopedExpression
argument_list|(
name|topNode
argument_list|,
name|scope
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|validateScopedExpression
parameter_list|(
name|SqlNode
name|topNode
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|SqlNode
name|outermostNode
init|=
name|performUnconditionalRewrites
argument_list|(
name|topNode
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|cursorSet
operator|.
name|add
argument_list|(
name|outermostNode
argument_list|)
expr_stmt|;
name|top
operator|=
name|outermostNode
expr_stmt|;
name|TRACER
operator|.
name|trace
argument_list|(
literal|"After unconditional rewrite: {}"
argument_list|,
name|outermostNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|outermostNode
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|TOP_LEVEL
argument_list|)
condition|)
block|{
name|registerQuery
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|outermostNode
argument_list|,
name|outermostNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|outermostNode
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outermostNode
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|TOP_LEVEL
argument_list|)
condition|)
block|{
comment|// force type derivation so that we can provide it to the
comment|// caller later without needing the scope
name|deriveType
argument_list|(
name|scope
argument_list|,
name|outermostNode
argument_list|)
expr_stmt|;
block|}
name|TRACER
operator|.
name|trace
argument_list|(
literal|"After validation: {}"
argument_list|,
name|outermostNode
argument_list|)
expr_stmt|;
return|return
name|outermostNode
return|;
block|}
specifier|public
name|void
name|validateQuery
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|node
argument_list|,
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|TABLESAMPLE
condition|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|SqlSampleSpec
name|sampleSpec
init|=
name|SqlLiteral
operator|.
name|sampleValue
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sampleSpec
operator|instanceof
name|SqlSampleSpec
operator|.
name|SqlTableSampleSpec
condition|)
block|{
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeature_T613
argument_list|()
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|sampleSpec
operator|instanceof
name|SqlSampleSpec
operator|.
name|SqlSubstitutionSampleSpec
condition|)
block|{
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeatureExt_T613_Substitution
argument_list|()
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|validateNamespace
argument_list|(
name|ns
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|top
condition|)
block|{
name|validateModality
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|validateAccess
argument_list|(
name|node
argument_list|,
name|ns
operator|.
name|getTable
argument_list|()
argument_list|,
name|SqlAccessEnum
operator|.
name|SELECT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validates a namespace.    *    * @param namespace Namespace    * @param targetRowType Desired row type, must not be null, may be the data    *                      type 'unknown'.    */
specifier|protected
name|void
name|validateNamespace
parameter_list|(
specifier|final
name|SqlValidatorNamespace
name|namespace
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
name|namespace
operator|.
name|validate
argument_list|(
name|targetRowType
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespace
operator|.
name|getNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|setValidatedNodeType
argument_list|(
name|namespace
operator|.
name|getNode
argument_list|()
argument_list|,
name|namespace
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|SqlValidatorScope
name|getEmptyScope
parameter_list|()
block|{
return|return
operator|new
name|EmptyScope
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getCursorScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|cursorScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getWhereScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|whereScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getSelectScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|selectScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SelectScope
name|getRawSelectScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|instanceof
name|AggregatingSelectScope
condition|)
block|{
name|scope
operator|=
operator|(
operator|(
name|AggregatingSelectScope
operator|)
name|scope
operator|)
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|SelectScope
operator|)
name|scope
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getHavingScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// Yes, it's the same as getSelectScope
return|return
name|selectScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getGroupScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// Yes, it's the same as getWhereScope
return|return
name|groupByScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getFromScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|scopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getOrderScope
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
return|return
name|orderScopes
operator|.
name|get
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getMatchRecognizeScope
parameter_list|(
name|SqlMatchRecognize
name|node
parameter_list|)
block|{
return|return
name|scopes
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getJoinScope
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
name|scopes
operator|.
name|get
argument_list|(
name|stripAs
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorScope
name|getOverScope
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
name|scopes
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
specifier|private
name|SqlValidatorNamespace
name|getNamespace
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlIdentifier
operator|&&
name|scope
operator|instanceof
name|DelegatingScope
condition|)
block|{
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
specifier|final
name|DelegatingScope
name|idScope
init|=
operator|(
name|DelegatingScope
operator|)
operator|(
operator|(
name|DelegatingScope
operator|)
name|scope
operator|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
return|return
name|getNamespace
argument_list|(
name|id
argument_list|,
name|idScope
argument_list|)
return|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
comment|// Handle extended identifiers.
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
switch|switch
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EXTEND
case|:
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|DelegatingScope
name|idScope
init|=
operator|(
name|DelegatingScope
operator|)
name|scope
decl_stmt|;
return|return
name|getNamespace
argument_list|(
name|id
argument_list|,
name|idScope
argument_list|)
return|;
case|case
name|AS
case|:
specifier|final
name|SqlNode
name|nested
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nested
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|EXTEND
case|:
return|return
name|getNamespace
argument_list|(
name|nested
argument_list|,
name|scope
argument_list|)
return|;
block|}
break|break;
block|}
block|}
return|return
name|getNamespace
argument_list|(
name|node
argument_list|)
return|;
block|}
specifier|private
name|SqlValidatorNamespace
name|getNamespace
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|,
name|DelegatingScope
name|scope
parameter_list|)
block|{
if|if
condition|(
name|id
operator|.
name|isSimple
argument_list|()
condition|)
block|{
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolve
argument_list|(
name|id
operator|.
name|names
argument_list|,
name|nameMatcher
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|resolved
operator|.
name|only
argument_list|()
operator|.
name|namespace
return|;
block|}
block|}
return|return
name|getNamespace
argument_list|(
name|id
argument_list|)
return|;
block|}
specifier|public
name|SqlValidatorNamespace
name|getNamespace
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
comment|// AS has a namespace if it has a column list 'AS t (c1, c2, ...)'
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|namespaces
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
return|return
name|ns
return|;
block|}
comment|// fall through
case|case
name|OVER
case|:
case|case
name|COLLECTION_TABLE
case|:
case|case
name|ORDER_BY
case|:
case|case
name|TABLESAMPLE
case|:
return|return
name|getNamespace
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|namespaces
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
block|}
comment|/**    * Performs expression rewrites which are always used unconditionally. These    * rewrites massage the expression tree into a standard form so that the    * rest of the validation logic can be simpler.    *    * @param node      expression to be rewritten    * @param underFrom whether node appears directly under a FROM clause    * @return rewritten expression    */
specifier|protected
name|SqlNode
name|performUnconditionalRewrites
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|underFrom
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return
name|node
return|;
block|}
name|SqlNode
name|newOperand
decl_stmt|;
comment|// first transform operands and invoke generic call rewrite
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlMerge
condition|)
block|{
name|validatingSqlMerge
operator|=
literal|true
expr_stmt|;
block|}
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|operand
init|=
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|childUnderFrom
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|SELECT
condition|)
block|{
name|childUnderFrom
operator|=
name|i
operator|==
name|SqlSelect
operator|.
name|FROM_OPERAND
expr_stmt|;
block|}
if|else if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|AS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
block|{
comment|// for an aliased expression, it is under FROM if
comment|// the AS expression is under FROM
name|childUnderFrom
operator|=
name|underFrom
expr_stmt|;
block|}
else|else
block|{
name|childUnderFrom
operator|=
literal|false
expr_stmt|;
block|}
name|newOperand
operator|=
name|performUnconditionalRewrites
argument_list|(
name|operand
argument_list|,
name|childUnderFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|newOperand
operator|!=
literal|null
operator|&&
name|newOperand
operator|!=
name|operand
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
name|i
argument_list|,
name|newOperand
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|call
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlUnresolvedFunction
condition|)
block|{
assert|assert
name|call
operator|instanceof
name|SqlBasicCall
assert|;
specifier|final
name|SqlUnresolvedFunction
name|function
init|=
operator|(
name|SqlUnresolvedFunction
operator|)
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
comment|// This function hasn't been resolved yet.  Perform
comment|// a half-hearted resolution now in case it's a
comment|// builtin function requiring special casing.  If it's
comment|// not, we'll handle it later during overload resolution.
specifier|final
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|overloads
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|opTab
operator|.
name|lookupOperatorOverloads
argument_list|(
name|function
operator|.
name|getNameAsId
argument_list|()
argument_list|,
name|function
operator|.
name|getFunctionType
argument_list|()
argument_list|,
name|SqlSyntax
operator|.
name|FUNCTION
argument_list|,
name|overloads
argument_list|)
expr_stmt|;
if|if
condition|(
name|overloads
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
operator|(
operator|(
name|SqlBasicCall
operator|)
name|call
operator|)
operator|.
name|setOperator
argument_list|(
name|overloads
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rewriteCalls
condition|)
block|{
name|node
operator|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|rewriteCall
argument_list|(
name|this
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|count
init|=
name|list
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|operand
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newOperand
operator|=
name|performUnconditionalRewrites
argument_list|(
name|operand
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|newOperand
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|getList
argument_list|()
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|newOperand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// now transform node itself
specifier|final
name|SqlKind
name|kind
init|=
name|node
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|VALUES
case|:
comment|// CHECKSTYLE: IGNORE 1
if|if
condition|(
name|underFrom
operator|||
literal|true
condition|)
block|{
comment|// leave FROM (VALUES(...)) [ AS alias ] clauses alone,
comment|// otherwise they grow cancerously if this rewrite is invoked
comment|// over and over
return|return
name|node
return|;
block|}
else|else
block|{
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlIdentifier
operator|.
name|star
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlSelect
argument_list|(
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|,
literal|null
argument_list|,
name|selectList
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
case|case
name|ORDER_BY
case|:
block|{
name|SqlOrderBy
name|orderBy
init|=
operator|(
name|SqlOrderBy
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|orderBy
operator|.
name|query
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|orderBy
operator|.
name|query
decl_stmt|;
comment|// Don't clobber existing ORDER BY.  It may be needed for
comment|// an order-sensitive function like RANK.
if|if
condition|(
name|select
operator|.
name|getOrderList
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// push ORDER BY into existing select
name|select
operator|.
name|setOrderBy
argument_list|(
name|orderBy
operator|.
name|orderList
argument_list|)
expr_stmt|;
name|select
operator|.
name|setOffset
argument_list|(
name|orderBy
operator|.
name|offset
argument_list|)
expr_stmt|;
name|select
operator|.
name|setFetch
argument_list|(
name|orderBy
operator|.
name|fetch
argument_list|)
expr_stmt|;
return|return
name|select
return|;
block|}
block|}
if|if
condition|(
name|orderBy
operator|.
name|query
operator|instanceof
name|SqlWith
operator|&&
operator|(
operator|(
name|SqlWith
operator|)
name|orderBy
operator|.
name|query
operator|)
operator|.
name|body
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlWith
name|with
init|=
operator|(
name|SqlWith
operator|)
name|orderBy
operator|.
name|query
decl_stmt|;
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|with
operator|.
name|body
decl_stmt|;
comment|// Don't clobber existing ORDER BY.  It may be needed for
comment|// an order-sensitive function like RANK.
if|if
condition|(
name|select
operator|.
name|getOrderList
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// push ORDER BY into existing select
name|select
operator|.
name|setOrderBy
argument_list|(
name|orderBy
operator|.
name|orderList
argument_list|)
expr_stmt|;
name|select
operator|.
name|setOffset
argument_list|(
name|orderBy
operator|.
name|offset
argument_list|)
expr_stmt|;
name|select
operator|.
name|setFetch
argument_list|(
name|orderBy
operator|.
name|fetch
argument_list|)
expr_stmt|;
return|return
name|with
return|;
block|}
block|}
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlIdentifier
operator|.
name|star
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|SqlNodeList
name|orderList
decl_stmt|;
if|if
condition|(
name|getInnerSelect
argument_list|(
name|node
argument_list|)
operator|!=
literal|null
operator|&&
name|isAggregate
argument_list|(
name|getInnerSelect
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|orderList
operator|=
name|orderBy
operator|.
name|orderList
operator|.
name|clone
argument_list|(
name|orderBy
operator|.
name|orderList
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
comment|// We assume that ORDER BY item does not have ASC etc.
comment|// We assume that ORDER BY item is present in SELECT list.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orderList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|sqlNode
init|=
name|orderList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|SqlNodeList
name|selectList2
init|=
name|getInnerSelect
argument_list|(
name|node
argument_list|)
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|sel
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|selectList2
argument_list|)
control|)
block|{
if|if
condition|(
name|stripAs
argument_list|(
name|sel
operator|.
name|e
argument_list|)
operator|.
name|equalsDeep
argument_list|(
name|sqlNode
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
name|orderList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|sel
operator|.
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|orderList
operator|=
name|orderBy
operator|.
name|orderList
expr_stmt|;
block|}
return|return
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
name|selectList
argument_list|,
name|orderBy
operator|.
name|query
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|orderList
argument_list|,
name|orderBy
operator|.
name|offset
argument_list|,
name|orderBy
operator|.
name|fetch
argument_list|)
return|;
block|}
case|case
name|EXPLICIT_TABLE
case|:
block|{
comment|// (TABLE t) is equivalent to (SELECT * FROM t)
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlIdentifier
operator|.
name|star
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
name|selectList
argument_list|,
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
case|case
name|DELETE
case|:
block|{
name|SqlDelete
name|call
init|=
operator|(
name|SqlDelete
operator|)
name|node
decl_stmt|;
name|SqlSelect
name|select
init|=
name|createSourceSelectForDelete
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|call
operator|.
name|setSourceSelect
argument_list|(
name|select
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UPDATE
case|:
block|{
name|SqlUpdate
name|call
init|=
operator|(
name|SqlUpdate
operator|)
name|node
decl_stmt|;
name|SqlSelect
name|select
init|=
name|createSourceSelectForUpdate
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|call
operator|.
name|setSourceSelect
argument_list|(
name|select
argument_list|)
expr_stmt|;
comment|// See if we're supposed to rewrite UPDATE to MERGE
comment|// (unless this is the UPDATE clause of a MERGE,
comment|// in which case leave it alone).
if|if
condition|(
operator|!
name|validatingSqlMerge
condition|)
block|{
name|SqlNode
name|selfJoinSrcExpr
init|=
name|getSelfJoinExprForUpdate
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|UPDATE_SRC_ALIAS
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfJoinSrcExpr
operator|!=
literal|null
condition|)
block|{
name|node
operator|=
name|rewriteUpdateToMerge
argument_list|(
name|call
argument_list|,
name|selfJoinSrcExpr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|MERGE
case|:
block|{
name|SqlMerge
name|call
init|=
operator|(
name|SqlMerge
operator|)
name|node
decl_stmt|;
name|rewriteMerge
argument_list|(
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|node
return|;
block|}
specifier|private
name|SqlSelect
name|getInnerSelect
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlSelect
condition|)
block|{
return|return
operator|(
name|SqlSelect
operator|)
name|node
return|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlOrderBy
condition|)
block|{
name|node
operator|=
operator|(
operator|(
name|SqlOrderBy
operator|)
name|node
operator|)
operator|.
name|query
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlWith
condition|)
block|{
name|node
operator|=
operator|(
operator|(
name|SqlWith
operator|)
name|node
operator|)
operator|.
name|body
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
specifier|private
name|void
name|rewriteMerge
parameter_list|(
name|SqlMerge
name|call
parameter_list|)
block|{
name|SqlNodeList
name|selectList
decl_stmt|;
name|SqlUpdate
name|updateStmt
init|=
name|call
operator|.
name|getUpdateCall
argument_list|()
decl_stmt|;
if|if
condition|(
name|updateStmt
operator|!=
literal|null
condition|)
block|{
comment|// if we have an update statement, just clone the select list
comment|// from the update statement's source since it's the same as
comment|// what we want for the select list of the merge source -- '*'
comment|// followed by the update set expressions
name|selectList
operator|=
operator|(
name|SqlNodeList
operator|)
name|updateStmt
operator|.
name|getSourceSelect
argument_list|()
operator|.
name|getSelectList
argument_list|()
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise, just use select *
name|selectList
operator|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlIdentifier
operator|.
name|star
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|targetTable
init|=
name|call
operator|.
name|getTargetTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|targetTable
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|targetTable
argument_list|,
name|call
operator|.
name|getAlias
argument_list|()
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Provided there is an insert substatement, the source select for
comment|// the merge is a left outer join between the source in the USING
comment|// clause and the target table; otherwise, the join is just an
comment|// inner join.  Need to clone the source table reference in order
comment|// for validation to work
name|SqlNode
name|sourceTableRef
init|=
name|call
operator|.
name|getSourceTableRef
argument_list|()
decl_stmt|;
name|SqlInsert
name|insertCall
init|=
name|call
operator|.
name|getInsertCall
argument_list|()
decl_stmt|;
name|JoinType
name|joinType
init|=
operator|(
name|insertCall
operator|==
literal|null
operator|)
condition|?
name|JoinType
operator|.
name|INNER
else|:
name|JoinType
operator|.
name|LEFT
decl_stmt|;
name|SqlNode
name|leftJoinTerm
init|=
operator|(
name|SqlNode
operator|)
name|sourceTableRef
operator|.
name|clone
argument_list|()
decl_stmt|;
name|SqlNode
name|outerJoin
init|=
operator|new
name|SqlJoin
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|leftJoinTerm
argument_list|,
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
literal|false
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
name|joinType
operator|.
name|symbol
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
name|targetTable
argument_list|,
name|JoinConditionType
operator|.
name|ON
operator|.
name|symbol
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|,
name|call
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
name|SqlSelect
name|select
init|=
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
name|selectList
argument_list|,
name|outerJoin
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|call
operator|.
name|setSourceSelect
argument_list|(
name|select
argument_list|)
expr_stmt|;
comment|// Source for the insert call is a select of the source table
comment|// reference with the select list being the value expressions;
comment|// note that the values clause has already been converted to a
comment|// select on the values row constructor; so we need to extract
comment|// that via the from clause on the select
if|if
condition|(
name|insertCall
operator|!=
literal|null
condition|)
block|{
name|SqlCall
name|valuesCall
init|=
operator|(
name|SqlCall
operator|)
name|insertCall
operator|.
name|getSource
argument_list|()
decl_stmt|;
name|SqlCall
name|rowCall
init|=
name|valuesCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|selectList
operator|=
operator|new
name|SqlNodeList
argument_list|(
name|rowCall
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|SqlNode
name|insertSource
init|=
operator|(
name|SqlNode
operator|)
name|sourceTableRef
operator|.
name|clone
argument_list|()
decl_stmt|;
name|select
operator|=
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
name|selectList
argument_list|,
name|insertSource
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|insertCall
operator|.
name|setSource
argument_list|(
name|select
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|SqlNode
name|rewriteUpdateToMerge
parameter_list|(
name|SqlUpdate
name|updateCall
parameter_list|,
name|SqlNode
name|selfJoinSrcExpr
parameter_list|)
block|{
comment|// Make sure target has an alias.
if|if
condition|(
name|updateCall
operator|.
name|getAlias
argument_list|()
operator|==
literal|null
condition|)
block|{
name|updateCall
operator|.
name|setAlias
argument_list|(
operator|new
name|SqlIdentifier
argument_list|(
name|UPDATE_TGT_ALIAS
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|selfJoinTgtExpr
init|=
name|getSelfJoinExprForUpdate
argument_list|(
name|updateCall
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|updateCall
operator|.
name|getAlias
argument_list|()
operator|.
name|getSimple
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|selfJoinTgtExpr
operator|!=
literal|null
assert|;
comment|// Create join condition between source and target exprs,
comment|// creating a conjunction with the user-level WHERE
comment|// clause if one was supplied
name|SqlNode
name|condition
init|=
name|updateCall
operator|.
name|getCondition
argument_list|()
decl_stmt|;
name|SqlNode
name|selfJoinCond
init|=
name|SqlStdOperatorTable
operator|.
name|EQUALS
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|selfJoinSrcExpr
argument_list|,
name|selfJoinTgtExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|condition
operator|==
literal|null
condition|)
block|{
name|condition
operator|=
name|selfJoinCond
expr_stmt|;
block|}
else|else
block|{
name|condition
operator|=
name|SqlStdOperatorTable
operator|.
name|AND
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|selfJoinCond
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|target
init|=
name|updateCall
operator|.
name|getTargetTable
argument_list|()
operator|.
name|clone
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
comment|// For the source, we need to anonymize the fields, so
comment|// that for a statement like UPDATE T SET I = I + 1,
comment|// there's no ambiguity for the "I" in "I + 1";
comment|// this is OK because the source and target have
comment|// identical values due to the self-join.
comment|// Note that we anonymize the source rather than the
comment|// target because downstream, the optimizer rules
comment|// don't want to see any projection on top of the target.
name|IdentifierNamespace
name|ns
init|=
operator|new
name|IdentifierNamespace
argument_list|(
name|this
argument_list|,
name|target
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RelDataType
name|rowType
init|=
name|ns
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|SqlNode
name|source
init|=
name|updateCall
operator|.
name|getTargetTable
argument_list|()
operator|.
name|clone
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|rowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
name|SqlIdentifier
name|col
init|=
operator|new
name|SqlIdentifier
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|col
argument_list|,
name|UPDATE_ANON_PREFIX
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|source
operator|=
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
name|selectList
argument_list|,
name|source
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|source
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|source
argument_list|,
name|UPDATE_SRC_ALIAS
argument_list|)
expr_stmt|;
name|SqlMerge
name|mergeCall
init|=
operator|new
name|SqlMerge
argument_list|(
name|updateCall
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|target
argument_list|,
name|condition
argument_list|,
name|source
argument_list|,
name|updateCall
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|updateCall
operator|.
name|getAlias
argument_list|()
argument_list|)
decl_stmt|;
name|rewriteMerge
argument_list|(
name|mergeCall
argument_list|)
expr_stmt|;
return|return
name|mergeCall
return|;
block|}
comment|/**    * Allows a subclass to provide information about how to convert an UPDATE    * into a MERGE via self-join. If this method returns null, then no such    * conversion takes place. Otherwise, this method should return a suitable    * unique identifier expression for the given table.    *    * @param table identifier for table being updated    * @param alias alias to use for qualifying columns in expression, or null    *              for unqualified references; if this is equal to    *              {@value #UPDATE_SRC_ALIAS}, then column references have been    *              anonymized to "SYS$ANONx", where x is the 1-based column    *              number.    * @return expression for unique identifier, or null to prevent conversion    */
specifier|protected
name|SqlNode
name|getSelfJoinExprForUpdate
parameter_list|(
name|SqlNode
name|table
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Creates the SELECT statement that putatively feeds rows into an UPDATE    * statement to be updated.    *    * @param call Call to the UPDATE operator    * @return select statement    */
specifier|protected
name|SqlSelect
name|createSourceSelectForUpdate
parameter_list|(
name|SqlUpdate
name|call
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlIdentifier
operator|.
name|star
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|ordinal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SqlNode
name|exp
range|:
name|call
operator|.
name|getSourceExpressionList
argument_list|()
control|)
block|{
comment|// Force unique aliases to avoid a duplicate for Y with
comment|// SET X=Y
name|String
name|alias
init|=
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|exp
argument_list|,
name|alias
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ordinal
expr_stmt|;
block|}
name|SqlNode
name|sourceTable
init|=
name|call
operator|.
name|getTargetTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sourceTable
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|sourceTable
argument_list|,
name|call
operator|.
name|getAlias
argument_list|()
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
name|selectList
argument_list|,
name|sourceTable
argument_list|,
name|call
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Creates the SELECT statement that putatively feeds rows into a DELETE    * statement to be deleted.    *    * @param call Call to the DELETE operator    * @return select statement    */
specifier|protected
name|SqlSelect
name|createSourceSelectForDelete
parameter_list|(
name|SqlDelete
name|call
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|selectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|selectList
operator|.
name|add
argument_list|(
name|SqlIdentifier
operator|.
name|star
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|SqlNode
name|sourceTable
init|=
name|call
operator|.
name|getTargetTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sourceTable
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|sourceTable
argument_list|,
name|call
operator|.
name|getAlias
argument_list|()
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SqlSelect
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
literal|null
argument_list|,
name|selectList
argument_list|,
name|sourceTable
argument_list|,
name|call
operator|.
name|getCondition
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns null if there is no common type. E.g. if the rows have a    * different number of columns.    */
name|RelDataType
name|getTableConstructorRowType
parameter_list|(
name|SqlCall
name|values
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|rows
init|=
name|values
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
assert|assert
name|rows
operator|.
name|size
argument_list|()
operator|>=
literal|1
assert|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|rowTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|SqlNode
name|row
range|:
name|rows
control|)
block|{
assert|assert
name|row
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
assert|;
name|SqlCall
name|rowConstructor
init|=
operator|(
name|SqlCall
operator|)
name|row
decl_stmt|;
comment|// REVIEW jvs 10-Sept-2003: Once we support single-row queries as
comment|// rows, need to infer aliases from there.
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|aliasList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|typeList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|column
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|rowConstructor
operator|.
name|getOperandList
argument_list|()
argument_list|)
control|)
block|{
specifier|final
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|column
operator|.
name|e
argument_list|,
name|column
operator|.
name|i
argument_list|)
decl_stmt|;
name|aliasList
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|column
operator|.
name|e
argument_list|)
decl_stmt|;
name|typeList
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|rowTypes
operator|.
name|add
argument_list|(
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|typeList
argument_list|,
name|aliasList
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rows
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// TODO jvs 10-Oct-2005:  get rid of this workaround once
comment|// leastRestrictive can handle all cases
return|return
name|rowTypes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
name|rowTypes
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|getValidatedNodeType
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|getValidatedNodeTypeIfKnown
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|node
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|type
return|;
block|}
block|}
specifier|public
name|RelDataType
name|getValidatedNodeTypeIfKnown
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|nodeToTypeMap
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
return|return
name|type
return|;
block|}
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
return|return
name|ns
operator|.
name|getType
argument_list|()
return|;
block|}
specifier|final
name|SqlNode
name|original
init|=
name|originalExprs
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|original
operator|!=
literal|null
operator|&&
name|original
operator|!=
name|node
condition|)
block|{
return|return
name|getValidatedNodeType
argument_list|(
name|original
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Saves the type of a {@link SqlNode}, now that it has been validated.    *    *<p>Unlike the base class method, this method is not deprecated.    * It is available from within Calcite, but is not part of the public API.    *    * @param node A SQL parse tree node, never null    * @param type Its type; must not be null    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|final
name|void
name|setValidatedNodeType
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|unknownType
argument_list|)
condition|)
block|{
comment|// don't set anything until we know what it is, and don't overwrite
comment|// a known type with the unknown type
return|return;
block|}
name|nodeToTypeMap
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeValidatedNodeType
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
name|nodeToTypeMap
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RelDataType
name|deriveType
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|expr
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|// if we already know the type, no need to re-derive
name|RelDataType
name|type
init|=
name|nodeToTypeMap
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
return|return
name|type
return|;
block|}
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
return|return
name|ns
operator|.
name|getType
argument_list|()
return|;
block|}
name|type
operator|=
name|deriveTypeImpl
argument_list|(
name|scope
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|type
operator|!=
literal|null
argument_list|,
literal|"SqlValidator.deriveTypeInternal returned null"
argument_list|)
expr_stmt|;
name|setValidatedNodeType
argument_list|(
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/**    * Derives the type of a node, never null.    */
name|RelDataType
name|deriveTypeImpl
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|operand
parameter_list|)
block|{
name|DeriveTypeVisitor
name|v
init|=
operator|new
name|DeriveTypeVisitor
argument_list|(
name|scope
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|operand
operator|.
name|accept
argument_list|(
name|v
argument_list|)
decl_stmt|;
comment|// After Guava 17, use Verify.verifyNotNull for Preconditions.checkNotNull
name|Bug
operator|.
name|upgrade
argument_list|(
literal|"guava-17"
argument_list|)
expr_stmt|;
return|return
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|scope
operator|.
name|nullifyType
argument_list|(
name|operand
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|deriveConstructorType
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|SqlFunction
name|unresolvedConstructor
parameter_list|,
name|SqlFunction
name|resolvedConstructor
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|)
block|{
name|SqlIdentifier
name|sqlIdentifier
init|=
name|unresolvedConstructor
operator|.
name|getSqlIdentifier
argument_list|()
decl_stmt|;
assert|assert
name|sqlIdentifier
operator|!=
literal|null
assert|;
name|RelDataType
name|type
init|=
name|catalogReader
operator|.
name|getNamedType
argument_list|(
name|sqlIdentifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
comment|// TODO jvs 12-Feb-2005:  proper type name formatting
throw|throw
name|newValidationError
argument_list|(
name|sqlIdentifier
argument_list|,
name|RESOURCE
operator|.
name|unknownDatatypeName
argument_list|(
name|sqlIdentifier
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|resolvedConstructor
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// This is not a default constructor invocation, and
comment|// no user-defined constructor could be found
throw|throw
name|handleUnresolvedFunction
argument_list|(
name|call
argument_list|,
name|unresolvedConstructor
argument_list|,
name|argTypes
argument_list|,
literal|null
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|SqlCall
name|testCall
init|=
name|resolvedConstructor
operator|.
name|createCall
argument_list|(
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|call
operator|.
name|getOperandList
argument_list|()
argument_list|)
decl_stmt|;
name|RelDataType
name|returnType
init|=
name|resolvedConstructor
operator|.
name|validateOperands
argument_list|(
name|this
argument_list|,
name|scope
argument_list|,
name|testCall
argument_list|)
decl_stmt|;
assert|assert
name|type
operator|==
name|returnType
assert|;
block|}
if|if
condition|(
name|shouldExpandIdentifiers
argument_list|()
condition|)
block|{
if|if
condition|(
name|resolvedConstructor
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|SqlBasicCall
operator|)
name|call
operator|)
operator|.
name|setOperator
argument_list|(
name|resolvedConstructor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fake a fully-qualified call to the default constructor
operator|(
operator|(
name|SqlBasicCall
operator|)
name|call
operator|)
operator|.
name|setOperator
argument_list|(
operator|new
name|SqlFunction
argument_list|(
name|type
operator|.
name|getSqlIdentifier
argument_list|()
argument_list|,
name|ReturnTypes
operator|.
name|explicit
argument_list|(
name|type
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|SqlFunctionCategory
operator|.
name|USER_DEFINED_CONSTRUCTOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|type
return|;
block|}
specifier|public
name|CalciteException
name|handleUnresolvedFunction
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlFunction
name|unresolvedFunction
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argNames
parameter_list|)
block|{
comment|// For builtins, we can give a better error message
specifier|final
name|List
argument_list|<
name|SqlOperator
argument_list|>
name|overloads
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|opTab
operator|.
name|lookupOperatorOverloads
argument_list|(
name|unresolvedFunction
operator|.
name|getNameAsId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|SqlSyntax
operator|.
name|FUNCTION
argument_list|,
name|overloads
argument_list|)
expr_stmt|;
if|if
condition|(
name|overloads
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|SqlFunction
name|fun
init|=
operator|(
name|SqlFunction
operator|)
name|overloads
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fun
operator|.
name|getSqlIdentifier
argument_list|()
operator|==
literal|null
operator|)
operator|&&
operator|(
name|fun
operator|.
name|getSyntax
argument_list|()
operator|!=
name|SqlSyntax
operator|.
name|FUNCTION_ID
operator|)
condition|)
block|{
specifier|final
name|int
name|expectedArgCount
init|=
name|fun
operator|.
name|getOperandCountRange
argument_list|()
operator|.
name|getMin
argument_list|()
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|RESOURCE
operator|.
name|invalidArgCount
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|expectedArgCount
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|AssignableOperandTypeChecker
name|typeChecking
init|=
operator|new
name|AssignableOperandTypeChecker
argument_list|(
name|argTypes
argument_list|,
name|argNames
argument_list|)
decl_stmt|;
name|String
name|signature
init|=
name|typeChecking
operator|.
name|getAllowedSignatures
argument_list|(
name|unresolvedFunction
argument_list|,
name|unresolvedFunction
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|RESOURCE
operator|.
name|validatorUnknownFunction
argument_list|(
name|signature
argument_list|)
argument_list|)
throw|;
block|}
specifier|protected
name|void
name|inferUnknownTypes
parameter_list|(
name|RelDataType
name|inferredType
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|newScope
init|=
name|scopes
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|newScope
operator|!=
literal|null
condition|)
block|{
name|scope
operator|=
name|newScope
expr_stmt|;
block|}
name|boolean
name|isNullLiteral
init|=
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|instanceof
name|SqlDynamicParam
operator|)
operator|||
name|isNullLiteral
condition|)
block|{
if|if
condition|(
name|inferredType
operator|.
name|equals
argument_list|(
name|unknownType
argument_list|)
condition|)
block|{
if|if
condition|(
name|isNullLiteral
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|nullIllegal
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|dynamicParamIllegal
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// REVIEW:  should dynamic parameter types always be nullable?
name|RelDataType
name|newInferredType
init|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|inferredType
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|inferredType
argument_list|)
condition|)
block|{
name|newInferredType
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|newInferredType
argument_list|,
name|inferredType
operator|.
name|getCharset
argument_list|()
argument_list|,
name|inferredType
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setValidatedNodeType
argument_list|(
name|node
argument_list|,
name|newInferredType
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|nodeList
init|=
operator|(
name|SqlNodeList
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|inferredType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
if|if
condition|(
name|inferredType
operator|.
name|getFieldCount
argument_list|()
operator|!=
name|nodeList
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// this can happen when we're validating an INSERT
comment|// where the source and target degrees are different;
comment|// bust out, and the error will be detected higher up
return|return;
block|}
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SqlNode
name|child
range|:
name|nodeList
control|)
block|{
name|RelDataType
name|type
decl_stmt|;
if|if
condition|(
name|inferredType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
name|type
operator|=
name|inferredType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|inferredType
expr_stmt|;
block|}
name|inferUnknownTypes
argument_list|(
name|type
argument_list|,
name|scope
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlCase
condition|)
block|{
specifier|final
name|SqlCase
name|caseCall
init|=
operator|(
name|SqlCase
operator|)
name|node
decl_stmt|;
specifier|final
name|RelDataType
name|whenType
init|=
name|caseCall
operator|.
name|getValueOperand
argument_list|()
operator|==
literal|null
condition|?
name|booleanType
else|:
name|unknownType
decl_stmt|;
for|for
control|(
name|SqlNode
name|sqlNode
range|:
name|caseCall
operator|.
name|getWhenOperands
argument_list|()
operator|.
name|getList
argument_list|()
control|)
block|{
name|inferUnknownTypes
argument_list|(
name|whenType
argument_list|,
name|scope
argument_list|,
name|sqlNode
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|returnType
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|node
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|sqlNode
range|:
name|caseCall
operator|.
name|getThenOperands
argument_list|()
operator|.
name|getList
argument_list|()
control|)
block|{
name|inferUnknownTypes
argument_list|(
name|returnType
argument_list|,
name|scope
argument_list|,
name|sqlNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|caseCall
operator|.
name|getElseOperand
argument_list|()
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|inferUnknownTypes
argument_list|(
name|returnType
argument_list|,
name|scope
argument_list|,
name|caseCall
operator|.
name|getElseOperand
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setValidatedNodeType
argument_list|(
name|caseCall
operator|.
name|getElseOperand
argument_list|()
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SqlOperandTypeInference
name|operandTypeInference
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getOperandTypeInference
argument_list|()
decl_stmt|;
specifier|final
name|SqlCallBinding
name|callBinding
init|=
operator|new
name|SqlCallBinding
argument_list|(
name|this
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|callBinding
operator|.
name|operands
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
index|[]
name|operandTypes
init|=
operator|new
name|RelDataType
index|[
name|operands
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|operandTypeInference
operator|==
literal|null
condition|)
block|{
comment|// TODO:  eventually should assert(operandTypeInference != null)
comment|// instead; for now just eat it
name|Arrays
operator|.
name|fill
argument_list|(
name|operandTypes
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operandTypeInference
operator|.
name|inferOperandTypes
argument_list|(
name|callBinding
argument_list|,
name|inferredType
argument_list|,
name|operandTypes
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|inferUnknownTypes
argument_list|(
name|operandTypes
index|[
name|i
index|]
argument_list|,
name|scope
argument_list|,
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Adds an expression to a select list, ensuring that its alias does not    * clash with any existing expressions on the list.    */
specifier|protected
name|void
name|addToSelectList
parameter_list|(
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|fieldList
parameter_list|,
name|SqlNode
name|exp
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
specifier|final
name|boolean
name|includeSystemVars
parameter_list|)
block|{
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|exp
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
name|uniqueAlias
init|=
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|alias
argument_list|,
name|aliases
argument_list|,
name|SqlValidatorUtil
operator|.
name|EXPR_SUGGESTER
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alias
operator|.
name|equals
argument_list|(
name|uniqueAlias
argument_list|)
condition|)
block|{
name|exp
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|exp
argument_list|,
name|uniqueAlias
argument_list|)
expr_stmt|;
block|}
name|fieldList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|uniqueAlias
argument_list|,
name|deriveType
argument_list|(
name|scope
argument_list|,
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|deriveAlias
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|)
block|{
return|return
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|)
return|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|setIdentifierExpansion
parameter_list|(
name|boolean
name|expandIdentifiers
parameter_list|)
block|{
name|this
operator|.
name|expandIdentifiers
operator|=
name|expandIdentifiers
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|setColumnReferenceExpansion
parameter_list|(
name|boolean
name|expandColumnReferences
parameter_list|)
block|{
name|this
operator|.
name|expandColumnReferences
operator|=
name|expandColumnReferences
expr_stmt|;
block|}
comment|// implement SqlValidator
specifier|public
name|boolean
name|getColumnReferenceExpansion
parameter_list|()
block|{
return|return
name|expandColumnReferences
return|;
block|}
specifier|public
name|void
name|setDefaultNullCollation
parameter_list|(
name|NullCollation
name|nullCollation
parameter_list|)
block|{
name|this
operator|.
name|nullCollation
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|nullCollation
argument_list|)
expr_stmt|;
block|}
specifier|public
name|NullCollation
name|getDefaultNullCollation
parameter_list|()
block|{
return|return
name|nullCollation
return|;
block|}
comment|// implement SqlValidator
specifier|public
name|void
name|setCallRewrite
parameter_list|(
name|boolean
name|rewriteCalls
parameter_list|)
block|{
name|this
operator|.
name|rewriteCalls
operator|=
name|rewriteCalls
expr_stmt|;
block|}
specifier|public
name|boolean
name|shouldExpandIdentifiers
parameter_list|()
block|{
return|return
name|expandIdentifiers
return|;
block|}
specifier|protected
name|boolean
name|shouldAllowIntermediateOrderBy
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|registerMatchRecognize
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|SqlMatchRecognize
name|call
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
specifier|final
name|MatchRecognizeNamespace
name|matchRecognizeNamespace
init|=
name|createMatchRecognizeNameSpace
argument_list|(
name|call
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|matchRecognizeNamespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
specifier|final
name|MatchRecognizeScope
name|matchRecognizeScope
init|=
operator|new
name|MatchRecognizeScope
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|matchRecognizeScope
argument_list|)
expr_stmt|;
comment|// parse input query
name|SqlNode
name|expr
init|=
name|call
operator|.
name|getTableRef
argument_list|()
decl_stmt|;
name|SqlNode
name|newExpr
init|=
name|registerFrom
argument_list|(
name|usingScope
argument_list|,
name|matchRecognizeScope
argument_list|,
name|expr
argument_list|,
name|expr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|forceNullable
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
name|newExpr
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newExpr
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|MatchRecognizeNamespace
name|createMatchRecognizeNameSpace
parameter_list|(
name|SqlMatchRecognize
name|call
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
return|return
operator|new
name|MatchRecognizeNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|enclosingNode
argument_list|)
return|;
block|}
comment|/**    * Registers a new namespace, and adds it as a child of its parent scope.    * Derived class can override this method to tinker with namespaces as they    * are created.    *    * @param usingScope    Parent scope (which will want to look for things in    *                      this namespace)    * @param alias         Alias by which parent will refer to this namespace    * @param ns            Namespace    * @param forceNullable Whether to force the type of namespace to be nullable    */
specifier|protected
name|void
name|registerNamespace
parameter_list|(
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|String
name|alias
parameter_list|,
name|SqlValidatorNamespace
name|ns
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
name|namespaces
operator|.
name|put
argument_list|(
name|ns
operator|.
name|getNode
argument_list|()
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|usingScope
operator|!=
literal|null
condition|)
block|{
name|usingScope
operator|.
name|addChild
argument_list|(
name|ns
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Registers scopes and namespaces implied a relational expression in the    * FROM clause.    *    *<p>{@code parentScope} and {@code usingScope} are often the same. They    * differ when the namespace are not visible within the parent. (Example    * needed.)    *    *<p>Likewise, {@code enclosingNode} and {@code node} are often the same.    * {@code enclosingNode} is the topmost node within the FROM clause, from    * which any decorations like an alias (<code>AS alias</code>) or a table    * sample clause are stripped away to get {@code node}. Both are recorded in    * the namespace.    *    * @param parentScope   Parent scope which this scope turns to in order to    *                      resolve objects    * @param usingScope    Scope whose child list this scope should add itself to    * @param node          Node which namespace is based on    * @param enclosingNode Outermost node for namespace, including decorations    *                      such as alias and sample clause    * @param alias         Alias    * @param extendList    Definitions of extended columns    * @param forceNullable Whether to force the type of namespace to be    *                      nullable because it is in an outer join    * @return registered node, usually the same as {@code node}    */
specifier|private
name|SqlNode
name|registerFrom
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
specifier|final
name|SqlNode
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|SqlNodeList
name|extendList
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
specifier|final
name|SqlKind
name|kind
init|=
name|node
operator|.
name|getKind
argument_list|()
decl_stmt|;
name|SqlNode
name|expr
decl_stmt|;
name|SqlNode
name|newExpr
decl_stmt|;
comment|// Add an alias if necessary.
name|SqlNode
name|newNode
init|=
name|node
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|OVER
case|:
name|alias
operator|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
name|alias
operator|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shouldExpandIdentifiers
argument_list|()
condition|)
block|{
name|newNode
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|node
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SELECT
case|:
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|VALUES
case|:
case|case
name|UNNEST
case|:
case|case
name|OTHER_FUNCTION
case|:
case|case
name|COLLECTION_TABLE
case|:
case|case
name|MATCH_RECOGNIZE
case|:
comment|// give this anonymous construct a name since later
comment|// query processing stages rely on it
name|alias
operator|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldExpandIdentifiers
argument_list|()
condition|)
block|{
comment|// Since we're expanding identifiers, we should make the
comment|// aliases explicit too, otherwise the expanded query
comment|// will not be consistent if we convert back to SQL, e.g.
comment|// "select EXPR$1.EXPR$2 from values (1)".
name|newNode
operator|=
name|SqlValidatorUtil
operator|.
name|addAlias
argument_list|(
name|node
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|SqlCall
name|call
decl_stmt|;
name|SqlNode
name|operand
decl_stmt|;
name|SqlNode
name|newOperand
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|AS
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
name|alias
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|SqlValidatorScope
name|usingScope2
init|=
name|usingScope
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|>
literal|2
condition|)
block|{
name|usingScope2
operator|=
literal|null
expr_stmt|;
block|}
name|expr
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newExpr
operator|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|usingScope2
argument_list|,
name|expr
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|extendList
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newExpr
operator|!=
name|expr
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newExpr
argument_list|)
expr_stmt|;
block|}
comment|// If alias has a column list, introduce a namespace to translate
comment|// column names.
if|if
condition|(
name|call
operator|.
name|operandCount
argument_list|()
operator|>
literal|2
condition|)
block|{
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
operator|new
name|AliasNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|enclosingNode
argument_list|)
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
case|case
name|MATCH_RECOGNIZE
case|:
name|registerMatchRecognize
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
operator|(
name|SqlMatchRecognize
operator|)
name|node
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
return|return
name|node
return|;
case|case
name|TABLESAMPLE
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|expr
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newExpr
operator|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|expr
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|extendList
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newExpr
operator|!=
name|expr
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
case|case
name|JOIN
case|:
specifier|final
name|SqlJoin
name|join
init|=
operator|(
name|SqlJoin
operator|)
name|node
decl_stmt|;
specifier|final
name|JoinScope
name|joinScope
init|=
operator|new
name|JoinScope
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|join
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|join
argument_list|,
name|joinScope
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|right
init|=
name|join
operator|.
name|getRight
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|rightIsLateral
init|=
name|isLateral
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|boolean
name|forceLeftNullable
init|=
name|forceNullable
decl_stmt|;
name|boolean
name|forceRightNullable
init|=
name|forceNullable
decl_stmt|;
switch|switch
condition|(
name|join
operator|.
name|getJoinType
argument_list|()
condition|)
block|{
case|case
name|LEFT
case|:
name|forceRightNullable
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|forceLeftNullable
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|FULL
case|:
name|forceLeftNullable
operator|=
literal|true
expr_stmt|;
name|forceRightNullable
operator|=
literal|true
expr_stmt|;
break|break;
block|}
specifier|final
name|SqlNode
name|newLeft
init|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|joinScope
argument_list|,
name|left
argument_list|,
name|left
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|forceLeftNullable
argument_list|)
decl_stmt|;
if|if
condition|(
name|newLeft
operator|!=
name|left
condition|)
block|{
name|join
operator|.
name|setLeft
argument_list|(
name|newLeft
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlValidatorScope
name|rightParentScope
decl_stmt|;
if|if
condition|(
name|rightIsLateral
condition|)
block|{
name|rightParentScope
operator|=
name|joinScope
expr_stmt|;
block|}
else|else
block|{
name|rightParentScope
operator|=
name|parentScope
expr_stmt|;
block|}
specifier|final
name|SqlNode
name|newRight
init|=
name|registerFrom
argument_list|(
name|rightParentScope
argument_list|,
name|joinScope
argument_list|,
name|right
argument_list|,
name|right
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|forceRightNullable
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRight
operator|!=
name|right
condition|)
block|{
name|join
operator|.
name|setRight
argument_list|(
name|newRight
argument_list|)
expr_stmt|;
block|}
name|registerSubQueries
argument_list|(
name|joinScope
argument_list|,
name|join
operator|.
name|getCondition
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|JoinNamespace
name|joinNamespace
init|=
operator|new
name|JoinNamespace
argument_list|(
name|this
argument_list|,
name|join
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|joinNamespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
return|return
name|join
return|;
case|case
name|IDENTIFIER
case|:
specifier|final
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
specifier|final
name|IdentifierNamespace
name|newNs
init|=
operator|new
name|IdentifierNamespace
argument_list|(
name|this
argument_list|,
name|id
argument_list|,
name|extendList
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|newNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableScope
operator|==
literal|null
condition|)
block|{
name|tableScope
operator|=
operator|new
name|TableScope
argument_list|(
name|parentScope
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|tableScope
operator|.
name|addChild
argument_list|(
name|newNs
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|extendList
operator|!=
literal|null
operator|&&
name|extendList
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|enclosingNode
return|;
block|}
return|return
name|newNode
return|;
case|case
name|LATERAL
case|:
if|if
condition|(
name|tableScope
operator|!=
literal|null
condition|)
block|{
name|tableScope
operator|.
name|meetLateral
argument_list|()
expr_stmt|;
block|}
return|return
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|extendList
argument_list|,
name|forceNullable
argument_list|)
return|;
case|case
name|COLLECTION_TABLE
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|operand
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newOperand
operator|=
name|registerFrom
argument_list|(
name|tableScope
operator|==
literal|null
condition|?
name|parentScope
else|:
name|tableScope
argument_list|,
name|usingScope
argument_list|,
name|operand
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|extendList
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newOperand
operator|!=
name|operand
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newOperand
argument_list|)
expr_stmt|;
block|}
name|scopes
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
return|return
name|newNode
return|;
case|case
name|SELECT
case|:
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|VALUES
case|:
case|case
name|WITH
case|:
case|case
name|UNNEST
case|:
case|case
name|OTHER_FUNCTION
case|:
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
name|alias
operator|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
expr_stmt|;
block|}
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
return|return
name|newNode
return|;
case|case
name|OVER
case|:
if|if
condition|(
operator|!
name|shouldAllowOverRelation
argument_list|()
condition|)
block|{
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
specifier|final
name|OverScope
name|overScope
init|=
operator|new
name|OverScope
argument_list|(
name|usingScope
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|overScope
argument_list|)
expr_stmt|;
name|operand
operator|=
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newOperand
operator|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|overScope
argument_list|,
name|operand
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|extendList
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
if|if
condition|(
name|newOperand
operator|!=
name|operand
condition|)
block|{
name|call
operator|.
name|setOperand
argument_list|(
literal|0
argument_list|,
name|newOperand
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ScopeChild
name|child
range|:
name|overScope
operator|.
name|children
control|)
block|{
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|child
operator|.
name|name
argument_list|,
name|child
operator|.
name|namespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
block|}
return|return
name|newNode
return|;
case|case
name|EXTEND
case|:
specifier|final
name|SqlCall
name|extend
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
return|return
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|extend
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|extend
argument_list|,
name|alias
argument_list|,
operator|(
name|SqlNodeList
operator|)
name|extend
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|forceNullable
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|kind
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isLateral
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|LATERAL
case|:
case|case
name|UNNEST
case|:
comment|// Per SQL std, UNNEST is implicitly LATERAL.
return|return
literal|true
return|;
case|case
name|AS
case|:
return|return
name|isLateral
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
specifier|protected
name|boolean
name|shouldAllowOverRelation
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Creates a namespace for a<code>SELECT</code> node. Derived class may    * override this factory method.    *    * @param select        Select node    * @param enclosingNode Enclosing node    * @return Select namespace    */
specifier|protected
name|SelectNamespace
name|createSelectNamespace
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
return|return
operator|new
name|SelectNamespace
argument_list|(
name|this
argument_list|,
name|select
argument_list|,
name|enclosingNode
argument_list|)
return|;
block|}
comment|/**    * Creates a namespace for a set operation (<code>UNION</code>,<code>    * INTERSECT</code>, or<code>EXCEPT</code>). Derived class may override    * this factory method.    *    * @param call          Call to set operation    * @param enclosingNode Enclosing node    * @return Set operation namespace    */
specifier|protected
name|SetopNamespace
name|createSetopNamespace
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|)
block|{
return|return
operator|new
name|SetopNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|enclosingNode
argument_list|)
return|;
block|}
comment|/**    * Registers a query in a parent scope.    *    * @param parentScope Parent scope which this scope turns to in order to    *                    resolve objects    * @param usingScope  Scope whose child list this scope should add itself to    * @param node        Query node    * @param alias       Name of this query within its parent. Must be specified    *                    if usingScope != null    */
specifier|private
name|void
name|registerQuery
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|usingScope
operator|==
literal|null
operator|||
name|alias
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers a query in a parent scope.    *    * @param parentScope Parent scope which this scope turns to in order to    *                    resolve objects    * @param usingScope  Scope whose child list this scope should add itself to    * @param node        Query node    * @param alias       Name of this query within its parent. Must be specified    *                    if usingScope != null    * @param checkUpdate if true, validate that the update feature is supported    *                    if validating the update statement    */
specifier|private
name|void
name|registerQuery
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|,
name|boolean
name|checkUpdate
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|enclosingNode
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|usingScope
operator|==
literal|null
operator|||
name|alias
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|SqlCall
name|call
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SELECT
case|:
specifier|final
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|node
decl_stmt|;
specifier|final
name|SelectNamespace
name|selectNs
init|=
name|createSelectNamespace
argument_list|(
name|select
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|selectNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorScope
name|windowParentScope
init|=
operator|(
name|usingScope
operator|!=
literal|null
operator|)
condition|?
name|usingScope
else|:
name|parentScope
decl_stmt|;
name|SelectScope
name|selectScope
init|=
operator|new
name|SelectScope
argument_list|(
name|parentScope
argument_list|,
name|windowParentScope
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|selectScope
argument_list|)
expr_stmt|;
comment|// Start by registering the WHERE clause
name|whereScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|selectScope
argument_list|)
expr_stmt|;
name|registerOperandSubQueries
argument_list|(
name|selectScope
argument_list|,
name|select
argument_list|,
name|SqlSelect
operator|.
name|WHERE_OPERAND
argument_list|)
expr_stmt|;
comment|// Register FROM with the inherited scope 'parentScope', not
comment|// 'selectScope', otherwise tables in the FROM clause would be
comment|// able to see each other.
specifier|final
name|SqlNode
name|from
init|=
name|select
operator|.
name|getFrom
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|!=
literal|null
condition|)
block|{
specifier|final
name|SqlNode
name|newFrom
init|=
name|registerFrom
argument_list|(
name|parentScope
argument_list|,
name|selectScope
argument_list|,
name|from
argument_list|,
name|from
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFrom
operator|!=
name|from
condition|)
block|{
name|select
operator|.
name|setFrom
argument_list|(
name|newFrom
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If this is an aggregating query, the SELECT list and HAVING
comment|// clause use a different scope, where you can only reference
comment|// columns which are in the GROUP BY clause.
name|SqlValidatorScope
name|aggScope
init|=
name|selectScope
decl_stmt|;
if|if
condition|(
name|isAggregate
argument_list|(
name|select
argument_list|)
condition|)
block|{
name|aggScope
operator|=
operator|new
name|AggregatingSelectScope
argument_list|(
name|selectScope
argument_list|,
name|select
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|selectScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|aggScope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|selectScope
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|select
operator|.
name|getGroup
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|GroupByScope
name|groupByScope
init|=
operator|new
name|GroupByScope
argument_list|(
name|selectScope
argument_list|,
name|select
operator|.
name|getGroup
argument_list|()
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|groupByScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|groupByScope
argument_list|)
expr_stmt|;
name|registerSubQueries
argument_list|(
name|groupByScope
argument_list|,
name|select
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|registerOperandSubQueries
argument_list|(
name|aggScope
argument_list|,
name|select
argument_list|,
name|SqlSelect
operator|.
name|HAVING_OPERAND
argument_list|)
expr_stmt|;
name|registerSubQueries
argument_list|(
name|aggScope
argument_list|,
name|select
operator|.
name|getSelectList
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|SqlNodeList
name|orderList
init|=
name|select
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|orderList
operator|!=
literal|null
condition|)
block|{
comment|// If the query is 'SELECT DISTINCT', restrict the columns
comment|// available to the ORDER BY clause.
if|if
condition|(
name|select
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|aggScope
operator|=
operator|new
name|AggregatingSelectScope
argument_list|(
name|selectScope
argument_list|,
name|select
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|OrderByScope
name|orderScope
init|=
operator|new
name|OrderByScope
argument_list|(
name|aggScope
argument_list|,
name|orderList
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|orderScopes
operator|.
name|put
argument_list|(
name|select
argument_list|,
name|orderScope
argument_list|)
expr_stmt|;
name|registerSubQueries
argument_list|(
name|orderScope
argument_list|,
name|orderList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isAggregate
argument_list|(
name|select
argument_list|)
condition|)
block|{
comment|// Since this is not an aggregating query,
comment|// there cannot be any aggregates in the ORDER BY clause.
name|SqlNode
name|agg
init|=
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|orderList
argument_list|)
decl_stmt|;
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|RESOURCE
operator|.
name|aggregateIllegalInOrderBy
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
break|break;
case|case
name|INTERSECT
case|:
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeature_F302
argument_list|()
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|registerSetop
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXCEPT
case|:
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeature_E071_03
argument_list|()
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|registerSetop
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|registerSetop
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH
case|:
name|registerWith
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
operator|(
name|SqlWith
operator|)
name|node
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|,
name|checkUpdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUES
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
specifier|final
name|TableConstructorNamespace
name|tableConstructorNamespace
init|=
operator|new
name|TableConstructorNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|parentScope
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|tableConstructorNamespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|operands
operator|=
name|call
operator|.
name|getOperandList
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
assert|;
comment|// FIXME jvs 9-Feb-2005:  Correlation should
comment|// be illegal in these sub-queries.  Same goes for
comment|// any non-lateral SELECT in the FROM list.
name|registerOperandSubQueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INSERT
case|:
name|SqlInsert
name|insertCall
init|=
operator|(
name|SqlInsert
operator|)
name|node
decl_stmt|;
name|InsertNamespace
name|insertNs
init|=
operator|new
name|InsertNamespace
argument_list|(
name|this
argument_list|,
name|insertCall
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
literal|null
argument_list|,
name|insertNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|insertCall
operator|.
name|getSource
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|SqlDelete
name|deleteCall
init|=
operator|(
name|SqlDelete
operator|)
name|node
decl_stmt|;
name|DeleteNamespace
name|deleteNs
init|=
operator|new
name|DeleteNamespace
argument_list|(
name|this
argument_list|,
name|deleteCall
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
literal|null
argument_list|,
name|deleteNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|deleteCall
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPDATE
case|:
if|if
condition|(
name|checkUpdate
condition|)
block|{
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeature_E101_03
argument_list|()
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SqlUpdate
name|updateCall
init|=
operator|(
name|SqlUpdate
operator|)
name|node
decl_stmt|;
name|UpdateNamespace
name|updateNs
init|=
operator|new
name|UpdateNamespace
argument_list|(
name|this
argument_list|,
name|updateCall
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
literal|null
argument_list|,
name|updateNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|updateCall
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE
case|:
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeature_F312
argument_list|()
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|SqlMerge
name|mergeCall
init|=
operator|(
name|SqlMerge
operator|)
name|node
decl_stmt|;
name|MergeNamespace
name|mergeNs
init|=
operator|new
name|MergeNamespace
argument_list|(
name|this
argument_list|,
name|mergeCall
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
literal|null
argument_list|,
name|mergeNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|mergeCall
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// update call can reference either the source table reference
comment|// or the target table, so set its parent scope to the merge's
comment|// source select; when validating the update, skip the feature
comment|// validation check
if|if
condition|(
name|mergeCall
operator|.
name|getUpdateCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|registerQuery
argument_list|(
name|whereScopes
operator|.
name|get
argument_list|(
name|mergeCall
operator|.
name|getSourceSelect
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|mergeCall
operator|.
name|getUpdateCall
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mergeCall
operator|.
name|getInsertCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|mergeCall
operator|.
name|getInsertCall
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNNEST
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
specifier|final
name|UnnestNamespace
name|unnestNs
init|=
operator|new
name|UnnestNamespace
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
name|parentScope
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|unnestNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerOperandSubQueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
break|break;
case|case
name|OTHER_FUNCTION
case|:
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|ProcedureNamespace
name|procNs
init|=
operator|new
name|ProcedureNamespace
argument_list|(
name|this
argument_list|,
name|parentScope
argument_list|,
name|call
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|procNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|registerSubQueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULTISET_QUERY_CONSTRUCTOR
case|:
case|case
name|MULTISET_VALUE_CONSTRUCTOR
case|:
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeature_S271
argument_list|()
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|call
operator|=
operator|(
name|SqlCall
operator|)
name|node
expr_stmt|;
name|CollectScope
name|cs
init|=
operator|new
name|CollectScope
argument_list|(
name|parentScope
argument_list|,
name|usingScope
argument_list|,
name|call
argument_list|)
decl_stmt|;
specifier|final
name|CollectNamespace
name|tableConstructorNs
init|=
operator|new
name|CollectNamespace
argument_list|(
name|call
argument_list|,
name|cs
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
specifier|final
name|String
name|alias2
init|=
name|deriveAlias
argument_list|(
name|node
argument_list|,
name|nextGeneratedId
operator|++
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias2
argument_list|,
name|tableConstructorNs
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|operands
operator|=
name|call
operator|.
name|getOperandList
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|registerOperandSubQueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|node
operator|.
name|getKind
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|registerSetop
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
specifier|final
name|SetopNamespace
name|setopNamespace
init|=
name|createSetopNamespace
argument_list|(
name|call
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|setopNamespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
comment|// A setop is in the same scope as its parent.
name|scopes
operator|.
name|put
argument_list|(
name|call
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|operand
argument_list|,
name|operand
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|registerWith
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlValidatorScope
name|usingScope
parameter_list|,
name|SqlWith
name|with
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|forceNullable
parameter_list|,
name|boolean
name|checkUpdate
parameter_list|)
block|{
specifier|final
name|WithNamespace
name|withNamespace
init|=
operator|new
name|WithNamespace
argument_list|(
name|this
argument_list|,
name|with
argument_list|,
name|enclosingNode
argument_list|)
decl_stmt|;
name|registerNamespace
argument_list|(
name|usingScope
argument_list|,
name|alias
argument_list|,
name|withNamespace
argument_list|,
name|forceNullable
argument_list|)
expr_stmt|;
name|SqlValidatorScope
name|scope
init|=
name|parentScope
decl_stmt|;
for|for
control|(
name|SqlNode
name|withItem_
range|:
name|with
operator|.
name|withList
control|)
block|{
specifier|final
name|SqlWithItem
name|withItem
init|=
operator|(
name|SqlWithItem
operator|)
name|withItem_
decl_stmt|;
specifier|final
name|WithScope
name|withScope
init|=
operator|new
name|WithScope
argument_list|(
name|scope
argument_list|,
name|withItem
argument_list|)
decl_stmt|;
name|scopes
operator|.
name|put
argument_list|(
name|withItem
argument_list|,
name|withScope
argument_list|)
expr_stmt|;
name|registerQuery
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|withItem
operator|.
name|query
argument_list|,
name|with
argument_list|,
name|withItem
operator|.
name|name
operator|.
name|getSimple
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|registerNamespace
argument_list|(
literal|null
argument_list|,
name|alias
argument_list|,
operator|new
name|WithItemNamespace
argument_list|(
name|this
argument_list|,
name|withItem
argument_list|,
name|enclosingNode
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|scope
operator|=
name|withScope
expr_stmt|;
block|}
name|registerQuery
argument_list|(
name|scope
argument_list|,
literal|null
argument_list|,
name|with
operator|.
name|body
argument_list|,
name|enclosingNode
argument_list|,
name|alias
argument_list|,
name|forceNullable
argument_list|,
name|checkUpdate
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isAggregate
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
if|if
condition|(
name|getAggregate
argument_list|(
name|select
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Also when nested window aggregates are present
for|for
control|(
name|SqlNode
name|node
range|:
name|select
operator|.
name|getSelectList
argument_list|()
control|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|overFinder
operator|.
name|findAgg
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
operator|&&
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OVER
operator|&&
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SqlCall
operator|&&
name|isNestedAggregateWindow
argument_list|(
operator|(
name|SqlCall
operator|)
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|protected
name|boolean
name|isNestedAggregateWindow
parameter_list|(
name|SqlCall
name|windowFunction
parameter_list|)
block|{
name|AggFinder
name|nestedAggFinder
init|=
operator|new
name|AggFinder
argument_list|(
name|opTab
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|aggFinder
argument_list|)
decl_stmt|;
return|return
name|nestedAggFinder
operator|.
name|findAgg
argument_list|(
name|windowFunction
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/** Returns the parse tree node (GROUP BY, HAVING, or an aggregate function    * call) that causes {@code select} to be an aggregate query, or null if it is    * not an aggregate query.    *    *<p>The node is useful context for error messages. */
specifier|protected
name|SqlNode
name|getAggregate
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
name|SqlNode
name|node
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|node
return|;
block|}
name|node
operator|=
name|select
operator|.
name|getHaving
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|node
return|;
block|}
return|return
name|getAgg
argument_list|(
name|select
argument_list|)
return|;
block|}
specifier|private
name|SqlNode
name|getAgg
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
specifier|final
name|SelectScope
name|selectScope
init|=
name|getRawSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectScope
operator|!=
literal|null
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
name|selectScope
operator|.
name|getExpandedSelectList
argument_list|()
decl_stmt|;
if|if
condition|(
name|selectList
operator|!=
literal|null
condition|)
block|{
return|return
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|selectList
argument_list|)
return|;
block|}
block|}
return|return
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|select
operator|.
name|getSelectList
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
name|boolean
name|isAggregate
parameter_list|(
name|SqlNode
name|selectNode
parameter_list|)
block|{
return|return
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|selectNode
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|private
name|void
name|validateNodeFeature
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|MULTISET_VALUE_CONSTRUCTOR
case|:
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeature_S271
argument_list|()
argument_list|,
name|node
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|void
name|registerSubQueries
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|node
operator|.
name|getKind
argument_list|()
operator|.
name|belongsTo
argument_list|(
name|SqlKind
operator|.
name|QUERY
argument_list|)
operator|||
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|MULTISET_QUERY_CONSTRUCTOR
operator|||
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|MULTISET_VALUE_CONSTRUCTOR
condition|)
block|{
name|registerQuery
argument_list|(
name|parentScope
argument_list|,
literal|null
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlCall
condition|)
block|{
name|validateNodeFeature
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|call
operator|.
name|operandCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|registerOperandSubQueries
argument_list|(
name|parentScope
argument_list|,
name|call
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlNodeList
condition|)
block|{
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|node
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|count
init|=
name|list
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|listNode
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|listNode
operator|.
name|getKind
argument_list|()
operator|.
name|belongsTo
argument_list|(
name|SqlKind
operator|.
name|QUERY
argument_list|)
condition|)
block|{
name|listNode
operator|=
name|SqlStdOperatorTable
operator|.
name|SCALAR_QUERY
operator|.
name|createCall
argument_list|(
name|listNode
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|listNode
argument_list|)
expr_stmt|;
name|list
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|listNode
argument_list|)
expr_stmt|;
block|}
name|registerSubQueries
argument_list|(
name|parentScope
argument_list|,
name|listNode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// atomic node -- can be ignored
block|}
block|}
comment|/**    * Registers any sub-queries inside a given call operand, and converts the    * operand to a scalar sub-query if the operator requires it.    *    * @param parentScope    Parent scope    * @param call           Call    * @param operandOrdinal Ordinal of operand within call    * @see SqlOperator#argumentMustBeScalar(int)    */
specifier|private
name|void
name|registerOperandSubQueries
parameter_list|(
name|SqlValidatorScope
name|parentScope
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|operandOrdinal
parameter_list|)
block|{
name|SqlNode
name|operand
init|=
name|call
operator|.
name|operand
argument_list|(
name|operandOrdinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|operand
operator|.
name|getKind
argument_list|()
operator|.
name|belongsTo
argument_list|(
name|SqlKind
operator|.
name|QUERY
argument_list|)
operator|&&
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|argumentMustBeScalar
argument_list|(
name|operandOrdinal
argument_list|)
condition|)
block|{
name|operand
operator|=
name|SqlStdOperatorTable
operator|.
name|SCALAR_QUERY
operator|.
name|createCall
argument_list|(
name|operand
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|call
operator|.
name|setOperand
argument_list|(
name|operandOrdinal
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
name|registerSubQueries
argument_list|(
name|parentScope
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateIdentifier
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|SqlQualified
name|fqId
init|=
name|scope
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|expandColumnReferences
condition|)
block|{
comment|// NOTE jvs 9-Apr-2007: this doesn't cover ORDER BY, which has its
comment|// own ideas about qualification.
name|id
operator|.
name|assignNamesFrom
argument_list|(
name|fqId
operator|.
name|identifier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Util
operator|.
name|discard
argument_list|(
name|fqId
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|validateLiteral
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|DECIMAL
case|:
comment|// Decimal and long have the same precision (as 64-bit integers), so
comment|// the unscaled value of a decimal must fit into a long.
comment|// REVIEW jvs 4-Aug-2004:  This should probably be calling over to
comment|// the available calculator implementations to see what they
comment|// support.  For now use ESP instead.
comment|//
comment|// jhyde 2006/12/21: I think the limits should be baked into the
comment|// type system, not dependent on the calculator implementation.
name|BigDecimal
name|bd
init|=
operator|(
name|BigDecimal
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|BigInteger
name|unscaled
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
decl_stmt|;
name|long
name|longValue
init|=
name|unscaled
operator|.
name|longValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|longValue
argument_list|)
operator|.
name|equals
argument_list|(
name|unscaled
argument_list|)
condition|)
block|{
comment|// overflow
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|RESOURCE
operator|.
name|numberLiteralOutOfRange
argument_list|(
name|bd
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|DOUBLE
case|:
name|validateLiteralAsDouble
argument_list|(
name|literal
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
specifier|final
name|BitString
name|bitString
init|=
operator|(
name|BitString
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|bitString
operator|.
name|getBitCount
argument_list|()
operator|%
literal|8
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|RESOURCE
operator|.
name|binaryLiteralOdd
argument_list|()
argument_list|)
throw|;
block|}
break|break;
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
name|Calendar
name|calendar
init|=
name|literal
operator|.
name|getValueAs
argument_list|(
name|Calendar
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|int
name|year
init|=
name|calendar
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
specifier|final
name|int
name|era
init|=
name|calendar
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ERA
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|<
literal|1
operator|||
name|era
operator|==
name|GregorianCalendar
operator|.
name|BC
operator|||
name|year
operator|>
literal|9999
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|RESOURCE
operator|.
name|dateLiteralOutOfRange
argument_list|(
name|literal
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
if|if
condition|(
name|literal
operator|instanceof
name|SqlIntervalLiteral
condition|)
block|{
name|SqlIntervalLiteral
operator|.
name|IntervalValue
name|interval
init|=
operator|(
name|SqlIntervalLiteral
operator|.
name|IntervalValue
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|SqlIntervalQualifier
name|intervalQualifier
init|=
name|interval
operator|.
name|getIntervalQualifier
argument_list|()
decl_stmt|;
comment|// ensure qualifier is good before attempting to validate literal
name|validateIntervalQualifier
argument_list|(
name|intervalQualifier
argument_list|)
expr_stmt|;
name|String
name|intervalStr
init|=
name|interval
operator|.
name|getIntervalLiteral
argument_list|()
decl_stmt|;
comment|// throws CalciteContextException if string is invalid
name|int
index|[]
name|values
init|=
name|intervalQualifier
operator|.
name|evaluateIntervalLiteral
argument_list|(
name|intervalStr
argument_list|,
name|literal
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// default is to do nothing
block|}
block|}
specifier|private
name|void
name|validateLiteralAsDouble
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
name|BigDecimal
name|bd
init|=
operator|(
name|BigDecimal
operator|)
name|literal
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|double
name|d
init|=
name|bd
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|Double
operator|.
name|isInfinite
argument_list|(
name|d
argument_list|)
operator|||
name|Double
operator|.
name|isNaN
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|// overflow
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|RESOURCE
operator|.
name|numberLiteralOutOfRange
argument_list|(
name|Util
operator|.
name|toScientificNotation
argument_list|(
name|bd
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// REVIEW jvs 4-Aug-2004:  what about underflow?
block|}
specifier|public
name|void
name|validateIntervalQualifier
parameter_list|(
name|SqlIntervalQualifier
name|qualifier
parameter_list|)
block|{
assert|assert
name|qualifier
operator|!=
literal|null
assert|;
name|boolean
name|startPrecisionOutOfRange
init|=
literal|false
decl_stmt|;
name|boolean
name|fractionalSecondPrecisionOutOfRange
init|=
literal|false
decl_stmt|;
specifier|final
name|RelDataTypeSystem
name|typeSystem
init|=
name|typeFactory
operator|.
name|getTypeSystem
argument_list|()
decl_stmt|;
specifier|final
name|int
name|startPrecision
init|=
name|qualifier
operator|.
name|getStartPrecision
argument_list|(
name|typeSystem
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fracPrecision
init|=
name|qualifier
operator|.
name|getFractionalSecondPrecision
argument_list|(
name|typeSystem
argument_list|)
decl_stmt|;
specifier|final
name|int
name|maxPrecision
init|=
name|typeSystem
operator|.
name|getMaxPrecision
argument_list|(
name|qualifier
operator|.
name|typeName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minPrecision
init|=
name|qualifier
operator|.
name|typeName
argument_list|()
operator|.
name|getMinPrecision
argument_list|()
decl_stmt|;
specifier|final
name|int
name|minScale
init|=
name|qualifier
operator|.
name|typeName
argument_list|()
operator|.
name|getMinScale
argument_list|()
decl_stmt|;
specifier|final
name|int
name|maxScale
init|=
name|typeSystem
operator|.
name|getMaxScale
argument_list|(
name|qualifier
operator|.
name|typeName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifier
operator|.
name|isYearMonth
argument_list|()
condition|)
block|{
if|if
condition|(
name|startPrecision
argument_list|<
name|minPrecision
operator|||
name|startPrecision
argument_list|>
name|maxPrecision
condition|)
block|{
name|startPrecisionOutOfRange
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fracPrecision
argument_list|<
name|minScale
operator|||
name|fracPrecision
argument_list|>
name|maxScale
condition|)
block|{
name|fractionalSecondPrecisionOutOfRange
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|startPrecision
argument_list|<
name|minPrecision
operator|||
name|startPrecision
argument_list|>
name|maxPrecision
condition|)
block|{
name|startPrecisionOutOfRange
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fracPrecision
argument_list|<
name|minScale
operator|||
name|fracPrecision
argument_list|>
name|maxScale
condition|)
block|{
name|fractionalSecondPrecisionOutOfRange
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|startPrecisionOutOfRange
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|qualifier
argument_list|,
name|RESOURCE
operator|.
name|intervalStartPrecisionOutOfRange
argument_list|(
name|startPrecision
argument_list|,
literal|"INTERVAL "
operator|+
name|qualifier
argument_list|)
argument_list|)
throw|;
block|}
if|else if
condition|(
name|fractionalSecondPrecisionOutOfRange
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|qualifier
argument_list|,
name|RESOURCE
operator|.
name|intervalFractionalSecondPrecisionOutOfRange
argument_list|(
name|fracPrecision
argument_list|,
literal|"INTERVAL "
operator|+
name|qualifier
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Validates the FROM clause of a query, or (recursively) a child node of    * the FROM clause: AS, OVER, JOIN, VALUES, or sub-query.    *    * @param node          Node in FROM clause, typically a table or derived    *                      table    * @param targetRowType Desired row type of this expression, or    *                      {@link #unknownType} if not fussy. Must not be null.    * @param scope         Scope    */
specifier|protected
name|void
name|validateFrom
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|targetRowType
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|AS
case|:
name|validateFrom
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|,
name|targetRowType
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUES
case|:
name|validateValues
argument_list|(
operator|(
name|SqlCall
operator|)
name|node
argument_list|,
name|targetRowType
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOIN
case|:
name|validateJoin
argument_list|(
operator|(
name|SqlJoin
operator|)
name|node
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVER
case|:
name|validateOver
argument_list|(
operator|(
name|SqlCall
operator|)
name|node
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
default|default:
name|validateQuery
argument_list|(
name|node
argument_list|,
name|scope
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Validate the namespace representation of the node, just in case the
comment|// validation did not occur implicitly.
name|getNamespace
argument_list|(
name|node
argument_list|,
name|scope
argument_list|)
operator|.
name|validate
argument_list|(
name|targetRowType
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|validateOver
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"OVER unexpected in this context"
argument_list|)
throw|;
block|}
specifier|private
name|void
name|checkRollUpInUsing
parameter_list|(
name|SqlIdentifier
name|identifier
parameter_list|,
name|SqlNode
name|leftOrRight
parameter_list|)
block|{
name|leftOrRight
operator|=
name|stripAs
argument_list|(
name|leftOrRight
argument_list|)
expr_stmt|;
comment|// if it's not a SqlIdentifier then that's fine, it'll be validated somewhere else.
if|if
condition|(
name|leftOrRight
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|SqlIdentifier
name|from
init|=
operator|(
name|SqlIdentifier
operator|)
name|leftOrRight
decl_stmt|;
name|Table
name|table
init|=
name|findTable
argument_list|(
name|catalogReader
operator|.
name|getRootSchema
argument_list|()
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|from
operator|.
name|names
argument_list|)
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|Util
operator|.
name|last
argument_list|(
name|identifier
operator|.
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
operator|&&
name|table
operator|.
name|isRolledUp
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|identifier
argument_list|,
name|RESOURCE
operator|.
name|rolledUpNotAllowed
argument_list|(
name|name
argument_list|,
literal|"USING"
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|validateJoin
parameter_list|(
name|SqlJoin
name|join
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|SqlNode
name|left
init|=
name|join
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|SqlNode
name|right
init|=
name|join
operator|.
name|getRight
argument_list|()
decl_stmt|;
name|SqlNode
name|condition
init|=
name|join
operator|.
name|getCondition
argument_list|()
decl_stmt|;
name|boolean
name|natural
init|=
name|join
operator|.
name|isNatural
argument_list|()
decl_stmt|;
specifier|final
name|JoinType
name|joinType
init|=
name|join
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
specifier|final
name|JoinConditionType
name|conditionType
init|=
name|join
operator|.
name|getConditionType
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
name|joinScope
init|=
name|scopes
operator|.
name|get
argument_list|(
name|join
argument_list|)
decl_stmt|;
name|validateFrom
argument_list|(
name|left
argument_list|,
name|unknownType
argument_list|,
name|joinScope
argument_list|)
expr_stmt|;
name|validateFrom
argument_list|(
name|right
argument_list|,
name|unknownType
argument_list|,
name|joinScope
argument_list|)
expr_stmt|;
comment|// Validate condition.
switch|switch
condition|(
name|conditionType
condition|)
block|{
case|case
name|NONE
case|:
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|condition
operator|==
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|ON
case|:
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|condition
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|SqlNode
name|expandedCondition
init|=
name|expand
argument_list|(
name|condition
argument_list|,
name|joinScope
argument_list|)
decl_stmt|;
name|join
operator|.
name|setOperand
argument_list|(
literal|5
argument_list|,
name|expandedCondition
argument_list|)
expr_stmt|;
name|condition
operator|=
name|join
operator|.
name|getCondition
argument_list|()
expr_stmt|;
name|validateWhereOrOn
argument_list|(
name|joinScope
argument_list|,
name|condition
argument_list|,
literal|"ON"
argument_list|)
expr_stmt|;
name|checkRollUp
argument_list|(
literal|null
argument_list|,
name|join
argument_list|,
name|condition
argument_list|,
name|joinScope
argument_list|,
literal|"ON"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING
case|:
name|SqlNodeList
name|list
init|=
operator|(
name|SqlNodeList
operator|)
name|condition
decl_stmt|;
comment|// Parser ensures that using clause is not empty.
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|list
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|,
literal|"Empty USING clause"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|leftColType
init|=
name|validateUsingCol
argument_list|(
name|id
argument_list|,
name|left
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rightColType
init|=
name|validateUsingCol
argument_list|(
name|id
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isComparable
argument_list|(
name|leftColType
argument_list|,
name|rightColType
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|naturalOrUsingColumnNotCompatible
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|,
name|leftColType
operator|.
name|toString
argument_list|()
argument_list|,
name|rightColType
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|checkRollUpInUsing
argument_list|(
name|id
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|checkRollUpInUsing
argument_list|(
name|id
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|conditionType
argument_list|)
throw|;
block|}
comment|// Validate NATURAL.
if|if
condition|(
name|natural
condition|)
block|{
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|condition
argument_list|,
name|RESOURCE
operator|.
name|naturalDisallowsOnOrUsing
argument_list|()
argument_list|)
throw|;
block|}
comment|// Join on fields that occur exactly once on each side. Ignore
comment|// fields that occur more than once on either side.
specifier|final
name|RelDataType
name|leftRowType
init|=
name|getNamespace
argument_list|(
name|left
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rightRowType
init|=
name|getNamespace
argument_list|(
name|right
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|naturalColumnNames
init|=
name|SqlValidatorUtil
operator|.
name|deriveNaturalJoinColumnList
argument_list|(
name|leftRowType
argument_list|,
name|rightRowType
argument_list|)
decl_stmt|;
comment|// Check compatibility of the chosen columns.
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|naturalColumnNames
control|)
block|{
specifier|final
name|RelDataType
name|leftColType
init|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|leftRowType
argument_list|,
name|name
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rightColType
init|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|rightRowType
argument_list|,
name|name
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|isComparable
argument_list|(
name|leftColType
argument_list|,
name|rightColType
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|join
argument_list|,
name|RESOURCE
operator|.
name|naturalOrUsingColumnNotCompatible
argument_list|(
name|name
argument_list|,
name|leftColType
operator|.
name|toString
argument_list|()
argument_list|,
name|rightColType
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Which join types require/allow a ON/USING condition, or allow
comment|// a NATURAL keyword?
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|INNER
case|:
case|case
name|LEFT
case|:
case|case
name|RIGHT
case|:
case|case
name|FULL
case|:
if|if
condition|(
operator|(
name|condition
operator|==
literal|null
operator|)
operator|&&
operator|!
name|natural
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|join
argument_list|,
name|RESOURCE
operator|.
name|joinRequiresCondition
argument_list|()
argument_list|)
throw|;
block|}
break|break;
case|case
name|COMMA
case|:
case|case
name|CROSS
case|:
if|if
condition|(
name|condition
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|join
operator|.
name|getConditionTypeNode
argument_list|()
argument_list|,
name|RESOURCE
operator|.
name|crossJoinDisallowsCondition
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|natural
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|join
operator|.
name|getConditionTypeNode
argument_list|()
argument_list|,
name|RESOURCE
operator|.
name|crossJoinDisallowsCondition
argument_list|()
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|joinType
argument_list|)
throw|;
block|}
block|}
comment|/**    * Throws an error if there is an aggregate or windowed aggregate in the    * given clause.    *    * @param aggFinder Finder for the particular kind(s) of aggregate function    * @param node      Parse tree    * @param clause    Name of clause: "WHERE", "GROUP BY", "ON"    */
specifier|private
name|void
name|validateNoAggs
parameter_list|(
name|AggFinder
name|aggFinder
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|String
name|clause
parameter_list|)
block|{
specifier|final
name|SqlCall
name|agg
init|=
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|agg
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|SqlOperator
name|op
init|=
name|agg
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|SqlStdOperatorTable
operator|.
name|OVER
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|RESOURCE
operator|.
name|windowedAggregateIllegalInClause
argument_list|(
name|clause
argument_list|)
argument_list|)
throw|;
block|}
if|else if
condition|(
name|op
operator|.
name|isGroup
argument_list|()
operator|||
name|op
operator|.
name|isGroupAuxiliary
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|RESOURCE
operator|.
name|groupFunctionMustAppearInGroupByClause
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|RESOURCE
operator|.
name|aggregateIllegalInClause
argument_list|(
name|clause
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|RelDataType
name|validateUsingCol
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|,
name|SqlNode
name|leftOrRight
parameter_list|)
block|{
if|if
condition|(
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|name
init|=
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|namespace
init|=
name|getNamespace
argument_list|(
name|leftOrRight
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|namespace
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|Collections
operator|.
name|frequency
argument_list|(
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|,
name|name
argument_list|)
operator|>
literal|1
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|columnInUsingNotUnique
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|field
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|columnNotFound
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * Validates a SELECT statement.    *    * @param select        Select statement    * @param targetRowType Desired row type, must not be null, may be the data    *                      type 'unknown'.    */
specifier|protected
name|void
name|validateSelect
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
assert|assert
name|targetRowType
operator|!=
literal|null
assert|;
comment|// Namespace is either a select namespace or a wrapper around one.
specifier|final
name|SelectNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|select
argument_list|)
operator|.
name|unwrap
argument_list|(
name|SelectNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Its rowtype is null, meaning it hasn't been validated yet.
comment|// This is important, because we need to take the targetRowType into
comment|// account.
assert|assert
name|ns
operator|.
name|rowType
operator|==
literal|null
assert|;
if|if
condition|(
name|select
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLFeature_E051_01
argument_list|()
argument_list|,
name|select
operator|.
name|getModifierNode
argument_list|(
name|SqlSelectKeyword
operator|.
name|DISTINCT
argument_list|)
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|SqlNodeList
name|selectItems
init|=
name|select
operator|.
name|getSelectList
argument_list|()
decl_stmt|;
name|RelDataType
name|fromType
init|=
name|unknownType
decl_stmt|;
if|if
condition|(
name|selectItems
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
specifier|final
name|SqlNode
name|selectItem
init|=
name|selectItems
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectItem
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|selectItem
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|isStar
argument_list|()
operator|&&
operator|(
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
comment|// Special case: for INSERT ... VALUES(?,?), the SQL
comment|// standard says we're supposed to propagate the target
comment|// types down.  So iff the select list is an unqualified
comment|// star (as it will be after an INSERT ... VALUES has been
comment|// expanded), then propagate.
name|fromType
operator|=
name|targetRowType
expr_stmt|;
block|}
block|}
block|}
comment|// Make sure that items in FROM clause have distinct aliases.
specifier|final
name|SelectScope
name|fromScope
init|=
operator|(
name|SelectScope
operator|)
name|getFromScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|fromScope
operator|.
name|getChildNames
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
condition|)
block|{
name|names
operator|=
name|Lists
operator|.
name|transform
argument_list|(
name|names
argument_list|,
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|String
name|apply
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|duplicateAliasOrdinal
init|=
name|Util
operator|.
name|firstDuplicate
argument_list|(
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|duplicateAliasOrdinal
operator|>=
literal|0
condition|)
block|{
specifier|final
name|ScopeChild
name|child
init|=
name|fromScope
operator|.
name|children
operator|.
name|get
argument_list|(
name|duplicateAliasOrdinal
argument_list|)
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|child
operator|.
name|namespace
operator|.
name|getEnclosingNode
argument_list|()
argument_list|,
name|RESOURCE
operator|.
name|fromAliasDuplicate
argument_list|(
name|child
operator|.
name|name
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|select
operator|.
name|getFrom
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|conformance
operator|.
name|isFromRequired
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|select
argument_list|,
name|RESOURCE
operator|.
name|selectMissingFrom
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|validateFrom
argument_list|(
name|select
operator|.
name|getFrom
argument_list|()
argument_list|,
name|fromType
argument_list|,
name|fromScope
argument_list|)
expr_stmt|;
block|}
name|validateWhereClause
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|validateGroupClause
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|validateHavingClause
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|validateWindowClause
argument_list|(
name|select
argument_list|)
expr_stmt|;
comment|// Validate the SELECT clause late, because a select item might
comment|// depend on the GROUP BY list, or the window function might reference
comment|// window name in the WINDOW clause etc.
specifier|final
name|RelDataType
name|rowType
init|=
name|validateSelectList
argument_list|(
name|selectItems
argument_list|,
name|select
argument_list|,
name|targetRowType
argument_list|)
decl_stmt|;
name|ns
operator|.
name|setType
argument_list|(
name|rowType
argument_list|)
expr_stmt|;
comment|// Validate ORDER BY after we have set ns.rowType because in some
comment|// dialects you can refer to columns of the select list, e.g.
comment|// "SELECT empno AS x FROM emp ORDER BY x"
name|validateOrderList
argument_list|(
name|select
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldCheckForRollUp
argument_list|(
name|select
operator|.
name|getFrom
argument_list|()
argument_list|)
condition|)
block|{
name|checkRollUpInSelectList
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|checkRollUp
argument_list|(
literal|null
argument_list|,
name|select
argument_list|,
name|select
operator|.
name|getWhere
argument_list|()
argument_list|,
name|getWhereScope
argument_list|(
name|select
argument_list|)
argument_list|)
expr_stmt|;
name|checkRollUp
argument_list|(
literal|null
argument_list|,
name|select
argument_list|,
name|select
operator|.
name|getHaving
argument_list|()
argument_list|,
name|getHavingScope
argument_list|(
name|select
argument_list|)
argument_list|)
expr_stmt|;
name|checkRollUpInWindowDecl
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|checkRollUpInGroupBy
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|checkRollUpInOrderBy
argument_list|(
name|select
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkRollUpInSelectList
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
name|SqlValidatorScope
name|scope
init|=
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|item
range|:
name|select
operator|.
name|getSelectList
argument_list|()
control|)
block|{
name|checkRollUp
argument_list|(
literal|null
argument_list|,
name|select
argument_list|,
name|item
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkRollUpInGroupBy
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
name|SqlNodeList
name|group
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
name|group
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|group
control|)
block|{
name|checkRollUp
argument_list|(
literal|null
argument_list|,
name|select
argument_list|,
name|node
argument_list|,
name|getGroupScope
argument_list|(
name|select
argument_list|)
argument_list|,
literal|"GROUP BY"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|checkRollUpInOrderBy
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
name|SqlNodeList
name|orderList
init|=
name|select
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|orderList
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|orderList
control|)
block|{
name|checkRollUp
argument_list|(
literal|null
argument_list|,
name|select
argument_list|,
name|node
argument_list|,
name|getOrderScope
argument_list|(
name|select
argument_list|)
argument_list|,
literal|"ORDER BY"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|checkRollUpInWindow
parameter_list|(
name|SqlWindow
name|window
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
if|if
condition|(
name|window
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|window
operator|.
name|getPartitionList
argument_list|()
control|)
block|{
name|checkRollUp
argument_list|(
literal|null
argument_list|,
name|window
argument_list|,
name|node
argument_list|,
name|scope
argument_list|,
literal|"PARTITION BY"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|node
range|:
name|window
operator|.
name|getOrderList
argument_list|()
control|)
block|{
name|checkRollUp
argument_list|(
literal|null
argument_list|,
name|window
argument_list|,
name|node
argument_list|,
name|scope
argument_list|,
literal|"ORDER BY"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|checkRollUpInWindowDecl
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|decl
range|:
name|select
operator|.
name|getWindowList
argument_list|()
control|)
block|{
name|checkRollUpInWindow
argument_list|(
operator|(
name|SqlWindow
operator|)
name|decl
argument_list|,
name|getSelectScope
argument_list|(
name|select
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkRollUp
parameter_list|(
name|SqlNode
name|grandParent
parameter_list|,
name|SqlNode
name|parent
parameter_list|,
name|SqlNode
name|current
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|String
name|optionalClause
parameter_list|)
block|{
name|current
operator|=
name|stripAs
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|instanceof
name|SqlCall
operator|&&
operator|!
operator|(
name|current
operator|instanceof
name|SqlSelect
operator|)
condition|)
block|{
comment|// Validate OVER separately
name|checkRollUpInWindow
argument_list|(
name|getWindowInOver
argument_list|(
name|current
argument_list|)
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|current
operator|=
name|stripOver
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|children
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|current
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|child
range|:
name|children
control|)
block|{
name|checkRollUp
argument_list|(
name|parent
argument_list|,
name|current
argument_list|,
name|child
argument_list|,
name|scope
argument_list|,
name|optionalClause
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|current
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|current
decl_stmt|;
if|if
condition|(
operator|!
name|id
operator|.
name|isStar
argument_list|()
operator|&&
name|isRolledUpColumn
argument_list|(
name|id
argument_list|,
name|scope
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isAggregation
argument_list|(
name|parent
operator|.
name|getKind
argument_list|()
argument_list|)
operator|||
operator|!
name|isRolledUpColumnAllowedInAgg
argument_list|(
name|id
argument_list|,
name|scope
argument_list|,
operator|(
name|SqlCall
operator|)
name|parent
argument_list|,
name|grandParent
argument_list|)
condition|)
block|{
name|String
name|context
init|=
name|optionalClause
operator|!=
literal|null
condition|?
name|optionalClause
else|:
name|parent
operator|.
name|getKind
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|rolledUpNotAllowed
argument_list|(
name|deriveAlias
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
argument_list|,
name|context
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|checkRollUp
parameter_list|(
name|SqlNode
name|grandParent
parameter_list|,
name|SqlNode
name|parent
parameter_list|,
name|SqlNode
name|current
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|checkRollUp
argument_list|(
name|grandParent
argument_list|,
name|parent
argument_list|,
name|current
argument_list|,
name|scope
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|SqlWindow
name|getWindowInOver
parameter_list|(
name|SqlNode
name|over
parameter_list|)
block|{
if|if
condition|(
name|over
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|OVER
condition|)
block|{
name|SqlNode
name|window
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|over
operator|)
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|window
operator|instanceof
name|SqlWindow
condition|)
block|{
return|return
operator|(
name|SqlWindow
operator|)
name|window
return|;
block|}
comment|// SqlIdentifier, gets validated elsewhere
return|return
literal|null
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|SqlNode
name|stripOver
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|OVER
case|:
return|return
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
default|default:
return|return
name|node
return|;
block|}
block|}
specifier|private
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|findTableColumnPair
parameter_list|(
name|SqlIdentifier
name|identifier
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|getOperatorTable
argument_list|()
argument_list|,
name|identifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SqlQualified
name|qualified
init|=
name|scope
operator|.
name|fullyQualify
argument_list|(
name|identifier
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|qualified
operator|.
name|identifier
operator|.
name|names
decl_stmt|;
if|if
condition|(
name|names
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|names
operator|.
name|get
argument_list|(
name|names
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|names
argument_list|)
argument_list|)
return|;
block|}
comment|// Returns true iff the given column is valid inside the given aggCall.
specifier|private
name|boolean
name|isRolledUpColumnAllowedInAgg
parameter_list|(
name|SqlIdentifier
name|identifier
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|aggCall
parameter_list|,
name|SqlNode
name|parent
parameter_list|)
block|{
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|pair
init|=
name|findTableColumnPair
argument_list|(
name|identifier
argument_list|,
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|String
name|tableAlias
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|String
name|columnName
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|Table
name|table
init|=
name|findTable
argument_list|(
name|tableAlias
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
return|return
name|table
operator|.
name|rolledUpColumnValidInsideAgg
argument_list|(
name|columnName
argument_list|,
name|aggCall
argument_list|,
name|parent
argument_list|,
name|catalogReader
operator|.
name|getConfig
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// Returns true iff the given column is actually rolled up.
specifier|private
name|boolean
name|isRolledUpColumn
parameter_list|(
name|SqlIdentifier
name|identifier
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|pair
init|=
name|findTableColumnPair
argument_list|(
name|identifier
argument_list|,
name|scope
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|tableAlias
init|=
name|pair
operator|.
name|left
decl_stmt|;
name|String
name|columnName
init|=
name|pair
operator|.
name|right
decl_stmt|;
name|Table
name|table
init|=
name|findTable
argument_list|(
name|tableAlias
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
return|return
name|table
operator|.
name|isRolledUp
argument_list|(
name|columnName
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Table
name|findTable
parameter_list|(
name|CalciteSchema
name|schema
parameter_list|,
name|String
name|tableName
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
name|CalciteSchema
operator|.
name|TableEntry
name|entry
init|=
name|schema
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|,
name|caseSensitive
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
return|return
name|entry
operator|.
name|getTable
argument_list|()
return|;
block|}
comment|// Check sub schemas
for|for
control|(
name|CalciteSchema
name|subSchema
range|:
name|schema
operator|.
name|getSubSchemaMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Table
name|table
init|=
name|findTable
argument_list|(
name|subSchema
argument_list|,
name|tableName
argument_list|,
name|caseSensitive
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
return|return
name|table
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Given a table alias, find the corresponding {@link Table} associated with it    * */
specifier|private
name|Table
name|findTable
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tableScope
operator|==
literal|null
condition|)
block|{
comment|// no tables to find
return|return
literal|null
return|;
block|}
for|for
control|(
name|ScopeChild
name|child
range|:
name|tableScope
operator|.
name|children
control|)
block|{
if|if
condition|(
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|matches
argument_list|(
name|child
operator|.
name|name
argument_list|,
name|alias
argument_list|)
condition|)
block|{
name|names
operator|=
operator|(
operator|(
name|SqlIdentifier
operator|)
name|child
operator|.
name|namespace
operator|.
name|getNode
argument_list|()
operator|)
operator|.
name|names
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|names
operator|==
literal|null
operator|||
name|names
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
if|else if
condition|(
name|names
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|findTable
argument_list|(
name|catalogReader
operator|.
name|getRootSchema
argument_list|()
argument_list|,
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
return|;
block|}
name|String
name|schemaName
init|=
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|names
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|CalciteSchema
name|schema
init|=
name|catalogReader
operator|.
name|getRootSchema
argument_list|()
operator|.
name|getSubSchemaMap
argument_list|()
operator|.
name|get
argument_list|(
name|schemaName
argument_list|)
decl_stmt|;
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|CalciteSchema
operator|.
name|TableEntry
name|entry
init|=
name|schema
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|entry
operator|==
literal|null
condition|?
literal|null
else|:
name|entry
operator|.
name|getTable
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|shouldCheckForRollUp
parameter_list|(
name|SqlNode
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|!=
literal|null
condition|)
block|{
name|SqlKind
name|kind
init|=
name|stripAs
argument_list|(
name|from
argument_list|)
operator|.
name|getKind
argument_list|()
decl_stmt|;
return|return
name|kind
operator|!=
name|SqlKind
operator|.
name|VALUES
operator|&&
name|kind
operator|!=
name|SqlKind
operator|.
name|SELECT
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Validates that a query can deliver the modality it promises. Only called    * on the top-most SELECT or set operator in the tree. */
specifier|private
name|void
name|validateModality
parameter_list|(
name|SqlNode
name|query
parameter_list|)
block|{
specifier|final
name|SqlModality
name|modality
init|=
name|deduceModality
argument_list|(
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|query
operator|instanceof
name|SqlSelect
condition|)
block|{
specifier|final
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
name|validateModality
argument_list|(
name|select
argument_list|,
name|modality
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|query
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|VALUES
condition|)
block|{
switch|switch
condition|(
name|modality
condition|)
block|{
case|case
name|STREAM
case|:
throw|throw
name|newValidationError
argument_list|(
name|query
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|cannotStreamValues
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
assert|assert
name|query
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|SET_QUERY
argument_list|)
assert|;
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|query
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|deduceModality
argument_list|(
name|operand
argument_list|)
operator|!=
name|modality
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|operand
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|streamSetOpInconsistentInputs
argument_list|()
argument_list|)
throw|;
block|}
name|validateModality
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Return the intended modality of a SELECT or set-op. */
specifier|private
name|SqlModality
name|deduceModality
parameter_list|(
name|SqlNode
name|query
parameter_list|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
return|return
name|select
operator|.
name|getModifierNode
argument_list|(
name|SqlSelectKeyword
operator|.
name|STREAM
argument_list|)
operator|!=
literal|null
condition|?
name|SqlModality
operator|.
name|STREAM
else|:
name|SqlModality
operator|.
name|RELATION
return|;
block|}
if|else if
condition|(
name|query
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|VALUES
condition|)
block|{
return|return
name|SqlModality
operator|.
name|RELATION
return|;
block|}
else|else
block|{
assert|assert
name|query
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|SET_QUERY
argument_list|)
assert|;
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|query
decl_stmt|;
return|return
name|deduceModality
argument_list|(
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
name|boolean
name|validateModality
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlModality
name|modality
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
specifier|final
name|SelectScope
name|scope
init|=
name|getRawSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|modality
condition|)
block|{
case|case
name|STREAM
case|:
if|if
condition|(
name|scope
operator|.
name|children
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|ScopeChild
name|child
range|:
name|scope
operator|.
name|children
control|)
block|{
if|if
condition|(
operator|!
name|child
operator|.
name|namespace
operator|.
name|supportsModality
argument_list|(
name|modality
argument_list|)
condition|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|child
operator|.
name|namespace
operator|.
name|getNode
argument_list|()
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|cannotConvertToStream
argument_list|(
name|child
operator|.
name|name
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
else|else
block|{
name|int
name|supportsModalityCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ScopeChild
name|child
range|:
name|scope
operator|.
name|children
control|)
block|{
if|if
condition|(
name|child
operator|.
name|namespace
operator|.
name|supportsModality
argument_list|(
name|modality
argument_list|)
condition|)
block|{
operator|++
name|supportsModalityCount
expr_stmt|;
block|}
block|}
if|if
condition|(
name|supportsModalityCount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
name|String
name|inputs
init|=
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|scope
operator|.
name|getChildNames
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|select
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|cannotStreamResultsForNonStreamingInputs
argument_list|(
name|inputs
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
break|break;
default|default:
for|for
control|(
name|ScopeChild
name|child
range|:
name|scope
operator|.
name|children
control|)
block|{
if|if
condition|(
operator|!
name|child
operator|.
name|namespace
operator|.
name|supportsModality
argument_list|(
name|modality
argument_list|)
condition|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|child
operator|.
name|namespace
operator|.
name|getNode
argument_list|()
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|cannotConvertToRelation
argument_list|(
name|child
operator|.
name|name
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
comment|// Make sure that aggregation is possible.
specifier|final
name|SqlNode
name|aggregateNode
init|=
name|getAggregate
argument_list|(
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggregateNode
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|modality
condition|)
block|{
case|case
name|STREAM
case|:
name|SqlNodeList
name|groupList
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
name|groupList
operator|==
literal|null
operator|||
operator|!
name|SqlValidatorUtil
operator|.
name|containsMonotonic
argument_list|(
name|scope
argument_list|,
name|groupList
argument_list|)
condition|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|aggregateNode
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|streamMustGroupByMonotonic
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
comment|// Make sure that ORDER BY is possible.
specifier|final
name|SqlNodeList
name|orderList
init|=
name|select
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|orderList
operator|!=
literal|null
operator|&&
name|orderList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|modality
condition|)
block|{
case|case
name|STREAM
case|:
if|if
condition|(
operator|!
name|hasSortedPrefix
argument_list|(
name|scope
argument_list|,
name|orderList
argument_list|)
condition|)
block|{
if|if
condition|(
name|fail
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|orderList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|streamMustOrderByMonotonic
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Returns whether the prefix is sorted. */
specifier|private
name|boolean
name|hasSortedPrefix
parameter_list|(
name|SelectScope
name|scope
parameter_list|,
name|SqlNodeList
name|orderList
parameter_list|)
block|{
return|return
name|isSortCompatible
argument_list|(
name|scope
argument_list|,
name|orderList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isSortCompatible
parameter_list|(
name|SelectScope
name|scope
parameter_list|,
name|SqlNode
name|node
parameter_list|,
name|boolean
name|descending
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
return|return
name|isSortCompatible
argument_list|(
name|scope
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|final
name|SqlMonotonicity
name|monotonicity
init|=
name|scope
operator|.
name|getMonotonicity
argument_list|(
name|node
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|monotonicity
condition|)
block|{
case|case
name|INCREASING
case|:
case|case
name|STRICTLY_INCREASING
case|:
return|return
operator|!
name|descending
return|;
case|case
name|DECREASING
case|:
case|case
name|STRICTLY_DECREASING
case|:
return|return
name|descending
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
specifier|protected
name|void
name|validateWindowClause
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|windowList
init|=
name|select
operator|.
name|getWindowList
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|SqlWindow
argument_list|>
name|windows
init|=
operator|(
name|List
operator|)
name|windowList
operator|.
name|getList
argument_list|()
decl_stmt|;
if|if
condition|(
name|windows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|SelectScope
name|windowScope
init|=
operator|(
name|SelectScope
operator|)
name|getFromScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
assert|assert
name|windowScope
operator|!=
literal|null
assert|;
comment|// 1. ensure window names are simple
comment|// 2. ensure they are unique within this scope
for|for
control|(
name|SqlWindow
name|window
range|:
name|windows
control|)
block|{
name|SqlIdentifier
name|declName
init|=
name|window
operator|.
name|getDeclName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|declName
operator|.
name|isSimple
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|declName
argument_list|,
name|RESOURCE
operator|.
name|windowNameMustBeSimple
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|windowScope
operator|.
name|existingWindowName
argument_list|(
name|declName
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|declName
argument_list|,
name|RESOURCE
operator|.
name|duplicateWindowName
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|windowScope
operator|.
name|addWindowName
argument_list|(
name|declName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 7.10 rule 2
comment|// Check for pairs of windows which are equivalent.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|window1
init|=
name|windows
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|windows
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|SqlNode
name|window2
init|=
name|windows
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|window1
operator|.
name|equalsDeep
argument_list|(
name|window2
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|window2
argument_list|,
name|RESOURCE
operator|.
name|dupWindowSpec
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
for|for
control|(
name|SqlWindow
name|window
range|:
name|windows
control|)
block|{
specifier|final
name|SqlNodeList
name|expandedOrderList
init|=
operator|(
name|SqlNodeList
operator|)
name|expand
argument_list|(
name|window
operator|.
name|getOrderList
argument_list|()
argument_list|,
name|windowScope
argument_list|)
decl_stmt|;
name|window
operator|.
name|setOrderList
argument_list|(
name|expandedOrderList
argument_list|)
expr_stmt|;
name|expandedOrderList
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|windowScope
argument_list|)
expr_stmt|;
specifier|final
name|SqlNodeList
name|expandedPartitionList
init|=
operator|(
name|SqlNodeList
operator|)
name|expand
argument_list|(
name|window
operator|.
name|getPartitionList
argument_list|()
argument_list|,
name|windowScope
argument_list|)
decl_stmt|;
name|window
operator|.
name|setPartitionList
argument_list|(
name|expandedPartitionList
argument_list|)
expr_stmt|;
name|expandedPartitionList
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|windowScope
argument_list|)
expr_stmt|;
block|}
comment|// Hand off to validate window spec components
name|windowList
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|windowScope
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateWith
parameter_list|(
name|SqlWith
name|with
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|namespace
init|=
name|getNamespace
argument_list|(
name|with
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|namespace
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateWithItem
parameter_list|(
name|SqlWithItem
name|withItem
parameter_list|)
block|{
if|if
condition|(
name|withItem
operator|.
name|columnList
operator|!=
literal|null
condition|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|getValidatedNodeType
argument_list|(
name|withItem
operator|.
name|query
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|withItem
operator|.
name|columnList
operator|.
name|size
argument_list|()
operator|!=
name|fieldCount
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|withItem
operator|.
name|columnList
argument_list|,
name|RESOURCE
operator|.
name|columnCountMismatch
argument_list|()
argument_list|)
throw|;
block|}
name|SqlValidatorUtil
operator|.
name|checkIdentifierListForDuplicates
argument_list|(
name|withItem
operator|.
name|columnList
operator|.
name|getList
argument_list|()
argument_list|,
name|validationErrorFunction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Luckily, field names have not been make unique yet.
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|getValidatedNodeType
argument_list|(
name|withItem
operator|.
name|query
argument_list|)
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|int
name|i
init|=
name|Util
operator|.
name|firstDuplicate
argument_list|(
name|fieldNames
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|withItem
operator|.
name|query
argument_list|,
name|RESOURCE
operator|.
name|duplicateColumnAndNoColumnList
argument_list|(
name|fieldNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|void
name|validateSequenceValue
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// Resolve identifier as a table.
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolveTable
argument_list|(
name|id
operator|.
name|names
argument_list|,
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
argument_list|,
name|SqlValidatorScope
operator|.
name|Path
operator|.
name|EMPTY
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|tableNameNotFound
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// We've found a table. But is it a sequence?
specifier|final
name|SqlValidatorNamespace
name|ns
init|=
name|resolved
operator|.
name|only
argument_list|()
operator|.
name|namespace
decl_stmt|;
if|if
condition|(
name|ns
operator|instanceof
name|TableNamespace
condition|)
block|{
specifier|final
name|Table
name|table
init|=
operator|(
operator|(
name|RelOptTable
operator|)
name|ns
operator|.
name|getTable
argument_list|()
operator|)
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|table
operator|.
name|getJdbcTableType
argument_list|()
condition|)
block|{
case|case
name|SEQUENCE
case|:
case|case
name|TEMPORARY_SEQUENCE
case|:
return|return;
block|}
block|}
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|notASequence
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
specifier|public
name|SqlValidatorScope
name|getWithScope
parameter_list|(
name|SqlNode
name|withItem
parameter_list|)
block|{
assert|assert
name|withItem
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|WITH_ITEM
assert|;
return|return
name|scopes
operator|.
name|get
argument_list|(
name|withItem
argument_list|)
return|;
block|}
comment|/**    * Validates the ORDER BY clause of a SELECT statement.    *    * @param select Select statement    */
specifier|protected
name|void
name|validateOrderList
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// ORDER BY is validated in a scope where aliases in the SELECT clause
comment|// are visible. For example, "SELECT empno AS x FROM emp ORDER BY x"
comment|// is valid.
name|SqlNodeList
name|orderList
init|=
name|select
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|orderList
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|shouldAllowIntermediateOrderBy
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|cursorSet
operator|.
name|contains
argument_list|(
name|select
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|select
argument_list|,
name|RESOURCE
operator|.
name|invalidOrderByPos
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|final
name|SqlValidatorScope
name|orderScope
init|=
name|getOrderScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|orderScope
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|expandList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|orderItem
range|:
name|orderList
control|)
block|{
name|SqlNode
name|expandedOrderItem
init|=
name|expand
argument_list|(
name|orderItem
argument_list|,
name|orderScope
argument_list|)
decl_stmt|;
name|expandList
operator|.
name|add
argument_list|(
name|expandedOrderItem
argument_list|)
expr_stmt|;
block|}
name|SqlNodeList
name|expandedOrderList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|expandList
argument_list|,
name|orderList
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
name|select
operator|.
name|setOrderBy
argument_list|(
name|expandedOrderList
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|orderItem
range|:
name|expandedOrderList
control|)
block|{
name|validateOrderItem
argument_list|(
name|select
argument_list|,
name|orderItem
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Validates an item in the GROUP BY clause of a SELECT statement.    *    * @param select Select statement    * @param groupByItem GROUP BY clause item    */
specifier|private
name|void
name|validateGroupByItem
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|groupByItem
parameter_list|)
block|{
specifier|final
name|SqlValidatorScope
name|groupByScope
init|=
name|getGroupScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|groupByScope
operator|.
name|validateExpr
argument_list|(
name|groupByItem
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validates an item in the ORDER BY clause of a SELECT statement.    *    * @param select Select statement    * @param orderItem ORDER BY clause item    */
specifier|private
name|void
name|validateOrderItem
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|orderItem
parameter_list|)
block|{
switch|switch
condition|(
name|orderItem
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|DESCENDING
case|:
name|validateFeature
argument_list|(
name|RESOURCE
operator|.
name|sQLConformance_OrderByDesc
argument_list|()
argument_list|,
name|orderItem
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|validateOrderItem
argument_list|(
name|select
argument_list|,
operator|(
operator|(
name|SqlCall
operator|)
name|orderItem
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|SqlValidatorScope
name|orderScope
init|=
name|getOrderScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|validateExpr
argument_list|(
name|orderItem
argument_list|,
name|orderScope
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|expandOrderExpr
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|orderExpr
parameter_list|)
block|{
specifier|final
name|SqlNode
name|newSqlNode
init|=
operator|new
name|OrderExpressionExpander
argument_list|(
name|select
argument_list|,
name|orderExpr
argument_list|)
operator|.
name|go
argument_list|()
decl_stmt|;
if|if
condition|(
name|newSqlNode
operator|!=
name|orderExpr
condition|)
block|{
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|getOrderScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|inferUnknownTypes
argument_list|(
name|unknownType
argument_list|,
name|scope
argument_list|,
name|newSqlNode
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|newSqlNode
argument_list|)
decl_stmt|;
name|setValidatedNodeType
argument_list|(
name|newSqlNode
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|newSqlNode
return|;
block|}
comment|/**    * Validates the GROUP BY clause of a SELECT statement. This method is    * called even if no GROUP BY clause is present.    */
specifier|protected
name|void
name|validateGroupClause
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
name|SqlNodeList
name|groupList
init|=
name|select
operator|.
name|getGroup
argument_list|()
decl_stmt|;
if|if
condition|(
name|groupList
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|validateNoAggs
argument_list|(
name|aggOrOverFinder
argument_list|,
name|groupList
argument_list|,
literal|"GROUP BY"
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorScope
name|groupScope
init|=
name|getGroupScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|inferUnknownTypes
argument_list|(
name|unknownType
argument_list|,
name|groupScope
argument_list|,
name|groupList
argument_list|)
expr_stmt|;
comment|// expand the expression in group list.
name|List
argument_list|<
name|SqlNode
argument_list|>
name|expandedList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|groupItem
range|:
name|groupList
control|)
block|{
name|SqlNode
name|expandedItem
init|=
name|expandGroupByOrHavingExpr
argument_list|(
name|groupItem
argument_list|,
name|groupScope
argument_list|,
name|select
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|expandedList
operator|.
name|add
argument_list|(
name|expandedItem
argument_list|)
expr_stmt|;
block|}
name|groupList
operator|=
operator|new
name|SqlNodeList
argument_list|(
name|expandedList
argument_list|,
name|groupList
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|select
operator|.
name|setGroupBy
argument_list|(
name|groupList
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|groupItem
range|:
name|expandedList
control|)
block|{
name|validateGroupByItem
argument_list|(
name|select
argument_list|,
name|groupItem
argument_list|)
expr_stmt|;
block|}
comment|// Nodes in the GROUP BY clause are expressions except if they are calls
comment|// to the GROUPING SETS, ROLLUP or CUBE operators; this operators are not
comment|// expressions, because they do not have a type.
for|for
control|(
name|SqlNode
name|node
range|:
name|groupList
control|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|GROUPING_SETS
case|:
case|case
name|ROLLUP
case|:
case|case
name|CUBE
case|:
name|node
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|groupScope
argument_list|)
expr_stmt|;
break|break;
default|default:
name|node
operator|.
name|validateExpr
argument_list|(
name|this
argument_list|,
name|groupScope
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Derive the type of each GROUP BY item. We don't need the type, but
comment|// it resolves functions, and that is necessary for deducing
comment|// monotonicity.
specifier|final
name|SqlValidatorScope
name|selectScope
init|=
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
name|AggregatingSelectScope
name|aggregatingScope
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|selectScope
operator|instanceof
name|AggregatingSelectScope
condition|)
block|{
name|aggregatingScope
operator|=
operator|(
name|AggregatingSelectScope
operator|)
name|selectScope
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|groupItem
range|:
name|groupList
control|)
block|{
if|if
condition|(
name|groupItem
operator|instanceof
name|SqlNodeList
operator|&&
operator|(
operator|(
name|SqlNodeList
operator|)
name|groupItem
operator|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|validateGroupItem
argument_list|(
name|groupScope
argument_list|,
name|aggregatingScope
argument_list|,
name|groupItem
argument_list|)
expr_stmt|;
block|}
name|SqlNode
name|agg
init|=
name|aggFinder
operator|.
name|findAgg
argument_list|(
name|groupList
argument_list|)
decl_stmt|;
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|agg
argument_list|,
name|RESOURCE
operator|.
name|aggregateIllegalInGroupBy
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|validateGroupItem
parameter_list|(
name|SqlValidatorScope
name|groupScope
parameter_list|,
name|AggregatingSelectScope
name|aggregatingScope
parameter_list|,
name|SqlNode
name|groupItem
parameter_list|)
block|{
switch|switch
condition|(
name|groupItem
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|GROUPING_SETS
case|:
case|case
name|ROLLUP
case|:
case|case
name|CUBE
case|:
name|validateGroupingSets
argument_list|(
name|groupScope
argument_list|,
name|aggregatingScope
argument_list|,
operator|(
name|SqlCall
operator|)
name|groupItem
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|groupItem
operator|instanceof
name|SqlNodeList
condition|)
block|{
break|break;
block|}
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|groupScope
argument_list|,
name|groupItem
argument_list|)
decl_stmt|;
name|setValidatedNodeType
argument_list|(
name|groupItem
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|validateGroupingSets
parameter_list|(
name|SqlValidatorScope
name|groupScope
parameter_list|,
name|AggregatingSelectScope
name|aggregatingScope
parameter_list|,
name|SqlCall
name|groupItem
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|groupItem
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|validateGroupItem
argument_list|(
name|groupScope
argument_list|,
name|aggregatingScope
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|validateWhereClause
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// validate WHERE clause
specifier|final
name|SqlNode
name|where
init|=
name|select
operator|.
name|getWhere
argument_list|()
decl_stmt|;
if|if
condition|(
name|where
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|SqlValidatorScope
name|whereScope
init|=
name|getWhereScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|expandedWhere
init|=
name|expand
argument_list|(
name|where
argument_list|,
name|whereScope
argument_list|)
decl_stmt|;
name|select
operator|.
name|setWhere
argument_list|(
name|expandedWhere
argument_list|)
expr_stmt|;
name|validateWhereOrOn
argument_list|(
name|whereScope
argument_list|,
name|expandedWhere
argument_list|,
literal|"WHERE"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|validateWhereOrOn
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlNode
name|condition
parameter_list|,
name|String
name|keyword
parameter_list|)
block|{
name|validateNoAggs
argument_list|(
name|aggOrOverOrGroupFinder
argument_list|,
name|condition
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|inferUnknownTypes
argument_list|(
name|booleanType
argument_list|,
name|scope
argument_list|,
name|condition
argument_list|)
expr_stmt|;
name|condition
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|condition
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|inBooleanFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|condition
argument_list|,
name|RESOURCE
operator|.
name|condMustBeBoolean
argument_list|(
name|keyword
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|void
name|validateHavingClause
parameter_list|(
name|SqlSelect
name|select
parameter_list|)
block|{
comment|// HAVING is validated in the scope after groups have been created.
comment|// For example, in "SELECT empno FROM emp WHERE empno = 10 GROUP BY
comment|// deptno HAVING empno = 10", the reference to 'empno' in the HAVING
comment|// clause is illegal.
name|SqlNode
name|having
init|=
name|select
operator|.
name|getHaving
argument_list|()
decl_stmt|;
if|if
condition|(
name|having
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|AggregatingScope
name|havingScope
init|=
operator|(
name|AggregatingScope
operator|)
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|getConformance
argument_list|()
operator|.
name|isHavingAlias
argument_list|()
condition|)
block|{
name|SqlNode
name|newExpr
init|=
name|expandGroupByOrHavingExpr
argument_list|(
name|having
argument_list|,
name|havingScope
argument_list|,
name|select
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|having
operator|!=
name|newExpr
condition|)
block|{
name|having
operator|=
name|newExpr
expr_stmt|;
name|select
operator|.
name|setHaving
argument_list|(
name|newExpr
argument_list|)
expr_stmt|;
block|}
block|}
name|havingScope
operator|.
name|checkAggregateExpr
argument_list|(
name|having
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|inferUnknownTypes
argument_list|(
name|booleanType
argument_list|,
name|havingScope
argument_list|,
name|having
argument_list|)
expr_stmt|;
name|having
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|havingScope
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|havingScope
argument_list|,
name|having
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|inBooleanFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|having
argument_list|,
name|RESOURCE
operator|.
name|havingMustBeBoolean
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|RelDataType
name|validateSelectList
parameter_list|(
specifier|final
name|SqlNodeList
name|selectItems
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
comment|// First pass, ensure that aliases are unique. "*" and "TABLE.*" items
comment|// are ignored.
comment|// Validate SELECT list. Expand terms of the form "*" or "TABLE.*".
specifier|final
name|SqlValidatorScope
name|selectScope
init|=
name|getSelectScope
argument_list|(
name|select
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|expandedSelectItems
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|fieldList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectItems
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|selectItem
init|=
name|selectItems
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectItem
operator|instanceof
name|SqlSelect
condition|)
block|{
name|handleScalarSubQuery
argument_list|(
name|select
argument_list|,
operator|(
name|SqlSelect
operator|)
name|selectItem
argument_list|,
name|expandedSelectItems
argument_list|,
name|aliases
argument_list|,
name|fieldList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expandSelectItem
argument_list|(
name|selectItem
argument_list|,
name|select
argument_list|,
name|targetRowType
operator|.
name|isStruct
argument_list|()
operator|&&
name|targetRowType
operator|.
name|getFieldCount
argument_list|()
operator|>=
name|i
condition|?
name|targetRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
else|:
name|unknownType
argument_list|,
name|expandedSelectItems
argument_list|,
name|aliases
argument_list|,
name|fieldList
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create the new select list with expanded items.  Pass through
comment|// the original parser position so that any overall failures can
comment|// still reference the original input text.
name|SqlNodeList
name|newSelectList
init|=
operator|new
name|SqlNodeList
argument_list|(
name|expandedSelectItems
argument_list|,
name|selectItems
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldExpandIdentifiers
argument_list|()
condition|)
block|{
name|select
operator|.
name|setSelectList
argument_list|(
name|newSelectList
argument_list|)
expr_stmt|;
block|}
name|getRawSelectScope
argument_list|(
name|select
argument_list|)
operator|.
name|setExpandedSelectList
argument_list|(
name|expandedSelectItems
argument_list|)
expr_stmt|;
comment|// TODO: when SELECT appears as a value sub-query, should be using
comment|// something other than unknownType for targetRowType
name|inferUnknownTypes
argument_list|(
name|targetRowType
argument_list|,
name|selectScope
argument_list|,
name|newSelectList
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|selectItem
range|:
name|expandedSelectItems
control|)
block|{
name|validateNoAggs
argument_list|(
name|groupFinder
argument_list|,
name|selectItem
argument_list|,
literal|"SELECT"
argument_list|)
expr_stmt|;
name|validateExpr
argument_list|(
name|selectItem
argument_list|,
name|selectScope
argument_list|)
expr_stmt|;
block|}
assert|assert
name|fieldList
operator|.
name|size
argument_list|()
operator|>=
name|aliases
operator|.
name|size
argument_list|()
assert|;
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|fieldList
argument_list|)
return|;
block|}
comment|/**    * Validates an expression.    *    * @param expr  Expression    * @param scope Scope in which expression occurs    */
specifier|private
name|void
name|validateExpr
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|SqlCall
condition|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|isAggregator
argument_list|()
operator|&&
name|op
operator|.
name|requiresOver
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|expr
argument_list|,
name|RESOURCE
operator|.
name|absentOverClause
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Call on the expression to validate itself.
name|expr
operator|.
name|validateExpr
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|// Perform any validation specific to the scope. For example, an
comment|// aggregating scope requires that expressions are valid aggregations.
name|scope
operator|.
name|validateExpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/**    * Processes SubQuery found in Select list. Checks that is actually Scalar    * sub-query and makes proper entries in each of the 3 lists used to create    * the final rowType entry.    *    * @param parentSelect        base SqlSelect item    * @param selectItem          child SqlSelect from select list    * @param expandedSelectItems Select items after processing    * @param aliasList           built from user or system values    * @param fieldList           Built up entries for each select list entry    */
specifier|private
name|void
name|handleScalarSubQuery
parameter_list|(
name|SqlSelect
name|parentSelect
parameter_list|,
name|SqlSelect
name|selectItem
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|expandedSelectItems
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliasList
parameter_list|,
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|fieldList
parameter_list|)
block|{
comment|// A scalar sub-query only has one output column.
if|if
condition|(
literal|1
operator|!=
name|selectItem
operator|.
name|getSelectList
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|selectItem
argument_list|,
name|RESOURCE
operator|.
name|onlyScalarSubQueryAllowed
argument_list|()
argument_list|)
throw|;
block|}
comment|// No expansion in this routine just append to list.
name|expandedSelectItems
operator|.
name|add
argument_list|(
name|selectItem
argument_list|)
expr_stmt|;
comment|// Get or generate alias and add to list.
specifier|final
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|selectItem
argument_list|,
name|aliasList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|aliasList
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
specifier|final
name|SelectScope
name|scope
init|=
operator|(
name|SelectScope
operator|)
name|getWhereScope
argument_list|(
name|parentSelect
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|selectItem
argument_list|)
decl_stmt|;
name|setValidatedNodeType
argument_list|(
name|selectItem
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|// we do not want to pass on the RelRecordType returned
comment|// by the sub query.  Just the type of the single expression
comment|// in the sub-query select list.
assert|assert
name|type
operator|instanceof
name|RelRecordType
assert|;
name|RelRecordType
name|rec
init|=
operator|(
name|RelRecordType
operator|)
name|type
decl_stmt|;
name|RelDataType
name|nodeType
init|=
name|rec
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|nodeType
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|nodeType
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fieldList
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|nodeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Derives a row-type for INSERT and UPDATE operations.    *    * @param table            Target table for INSERT/UPDATE    * @param targetColumnList List of target columns, or null if not specified    * @param append           Whether to append fields to those in<code>    *                         baseRowType</code>    * @return Rowtype    */
specifier|protected
name|RelDataType
name|createTargetRowType
parameter_list|(
name|SqlValidatorTable
name|table
parameter_list|,
name|SqlNodeList
name|targetColumnList
parameter_list|,
name|boolean
name|append
parameter_list|)
block|{
name|RelDataType
name|baseRowType
init|=
name|table
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetColumnList
operator|==
literal|null
condition|)
block|{
return|return
name|baseRowType
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|targetFields
init|=
name|baseRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|append
condition|)
block|{
for|for
control|(
name|RelDataTypeField
name|targetField
range|:
name|targetFields
control|)
block|{
name|types
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|SqlUtil
operator|.
name|deriveAliasFromOrdinal
argument_list|(
name|types
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|targetField
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|assignedFields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelOptTable
name|relOptTable
init|=
name|table
operator|instanceof
name|RelOptTable
condition|?
operator|(
operator|(
name|RelOptTable
operator|)
name|table
operator|)
else|:
literal|null
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|targetColumnList
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
name|RelDataTypeField
name|targetField
init|=
name|SqlValidatorUtil
operator|.
name|getTargetField
argument_list|(
name|baseRowType
argument_list|,
name|typeFactory
argument_list|,
name|id
argument_list|,
name|catalogReader
argument_list|,
name|relOptTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetField
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|unknownTargetColumn
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|assignedFields
operator|.
name|add
argument_list|(
name|targetField
operator|.
name|getIndex
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|duplicateTargetColumn
argument_list|(
name|targetField
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|types
operator|.
name|add
argument_list|(
name|targetField
argument_list|)
expr_stmt|;
block|}
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|)
return|;
block|}
specifier|public
name|void
name|validateInsert
parameter_list|(
name|SqlInsert
name|insert
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|targetNamespace
init|=
name|getNamespace
argument_list|(
name|insert
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
specifier|final
name|RelOptTable
name|relOptTable
init|=
name|SqlValidatorUtil
operator|.
name|getRelOptTable
argument_list|(
name|targetNamespace
argument_list|,
name|catalogReader
operator|.
name|unwrap
argument_list|(
name|Prepare
operator|.
name|CatalogReader
operator|.
name|class
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorTable
name|table
init|=
name|relOptTable
operator|==
literal|null
condition|?
name|targetNamespace
operator|.
name|getTable
argument_list|()
else|:
name|relOptTable
operator|.
name|unwrap
argument_list|(
name|SqlValidatorTable
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// INSERT has an optional column name list.  If present then
comment|// reduce the rowtype to the columns specified.  If not present
comment|// then the entire target rowtype is used.
specifier|final
name|RelDataType
name|targetRowType
init|=
name|createTargetRowType
argument_list|(
name|table
argument_list|,
name|insert
operator|.
name|getTargetColumnList
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|SqlNode
name|source
init|=
name|insert
operator|.
name|getSource
argument_list|()
decl_stmt|;
if|if
condition|(
name|source
operator|instanceof
name|SqlSelect
condition|)
block|{
specifier|final
name|SqlSelect
name|sqlSelect
init|=
operator|(
name|SqlSelect
operator|)
name|source
decl_stmt|;
name|validateSelect
argument_list|(
name|sqlSelect
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SqlValidatorScope
name|scope
init|=
name|scopes
operator|.
name|get
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|validateQuery
argument_list|(
name|source
argument_list|,
name|scope
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
block|}
comment|// REVIEW jvs 4-Dec-2008: In FRG-365, this namespace row type is
comment|// discarding the type inferred by inferUnknownTypes (which was invoked
comment|// from validateSelect above).  It would be better if that information
comment|// were used here so that we never saw any untyped nulls during
comment|// checkTypeAssignment.
specifier|final
name|RelDataType
name|sourceRowType
init|=
name|getNamespace
argument_list|(
name|source
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|logicalTargetRowType
init|=
name|getLogicalTargetRowType
argument_list|(
name|targetRowType
argument_list|,
name|insert
argument_list|)
decl_stmt|;
name|setValidatedNodeType
argument_list|(
name|insert
argument_list|,
name|logicalTargetRowType
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|logicalSourceRowType
init|=
name|getLogicalSourceRowType
argument_list|(
name|sourceRowType
argument_list|,
name|insert
argument_list|)
decl_stmt|;
name|checkFieldCount
argument_list|(
name|insert
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|logicalSourceRowType
argument_list|,
name|logicalTargetRowType
argument_list|)
expr_stmt|;
name|checkTypeAssignment
argument_list|(
name|logicalSourceRowType
argument_list|,
name|logicalTargetRowType
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|checkConstraint
argument_list|(
name|table
argument_list|,
name|source
argument_list|,
name|logicalTargetRowType
argument_list|)
expr_stmt|;
name|validateAccess
argument_list|(
name|insert
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|SqlAccessEnum
operator|.
name|INSERT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validates insert values against the constraint of a modifiable view.    *    * @param validatorTable Table that may wrap a ModifiableViewTable    * @param source        The values being inserted    * @param targetRowType The target type for the view    */
specifier|private
name|void
name|checkConstraint
parameter_list|(
name|SqlValidatorTable
name|validatorTable
parameter_list|,
name|SqlNode
name|source
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
specifier|final
name|ModifiableViewTable
name|modifiableViewTable
init|=
name|validatorTable
operator|.
name|unwrap
argument_list|(
name|ModifiableViewTable
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifiableViewTable
operator|!=
literal|null
operator|&&
name|source
operator|instanceof
name|SqlCall
condition|)
block|{
specifier|final
name|Table
name|table
init|=
name|modifiableViewTable
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|tableRowType
init|=
name|table
operator|.
name|getRowType
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|tableFields
init|=
name|tableRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
comment|// Get the mapping from column indexes of the underlying table
comment|// to the target columns and view constraints.
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RelDataTypeField
argument_list|>
name|tableIndexToTargetField
init|=
name|SqlValidatorUtil
operator|.
name|getIndexToFieldMap
argument_list|(
name|tableFields
argument_list|,
name|targetRowType
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|projectMap
init|=
name|RelOptUtil
operator|.
name|getColumnConstraints
argument_list|(
name|modifiableViewTable
argument_list|,
name|targetRowType
argument_list|,
name|typeFactory
argument_list|)
decl_stmt|;
comment|// Determine columns (indexed to the underlying table) that need
comment|// to be validated against the view constraint.
specifier|final
name|ImmutableBitSet
name|targetColumns
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|tableIndexToTargetField
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|constrainedColumns
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|projectMap
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|constrainedTargetColumns
init|=
name|targetColumns
operator|.
name|intersect
argument_list|(
name|constrainedColumns
argument_list|)
decl_stmt|;
comment|// Validate insert values against the view constraint.
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|values
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|source
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|colIndex
range|:
name|constrainedTargetColumns
operator|.
name|asList
argument_list|()
control|)
block|{
specifier|final
name|String
name|colName
init|=
name|tableFields
operator|.
name|get
argument_list|(
name|colIndex
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
name|targetField
init|=
name|tableIndexToTargetField
operator|.
name|get
argument_list|(
name|colIndex
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|row
range|:
name|values
control|)
block|{
specifier|final
name|SqlCall
name|call
init|=
operator|(
name|SqlCall
operator|)
name|row
decl_stmt|;
specifier|final
name|SqlNode
name|sourceValue
init|=
name|call
operator|.
name|operand
argument_list|(
name|targetField
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ValidationError
name|validationError
init|=
operator|new
name|ValidationError
argument_list|(
name|sourceValue
argument_list|,
name|RESOURCE
operator|.
name|viewConstraintNotSatisfied
argument_list|(
name|colName
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|validatorTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|validateValueAgainstConstraint
argument_list|(
name|sourceValue
argument_list|,
name|projectMap
operator|.
name|get
argument_list|(
name|colIndex
argument_list|)
argument_list|,
name|validationError
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Validates updates against the constraint of a modifiable view.    *    * @param validatorTable A {@link SqlValidatorTable} that may wrap a    *                       ModifiableViewTable    * @param update         The UPDATE parse tree node    * @param targetRowType  The target type    */
specifier|private
name|void
name|checkConstraint
parameter_list|(
name|SqlValidatorTable
name|validatorTable
parameter_list|,
name|SqlUpdate
name|update
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|)
block|{
specifier|final
name|ModifiableViewTable
name|modifiableViewTable
init|=
name|validatorTable
operator|.
name|unwrap
argument_list|(
name|ModifiableViewTable
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifiableViewTable
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Table
name|table
init|=
name|modifiableViewTable
operator|.
name|unwrap
argument_list|(
name|Table
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|tableRowType
init|=
name|table
operator|.
name|getRowType
argument_list|(
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RexNode
argument_list|>
name|projectMap
init|=
name|RelOptUtil
operator|.
name|getColumnConstraints
argument_list|(
name|modifiableViewTable
argument_list|,
name|targetRowType
argument_list|,
name|typeFactory
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nameToIndex
init|=
name|SqlValidatorUtil
operator|.
name|mapNameToIndex
argument_list|(
name|tableRowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
decl_stmt|;
comment|// Validate update values against the view constraint.
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|targets
init|=
name|update
operator|.
name|getTargetColumnList
argument_list|()
operator|.
name|getList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|sources
init|=
name|update
operator|.
name|getSourceExpressionList
argument_list|()
operator|.
name|getList
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Pair
argument_list|<
name|SqlNode
argument_list|,
name|SqlNode
argument_list|>
name|column
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|targets
argument_list|,
name|sources
argument_list|)
control|)
block|{
specifier|final
name|String
name|columnName
init|=
operator|(
operator|(
name|SqlIdentifier
operator|)
name|column
operator|.
name|left
operator|)
operator|.
name|getSimple
argument_list|()
decl_stmt|;
specifier|final
name|Integer
name|columnIndex
init|=
name|nameToIndex
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
decl_stmt|;
if|if
condition|(
name|projectMap
operator|.
name|containsKey
argument_list|(
name|columnIndex
argument_list|)
condition|)
block|{
specifier|final
name|RexNode
name|columnConstraint
init|=
name|projectMap
operator|.
name|get
argument_list|(
name|columnIndex
argument_list|)
decl_stmt|;
specifier|final
name|ValidationError
name|validationError
init|=
operator|new
name|ValidationError
argument_list|(
name|column
operator|.
name|right
argument_list|,
name|RESOURCE
operator|.
name|viewConstraintNotSatisfied
argument_list|(
name|columnName
argument_list|,
name|Util
operator|.
name|last
argument_list|(
name|validatorTable
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|validateValueAgainstConstraint
argument_list|(
name|column
operator|.
name|right
argument_list|,
name|columnConstraint
argument_list|,
name|validationError
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|checkFieldCount
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorTable
name|table
parameter_list|,
name|RelDataType
name|logicalSourceRowType
parameter_list|,
name|RelDataType
name|logicalTargetRowType
parameter_list|)
block|{
specifier|final
name|int
name|sourceFieldCount
init|=
name|logicalSourceRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|int
name|targetFieldCount
init|=
name|logicalTargetRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceFieldCount
operator|!=
name|targetFieldCount
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|unmatchInsertColumn
argument_list|(
name|targetFieldCount
argument_list|,
name|sourceFieldCount
argument_list|)
argument_list|)
throw|;
block|}
comment|// Ensure that non-nullable fields are targeted.
specifier|final
name|InitializerContext
name|rexBuilder
init|=
operator|new
name|InitializerContext
argument_list|()
block|{
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
operator|new
name|RexBuilder
argument_list|(
name|typeFactory
argument_list|)
return|;
block|}
block|}
decl_stmt|;
for|for
control|(
specifier|final
name|RelDataTypeField
name|field
range|:
name|table
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|field
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
specifier|final
name|RelDataTypeField
name|targetField
init|=
name|logicalTargetRowType
operator|.
name|getField
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetField
operator|==
literal|null
operator|&&
operator|!
name|table
operator|.
name|columnHasDefaultValue
argument_list|(
name|table
operator|.
name|getRowType
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|rexBuilder
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|columnNotNullable
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|protected
name|RelDataType
name|getLogicalTargetRowType
parameter_list|(
name|RelDataType
name|targetRowType
parameter_list|,
name|SqlInsert
name|insert
parameter_list|)
block|{
if|if
condition|(
name|insert
operator|.
name|getTargetColumnList
argument_list|()
operator|==
literal|null
operator|&&
name|conformance
operator|.
name|isInsertSubsetColumnsAllowed
argument_list|()
condition|)
block|{
comment|// Target an implicit subset of columns.
specifier|final
name|SqlNode
name|source
init|=
name|insert
operator|.
name|getSource
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|sourceRowType
init|=
name|getNamespace
argument_list|(
name|source
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|logicalSourceRowType
init|=
name|getLogicalSourceRowType
argument_list|(
name|sourceRowType
argument_list|,
name|insert
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|implicitTargetRowType
init|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|targetRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|logicalSourceRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|targetNamespace
init|=
name|getNamespace
argument_list|(
name|insert
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|,
name|implicitTargetRowType
argument_list|)
expr_stmt|;
return|return
name|implicitTargetRowType
return|;
block|}
else|else
block|{
comment|// Either the set of columns are explicitly targeted, or target the full
comment|// set of columns.
return|return
name|targetRowType
return|;
block|}
block|}
specifier|protected
name|RelDataType
name|getLogicalSourceRowType
parameter_list|(
name|RelDataType
name|sourceRowType
parameter_list|,
name|SqlInsert
name|insert
parameter_list|)
block|{
return|return
name|sourceRowType
return|;
block|}
specifier|protected
name|void
name|checkTypeAssignment
parameter_list|(
name|RelDataType
name|sourceRowType
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|,
specifier|final
name|SqlNode
name|query
parameter_list|)
block|{
comment|// NOTE jvs 23-Feb-2006: subclasses may allow for extra targets
comment|// representing system-maintained columns, so stop after all sources
comment|// matched
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|sourceFields
init|=
name|sourceRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|targetFields
init|=
name|targetRowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|sourceCount
init|=
name|sourceFields
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceCount
condition|;
operator|++
name|i
control|)
block|{
name|RelDataType
name|sourceType
init|=
name|sourceFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|RelDataType
name|targetType
init|=
name|targetFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|canAssignFrom
argument_list|(
name|targetType
argument_list|,
name|sourceType
argument_list|)
condition|)
block|{
comment|// FRG-255:  account for UPDATE rewrite; there's
comment|// probably a better way to do this.
name|int
name|iAdjusted
init|=
name|i
decl_stmt|;
if|if
condition|(
name|query
operator|instanceof
name|SqlUpdate
condition|)
block|{
name|int
name|nUpdateColumns
init|=
operator|(
operator|(
name|SqlUpdate
operator|)
name|query
operator|)
operator|.
name|getTargetColumnList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
assert|assert
name|sourceFields
operator|.
name|size
argument_list|()
operator|>=
name|nUpdateColumns
assert|;
name|iAdjusted
operator|-=
name|sourceFields
operator|.
name|size
argument_list|()
operator|-
name|nUpdateColumns
expr_stmt|;
block|}
name|SqlNode
name|node
init|=
name|getNthExpr
argument_list|(
name|query
argument_list|,
name|iAdjusted
argument_list|,
name|sourceCount
argument_list|)
decl_stmt|;
name|String
name|targetTypeString
decl_stmt|;
name|String
name|sourceTypeString
decl_stmt|;
if|if
condition|(
name|SqlTypeUtil
operator|.
name|areCharacterSetsMismatched
argument_list|(
name|sourceType
argument_list|,
name|targetType
argument_list|)
condition|)
block|{
name|sourceTypeString
operator|=
name|sourceType
operator|.
name|getFullTypeString
argument_list|()
expr_stmt|;
name|targetTypeString
operator|=
name|targetType
operator|.
name|getFullTypeString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sourceTypeString
operator|=
name|sourceType
operator|.
name|toString
argument_list|()
expr_stmt|;
name|targetTypeString
operator|=
name|targetType
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|typeNotAssignable
argument_list|(
name|targetFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|targetTypeString
argument_list|,
name|sourceFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|sourceTypeString
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Locates the n'th expression in an INSERT or UPDATE query.    *    * @param query       Query    * @param ordinal     Ordinal of expression    * @param sourceCount Number of expressions    * @return Ordinal'th expression, never null    */
specifier|private
name|SqlNode
name|getNthExpr
parameter_list|(
name|SqlNode
name|query
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|int
name|sourceCount
parameter_list|)
block|{
if|if
condition|(
name|query
operator|instanceof
name|SqlInsert
condition|)
block|{
name|SqlInsert
name|insert
init|=
operator|(
name|SqlInsert
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|insert
operator|.
name|getTargetColumnList
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|insert
operator|.
name|getTargetColumnList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getNthExpr
argument_list|(
name|insert
operator|.
name|getSource
argument_list|()
argument_list|,
name|ordinal
argument_list|,
name|sourceCount
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|query
operator|instanceof
name|SqlUpdate
condition|)
block|{
name|SqlUpdate
name|update
init|=
operator|(
name|SqlUpdate
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|update
operator|.
name|getTargetColumnList
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|update
operator|.
name|getTargetColumnList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
if|else if
condition|(
name|update
operator|.
name|getSourceExpressionList
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|update
operator|.
name|getSourceExpressionList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getNthExpr
argument_list|(
name|update
operator|.
name|getSourceSelect
argument_list|()
argument_list|,
name|ordinal
argument_list|,
name|sourceCount
argument_list|)
return|;
block|}
block|}
if|else if
condition|(
name|query
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|select
init|=
operator|(
name|SqlSelect
operator|)
name|query
decl_stmt|;
if|if
condition|(
name|select
operator|.
name|getSelectList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|sourceCount
condition|)
block|{
return|return
name|select
operator|.
name|getSelectList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|query
return|;
comment|// give up
block|}
block|}
else|else
block|{
return|return
name|query
return|;
comment|// give up
block|}
block|}
specifier|public
name|void
name|validateDelete
parameter_list|(
name|SqlDelete
name|call
parameter_list|)
block|{
specifier|final
name|SqlSelect
name|sqlSelect
init|=
name|call
operator|.
name|getSourceSelect
argument_list|()
decl_stmt|;
name|validateSelect
argument_list|(
name|sqlSelect
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorNamespace
name|targetNamespace
init|=
name|getNamespace
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
specifier|final
name|SqlValidatorTable
name|table
init|=
name|targetNamespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|validateAccess
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|SqlAccessEnum
operator|.
name|DELETE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateUpdate
parameter_list|(
name|SqlUpdate
name|call
parameter_list|)
block|{
specifier|final
name|SqlValidatorNamespace
name|targetNamespace
init|=
name|getNamespace
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
specifier|final
name|RelOptTable
name|relOptTable
init|=
name|SqlValidatorUtil
operator|.
name|getRelOptTable
argument_list|(
name|targetNamespace
argument_list|,
name|catalogReader
operator|.
name|unwrap
argument_list|(
name|Prepare
operator|.
name|CatalogReader
operator|.
name|class
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|SqlValidatorTable
name|table
init|=
name|relOptTable
operator|==
literal|null
condition|?
name|targetNamespace
operator|.
name|getTable
argument_list|()
else|:
name|relOptTable
operator|.
name|unwrap
argument_list|(
name|SqlValidatorTable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|targetRowType
init|=
name|createTargetRowType
argument_list|(
name|table
argument_list|,
name|call
operator|.
name|getTargetColumnList
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|SqlSelect
name|select
init|=
name|call
operator|.
name|getSourceSelect
argument_list|()
decl_stmt|;
name|validateSelect
argument_list|(
name|select
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|sourceRowType
init|=
name|getNamespace
argument_list|(
name|call
argument_list|)
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|checkTypeAssignment
argument_list|(
name|sourceRowType
argument_list|,
name|targetRowType
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|checkConstraint
argument_list|(
name|table
argument_list|,
name|call
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
name|validateAccess
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|SqlAccessEnum
operator|.
name|UPDATE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validateMerge
parameter_list|(
name|SqlMerge
name|call
parameter_list|)
block|{
name|SqlSelect
name|sqlSelect
init|=
name|call
operator|.
name|getSourceSelect
argument_list|()
decl_stmt|;
comment|// REVIEW zfong 5/25/06 - Does an actual type have to be passed into
comment|// validateSelect()?
comment|// REVIEW jvs 6-June-2006:  In general, passing unknownType like
comment|// this means we won't be able to correctly infer the types
comment|// for dynamic parameter markers (SET x = ?).  But
comment|// maybe validateUpdate and validateInsert below will do
comment|// the job?
comment|// REVIEW ksecretan 15-July-2011: They didn't get a chance to
comment|// since validateSelect() would bail.
comment|// Let's use the update/insert targetRowType when available.
name|IdentifierNamespace
name|targetNamespace
init|=
operator|(
name|IdentifierNamespace
operator|)
name|getNamespace
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|)
decl_stmt|;
name|validateNamespace
argument_list|(
name|targetNamespace
argument_list|,
name|unknownType
argument_list|)
expr_stmt|;
name|SqlValidatorTable
name|table
init|=
name|targetNamespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|validateAccess
argument_list|(
name|call
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|table
argument_list|,
name|SqlAccessEnum
operator|.
name|UPDATE
argument_list|)
expr_stmt|;
name|RelDataType
name|targetRowType
init|=
name|unknownType
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|getUpdateCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|targetRowType
operator|=
name|createTargetRowType
argument_list|(
name|table
argument_list|,
name|call
operator|.
name|getUpdateCall
argument_list|()
operator|.
name|getTargetColumnList
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|.
name|getInsertCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|targetRowType
operator|=
name|createTargetRowType
argument_list|(
name|table
argument_list|,
name|call
operator|.
name|getInsertCall
argument_list|()
operator|.
name|getTargetColumnList
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|validateSelect
argument_list|(
name|sqlSelect
argument_list|,
name|targetRowType
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|getUpdateCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|validateUpdate
argument_list|(
name|call
operator|.
name|getUpdateCall
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|.
name|getInsertCall
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|validateInsert
argument_list|(
name|call
operator|.
name|getInsertCall
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Validates access to a table.    *    * @param table          Table    * @param requiredAccess Access requested on table    */
specifier|private
name|void
name|validateAccess
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|SqlValidatorTable
name|table
parameter_list|,
name|SqlAccessEnum
name|requiredAccess
parameter_list|)
block|{
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
name|SqlAccessType
name|access
init|=
name|table
operator|.
name|getAllowedAccess
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|access
operator|.
name|allowsAccess
argument_list|(
name|requiredAccess
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|accessNotAllowed
argument_list|(
name|requiredAccess
operator|.
name|name
argument_list|()
argument_list|,
name|table
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Validates a VALUES clause.    *    * @param node          Values clause    * @param targetRowType Row type which expression must conform to    * @param scope         Scope within which clause occurs    */
specifier|protected
name|void
name|validateValues
parameter_list|(
name|SqlCall
name|node
parameter_list|,
name|RelDataType
name|targetRowType
parameter_list|,
specifier|final
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
assert|assert
name|node
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|VALUES
assert|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|node
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|operands
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|operand
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
operator|)
condition|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
literal|"Values function where operands are scalars"
argument_list|)
throw|;
block|}
name|SqlCall
name|rowConstructor
init|=
operator|(
name|SqlCall
operator|)
name|operand
decl_stmt|;
if|if
condition|(
name|conformance
operator|.
name|isInsertSubsetColumnsAllowed
argument_list|()
operator|&&
name|targetRowType
operator|.
name|isStruct
argument_list|()
operator|&&
name|rowConstructor
operator|.
name|operandCount
argument_list|()
operator|<
name|targetRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
name|targetRowType
operator|=
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|targetRowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|rowConstructor
operator|.
name|operandCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|targetRowType
operator|.
name|isStruct
argument_list|()
operator|&&
name|rowConstructor
operator|.
name|operandCount
argument_list|()
operator|!=
name|targetRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
return|return;
block|}
name|inferUnknownTypes
argument_list|(
name|targetRowType
argument_list|,
name|scope
argument_list|,
name|rowConstructor
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetRowType
operator|.
name|isStruct
argument_list|()
condition|)
block|{
for|for
control|(
name|Pair
argument_list|<
name|SqlNode
argument_list|,
name|RelDataTypeField
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|rowConstructor
operator|.
name|getOperandList
argument_list|()
argument_list|,
name|targetRowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|pair
operator|.
name|right
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
operator|&&
name|SqlUtil
operator|.
name|isNullLiteral
argument_list|(
name|pair
operator|.
name|left
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|columnNotNullable
argument_list|(
name|pair
operator|.
name|right
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
for|for
control|(
name|SqlNode
name|operand
range|:
name|operands
control|)
block|{
name|operand
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
comment|// validate that all row types have the same number of columns
comment|//  and that expressions in each column are compatible.
comment|// A values expression is turned into something that looks like
comment|// ROW(type00, type01,...), ROW(type11,...),...
specifier|final
name|int
name|rowCount
init|=
name|operands
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowCount
operator|>=
literal|2
condition|)
block|{
name|SqlCall
name|firstRow
init|=
operator|(
name|SqlCall
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|int
name|columnCount
init|=
name|firstRow
operator|.
name|operandCount
argument_list|()
decl_stmt|;
comment|// 1. check that all rows have the same cols length
for|for
control|(
name|SqlNode
name|operand
range|:
name|operands
control|)
block|{
name|SqlCall
name|thisRow
init|=
operator|(
name|SqlCall
operator|)
name|operand
decl_stmt|;
if|if
condition|(
name|columnCount
operator|!=
name|thisRow
operator|.
name|operandCount
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|incompatibleValueType
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VALUES
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// 2. check if types at i:th position in each row are compatible
for|for
control|(
name|int
name|col
init|=
literal|0
init|;
name|col
operator|<
name|columnCount
condition|;
name|col
operator|++
control|)
block|{
specifier|final
name|int
name|c
init|=
name|col
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|leastRestrictive
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|row
parameter_list|)
block|{
name|SqlCall
name|thisRow
init|=
operator|(
name|SqlCall
operator|)
name|operands
operator|.
name|get
argument_list|(
name|row
argument_list|)
decl_stmt|;
return|return
name|deriveType
argument_list|(
name|scope
argument_list|,
name|thisRow
operator|.
name|operand
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rowCount
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|type
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|node
argument_list|,
name|RESOURCE
operator|.
name|incompatibleValueType
argument_list|(
name|SqlStdOperatorTable
operator|.
name|VALUES
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|public
name|void
name|validateDataType
parameter_list|(
name|SqlDataTypeSpec
name|dataType
parameter_list|)
block|{
block|}
specifier|public
name|void
name|validateDynamicParam
parameter_list|(
name|SqlDynamicParam
name|dynamicParam
parameter_list|)
block|{
block|}
comment|/**    * Throws a validator exception with access to the validator context.    * The exception is determined when an instance is created.    */
specifier|private
class|class
name|ValidationError
implements|implements
name|Supplier
argument_list|<
name|CalciteContextException
argument_list|>
block|{
specifier|private
specifier|final
name|SqlNode
name|sqlNode
decl_stmt|;
specifier|private
specifier|final
name|Resources
operator|.
name|ExInst
argument_list|<
name|SqlValidatorException
argument_list|>
name|validatorException
decl_stmt|;
name|ValidationError
parameter_list|(
name|SqlNode
name|sqlNode
parameter_list|,
name|Resources
operator|.
name|ExInst
argument_list|<
name|SqlValidatorException
argument_list|>
name|validatorException
parameter_list|)
block|{
name|this
operator|.
name|sqlNode
operator|=
name|sqlNode
expr_stmt|;
name|this
operator|.
name|validatorException
operator|=
name|validatorException
expr_stmt|;
block|}
specifier|public
name|CalciteContextException
name|get
parameter_list|()
block|{
return|return
name|newValidationError
argument_list|(
name|sqlNode
argument_list|,
name|validatorException
argument_list|)
return|;
block|}
block|}
comment|/**    * Throws a validator exception with access to the validator context.    * The exception is determined when the function is applied.    */
class|class
name|ValidationErrorFunction
implements|implements
name|Function2
argument_list|<
name|SqlNode
argument_list|,
name|Resources
operator|.
name|ExInst
argument_list|<
name|SqlValidatorException
argument_list|>
argument_list|,
name|CalciteContextException
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|CalciteContextException
name|apply
parameter_list|(
name|SqlNode
name|v0
parameter_list|,
name|Resources
operator|.
name|ExInst
argument_list|<
name|SqlValidatorException
argument_list|>
name|v1
parameter_list|)
block|{
return|return
name|newValidationError
argument_list|(
name|v0
argument_list|,
name|v1
argument_list|)
return|;
block|}
block|}
specifier|public
name|ValidationErrorFunction
name|getValidationErrorFunction
parameter_list|()
block|{
return|return
name|validationErrorFunction
return|;
block|}
specifier|public
name|CalciteContextException
name|newValidationError
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|Resources
operator|.
name|ExInst
argument_list|<
name|SqlValidatorException
argument_list|>
name|e
parameter_list|)
block|{
assert|assert
name|node
operator|!=
literal|null
assert|;
specifier|final
name|SqlParserPos
name|pos
init|=
name|node
operator|.
name|getParserPosition
argument_list|()
decl_stmt|;
return|return
name|SqlUtil
operator|.
name|newContextException
argument_list|(
name|pos
argument_list|,
name|e
argument_list|)
return|;
block|}
specifier|protected
name|SqlWindow
name|getWindowByName
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|SqlWindow
name|window
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|isSimple
argument_list|()
condition|)
block|{
specifier|final
name|String
name|name
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|window
operator|=
name|scope
operator|.
name|lookupWindow
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|window
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|windowNotFound
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|window
return|;
block|}
specifier|public
name|SqlWindow
name|resolveWindow
parameter_list|(
name|SqlNode
name|windowOrRef
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|boolean
name|populateBounds
parameter_list|)
block|{
name|SqlWindow
name|window
decl_stmt|;
if|if
condition|(
name|windowOrRef
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|window
operator|=
name|getWindowByName
argument_list|(
operator|(
name|SqlIdentifier
operator|)
name|windowOrRef
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|window
operator|=
operator|(
name|SqlWindow
operator|)
name|windowOrRef
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|SqlIdentifier
name|refId
init|=
name|window
operator|.
name|getRefName
argument_list|()
decl_stmt|;
if|if
condition|(
name|refId
operator|==
literal|null
condition|)
block|{
break|break;
block|}
specifier|final
name|String
name|refName
init|=
name|refId
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|SqlWindow
name|refWindow
init|=
name|scope
operator|.
name|lookupWindow
argument_list|(
name|refName
argument_list|)
decl_stmt|;
if|if
condition|(
name|refWindow
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|refId
argument_list|,
name|RESOURCE
operator|.
name|windowNotFound
argument_list|(
name|refName
argument_list|)
argument_list|)
throw|;
block|}
name|window
operator|=
name|window
operator|.
name|overlay
argument_list|(
name|refWindow
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|populateBounds
condition|)
block|{
name|window
operator|.
name|populateBounds
argument_list|()
expr_stmt|;
block|}
return|return
name|window
return|;
block|}
specifier|public
name|SqlNode
name|getOriginal
parameter_list|(
name|SqlNode
name|expr
parameter_list|)
block|{
name|SqlNode
name|original
init|=
name|originalExprs
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|original
operator|==
literal|null
condition|)
block|{
name|original
operator|=
name|expr
expr_stmt|;
block|}
return|return
name|original
return|;
block|}
specifier|public
name|void
name|setOriginal
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|SqlNode
name|original
parameter_list|)
block|{
comment|// Don't overwrite the original original.
if|if
condition|(
name|originalExprs
operator|.
name|get
argument_list|(
name|expr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|originalExprs
operator|.
name|put
argument_list|(
name|expr
argument_list|,
name|original
argument_list|)
expr_stmt|;
block|}
block|}
name|SqlValidatorNamespace
name|lookupFieldNamespace
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|String
name|name
parameter_list|)
block|{
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|RelDataTypeField
name|field
init|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|name
argument_list|)
decl_stmt|;
return|return
operator|new
name|FieldNamespace
argument_list|(
name|this
argument_list|,
name|field
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|validateWindow
parameter_list|(
name|SqlNode
name|windowOrId
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Enable nested aggregates with window aggregates (OVER operator)
name|inWindow
operator|=
literal|true
expr_stmt|;
specifier|final
name|SqlWindow
name|targetWindow
decl_stmt|;
switch|switch
condition|(
name|windowOrId
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|IDENTIFIER
case|:
comment|// Just verify the window exists in this query.  It will validate
comment|// when the definition is processed
name|targetWindow
operator|=
name|getWindowByName
argument_list|(
operator|(
name|SqlIdentifier
operator|)
name|windowOrId
argument_list|,
name|scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|WINDOW
case|:
name|targetWindow
operator|=
operator|(
name|SqlWindow
operator|)
name|windowOrId
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|windowOrId
operator|.
name|getKind
argument_list|()
argument_list|)
throw|;
block|}
assert|assert
name|targetWindow
operator|.
name|getWindowCall
argument_list|()
operator|==
literal|null
assert|;
name|targetWindow
operator|.
name|setWindowCall
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|targetWindow
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|targetWindow
operator|.
name|setWindowCall
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|call
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|validateAggregateParams
argument_list|(
name|call
argument_list|,
literal|null
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|// Disable nested aggregates post validation
name|inWindow
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|validateMatchRecognize
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlMatchRecognize
name|matchRecognize
init|=
operator|(
name|SqlMatchRecognize
operator|)
name|call
decl_stmt|;
specifier|final
name|MatchRecognizeScope
name|scope
init|=
operator|(
name|MatchRecognizeScope
operator|)
name|getMatchRecognizeScope
argument_list|(
name|matchRecognize
argument_list|)
decl_stmt|;
specifier|final
name|MatchRecognizeNamespace
name|ns
init|=
name|getNamespace
argument_list|(
name|call
argument_list|)
operator|.
name|unwrap
argument_list|(
name|MatchRecognizeNamespace
operator|.
name|class
argument_list|)
decl_stmt|;
assert|assert
name|ns
operator|.
name|rowType
operator|==
literal|null
assert|;
comment|// rows per match
specifier|final
name|SqlLiteral
name|rowsPerMatch
init|=
name|matchRecognize
operator|.
name|getRowsPerMatch
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|allRows
init|=
name|rowsPerMatch
operator|!=
literal|null
operator|&&
name|rowsPerMatch
operator|.
name|getValue
argument_list|()
operator|==
name|SqlMatchRecognize
operator|.
name|RowsPerMatchOption
operator|.
name|ALL_ROWS
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|Builder
name|typeBuilder
init|=
name|typeFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
comment|// parse PARTITION BY column
name|SqlNodeList
name|partitionBy
init|=
name|matchRecognize
operator|.
name|getPartitionList
argument_list|()
decl_stmt|;
if|if
condition|(
name|partitionBy
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|partitionBy
control|)
block|{
name|SqlIdentifier
name|identifier
init|=
operator|(
name|SqlIdentifier
operator|)
name|node
decl_stmt|;
name|identifier
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|identifier
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|typeBuilder
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|// parse ORDER BY column
name|SqlNodeList
name|orderBy
init|=
name|matchRecognize
operator|.
name|getOrderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|orderBy
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|orderBy
control|)
block|{
name|node
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|SqlIdentifier
name|identifier
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|SqlBasicCall
condition|)
block|{
name|identifier
operator|=
operator|(
name|SqlIdentifier
operator|)
operator|(
operator|(
name|SqlBasicCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|identifier
operator|=
operator|(
name|SqlIdentifier
operator|)
name|node
expr_stmt|;
block|}
if|if
condition|(
name|allRows
condition|)
block|{
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|identifier
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|typeBuilder
operator|.
name|nameExists
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|allRows
condition|)
block|{
specifier|final
name|SqlValidatorNamespace
name|sqlNs
init|=
name|getNamespace
argument_list|(
name|matchRecognize
operator|.
name|getTableRef
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|inputDataType
init|=
name|sqlNs
operator|.
name|getRowType
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|fs
range|:
name|inputDataType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|typeBuilder
operator|.
name|nameExists
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// retrieve pattern variables used in pattern and subset
name|SqlNode
name|pattern
init|=
name|matchRecognize
operator|.
name|getPattern
argument_list|()
decl_stmt|;
name|PatternVarVisitor
name|visitor
init|=
operator|new
name|PatternVarVisitor
argument_list|(
name|scope
argument_list|)
decl_stmt|;
name|pattern
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
name|SqlLiteral
name|interval
init|=
name|matchRecognize
operator|.
name|getInterval
argument_list|()
decl_stmt|;
if|if
condition|(
name|interval
operator|!=
literal|null
condition|)
block|{
name|interval
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|SqlIntervalLiteral
operator|)
name|interval
operator|)
operator|.
name|signum
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|interval
argument_list|,
name|RESOURCE
operator|.
name|intervalMustBeNonNegative
argument_list|(
name|interval
operator|.
name|toValue
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|orderBy
operator|==
literal|null
operator|||
name|orderBy
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|interval
argument_list|,
name|RESOURCE
operator|.
name|cannotUseWithinWithoutOrderBy
argument_list|()
argument_list|)
throw|;
block|}
name|SqlNode
name|firstOrderByColumn
init|=
name|orderBy
operator|.
name|getList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SqlIdentifier
name|identifier
decl_stmt|;
if|if
condition|(
name|firstOrderByColumn
operator|instanceof
name|SqlBasicCall
condition|)
block|{
name|identifier
operator|=
operator|(
name|SqlIdentifier
operator|)
operator|(
operator|(
name|SqlBasicCall
operator|)
name|firstOrderByColumn
operator|)
operator|.
name|getOperands
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|identifier
operator|=
operator|(
name|SqlIdentifier
operator|)
name|firstOrderByColumn
expr_stmt|;
block|}
name|RelDataType
name|firstOrderByColumnType
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|identifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstOrderByColumnType
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|TIMESTAMP
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|interval
argument_list|,
name|RESOURCE
operator|.
name|firstColumnOfOrderByMustBeTimestamp
argument_list|()
argument_list|)
throw|;
block|}
name|SqlNode
name|expand
init|=
name|expand
argument_list|(
name|interval
argument_list|,
name|scope
argument_list|)
decl_stmt|;
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|expand
argument_list|)
decl_stmt|;
name|setValidatedNodeType
argument_list|(
name|interval
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|validateDefinitions
argument_list|(
name|matchRecognize
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|SqlNodeList
name|subsets
init|=
name|matchRecognize
operator|.
name|getSubsetList
argument_list|()
decl_stmt|;
if|if
condition|(
name|subsets
operator|!=
literal|null
operator|&&
name|subsets
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|subsets
control|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|String
name|leftString
init|=
operator|(
operator|(
name|SqlIdentifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getSimple
argument_list|()
decl_stmt|;
if|if
condition|(
name|scope
operator|.
name|getPatternVars
argument_list|()
operator|.
name|contains
argument_list|(
name|leftString
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|RESOURCE
operator|.
name|patternVarAlreadyDefined
argument_list|(
name|leftString
argument_list|)
argument_list|)
throw|;
block|}
name|scope
operator|.
name|addPatternVar
argument_list|(
name|leftString
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|right
range|:
operator|(
name|SqlNodeList
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
control|)
block|{
name|SqlIdentifier
name|id
init|=
operator|(
name|SqlIdentifier
operator|)
name|right
decl_stmt|;
if|if
condition|(
operator|!
name|scope
operator|.
name|getPatternVars
argument_list|()
operator|.
name|contains
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|unknownPattern
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|scope
operator|.
name|addPatternVar
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// validate AFTER ... SKIP TO
specifier|final
name|SqlNode
name|skipTo
init|=
name|matchRecognize
operator|.
name|getAfter
argument_list|()
decl_stmt|;
if|if
condition|(
name|skipTo
operator|instanceof
name|SqlCall
condition|)
block|{
specifier|final
name|SqlCall
name|skipToCall
init|=
operator|(
name|SqlCall
operator|)
name|skipTo
decl_stmt|;
specifier|final
name|SqlIdentifier
name|id
init|=
name|skipToCall
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scope
operator|.
name|getPatternVars
argument_list|()
operator|.
name|contains
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|unknownPattern
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|measureColumns
init|=
name|validateMeasure
argument_list|(
name|matchRecognize
argument_list|,
name|scope
argument_list|,
name|allRows
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|c
range|:
name|measureColumns
control|)
block|{
if|if
condition|(
operator|!
name|typeBuilder
operator|.
name|nameExists
argument_list|(
name|c
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|typeBuilder
operator|.
name|add
argument_list|(
name|c
operator|.
name|getKey
argument_list|()
argument_list|,
name|c
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RelDataType
name|rowType
init|=
name|typeBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|matchRecognize
operator|.
name|getMeasureList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|ns
operator|.
name|setType
argument_list|(
name|getNamespace
argument_list|(
name|matchRecognize
operator|.
name|getTableRef
argument_list|()
argument_list|)
operator|.
name|getRowType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|.
name|setType
argument_list|(
name|rowType
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|validateMeasure
parameter_list|(
name|SqlMatchRecognize
name|mr
parameter_list|,
name|MatchRecognizeScope
name|scope
parameter_list|,
name|boolean
name|allRows
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|sqlNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|SqlNodeList
name|measures
init|=
name|mr
operator|.
name|getMeasureList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|measure
range|:
name|measures
control|)
block|{
assert|assert
name|measure
operator|instanceof
name|SqlCall
assert|;
specifier|final
name|String
name|alias
init|=
name|deriveAlias
argument_list|(
name|measure
argument_list|,
name|aliases
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|aliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|SqlNode
name|expand
init|=
name|expand
argument_list|(
name|measure
argument_list|,
name|scope
argument_list|)
decl_stmt|;
name|expand
operator|=
name|navigationInMeasure
argument_list|(
name|expand
argument_list|,
name|allRows
argument_list|)
expr_stmt|;
name|setOriginal
argument_list|(
name|expand
argument_list|,
name|measure
argument_list|)
expr_stmt|;
name|inferUnknownTypes
argument_list|(
name|unknownType
argument_list|,
name|scope
argument_list|,
name|expand
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|expand
argument_list|)
decl_stmt|;
name|setValidatedNodeType
argument_list|(
name|measure
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|sqlNodes
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|expand
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SqlNodeList
name|list
init|=
operator|new
name|SqlNodeList
argument_list|(
name|sqlNodes
argument_list|,
name|measures
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
name|inferUnknownTypes
argument_list|(
name|unknownType
argument_list|,
name|scope
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|list
control|)
block|{
name|validateExpr
argument_list|(
name|node
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
name|mr
operator|.
name|setOperand
argument_list|(
name|SqlMatchRecognize
operator|.
name|OPERAND_MEASURES
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|fields
return|;
block|}
specifier|private
name|SqlNode
name|navigationInMeasure
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|allRows
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|prefix
init|=
name|node
operator|.
name|accept
argument_list|(
operator|new
name|PatternValidator
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|ops
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
specifier|final
name|SqlOperator
name|defaultOp
init|=
name|allRows
condition|?
name|SqlStdOperatorTable
operator|.
name|RUNNING
else|:
name|SqlStdOperatorTable
operator|.
name|FINAL
decl_stmt|;
specifier|final
name|SqlNode
name|op0
init|=
name|ops
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isRunningOrFinal
argument_list|(
name|op0
operator|.
name|getKind
argument_list|()
argument_list|)
operator|||
operator|!
name|allRows
operator|&&
name|op0
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|RUNNING
condition|)
block|{
name|SqlNode
name|newNode
init|=
name|defaultOp
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|op0
argument_list|)
decl_stmt|;
name|node
operator|=
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|newNode
argument_list|,
name|ops
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
operator|new
name|NavigationExpander
argument_list|()
operator|.
name|go
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|private
name|void
name|validateDefinitions
parameter_list|(
name|SqlMatchRecognize
name|mr
parameter_list|,
name|MatchRecognizeScope
name|scope
parameter_list|)
block|{
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
operator|.
name|isCaseSensitive
argument_list|()
condition|?
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
else|:
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
decl_stmt|;
for|for
control|(
name|SqlNode
name|item
range|:
name|mr
operator|.
name|getPatternDefList
argument_list|()
operator|.
name|getList
argument_list|()
control|)
block|{
specifier|final
name|String
name|alias
init|=
name|alias
argument_list|(
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|aliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|item
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternVarAlreadyDefined
argument_list|(
name|alias
argument_list|)
argument_list|)
throw|;
block|}
name|scope
operator|.
name|addPatternVar
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|sqlNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|item
range|:
name|mr
operator|.
name|getPatternDefList
argument_list|()
operator|.
name|getList
argument_list|()
control|)
block|{
specifier|final
name|String
name|alias
init|=
name|alias
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|SqlNode
name|expand
init|=
name|expand
argument_list|(
name|item
argument_list|,
name|scope
argument_list|)
decl_stmt|;
name|expand
operator|=
name|navigationInDefine
argument_list|(
name|expand
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|setOriginal
argument_list|(
name|expand
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|inferUnknownTypes
argument_list|(
name|booleanType
argument_list|,
name|scope
argument_list|,
name|expand
argument_list|)
expr_stmt|;
name|expand
operator|.
name|validate
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|// Some extra work need required here.
comment|// In PREV, NEXT, FINAL and LAST, only one pattern variable is allowed.
name|sqlNodes
operator|.
name|add
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|expand
argument_list|,
operator|new
name|SqlIdentifier
argument_list|(
name|alias
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|deriveType
argument_list|(
name|scope
argument_list|,
name|expand
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SqlTypeUtil
operator|.
name|inBooleanFamily
argument_list|(
name|type
argument_list|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|expand
argument_list|,
name|RESOURCE
operator|.
name|condMustBeBoolean
argument_list|(
literal|"DEFINE"
argument_list|)
argument_list|)
throw|;
block|}
name|setValidatedNodeType
argument_list|(
name|item
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|SqlNodeList
name|list
init|=
operator|new
name|SqlNodeList
argument_list|(
name|sqlNodes
argument_list|,
name|mr
operator|.
name|getPatternDefList
argument_list|()
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
name|inferUnknownTypes
argument_list|(
name|unknownType
argument_list|,
name|scope
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|list
control|)
block|{
name|validateExpr
argument_list|(
name|node
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
name|mr
operator|.
name|setOperand
argument_list|(
name|SqlMatchRecognize
operator|.
name|OPERAND_PATTERN_DEFINES
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the alias of a "expr AS alias" expression. */
specifier|private
specifier|static
name|String
name|alias
parameter_list|(
name|SqlNode
name|item
parameter_list|)
block|{
assert|assert
name|item
operator|instanceof
name|SqlCall
assert|;
assert|assert
name|item
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|AS
assert|;
specifier|final
name|SqlIdentifier
name|identifier
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|item
operator|)
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
decl_stmt|;
return|return
name|identifier
operator|.
name|getSimple
argument_list|()
return|;
block|}
comment|/** Checks that all pattern variables within a function are the same,    * and canonizes expressions such as {@code PREV(B.price)} to    * {@code LAST(B.price, 0)}. */
specifier|private
name|SqlNode
name|navigationInDefine
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|String
name|alpha
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|prefix
init|=
name|node
operator|.
name|accept
argument_list|(
operator|new
name|PatternValidator
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|Util
operator|.
name|discard
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|node
operator|=
operator|new
name|NavigationExpander
argument_list|()
operator|.
name|go
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
operator|new
name|NavigationReplacer
argument_list|(
name|alpha
argument_list|)
operator|.
name|go
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|public
name|void
name|validateAggregateParams
parameter_list|(
name|SqlCall
name|aggCall
parameter_list|,
name|SqlNode
name|filter
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
comment|// For "agg(expr)", expr cannot itself contain aggregate function
comment|// invocations.  For example, "SUM(2 * MAX(x))" is illegal; when
comment|// we see it, we'll report the error for the SUM (not the MAX).
comment|// For more than one level of nesting, the error which results
comment|// depends on the traversal order for validation.
comment|//
comment|// For a windowed aggregate "agg(expr)", expr can contain an aggregate
comment|// function. For example,
comment|//   SELECT AVG(2 * MAX(x)) OVER (PARTITION BY y)
comment|//   FROM t
comment|//   GROUP BY y
comment|// is legal. Only one level of nesting is allowed since non-windowed
comment|// aggregates cannot nest aggregates.
comment|// Store nesting level of each aggregate. If an aggregate is found at an invalid
comment|// nesting level, throw an assert.
specifier|final
name|AggFinder
name|a
decl_stmt|;
if|if
condition|(
name|inWindow
condition|)
block|{
name|a
operator|=
name|overFinder
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|aggOrOverFinder
expr_stmt|;
block|}
for|for
control|(
name|SqlNode
name|param
range|:
name|aggCall
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|a
operator|.
name|findAgg
argument_list|(
name|param
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|aggCall
argument_list|,
name|RESOURCE
operator|.
name|nestedAggIllegal
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|a
operator|.
name|findAgg
argument_list|(
name|filter
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|filter
argument_list|,
name|RESOURCE
operator|.
name|aggregateInFilterIllegal
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|void
name|validateCall
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|call
operator|.
name|operandCount
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|operator
operator|.
name|getSyntax
argument_list|()
operator|==
name|SqlSyntax
operator|.
name|FUNCTION_ID
operator|)
operator|&&
operator|!
name|call
operator|.
name|isExpanded
argument_list|()
operator|&&
operator|!
name|conformance
operator|.
name|allowNiladicParentheses
argument_list|()
condition|)
block|{
comment|// For example, "LOCALTIME()" is illegal. (It should be
comment|// "LOCALTIME", which would have been handled as a
comment|// SqlIdentifier.)
throw|throw
name|handleUnresolvedFunction
argument_list|(
name|call
argument_list|,
operator|(
name|SqlFunction
operator|)
name|operator
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RelDataType
operator|>
name|of
argument_list|()
argument_list|,
literal|null
argument_list|)
throw|;
block|}
name|SqlValidatorScope
name|operandScope
init|=
name|scope
operator|.
name|getOperandScope
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|operator
operator|instanceof
name|SqlFunction
operator|&&
operator|(
operator|(
name|SqlFunction
operator|)
name|operator
operator|)
operator|.
name|getFunctionType
argument_list|()
operator|==
name|SqlFunctionCategory
operator|.
name|MATCH_RECOGNIZE
operator|&&
operator|!
operator|(
name|operandScope
operator|instanceof
name|MatchRecognizeScope
operator|)
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|functionMatchRecognizeOnly
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// Delegate validation to the operator.
name|operator
operator|.
name|validateCall
argument_list|(
name|call
argument_list|,
name|this
argument_list|,
name|scope
argument_list|,
name|operandScope
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validates that a particular feature is enabled. By default, all features    * are enabled; subclasses may override this method to be more    * discriminating.    *    * @param feature feature being used, represented as a resource instance    * @param context parser position context for error reporting, or null if    */
specifier|protected
name|void
name|validateFeature
parameter_list|(
name|Feature
name|feature
parameter_list|,
name|SqlParserPos
name|context
parameter_list|)
block|{
comment|// By default, do nothing except to verify that the resource
comment|// represents a real feature definition.
assert|assert
name|feature
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
literal|"FeatureDefinition"
argument_list|)
operator|!=
literal|null
assert|;
block|}
specifier|public
name|SqlNode
name|expand
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
specifier|final
name|Expander
name|expander
init|=
operator|new
name|Expander
argument_list|(
name|this
argument_list|,
name|scope
argument_list|)
decl_stmt|;
name|SqlNode
name|newExpr
init|=
name|expr
operator|.
name|accept
argument_list|(
name|expander
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
name|newExpr
condition|)
block|{
name|setOriginal
argument_list|(
name|newExpr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|newExpr
return|;
block|}
specifier|public
name|SqlNode
name|expandGroupByOrHavingExpr
parameter_list|(
name|SqlNode
name|expr
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|boolean
name|havingExpression
parameter_list|)
block|{
specifier|final
name|Expander
name|expander
init|=
operator|new
name|ExtendedExpander
argument_list|(
name|this
argument_list|,
name|scope
argument_list|,
name|select
argument_list|,
name|expr
argument_list|,
name|havingExpression
argument_list|)
decl_stmt|;
name|SqlNode
name|newExpr
init|=
name|expr
operator|.
name|accept
argument_list|(
name|expander
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
name|newExpr
condition|)
block|{
name|setOriginal
argument_list|(
name|newExpr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|newExpr
return|;
block|}
specifier|public
name|boolean
name|isSystemField
parameter_list|(
name|RelDataTypeField
name|field
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|getFieldOrigins
parameter_list|(
name|SqlNode
name|sqlQuery
parameter_list|)
block|{
if|if
condition|(
name|sqlQuery
operator|instanceof
name|SqlExplain
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
specifier|final
name|RelDataType
name|rowType
init|=
name|getValidatedNodeType
argument_list|(
name|sqlQuery
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sqlQuery
operator|.
name|isA
argument_list|(
name|SqlKind
operator|.
name|QUERY
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|nCopies
argument_list|(
name|fieldCount
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldCount
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|getFieldOrigin
argument_list|(
name|sqlQuery
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ImmutableNullableList
operator|.
name|copyOf
argument_list|(
name|list
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getFieldOrigin
parameter_list|(
name|SqlNode
name|sqlQuery
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|sqlQuery
operator|instanceof
name|SqlSelect
condition|)
block|{
name|SqlSelect
name|sqlSelect
init|=
operator|(
name|SqlSelect
operator|)
name|sqlQuery
decl_stmt|;
specifier|final
name|SelectScope
name|scope
init|=
name|getRawSelectScope
argument_list|(
name|sqlSelect
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|selectList
init|=
name|scope
operator|.
name|getExpandedSelectList
argument_list|()
decl_stmt|;
specifier|final
name|SqlNode
name|selectItem
init|=
name|stripAs
argument_list|(
name|selectList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectItem
operator|instanceof
name|SqlIdentifier
condition|)
block|{
specifier|final
name|SqlQualified
name|qualified
init|=
name|scope
operator|.
name|fullyQualify
argument_list|(
operator|(
name|SqlIdentifier
operator|)
name|selectItem
argument_list|)
decl_stmt|;
name|SqlValidatorNamespace
name|namespace
init|=
name|qualified
operator|.
name|namespace
decl_stmt|;
specifier|final
name|SqlValidatorTable
name|table
init|=
name|namespace
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|table
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|origin
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|table
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|qualified
operator|.
name|suffix
argument_list|()
control|)
block|{
name|namespace
operator|=
name|namespace
operator|.
name|lookupChild
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|namespace
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|origin
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|origin
return|;
block|}
return|return
literal|null
return|;
block|}
if|else if
condition|(
name|sqlQuery
operator|instanceof
name|SqlOrderBy
condition|)
block|{
return|return
name|getFieldOrigin
argument_list|(
operator|(
operator|(
name|SqlOrderBy
operator|)
name|sqlQuery
operator|)
operator|.
name|query
argument_list|,
name|i
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|RelDataType
name|getParameterRowType
parameter_list|(
name|SqlNode
name|sqlQuery
parameter_list|)
block|{
comment|// NOTE: We assume that bind variables occur in depth-first tree
comment|// traversal in the same order that they occurred in the SQL text.
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|types
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|sqlQuery
operator|.
name|accept
argument_list|(
operator|new
name|SqlShuttle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
name|RelDataType
name|type
init|=
name|getValidatedNodeType
argument_list|(
name|param
argument_list|)
decl_stmt|;
name|types
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|param
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|typeFactory
operator|.
name|createStructType
argument_list|(
name|types
argument_list|,
operator|new
name|AbstractList
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
literal|"?"
operator|+
name|index
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|types
operator|.
name|size
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
name|void
name|validateColumnListParams
parameter_list|(
name|SqlFunction
name|function
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|private
specifier|static
name|boolean
name|isPhysicalNavigation
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
return|return
name|kind
operator|==
name|SqlKind
operator|.
name|PREV
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|NEXT
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isLogicalNavigation
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
return|return
name|kind
operator|==
name|SqlKind
operator|.
name|FIRST
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|LAST
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isAggregation
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
return|return
name|kind
operator|==
name|SqlKind
operator|.
name|SUM
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|SUM0
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|AVG
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|COUNT
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|MAX
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|MIN
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isRunningOrFinal
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
return|return
name|kind
operator|==
name|SqlKind
operator|.
name|RUNNING
operator|||
name|kind
operator|==
name|SqlKind
operator|.
name|FINAL
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isSingleVarRequired
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
return|return
name|isPhysicalNavigation
argument_list|(
name|kind
argument_list|)
operator|||
name|isLogicalNavigation
argument_list|(
name|kind
argument_list|)
operator|||
name|isAggregation
argument_list|(
name|kind
argument_list|)
return|;
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/**    * Common base class for DML statement namespaces.    */
specifier|public
specifier|static
class|class
name|DmlNamespace
extends|extends
name|IdentifierNamespace
block|{
specifier|protected
name|DmlNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlNode
name|id
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|SqlValidatorScope
name|parentScope
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|id
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Namespace for an INSERT statement.    */
specifier|private
specifier|static
class|class
name|InsertNamespace
extends|extends
name|DmlNamespace
block|{
specifier|private
specifier|final
name|SqlInsert
name|node
decl_stmt|;
name|InsertNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlInsert
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|SqlValidatorScope
name|parentScope
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|node
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SqlInsert
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * Namespace for an UPDATE statement.    */
specifier|private
specifier|static
class|class
name|UpdateNamespace
extends|extends
name|DmlNamespace
block|{
specifier|private
specifier|final
name|SqlUpdate
name|node
decl_stmt|;
name|UpdateNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlUpdate
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|SqlValidatorScope
name|parentScope
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|node
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SqlUpdate
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * Namespace for a DELETE statement.    */
specifier|private
specifier|static
class|class
name|DeleteNamespace
extends|extends
name|DmlNamespace
block|{
specifier|private
specifier|final
name|SqlDelete
name|node
decl_stmt|;
name|DeleteNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlDelete
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|SqlValidatorScope
name|parentScope
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|node
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SqlDelete
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * Namespace for a MERGE statement.    */
specifier|private
specifier|static
class|class
name|MergeNamespace
extends|extends
name|DmlNamespace
block|{
specifier|private
specifier|final
name|SqlMerge
name|node
decl_stmt|;
name|MergeNamespace
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlMerge
name|node
parameter_list|,
name|SqlNode
name|enclosingNode
parameter_list|,
name|SqlValidatorScope
name|parentScope
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|node
operator|.
name|getTargetTable
argument_list|()
argument_list|,
name|enclosingNode
argument_list|,
name|parentScope
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
specifier|public
name|SqlMerge
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
block|}
comment|/**    * retrieve pattern variables defined    */
specifier|private
class|class
name|PatternVarVisitor
implements|implements
name|SqlVisitor
argument_list|<
name|Void
argument_list|>
block|{
specifier|private
name|MatchRecognizeScope
name|scope
decl_stmt|;
name|PatternVarVisitor
parameter_list|(
name|MatchRecognizeScope
name|scope
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|nodeList
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|id
operator|.
name|isSimple
argument_list|()
argument_list|)
expr_stmt|;
name|scope
operator|.
name|addPatternVar
argument_list|(
name|id
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|type
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|param
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Void
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|intervalQualifier
argument_list|)
throw|;
block|}
block|}
comment|/**    * Visitor which derives the type of a given {@link SqlNode}.    *    *<p>Each method must return the derived type. This visitor is basically a    * single-use dispatcher; the visit is never recursive.    */
specifier|private
class|class
name|DeriveTypeVisitor
implements|implements
name|SqlVisitor
argument_list|<
name|RelDataType
argument_list|>
block|{
specifier|private
specifier|final
name|SqlValidatorScope
name|scope
decl_stmt|;
name|DeriveTypeVisitor
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|literal
operator|.
name|createSqlType
argument_list|(
name|typeFactory
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|operator
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
return|return
name|operator
operator|.
name|deriveType
argument_list|(
name|SqlValidatorImpl
operator|.
name|this
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
comment|// Operand is of a type that we can't derive a type for. If the
comment|// operand is of a peculiar type, such as a SqlNodeList, then you
comment|// should override the operator's validateCall() method so that it
comment|// doesn't try to validate that operand as an expression.
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|nodeList
argument_list|)
throw|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// First check for builtin functions which don't have parentheses,
comment|// like "LOCALTIME".
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|opTab
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|validateOperands
argument_list|(
name|SqlValidatorImpl
operator|.
name|this
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
return|;
block|}
name|RelDataType
name|type
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scope
operator|instanceof
name|EmptyScope
operator|)
condition|)
block|{
name|id
operator|=
name|scope
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
operator|.
name|identifier
expr_stmt|;
block|}
comment|// Resolve the longest prefix of id that we can
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// REVIEW jvs 9-June-2005: The name resolution rules used
comment|// here are supposed to match SQL:2003 Part 2 Section 6.6
comment|// (identifier chain), but we don't currently have enough
comment|// information to get everything right.  In particular,
comment|// routine parameters are currently looked up via resolve;
comment|// we could do a better job if they were looked up via
comment|// resolveColumn.
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorScope
operator|.
name|ResolvedImpl
name|resolved
init|=
operator|new
name|SqlValidatorScope
operator|.
name|ResolvedImpl
argument_list|()
decl_stmt|;
name|scope
operator|.
name|resolve
argument_list|(
name|id
operator|.
name|names
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|nameMatcher
argument_list|,
literal|false
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
if|if
condition|(
name|resolved
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// There's a namespace with the name we seek.
specifier|final
name|SqlValidatorScope
operator|.
name|Resolve
name|resolve
init|=
name|resolved
operator|.
name|only
argument_list|()
decl_stmt|;
name|type
operator|=
name|resolve
operator|.
name|rowType
argument_list|()
expr_stmt|;
for|for
control|(
name|SqlValidatorScope
operator|.
name|Step
name|p
range|:
name|Util
operator|.
name|skip
argument_list|(
name|resolve
operator|.
name|path
operator|.
name|steps
argument_list|()
argument_list|)
control|)
block|{
name|type
operator|=
name|type
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|p
operator|.
name|i
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|// Give precedence to namespace found, unless there
comment|// are no more identifier components.
if|if
condition|(
name|type
operator|==
literal|null
operator|||
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// See if there's a column with the name we seek in
comment|// precisely one of the namespaces in this scope.
name|RelDataType
name|colType
init|=
name|scope
operator|.
name|resolveColumn
argument_list|(
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|colType
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|colType
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
specifier|final
name|SqlIdentifier
name|last
init|=
name|id
operator|.
name|getComponent
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|)
decl_stmt|;
throw|throw
name|newValidationError
argument_list|(
name|last
argument_list|,
name|RESOURCE
operator|.
name|unknownIdentifier
argument_list|(
name|last
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// Resolve rest of identifier
for|for
control|(
init|;
name|i
operator|<
name|id
operator|.
name|names
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|field
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// The wildcard "*" is represented as an empty name. It never
comment|// resolves to a field.
name|name
operator|=
literal|"*"
expr_stmt|;
name|field
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
name|field
operator|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|id
operator|.
name|getComponent
argument_list|(
name|i
argument_list|)
argument_list|,
name|RESOURCE
operator|.
name|unknownField
argument_list|(
name|name
argument_list|)
argument_list|)
throw|;
block|}
name|type
operator|=
name|field
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
name|type
operator|=
name|SqlTypeUtil
operator|.
name|addCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|getTypeFactory
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|dataType
parameter_list|)
block|{
comment|// Q. How can a data type have a type?
comment|// A. When it appears in an expression. (Say as the 2nd arg to the
comment|//    CAST operator.)
name|validateDataType
argument_list|(
name|dataType
argument_list|)
expr_stmt|;
return|return
name|dataType
operator|.
name|deriveType
argument_list|(
name|SqlValidatorImpl
operator|.
name|this
argument_list|)
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
name|unknownType
return|;
block|}
specifier|public
name|RelDataType
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|)
block|{
return|return
name|typeFactory
operator|.
name|createSqlIntervalType
argument_list|(
name|intervalQualifier
argument_list|)
return|;
block|}
block|}
comment|/**    * Converts an expression into canonical form by fully-qualifying any    * identifiers.    */
specifier|private
specifier|static
class|class
name|Expander
extends|extends
name|SqlScopedShuttle
block|{
specifier|protected
specifier|final
name|SqlValidatorImpl
name|validator
decl_stmt|;
name|Expander
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|super
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|this
operator|.
name|validator
operator|=
name|validator
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// First check for builtin functions which don't have
comment|// parentheses, like "LOCALTIME".
name|SqlCall
name|call
init|=
name|SqlUtil
operator|.
name|makeCall
argument_list|(
name|validator
operator|.
name|getOperatorTable
argument_list|()
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|final
name|SqlIdentifier
name|fqId
init|=
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
operator|.
name|identifier
decl_stmt|;
name|SqlNode
name|expandedExpr
init|=
name|fqId
decl_stmt|;
comment|// Convert a column ref into ITEM(*, 'col_name').
comment|// select col_name from (select * from dynTable)
comment|// SqlIdentifier "col_name" would be resolved to a dynamic star field in dynTable's rowType.
comment|// Expand such SqlIdentifier to ITEM operator.
if|if
condition|(
name|DynamicRecordType
operator|.
name|isDynamicStarColName
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|fqId
operator|.
name|names
argument_list|)
argument_list|)
operator|&&
operator|!
name|DynamicRecordType
operator|.
name|isDynamicStarColName
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|id
operator|.
name|names
argument_list|)
argument_list|)
condition|)
block|{
name|SqlNode
index|[]
name|inputs
init|=
operator|new
name|SqlNode
index|[
literal|2
index|]
decl_stmt|;
name|inputs
index|[
literal|0
index|]
operator|=
name|fqId
expr_stmt|;
name|inputs
index|[
literal|1
index|]
operator|=
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
name|Util
operator|.
name|last
argument_list|(
name|id
operator|.
name|names
argument_list|)
argument_list|,
name|id
operator|.
name|getParserPosition
argument_list|()
argument_list|)
expr_stmt|;
name|SqlBasicCall
name|item_call
init|=
operator|new
name|SqlBasicCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|ITEM
argument_list|,
name|inputs
argument_list|,
name|id
operator|.
name|getParserPosition
argument_list|()
argument_list|)
decl_stmt|;
name|expandedExpr
operator|=
name|item_call
expr_stmt|;
block|}
name|validator
operator|.
name|setOriginal
argument_list|(
name|expandedExpr
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|expandedExpr
return|;
block|}
annotation|@
name|Override
specifier|protected
name|SqlNode
name|visitScoped
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
switch|switch
condition|(
name|call
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|SCALAR_QUERY
case|:
case|case
name|CURRENT_VALUE
case|:
case|case
name|NEXT_VALUE
case|:
case|case
name|WITH
case|:
return|return
name|call
return|;
block|}
comment|// Only visits arguments which are expressions. We don't want to
comment|// qualify non-expressions such as 'x' in 'empno * 5 AS x'.
name|ArgHandler
argument_list|<
name|SqlNode
argument_list|>
name|argHandler
init|=
operator|new
name|CallCopyingArgHandler
argument_list|(
name|call
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|acceptCall
argument_list|(
name|this
argument_list|,
name|call
argument_list|,
literal|true
argument_list|,
name|argHandler
argument_list|)
expr_stmt|;
specifier|final
name|SqlNode
name|result
init|=
name|argHandler
operator|.
name|result
argument_list|()
decl_stmt|;
name|validator
operator|.
name|setOriginal
argument_list|(
name|result
argument_list|,
name|call
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/**    * Shuttle which walks over an expression in the ORDER BY clause, replacing    * usages of aliases with the underlying expression.    */
class|class
name|OrderExpressionExpander
extends|extends
name|SqlScopedShuttle
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|aliasList
decl_stmt|;
specifier|private
specifier|final
name|SqlSelect
name|select
decl_stmt|;
specifier|private
specifier|final
name|SqlNode
name|root
decl_stmt|;
name|OrderExpressionExpander
parameter_list|(
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|root
parameter_list|)
block|{
name|super
argument_list|(
name|getOrderScope
argument_list|(
name|select
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|select
operator|=
name|select
expr_stmt|;
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|aliasList
operator|=
name|getNamespace
argument_list|(
name|select
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
expr_stmt|;
block|}
specifier|public
name|SqlNode
name|go
parameter_list|()
block|{
return|return
name|root
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
comment|// Ordinal markers, e.g. 'select a, b from t order by 2'.
comment|// Only recognize them if they are the whole expression,
comment|// and if the dialect permits.
if|if
condition|(
name|literal
operator|==
name|root
operator|&&
name|getConformance
argument_list|()
operator|.
name|isSortByOrdinal
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
specifier|final
name|int
name|intValue
init|=
name|literal
operator|.
name|intValue
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|intValue
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|intValue
operator|<
literal|1
operator|||
name|intValue
operator|>
name|aliasList
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|RESOURCE
operator|.
name|orderByOrdinalOutOfRange
argument_list|()
argument_list|)
throw|;
block|}
comment|// SQL ordinals are 1-based, but Sort's are 0-based
name|int
name|ordinal
init|=
name|intValue
operator|-
literal|1
decl_stmt|;
return|return
name|nthSelectItem
argument_list|(
name|ordinal
argument_list|,
name|literal
operator|.
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
break|break;
block|}
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|literal
argument_list|)
return|;
block|}
comment|/**      * Returns the<code>ordinal</code>th item in the select list.      */
specifier|private
name|SqlNode
name|nthSelectItem
parameter_list|(
name|int
name|ordinal
parameter_list|,
specifier|final
name|SqlParserPos
name|pos
parameter_list|)
block|{
comment|// TODO: Don't expand the list every time. Maybe keep an expanded
comment|// version of each expression -- select lists and identifiers -- in
comment|// the validator.
name|SqlNodeList
name|expandedSelectList
init|=
name|expandStar
argument_list|(
name|select
operator|.
name|getSelectList
argument_list|()
argument_list|,
name|select
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|SqlNode
name|expr
init|=
name|expandedSelectList
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
decl_stmt|;
name|expr
operator|=
name|stripAs
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|expr
operator|=
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
operator|(
name|SqlIdentifier
operator|)
name|expr
argument_list|)
operator|.
name|identifier
expr_stmt|;
block|}
comment|// Create a copy of the expression with the position of the order
comment|// item.
return|return
name|expr
operator|.
name|clone
argument_list|(
name|pos
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
comment|// Aliases, e.g. 'select a as x, b from t order by x'.
if|if
condition|(
name|id
operator|.
name|isSimple
argument_list|()
operator|&&
name|getConformance
argument_list|()
operator|.
name|isSortByAlias
argument_list|()
condition|)
block|{
name|String
name|alias
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
specifier|final
name|SqlValidatorNamespace
name|selectNs
init|=
name|getNamespace
argument_list|(
name|select
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|selectNs
operator|.
name|getRowTypeSansSystemColumns
argument_list|()
decl_stmt|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|nameMatcher
operator|.
name|field
argument_list|(
name|rowType
argument_list|,
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
return|return
name|nthSelectItem
argument_list|(
name|field
operator|.
name|getIndex
argument_list|()
argument_list|,
name|id
operator|.
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// No match. Return identifier unchanged.
return|return
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
name|id
argument_list|)
operator|.
name|identifier
return|;
block|}
specifier|protected
name|SqlNode
name|visitScoped
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Don't attempt to expand sub-queries. We haven't implemented
comment|// these yet.
if|if
condition|(
name|call
operator|instanceof
name|SqlSelect
condition|)
block|{
return|return
name|call
return|;
block|}
return|return
name|super
operator|.
name|visitScoped
argument_list|(
name|call
argument_list|)
return|;
block|}
block|}
comment|/**    * Shuttle which walks over an expression in the GROUP BY/HAVING clause, replacing    * usages of aliases or ordinals with the underlying expression.    */
specifier|static
class|class
name|ExtendedExpander
extends|extends
name|Expander
block|{
specifier|final
name|SqlSelect
name|select
decl_stmt|;
specifier|final
name|SqlNode
name|root
decl_stmt|;
specifier|final
name|boolean
name|havingExpr
decl_stmt|;
name|ExtendedExpander
parameter_list|(
name|SqlValidatorImpl
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlSelect
name|select
parameter_list|,
name|SqlNode
name|root
parameter_list|,
name|boolean
name|havingExpr
parameter_list|)
block|{
name|super
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|)
expr_stmt|;
name|this
operator|.
name|select
operator|=
name|select
expr_stmt|;
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|havingExpr
operator|=
name|havingExpr
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|.
name|isSimple
argument_list|()
operator|&&
operator|(
name|havingExpr
condition|?
name|validator
operator|.
name|getConformance
argument_list|()
operator|.
name|isHavingAlias
argument_list|()
else|:
name|validator
operator|.
name|getConformance
argument_list|()
operator|.
name|isGroupByAlias
argument_list|()
operator|)
condition|)
block|{
name|String
name|name
init|=
name|id
operator|.
name|getSimple
argument_list|()
decl_stmt|;
name|SqlNode
name|expr
init|=
literal|null
decl_stmt|;
specifier|final
name|SqlNameMatcher
name|nameMatcher
init|=
name|validator
operator|.
name|catalogReader
operator|.
name|nameMatcher
argument_list|()
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SqlNode
name|s
range|:
name|select
operator|.
name|getSelectList
argument_list|()
control|)
block|{
specifier|final
name|String
name|alias
init|=
name|SqlValidatorUtil
operator|.
name|getAlias
argument_list|(
name|s
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|!=
literal|null
operator|&&
name|nameMatcher
operator|.
name|matches
argument_list|(
name|alias
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|expr
operator|=
name|s
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
name|super
operator|.
name|visit
argument_list|(
name|id
argument_list|)
return|;
block|}
if|else if
condition|(
name|n
operator|>
literal|1
condition|)
block|{
comment|// More than one column has this alias.
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|id
argument_list|,
name|RESOURCE
operator|.
name|columnAmbiguous
argument_list|(
name|name
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|havingExpr
operator|&&
name|validator
operator|.
name|isAggregate
argument_list|(
name|root
argument_list|)
condition|)
block|{
return|return
name|super
operator|.
name|visit
argument_list|(
name|id
argument_list|)
return|;
block|}
name|expr
operator|=
name|stripAs
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|expr
operator|=
name|getScope
argument_list|()
operator|.
name|fullyQualify
argument_list|(
operator|(
name|SqlIdentifier
operator|)
name|expr
argument_list|)
operator|.
name|identifier
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|id
argument_list|)
return|;
block|}
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
if|if
condition|(
name|havingExpr
operator|||
operator|!
name|validator
operator|.
name|getConformance
argument_list|()
operator|.
name|isGroupByOrdinal
argument_list|()
condition|)
block|{
return|return
name|super
operator|.
name|visit
argument_list|(
name|literal
argument_list|)
return|;
block|}
name|boolean
name|isOrdinalLiteral
init|=
name|literal
operator|==
name|root
decl_stmt|;
switch|switch
condition|(
name|root
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|GROUPING_SETS
case|:
case|case
name|ROLLUP
case|:
case|case
name|CUBE
case|:
if|if
condition|(
name|root
operator|instanceof
name|SqlBasicCall
condition|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
init|=
operator|(
operator|(
name|SqlBasicCall
operator|)
name|root
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|node
range|:
name|operandList
control|)
block|{
if|if
condition|(
name|node
operator|.
name|equals
argument_list|(
name|literal
argument_list|)
condition|)
block|{
name|isOrdinalLiteral
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
block|}
if|if
condition|(
name|isOrdinalLiteral
condition|)
block|{
switch|switch
condition|(
name|literal
operator|.
name|getTypeName
argument_list|()
condition|)
block|{
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
specifier|final
name|int
name|intValue
init|=
name|literal
operator|.
name|intValue
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|intValue
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|intValue
operator|<
literal|1
operator|||
name|intValue
operator|>
name|select
operator|.
name|getSelectList
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|literal
argument_list|,
name|RESOURCE
operator|.
name|orderByOrdinalOutOfRange
argument_list|()
argument_list|)
throw|;
block|}
comment|// SQL ordinals are 1-based, but Sort's are 0-based
name|int
name|ordinal
init|=
name|intValue
operator|-
literal|1
decl_stmt|;
return|return
name|SqlUtil
operator|.
name|stripAs
argument_list|(
name|select
operator|.
name|getSelectList
argument_list|()
operator|.
name|get
argument_list|(
name|ordinal
argument_list|)
argument_list|)
return|;
block|}
break|break;
block|}
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|literal
argument_list|)
return|;
block|}
block|}
comment|/** Information about an identifier in a particular scope. */
specifier|protected
specifier|static
class|class
name|IdInfo
block|{
specifier|public
specifier|final
name|SqlValidatorScope
name|scope
decl_stmt|;
specifier|public
specifier|final
name|SqlIdentifier
name|id
decl_stmt|;
specifier|public
name|IdInfo
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlIdentifier
name|id
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
block|}
comment|/**    * Utility object used to maintain information about the parameters in a    * function call.    */
specifier|protected
specifier|static
class|class
name|FunctionParamInfo
block|{
comment|/**      * Maps a cursor (based on its position relative to other cursor      * parameters within a function call) to the SELECT associated with the      * cursor.      */
specifier|public
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|SqlSelect
argument_list|>
name|cursorPosToSelectMap
decl_stmt|;
comment|/**      * Maps a column list parameter to the parent cursor parameter it      * references. The parameters are id'd by their names.      */
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|columnListParamToParentCursorMap
decl_stmt|;
specifier|public
name|FunctionParamInfo
parameter_list|()
block|{
name|cursorPosToSelectMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|columnListParamToParentCursorMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Modify the nodes in navigation function    * such as FIRST, LAST, PREV AND NEXT.    */
specifier|private
specifier|static
class|class
name|NavigationModifier
extends|extends
name|SqlShuttle
block|{
specifier|public
name|SqlNode
name|go
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
name|node
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Shuttle that expands navigation expressions in a MATCH_RECOGNIZE clause.    *    *<p>Examples:    *    *<ul>    *<li>{@code PREV(A.price + A.amount)}&rarr;    *   {@code PREV(A.price) + PREV(A.amount)}    *    *<li>{@code FIRST(A.price * 2)}&rarr; {@code FIRST(A.PRICE) * 2}    *</ul>    */
specifier|private
specifier|static
class|class
name|NavigationExpander
extends|extends
name|NavigationModifier
block|{
specifier|final
name|SqlOperator
name|op
decl_stmt|;
specifier|final
name|SqlNode
name|offset
decl_stmt|;
name|NavigationExpander
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|NavigationExpander
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|SqlNode
name|offset
parameter_list|)
block|{
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|op
operator|=
name|operator
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|newOperands
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isLogicalNavigation
argument_list|(
name|kind
argument_list|)
operator|||
name|isPhysicalNavigation
argument_list|(
name|kind
argument_list|)
condition|)
block|{
name|SqlNode
name|inner
init|=
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|SqlNode
name|offset
init|=
name|operands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// merge two straight prev/next, update offset
if|if
condition|(
name|isPhysicalNavigation
argument_list|(
name|kind
argument_list|)
condition|)
block|{
name|SqlKind
name|innerKind
init|=
name|inner
operator|.
name|getKind
argument_list|()
decl_stmt|;
if|if
condition|(
name|isPhysicalNavigation
argument_list|(
name|innerKind
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|innerOperands
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|inner
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|SqlNode
name|innerOffset
init|=
name|innerOperands
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|SqlOperator
name|newOperator
init|=
name|innerKind
operator|==
name|kind
condition|?
name|SqlStdOperatorTable
operator|.
name|PLUS
else|:
name|SqlStdOperatorTable
operator|.
name|MINUS
decl_stmt|;
name|offset
operator|=
name|newOperator
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|offset
argument_list|,
name|innerOffset
argument_list|)
expr_stmt|;
name|inner
operator|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|innerOperands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
name|SqlNode
name|newInnerNode
init|=
name|inner
operator|.
name|accept
argument_list|(
operator|new
name|NavigationExpander
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|offset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|!=
literal|null
condition|)
block|{
name|newInnerNode
operator|=
name|op
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|newInnerNode
argument_list|,
name|this
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|newInnerNode
return|;
block|}
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|SqlNode
name|node
range|:
name|operands
control|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|SqlNode
name|newNode
init|=
name|node
operator|.
name|accept
argument_list|(
operator|new
name|NavigationExpander
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|!=
literal|null
condition|)
block|{
name|newNode
operator|=
name|op
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|newNode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|newOperands
operator|.
name|add
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newOperands
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|newOperands
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
return|return
name|call
return|;
block|}
else|else
block|{
return|return
name|op
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|call
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
return|return
name|id
return|;
block|}
else|else
block|{
return|return
name|op
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|id
argument_list|,
name|offset
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Shuttle that replaces {@code A as A.price> PREV(B.price)} with    * {@code PREV(A.price, 0)> LAST(B.price, 0)}.    *    *<p>Replacing {@code A.price} with {@code PREV(A.price, 0)} makes the    * implementation of    * {@link RexVisitor#visitPatternFieldRef(RexPatternFieldRef)} more unified.    * Otherwise, it's difficult to implement this method. If it returns the    * specified field, then the navigation such as {@code PREV(A.price, 1)}    * becomes impossible; if not, then comparisons such as    * {@code A.price> PREV(A.price, 1)} become meaningless.    */
specifier|private
specifier|static
class|class
name|NavigationReplacer
extends|extends
name|NavigationModifier
block|{
specifier|private
specifier|final
name|String
name|alpha
decl_stmt|;
name|NavigationReplacer
parameter_list|(
name|String
name|alpha
parameter_list|)
block|{
name|this
operator|.
name|alpha
operator|=
name|alpha
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
if|if
condition|(
name|isLogicalNavigation
argument_list|(
name|kind
argument_list|)
operator|||
name|isAggregation
argument_list|(
name|kind
argument_list|)
operator|||
name|isRunningOrFinal
argument_list|(
name|kind
argument_list|)
condition|)
block|{
return|return
name|call
return|;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|PREV
case|:
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
if|if
condition|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SqlIdentifier
condition|)
block|{
name|String
name|name
init|=
operator|(
operator|(
name|SqlIdentifier
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|name
operator|.
name|equals
argument_list|(
name|alpha
argument_list|)
condition|?
name|call
else|:
name|SqlStdOperatorTable
operator|.
name|LAST
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|operands
argument_list|)
return|;
block|}
block|}
return|return
name|super
operator|.
name|visit
argument_list|(
name|call
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SqlNode
name|visit
parameter_list|(
name|SqlIdentifier
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|.
name|isSimple
argument_list|()
condition|)
block|{
return|return
name|id
return|;
block|}
name|SqlOperator
name|operator
init|=
name|id
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|alpha
argument_list|)
condition|?
name|SqlStdOperatorTable
operator|.
name|PREV
else|:
name|SqlStdOperatorTable
operator|.
name|LAST
decl_stmt|;
return|return
name|operator
operator|.
name|createCall
argument_list|(
name|SqlParserPos
operator|.
name|ZERO
argument_list|,
name|id
argument_list|,
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
literal|"0"
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Within one navigation function, the pattern var should be same    */
specifier|private
class|class
name|PatternValidator
extends|extends
name|SqlBasicVisitor
argument_list|<
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
block|{
specifier|private
specifier|final
name|boolean
name|isMeasure
decl_stmt|;
name|int
name|firstLastCount
decl_stmt|;
name|int
name|prevNextCount
decl_stmt|;
name|int
name|aggregateCount
decl_stmt|;
name|PatternValidator
parameter_list|(
name|boolean
name|isMeasure
parameter_list|)
block|{
name|this
argument_list|(
name|isMeasure
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|PatternValidator
parameter_list|(
name|boolean
name|isMeasure
parameter_list|,
name|int
name|firstLastCount
parameter_list|,
name|int
name|prevNextCount
parameter_list|,
name|int
name|aggregateCount
parameter_list|)
block|{
name|this
operator|.
name|isMeasure
operator|=
name|isMeasure
expr_stmt|;
name|this
operator|.
name|firstLastCount
operator|=
name|firstLastCount
expr_stmt|;
name|this
operator|.
name|prevNextCount
operator|=
name|prevNextCount
expr_stmt|;
name|this
operator|.
name|aggregateCount
operator|=
name|aggregateCount
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|visit
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
name|boolean
name|isSingle
init|=
literal|false
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|vars
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|SqlKind
name|kind
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSingleVarRequired
argument_list|(
name|kind
argument_list|)
condition|)
block|{
name|isSingle
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|isPhysicalNavigation
argument_list|(
name|kind
argument_list|)
condition|)
block|{
if|if
condition|(
name|isMeasure
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternPrevFunctionInMeasure
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|firstLastCount
operator|!=
literal|0
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternPrevFunctionOrder
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|prevNextCount
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|isLogicalNavigation
argument_list|(
name|kind
argument_list|)
condition|)
block|{
if|if
condition|(
name|firstLastCount
operator|!=
literal|0
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternPrevFunctionOrder
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|firstLastCount
operator|++
expr_stmt|;
block|}
if|else if
condition|(
name|isAggregation
argument_list|(
name|kind
argument_list|)
condition|)
block|{
comment|// cannot apply aggregation in PREV/NEXT, FIRST/LAST
if|if
condition|(
name|firstLastCount
operator|!=
literal|0
operator|||
name|prevNextCount
operator|!=
literal|0
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternAggregationInNavigation
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|kind
operator|==
name|SqlKind
operator|.
name|COUNT
operator|&&
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternCountFunctionArg
argument_list|()
argument_list|)
throw|;
block|}
name|aggregateCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isRunningOrFinal
argument_list|(
name|kind
argument_list|)
operator|&&
operator|!
name|isMeasure
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternRunningFunctionInDefine
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|SqlNode
name|node
range|:
name|operands
control|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|vars
operator|.
name|addAll
argument_list|(
name|node
operator|.
name|accept
argument_list|(
operator|new
name|PatternValidator
argument_list|(
name|isMeasure
argument_list|,
name|firstLastCount
argument_list|,
name|prevNextCount
argument_list|,
name|aggregateCount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isSingle
condition|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|COUNT
case|:
if|if
condition|(
name|vars
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternCountFunctionArg
argument_list|()
argument_list|)
throw|;
block|}
break|break;
default|default:
if|if
condition|(
name|operands
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
operator|!
operator|(
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SqlCall
operator|)
operator|||
operator|(
operator|(
name|SqlCall
operator|)
name|operands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getOperator
argument_list|()
operator|!=
name|SqlStdOperatorTable
operator|.
name|CLASSIFIER
condition|)
block|{
if|if
condition|(
name|vars
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternFunctionNullCheck
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|vars
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
name|newValidationError
argument_list|(
name|call
argument_list|,
name|Static
operator|.
name|RESOURCE
operator|.
name|patternFunctionVariableCheck
argument_list|(
name|call
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|vars
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|visit
parameter_list|(
name|SqlIdentifier
name|identifier
parameter_list|)
block|{
name|boolean
name|check
init|=
name|prevNextCount
operator|>
literal|0
operator|||
name|firstLastCount
operator|>
literal|0
operator|||
name|aggregateCount
operator|>
literal|0
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|vars
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|identifier
operator|.
name|names
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
name|check
condition|)
block|{
name|vars
operator|.
name|add
argument_list|(
name|identifier
operator|.
name|names
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|vars
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|visit
parameter_list|(
name|SqlLiteral
name|literal
parameter_list|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|visit
parameter_list|(
name|SqlIntervalQualifier
name|qualifier
parameter_list|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|visit
parameter_list|(
name|SqlDataTypeSpec
name|type
parameter_list|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|visit
parameter_list|(
name|SqlDynamicParam
name|param
parameter_list|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|()
return|;
block|}
block|}
comment|//~ Enums ------------------------------------------------------------------
comment|/**    * Validation status.    */
specifier|public
enum|enum
name|Status
block|{
comment|/**      * Validation has not started for this scope.      */
name|UNVALIDATED
block|,
comment|/**      * Validation is in progress for this scope.      */
name|IN_PROGRESS
block|,
comment|/**      * Validation has completed (perhaps unsuccessfully).      */
name|VALID
block|}
block|}
end_class

begin_comment
comment|// End SqlValidatorImpl.java
end_comment

end_unit

