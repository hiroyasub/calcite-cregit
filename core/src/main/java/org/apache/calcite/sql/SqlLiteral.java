begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnitRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlLiteralChainOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonotonicity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BitString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|UnsupportedCharsetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * A<code>SqlLiteral</code> is a constant. It is, appropriately, immutable.  *  *<p>How is the value stored? In that respect, the class is somewhat of a black  * box. There is a {@link #getValue} method which returns the value as an  * object, but the type of that value is implementation detail, and it is best  * that your code does not depend upon that knowledge. It is better to use  * task-oriented methods such as {@link #toSqlString(SqlDialect)} and  * {@link #toValue}.</p>  *  *<p>If you really need to access the value directly, you should switch on the  * value of the {@link #typeName} field, rather than making assumptions about  * the runtime type of the {@link #value}.</p>  *  *<p>The allowable types and combinations are:  *  *<table>  *<caption>Allowable types for SqlLiteral</caption>  *<tr>  *<th>TypeName</th>  *<th>Meaing</th>  *<th>Value type</th>  *</tr>  *<tr>  *<td>{@link SqlTypeName#NULL}</td>  *<td>The null value. It has its own special type.</td>  *<td>null</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#BOOLEAN}</td>  *<td>Boolean, namely<code>TRUE</code>,<code>FALSE</code> or<code>  * UNKNOWN</code>.</td>  *<td>{@link Boolean}, or null represents the UNKNOWN value</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#DECIMAL}</td>  *<td>Exact number, for example<code>0</code>,<code>-.5</code>,<code>  * 12345</code>.</td>  *<td>{@link BigDecimal}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#DOUBLE}</td>  *<td>Approximate number, for example<code>6.023E-23</code>.</td>  *<td>{@link BigDecimal}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#DATE}</td>  *<td>Date, for example<code>DATE '1969-04'29'</code></td>  *<td>{@link Calendar}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#TIME}</td>  *<td>Time, for example<code>TIME '18:37:42.567'</code></td>  *<td>{@link Calendar}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#TIMESTAMP}</td>  *<td>Timestamp, for example<code>TIMESTAMP '1969-04-29  * 18:37:42.567'</code></td>  *<td>{@link Calendar}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#CHAR}</td>  *<td>Character constant, for example<code>'Hello, world!'</code>,<code>  * ''</code>,<code>_N'Bonjour'</code>,<code>_ISO-8859-1'It''s superman!'  * COLLATE SHIFT_JIS$ja_JP$2</code>. These are always CHAR, never VARCHAR.</td>  *<td>{@link NlsString}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#BINARY}</td>  *<td>Binary constant, for example<code>X'ABC'</code>,<code>X'7F'</code>.  * Note that strings with an odd number of hexits will later become values of  * the BIT datatype, because they have an incomplete number of bytes. But here,  * they are all binary constants, because that's how they were written. These  * constants are always BINARY, never VARBINARY.</td>  *<td>{@link BitString}</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#SYMBOL}</td>  *<td>A symbol is a special type used to make parsing easier; it is not part of  * the SQL standard, and is not exposed to end-users. It is used to hold a  * symbol, such as the LEADING flag in a call to the function<code>  * TRIM([LEADING|TRAILING|BOTH] chars FROM string)</code>.</td>  *<td>A class which implements the {@link SqlSymbol} interface</td>  *</tr>  *<tr>  *<td>{@link SqlTypeName#INTERVAL_DAY_TIME}</td>  *<td>Interval, for example<code>INTERVAL '1:34' HOUR</code>.</td>  *<td>{@link SqlIntervalLiteral.IntervalValue}.</td>  *</tr>  *</table>  */
end_comment

begin_class
specifier|public
class|class
name|SqlLiteral
extends|extends
name|SqlNode
block|{
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * The type with which this literal was declared. This type is very    * approximate: the literal may have a different type once validated. For    * example, all numeric literals have a type name of    * {@link SqlTypeName#DECIMAL}, but on validation may become    * {@link SqlTypeName#INTEGER}.    */
specifier|private
specifier|final
name|SqlTypeName
name|typeName
decl_stmt|;
comment|/**    * The value of this literal. The type of the value must be appropriate for    * the typeName, as defined by the {@link #valueMatchesType} method.    */
specifier|protected
specifier|final
name|Object
name|value
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a<code>SqlLiteral</code>.    */
specifier|protected
name|SqlLiteral
parameter_list|(
name|Object
name|value
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|super
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|typeName
operator|=
name|typeName
expr_stmt|;
assert|assert
name|typeName
operator|!=
literal|null
assert|;
assert|assert
name|valueMatchesType
argument_list|(
name|value
argument_list|,
name|typeName
argument_list|)
assert|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * @return value of {@link #typeName}    */
specifier|public
name|SqlTypeName
name|getTypeName
parameter_list|()
block|{
return|return
name|typeName
return|;
block|}
comment|/**    * @return whether value is appropriate for its type (we have rules about    * these things)    */
specifier|public
specifier|static
name|boolean
name|valueMatchesType
parameter_list|(
name|Object
name|value
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|)
block|{
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
operator|(
name|value
operator|==
literal|null
operator|)
operator|||
operator|(
name|value
operator|instanceof
name|Boolean
operator|)
return|;
case|case
name|NULL
case|:
return|return
name|value
operator|==
literal|null
return|;
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
return|return
name|value
operator|instanceof
name|BigDecimal
return|;
case|case
name|DATE
case|:
case|case
name|TIME
case|:
case|case
name|TIMESTAMP
case|:
return|return
name|value
operator|instanceof
name|Calendar
return|;
case|case
name|INTERVAL_DAY_TIME
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
return|return
name|value
operator|instanceof
name|SqlIntervalLiteral
operator|.
name|IntervalValue
return|;
case|case
name|BINARY
case|:
return|return
name|value
operator|instanceof
name|BitString
return|;
case|case
name|CHAR
case|:
return|return
name|value
operator|instanceof
name|NlsString
return|;
case|case
name|SYMBOL
case|:
return|return
operator|(
name|value
operator|instanceof
name|SqlSymbol
operator|)
operator|||
operator|(
name|value
operator|instanceof
name|SqlSampleSpec
operator|)
operator|||
operator|(
name|value
operator|instanceof
name|TimeUnitRange
operator|)
return|;
case|case
name|MULTISET
case|:
return|return
literal|true
return|;
case|case
name|INTEGER
case|:
comment|// not allowed -- use Decimal
case|case
name|VARCHAR
case|:
comment|// not allowed -- use Char
case|case
name|VARBINARY
case|:
comment|// not allowed -- use Binary
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
block|}
specifier|public
name|SqlNode
name|clone
parameter_list|(
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlLiteral
argument_list|(
name|value
argument_list|,
name|typeName
argument_list|,
name|pos
argument_list|)
return|;
block|}
specifier|public
name|SqlKind
name|getKind
parameter_list|()
block|{
return|return
name|SqlKind
operator|.
name|LITERAL
return|;
block|}
comment|/**    * Returns the value of this literal.    *    *<p>Try not to use this method! There are so many different kinds of    * values, it's better to to let SqlLiteral do whatever it is you want to    * do.    *    * @see #booleanValue()    * @see #symbolValue()    */
specifier|public
name|Object
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
comment|/** Returns the value as a symbol. */
specifier|public
parameter_list|<
name|E
extends|extends
name|SqlSymbol
parameter_list|>
name|E
name|symbolValue
parameter_list|()
block|{
comment|//noinspection unchecked
return|return
operator|(
name|E
operator|)
name|value
return|;
block|}
comment|/** Returns the value as a boolean. */
specifier|public
name|boolean
name|booleanValue
parameter_list|()
block|{
return|return
operator|(
name|Boolean
operator|)
name|value
return|;
block|}
comment|/**    * Extracts the {@link SqlSampleSpec} value from a symbol literal.    *    * @throws ClassCastException if the value is not a symbol literal    * @see #createSymbol(SqlSymbol, SqlParserPos)    */
specifier|public
specifier|static
name|SqlSampleSpec
name|sampleValue
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
return|return
operator|(
name|SqlSampleSpec
operator|)
operator|(
operator|(
name|SqlLiteral
operator|)
name|node
operator|)
operator|.
name|value
return|;
block|}
comment|/**    * Extracts the string value from a string literal, a chain of string    * literals, or a CAST of a string literal.    */
specifier|public
specifier|static
name|String
name|stringValue
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlLiteral
condition|)
block|{
name|SqlLiteral
name|literal
init|=
operator|(
name|SqlLiteral
operator|)
name|node
decl_stmt|;
assert|assert
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|)
assert|;
return|return
name|literal
operator|.
name|toValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|SqlUtil
operator|.
name|isLiteralChain
argument_list|(
name|node
argument_list|)
condition|)
block|{
specifier|final
name|SqlLiteral
name|literal
init|=
name|SqlLiteralChainOperator
operator|.
name|concatenateOperands
argument_list|(
operator|(
name|SqlCall
operator|)
name|node
argument_list|)
decl_stmt|;
assert|assert
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|literal
operator|.
name|getTypeName
argument_list|()
argument_list|)
assert|;
return|return
name|literal
operator|.
name|toValue
argument_list|()
return|;
block|}
if|else if
condition|(
name|node
operator|instanceof
name|SqlCall
operator|&&
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|getOperator
argument_list|()
operator|==
name|SqlStdOperatorTable
operator|.
name|CAST
condition|)
block|{
return|return
name|stringValue
argument_list|(
operator|(
operator|(
name|SqlCall
operator|)
name|node
operator|)
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"invalid string literal: "
operator|+
name|node
argument_list|)
throw|;
block|}
block|}
comment|/**    * Converts a chained string literals into regular literals; returns regular    * literals unchanged.    */
specifier|public
specifier|static
name|SqlLiteral
name|unchain
parameter_list|(
name|SqlNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|SqlLiteral
condition|)
block|{
return|return
operator|(
name|SqlLiteral
operator|)
name|node
return|;
block|}
if|else if
condition|(
name|SqlUtil
operator|.
name|isLiteralChain
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return
name|SqlLiteralChainOperator
operator|.
name|concatenateOperands
argument_list|(
operator|(
name|SqlCall
operator|)
name|node
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"invalid literal: "
operator|+
name|node
argument_list|)
throw|;
block|}
block|}
comment|/**    * For calc program builder - value may be different than {@link #unparse}    * Typical values:    *    *<ul>    *<li>Hello, world!</li>    *<li>12.34</li>    *<li>{null}</li>    *<li>1969-04-29</li>    *</ul>    *    * @return string representation of the value    */
specifier|public
name|String
name|toValue
parameter_list|()
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|CHAR
case|:
comment|// We want 'It''s superman!', not _ISO-8859-1'It''s superman!'
return|return
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
return|;
default|default:
return|return
name|value
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|public
name|void
name|validate
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
name|validator
operator|.
name|validateLiteral
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|public
parameter_list|<
name|R
parameter_list|>
name|R
name|accept
parameter_list|(
name|SqlVisitor
argument_list|<
name|R
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|equalsDeep
parameter_list|(
name|SqlNode
name|node
parameter_list|,
name|boolean
name|fail
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|instanceof
name|SqlLiteral
operator|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
name|this
operator|+
literal|"!="
operator|+
name|node
assert|;
return|return
literal|false
return|;
block|}
name|SqlLiteral
name|that
init|=
operator|(
name|SqlLiteral
operator|)
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|equals
argument_list|(
name|that
argument_list|)
condition|)
block|{
assert|assert
operator|!
name|fail
operator|:
name|this
operator|+
literal|"!="
operator|+
name|node
assert|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|SqlMonotonicity
name|getMonotonicity
parameter_list|(
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
return|return
name|SqlMonotonicity
operator|.
name|CONSTANT
return|;
block|}
comment|/**    * Creates a NULL literal.    *    *<p>There's no singleton constant for a NULL literal. Instead, nulls must    * be instantiated via createNull(), because different instances have    * different context-dependent types.    */
specifier|public
specifier|static
name|SqlLiteral
name|createNull
parameter_list|(
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlLiteral
argument_list|(
literal|null
argument_list|,
name|SqlTypeName
operator|.
name|NULL
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Creates a boolean literal.    */
specifier|public
specifier|static
name|SqlLiteral
name|createBoolean
parameter_list|(
name|boolean
name|b
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
name|b
condition|?
operator|new
name|SqlLiteral
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|,
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|,
name|pos
argument_list|)
else|:
operator|new
name|SqlLiteral
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|,
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|,
name|pos
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|SqlLiteral
name|createUnknown
parameter_list|(
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlLiteral
argument_list|(
literal|null
argument_list|,
name|SqlTypeName
operator|.
name|BOOLEAN
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Creates a literal which represents a parser symbol, for example the    *<code>TRAILING</code> keyword in the call<code>Trim(TRAILING 'x' FROM    * 'Hello world!')</code>.    *    * @see #symbolValue()    */
specifier|public
specifier|static
name|SqlLiteral
name|createSymbol
parameter_list|(
name|SqlLiteral
operator|.
name|SqlSymbol
name|o
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlLiteral
argument_list|(
name|o
argument_list|,
name|SqlTypeName
operator|.
name|SYMBOL
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Creates a literal which represents a sample specification.    */
specifier|public
specifier|static
name|SqlLiteral
name|createSample
parameter_list|(
name|SqlSampleSpec
name|sampleSpec
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlLiteral
argument_list|(
name|sampleSpec
argument_list|,
name|SqlTypeName
operator|.
name|SYMBOL
argument_list|,
name|pos
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|SqlLiteral
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SqlLiteral
name|that
init|=
operator|(
name|SqlLiteral
operator|)
name|obj
decl_stmt|;
return|return
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
operator|.
name|equal
argument_list|(
name|value
argument_list|,
name|that
operator|.
name|value
argument_list|)
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|value
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|value
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**    * Returns the integer value of this literal.    *    * @param exact Whether the value has to be exact. If true, and the literal    *              is a fraction (e.g. 3.14), throws. If false, discards the    *              fractional part of the value.    * @return Integer value of this literal    */
specifier|public
name|int
name|intValue
parameter_list|(
name|boolean
name|exact
parameter_list|)
block|{
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
name|BigDecimal
name|bd
init|=
operator|(
name|BigDecimal
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|exact
condition|)
block|{
try|try
block|{
return|return
name|bd
operator|.
name|intValueExact
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|e
parameter_list|)
block|{
throw|throw
name|SqlUtil
operator|.
name|newContextException
argument_list|(
name|getParserPosition
argument_list|()
argument_list|,
name|RESOURCE
operator|.
name|numberLiteralOutOfRange
argument_list|(
name|bd
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|bd
operator|.
name|intValue
argument_list|()
return|;
block|}
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the long value of this literal.    *    * @param exact Whether the value has to be exact. If true, and the literal    *              is a fraction (e.g. 3.14), throws. If false, discards the    *              fractional part of the value.    * @return Long value of this literal    */
specifier|public
name|long
name|longValue
parameter_list|(
name|boolean
name|exact
parameter_list|)
block|{
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
name|BigDecimal
name|bd
init|=
operator|(
name|BigDecimal
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|exact
condition|)
block|{
try|try
block|{
return|return
name|bd
operator|.
name|longValueExact
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|e
parameter_list|)
block|{
throw|throw
name|SqlUtil
operator|.
name|newContextException
argument_list|(
name|getParserPosition
argument_list|()
argument_list|,
name|RESOURCE
operator|.
name|numberLiteralOutOfRange
argument_list|(
name|bd
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|bd
operator|.
name|longValue
argument_list|()
return|;
block|}
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns sign of value.    *    * @return -1, 0 or 1    */
specifier|public
name|int
name|signum
parameter_list|()
block|{
return|return
name|bigDecimalValue
argument_list|()
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
return|;
block|}
comment|/**    * Returns a numeric literal's value as a {@link BigDecimal}.    */
specifier|public
name|BigDecimal
name|bigDecimalValue
parameter_list|()
block|{
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
return|return
operator|(
name|BigDecimal
operator|)
name|value
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
block|}
block|}
specifier|public
name|String
name|getStringValue
parameter_list|()
block|{
return|return
operator|(
operator|(
name|NlsString
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
specifier|public
name|void
name|unparse
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|writer
operator|.
name|keyword
argument_list|(
name|value
operator|==
literal|null
condition|?
literal|"UNKNOWN"
else|:
operator|(
name|Boolean
operator|)
name|value
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NULL
case|:
name|writer
operator|.
name|keyword
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
case|case
name|DECIMAL
case|:
case|case
name|DOUBLE
case|:
case|case
name|BINARY
case|:
comment|// should be handled in subtype
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|typeName
argument_list|)
throw|;
case|case
name|SYMBOL
case|:
if|if
condition|(
name|value
operator|instanceof
name|Enum
condition|)
block|{
name|Enum
name|enumVal
init|=
operator|(
name|Enum
operator|)
name|value
decl_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
name|enumVal
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|keyword
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|writer
operator|.
name|literal
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|RelDataType
name|createSqlType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|)
block|{
name|BitString
name|bitString
decl_stmt|;
switch|switch
condition|(
name|typeName
condition|)
block|{
case|case
name|NULL
case|:
case|case
name|BOOLEAN
case|:
name|RelDataType
name|ret
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
name|ret
operator|=
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|ret
argument_list|,
literal|null
operator|==
name|value
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
case|case
name|BINARY
case|:
name|bitString
operator|=
operator|(
name|BitString
operator|)
name|value
expr_stmt|;
name|int
name|bitCount
init|=
name|bitString
operator|.
name|getBitCount
argument_list|()
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|BINARY
argument_list|,
name|bitCount
operator|/
literal|8
argument_list|)
return|;
case|case
name|CHAR
case|:
name|NlsString
name|string
init|=
operator|(
name|NlsString
operator|)
name|value
decl_stmt|;
name|Charset
name|charset
init|=
name|string
operator|.
name|getCharset
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|charset
condition|)
block|{
name|charset
operator|=
name|typeFactory
operator|.
name|getDefaultCharset
argument_list|()
expr_stmt|;
block|}
name|SqlCollation
name|collation
init|=
name|string
operator|.
name|getCollation
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|collation
condition|)
block|{
name|collation
operator|=
name|SqlCollation
operator|.
name|COERCIBLE
expr_stmt|;
block|}
name|RelDataType
name|type
init|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|CHAR
argument_list|,
name|string
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|type
operator|=
name|typeFactory
operator|.
name|createTypeWithCharsetAndCollation
argument_list|(
name|type
argument_list|,
name|charset
argument_list|,
name|collation
argument_list|)
expr_stmt|;
return|return
name|type
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
name|SqlIntervalLiteral
operator|.
name|IntervalValue
name|intervalValue
init|=
operator|(
name|SqlIntervalLiteral
operator|.
name|IntervalValue
operator|)
name|value
decl_stmt|;
return|return
name|typeFactory
operator|.
name|createSqlIntervalType
argument_list|(
name|intervalValue
operator|.
name|getIntervalQualifier
argument_list|()
argument_list|)
return|;
case|case
name|SYMBOL
case|:
return|return
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|SYMBOL
argument_list|)
return|;
case|case
name|INTEGER
case|:
comment|// handled in derived class
case|case
name|TIME
case|:
comment|// handled in derived class
case|case
name|VARCHAR
case|:
comment|// should never happen
case|case
name|VARBINARY
case|:
comment|// should never happen
default|default:
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|toString
argument_list|()
operator|+
literal|", operand="
operator|+
name|value
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|SqlDateLiteral
name|createDate
parameter_list|(
name|Calendar
name|calendar
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlDateLiteral
argument_list|(
name|calendar
argument_list|,
name|pos
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|SqlTimestampLiteral
name|createTimestamp
parameter_list|(
name|Calendar
name|calendar
parameter_list|,
name|int
name|precision
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlTimestampLiteral
argument_list|(
name|calendar
argument_list|,
name|precision
argument_list|,
literal|false
argument_list|,
name|pos
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|SqlTimeLiteral
name|createTime
parameter_list|(
name|Calendar
name|calendar
parameter_list|,
name|int
name|precision
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlTimeLiteral
argument_list|(
name|calendar
argument_list|,
name|precision
argument_list|,
literal|false
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Creates an interval literal.    *    * @param intervalStr       input string of '1:23:04'    * @param intervalQualifier describes the interval type and precision    * @param pos               Parser position    */
specifier|public
specifier|static
name|SqlIntervalLiteral
name|createInterval
parameter_list|(
name|int
name|sign
parameter_list|,
name|String
name|intervalStr
parameter_list|,
name|SqlIntervalQualifier
name|intervalQualifier
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|SqlTypeName
name|typeName
init|=
name|intervalQualifier
operator|.
name|isYearMonth
argument_list|()
condition|?
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
else|:
name|SqlTypeName
operator|.
name|INTERVAL_DAY_TIME
decl_stmt|;
return|return
operator|new
name|SqlIntervalLiteral
argument_list|(
name|sign
argument_list|,
name|intervalStr
argument_list|,
name|intervalQualifier
argument_list|,
name|typeName
argument_list|,
name|pos
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|SqlNumericLiteral
name|createNegative
parameter_list|(
name|SqlNumericLiteral
name|num
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
return|return
operator|new
name|SqlNumericLiteral
argument_list|(
operator|(
operator|(
name|BigDecimal
operator|)
name|num
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|negate
argument_list|()
argument_list|,
name|num
operator|.
name|getPrec
argument_list|()
argument_list|,
name|num
operator|.
name|getScale
argument_list|()
argument_list|,
name|num
operator|.
name|isExact
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|SqlNumericLiteral
name|createExactNumeric
parameter_list|(
name|String
name|s
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|BigDecimal
name|value
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|int
name|scale
decl_stmt|;
name|int
name|i
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|!=
name|i
operator|)
condition|)
block|{
name|value
operator|=
name|SqlParserUtil
operator|.
name|parseDecimal
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|scale
operator|=
name|s
operator|.
name|length
argument_list|()
operator|-
name|i
operator|-
literal|1
expr_stmt|;
assert|assert
name|scale
operator|==
name|value
operator|.
name|scale
argument_list|()
operator|:
name|s
assert|;
name|prec
operator|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
operator|==
name|i
operator|)
condition|)
block|{
name|value
operator|=
name|SqlParserUtil
operator|.
name|parseInteger
argument_list|(
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|scale
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|SqlParserUtil
operator|.
name|parseInteger
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|scale
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|SqlNumericLiteral
argument_list|(
name|value
argument_list|,
name|prec
argument_list|,
name|scale
argument_list|,
literal|true
argument_list|,
name|pos
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|SqlNumericLiteral
name|createApproxNumeric
parameter_list|(
name|String
name|s
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|BigDecimal
name|value
init|=
name|SqlParserUtil
operator|.
name|parseDecimal
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlNumericLiteral
argument_list|(
name|value
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Creates a literal like X'ABAB'. Although it matters when we derive a type    * for this beastie, we don't care at this point whether the number of    * hexits is odd or even.    */
specifier|public
specifier|static
name|SqlBinaryStringLiteral
name|createBinaryString
parameter_list|(
name|String
name|s
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|BitString
name|bits
decl_stmt|;
try|try
block|{
name|bits
operator|=
name|BitString
operator|.
name|createFromHexString
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
name|SqlUtil
operator|.
name|newContextException
argument_list|(
name|pos
argument_list|,
name|RESOURCE
operator|.
name|binaryLiteralInvalid
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|SqlBinaryStringLiteral
argument_list|(
name|bits
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Creates a literal like X'ABAB' from an array of bytes.    *    * @param bytes Contents of binary literal    * @param pos   Parser position    * @return Binary string literal    */
specifier|public
specifier|static
name|SqlBinaryStringLiteral
name|createBinaryString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|BitString
name|bits
decl_stmt|;
try|try
block|{
name|bits
operator|=
name|BitString
operator|.
name|createFromBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
name|SqlUtil
operator|.
name|newContextException
argument_list|(
name|pos
argument_list|,
name|RESOURCE
operator|.
name|binaryLiteralInvalid
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|SqlBinaryStringLiteral
argument_list|(
name|bits
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Creates a string literal in the system character set.    *    * @param s   a string (without the sql single quotes)    * @param pos Parser position    */
specifier|public
specifier|static
name|SqlCharStringLiteral
name|createCharString
parameter_list|(
name|String
name|s
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
comment|// UnsupportedCharsetException not possible
return|return
name|createCharString
argument_list|(
name|s
argument_list|,
literal|null
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Creates a string literal, with optional character-set.    *    * @param s       a string (without the sql single quotes)    * @param charSet character set name, null means take system default    * @param pos     Parser position    * @return A string literal    * @throws UnsupportedCharsetException if charSet is not null but there is    *                                     no character set with that name in this    *                                     environment    */
specifier|public
specifier|static
name|SqlCharStringLiteral
name|createCharString
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|charSet
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
name|NlsString
name|slit
init|=
operator|new
name|NlsString
argument_list|(
name|s
argument_list|,
name|charSet
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|SqlCharStringLiteral
argument_list|(
name|slit
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Transforms this literal (which must be of type character) into a new one    * in which 4-digit Unicode escape sequences have been replaced with the    * corresponding Unicode characters.    *    * @param unicodeEscapeChar escape character (e.g. backslash) for Unicode    *                          numeric sequences; 0 implies no transformation    * @return transformed literal    */
specifier|public
name|SqlLiteral
name|unescapeUnicode
parameter_list|(
name|char
name|unicodeEscapeChar
parameter_list|)
block|{
if|if
condition|(
name|unicodeEscapeChar
operator|==
literal|0
condition|)
block|{
return|return
name|this
return|;
block|}
assert|assert
name|SqlTypeUtil
operator|.
name|inCharFamily
argument_list|(
name|getTypeName
argument_list|()
argument_list|)
assert|;
name|NlsString
name|ns
init|=
operator|(
name|NlsString
operator|)
name|value
decl_stmt|;
name|String
name|s
init|=
name|ns
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|s
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|unicodeEscapeChar
condition|)
block|{
if|if
condition|(
name|n
operator|>
operator|(
name|i
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|unicodeEscapeChar
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|unicodeEscapeChar
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|+
literal|5
operator|)
operator|>
name|n
condition|)
block|{
throw|throw
name|SqlUtil
operator|.
name|newContextException
argument_list|(
name|getParserPosition
argument_list|()
argument_list|,
name|RESOURCE
operator|.
name|unicodeEscapeMalformed
argument_list|(
name|i
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|String
name|u
init|=
name|s
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|int
name|v
decl_stmt|;
try|try
block|{
name|v
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|u
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
throw|throw
name|SqlUtil
operator|.
name|newContextException
argument_list|(
name|getParserPosition
argument_list|()
argument_list|,
name|RESOURCE
operator|.
name|unicodeEscapeMalformed
argument_list|(
name|i
argument_list|)
argument_list|)
throw|;
block|}
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
operator|(
name|v
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
comment|// skip hexits
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|ns
operator|=
operator|new
name|NlsString
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|,
name|ns
operator|.
name|getCharsetName
argument_list|()
argument_list|,
name|ns
operator|.
name|getCollation
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlCharStringLiteral
argument_list|(
name|ns
argument_list|,
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
comment|//~ Inner Interfaces -------------------------------------------------------
comment|/**    * A value must implement this interface if it is to be embedded as a    * SqlLiteral of type SYMBOL. If the class is an {@link Enum} it trivially    * implements this interface.    *    *<p>The {@link #toString()} method should return how the symbol should be    * unparsed, which is sometimes not the same as the enumerated value's name    * (e.g. "UNBOUNDED PRECEDING" versus "UnboundedPreceeding").    */
specifier|public
interface|interface
name|SqlSymbol
block|{
name|String
name|name
parameter_list|()
function_decl|;
name|int
name|ordinal
parameter_list|()
function_decl|;
block|}
block|}
end_class

begin_comment
comment|// End SqlLiteral.java
end_comment

end_unit

