begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|advise
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Quoting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * A simple parser that takes an incomplete and turn it into a syntactically  * correct statement. It is used in the SQL editor user-interface.  */
end_comment

begin_class
specifier|public
class|class
name|SqlSimpleParser
block|{
comment|//~ Enums ------------------------------------------------------------------
enum|enum
name|TokenType
block|{
comment|// keywords
name|SELECT
block|,
name|FROM
block|,
name|JOIN
block|,
name|ON
block|,
name|USING
block|,
name|WHERE
block|,
name|GROUP
block|,
name|HAVING
block|,
name|ORDER
block|,
name|BY
block|,
name|UNION
block|,
name|INTERSECT
block|,
name|EXCEPT
block|,
name|MINUS
block|,
comment|/**      * left parenthesis      */
name|LPAREN
block|{
specifier|public
name|String
name|sql
parameter_list|()
block|{
return|return
literal|"("
return|;
block|}
block|}
block|,
comment|/**      * right parenthesis      */
name|RPAREN
block|{
specifier|public
name|String
name|sql
parameter_list|()
block|{
return|return
literal|")"
return|;
block|}
block|}
block|,
comment|/**      * identifier, or indeed any miscellaneous sequence of characters      */
name|ID
block|,
comment|/**      * double-quoted identifier, e.g. "FOO""BAR"      */
name|DQID
block|,
comment|/**      * single-quoted string literal, e.g. 'foobar'      */
name|SQID
block|,
name|COMMENT
block|,
name|COMMA
block|{
specifier|public
name|String
name|sql
parameter_list|()
block|{
return|return
literal|","
return|;
block|}
block|}
block|,
comment|/**      * A token created by reducing an entire sub-query.      */
name|QUERY
block|;
specifier|public
name|String
name|sql
parameter_list|()
block|{
return|return
name|name
argument_list|()
return|;
block|}
block|}
comment|//~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|String
name|hintToken
decl_stmt|;
specifier|private
specifier|final
name|SqlParser
operator|.
name|Config
name|parserConfig
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a SqlSimpleParser    *    * @param hintToken Hint token    * @deprecated    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlSimpleParser
parameter_list|(
name|String
name|hintToken
parameter_list|)
block|{
name|this
argument_list|(
name|hintToken
argument_list|,
name|SqlParser
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a SqlSimpleParser    *    * @param hintToken Hint token    * @param parserConfig parser configuration    */
specifier|public
name|SqlSimpleParser
parameter_list|(
name|String
name|hintToken
parameter_list|,
name|SqlParser
operator|.
name|Config
name|parserConfig
parameter_list|)
block|{
name|this
operator|.
name|hintToken
operator|=
name|hintToken
expr_stmt|;
name|this
operator|.
name|parserConfig
operator|=
name|parserConfig
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Turns a partially completed or syntactically incorrect sql statement into    * a simplified, valid one that can be passed into getCompletionHints().    *    * @param sql    A partial or syntactically incorrect sql statement    * @param cursor to indicate column position in the query at which    *               completion hints need to be retrieved.    * @return a completed, valid (and possibly simplified SQL statement    */
specifier|public
name|String
name|simplifySql
parameter_list|(
name|String
name|sql
parameter_list|,
name|int
name|cursor
parameter_list|)
block|{
comment|// introduce the hint token into the sql at the cursor pos
if|if
condition|(
name|cursor
operator|>=
name|sql
operator|.
name|length
argument_list|()
condition|)
block|{
name|sql
operator|+=
literal|" "
operator|+
name|hintToken
operator|+
literal|" "
expr_stmt|;
block|}
else|else
block|{
name|String
name|left
init|=
name|sql
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|cursor
argument_list|)
decl_stmt|;
name|String
name|right
init|=
name|sql
operator|.
name|substring
argument_list|(
name|cursor
argument_list|)
decl_stmt|;
name|sql
operator|=
name|left
operator|+
literal|" "
operator|+
name|hintToken
operator|+
literal|" "
operator|+
name|right
expr_stmt|;
block|}
return|return
name|simplifySql
argument_list|(
name|sql
argument_list|)
return|;
block|}
comment|/**    * Turns a partially completed or syntactically incorrect sql statement into    * a simplified, valid one that can be validated    *    * @param sql A partial or syntactically incorrect sql statement    * @return a completed, valid (and possibly simplified) SQL statement    */
specifier|public
name|String
name|simplifySql
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|Tokenizer
name|tokenizer
init|=
operator|new
name|Tokenizer
argument_list|(
name|sql
argument_list|,
name|hintToken
argument_list|,
name|parserConfig
operator|.
name|quoting
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Token
name|token
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|COMMENT
condition|)
block|{
comment|// ignore comments
continue|continue;
block|}
name|list
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
comment|// Gather consecutive sub-sequences of tokens into sub-queries.
name|List
argument_list|<
name|Token
argument_list|>
name|outList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|consumeQuery
argument_list|(
name|list
operator|.
name|listIterator
argument_list|()
argument_list|,
name|outList
argument_list|)
expr_stmt|;
comment|// Simplify.
name|Query
operator|.
name|simplifyList
argument_list|(
name|outList
argument_list|,
name|hintToken
argument_list|)
expr_stmt|;
comment|// Convert to string.
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|k
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|outList
control|)
block|{
if|if
condition|(
operator|++
name|k
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|token
operator|.
name|unparse
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|consumeQuery
parameter_list|(
name|ListIterator
argument_list|<
name|Token
argument_list|>
name|iter
parameter_list|,
name|List
argument_list|<
name|Token
argument_list|>
name|outList
parameter_list|)
block|{
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|consumeSelect
argument_list|(
name|iter
argument_list|,
name|outList
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Token
name|token
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|MINUS
case|:
name|outList
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|token
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|ID
operator|)
operator|&&
literal|"ALL"
operator|.
name|equalsIgnoreCase
argument_list|(
name|token
operator|.
name|s
argument_list|)
condition|)
block|{
name|outList
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iter
operator|.
name|previous
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Combine SELECT ... UNION SELECT..., so keep trying consumeSelect
break|break;
default|default:
comment|// Unknown token detected => end of query detected
name|iter
operator|.
name|previous
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|consumeSelect
parameter_list|(
name|ListIterator
argument_list|<
name|Token
argument_list|>
name|iter
parameter_list|,
name|List
argument_list|<
name|Token
argument_list|>
name|outList
parameter_list|)
block|{
name|boolean
name|isQuery
init|=
literal|false
decl_stmt|;
name|int
name|start
init|=
name|outList
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|>
name|subQueryList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|loop
label|:
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Token
name|token
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|subQueryList
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|LPAREN
case|:
name|consumeQuery
argument_list|(
name|iter
argument_list|,
name|subQueryList
argument_list|)
expr_stmt|;
break|break;
case|case
name|RPAREN
case|:
if|if
condition|(
name|isQuery
condition|)
block|{
name|subQueryList
operator|.
name|remove
argument_list|(
name|subQueryList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break
name|loop
break|;
case|case
name|SELECT
case|:
name|isQuery
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
case|case
name|MINUS
case|:
name|subQueryList
operator|.
name|remove
argument_list|(
name|subQueryList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iter
operator|.
name|previous
argument_list|()
expr_stmt|;
break|break
name|loop
break|;
default|default:
block|}
block|}
comment|// Fell off end of list. Pretend we saw the required right-paren.
if|if
condition|(
name|isQuery
condition|)
block|{
name|outList
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|outList
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outList
operator|.
name|add
argument_list|(
operator|new
name|Query
argument_list|(
name|subQueryList
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outList
operator|.
name|size
argument_list|()
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|outList
operator|.
name|get
argument_list|(
name|outList
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
operator|.
name|type
operator|==
name|TokenType
operator|.
name|LPAREN
operator|)
condition|)
block|{
name|outList
operator|.
name|add
argument_list|(
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|RPAREN
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// not a query - just a parenthesized expr
name|outList
operator|.
name|addAll
argument_list|(
name|subQueryList
argument_list|)
expr_stmt|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
specifier|public
specifier|static
class|class
name|Tokenizer
block|{
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TokenType
argument_list|>
name|TOKEN_TYPES
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
for|for
control|(
name|TokenType
name|type
range|:
name|TokenType
operator|.
name|values
argument_list|()
control|)
block|{
name|TOKEN_TYPES
operator|.
name|put
argument_list|(
name|type
operator|.
name|name
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|String
name|sql
decl_stmt|;
specifier|private
specifier|final
name|String
name|hintToken
decl_stmt|;
specifier|private
specifier|final
name|char
name|openQuote
decl_stmt|;
specifier|private
name|int
name|pos
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|Tokenizer
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|hintToken
parameter_list|)
block|{
name|this
argument_list|(
name|sql
argument_list|,
name|hintToken
argument_list|,
name|Quoting
operator|.
name|DOUBLE_QUOTE
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Tokenizer
parameter_list|(
name|String
name|sql
parameter_list|,
name|String
name|hintToken
parameter_list|,
name|Quoting
name|quoting
parameter_list|)
block|{
name|this
operator|.
name|sql
operator|=
name|sql
expr_stmt|;
name|this
operator|.
name|hintToken
operator|=
name|hintToken
expr_stmt|;
name|this
operator|.
name|openQuote
operator|=
name|quoting
operator|.
name|string
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|Token
name|parseQuotedIdentifier
parameter_list|()
block|{
comment|// Parse double-quoted identifier.
name|start
operator|=
name|pos
expr_stmt|;
operator|++
name|pos
expr_stmt|;
name|char
name|closeQuote
init|=
name|openQuote
operator|==
literal|'['
condition|?
literal|']'
else|:
name|openQuote
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|sql
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|sql
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
operator|++
name|pos
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|closeQuote
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|sql
operator|.
name|length
argument_list|()
operator|&&
name|sql
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
operator|==
name|closeQuote
condition|)
block|{
comment|// Double close means escaped closing quote is a part of identifer
operator|++
name|pos
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
name|String
name|match
init|=
name|sql
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|.
name|startsWith
argument_list|(
name|openQuote
operator|+
literal|" "
operator|+
name|hintToken
operator|+
literal|" "
argument_list|)
condition|)
block|{
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|ID
argument_list|,
name|hintToken
argument_list|)
return|;
block|}
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|DQID
argument_list|,
name|match
argument_list|)
return|;
block|}
specifier|public
name|Token
name|nextToken
parameter_list|()
block|{
while|while
condition|(
name|pos
operator|<
name|sql
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c
init|=
name|sql
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
specifier|final
name|String
name|match
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|','
case|:
operator|++
name|pos
expr_stmt|;
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|COMMA
argument_list|)
return|;
case|case
literal|'('
case|:
operator|++
name|pos
expr_stmt|;
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|LPAREN
argument_list|)
return|;
case|case
literal|')'
case|:
operator|++
name|pos
expr_stmt|;
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|RPAREN
argument_list|)
return|;
case|case
literal|'\''
case|:
comment|// Parse single-quoted identifier.
name|start
operator|=
name|pos
expr_stmt|;
operator|++
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|sql
operator|.
name|length
argument_list|()
condition|)
block|{
name|c
operator|=
name|sql
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
operator|++
name|pos
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|sql
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c1
init|=
name|sql
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'\''
condition|)
block|{
comment|// encountered consecutive
comment|// single-quotes; still in identifier
operator|++
name|pos
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
name|match
operator|=
name|sql
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|SQID
argument_list|,
name|match
argument_list|)
return|;
case|case
literal|'/'
case|:
comment|// possible start of '/*' or '//' comment
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|sql
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|c1
init|=
name|sql
operator|.
name|charAt
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'*'
condition|)
block|{
name|int
name|end
init|=
name|sql
operator|.
name|indexOf
argument_list|(
literal|"*/"
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
block|{
name|end
operator|=
name|sql
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|end
operator|+=
literal|"*/"
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|pos
operator|=
name|end
expr_stmt|;
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|COMMENT
argument_list|)
return|;
block|}
if|if
condition|(
name|c1
operator|==
literal|'/'
condition|)
block|{
name|pos
operator|=
name|indexOfLineEnd
argument_list|(
name|sql
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|COMMENT
argument_list|)
return|;
block|}
block|}
comment|// fall through
case|case
literal|'-'
case|:
comment|// possible start of '--' comment
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|pos
operator|+
literal|1
operator|<
name|sql
operator|.
name|length
argument_list|()
operator|&&
name|sql
operator|.
name|charAt
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|pos
operator|=
name|indexOfLineEnd
argument_list|(
name|sql
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|COMMENT
argument_list|)
return|;
block|}
comment|// fall through
default|default:
if|if
condition|(
name|c
operator|==
name|openQuote
condition|)
block|{
return|return
name|parseQuotedIdentifier
argument_list|()
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|++
name|pos
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// Probably a letter or digit. Start an identifier.
comment|// Other characters, e.g. *, ! are also included
comment|// in identifiers.
name|int
name|start
init|=
name|pos
decl_stmt|;
operator|++
name|pos
expr_stmt|;
name|loop
label|:
while|while
condition|(
name|pos
operator|<
name|sql
operator|.
name|length
argument_list|()
condition|)
block|{
name|c
operator|=
name|sql
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'/'
case|:
case|case
literal|','
case|:
break|break
name|loop
break|;
default|default:
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
break|break
name|loop
break|;
block|}
else|else
block|{
operator|++
name|pos
expr_stmt|;
block|}
block|}
block|}
name|String
name|name
init|=
name|sql
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|TokenType
name|tokenType
init|=
name|TOKEN_TYPES
operator|.
name|get
argument_list|(
name|name
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenType
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|IdToken
argument_list|(
name|TokenType
operator|.
name|ID
argument_list|,
name|name
argument_list|)
return|;
block|}
else|else
block|{
comment|// keyword, e.g. SELECT, FROM, WHERE
return|return
operator|new
name|Token
argument_list|(
name|tokenType
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|int
name|indexOfLineEnd
parameter_list|(
name|String
name|sql
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|length
init|=
name|sql
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|length
condition|)
block|{
name|char
name|c
init|=
name|sql
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
return|return
name|i
return|;
default|default:
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|Token
block|{
specifier|private
specifier|final
name|TokenType
name|type
decl_stmt|;
specifier|private
specifier|final
name|String
name|s
decl_stmt|;
name|Token
parameter_list|(
name|TokenType
name|tokenType
parameter_list|)
block|{
name|this
argument_list|(
name|tokenType
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|Token
parameter_list|(
name|TokenType
name|type
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|s
operator|=
name|s
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|(
name|s
operator|==
literal|null
operator|)
condition|?
name|type
operator|.
name|toString
argument_list|()
else|:
operator|(
name|type
operator|+
literal|"("
operator|+
name|s
operator|+
literal|")"
operator|)
return|;
block|}
specifier|public
name|void
name|unparse
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|type
operator|.
name|sql
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|IdToken
extends|extends
name|Token
block|{
specifier|public
name|IdToken
parameter_list|(
name|TokenType
name|type
parameter_list|,
name|String
name|s
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|,
name|s
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|type
operator|==
name|TokenType
operator|.
name|DQID
operator|)
operator|||
operator|(
name|type
operator|==
name|TokenType
operator|.
name|ID
operator|)
assert|;
block|}
block|}
specifier|static
class|class
name|Query
extends|extends
name|Token
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Token
argument_list|>
name|tokenList
decl_stmt|;
name|Query
parameter_list|(
name|List
argument_list|<
name|Token
argument_list|>
name|tokenList
parameter_list|)
block|{
name|super
argument_list|(
name|TokenType
operator|.
name|QUERY
argument_list|)
expr_stmt|;
name|this
operator|.
name|tokenList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tokenList
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|unparse
parameter_list|(
name|StringBuilder
name|buf
parameter_list|)
block|{
name|int
name|k
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|tokenList
control|)
block|{
if|if
condition|(
operator|++
name|k
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|token
operator|.
name|unparse
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|simplifyList
parameter_list|(
name|List
argument_list|<
name|Token
argument_list|>
name|list
parameter_list|,
name|String
name|hintToken
parameter_list|)
block|{
comment|// Simplify
comment|//   SELECT * FROM t UNION ALL SELECT * FROM u WHERE ^
comment|// to
comment|//   SELECT * FROM u WHERE ^
for|for
control|(
name|Token
name|token
range|:
name|list
control|)
block|{
if|if
condition|(
name|token
operator|instanceof
name|Query
condition|)
block|{
name|Query
name|query
init|=
operator|(
name|Query
operator|)
name|token
decl_stmt|;
if|if
condition|(
name|query
operator|.
name|contains
argument_list|(
name|hintToken
argument_list|)
condition|)
block|{
name|list
operator|.
name|clear
argument_list|()
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|query
operator|.
name|simplify
argument_list|(
name|hintToken
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
specifier|public
name|Query
name|simplify
parameter_list|(
name|String
name|hintToken
parameter_list|)
block|{
name|TokenType
name|clause
init|=
name|TokenType
operator|.
name|SELECT
decl_stmt|;
name|TokenType
name|foundInClause
init|=
literal|null
decl_stmt|;
name|Query
name|foundInSubQuery
init|=
literal|null
decl_stmt|;
name|TokenType
name|majorClause
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hintToken
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Token
name|token
range|:
name|tokenList
control|)
block|{
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|ID
case|:
if|if
condition|(
name|hintToken
operator|.
name|equals
argument_list|(
name|token
operator|.
name|s
argument_list|)
condition|)
block|{
name|foundInClause
operator|=
name|clause
expr_stmt|;
block|}
break|break;
case|case
name|SELECT
case|:
case|case
name|FROM
case|:
case|case
name|WHERE
case|:
case|case
name|GROUP
case|:
case|case
name|HAVING
case|:
case|case
name|ORDER
case|:
name|majorClause
operator|=
name|token
operator|.
name|type
expr_stmt|;
comment|// fall through
case|case
name|JOIN
case|:
case|case
name|USING
case|:
case|case
name|ON
case|:
name|clause
operator|=
name|token
operator|.
name|type
expr_stmt|;
break|break;
case|case
name|COMMA
case|:
if|if
condition|(
name|majorClause
operator|==
name|TokenType
operator|.
name|FROM
condition|)
block|{
comment|// comma inside from clause
name|clause
operator|=
name|TokenType
operator|.
name|FROM
expr_stmt|;
block|}
break|break;
case|case
name|QUERY
case|:
if|if
condition|(
operator|(
operator|(
name|Query
operator|)
name|token
operator|)
operator|.
name|contains
argument_list|(
name|hintToken
argument_list|)
condition|)
block|{
name|foundInClause
operator|=
name|clause
expr_stmt|;
name|foundInSubQuery
operator|=
operator|(
name|Query
operator|)
name|token
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
name|foundInClause
operator|=
name|TokenType
operator|.
name|QUERY
expr_stmt|;
block|}
if|if
condition|(
name|foundInClause
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|foundInClause
condition|)
block|{
case|case
name|SELECT
case|:
name|purgeSelectListExcept
argument_list|(
name|hintToken
argument_list|)
expr_stmt|;
name|purgeWhere
argument_list|()
expr_stmt|;
name|purgeOrderBy
argument_list|()
expr_stmt|;
break|break;
case|case
name|FROM
case|:
case|case
name|JOIN
case|:
comment|// See comments against ON/USING.
name|purgeSelect
argument_list|()
expr_stmt|;
name|purgeFromExcept
argument_list|(
name|hintToken
argument_list|)
expr_stmt|;
name|purgeWhere
argument_list|()
expr_stmt|;
name|purgeGroupByHaving
argument_list|()
expr_stmt|;
name|purgeOrderBy
argument_list|()
expr_stmt|;
break|break;
case|case
name|ON
case|:
case|case
name|USING
case|:
comment|// We need to treat expressions in FROM and JOIN
comment|// differently than ON and USING. Consider
comment|//     FROM t1 JOIN t2 ON b1 JOIN t3 USING (c2)
comment|// t1, t2, t3 occur in the FROM clause, and do not depend
comment|// on anything; b1 and c2 occur in ON scope, and depend
comment|// on the FROM clause
name|purgeSelect
argument_list|()
expr_stmt|;
name|purgeWhere
argument_list|()
expr_stmt|;
name|purgeOrderBy
argument_list|()
expr_stmt|;
break|break;
case|case
name|WHERE
case|:
name|purgeSelect
argument_list|()
expr_stmt|;
name|purgeGroupByHaving
argument_list|()
expr_stmt|;
name|purgeOrderBy
argument_list|()
expr_stmt|;
break|break;
case|case
name|GROUP
case|:
case|case
name|HAVING
case|:
name|purgeSelect
argument_list|()
expr_stmt|;
name|purgeWhere
argument_list|()
expr_stmt|;
name|purgeOrderBy
argument_list|()
expr_stmt|;
break|break;
case|case
name|ORDER
case|:
name|purgeWhere
argument_list|()
expr_stmt|;
break|break;
case|case
name|QUERY
case|:
comment|// Indicates that the expression to be simplified is
comment|// outside this sub-query. Preserve a simplified SELECT
comment|// clause.
comment|// It might be a good idea to purge select expressions, however
comment|// purgeSelectExprsKeepAliases might end up with<<0 as "*">> which is not valid.
comment|// purgeSelectExprsKeepAliases();
name|purgeWhere
argument_list|()
expr_stmt|;
name|purgeGroupByHaving
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|// Simplify sub-queries.
for|for
control|(
name|Token
name|token
range|:
name|tokenList
control|)
block|{
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|QUERY
case|:
block|{
name|Query
name|query
init|=
operator|(
name|Query
operator|)
name|token
decl_stmt|;
name|query
operator|.
name|simplify
argument_list|(
operator|(
name|query
operator|==
name|foundInSubQuery
operator|)
condition|?
name|hintToken
else|:
literal|null
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|this
return|;
block|}
specifier|private
name|void
name|purgeSelectListExcept
parameter_list|(
name|String
name|hintToken
parameter_list|)
block|{
name|List
argument_list|<
name|Token
argument_list|>
name|sublist
init|=
name|findClause
argument_list|(
name|TokenType
operator|.
name|SELECT
argument_list|)
decl_stmt|;
name|int
name|parenCount
init|=
literal|0
decl_stmt|;
name|int
name|itemStart
init|=
literal|1
decl_stmt|;
name|int
name|itemEnd
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sublist
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Token
name|token
init|=
name|sublist
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|LPAREN
case|:
operator|++
name|parenCount
expr_stmt|;
break|break;
case|case
name|RPAREN
case|:
operator|--
name|parenCount
expr_stmt|;
break|break;
case|case
name|COMMA
case|:
if|if
condition|(
name|parenCount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found
condition|)
block|{
name|itemEnd
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|itemStart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ID
case|:
if|if
condition|(
name|hintToken
operator|.
name|equals
argument_list|(
name|token
operator|.
name|s
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|itemEnd
operator|<
literal|0
condition|)
block|{
name|itemEnd
operator|=
name|sublist
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|Token
argument_list|>
name|selectItem
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|sublist
operator|.
name|subList
argument_list|(
name|itemStart
argument_list|,
name|itemEnd
argument_list|)
argument_list|)
decl_stmt|;
name|Token
name|select
init|=
name|sublist
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sublist
operator|.
name|add
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|sublist
operator|.
name|addAll
argument_list|(
name|selectItem
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|purgeSelect
parameter_list|()
block|{
name|List
argument_list|<
name|Token
argument_list|>
name|sublist
init|=
name|findClause
argument_list|(
name|TokenType
operator|.
name|SELECT
argument_list|)
decl_stmt|;
name|Token
name|select
init|=
name|sublist
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sublist
operator|.
name|add
argument_list|(
name|select
argument_list|)
expr_stmt|;
name|sublist
operator|.
name|add
argument_list|(
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|ID
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|purgeSelectExprsKeepAliases
parameter_list|()
block|{
name|List
argument_list|<
name|Token
argument_list|>
name|sublist
init|=
name|findClause
argument_list|(
name|TokenType
operator|.
name|SELECT
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|>
name|newSelectClause
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|newSelectClause
operator|.
name|add
argument_list|(
name|sublist
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|itemStart
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|sublist
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Token
name|token
init|=
name|sublist
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|sublist
operator|.
name|size
argument_list|()
operator|)
operator|||
operator|(
name|sublist
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|type
operator|==
name|TokenType
operator|.
name|COMMA
operator|)
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|ID
condition|)
block|{
comment|// This might produce<<0 as "a.x+b.y">>, or<<0 as "*">>, or even<<0 as "a.*">>
name|newSelectClause
operator|.
name|add
argument_list|(
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|ID
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|newSelectClause
operator|.
name|add
argument_list|(
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|ID
argument_list|,
literal|"AS"
argument_list|)
argument_list|)
expr_stmt|;
name|newSelectClause
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newSelectClause
operator|.
name|addAll
argument_list|(
name|sublist
operator|.
name|subList
argument_list|(
name|itemStart
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|itemStart
operator|=
name|i
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|sublist
operator|.
name|size
argument_list|()
condition|)
block|{
name|newSelectClause
operator|.
name|add
argument_list|(
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|COMMA
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sublist
operator|.
name|addAll
argument_list|(
name|newSelectClause
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|purgeFromExcept
parameter_list|(
name|String
name|hintToken
parameter_list|)
block|{
name|List
argument_list|<
name|Token
argument_list|>
name|sublist
init|=
name|findClause
argument_list|(
name|TokenType
operator|.
name|FROM
argument_list|)
decl_stmt|;
name|int
name|itemStart
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|itemEnd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|joinCount
init|=
literal|0
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sublist
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Token
name|token
init|=
name|sublist
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|QUERY
case|:
if|if
condition|(
operator|(
operator|(
name|Query
operator|)
name|token
operator|)
operator|.
name|contains
argument_list|(
name|hintToken
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|JOIN
case|:
operator|++
name|joinCount
expr_stmt|;
comment|// fall through
case|case
name|FROM
case|:
case|case
name|ON
case|:
case|case
name|COMMA
case|:
if|if
condition|(
name|found
condition|)
block|{
name|itemEnd
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|itemStart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|ID
case|:
if|if
condition|(
name|hintToken
operator|.
name|equals
argument_list|(
name|token
operator|.
name|s
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// Don't simplify a FROM clause containing a JOIN: we lose help
comment|// with syntax.
if|if
condition|(
name|found
operator|&&
operator|(
name|joinCount
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|itemEnd
operator|==
operator|-
literal|1
condition|)
block|{
name|itemEnd
operator|=
name|sublist
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|Token
argument_list|>
name|fromItem
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|sublist
operator|.
name|subList
argument_list|(
name|itemStart
argument_list|,
name|itemEnd
argument_list|)
argument_list|)
decl_stmt|;
name|Token
name|from
init|=
name|sublist
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sublist
operator|.
name|add
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|sublist
operator|.
name|addAll
argument_list|(
name|fromItem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sublist
operator|.
name|get
argument_list|(
name|sublist
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|type
operator|==
name|TokenType
operator|.
name|ON
condition|)
block|{
name|sublist
operator|.
name|add
argument_list|(
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|ID
argument_list|,
literal|"TRUE"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|purgeWhere
parameter_list|()
block|{
name|List
argument_list|<
name|Token
argument_list|>
name|sublist
init|=
name|findClause
argument_list|(
name|TokenType
operator|.
name|WHERE
argument_list|)
decl_stmt|;
if|if
condition|(
name|sublist
operator|!=
literal|null
condition|)
block|{
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|purgeGroupByHaving
parameter_list|()
block|{
name|List
argument_list|<
name|Token
argument_list|>
name|sublist
init|=
name|findClause
argument_list|(
name|TokenType
operator|.
name|GROUP
argument_list|)
decl_stmt|;
if|if
condition|(
name|sublist
operator|!=
literal|null
condition|)
block|{
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|sublist
operator|=
name|findClause
argument_list|(
name|TokenType
operator|.
name|HAVING
argument_list|)
expr_stmt|;
if|if
condition|(
name|sublist
operator|!=
literal|null
condition|)
block|{
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|purgeOrderBy
parameter_list|()
block|{
name|List
argument_list|<
name|Token
argument_list|>
name|sublist
init|=
name|findClause
argument_list|(
name|TokenType
operator|.
name|ORDER
argument_list|)
decl_stmt|;
if|if
condition|(
name|sublist
operator|!=
literal|null
condition|)
block|{
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Token
argument_list|>
name|findClause
parameter_list|(
name|TokenType
name|keyword
parameter_list|)
block|{
name|int
name|start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|k
init|=
operator|-
literal|1
decl_stmt|;
name|EnumSet
argument_list|<
name|TokenType
argument_list|>
name|clauses
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|TokenType
operator|.
name|SELECT
argument_list|,
name|TokenType
operator|.
name|FROM
argument_list|,
name|TokenType
operator|.
name|WHERE
argument_list|,
name|TokenType
operator|.
name|GROUP
argument_list|,
name|TokenType
operator|.
name|HAVING
argument_list|,
name|TokenType
operator|.
name|ORDER
argument_list|)
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|tokenList
control|)
block|{
operator|++
name|k
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|keyword
condition|)
block|{
name|start
operator|=
name|k
expr_stmt|;
block|}
if|else if
condition|(
operator|(
name|start
operator|>=
literal|0
operator|)
operator|&&
name|clauses
operator|.
name|contains
argument_list|(
name|token
operator|.
name|type
argument_list|)
condition|)
block|{
return|return
name|tokenList
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|k
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
return|return
name|tokenList
operator|.
name|subList
argument_list|(
name|start
argument_list|,
name|k
operator|+
literal|1
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|boolean
name|contains
parameter_list|(
name|String
name|hintToken
parameter_list|)
block|{
for|for
control|(
name|Token
name|token
range|:
name|tokenList
control|)
block|{
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|ID
case|:
if|if
condition|(
name|hintToken
operator|.
name|equals
argument_list|(
name|token
operator|.
name|s
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
case|case
name|QUERY
case|:
if|if
condition|(
operator|(
operator|(
name|Query
operator|)
name|token
operator|)
operator|.
name|contains
argument_list|(
name|hintToken
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

