begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|advise
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|Casing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteContextException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|runtime
operator|.
name|CalciteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSelect
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlAbstractParserImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMoniker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonikerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonikerType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorWithHints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|trace
operator|.
name|CalciteTrace
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_comment
comment|/**  * An assistant which offers hints and corrections to a partially-formed SQL  * statement. It is used in the SQL editor user-interface.  */
end_comment

begin_class
specifier|public
class|class
name|SqlAdvisor
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|public
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|CalciteTrace
operator|.
name|PARSER_LOGGER
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|HINT_TOKEN
init|=
literal|"_suggest_"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|UPPER_HINT_TOKEN
init|=
name|HINT_TOKEN
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|// Flags indicating precision/scale combinations
specifier|private
specifier|final
name|SqlValidatorWithHints
name|validator
decl_stmt|;
specifier|private
specifier|final
name|SqlParser
operator|.
name|Config
name|parserConfig
decl_stmt|;
comment|// Cache for getPreferredCasing
specifier|private
name|String
name|prevWord
decl_stmt|;
specifier|private
name|Casing
name|prevPreferredCasing
decl_stmt|;
comment|// Reserved words cache
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|reservedWordsSet
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|reservedWordsList
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates a SqlAdvisor with a validator instance.    *    * @param validator Validator    * @deprecated use {@link #SqlAdvisor(SqlValidatorWithHints, SqlParser.Config)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlAdvisor
parameter_list|(
name|SqlValidatorWithHints
name|validator
parameter_list|)
block|{
name|this
argument_list|(
name|validator
argument_list|,
name|SqlParser
operator|.
name|Config
operator|.
name|DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a SqlAdvisor with a validator instance and given parser    * configuration.    *    * @param validator Validator    * @param parserConfig parser config    */
specifier|public
name|SqlAdvisor
parameter_list|(
name|SqlValidatorWithHints
name|validator
parameter_list|,
name|SqlParser
operator|.
name|Config
name|parserConfig
parameter_list|)
block|{
name|this
operator|.
name|validator
operator|=
name|validator
expr_stmt|;
name|this
operator|.
name|parserConfig
operator|=
name|parserConfig
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|private
name|char
name|quoteStart
parameter_list|()
block|{
return|return
name|parserConfig
operator|.
name|quoting
argument_list|()
operator|.
name|string
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|private
name|char
name|quoteEnd
parameter_list|()
block|{
name|char
name|quote
init|=
name|quoteStart
argument_list|()
decl_stmt|;
return|return
name|quote
operator|==
literal|'['
condition|?
literal|']'
else|:
name|quote
return|;
block|}
comment|/**    * Gets completion hints for a partially completed or syntactically incorrect    * sql statement with cursor pointing to the position where completion hints    * are requested.    *    *<p>Writes into<code>replaced[0]</code> the string that is being    * replaced. Includes the cursor and the preceding identifier. For example,    * if<code>sql</code> is "select abc^de from t", sets<code>    * replaced[0]</code> to "abc". If the cursor is in the middle of    * whitespace, the replaced string is empty. The replaced string is never    * null.    *    * @param sql      A partial or syntactically incorrect sql statement for    *                 which to retrieve completion hints    * @param cursor   to indicate the 0-based cursor position in the query at    * @param replaced String which is being replaced (output)    * @return completion hints    */
specifier|public
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|getCompletionHints
parameter_list|(
name|String
name|sql
parameter_list|,
name|int
name|cursor
parameter_list|,
name|String
index|[]
name|replaced
parameter_list|)
block|{
comment|// search backward starting from current position to find a "word"
name|int
name|wordStart
init|=
name|cursor
decl_stmt|;
name|boolean
name|quoted
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|wordStart
operator|>
literal|0
operator|&&
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|sql
operator|.
name|charAt
argument_list|(
name|wordStart
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|--
name|wordStart
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|wordStart
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sql
operator|.
name|charAt
argument_list|(
name|wordStart
operator|-
literal|1
argument_list|)
operator|==
name|quoteStart
argument_list|()
operator|)
condition|)
block|{
name|quoted
operator|=
literal|true
expr_stmt|;
operator|--
name|wordStart
expr_stmt|;
block|}
if|if
condition|(
name|wordStart
operator|<
literal|0
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
comment|// Search forwards to the end of the word we should remove. Eat up
comment|// trailing double-quote, if any
name|int
name|wordEnd
init|=
name|cursor
decl_stmt|;
while|while
condition|(
name|wordEnd
operator|<
name|sql
operator|.
name|length
argument_list|()
operator|&&
name|Character
operator|.
name|isJavaIdentifierPart
argument_list|(
name|sql
operator|.
name|charAt
argument_list|(
name|wordEnd
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|wordEnd
expr_stmt|;
block|}
if|if
condition|(
name|quoted
operator|&&
operator|(
name|wordEnd
operator|<
name|sql
operator|.
name|length
argument_list|()
operator|)
operator|&&
operator|(
name|sql
operator|.
name|charAt
argument_list|(
name|wordEnd
argument_list|)
operator|==
name|quoteEnd
argument_list|()
operator|)
condition|)
block|{
operator|++
name|wordEnd
expr_stmt|;
block|}
comment|// remove the partially composed identifier from the
comment|// sql statement - otherwise we get a parser exception
name|String
name|word
init|=
name|replaced
index|[
literal|0
index|]
operator|=
name|sql
operator|.
name|substring
argument_list|(
name|wordStart
argument_list|,
name|cursor
argument_list|)
decl_stmt|;
if|if
condition|(
name|wordStart
operator|<
name|wordEnd
condition|)
block|{
name|sql
operator|=
name|sql
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|wordStart
argument_list|)
operator|+
name|sql
operator|.
name|substring
argument_list|(
name|wordEnd
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|completionHints
init|=
name|getCompletionHints0
argument_list|(
name|sql
argument_list|,
name|wordStart
argument_list|)
decl_stmt|;
if|if
condition|(
name|quoted
condition|)
block|{
name|word
operator|=
name|word
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|word
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|completionHints
argument_list|)
return|;
block|}
comment|// If cursor was part of the way through a word, only include hints
comment|// which start with that word in the result.
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|SqlMoniker
argument_list|>
name|result
init|=
operator|new
name|ImmutableList
operator|.
name|Builder
argument_list|<>
argument_list|()
decl_stmt|;
name|Casing
name|preferredCasing
init|=
name|getPreferredCasing
argument_list|(
name|word
argument_list|)
decl_stmt|;
name|boolean
name|ignoreCase
init|=
name|preferredCasing
operator|!=
name|Casing
operator|.
name|UNCHANGED
decl_stmt|;
for|for
control|(
name|SqlMoniker
name|hint
range|:
name|completionHints
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|hint
operator|.
name|getFullyQualifiedNames
argument_list|()
decl_stmt|;
comment|// For now we treat only simple cases where the added name is the last
comment|// See [CALCITE-2439] Smart complete for SqlAdvisor
name|String
name|cname
init|=
name|Util
operator|.
name|last
argument_list|(
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|.
name|regionMatches
argument_list|(
name|ignoreCase
argument_list|,
literal|0
argument_list|,
name|word
argument_list|,
literal|0
argument_list|,
name|word
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|hint
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|build
argument_list|()
return|;
block|}
specifier|public
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|getCompletionHints0
parameter_list|(
name|String
name|sql
parameter_list|,
name|int
name|cursor
parameter_list|)
block|{
name|String
name|simpleSql
init|=
name|simplifySql
argument_list|(
name|sql
argument_list|,
name|cursor
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
name|simpleSql
operator|.
name|indexOf
argument_list|(
name|HINT_TOKEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|SqlParserPos
name|pos
init|=
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
name|getCompletionHints
argument_list|(
name|simpleSql
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Returns casing which is preferred for replacement.    * For instance, {@code en => ename, EN => ENAME}.    * When input has mixed case, {@code Casing.UNCHANGED} is returned.    * @param word input word    * @return preferred casing when replacing input word    */
specifier|private
name|Casing
name|getPreferredCasing
parameter_list|(
name|String
name|word
parameter_list|)
block|{
if|if
condition|(
name|word
operator|==
name|prevWord
condition|)
block|{
return|return
name|prevPreferredCasing
return|;
block|}
name|boolean
name|hasLower
init|=
literal|false
decl_stmt|;
name|boolean
name|hasUpper
init|=
literal|false
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|word
operator|.
name|length
argument_list|()
operator|&&
operator|!
operator|(
name|hasLower
operator|&&
name|hasUpper
operator|)
condition|)
block|{
name|int
name|codePoint
init|=
name|word
operator|.
name|codePointAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|hasLower
operator||=
name|Character
operator|.
name|isLowerCase
argument_list|(
name|codePoint
argument_list|)
expr_stmt|;
name|hasUpper
operator||=
name|Character
operator|.
name|isUpperCase
argument_list|(
name|codePoint
argument_list|)
expr_stmt|;
name|i
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|codePoint
argument_list|)
expr_stmt|;
block|}
name|Casing
name|preferredCasing
decl_stmt|;
if|if
condition|(
name|hasUpper
operator|&&
operator|!
name|hasLower
condition|)
block|{
name|preferredCasing
operator|=
name|Casing
operator|.
name|TO_UPPER
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|hasUpper
operator|&&
name|hasLower
condition|)
block|{
name|preferredCasing
operator|=
name|Casing
operator|.
name|TO_LOWER
expr_stmt|;
block|}
else|else
block|{
name|preferredCasing
operator|=
name|Casing
operator|.
name|UNCHANGED
expr_stmt|;
block|}
name|prevWord
operator|=
name|word
expr_stmt|;
name|prevPreferredCasing
operator|=
name|preferredCasing
expr_stmt|;
return|return
name|preferredCasing
return|;
block|}
specifier|public
name|String
name|getReplacement
parameter_list|(
name|SqlMoniker
name|hint
parameter_list|,
name|String
name|word
parameter_list|)
block|{
name|Casing
name|preferredCasing
init|=
name|getPreferredCasing
argument_list|(
name|word
argument_list|)
decl_stmt|;
name|boolean
name|quoted
init|=
operator|!
name|word
operator|.
name|isEmpty
argument_list|()
operator|&&
name|word
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|quoteStart
argument_list|()
decl_stmt|;
return|return
name|getReplacement
argument_list|(
name|hint
argument_list|,
name|quoted
argument_list|,
name|preferredCasing
argument_list|)
return|;
block|}
specifier|public
name|String
name|getReplacement
parameter_list|(
name|SqlMoniker
name|hint
parameter_list|,
name|boolean
name|quoted
parameter_list|,
name|Casing
name|preferredCasing
parameter_list|)
block|{
name|String
name|name
init|=
name|Util
operator|.
name|last
argument_list|(
name|hint
operator|.
name|getFullyQualifiedNames
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isKeyword
init|=
name|hint
operator|.
name|getType
argument_list|()
operator|==
name|SqlMonikerType
operator|.
name|KEYWORD
decl_stmt|;
comment|// If replacement has mixed case, we need to quote it (or not depending
comment|// on quotedCasing/unquotedCasing
name|quoted
operator|&=
operator|!
name|isKeyword
expr_stmt|;
if|if
condition|(
operator|!
name|quoted
operator|&&
operator|!
name|isKeyword
operator|&&
name|getReservedAndKeyWordsSet
argument_list|()
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|quoted
operator|=
literal|true
expr_stmt|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|name
operator|.
name|length
argument_list|()
operator|+
operator|(
name|quoted
condition|?
literal|2
else|:
literal|0
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isKeyword
operator|&&
operator|!
name|Util
operator|.
name|isValidJavaIdentifier
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// needs quotes ==> quoted
name|quoted
operator|=
literal|true
expr_stmt|;
block|}
name|String
name|idToAppend
init|=
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|quoted
condition|)
block|{
comment|// id ==preferredCasing==> preferredId ==unquotedCasing==> recasedId
comment|// if recasedId matches id, then use preferredId
name|String
name|preferredId
init|=
name|applyCasing
argument_list|(
name|name
argument_list|,
name|preferredCasing
argument_list|)
decl_stmt|;
if|if
condition|(
name|isKeyword
operator|||
name|matchesUnquoted
argument_list|(
name|name
argument_list|,
name|preferredId
argument_list|)
condition|)
block|{
name|idToAppend
operator|=
name|preferredId
expr_stmt|;
block|}
else|else
block|{
comment|// Check if we can use unquoted identifier as is: for instance, unquotedCasing==UNCHANGED
name|quoted
operator|=
operator|!
name|matchesUnquoted
argument_list|(
name|name
argument_list|,
name|idToAppend
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quoted
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|quoteStart
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|idToAppend
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|quoteEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|matchesUnquoted
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|idToAppend
parameter_list|)
block|{
name|String
name|recasedId
init|=
name|applyCasing
argument_list|(
name|idToAppend
argument_list|,
name|parserConfig
operator|.
name|unquotedCasing
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|recasedId
operator|.
name|regionMatches
argument_list|(
operator|!
name|parserConfig
operator|.
name|caseSensitive
argument_list|()
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|name
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|String
name|applyCasing
parameter_list|(
name|String
name|value
parameter_list|,
name|Casing
name|casing
parameter_list|)
block|{
return|return
name|SqlParserUtil
operator|.
name|strip
argument_list|(
name|value
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|casing
argument_list|)
return|;
block|}
comment|/**    * Gets completion hints for a syntactically correct SQL statement with dummy    * {@link SqlIdentifier}.    *    * @param sql A syntactically correct sql statement for which to retrieve    *            completion hints    * @param pos to indicate the line and column position in the query at which    *            completion hints need to be retrieved. For example, "select    *            a.ename, b.deptno from sales.emp a join sales.dept b "on    *            a.deptno=b.deptno where empno=1"; setting pos to 'Line 1, Column    *            17' returns all the possible column names that can be selected    *            from sales.dept table setting pos to 'Line 1, Column 31' returns    *            all the possible table names in 'sales' schema    * @return an array of hints ({@link SqlMoniker}) that can fill in at the    * indicated position    */
specifier|public
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|getCompletionHints
parameter_list|(
name|String
name|sql
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
comment|// First try the statement they gave us. If this fails, just return
comment|// the tokens which were expected at the failure point.
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|SqlNode
name|sqlNode
init|=
name|tryParse
argument_list|(
name|sql
argument_list|,
name|hintList
argument_list|)
decl_stmt|;
if|if
condition|(
name|sqlNode
operator|==
literal|null
condition|)
block|{
return|return
name|hintList
return|;
block|}
comment|// Now construct a statement which is bound to fail. (Character 7 BEL
comment|// is not legal in any SQL statement.)
specifier|final
name|int
name|x
init|=
name|pos
operator|.
name|getColumnNum
argument_list|()
operator|-
literal|1
decl_stmt|;
name|sql
operator|=
name|sql
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|x
argument_list|)
operator|+
literal|" \07"
operator|+
name|sql
operator|.
name|substring
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tryParse
argument_list|(
name|sql
argument_list|,
name|hintList
argument_list|)
expr_stmt|;
specifier|final
name|SqlMoniker
name|star
init|=
operator|new
name|SqlMonikerImpl
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"*"
argument_list|)
argument_list|,
name|SqlMonikerType
operator|.
name|KEYWORD
argument_list|)
decl_stmt|;
name|String
name|hintToken
init|=
name|parserConfig
operator|.
name|unquotedCasing
argument_list|()
operator|==
name|Casing
operator|.
name|TO_UPPER
condition|?
name|UPPER_HINT_TOKEN
else|:
name|HINT_TOKEN
decl_stmt|;
if|if
condition|(
name|hintList
operator|.
name|contains
argument_list|(
name|star
argument_list|)
operator|&&
operator|!
name|isSelectListItem
argument_list|(
name|sqlNode
argument_list|,
name|pos
argument_list|,
name|hintToken
argument_list|)
condition|)
block|{
name|hintList
operator|.
name|remove
argument_list|(
name|star
argument_list|)
expr_stmt|;
block|}
comment|// Add the identifiers which are expected at the point of interest.
try|try
block|{
name|validator
operator|.
name|validate
argument_list|(
name|sqlNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// mask any exception that is thrown during the validation, i.e.
comment|// try to continue even if the sql is invalid. we are doing a best
comment|// effort here to try to come up with the requested completion
comment|// hints
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
name|LOGGER
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|validatorHints
init|=
name|validator
operator|.
name|lookupHints
argument_list|(
name|sqlNode
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|hintList
operator|.
name|addAll
argument_list|(
name|validatorHints
argument_list|)
expr_stmt|;
return|return
name|hintList
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isSelectListItem
parameter_list|(
name|SqlNode
name|root
parameter_list|,
specifier|final
name|SqlParserPos
name|pos
parameter_list|,
name|String
name|hintToken
parameter_list|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|nodes
init|=
name|SqlUtil
operator|.
name|getAncestry
argument_list|(
name|root
argument_list|,
name|input
lambda|->
name|input
operator|instanceof
name|SqlIdentifier
operator|&&
operator|(
operator|(
name|SqlIdentifier
operator|)
name|input
operator|)
operator|.
name|names
operator|.
name|contains
argument_list|(
name|hintToken
argument_list|)
argument_list|,
name|input
lambda|->
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|input
argument_list|)
operator|.
name|getParserPosition
argument_list|()
operator|.
name|startsAt
argument_list|(
name|pos
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|==
name|root
assert|;
name|nodes
operator|=
name|Lists
operator|.
name|reverse
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
return|return
name|nodes
operator|.
name|size
argument_list|()
operator|>
literal|2
operator|&&
name|nodes
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|instanceof
name|SqlSelect
operator|&&
name|nodes
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|==
operator|(
operator|(
name|SqlSelect
operator|)
name|nodes
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|)
operator|.
name|getSelectList
argument_list|()
return|;
block|}
comment|/**    * Tries to parse a SQL statement.    *    *<p>If succeeds, returns the parse tree node; if fails, populates the list    * of hints and returns null.    *    * @param sql      SQL statement    * @param hintList List of hints suggesting allowable tokens at the point of    *                 failure    * @return Parse tree if succeeded, null if parse failed    */
specifier|private
name|SqlNode
name|tryParse
parameter_list|(
name|String
name|sql
parameter_list|,
name|List
argument_list|<
name|SqlMoniker
argument_list|>
name|hintList
parameter_list|)
block|{
try|try
block|{
return|return
name|parseQuery
argument_list|(
name|sql
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|e
parameter_list|)
block|{
for|for
control|(
name|String
name|tokenName
range|:
name|e
operator|.
name|getExpectedTokenNames
argument_list|()
control|)
block|{
comment|// Only add tokens which are keywords, like '"BY"'; ignore
comment|// symbols such as '<Identifier>'.
if|if
condition|(
name|tokenName
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
operator|&&
name|tokenName
operator|.
name|endsWith
argument_list|(
literal|"\""
argument_list|)
condition|)
block|{
name|hintList
operator|.
name|add
argument_list|(
operator|new
name|SqlMonikerImpl
argument_list|(
name|tokenName
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|tokenName
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|,
name|SqlMonikerType
operator|.
name|KEYWORD
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|CalciteException
name|e
parameter_list|)
block|{
name|Util
operator|.
name|swallow
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Gets the fully qualified name for a {@link SqlIdentifier} at a given    * position of a sql statement.    *    * @param sql    A syntactically correct sql statement for which to retrieve a    *               fully qualified SQL identifier name    * @param cursor to indicate the 0-based cursor position in the query that    *               represents a SQL identifier for which its fully qualified    *               name is to be returned.    * @return a {@link SqlMoniker} that contains the fully qualified name of    * the specified SQL identifier, returns null if none is found or the SQL    * statement is invalid.    */
specifier|public
name|SqlMoniker
name|getQualifiedName
parameter_list|(
name|String
name|sql
parameter_list|,
name|int
name|cursor
parameter_list|)
block|{
name|SqlNode
name|sqlNode
decl_stmt|;
try|try
block|{
name|sqlNode
operator|=
name|parseQuery
argument_list|(
name|sql
argument_list|)
expr_stmt|;
name|validator
operator|.
name|validate
argument_list|(
name|sqlNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
name|SqlParserPos
name|pos
init|=
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
name|cursor
operator|+
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|validator
operator|.
name|lookupQualifiedName
argument_list|(
name|sqlNode
argument_list|,
name|pos
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|CalciteContextException
decl||
name|AssertionError
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Attempts to complete and validate a given partially completed sql    * statement, and returns whether it is valid.    *    * @param sql A partial or syntactically incorrect sql statement to validate    * @return whether SQL statement is valid    */
specifier|public
name|boolean
name|isValid
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|SqlSimpleParser
name|simpleParser
init|=
operator|new
name|SqlSimpleParser
argument_list|(
name|HINT_TOKEN
argument_list|,
name|parserConfig
argument_list|)
decl_stmt|;
name|String
name|simpleSql
init|=
name|simpleParser
operator|.
name|simplifySql
argument_list|(
name|sql
argument_list|)
decl_stmt|;
name|SqlNode
name|sqlNode
decl_stmt|;
try|try
block|{
name|sqlNode
operator|=
name|parseQuery
argument_list|(
name|simpleSql
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// if the sql can't be parsed we wont' be able to validate it
return|return
literal|false
return|;
block|}
try|try
block|{
name|validator
operator|.
name|validate
argument_list|(
name|sqlNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Attempts to parse and validate a SQL statement. Throws the first    * exception encountered. The error message of this exception is to be    * displayed on the UI    *    * @param sql A user-input sql statement to be validated    * @return a List of ValidateErrorInfo (null if sql is valid)    */
specifier|public
name|List
argument_list|<
name|ValidateErrorInfo
argument_list|>
name|validate
parameter_list|(
name|String
name|sql
parameter_list|)
block|{
name|SqlNode
name|sqlNode
decl_stmt|;
name|List
argument_list|<
name|ValidateErrorInfo
argument_list|>
name|errorList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|sqlNode
operator|=
name|collectParserError
argument_list|(
name|sql
argument_list|,
name|errorList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errorList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|errorList
return|;
block|}
try|try
block|{
name|validator
operator|.
name|validate
argument_list|(
name|sqlNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CalciteContextException
name|e
parameter_list|)
block|{
name|ValidateErrorInfo
name|errInfo
init|=
operator|new
name|ValidateErrorInfo
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|// validator only returns 1 exception now
name|errorList
operator|.
name|add
argument_list|(
name|errInfo
argument_list|)
expr_stmt|;
return|return
name|errorList
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|ValidateErrorInfo
name|errInfo
init|=
operator|new
name|ValidateErrorInfo
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|sql
operator|.
name|length
argument_list|()
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
comment|// parser only returns 1 exception now
name|errorList
operator|.
name|add
argument_list|(
name|errInfo
argument_list|)
expr_stmt|;
return|return
name|errorList
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Turns a partially completed or syntactically incorrect sql statement into    * a simplified, valid one that can be passed into    * {@link #getCompletionHints(String, SqlParserPos)}.    *    * @param sql    A partial or syntactically incorrect SQL statement    * @param cursor Indicates the position in the query at which    *               completion hints need to be retrieved    * @return a completed, valid (and possibly simplified SQL statement    */
specifier|public
name|String
name|simplifySql
parameter_list|(
name|String
name|sql
parameter_list|,
name|int
name|cursor
parameter_list|)
block|{
name|SqlSimpleParser
name|parser
init|=
operator|new
name|SqlSimpleParser
argument_list|(
name|HINT_TOKEN
argument_list|,
name|parserConfig
argument_list|)
decl_stmt|;
return|return
name|parser
operator|.
name|simplifySql
argument_list|(
name|sql
argument_list|,
name|cursor
argument_list|)
return|;
block|}
comment|/**    * Returns an array of SQL reserved and keywords.    *    * @return an of SQL reserved and keywords    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getReservedAndKeyWords
parameter_list|()
block|{
name|ensureReservedAndKeyWords
argument_list|()
expr_stmt|;
return|return
name|reservedWordsList
return|;
block|}
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getReservedAndKeyWordsSet
parameter_list|()
block|{
name|ensureReservedAndKeyWords
argument_list|()
expr_stmt|;
return|return
name|reservedWordsSet
return|;
block|}
specifier|private
name|void
name|ensureReservedAndKeyWords
parameter_list|()
block|{
if|if
condition|(
name|reservedWordsSet
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|Collection
argument_list|<
name|String
argument_list|>
name|c
init|=
name|SqlAbstractParserImpl
operator|.
name|getSql92ReservedWords
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|l
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|getParserMetadata
argument_list|()
operator|.
name|getJdbcKeywords
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|al
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|al
operator|.
name|addAll
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|al
operator|.
name|addAll
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|reservedWordsList
operator|=
name|al
expr_stmt|;
name|reservedWordsSet
operator|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
expr_stmt|;
name|reservedWordsSet
operator|.
name|addAll
argument_list|(
name|reservedWordsList
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the underlying Parser metadata.    *    *<p>To use a different parser (recognizing a different dialect of SQL),    * derived class should override.    *    * @return metadata    */
specifier|protected
name|SqlAbstractParserImpl
operator|.
name|Metadata
name|getParserMetadata
parameter_list|()
block|{
name|SqlParser
name|parser
init|=
name|SqlParser
operator|.
name|create
argument_list|(
literal|""
argument_list|,
name|parserConfig
argument_list|)
decl_stmt|;
return|return
name|parser
operator|.
name|getMetadata
argument_list|()
return|;
block|}
comment|/**    * Wrapper function to parse a SQL query (SELECT or VALUES, but not INSERT,    * UPDATE, DELETE, CREATE, DROP etc.), throwing a {@link SqlParseException}    * if the statement is not syntactically valid.    *    * @param sql SQL statement    * @return parse tree    * @throws SqlParseException if not syntactically valid    */
specifier|protected
name|SqlNode
name|parseQuery
parameter_list|(
name|String
name|sql
parameter_list|)
throws|throws
name|SqlParseException
block|{
name|SqlParser
name|parser
init|=
name|SqlParser
operator|.
name|create
argument_list|(
name|sql
argument_list|,
name|parserConfig
argument_list|)
decl_stmt|;
return|return
name|parser
operator|.
name|parseStmt
argument_list|()
return|;
block|}
comment|/**    * Attempts to parse a SQL statement and adds to the errorList if any syntax    * error is found. This implementation uses {@link SqlParser}. Subclass can    * re-implement this with a different parser implementation    *    * @param sql       A user-input sql statement to be parsed    * @param errorList A {@link List} of error to be added to    * @return {@link SqlNode } that is root of the parse tree, null if the sql    * is not valid    */
specifier|protected
name|SqlNode
name|collectParserError
parameter_list|(
name|String
name|sql
parameter_list|,
name|List
argument_list|<
name|ValidateErrorInfo
argument_list|>
name|errorList
parameter_list|)
block|{
try|try
block|{
return|return
name|parseQuery
argument_list|(
name|sql
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SqlParseException
name|e
parameter_list|)
block|{
name|ValidateErrorInfo
name|errInfo
init|=
operator|new
name|ValidateErrorInfo
argument_list|(
name|e
operator|.
name|getPos
argument_list|()
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
comment|// parser only returns 1 exception now
name|errorList
operator|.
name|add
argument_list|(
name|errInfo
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|//~ Inner Classes ----------------------------------------------------------
comment|/** Text and position info of a validator or parser exception. */
specifier|public
class|class
name|ValidateErrorInfo
block|{
specifier|private
name|int
name|startLineNum
decl_stmt|;
specifier|private
name|int
name|startColumnNum
decl_stmt|;
specifier|private
name|int
name|endLineNum
decl_stmt|;
specifier|private
name|int
name|endColumnNum
decl_stmt|;
specifier|private
name|String
name|errorMsg
decl_stmt|;
comment|/**      * Creates a new ValidateErrorInfo with the position coordinates and an      * error string.      *      * @param startLineNum   Start line number      * @param startColumnNum Start column number      * @param endLineNum     End line number      * @param endColumnNum   End column number      * @param errorMsg       Error message      */
specifier|public
name|ValidateErrorInfo
parameter_list|(
name|int
name|startLineNum
parameter_list|,
name|int
name|startColumnNum
parameter_list|,
name|int
name|endLineNum
parameter_list|,
name|int
name|endColumnNum
parameter_list|,
name|String
name|errorMsg
parameter_list|)
block|{
name|this
operator|.
name|startLineNum
operator|=
name|startLineNum
expr_stmt|;
name|this
operator|.
name|startColumnNum
operator|=
name|startColumnNum
expr_stmt|;
name|this
operator|.
name|endLineNum
operator|=
name|endLineNum
expr_stmt|;
name|this
operator|.
name|endColumnNum
operator|=
name|endColumnNum
expr_stmt|;
name|this
operator|.
name|errorMsg
operator|=
name|errorMsg
expr_stmt|;
block|}
comment|/**      * Creates a new ValidateErrorInfo with an CalciteContextException.      *      * @param e Exception      */
specifier|public
name|ValidateErrorInfo
parameter_list|(
name|CalciteContextException
name|e
parameter_list|)
block|{
name|this
operator|.
name|startLineNum
operator|=
name|e
operator|.
name|getPosLine
argument_list|()
expr_stmt|;
name|this
operator|.
name|startColumnNum
operator|=
name|e
operator|.
name|getPosColumn
argument_list|()
expr_stmt|;
name|this
operator|.
name|endLineNum
operator|=
name|e
operator|.
name|getEndPosLine
argument_list|()
expr_stmt|;
name|this
operator|.
name|endColumnNum
operator|=
name|e
operator|.
name|getEndPosColumn
argument_list|()
expr_stmt|;
name|this
operator|.
name|errorMsg
operator|=
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates a new ValidateErrorInfo with a SqlParserPos and an error      * string.      *      * @param pos      Error position      * @param errorMsg Error message      */
specifier|public
name|ValidateErrorInfo
parameter_list|(
name|SqlParserPos
name|pos
parameter_list|,
name|String
name|errorMsg
parameter_list|)
block|{
name|this
operator|.
name|startLineNum
operator|=
name|pos
operator|.
name|getLineNum
argument_list|()
expr_stmt|;
name|this
operator|.
name|startColumnNum
operator|=
name|pos
operator|.
name|getColumnNum
argument_list|()
expr_stmt|;
name|this
operator|.
name|endLineNum
operator|=
name|pos
operator|.
name|getEndLineNum
argument_list|()
expr_stmt|;
name|this
operator|.
name|endColumnNum
operator|=
name|pos
operator|.
name|getEndColumnNum
argument_list|()
expr_stmt|;
name|this
operator|.
name|errorMsg
operator|=
name|errorMsg
expr_stmt|;
block|}
comment|/** Returns 1-based starting line number. */
specifier|public
name|int
name|getStartLineNum
parameter_list|()
block|{
return|return
name|startLineNum
return|;
block|}
comment|/** Returns 1-based starting column number. */
specifier|public
name|int
name|getStartColumnNum
parameter_list|()
block|{
return|return
name|startColumnNum
return|;
block|}
comment|/** Returns 1-based end line number. */
specifier|public
name|int
name|getEndLineNum
parameter_list|()
block|{
return|return
name|endLineNum
return|;
block|}
comment|/** Returns 1-based end column number. */
specifier|public
name|int
name|getEndColumnNum
parameter_list|()
block|{
return|return
name|endColumnNum
return|;
block|}
comment|/** Returns the error message. */
specifier|public
name|String
name|getMessage
parameter_list|()
block|{
return|return
name|errorMsg
return|;
block|}
block|}
block|}
end_class

end_unit

