begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|DateString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimeString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|TimestampString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|checkerframework
operator|.
name|checker
operator|.
name|nullness
operator|.
name|qual
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Enumeration of the type names which can be used to construct a SQL type.  * Rationale for this class's existence (instead of just using the standard  * java.sql.Type ordinals):  *  *<ul>  *<li>{@link java.sql.Types} does not include all SQL2003 data-types;  *<li>SqlTypeName provides a type-safe enumeration;  *<li>SqlTypeName provides a place to hang extra information such as whether  * the type carries precision and scale.  *</ul>  */
end_comment

begin_enum
specifier|public
enum|enum
name|SqlTypeName
block|{
name|BOOLEAN
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|BOOLEAN
argument_list|,
name|SqlTypeFamily
operator|.
name|BOOLEAN
argument_list|)
block|,
name|TINYINT
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|TINYINT
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
block|,
name|SMALLINT
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|SMALLINT
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
block|,
name|INTEGER
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|INTEGER
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
block|,
name|BIGINT
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
block|,
name|DECIMAL
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|DECIMAL
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
block|,
name|FLOAT
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|FLOAT
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
block|,
name|REAL
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|REAL
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
block|,
name|DOUBLE
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|DOUBLE
argument_list|,
name|SqlTypeFamily
operator|.
name|NUMERIC
argument_list|)
block|,
name|DATE
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|DATE
argument_list|,
name|SqlTypeFamily
operator|.
name|DATE
argument_list|)
block|,
name|TIME
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|TIME
argument_list|,
name|SqlTypeFamily
operator|.
name|TIME
argument_list|)
block|,
name|TIME_WITH_LOCAL_TIME_ZONE
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|TIME
argument_list|)
block|,
name|TIMESTAMP
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|TIMESTAMP
argument_list|,
name|SqlTypeFamily
operator|.
name|TIMESTAMP
argument_list|)
block|,
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|TIMESTAMP
argument_list|)
block|,
name|INTERVAL_YEAR
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_YEAR_MONTH
argument_list|)
block|,
name|INTERVAL_YEAR_MONTH
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_YEAR_MONTH
argument_list|)
block|,
name|INTERVAL_MONTH
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_YEAR_MONTH
argument_list|)
block|,
name|INTERVAL_DAY
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_DAY_HOUR
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_DAY_MINUTE
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_DAY_SECOND
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_HOUR
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_HOUR_MINUTE
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_HOUR_SECOND
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_MINUTE
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_MINUTE_SECOND
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|INTERVAL_SECOND
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|INTERVAL_DAY_TIME
argument_list|)
block|,
name|CHAR
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|CHAR
argument_list|,
name|SqlTypeFamily
operator|.
name|CHARACTER
argument_list|)
block|,
name|VARCHAR
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
name|SqlTypeFamily
operator|.
name|CHARACTER
argument_list|)
block|,
name|BINARY
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|BINARY
argument_list|,
name|SqlTypeFamily
operator|.
name|BINARY
argument_list|)
block|,
name|VARBINARY
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|VARBINARY
argument_list|,
name|SqlTypeFamily
operator|.
name|BINARY
argument_list|)
block|,
name|NULL
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|true
argument_list|,
name|Types
operator|.
name|NULL
argument_list|,
name|SqlTypeFamily
operator|.
name|NULL
argument_list|)
block|,
name|ANY
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|true
argument_list|,
name|Types
operator|.
name|JAVA_OBJECT
argument_list|,
name|SqlTypeFamily
operator|.
name|ANY
argument_list|)
block|,
name|SYMBOL
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|true
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
literal|null
argument_list|)
block|,
name|MULTISET
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|ARRAY
argument_list|,
name|SqlTypeFamily
operator|.
name|MULTISET
argument_list|)
block|,
name|ARRAY
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|ARRAY
argument_list|,
name|SqlTypeFamily
operator|.
name|ARRAY
argument_list|)
block|,
name|MAP
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|MAP
argument_list|)
block|,
name|DISTINCT
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|DISTINCT
argument_list|,
literal|null
argument_list|)
block|,
name|STRUCTURED
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|STRUCT
argument_list|,
literal|null
argument_list|)
block|,
name|ROW
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|STRUCT
argument_list|,
literal|null
argument_list|)
block|,
name|OTHER
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
literal|null
argument_list|)
block|,
name|CURSOR
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|ExtraSqlTypes
operator|.
name|REF_CURSOR
argument_list|,
name|SqlTypeFamily
operator|.
name|CURSOR
argument_list|)
block|,
name|COLUMN_LIST
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|Types
operator|.
name|OTHER
operator|+
literal|2
argument_list|,
name|SqlTypeFamily
operator|.
name|COLUMN_LIST
argument_list|)
block|,
name|DYNAMIC_STAR
argument_list|(
name|PrecScale
operator|.
name|NO_NO
operator||
name|PrecScale
operator|.
name|YES_NO
operator||
name|PrecScale
operator|.
name|YES_YES
argument_list|,
literal|true
argument_list|,
name|Types
operator|.
name|JAVA_OBJECT
argument_list|,
name|SqlTypeFamily
operator|.
name|ANY
argument_list|)
block|,
comment|/** Spatial type. Though not standard, it is common to several DBs, so we    * do not flag it 'special' (internal). */
name|GEOMETRY
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|false
argument_list|,
name|ExtraSqlTypes
operator|.
name|GEOMETRY
argument_list|,
name|SqlTypeFamily
operator|.
name|GEO
argument_list|)
block|,
name|SARG
argument_list|(
name|PrecScale
operator|.
name|NO_NO
argument_list|,
literal|true
argument_list|,
name|Types
operator|.
name|OTHER
argument_list|,
name|SqlTypeFamily
operator|.
name|ANY
argument_list|)
block|;
specifier|public
specifier|static
specifier|final
name|int
name|MAX_DATETIME_PRECISION
init|=
literal|3
decl_stmt|;
comment|// Minimum and default interval precisions are  defined by SQL2003
comment|// Maximum interval precisions are implementation dependent,
comment|//  but must be at least the default value
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_INTERVAL_START_PRECISION
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_INTERVAL_FRACTIONAL_SECOND_PRECISION
init|=
literal|6
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MIN_INTERVAL_START_PRECISION
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MAX_INTERVAL_START_PRECISION
init|=
literal|10
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MAX_INTERVAL_FRACTIONAL_SECOND_PRECISION
init|=
literal|9
decl_stmt|;
comment|// Cached map of enum values
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|SqlTypeName
argument_list|>
name|VALUES_MAP
init|=
name|Util
operator|.
name|enumConstants
argument_list|(
name|SqlTypeName
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// categorizations used by SqlTypeFamily definitions
comment|// you probably want to use JDK 1.5 support for treating enumeration
comment|// as collection instead; this is only here to support
comment|// SqlTypeFamily.ANY
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|ALL_TYPES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|BOOLEAN
argument_list|,
name|INTEGER
argument_list|,
name|VARCHAR
argument_list|,
name|DATE
argument_list|,
name|TIME
argument_list|,
name|TIMESTAMP
argument_list|,
name|NULL
argument_list|,
name|DECIMAL
argument_list|,
name|ANY
argument_list|,
name|CHAR
argument_list|,
name|BINARY
argument_list|,
name|VARBINARY
argument_list|,
name|TINYINT
argument_list|,
name|SMALLINT
argument_list|,
name|BIGINT
argument_list|,
name|REAL
argument_list|,
name|DOUBLE
argument_list|,
name|SYMBOL
argument_list|,
name|INTERVAL_YEAR
argument_list|,
name|INTERVAL_YEAR_MONTH
argument_list|,
name|INTERVAL_MONTH
argument_list|,
name|INTERVAL_DAY
argument_list|,
name|INTERVAL_DAY_HOUR
argument_list|,
name|INTERVAL_DAY_MINUTE
argument_list|,
name|INTERVAL_DAY_SECOND
argument_list|,
name|INTERVAL_HOUR
argument_list|,
name|INTERVAL_HOUR_MINUTE
argument_list|,
name|INTERVAL_HOUR_SECOND
argument_list|,
name|INTERVAL_MINUTE
argument_list|,
name|INTERVAL_MINUTE_SECOND
argument_list|,
name|INTERVAL_SECOND
argument_list|,
name|TIME_WITH_LOCAL_TIME_ZONE
argument_list|,
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
argument_list|,
name|FLOAT
argument_list|,
name|MULTISET
argument_list|,
name|DISTINCT
argument_list|,
name|STRUCTURED
argument_list|,
name|ROW
argument_list|,
name|CURSOR
argument_list|,
name|COLUMN_LIST
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|BOOLEAN_TYPES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|BINARY_TYPES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|BINARY
argument_list|,
name|VARBINARY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|INT_TYPES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|TINYINT
argument_list|,
name|SMALLINT
argument_list|,
name|INTEGER
argument_list|,
name|BIGINT
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|EXACT_TYPES
init|=
name|combine
argument_list|(
name|INT_TYPES
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|DECIMAL
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|APPROX_TYPES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|FLOAT
argument_list|,
name|REAL
argument_list|,
name|DOUBLE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|NUMERIC_TYPES
init|=
name|combine
argument_list|(
name|EXACT_TYPES
argument_list|,
name|APPROX_TYPES
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|FRACTIONAL_TYPES
init|=
name|combine
argument_list|(
name|APPROX_TYPES
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|DECIMAL
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|CHAR_TYPES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|CHAR
argument_list|,
name|VARCHAR
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|STRING_TYPES
init|=
name|combine
argument_list|(
name|CHAR_TYPES
argument_list|,
name|BINARY_TYPES
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|DATETIME_TYPES
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|DATE
argument_list|,
name|TIME
argument_list|,
name|TIME_WITH_LOCAL_TIME_ZONE
argument_list|,
name|TIMESTAMP
argument_list|,
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|SqlTypeName
argument_list|>
name|YEAR_INTERVAL_TYPES
init|=
name|Sets
operator|.
name|immutableEnumSet
argument_list|(
name|SqlTypeName
operator|.
name|INTERVAL_YEAR
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_YEAR_MONTH
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_MONTH
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|SqlTypeName
argument_list|>
name|DAY_INTERVAL_TYPES
init|=
name|Sets
operator|.
name|immutableEnumSet
argument_list|(
name|SqlTypeName
operator|.
name|INTERVAL_DAY
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_DAY_HOUR
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_DAY_MINUTE
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_DAY_SECOND
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_HOUR
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_HOUR_MINUTE
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_HOUR_SECOND
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_MINUTE
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_MINUTE_SECOND
argument_list|,
name|SqlTypeName
operator|.
name|INTERVAL_SECOND
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|SqlTypeName
argument_list|>
name|INTERVAL_TYPES
init|=
name|Sets
operator|.
name|immutableEnumSet
argument_list|(
name|Iterables
operator|.
name|concat
argument_list|(
name|YEAR_INTERVAL_TYPES
argument_list|,
name|DAY_INTERVAL_TYPES
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|SqlTypeName
argument_list|>
name|JDBC_TYPE_TO_NAME
init|=
name|ImmutableMap
operator|.
expr|<
name|Integer
decl_stmt|,
name|SqlTypeName
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
name|Types
operator|.
name|TINYINT
argument_list|,
name|TINYINT
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|SMALLINT
argument_list|,
name|SMALLINT
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|BIGINT
argument_list|,
name|BIGINT
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|INTEGER
argument_list|,
name|INTEGER
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|NUMERIC
argument_list|,
name|DECIMAL
argument_list|)
comment|// REVIEW
decl|.
name|put
argument_list|(
name|Types
operator|.
name|DECIMAL
argument_list|,
name|DECIMAL
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|FLOAT
argument_list|,
name|FLOAT
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|REAL
argument_list|,
name|REAL
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|DOUBLE
argument_list|,
name|DOUBLE
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|CHAR
argument_list|,
name|CHAR
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|VARCHAR
argument_list|,
name|VARCHAR
argument_list|)
comment|// TODO: provide real support for these eventually
decl|.
name|put
argument_list|(
name|ExtraSqlTypes
operator|.
name|NCHAR
argument_list|,
name|CHAR
argument_list|)
decl|.
name|put
argument_list|(
name|ExtraSqlTypes
operator|.
name|NVARCHAR
argument_list|,
name|VARCHAR
argument_list|)
comment|// TODO: additional types not yet supported. See ExtraSqlTypes.
comment|// .put(Types.LONGVARCHAR, Longvarchar)
comment|// .put(Types.CLOB, Clob)
comment|// .put(Types.LONGVARBINARY, Longvarbinary)
comment|// .put(Types.BLOB, Blob)
comment|// .put(Types.LONGNVARCHAR, Longnvarchar)
comment|// .put(Types.NCLOB, Nclob)
comment|// .put(Types.ROWID, Rowid)
comment|// .put(Types.SQLXML, Sqlxml)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|BINARY
argument_list|,
name|BINARY
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|VARBINARY
argument_list|,
name|VARBINARY
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|DATE
argument_list|,
name|DATE
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|TIME
argument_list|,
name|TIME
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|TIMESTAMP
argument_list|,
name|TIMESTAMP
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|BIT
argument_list|,
name|BOOLEAN
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|BOOLEAN
argument_list|,
name|BOOLEAN
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|DISTINCT
argument_list|,
name|DISTINCT
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|STRUCT
argument_list|,
name|STRUCTURED
argument_list|)
decl|.
name|put
argument_list|(
name|Types
operator|.
name|ARRAY
argument_list|,
name|ARRAY
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
comment|/**    * Bitwise-or of flags indicating allowable precision/scale combinations.    */
specifier|private
specifier|final
name|int
name|signatures
decl_stmt|;
comment|/**    * Returns true if not of a "pure" standard sql type. "Inpure" types are    * {@link #ANY}, {@link #NULL} and {@link #SYMBOL}    */
specifier|private
specifier|final
name|boolean
name|special
decl_stmt|;
specifier|private
specifier|final
name|int
name|jdbcOrdinal
decl_stmt|;
specifier|private
specifier|final
annotation|@
name|Nullable
name|SqlTypeFamily
name|family
decl_stmt|;
name|SqlTypeName
parameter_list|(
name|int
name|signatures
parameter_list|,
name|boolean
name|special
parameter_list|,
name|int
name|jdbcType
parameter_list|,
annotation|@
name|Nullable
name|SqlTypeFamily
name|family
parameter_list|)
block|{
name|this
operator|.
name|signatures
operator|=
name|signatures
expr_stmt|;
name|this
operator|.
name|special
operator|=
name|special
expr_stmt|;
name|this
operator|.
name|jdbcOrdinal
operator|=
name|jdbcType
expr_stmt|;
name|this
operator|.
name|family
operator|=
name|family
expr_stmt|;
block|}
comment|/**    * Looks up a type name from its name.    *    * @return Type name, or null if not found    */
specifier|public
specifier|static
annotation|@
name|Nullable
name|SqlTypeName
name|get
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
literal|false
condition|)
block|{
comment|// The following code works OK, but the spurious exceptions are
comment|// annoying.
try|try
block|{
return|return
name|SqlTypeName
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|VALUES_MAP
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|allowsNoPrecNoScale
parameter_list|()
block|{
return|return
operator|(
name|signatures
operator|&
name|PrecScale
operator|.
name|NO_NO
operator|)
operator|!=
literal|0
return|;
block|}
specifier|public
name|boolean
name|allowsPrecNoScale
parameter_list|()
block|{
return|return
operator|(
name|signatures
operator|&
name|PrecScale
operator|.
name|YES_NO
operator|)
operator|!=
literal|0
return|;
block|}
specifier|public
name|boolean
name|allowsPrec
parameter_list|()
block|{
return|return
name|allowsPrecScale
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
operator|||
name|allowsPrecScale
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|allowsScale
parameter_list|()
block|{
return|return
name|allowsPrecScale
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Returns whether this type can be specified with a given combination of    * precision and scale. For example,    *    *<ul>    *<li><code>Varchar.allowsPrecScale(true, false)</code> returns<code>    * true</code>, because the VARCHAR type allows a precision parameter, as in    *<code>VARCHAR(10)</code>.</li>    *<li><code>Varchar.allowsPrecScale(true, true)</code> returns<code>    * true</code>, because the VARCHAR type does not allow a precision and a    * scale parameter, as in<code>VARCHAR(10, 4)</code>.</li>    *<li><code>allowsPrecScale(false, true)</code> returns<code>false</code>    * for every type.</li>    *</ul>    *    * @param precision Whether the precision/length field is part of the type    *                  specification    * @param scale     Whether the scale field is part of the type specification    * @return Whether this combination of precision/scale is valid    */
specifier|public
name|boolean
name|allowsPrecScale
parameter_list|(
name|boolean
name|precision
parameter_list|,
name|boolean
name|scale
parameter_list|)
block|{
name|int
name|mask
init|=
name|precision
condition|?
operator|(
name|scale
condition|?
name|PrecScale
operator|.
name|YES_YES
else|:
name|PrecScale
operator|.
name|YES_NO
operator|)
else|:
operator|(
name|scale
condition|?
literal|0
else|:
name|PrecScale
operator|.
name|NO_NO
operator|)
decl_stmt|;
return|return
operator|(
name|signatures
operator|&
name|mask
operator|)
operator|!=
literal|0
return|;
block|}
specifier|public
name|boolean
name|isSpecial
parameter_list|()
block|{
return|return
name|special
return|;
block|}
comment|/** Returns the ordinal from {@link java.sql.Types} corresponding to this    * SqlTypeName. */
specifier|public
name|int
name|getJdbcOrdinal
parameter_list|()
block|{
return|return
name|jdbcOrdinal
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|combine
parameter_list|(
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|list0
parameter_list|,
name|List
argument_list|<
name|SqlTypeName
argument_list|>
name|list1
parameter_list|)
block|{
return|return
name|ImmutableList
operator|.
expr|<
name|SqlTypeName
operator|>
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|list0
argument_list|)
operator|.
name|addAll
argument_list|(
name|list1
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns the default scale for this type if supported, otherwise -1 if    * scale is either unsupported or must be specified explicitly. */
specifier|public
name|int
name|getDefaultScale
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|DECIMAL
case|:
return|return
literal|0
return|;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
return|return
name|DEFAULT_INTERVAL_FRACTIONAL_SECOND_PRECISION
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Gets the SqlTypeFamily containing this SqlTypeName.    *    * @return containing family, or null for none (SYMBOL, DISTINCT, STRUCTURED, ROW, OTHER)    */
specifier|public
annotation|@
name|Nullable
name|SqlTypeFamily
name|getFamily
parameter_list|()
block|{
return|return
name|family
return|;
block|}
comment|/**    * Gets the SqlTypeName corresponding to a JDBC type.    *    * @param jdbcType the JDBC type of interest    * @return corresponding SqlTypeName, or null if the type is not known    */
specifier|public
specifier|static
annotation|@
name|Nullable
name|SqlTypeName
name|getNameForJdbcType
parameter_list|(
name|int
name|jdbcType
parameter_list|)
block|{
return|return
name|JDBC_TYPE_TO_NAME
operator|.
name|get
argument_list|(
name|jdbcType
argument_list|)
return|;
block|}
comment|/**    * Returns the limit of this datatype. For example,    *    *<table border="1">    *<caption>Datatype limits</caption>    *<tr>    *<th>Datatype</th>    *<th>sign</th>    *<th>limit</th>    *<th>beyond</th>    *<th>precision</th>    *<th>scale</th>    *<th>Returns</th>    *</tr>    *<tr>    *<td>Integer</td>    *<td>true</td>    *<td>true</td>    *<td>false</td>    *<td>-1</td>    *<td>-1</td>    *<td>2147483647 (2 ^ 31 -1 = MAXINT)</td>    *</tr>    *<tr>    *<td>Integer</td>    *<td>true</td>    *<td>true</td>    *<td>true</td>    *<td>-1</td>    *<td>-1</td>    *<td>2147483648 (2 ^ 31 = MAXINT + 1)</td>    *</tr>    *<tr>    *<td>Integer</td>    *<td>false</td>    *<td>true</td>    *<td>false</td>    *<td>-1</td>    *<td>-1</td>    *<td>-2147483648 (-2 ^ 31 = MININT)</td>    *</tr>    *<tr>    *<td>Boolean</td>    *<td>true</td>    *<td>true</td>    *<td>false</td>    *<td>-1</td>    *<td>-1</td>    *<td>TRUE</td>    *</tr>    *<tr>    *<td>Varchar</td>    *<td>true</td>    *<td>true</td>    *<td>false</td>    *<td>10</td>    *<td>-1</td>    *<td>'ZZZZZZZZZZ'</td>    *</tr>    *</table>    *    * @param sign      If true, returns upper limit, otherwise lower limit    * @param limit     If true, returns value at or near to overflow; otherwise    *                  value at or near to underflow    * @param beyond    If true, returns the value just beyond the limit,    *                  otherwise the value at the limit    * @param precision Precision, or -1 if not applicable    * @param scale     Scale, or -1 if not applicable    * @return Limit value    */
specifier|public
annotation|@
name|Nullable
name|Object
name|getLimit
parameter_list|(
name|boolean
name|sign
parameter_list|,
name|Limit
name|limit
parameter_list|,
name|boolean
name|beyond
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
assert|assert
name|allowsPrecScale
argument_list|(
name|precision
operator|!=
operator|-
literal|1
argument_list|,
name|scale
operator|!=
operator|-
literal|1
argument_list|)
operator|:
name|this
assert|;
if|if
condition|(
name|limit
operator|==
name|Limit
operator|.
name|ZERO
condition|)
block|{
if|if
condition|(
name|beyond
condition|)
block|{
return|return
literal|null
return|;
block|}
name|sign
operator|=
literal|true
expr_stmt|;
block|}
name|Calendar
name|calendar
decl_stmt|;
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|BOOLEAN
case|:
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|ZERO
case|:
return|return
literal|false
return|;
case|case
name|UNDERFLOW
case|:
return|return
literal|null
return|;
case|case
name|OVERFLOW
case|:
if|if
condition|(
name|beyond
operator|||
operator|!
name|sign
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|limit
argument_list|)
throw|;
block|}
case|case
name|TINYINT
case|:
return|return
name|getNumericLimit
argument_list|(
literal|2
argument_list|,
literal|8
argument_list|,
name|sign
argument_list|,
name|limit
argument_list|,
name|beyond
argument_list|)
return|;
case|case
name|SMALLINT
case|:
return|return
name|getNumericLimit
argument_list|(
literal|2
argument_list|,
literal|16
argument_list|,
name|sign
argument_list|,
name|limit
argument_list|,
name|beyond
argument_list|)
return|;
case|case
name|INTEGER
case|:
return|return
name|getNumericLimit
argument_list|(
literal|2
argument_list|,
literal|32
argument_list|,
name|sign
argument_list|,
name|limit
argument_list|,
name|beyond
argument_list|)
return|;
case|case
name|BIGINT
case|:
return|return
name|getNumericLimit
argument_list|(
literal|2
argument_list|,
literal|64
argument_list|,
name|sign
argument_list|,
name|limit
argument_list|,
name|beyond
argument_list|)
return|;
case|case
name|DECIMAL
case|:
name|BigDecimal
name|decimal
init|=
name|getNumericLimit
argument_list|(
literal|10
argument_list|,
name|precision
argument_list|,
name|sign
argument_list|,
name|limit
argument_list|,
name|beyond
argument_list|)
decl_stmt|;
if|if
condition|(
name|decimal
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Decimal values must fit into 64 bits. So, the maximum value of
comment|// a DECIMAL(19, 0) is 2^63 - 1, not 10^19 - 1.
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|OVERFLOW
case|:
specifier|final
name|BigDecimal
name|other
init|=
operator|(
name|BigDecimal
operator|)
name|BIGINT
operator|.
name|getLimit
argument_list|(
name|sign
argument_list|,
name|limit
argument_list|,
name|beyond
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|other
operator|!=
literal|null
operator|&&
name|decimal
operator|.
name|compareTo
argument_list|(
name|other
argument_list|)
operator|==
operator|(
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
condition|)
block|{
name|decimal
operator|=
name|other
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// Apply scale.
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
comment|// do nothing
block|}
if|else if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
name|decimal
operator|=
name|decimal
operator|.
name|divide
argument_list|(
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
name|scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decimal
operator|=
name|decimal
operator|.
name|multiply
argument_list|(
name|BigDecimal
operator|.
name|TEN
operator|.
name|pow
argument_list|(
operator|-
name|scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|decimal
return|;
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
if|if
condition|(
operator|!
name|sign
condition|)
block|{
return|return
literal|null
return|;
comment|// this type does not have negative values
block|}
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|ZERO
case|:
break|break;
case|case
name|UNDERFLOW
case|:
if|if
condition|(
name|beyond
condition|)
block|{
comment|// There is no value between the empty string and the
comment|// smallest non-empty string.
return|return
literal|null
return|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OVERFLOW
case|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|precision
condition|;
operator|++
name|i
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"Z"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|beyond
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"Z"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
case|case
name|BINARY
case|:
case|case
name|VARBINARY
case|:
if|if
condition|(
operator|!
name|sign
condition|)
block|{
return|return
literal|null
return|;
comment|// this type does not have negative values
block|}
name|byte
index|[]
name|bytes
decl_stmt|;
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|ZERO
case|:
name|bytes
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|UNDERFLOW
case|:
if|if
condition|(
name|beyond
condition|)
block|{
comment|// There is no value between the empty string and the
comment|// smallest value.
return|return
literal|null
return|;
block|}
name|bytes
operator|=
operator|new
name|byte
index|[]
block|{
literal|0x00
block|}
expr_stmt|;
break|break;
case|case
name|OVERFLOW
case|:
name|bytes
operator|=
operator|new
name|byte
index|[
name|precision
operator|+
operator|(
name|beyond
condition|?
literal|1
else|:
literal|0
operator|)
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|bytes
argument_list|,
operator|(
name|byte
operator|)
literal|0xff
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|limit
argument_list|)
throw|;
block|}
return|return
name|bytes
return|;
case|case
name|DATE
case|:
name|calendar
operator|=
name|Util
operator|.
name|calendar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|ZERO
case|:
comment|// The epoch.
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
literal|1970
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDERFLOW
case|:
return|return
literal|null
return|;
case|case
name|OVERFLOW
case|:
if|if
condition|(
name|beyond
condition|)
block|{
comment|// It is impossible to represent an invalid year as a date
comment|// literal. SQL dates are represented as 'yyyy-mm-dd', and
comment|// 1<= yyyy<= 9999 is valid. There is no year 0: the year
comment|// before 1AD is 1BC, so SimpleDateFormat renders the day
comment|// before 0001-01-01 (AD) as 0001-12-31 (BC), which looks
comment|// like a valid date.
return|return
literal|null
return|;
block|}
comment|// "SQL:2003 6.1<data type> Access Rules 6" says that year is
comment|// between 1 and 9999, and days/months are the valid Gregorian
comment|// calendar values for these years.
if|if
condition|(
name|sign
condition|)
block|{
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
literal|9999
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|calendar
return|;
case|case
name|TIME
case|:
if|if
condition|(
operator|!
name|sign
condition|)
block|{
return|return
literal|null
return|;
comment|// this type does not have negative values
block|}
if|if
condition|(
name|beyond
condition|)
block|{
return|return
literal|null
return|;
comment|// invalid values are impossible to represent
block|}
name|calendar
operator|=
name|Util
operator|.
name|calendar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|ZERO
case|:
comment|// The epoch.
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDERFLOW
case|:
return|return
literal|null
return|;
case|case
name|OVERFLOW
case|:
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|int
name|millis
init|=
operator|(
name|precision
operator|>=
literal|3
operator|)
condition|?
literal|999
else|:
operator|(
operator|(
name|precision
operator|==
literal|2
operator|)
condition|?
literal|990
else|:
operator|(
operator|(
name|precision
operator|==
literal|1
operator|)
condition|?
literal|900
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
name|millis
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|calendar
return|;
case|case
name|TIMESTAMP
case|:
name|calendar
operator|=
name|Util
operator|.
name|calendar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|ZERO
case|:
comment|// The epoch.
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
literal|1970
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDERFLOW
case|:
return|return
literal|null
return|;
case|case
name|OVERFLOW
case|:
if|if
condition|(
name|beyond
condition|)
block|{
comment|// It is impossible to represent an invalid year as a date
comment|// literal. SQL dates are represented as 'yyyy-mm-dd', and
comment|// 1<= yyyy<= 9999 is valid. There is no year 0: the year
comment|// before 1AD is 1BC, so SimpleDateFormat renders the day
comment|// before 0001-01-01 (AD) as 0001-12-31 (BC), which looks
comment|// like a valid date.
return|return
literal|null
return|;
block|}
comment|// "SQL:2003 6.1<data type> Access Rules 6" says that year is
comment|// between 1 and 9999, and days/months are the valid Gregorian
comment|// calendar values for these years.
if|if
condition|(
name|sign
condition|)
block|{
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
literal|9999
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|int
name|millis
init|=
operator|(
name|precision
operator|>=
literal|3
operator|)
condition|?
literal|999
else|:
operator|(
operator|(
name|precision
operator|==
literal|2
operator|)
condition|?
literal|990
else|:
operator|(
operator|(
name|precision
operator|==
literal|1
operator|)
condition|?
literal|900
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
name|millis
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calendar
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|calendar
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the minimum precision (or length) allowed for this type, or -1 if    * precision/length are not applicable for this type.    *    * @return Minimum allowed precision    */
specifier|public
name|int
name|getMinPrecision
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|DECIMAL
case|:
case|case
name|VARCHAR
case|:
case|case
name|CHAR
case|:
case|case
name|VARBINARY
case|:
case|case
name|BINARY
case|:
case|case
name|TIME
case|:
case|case
name|TIME_WITH_LOCAL_TIME_ZONE
case|:
case|case
name|TIMESTAMP
case|:
case|case
name|TIMESTAMP_WITH_LOCAL_TIME_ZONE
case|:
return|return
literal|1
return|;
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
return|return
name|MIN_INTERVAL_START_PRECISION
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Returns the minimum scale (or fractional second precision in the case of    * intervals) allowed for this type, or -1 if precision/length are not    * applicable for this type.    *    * @return Minimum allowed scale    */
specifier|public
name|int
name|getMinScale
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
comment|// TODO: Minimum numeric scale for decimal
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
return|return
name|MIN_INTERVAL_FRACTIONAL_SECOND_PRECISION
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/** Returns {@code HOUR} for {@code HOUR TO SECOND} and    * {@code HOUR}, {@code SECOND} for {@code SECOND}. */
specifier|public
name|TimeUnit
name|getStartUnit
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
return|return
name|TimeUnit
operator|.
name|YEAR
return|;
case|case
name|INTERVAL_MONTH
case|:
return|return
name|TimeUnit
operator|.
name|MONTH
return|;
case|case
name|INTERVAL_DAY
case|:
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_DAY_SECOND
case|:
return|return
name|TimeUnit
operator|.
name|DAY
return|;
case|case
name|INTERVAL_HOUR
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
return|return
name|TimeUnit
operator|.
name|HOUR
return|;
case|case
name|INTERVAL_MINUTE
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
return|return
name|TimeUnit
operator|.
name|MINUTE
return|;
case|case
name|INTERVAL_SECOND
case|:
return|return
name|TimeUnit
operator|.
name|SECOND
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
comment|/** Returns {@code SECOND} for both {@code HOUR TO SECOND} and    * {@code SECOND}. */
specifier|public
name|TimeUnit
name|getEndUnit
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
return|return
name|TimeUnit
operator|.
name|YEAR
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
return|return
name|TimeUnit
operator|.
name|MONTH
return|;
case|case
name|INTERVAL_DAY
case|:
return|return
name|TimeUnit
operator|.
name|DAY
return|;
case|case
name|INTERVAL_DAY_HOUR
case|:
case|case
name|INTERVAL_HOUR
case|:
return|return
name|TimeUnit
operator|.
name|HOUR
return|;
case|case
name|INTERVAL_DAY_MINUTE
case|:
case|case
name|INTERVAL_HOUR_MINUTE
case|:
case|case
name|INTERVAL_MINUTE
case|:
return|return
name|TimeUnit
operator|.
name|MINUTE
return|;
case|case
name|INTERVAL_DAY_SECOND
case|:
case|case
name|INTERVAL_HOUR_SECOND
case|:
case|case
name|INTERVAL_MINUTE_SECOND
case|:
case|case
name|INTERVAL_SECOND
case|:
return|return
name|TimeUnit
operator|.
name|SECOND
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|isYearMonth
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|INTERVAL_YEAR
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_MONTH
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
comment|/** Limit. */
specifier|public
enum|enum
name|Limit
block|{
name|ZERO
block|,
name|UNDERFLOW
block|,
name|OVERFLOW
block|}
specifier|private
annotation|@
name|Nullable
name|BigDecimal
name|getNumericLimit
parameter_list|(
name|int
name|radix
parameter_list|,
name|int
name|exponent
parameter_list|,
name|boolean
name|sign
parameter_list|,
name|Limit
name|limit
parameter_list|,
name|boolean
name|beyond
parameter_list|)
block|{
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|OVERFLOW
case|:
comment|// 2-based schemes run from -2^(N-1) to 2^(N-1)-1 e.g. -128 to +127
comment|// 10-based schemas run from -(10^N-1) to 10^N-1 e.g. -99 to +99
specifier|final
name|BigDecimal
name|bigRadix
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|radix
argument_list|)
decl_stmt|;
if|if
condition|(
name|radix
operator|==
literal|2
condition|)
block|{
operator|--
name|exponent
expr_stmt|;
block|}
name|BigDecimal
name|decimal
init|=
name|bigRadix
operator|.
name|pow
argument_list|(
name|exponent
argument_list|)
decl_stmt|;
if|if
condition|(
name|sign
operator|||
operator|(
name|radix
operator|!=
literal|2
operator|)
condition|)
block|{
name|decimal
operator|=
name|decimal
operator|.
name|subtract
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|beyond
condition|)
block|{
name|decimal
operator|=
name|decimal
operator|.
name|add
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sign
condition|)
block|{
name|decimal
operator|=
name|decimal
operator|.
name|negate
argument_list|()
expr_stmt|;
block|}
return|return
name|decimal
return|;
case|case
name|UNDERFLOW
case|:
return|return
name|beyond
condition|?
literal|null
else|:
operator|(
name|sign
condition|?
name|BigDecimal
operator|.
name|ONE
else|:
name|BigDecimal
operator|.
name|ONE
operator|.
name|negate
argument_list|()
operator|)
return|;
case|case
name|ZERO
case|:
return|return
name|BigDecimal
operator|.
name|ZERO
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|limit
argument_list|)
throw|;
block|}
block|}
specifier|public
name|SqlLiteral
name|createLiteral
parameter_list|(
name|Object
name|o
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|)
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|BOOLEAN
case|:
return|return
name|SqlLiteral
operator|.
name|createBoolean
argument_list|(
operator|(
name|Boolean
operator|)
name|o
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|TINYINT
case|:
case|case
name|SMALLINT
case|:
case|case
name|INTEGER
case|:
case|case
name|BIGINT
case|:
case|case
name|DECIMAL
case|:
return|return
name|SqlLiteral
operator|.
name|createExactNumeric
argument_list|(
name|o
operator|.
name|toString
argument_list|()
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|VARCHAR
case|:
case|case
name|CHAR
case|:
return|return
name|SqlLiteral
operator|.
name|createCharString
argument_list|(
operator|(
name|String
operator|)
name|o
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|VARBINARY
case|:
case|case
name|BINARY
case|:
return|return
name|SqlLiteral
operator|.
name|createBinaryString
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|o
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|DATE
case|:
return|return
name|SqlLiteral
operator|.
name|createDate
argument_list|(
name|o
operator|instanceof
name|Calendar
condition|?
name|DateString
operator|.
name|fromCalendarFields
argument_list|(
operator|(
name|Calendar
operator|)
name|o
argument_list|)
else|:
operator|(
name|DateString
operator|)
name|o
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|TIME
case|:
return|return
name|SqlLiteral
operator|.
name|createTime
argument_list|(
name|o
operator|instanceof
name|Calendar
condition|?
name|TimeString
operator|.
name|fromCalendarFields
argument_list|(
operator|(
name|Calendar
operator|)
name|o
argument_list|)
else|:
operator|(
name|TimeString
operator|)
name|o
argument_list|,
literal|0
comment|/* todo */
argument_list|,
name|pos
argument_list|)
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|SqlLiteral
operator|.
name|createTimestamp
argument_list|(
name|o
operator|instanceof
name|Calendar
condition|?
name|TimestampString
operator|.
name|fromCalendarFields
argument_list|(
operator|(
name|Calendar
operator|)
name|o
argument_list|)
else|:
operator|(
name|TimestampString
operator|)
name|o
argument_list|,
literal|0
comment|/* todo */
argument_list|,
name|pos
argument_list|)
return|;
default|default:
throw|throw
name|Util
operator|.
name|unexpected
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
comment|/** Returns the name of this type. */
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|toString
argument_list|()
return|;
block|}
comment|/**    * Flags indicating precision/scale combinations.    *    *<p>Note: for intervals:    *    *<ul>    *<li>precision = start (leading field) precision</li>    *<li>scale = fractional second precision</li>    *</ul>    */
specifier|private
interface|interface
name|PrecScale
block|{
name|int
name|NO_NO
init|=
literal|1
decl_stmt|;
name|int
name|YES_NO
init|=
literal|2
decl_stmt|;
name|int
name|YES_YES
init|=
literal|4
decl_stmt|;
block|}
block|}
end_enum

end_unit

