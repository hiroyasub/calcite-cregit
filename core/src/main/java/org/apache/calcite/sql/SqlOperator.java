begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Strong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlOperandTypeChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlOperandTypeInference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlReturnTypeInference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlBasicVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|SqlVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlMonotonicity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
operator|.
name|RESOURCE
import|;
end_import

begin_comment
comment|/**  * A<code>SqlOperator</code> is a type of node in a SQL parse tree (it is NOT a  * node in a SQL parse tree). It includes functions, operators such as '=', and  * syntactic constructs such as 'case' statements. Operators may represent  * query-level expressions (e.g. {@link SqlSelectOperator} or row-level  * expressions (e.g. {@link org.apache.calcite.sql.fun.SqlBetweenOperator}.  *  *<p>Operators have<em>formal operands</em>, meaning ordered (and optionally  * named) placeholders for the values they operate on. For example, the division  * operator takes two operands; the first is the numerator and the second is the  * denominator. In the context of subclass {@link SqlFunction}, formal operands  * are referred to as<em>parameters</em>.  *  *<p>When an operator is instantiated via a {@link SqlCall}, it is supplied  * with<em>actual operands</em>. For example, in the expression<code>3 /  * 5</code>, the literal expression<code>3</code> is the actual operand  * corresponding to the numerator, and<code>5</code> is the actual operand  * corresponding to the denominator. In the context of SqlFunction, actual  * operands are referred to as<em>arguments</em>  *  *<p>In many cases, the formal/actual distinction is clear from context, in  * which case we drop these qualifiers.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SqlOperator
block|{
comment|//~ Static fields/initializers ---------------------------------------------
specifier|public
specifier|static
specifier|final
name|String
name|NL
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
comment|/**    * Maximum precedence.    */
specifier|public
specifier|static
specifier|final
name|int
name|MDX_PRECEDENCE
init|=
literal|200
decl_stmt|;
comment|//~ Instance fields --------------------------------------------------------
comment|/**    * The name of the operator/function. Ex. "OVERLAY" or "TRIM"    */
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
comment|/**    * See {@link SqlKind}. It's possible to have a name that doesn't match the    * kind    */
specifier|public
specifier|final
name|SqlKind
name|kind
decl_stmt|;
comment|/**    * The precedence with which this operator binds to the expression to the    * left. This is less than the right precedence if the operator is    * left-associative.    */
specifier|private
specifier|final
name|int
name|leftPrec
decl_stmt|;
comment|/**    * The precedence with which this operator binds to the expression to the    * right. This is more than the left precedence if the operator is    * left-associative.    */
specifier|private
specifier|final
name|int
name|rightPrec
decl_stmt|;
comment|/** Used to infer the return type of a call to this operator. */
specifier|private
specifier|final
name|SqlReturnTypeInference
name|returnTypeInference
decl_stmt|;
comment|/** Used to infer types of unknown operands. */
specifier|private
specifier|final
name|SqlOperandTypeInference
name|operandTypeInference
decl_stmt|;
comment|/** Used to validate operand types. */
specifier|private
specifier|final
name|SqlOperandTypeChecker
name|operandTypeChecker
decl_stmt|;
comment|//~ Constructors -----------------------------------------------------------
comment|/**    * Creates an operator.    */
specifier|protected
name|SqlOperator
parameter_list|(
name|String
name|name
parameter_list|,
name|SqlKind
name|kind
parameter_list|,
name|int
name|leftPrecedence
parameter_list|,
name|int
name|rightPrecedence
parameter_list|,
name|SqlReturnTypeInference
name|returnTypeInference
parameter_list|,
name|SqlOperandTypeInference
name|operandTypeInference
parameter_list|,
name|SqlOperandTypeChecker
name|operandTypeChecker
parameter_list|)
block|{
assert|assert
name|kind
operator|!=
literal|null
assert|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|this
operator|.
name|leftPrec
operator|=
name|leftPrecedence
expr_stmt|;
name|this
operator|.
name|rightPrec
operator|=
name|rightPrecedence
expr_stmt|;
name|this
operator|.
name|returnTypeInference
operator|=
name|returnTypeInference
expr_stmt|;
name|this
operator|.
name|operandTypeInference
operator|=
name|operandTypeInference
expr_stmt|;
name|this
operator|.
name|operandTypeChecker
operator|=
name|operandTypeChecker
expr_stmt|;
block|}
comment|/**    * Creates an operator specifying left/right associativity.    */
specifier|protected
name|SqlOperator
parameter_list|(
name|String
name|name
parameter_list|,
name|SqlKind
name|kind
parameter_list|,
name|int
name|prec
parameter_list|,
name|boolean
name|leftAssoc
parameter_list|,
name|SqlReturnTypeInference
name|returnTypeInference
parameter_list|,
name|SqlOperandTypeInference
name|operandTypeInference
parameter_list|,
name|SqlOperandTypeChecker
name|operandTypeChecker
parameter_list|)
block|{
name|this
argument_list|(
name|name
argument_list|,
name|kind
argument_list|,
name|leftPrec
argument_list|(
name|prec
argument_list|,
name|leftAssoc
argument_list|)
argument_list|,
name|rightPrec
argument_list|(
name|prec
argument_list|,
name|leftAssoc
argument_list|)
argument_list|,
name|returnTypeInference
argument_list|,
name|operandTypeInference
argument_list|,
name|operandTypeChecker
argument_list|)
expr_stmt|;
block|}
comment|//~ Methods ----------------------------------------------------------------
specifier|protected
specifier|static
name|int
name|leftPrec
parameter_list|(
name|int
name|prec
parameter_list|,
name|boolean
name|leftAssoc
parameter_list|)
block|{
assert|assert
operator|(
name|prec
operator|%
literal|2
operator|)
operator|==
literal|0
assert|;
if|if
condition|(
operator|!
name|leftAssoc
condition|)
block|{
operator|++
name|prec
expr_stmt|;
block|}
return|return
name|prec
return|;
block|}
specifier|protected
specifier|static
name|int
name|rightPrec
parameter_list|(
name|int
name|prec
parameter_list|,
name|boolean
name|leftAssoc
parameter_list|)
block|{
assert|assert
operator|(
name|prec
operator|%
literal|2
operator|)
operator|==
literal|0
assert|;
if|if
condition|(
name|leftAssoc
condition|)
block|{
operator|++
name|prec
expr_stmt|;
block|}
return|return
name|prec
return|;
block|}
specifier|public
name|SqlOperandTypeChecker
name|getOperandTypeChecker
parameter_list|()
block|{
return|return
name|operandTypeChecker
return|;
block|}
comment|/**    * Returns a constraint on the number of operands expected by this operator.    * Subclasses may override this method; when they don't, the range is    * derived from the {@link SqlOperandTypeChecker} associated with this    * operator.    *    * @return acceptable range    */
specifier|public
name|SqlOperandCountRange
name|getOperandCountRange
parameter_list|()
block|{
if|if
condition|(
name|operandTypeChecker
operator|!=
literal|null
condition|)
block|{
return|return
name|operandTypeChecker
operator|.
name|getOperandCountRange
argument_list|()
return|;
block|}
comment|// If you see this error you need to override this method
comment|// or give operandTypeChecker a value.
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|this
argument_list|)
throw|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/**    * Returns the fully-qualified name of this operator.    */
specifier|public
name|SqlIdentifier
name|getNameAsId
parameter_list|()
block|{
return|return
operator|new
name|SqlIdentifier
argument_list|(
name|getName
argument_list|()
argument_list|,
name|SqlParserPos
operator|.
name|ZERO
argument_list|)
return|;
block|}
specifier|public
name|SqlKind
name|getKind
parameter_list|()
block|{
return|return
name|kind
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
specifier|public
name|int
name|getLeftPrec
parameter_list|()
block|{
return|return
name|leftPrec
return|;
block|}
specifier|public
name|int
name|getRightPrec
parameter_list|()
block|{
return|return
name|rightPrec
return|;
block|}
comment|/**    * Returns the syntactic type of this operator, never null.    */
specifier|public
specifier|abstract
name|SqlSyntax
name|getSyntax
parameter_list|()
function_decl|;
comment|/**    * Creates a call to this operand with an array of operands.    *    *<p>The position of the resulting call is the union of the<code>    * pos</code> and the positions of all of the operands.    *    * @param functionQualifier function qualifier (e.g. "DISTINCT"), may be    * @param pos               parser position of the identifier of the call    * @param operands          array of operands    */
specifier|public
name|SqlCall
name|createCall
parameter_list|(
name|SqlLiteral
name|functionQualifier
parameter_list|,
name|SqlParserPos
name|pos
parameter_list|,
name|SqlNode
modifier|...
name|operands
parameter_list|)
block|{
name|pos
operator|=
name|pos
operator|.
name|plusAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|operands
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SqlBasicCall
argument_list|(
name|this
argument_list|,
name|operands
argument_list|,
name|pos
argument_list|,
literal|false
argument_list|,
name|functionQualifier
argument_list|)
return|;
block|}
comment|/**    * Creates a call to this operand with an array of operands.    *    *<p>The position of the resulting call is the union of the<code>    * pos</code> and the positions of all of the operands.    *    * @param pos      Parser position    * @param operands List of arguments    * @return call to this operator    */
specifier|public
specifier|final
name|SqlCall
name|createCall
parameter_list|(
name|SqlParserPos
name|pos
parameter_list|,
name|SqlNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|createCall
argument_list|(
literal|null
argument_list|,
name|pos
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/**    * Creates a call to this operand with a list of operands contained in a    * {@link SqlNodeList}.    *    *<p>The position of the resulting call inferred from the SqlNodeList.    *    * @param nodeList List of arguments    * @return call to this operator    */
specifier|public
specifier|final
name|SqlCall
name|createCall
parameter_list|(
name|SqlNodeList
name|nodeList
parameter_list|)
block|{
return|return
name|createCall
argument_list|(
literal|null
argument_list|,
name|nodeList
operator|.
name|getParserPosition
argument_list|()
argument_list|,
name|nodeList
operator|.
name|toArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a call to this operand with a list of operands.    *    *<p>The position of the resulting call is the union of the<code>    * pos</code> and the positions of all of the operands.    */
specifier|public
specifier|final
name|SqlCall
name|createCall
parameter_list|(
name|SqlParserPos
name|pos
parameter_list|,
name|List
argument_list|<
name|?
extends|extends
name|SqlNode
argument_list|>
name|operandList
parameter_list|)
block|{
return|return
name|createCall
argument_list|(
literal|null
argument_list|,
name|pos
argument_list|,
name|operandList
operator|.
name|toArray
argument_list|(
operator|new
name|SqlNode
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Rewrites a call to this operator. Some operators are implemented as    * trivial rewrites (e.g. NULLIF becomes CASE). However, we don't do this at    * createCall time because we want to preserve the original SQL syntax as    * much as possible; instead, we do this before the call is validated (so    * the trivial operator doesn't need its own implementation of type    * derivation methods). The default implementation is to just return the    * original call without any rewrite.    *    * @param validator Validator    * @param call      Call to be rewritten    * @return rewritten call    */
specifier|public
name|SqlNode
name|rewriteCall
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
return|return
name|call
return|;
block|}
comment|/**    * Writes a SQL representation of a call to this operator to a writer,    * including parentheses if the operators on either side are of greater    * precedence.    *    *<p>The default implementation of this method delegates to    * {@link SqlSyntax#unparse}.    */
specifier|public
name|void
name|unparse
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|getSyntax
argument_list|()
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|this
argument_list|,
name|call
argument_list|,
name|leftPrec
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|protected
name|void
name|unparseListClause
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|clause
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|nodeList
init|=
name|clause
operator|instanceof
name|SqlNodeList
condition|?
operator|(
name|SqlNodeList
operator|)
name|clause
else|:
name|SqlNodeList
operator|.
name|of
argument_list|(
name|clause
argument_list|)
decl_stmt|;
name|writer
operator|.
name|list
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|SIMPLE
argument_list|,
name|SqlWriter
operator|.
name|COMMA
argument_list|,
name|nodeList
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|protected
name|void
name|unparseListClause
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlNode
name|clause
parameter_list|,
name|SqlKind
name|sepKind
parameter_list|)
block|{
specifier|final
name|SqlNodeList
name|nodeList
init|=
name|clause
operator|instanceof
name|SqlNodeList
condition|?
operator|(
name|SqlNodeList
operator|)
name|clause
else|:
name|SqlNodeList
operator|.
name|of
argument_list|(
name|clause
argument_list|)
decl_stmt|;
specifier|final
name|SqlBinaryOperator
name|sepOp
decl_stmt|;
if|if
condition|(
name|sepKind
operator|==
literal|null
condition|)
block|{
name|sepOp
operator|=
name|SqlWriter
operator|.
name|COMMA
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|sepKind
condition|)
block|{
case|case
name|AND
case|:
name|sepOp
operator|=
name|SqlStdOperatorTable
operator|.
name|AND
expr_stmt|;
break|break;
case|case
name|OR
case|:
name|sepOp
operator|=
name|SqlStdOperatorTable
operator|.
name|OR
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
name|writer
operator|.
name|list
argument_list|(
name|SqlWriter
operator|.
name|FrameTypeEnum
operator|.
name|SIMPLE
argument_list|,
name|sepOp
argument_list|,
name|nodeList
argument_list|)
expr_stmt|;
block|}
comment|// override Object
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|SqlOperator
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|obj
operator|.
name|getClass
argument_list|()
operator|.
name|equals
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SqlOperator
name|other
init|=
operator|(
name|SqlOperator
operator|)
name|obj
decl_stmt|;
return|return
name|name
operator|.
name|equals
argument_list|(
name|other
operator|.
name|name
argument_list|)
operator|&&
name|kind
operator|==
name|other
operator|.
name|kind
return|;
block|}
specifier|public
name|boolean
name|isName
parameter_list|(
name|String
name|testName
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|)
block|{
return|return
name|caseSensitive
condition|?
name|name
operator|.
name|equals
argument_list|(
name|testName
argument_list|)
else|:
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
name|testName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|kind
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * Validates a call to this operator.    *    *<p>This method should not perform type-derivation or perform validation    * related related to types. That is done later, by    * {@link #deriveType(SqlValidator, SqlValidatorScope, SqlCall)}. This method    * should focus on structural validation.    *    *<p>A typical implementation of this method first validates the operands,    * then performs some operator-specific logic. The default implementation    * just validates the operands.    *    *<p>This method is the default implementation of {@link SqlCall#validate};    * but note that some sub-classes of {@link SqlCall} never call this method.    *    * @param call         the call to this operator    * @param validator    the active validator    * @param scope        validator scope    * @param operandScope validator scope in which to validate operands to this    *                     call; usually equal to scope, but not always because    *                     some operators introduce new scopes    * @see SqlNode#validateExpr(SqlValidator, SqlValidatorScope)    * @see #deriveType(SqlValidator, SqlValidatorScope, SqlCall)    */
specifier|public
name|void
name|validateCall
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlValidatorScope
name|operandScope
parameter_list|)
block|{
assert|assert
name|call
operator|.
name|getOperator
argument_list|()
operator|==
name|this
assert|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|operand
operator|.
name|validateExpr
argument_list|(
name|validator
argument_list|,
name|operandScope
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Validates the operands of a call, inferring the return type in the    * process.    *    * @param validator active validator    * @param scope     validation scope    * @param call      call to be validated    * @return inferred type    */
specifier|public
specifier|final
name|RelDataType
name|validateOperands
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
comment|// Let subclasses know what's up.
name|preValidateCall
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
expr_stmt|;
comment|// Check the number of operands
name|checkOperandCount
argument_list|(
name|validator
argument_list|,
name|operandTypeChecker
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|SqlCallBinding
name|opBinding
init|=
operator|new
name|SqlCallBinding
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|checkOperandTypes
argument_list|(
name|opBinding
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Now infer the result type.
name|RelDataType
name|ret
init|=
name|inferReturnType
argument_list|(
name|opBinding
argument_list|)
decl_stmt|;
operator|(
operator|(
name|SqlValidatorImpl
operator|)
name|validator
operator|)
operator|.
name|setValidatedNodeType
argument_list|(
name|call
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Receives notification that validation of a call to this operator is    * beginning. Subclasses can supply custom behavior; default implementation    * does nothing.    *    * @param validator invoking validator    * @param scope     validation scope    * @param call      the call being validated    */
specifier|protected
name|void
name|preValidateCall
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
block|}
comment|/**    * Infers the return type of an invocation of this operator; only called    * after the number and types of operands have already been validated.    * Subclasses must either override this method or supply an instance of    * {@link SqlReturnTypeInference} to the constructor.    *    * @param opBinding description of invocation (not necessarily a    * {@link SqlCall})    * @return inferred return type    */
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
if|if
condition|(
name|returnTypeInference
operator|!=
literal|null
condition|)
block|{
name|RelDataType
name|returnType
init|=
name|returnTypeInference
operator|.
name|inferReturnType
argument_list|(
name|opBinding
argument_list|)
decl_stmt|;
if|if
condition|(
name|returnType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot infer return type for "
operator|+
name|opBinding
operator|.
name|getOperator
argument_list|()
operator|+
literal|"; operand types: "
operator|+
name|opBinding
operator|.
name|collectOperandTypes
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|returnType
return|;
block|}
comment|// Derived type should have overridden this method, since it didn't
comment|// supply a type inference rule.
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|this
argument_list|)
throw|;
block|}
comment|/**    * Derives the type of a call to this operator.    *    *<p>This method is an intrinsic part of the validation process so, unlike    * {@link #inferReturnType}, specific operators would not typically override    * this method.    *    * @param validator Validator    * @param scope     Scope of validation    * @param call      Call to this operator    * @return Type of call    */
specifier|public
name|RelDataType
name|deriveType
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
name|RelDataType
name|nodeType
init|=
name|validator
operator|.
name|deriveType
argument_list|(
name|scope
argument_list|,
name|operand
argument_list|)
decl_stmt|;
assert|assert
name|nodeType
operator|!=
literal|null
assert|;
block|}
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|args
init|=
name|constructOperandList
argument_list|(
name|validator
argument_list|,
name|call
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelDataType
argument_list|>
name|argTypes
init|=
name|constructArgTypeList
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|call
argument_list|,
name|args
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Always disable type coercion for builtin operator operands,
comment|// they are handled by the TypeCoercion specifically.
specifier|final
name|SqlOperator
name|sqlOperator
init|=
name|SqlUtil
operator|.
name|lookupRoutine
argument_list|(
name|validator
operator|.
name|getOperatorTable
argument_list|()
argument_list|,
name|validator
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|getNameAsId
argument_list|()
argument_list|,
name|argTypes
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|getSyntax
argument_list|()
argument_list|,
name|getKind
argument_list|()
argument_list|,
name|validator
operator|.
name|getCatalogReader
argument_list|()
operator|.
name|nameMatcher
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
operator|(
operator|(
name|SqlBasicCall
operator|)
name|call
operator|)
operator|.
name|setOperator
argument_list|(
name|sqlOperator
argument_list|)
expr_stmt|;
name|RelDataType
name|type
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|validateOperands
argument_list|(
name|validator
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
decl_stmt|;
comment|// Validate and determine coercibility and resulting collation
comment|// name of binary operator if needed.
name|type
operator|=
name|adjustType
argument_list|(
name|validator
argument_list|,
name|call
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|SqlValidatorUtil
operator|.
name|checkCharsetAndCollateConsistentIfCharType
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|constructArgNameList
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
comment|// If any arguments are named, construct a map.
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|String
argument_list|>
name|nameBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ARGUMENT_ASSIGNMENT
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|operand
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|nameBuilder
operator|.
name|add
argument_list|(
operator|(
operator|(
name|SqlIdentifier
operator|)
name|operandList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getSimple
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ImmutableList
argument_list|<
name|String
argument_list|>
name|argNames
init|=
name|nameBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|argNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|argNames
return|;
block|}
block|}
specifier|protected
name|List
argument_list|<
name|SqlNode
argument_list|>
name|constructOperandList
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|argNames
parameter_list|)
block|{
if|if
condition|(
name|argNames
operator|==
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|getOperandList
argument_list|()
return|;
block|}
if|if
condition|(
name|argNames
operator|.
name|size
argument_list|()
operator|<
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|call
argument_list|,
name|RESOURCE
operator|.
name|someButNotAllArgumentsAreNamed
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|int
name|duplicate
init|=
name|Util
operator|.
name|firstDuplicate
argument_list|(
name|argNames
argument_list|)
decl_stmt|;
if|if
condition|(
name|duplicate
operator|>=
literal|0
condition|)
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|call
argument_list|,
name|RESOURCE
operator|.
name|duplicateArgumentName
argument_list|(
name|argNames
operator|.
name|get
argument_list|(
name|duplicate
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|SqlNode
argument_list|>
name|argBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ARGUMENT_ASSIGNMENT
condition|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operandList
init|=
operator|(
operator|(
name|SqlCall
operator|)
name|operand
operator|)
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
name|argBuilder
operator|.
name|add
argument_list|(
name|operandList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|argBuilder
operator|.
name|build
argument_list|()
return|;
block|}
specifier|protected
name|List
argument_list|<
name|RelDataType
argument_list|>
name|constructArgTypeList
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|List
argument_list|<
name|SqlNode
argument_list|>
name|args
parameter_list|,
name|boolean
name|convertRowArgToColumnList
parameter_list|)
block|{
comment|// Scope for operands. Usually the same as 'scope'.
specifier|final
name|SqlValidatorScope
name|operandScope
init|=
name|scope
operator|.
name|getOperandScope
argument_list|(
name|call
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RelDataType
argument_list|>
name|argTypeBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|SqlNode
name|operand
range|:
name|args
control|)
block|{
name|RelDataType
name|nodeType
decl_stmt|;
comment|// for row arguments that should be converted to ColumnList
comment|// types, set the nodeType to a ColumnList type but defer
comment|// validating the arguments of the row constructor until we know
comment|// for sure that the row argument maps to a ColumnList type
if|if
condition|(
name|operand
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|ROW
operator|&&
name|convertRowArgToColumnList
condition|)
block|{
name|RelDataTypeFactory
name|typeFactory
init|=
name|validator
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|nodeType
operator|=
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|COLUMN_LIST
argument_list|)
expr_stmt|;
operator|(
operator|(
name|SqlValidatorImpl
operator|)
name|validator
operator|)
operator|.
name|setValidatedNodeType
argument_list|(
name|operand
argument_list|,
name|nodeType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeType
operator|=
name|validator
operator|.
name|deriveType
argument_list|(
name|operandScope
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
name|argTypeBuilder
operator|.
name|add
argument_list|(
name|nodeType
argument_list|)
expr_stmt|;
block|}
return|return
name|argTypeBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Returns whether this operator should be surrounded by space when    * unparsed.    *    * @return whether this operator should be surrounded by space    */
name|boolean
name|needsSpace
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Validates and determines coercibility and resulting collation name of    * binary operator if needed.    */
specifier|protected
name|RelDataType
name|adjustType
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
specifier|final
name|SqlCall
name|call
parameter_list|,
name|RelDataType
name|type
parameter_list|)
block|{
return|return
name|type
return|;
block|}
comment|/**    * Infers the type of a call to this operator with a given set of operand    * types. Shorthand for {@link #inferReturnType(SqlOperatorBinding)}.    */
specifier|public
specifier|final
name|RelDataType
name|inferReturnType
parameter_list|(
name|RelDataTypeFactory
name|typeFactory
parameter_list|,
name|List
argument_list|<
name|RelDataType
argument_list|>
name|operandTypes
parameter_list|)
block|{
return|return
name|inferReturnType
argument_list|(
operator|new
name|ExplicitOperatorBinding
argument_list|(
name|typeFactory
argument_list|,
name|this
argument_list|,
name|operandTypes
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Checks that the operand values in a {@link SqlCall} to this operator are    * valid. Subclasses must either override this method or supply an instance    * of {@link SqlOperandTypeChecker} to the constructor.    *    * @param callBinding    description of call    * @param throwOnFailure whether to throw an exception if check fails    *                       (otherwise returns false in that case)    * @return whether check succeeded    */
specifier|public
name|boolean
name|checkOperandTypes
parameter_list|(
name|SqlCallBinding
name|callBinding
parameter_list|,
name|boolean
name|throwOnFailure
parameter_list|)
block|{
comment|// Check that all of the operands are of the right type.
if|if
condition|(
literal|null
operator|==
name|operandTypeChecker
condition|)
block|{
comment|// If you see this you must either give operandTypeChecker a value
comment|// or override this method.
throw|throw
name|Util
operator|.
name|needToImplement
argument_list|(
name|this
argument_list|)
throw|;
block|}
if|if
condition|(
name|kind
operator|!=
name|SqlKind
operator|.
name|ARGUMENT_ASSIGNMENT
condition|)
block|{
for|for
control|(
name|Ord
argument_list|<
name|SqlNode
argument_list|>
name|operand
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|callBinding
operator|.
name|operands
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|operand
operator|.
name|e
operator|!=
literal|null
operator|&&
name|operand
operator|.
name|e
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|DEFAULT
operator|&&
operator|!
name|operandTypeChecker
operator|.
name|isOptional
argument_list|(
name|operand
operator|.
name|i
argument_list|)
condition|)
block|{
throw|throw
name|callBinding
operator|.
name|newValidationError
argument_list|(
name|RESOURCE
operator|.
name|defaultForOptionalParameter
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|operandTypeChecker
operator|.
name|checkOperandTypes
argument_list|(
name|callBinding
argument_list|,
name|throwOnFailure
argument_list|)
return|;
block|}
specifier|protected
name|void
name|checkOperandCount
parameter_list|(
name|SqlValidator
name|validator
parameter_list|,
name|SqlOperandTypeChecker
name|argType
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
name|SqlOperandCountRange
name|od
init|=
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getOperandCountRange
argument_list|()
decl_stmt|;
if|if
condition|(
name|od
operator|.
name|isValidCount
argument_list|(
name|call
operator|.
name|operandCount
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|od
operator|.
name|getMin
argument_list|()
operator|==
name|od
operator|.
name|getMax
argument_list|()
condition|)
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|call
argument_list|,
name|RESOURCE
operator|.
name|invalidArgCount
argument_list|(
name|call
operator|.
name|getOperator
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|od
operator|.
name|getMin
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|validator
operator|.
name|newValidationError
argument_list|(
name|call
argument_list|,
name|RESOURCE
operator|.
name|wrongNumOfArguments
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns whether the given operands are valid. If not valid and    * {@code fail}, throws an assertion error.    *    *<p>Similar to {@link #checkOperandCount}, but some operators may have    * different valid operands in {@link SqlNode} and {@code RexNode} formats    * (some examples are CAST and AND), and this method throws internal errors,    * not user errors.</p>    */
specifier|public
name|boolean
name|validRexOperands
parameter_list|(
name|int
name|count
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Returns a template describing how the operator signature is to be built.    * E.g for the binary + operator the template looks like "{1} {0} {2}" {0}    * is the operator, subsequent numbers are operands.    *    * @param operandsCount is used with functions that can take a variable    *                      number of operands    * @return signature template, or null to indicate that a default template    * will suffice    */
specifier|public
name|String
name|getSignatureTemplate
parameter_list|(
specifier|final
name|int
name|operandsCount
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Returns a string describing the expected operand types of a call, e.g.    * "SUBSTR(VARCHAR, INTEGER, INTEGER)".    */
specifier|public
specifier|final
name|String
name|getAllowedSignatures
parameter_list|()
block|{
return|return
name|getAllowedSignatures
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Returns a string describing the expected operand types of a call, e.g.    * "SUBSTRING(VARCHAR, INTEGER, INTEGER)" where the name (SUBSTRING in this    * example) can be replaced by a specified name.    */
specifier|public
name|String
name|getAllowedSignatures
parameter_list|(
name|String
name|opNameToUse
parameter_list|)
block|{
assert|assert
name|operandTypeChecker
operator|!=
literal|null
operator|:
literal|"If you see this, assign operandTypeChecker a value "
operator|+
literal|"or override this function"
assert|;
return|return
name|operandTypeChecker
operator|.
name|getAllowedSignatures
argument_list|(
name|this
argument_list|,
name|opNameToUse
argument_list|)
operator|.
name|trim
argument_list|()
return|;
block|}
specifier|public
name|SqlOperandTypeInference
name|getOperandTypeInference
parameter_list|()
block|{
return|return
name|operandTypeInference
return|;
block|}
comment|/**    * Returns whether this operator is an aggregate function. By default,    * subclass type is used (an instance of SqlAggFunction is assumed to be an    * aggregator; anything else is not).    *    *<p>Per SQL:2011, there are<dfn>aggregate functions</dfn> and    *<dfn>window functions</dfn>.    * Every aggregate function (e.g. SUM) is also a window function.    * There are window functions that are not aggregate functions, e.g. RANK,    * NTILE, LEAD, FIRST_VALUE.</p>    *    *<p>Collectively, aggregate and window functions are called<dfn>analytic    * functions</dfn>. Despite its name, this method returns true for every    * analytic function.</p>    *    * @see #requiresOrder()    *    * @return whether this operator is an analytic function (aggregate function    * or window function)    */
specifier|public
name|boolean
name|isAggregator
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Returns whether this is a window function that requires an OVER clause.    *    *<p>For example, returns true for {@code RANK}, {@code DENSE_RANK} and    * other ranking functions; returns false for {@code SUM}, {@code COUNT},    * {@code MIN}, {@code MAX}, {@code AVG} (they can be used as non-window    * aggregate functions).    *    *<p>If {@code requiresOver} returns true, then {@link #isAggregator()} must    * also return true.    *    * @see #allowsFraming()    * @see #requiresOrder()    */
specifier|public
name|boolean
name|requiresOver
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether this is a window function that requires ordering.    *    *<p>Per SQL:2011, 2, 6.10: "If&lt;ntile function&gt;,&lt;lead or lag    * function&gt;, RANK or DENSE_RANK is specified, then the window ordering    * clause shall be present."</p>    *    * @see #isAggregator()    */
specifier|public
name|boolean
name|requiresOrder
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether this is a window function that allows framing (i.e. a    * ROWS or RANGE clause in the window specification).    */
specifier|public
name|boolean
name|allowsFraming
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether this is a group function.    *    *<p>Group functions can only appear in the GROUP BY clause.    *    *<p>Examples are {@code HOP}, {@code TUMBLE}, {@code SESSION}.    *    *<p>Group functions have auxiliary functions, e.g. {@code HOP_START}, but    * these are not group functions.    */
specifier|public
name|boolean
name|isGroup
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Returns whether this is an group auxiliary function.    *    *<p>Examples are {@code HOP_START} and {@code HOP_END} (both auxiliary to    * {@code HOP}).    *    * @see #isGroup()    */
specifier|public
name|boolean
name|isGroupAuxiliary
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Accepts a {@link SqlVisitor}, visiting each operand of a call. Returns    * null.    *    * @param visitor Visitor    * @param call    Call to visit    */
specifier|public
parameter_list|<
name|R
parameter_list|>
name|R
name|acceptCall
parameter_list|(
name|SqlVisitor
argument_list|<
name|R
argument_list|>
name|visitor
parameter_list|,
name|SqlCall
name|call
parameter_list|)
block|{
for|for
control|(
name|SqlNode
name|operand
range|:
name|call
operator|.
name|getOperandList
argument_list|()
control|)
block|{
if|if
condition|(
name|operand
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|operand
operator|.
name|accept
argument_list|(
name|visitor
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Accepts a {@link SqlVisitor}, directing an    * {@link org.apache.calcite.sql.util.SqlBasicVisitor.ArgHandler}    * to visit an operand of a call.    *    *<p>The argument handler allows fine control about how the operands are    * visited, and how the results are combined.    *    * @param visitor         Visitor    * @param call            Call to visit    * @param onlyExpressions If true, ignores operands which are not    *                        expressions. For example, in the call to the    *<code>AS</code> operator    * @param argHandler      Called for each operand    */
specifier|public
parameter_list|<
name|R
parameter_list|>
name|void
name|acceptCall
parameter_list|(
name|SqlVisitor
argument_list|<
name|R
argument_list|>
name|visitor
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|boolean
name|onlyExpressions
parameter_list|,
name|SqlBasicVisitor
operator|.
name|ArgHandler
argument_list|<
name|R
argument_list|>
name|argHandler
parameter_list|)
block|{
name|List
argument_list|<
name|SqlNode
argument_list|>
name|operands
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|operands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|argHandler
operator|.
name|visitChild
argument_list|(
name|visitor
argument_list|,
name|call
argument_list|,
name|i
argument_list|,
name|operands
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns the return type inference strategy for this operator, or null if    * return type inference is implemented by a subclass override. */
specifier|public
name|SqlReturnTypeInference
name|getReturnTypeInference
parameter_list|()
block|{
return|return
name|returnTypeInference
return|;
block|}
comment|/**    * Returns the {@link Strong.Policy} strategy for this operator, or null if    * there is no particular strategy, in which case this policy will be deducted    * from the operator's {@link SqlKind}.    *    * @see Strong    */
specifier|public
name|Supplier
argument_list|<
name|Strong
operator|.
name|Policy
argument_list|>
name|getStrongPolicyInference
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Returns whether this operator is monotonic.    *    *<p>Default implementation returns {@link SqlMonotonicity#NOT_MONOTONIC}.    *    * @param call  Call to this operator    * @param scope Scope in which the call occurs    *    * @deprecated Use {@link #getMonotonicity(SqlOperatorBinding)}    */
annotation|@
name|Deprecated
comment|// to be removed before 2.0
specifier|public
name|SqlMonotonicity
name|getMonotonicity
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlValidatorScope
name|scope
parameter_list|)
block|{
return|return
name|getMonotonicity
argument_list|(
operator|new
name|SqlCallBinding
argument_list|(
name|scope
operator|.
name|getValidator
argument_list|()
argument_list|,
name|scope
argument_list|,
name|call
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns whether a call to this operator is monotonic.    *    *<p>Default implementation returns {@link SqlMonotonicity#NOT_MONOTONIC}.    *    * @param call Call to this operator with particular arguments and information    *             about the monotonicity of the arguments    */
specifier|public
name|SqlMonotonicity
name|getMonotonicity
parameter_list|(
name|SqlOperatorBinding
name|call
parameter_list|)
block|{
return|return
name|SqlMonotonicity
operator|.
name|NOT_MONOTONIC
return|;
block|}
comment|/**    * Returns whether a call to this operator is guaranteed to always return    * the same result given the same operands; true is assumed by default.    */
specifier|public
name|boolean
name|isDeterministic
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether a call to this operator is not sensitive to the operands input order.    * An operator is symmetrical if the call returns the same result when    * the operands are shuffled.    *    *<p>By default, returns true for {@link SqlKind#SYMMETRICAL}.    */
specifier|public
name|boolean
name|isSymmetrical
parameter_list|()
block|{
return|return
name|SqlKind
operator|.
name|SYMMETRICAL
operator|.
name|contains
argument_list|(
name|kind
argument_list|)
return|;
block|}
comment|/**    * Returns whether it is unsafe to cache query plans referencing this    * operator; false is assumed by default.    */
specifier|public
name|boolean
name|isDynamicFunction
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Method to check if call requires expansion when it has decimal operands.    * The default implementation is to return true.    */
specifier|public
name|boolean
name|requiresDecimalExpansion
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Returns whether the<code>ordinal</code>th argument to this operator must    * be scalar (as opposed to a query).    *    *<p>If true (the default), the validator will attempt to convert the    * argument into a scalar sub-query, which must have one column and return at    * most one row.    *    *<p>Operators such as<code>SELECT</code> and<code>EXISTS</code> override    * this method.    */
specifier|public
name|boolean
name|argumentMustBeScalar
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

