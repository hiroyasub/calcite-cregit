begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAsOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBasicCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlBinaryOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlFunctionCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlInternalOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLateralOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlNumericLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperandCountRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperatorBinding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOverOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlPostfixOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlPrefixOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlProcedureCallOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlRankFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSampleSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSetOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlSpecialOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUnnestOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlValuesOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|InferTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|IntervalSqlType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|OperandTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|ReturnTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlOperandCountRanges
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|util
operator|.
name|ReflectiveSqlOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlModality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql2rel
operator|.
name|AuxiliaryConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Implementation of {@link org.apache.calcite.sql.SqlOperatorTable} containing  * the standard operators and functions.  */
end_comment

begin_class
specifier|public
class|class
name|SqlStdOperatorTable
extends|extends
name|ReflectiveSqlOperatorTable
block|{
comment|//~ Static fields/initializers ---------------------------------------------
comment|/**    * The standard operator table.    */
specifier|private
specifier|static
name|SqlStdOperatorTable
name|instance
decl_stmt|;
comment|//-------------------------------------------------------------
comment|//                   SET OPERATORS
comment|//-------------------------------------------------------------
comment|// The set operators can be compared to the arithmetic operators
comment|// UNION -> +
comment|// EXCEPT -> -
comment|// INTERSECT -> *
comment|// which explains the different precedence values
specifier|public
specifier|static
specifier|final
name|SqlSetOperator
name|UNION
init|=
operator|new
name|SqlSetOperator
argument_list|(
literal|"UNION"
argument_list|,
name|SqlKind
operator|.
name|UNION
argument_list|,
literal|14
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSetOperator
name|UNION_ALL
init|=
operator|new
name|SqlSetOperator
argument_list|(
literal|"UNION ALL"
argument_list|,
name|SqlKind
operator|.
name|UNION
argument_list|,
literal|14
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSetOperator
name|EXCEPT
init|=
operator|new
name|SqlSetOperator
argument_list|(
literal|"EXCEPT"
argument_list|,
name|SqlKind
operator|.
name|EXCEPT
argument_list|,
literal|14
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSetOperator
name|EXCEPT_ALL
init|=
operator|new
name|SqlSetOperator
argument_list|(
literal|"EXCEPT ALL"
argument_list|,
name|SqlKind
operator|.
name|EXCEPT
argument_list|,
literal|14
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSetOperator
name|INTERSECT
init|=
operator|new
name|SqlSetOperator
argument_list|(
literal|"INTERSECT"
argument_list|,
name|SqlKind
operator|.
name|INTERSECT
argument_list|,
literal|18
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSetOperator
name|INTERSECT_ALL
init|=
operator|new
name|SqlSetOperator
argument_list|(
literal|"INTERSECT ALL"
argument_list|,
name|SqlKind
operator|.
name|INTERSECT
argument_list|,
literal|18
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/**    * The "MULTISET UNION" operator.    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetSetOperator
name|MULTISET_UNION
init|=
operator|new
name|SqlMultisetSetOperator
argument_list|(
literal|"MULTISET UNION"
argument_list|,
literal|14
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/**    * The "MULTISET UNION ALL" operator.    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetSetOperator
name|MULTISET_UNION_ALL
init|=
operator|new
name|SqlMultisetSetOperator
argument_list|(
literal|"MULTISET UNION ALL"
argument_list|,
literal|14
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/**    * The "MULTISET EXCEPT" operator.    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetSetOperator
name|MULTISET_EXCEPT
init|=
operator|new
name|SqlMultisetSetOperator
argument_list|(
literal|"MULTISET EXCEPT"
argument_list|,
literal|14
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/**    * The "MULTISET EXCEPT ALL" operator.    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetSetOperator
name|MULTISET_EXCEPT_ALL
init|=
operator|new
name|SqlMultisetSetOperator
argument_list|(
literal|"MULTISET EXCEPT ALL"
argument_list|,
literal|14
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/**    * The "MULTISET INTERSECT" operator.    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetSetOperator
name|MULTISET_INTERSECT
init|=
operator|new
name|SqlMultisetSetOperator
argument_list|(
literal|"MULTISET INTERSECT"
argument_list|,
literal|18
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/**    * The "MULTISET INTERSECT ALL" operator.    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetSetOperator
name|MULTISET_INTERSECT_ALL
init|=
operator|new
name|SqlMultisetSetOperator
argument_list|(
literal|"MULTISET INTERSECT ALL"
argument_list|,
literal|18
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//-------------------------------------------------------------
comment|//                   BINARY OPERATORS
comment|//-------------------------------------------------------------
comment|/**    * Logical<code>AND</code> operator.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|AND
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"AND"
argument_list|,
name|SqlKind
operator|.
name|AND
argument_list|,
literal|24
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE_OPTIMIZED
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN_BOOLEAN
argument_list|)
decl_stmt|;
comment|/**    *<code>AS</code> operator associates an expression in the SELECT clause    * with an alias.    */
specifier|public
specifier|static
specifier|final
name|SqlAsOperator
name|AS
init|=
operator|new
name|SqlAsOperator
argument_list|()
decl_stmt|;
comment|/**    *<code>ARGUMENT_ASSIGNMENT</code> operator (<code>=&lt;</code>)    * assigns an argument to a function call to a particular named parameter.    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|ARGUMENT_ASSIGNMENT
init|=
operator|new
name|SqlArgumentAssignmentOperator
argument_list|()
decl_stmt|;
comment|/**    *<code>DEFAULT</code> operator indicates that an argument to a function call    * is to take its default value..    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|DEFAULT
init|=
operator|new
name|SqlDefaultOperator
argument_list|()
decl_stmt|;
comment|/**<code>FILTER</code> operator filters which rows are included in an    *  aggregate function. */
specifier|public
specifier|static
specifier|final
name|SqlFilterOperator
name|FILTER
init|=
operator|new
name|SqlFilterOperator
argument_list|()
decl_stmt|;
comment|/** {@code CUBE} operator, occurs within {@code GROUP BY} clause    * or nested within a {@code GROUPING SETS}. */
specifier|public
specifier|static
specifier|final
name|SqlInternalOperator
name|CUBE
init|=
operator|new
name|SqlRollupOperator
argument_list|(
literal|"CUBE"
argument_list|,
name|SqlKind
operator|.
name|CUBE
argument_list|)
decl_stmt|;
comment|/** {@code ROLLUP} operator, occurs within {@code GROUP BY} clause    * or nested within a {@code GROUPING SETS}. */
specifier|public
specifier|static
specifier|final
name|SqlInternalOperator
name|ROLLUP
init|=
operator|new
name|SqlRollupOperator
argument_list|(
literal|"ROLLUP"
argument_list|,
name|SqlKind
operator|.
name|ROLLUP
argument_list|)
decl_stmt|;
comment|/** {@code GROUPING SETS} operator, occurs within {@code GROUP BY} clause    * or nested within a {@code GROUPING SETS}. */
specifier|public
specifier|static
specifier|final
name|SqlInternalOperator
name|GROUPING_SETS
init|=
operator|new
name|SqlRollupOperator
argument_list|(
literal|"GROUPING SETS"
argument_list|,
name|SqlKind
operator|.
name|GROUPING_SETS
argument_list|)
decl_stmt|;
comment|/** {@code GROUPING} function. Occurs in similar places to an aggregate    * function ({@code SELECT}, {@code HAVING} clause, etc. of an aggregate    * query), but not technically an aggregate function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupingFunction
name|GROUPING
init|=
operator|new
name|SqlGroupingFunction
argument_list|(
literal|"GROUPING"
argument_list|)
decl_stmt|;
comment|/** {@code GROUP_ID} function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupIdFunction
name|GROUP_ID
init|=
operator|new
name|SqlGroupIdFunction
argument_list|()
decl_stmt|;
comment|/** {@code GROUP_ID} function is a synonym for {@code GROUPING}.    *    *<p>Some history. The {@code GROUPING} function is in the SQL standard,    * and originally supported only one argument. The {@code GROUP_ID} is not    * standard (though supported in Oracle and SQL Server) and supports zero or    * more arguments.    *    *<p>The SQL standard has changed to allow {@code GROUPING} to have multiple    * arguments. It is now equivalent to {@code GROUP_ID}, so we made    * {@code GROUP_ID} a synonym for {@code GROUPING}. */
specifier|public
specifier|static
specifier|final
name|SqlGroupingFunction
name|GROUPING_ID
init|=
operator|new
name|SqlGroupingFunction
argument_list|(
literal|"GROUPING_ID"
argument_list|)
decl_stmt|;
comment|/** {@code EXTEND} operator. */
specifier|public
specifier|static
specifier|final
name|SqlInternalOperator
name|EXTEND
init|=
operator|new
name|SqlExtendOperator
argument_list|()
decl_stmt|;
comment|/**    * String concatenation operator, '<code>||</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|CONCAT
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"||"
argument_list|,
name|SqlKind
operator|.
name|OTHER
argument_list|,
literal|60
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|DYADIC_STRING_SUM_PRECISION_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|STRING_SAME_SAME
argument_list|)
decl_stmt|;
comment|/**    * Arithmetic division operator, '<code>/</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|DIVIDE
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"/"
argument_list|,
name|SqlKind
operator|.
name|DIVIDE
argument_list|,
literal|60
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|QUOTIENT_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|DIVISION_OPERATOR
argument_list|)
decl_stmt|;
comment|/** The {@code RAND_INTEGER([seed, ] bound)} function, which yields a random    * integer, optionally with seed. */
specifier|public
specifier|static
specifier|final
name|SqlRandIntegerFunction
name|RAND_INTEGER
init|=
operator|new
name|SqlRandIntegerFunction
argument_list|()
decl_stmt|;
comment|/** The {@code RAND([seed])} function, which yields a random double,    * optionally with seed. */
specifier|public
specifier|static
specifier|final
name|SqlRandFunction
name|RAND
init|=
operator|new
name|SqlRandFunction
argument_list|()
decl_stmt|;
comment|/**    * Internal integer arithmetic division operator, '<code>/INT</code>'. This    * is only used to adjust scale for numerics. We distinguish it from    * user-requested division since some personalities want a floating-point    * computation, whereas for the internal scaling use of division, we always    * want integer division.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|DIVIDE_INTEGER
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"/INT"
argument_list|,
name|SqlKind
operator|.
name|DIVIDE
argument_list|,
literal|60
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|INTEGER_QUOTIENT_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|DIVISION_OPERATOR
argument_list|)
decl_stmt|;
comment|/**    * Dot operator, '<code>.</code>', used for referencing fields of records.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|DOT
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"."
argument_list|,
name|SqlKind
operator|.
name|DOT
argument_list|,
literal|80
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY_ANY
argument_list|)
decl_stmt|;
comment|/**    * Logical equals operator, '<code>=</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|EQUALS
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"="
argument_list|,
name|SqlKind
operator|.
name|EQUALS
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_UNORDERED_COMPARABLE_UNORDERED
argument_list|)
decl_stmt|;
comment|/**    * Logical greater-than operator, '<code>&gt;</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|GREATER_THAN
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|">"
argument_list|,
name|SqlKind
operator|.
name|GREATER_THAN
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_ORDERED_COMPARABLE_ORDERED
argument_list|)
decl_stmt|;
comment|/**    *<code>IS DISTINCT FROM</code> operator.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|IS_DISTINCT_FROM
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"IS DISTINCT FROM"
argument_list|,
name|SqlKind
operator|.
name|IS_DISTINCT_FROM
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_UNORDERED_COMPARABLE_UNORDERED
argument_list|)
decl_stmt|;
comment|/**    *<code>IS NOT DISTINCT FROM</code> operator. Is equivalent to<code>NOT(x    * IS DISTINCT FROM y)</code>    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|IS_NOT_DISTINCT_FROM
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"IS NOT DISTINCT FROM"
argument_list|,
name|SqlKind
operator|.
name|IS_NOT_DISTINCT_FROM
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_UNORDERED_COMPARABLE_UNORDERED
argument_list|)
decl_stmt|;
comment|/**    * The internal<code>$IS_DIFFERENT_FROM</code> operator is the same as the    * user-level {@link #IS_DISTINCT_FROM} in all respects except that    * the test for equality on character datatypes treats trailing spaces as    * significant.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|IS_DIFFERENT_FROM
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"$IS_DIFFERENT_FROM"
argument_list|,
name|SqlKind
operator|.
name|OTHER
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_UNORDERED_COMPARABLE_UNORDERED
argument_list|)
decl_stmt|;
comment|/**    * Logical greater-than-or-equal operator, '<code>&gt;=</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|GREATER_THAN_OR_EQUAL
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|">="
argument_list|,
name|SqlKind
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_ORDERED_COMPARABLE_ORDERED
argument_list|)
decl_stmt|;
comment|/**    *<code>IN</code> operator tests for a value's membership in a sub-query or    * a list of values.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|IN
init|=
operator|new
name|SqlInOperator
argument_list|(
name|SqlKind
operator|.
name|IN
argument_list|)
decl_stmt|;
comment|/**    *<code>NOT IN</code> operator tests for a value's membership in a sub-query    * or a list of values.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|NOT_IN
init|=
operator|new
name|SqlInOperator
argument_list|(
name|SqlKind
operator|.
name|NOT_IN
argument_list|)
decl_stmt|;
comment|/**    * The<code>&lt; SOME</code> operator (synonymous with    *<code>&lt; ANY</code>).    */
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|SOME_LT
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|SOME
argument_list|,
name|SqlKind
operator|.
name|LESS_THAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|SOME_LE
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|SOME
argument_list|,
name|SqlKind
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|SOME_GT
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|SOME
argument_list|,
name|SqlKind
operator|.
name|GREATER_THAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|SOME_GE
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|SOME
argument_list|,
name|SqlKind
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|SOME_EQ
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|SOME
argument_list|,
name|SqlKind
operator|.
name|EQUALS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|SOME_NE
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|SOME
argument_list|,
name|SqlKind
operator|.
name|NOT_EQUALS
argument_list|)
decl_stmt|;
comment|/**    * The<code>&lt; ALL</code> operator.    */
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|ALL_LT
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|ALL
argument_list|,
name|SqlKind
operator|.
name|LESS_THAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|ALL_LE
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|ALL
argument_list|,
name|SqlKind
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|ALL_GT
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|ALL
argument_list|,
name|SqlKind
operator|.
name|GREATER_THAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|ALL_GE
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|ALL
argument_list|,
name|SqlKind
operator|.
name|GREATER_THAN_OR_EQUAL
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|ALL_EQ
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|ALL
argument_list|,
name|SqlKind
operator|.
name|EQUALS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlQuantifyOperator
name|ALL_NE
init|=
operator|new
name|SqlQuantifyOperator
argument_list|(
name|SqlKind
operator|.
name|ALL
argument_list|,
name|SqlKind
operator|.
name|NOT_EQUALS
argument_list|)
decl_stmt|;
comment|/**    * Logical less-than operator, '<code>&lt;</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|LESS_THAN
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"<"
argument_list|,
name|SqlKind
operator|.
name|LESS_THAN
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_ORDERED_COMPARABLE_ORDERED
argument_list|)
decl_stmt|;
comment|/**    * Logical less-than-or-equal operator, '<code>&lt;=</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|LESS_THAN_OR_EQUAL
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"<="
argument_list|,
name|SqlKind
operator|.
name|LESS_THAN_OR_EQUAL
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_ORDERED_COMPARABLE_ORDERED
argument_list|)
decl_stmt|;
comment|/**    * Infix arithmetic minus operator, '<code>-</code>'.    *    *<p>Its precedence is less than the prefix {@link #UNARY_PLUS +}    * and {@link #UNARY_MINUS -} operators.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|MINUS
init|=
operator|new
name|SqlMonotonicBinaryOperator
argument_list|(
literal|"-"
argument_list|,
name|SqlKind
operator|.
name|MINUS
argument_list|,
literal|40
argument_list|,
literal|true
argument_list|,
comment|// Same type inference strategy as sum
name|ReturnTypes
operator|.
name|NULLABLE_SUM
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|MINUS_OPERATOR
argument_list|)
decl_stmt|;
comment|/**    * Arithmetic multiplication operator, '<code>*</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|MULTIPLY
init|=
operator|new
name|SqlMonotonicBinaryOperator
argument_list|(
literal|"*"
argument_list|,
name|SqlKind
operator|.
name|TIMES
argument_list|,
literal|60
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|PRODUCT_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|MULTIPLY_OPERATOR
argument_list|)
decl_stmt|;
comment|/**    * Logical not-equals operator, '<code>&lt;&gt;</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|NOT_EQUALS
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"<>"
argument_list|,
name|SqlKind
operator|.
name|NOT_EQUALS
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|COMPARABLE_UNORDERED_COMPARABLE_UNORDERED
argument_list|)
decl_stmt|;
comment|/**    * Logical<code>OR</code> operator.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|OR
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"OR"
argument_list|,
name|SqlKind
operator|.
name|OR
argument_list|,
literal|22
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE_OPTIMIZED
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN_BOOLEAN
argument_list|)
decl_stmt|;
comment|/**    * Infix arithmetic plus operator, '<code>+</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|PLUS
init|=
operator|new
name|SqlMonotonicBinaryOperator
argument_list|(
literal|"+"
argument_list|,
name|SqlKind
operator|.
name|PLUS
argument_list|,
literal|40
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|NULLABLE_SUM
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|PLUS_OPERATOR
argument_list|)
decl_stmt|;
comment|/**    * Infix datetime plus operator, '<code>DATETIME + INTERVAL</code>'.    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|DATETIME_PLUS
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"DATETIME_PLUS"
argument_list|,
name|SqlKind
operator|.
name|PLUS
argument_list|,
literal|40
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|InferTypes
operator|.
name|FIRST_KNOWN
argument_list|,
name|OperandTypes
operator|.
name|PLUS_OPERATOR
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RelDataType
name|inferReturnType
parameter_list|(
name|SqlOperatorBinding
name|opBinding
parameter_list|)
block|{
specifier|final
name|RelDataTypeFactory
name|typeFactory
init|=
name|opBinding
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|leftType
init|=
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|IntervalSqlType
name|unitType
init|=
operator|(
name|IntervalSqlType
operator|)
name|opBinding
operator|.
name|getOperandType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|unitType
operator|.
name|getIntervalQualifier
argument_list|()
operator|.
name|getStartUnit
argument_list|()
condition|)
block|{
case|case
name|HOUR
case|:
case|case
name|MINUTE
case|:
case|case
name|SECOND
case|:
case|case
name|MILLISECOND
case|:
case|case
name|MICROSECOND
case|:
return|return
name|typeFactory
operator|.
name|createTypeWithNullability
argument_list|(
name|typeFactory
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
argument_list|,
name|leftType
operator|.
name|isNullable
argument_list|()
operator|||
name|unitType
operator|.
name|isNullable
argument_list|()
argument_list|)
return|;
default|default:
return|return
name|leftType
return|;
block|}
block|}
block|}
decl_stmt|;
comment|/**    * Multiset {@code MEMBER OF}, which returns whether a element belongs to a    * multiset.    *    *<p>For example, the following returns<code>false</code>:    *    *<blockquote>    *<code>'green' MEMBER OF MULTISET ['red','almost green','blue']</code>    *</blockquote>    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|MEMBER_OF
init|=
operator|new
name|SqlMultisetMemberOfOperator
argument_list|()
decl_stmt|;
comment|/**    * Submultiset. Checks to see if an multiset is a sub-set of another    * multiset.    *    *<p>For example, the following returns<code>false</code>:    *    *<blockquote>    *<code>MULTISET ['green'] SUBMULTISET OF    * MULTISET['red', 'almost green', 'blue']</code>    *</blockquote>    *    *<p>The following returns<code>true</code>, in part because multisets are    * order-independent:    *    *<blockquote>    *<code>MULTISET ['blue', 'red'] SUBMULTISET OF    * MULTISET ['red', 'almost green', 'blue']</code>    *</blockquote>    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|SUBMULTISET_OF
init|=
comment|// TODO: check if precedence is correct
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"SUBMULTISET OF"
argument_list|,
name|SqlKind
operator|.
name|OTHER
argument_list|,
literal|30
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|MULTISET_MULTISET
argument_list|)
decl_stmt|;
comment|//-------------------------------------------------------------
comment|//                   POSTFIX OPERATORS
comment|//-------------------------------------------------------------
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|DESC
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"DESC"
argument_list|,
name|SqlKind
operator|.
name|DESCENDING
argument_list|,
literal|20
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
name|InferTypes
operator|.
name|RETURN_TYPE
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|NULLS_FIRST
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"NULLS FIRST"
argument_list|,
name|SqlKind
operator|.
name|NULLS_FIRST
argument_list|,
literal|18
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
name|InferTypes
operator|.
name|RETURN_TYPE
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|NULLS_LAST
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"NULLS LAST"
argument_list|,
name|SqlKind
operator|.
name|NULLS_LAST
argument_list|,
literal|18
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
name|InferTypes
operator|.
name|RETURN_TYPE
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_NOT_NULL
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS NOT NULL"
argument_list|,
name|SqlKind
operator|.
name|IS_NOT_NULL
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NOT_NULL
argument_list|,
name|InferTypes
operator|.
name|VARCHAR_1024
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_NULL
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS NULL"
argument_list|,
name|SqlKind
operator|.
name|IS_NULL
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NOT_NULL
argument_list|,
name|InferTypes
operator|.
name|VARCHAR_1024
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_NOT_TRUE
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS NOT TRUE"
argument_list|,
name|SqlKind
operator|.
name|IS_NOT_TRUE
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NOT_NULL
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_TRUE
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS TRUE"
argument_list|,
name|SqlKind
operator|.
name|IS_TRUE
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NOT_NULL
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_NOT_FALSE
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS NOT FALSE"
argument_list|,
name|SqlKind
operator|.
name|IS_NOT_FALSE
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NOT_NULL
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_FALSE
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS FALSE"
argument_list|,
name|SqlKind
operator|.
name|IS_FALSE
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NOT_NULL
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_NOT_UNKNOWN
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS NOT UNKNOWN"
argument_list|,
name|SqlKind
operator|.
name|IS_NOT_NULL
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NOT_NULL
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_UNKNOWN
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS UNKNOWN"
argument_list|,
name|SqlKind
operator|.
name|IS_NULL
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN_NOT_NULL
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPostfixOperator
name|IS_A_SET
init|=
operator|new
name|SqlPostfixOperator
argument_list|(
literal|"IS A SET"
argument_list|,
name|SqlKind
operator|.
name|OTHER
argument_list|,
literal|28
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|MULTISET
argument_list|)
decl_stmt|;
comment|//-------------------------------------------------------------
comment|//                   PREFIX OPERATORS
comment|//-------------------------------------------------------------
specifier|public
specifier|static
specifier|final
name|SqlPrefixOperator
name|EXISTS
init|=
operator|new
name|SqlPrefixOperator
argument_list|(
literal|"EXISTS"
argument_list|,
name|SqlKind
operator|.
name|EXISTS
argument_list|,
literal|40
argument_list|,
name|ReturnTypes
operator|.
name|BOOLEAN
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|)
block|{
specifier|public
name|boolean
name|argumentMustBeScalar
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|validRexOperands
parameter_list|(
name|int
name|count
parameter_list|,
name|Litmus
name|litmus
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
return|return
name|litmus
operator|.
name|fail
argument_list|(
literal|"wrong operand count {} for {}"
argument_list|,
name|count
argument_list|,
name|this
argument_list|)
return|;
block|}
return|return
name|litmus
operator|.
name|succeed
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlPrefixOperator
name|NOT
init|=
operator|new
name|SqlPrefixOperator
argument_list|(
literal|"NOT"
argument_list|,
name|SqlKind
operator|.
name|NOT
argument_list|,
literal|26
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
name|InferTypes
operator|.
name|BOOLEAN
argument_list|,
name|OperandTypes
operator|.
name|BOOLEAN
argument_list|)
decl_stmt|;
comment|/**    * Prefix arithmetic minus operator, '<code>-</code>'.    *    *<p>Its precedence is greater than the infix '{@link #PLUS +}' and    * '{@link #MINUS -}' operators.    */
specifier|public
specifier|static
specifier|final
name|SqlPrefixOperator
name|UNARY_MINUS
init|=
operator|new
name|SqlPrefixOperator
argument_list|(
literal|"-"
argument_list|,
name|SqlKind
operator|.
name|MINUS_PREFIX
argument_list|,
literal|80
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
name|InferTypes
operator|.
name|RETURN_TYPE
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_OR_INTERVAL
argument_list|)
decl_stmt|;
comment|/**    * Prefix arithmetic plus operator, '<code>+</code>'.    *    *<p>Its precedence is greater than the infix '{@link #PLUS +}' and    * '{@link #MINUS -}' operators.    */
specifier|public
specifier|static
specifier|final
name|SqlPrefixOperator
name|UNARY_PLUS
init|=
operator|new
name|SqlPrefixOperator
argument_list|(
literal|"+"
argument_list|,
name|SqlKind
operator|.
name|PLUS_PREFIX
argument_list|,
literal|80
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
name|InferTypes
operator|.
name|RETURN_TYPE
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_OR_INTERVAL
argument_list|)
decl_stmt|;
comment|/**    * Keyword which allows an identifier to be explicitly flagged as a table.    * For example,<code>select * from (TABLE t)</code> or<code>TABLE    * t</code>. See also {@link #COLLECTION_TABLE}.    */
specifier|public
specifier|static
specifier|final
name|SqlPrefixOperator
name|EXPLICIT_TABLE
init|=
operator|new
name|SqlPrefixOperator
argument_list|(
literal|"TABLE"
argument_list|,
name|SqlKind
operator|.
name|EXPLICIT_TABLE
argument_list|,
literal|2
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|/** {@code FINAL} function to be used within {@code MATCH_RECOGNIZE}. */
specifier|public
specifier|static
specifier|final
name|SqlPrefixOperator
name|FINAL
init|=
operator|new
name|SqlPrefixOperator
argument_list|(
literal|"FINAL"
argument_list|,
name|SqlKind
operator|.
name|FINAL
argument_list|,
literal|80
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|)
decl_stmt|;
comment|/** {@code RUNNING} function to be used within {@code MATCH_RECOGNIZE}. */
specifier|public
specifier|static
specifier|final
name|SqlPrefixOperator
name|RUNNING
init|=
operator|new
name|SqlPrefixOperator
argument_list|(
literal|"RUNNING"
argument_list|,
name|SqlKind
operator|.
name|RUNNING
argument_list|,
literal|80
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|)
decl_stmt|;
comment|//-------------------------------------------------------------
comment|// AGGREGATE OPERATORS
comment|//-------------------------------------------------------------
comment|/**    *<code>SUM</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|SUM
init|=
operator|new
name|SqlSumAggFunction
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|/**    *<code>COUNT</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|COUNT
init|=
operator|new
name|SqlCountAggFunction
argument_list|()
decl_stmt|;
comment|/**    *<code>MIN</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|MIN
init|=
operator|new
name|SqlMinMaxAggFunction
argument_list|(
name|SqlKind
operator|.
name|MIN
argument_list|)
decl_stmt|;
comment|/**    *<code>MAX</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|MAX
init|=
operator|new
name|SqlMinMaxAggFunction
argument_list|(
name|SqlKind
operator|.
name|MAX
argument_list|)
decl_stmt|;
comment|/**    *<code>LAST_VALUE</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|LAST_VALUE
init|=
operator|new
name|SqlFirstLastValueAggFunction
argument_list|(
name|SqlKind
operator|.
name|LAST_VALUE
argument_list|)
decl_stmt|;
comment|/**    *<code>FIRST_VALUE</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|FIRST_VALUE
init|=
operator|new
name|SqlFirstLastValueAggFunction
argument_list|(
name|SqlKind
operator|.
name|FIRST_VALUE
argument_list|)
decl_stmt|;
comment|/**    *<code>LEAD</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|LEAD
init|=
operator|new
name|SqlLeadLagAggFunction
argument_list|(
name|SqlKind
operator|.
name|LEAD
argument_list|)
decl_stmt|;
comment|/**    *<code>LAG</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|LAG
init|=
operator|new
name|SqlLeadLagAggFunction
argument_list|(
name|SqlKind
operator|.
name|LAG
argument_list|)
decl_stmt|;
comment|/**    *<code>NTILE</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|NTILE
init|=
operator|new
name|SqlNtileAggFunction
argument_list|()
decl_stmt|;
comment|/**    *<code>SINGLE_VALUE</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|SINGLE_VALUE
init|=
operator|new
name|SqlSingleValueAggFunction
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|/**    *<code>AVG</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|AVG
init|=
operator|new
name|SqlAvgAggFunction
argument_list|(
name|SqlKind
operator|.
name|AVG
argument_list|)
decl_stmt|;
comment|/**    *<code>STDDEV_POP</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|STDDEV_POP
init|=
operator|new
name|SqlAvgAggFunction
argument_list|(
name|SqlKind
operator|.
name|STDDEV_POP
argument_list|)
decl_stmt|;
comment|/**    *<code>REGR_SXX</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|REGR_SXX
init|=
operator|new
name|SqlCovarAggFunction
argument_list|(
name|SqlKind
operator|.
name|REGR_SXX
argument_list|)
decl_stmt|;
comment|/**    *<code>REGR_SYY</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|REGR_SYY
init|=
operator|new
name|SqlCovarAggFunction
argument_list|(
name|SqlKind
operator|.
name|REGR_SYY
argument_list|)
decl_stmt|;
comment|/**    *<code>COVAR_POP</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|COVAR_POP
init|=
operator|new
name|SqlCovarAggFunction
argument_list|(
name|SqlKind
operator|.
name|COVAR_POP
argument_list|)
decl_stmt|;
comment|/**    *<code>COVAR_SAMP</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|COVAR_SAMP
init|=
operator|new
name|SqlCovarAggFunction
argument_list|(
name|SqlKind
operator|.
name|COVAR_SAMP
argument_list|)
decl_stmt|;
comment|/**    *<code>STDDEV_SAMP</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|STDDEV_SAMP
init|=
operator|new
name|SqlAvgAggFunction
argument_list|(
name|SqlKind
operator|.
name|STDDEV_SAMP
argument_list|)
decl_stmt|;
comment|/**    *<code>VAR_POP</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|VAR_POP
init|=
operator|new
name|SqlAvgAggFunction
argument_list|(
name|SqlKind
operator|.
name|VAR_POP
argument_list|)
decl_stmt|;
comment|/**    *<code>VAR_SAMP</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|VAR_SAMP
init|=
operator|new
name|SqlAvgAggFunction
argument_list|(
name|SqlKind
operator|.
name|VAR_SAMP
argument_list|)
decl_stmt|;
comment|//-------------------------------------------------------------
comment|// WINDOW Aggregate Functions
comment|//-------------------------------------------------------------
comment|/**    *<code>HISTOGRAM</code> aggregate function support. Used by window    * aggregate versions of MIN/MAX    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|HISTOGRAM_AGG
init|=
operator|new
name|SqlHistogramAggFunction
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|/**    *<code>HISTOGRAM_MIN</code> window aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|HISTOGRAM_MIN
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"$HISTOGRAM_MIN"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_OR_STRING
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
comment|/**    *<code>HISTOGRAM_MAX</code> window aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|HISTOGRAM_MAX
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"$HISTOGRAM_MAX"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_OR_STRING
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
comment|/**    *<code>HISTOGRAM_FIRST_VALUE</code> window aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|HISTOGRAM_FIRST_VALUE
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"$HISTOGRAM_FIRST_VALUE"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_OR_STRING
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
comment|/**    *<code>HISTOGRAM_LAST_VALUE</code> window aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|HISTOGRAM_LAST_VALUE
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"$HISTOGRAM_LAST_VALUE"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_OR_STRING
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
comment|/**    *<code>SUM0</code> aggregate function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|SUM0
init|=
operator|new
name|SqlSumEmptyIsZeroAggFunction
argument_list|()
decl_stmt|;
comment|//-------------------------------------------------------------
comment|// WINDOW Rank Functions
comment|//-------------------------------------------------------------
comment|/**    *<code>CUME_DIST</code> window function.    */
specifier|public
specifier|static
specifier|final
name|SqlRankFunction
name|CUME_DIST
init|=
operator|new
name|SqlRankFunction
argument_list|(
name|SqlKind
operator|.
name|CUME_DIST
argument_list|,
name|ReturnTypes
operator|.
name|FRACTIONAL_RANK
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/**    *<code>DENSE_RANK</code> window function.    */
specifier|public
specifier|static
specifier|final
name|SqlRankFunction
name|DENSE_RANK
init|=
operator|new
name|SqlRankFunction
argument_list|(
name|SqlKind
operator|.
name|DENSE_RANK
argument_list|,
name|ReturnTypes
operator|.
name|RANK
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/**    *<code>PERCENT_RANK</code> window function.    */
specifier|public
specifier|static
specifier|final
name|SqlRankFunction
name|PERCENT_RANK
init|=
operator|new
name|SqlRankFunction
argument_list|(
name|SqlKind
operator|.
name|PERCENT_RANK
argument_list|,
name|ReturnTypes
operator|.
name|FRACTIONAL_RANK
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/**    *<code>RANK</code> window function.    */
specifier|public
specifier|static
specifier|final
name|SqlRankFunction
name|RANK
init|=
operator|new
name|SqlRankFunction
argument_list|(
name|SqlKind
operator|.
name|RANK
argument_list|,
name|ReturnTypes
operator|.
name|RANK
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/**    *<code>ROW_NUMBER</code> window function.    */
specifier|public
specifier|static
specifier|final
name|SqlRankFunction
name|ROW_NUMBER
init|=
operator|new
name|SqlRankFunction
argument_list|(
name|SqlKind
operator|.
name|ROW_NUMBER
argument_list|,
name|ReturnTypes
operator|.
name|RANK
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//-------------------------------------------------------------
comment|//                   SPECIAL OPERATORS
comment|//-------------------------------------------------------------
specifier|public
specifier|static
specifier|final
name|SqlRowOperator
name|ROW
init|=
operator|new
name|SqlRowOperator
argument_list|(
literal|"ROW"
argument_list|)
decl_stmt|;
comment|/**    * A special operator for the subtraction of two DATETIMEs. The format of    * DATETIME subtraction is:    *    *<blockquote><code>"("&lt;datetime&gt; "-"&lt;datetime&gt; ")"    *&lt;interval qualifier&gt;</code></blockquote>    *    *<p>This operator is special since it needs to hold the    * additional interval qualifier specification.</p>    */
specifier|public
specifier|static
specifier|final
name|SqlDatetimeSubtractionOperator
name|MINUS_DATE
init|=
operator|new
name|SqlDatetimeSubtractionOperator
argument_list|()
decl_stmt|;
comment|/**    * The MULTISET Value Constructor. e.g. "<code>MULTISET[1,2,3]</code>".    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetValueConstructor
name|MULTISET_VALUE
init|=
operator|new
name|SqlMultisetValueConstructor
argument_list|()
decl_stmt|;
comment|/**    * The MULTISET Query Constructor. e.g. "<code>SELECT dname, MULTISET(SELECT    * FROM emp WHERE deptno = dept.deptno) FROM dept</code>".    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetQueryConstructor
name|MULTISET_QUERY
init|=
operator|new
name|SqlMultisetQueryConstructor
argument_list|()
decl_stmt|;
comment|/**    * The ARRAY Query Constructor. e.g. "<code>SELECT dname, ARRAY(SELECT    * FROM emp WHERE deptno = dept.deptno) FROM dept</code>".    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetQueryConstructor
name|ARRAY_QUERY
init|=
operator|new
name|SqlArrayQueryConstructor
argument_list|()
decl_stmt|;
comment|/**    * The MAP Query Constructor. e.g. "<code>MAP(SELECT empno, deptno    * FROM emp)</code>".    */
specifier|public
specifier|static
specifier|final
name|SqlMultisetQueryConstructor
name|MAP_QUERY
init|=
operator|new
name|SqlMapQueryConstructor
argument_list|()
decl_stmt|;
comment|/**    * The CURSOR constructor. e.g. "<code>SELECT * FROM    * TABLE(DEDUP(CURSOR(SELECT * FROM EMPS), 'name'))</code>".    */
specifier|public
specifier|static
specifier|final
name|SqlCursorConstructor
name|CURSOR
init|=
operator|new
name|SqlCursorConstructor
argument_list|()
decl_stmt|;
comment|/**    * The COLUMN_LIST constructor. e.g. the ROW() call in "<code>SELECT * FROM    * TABLE(DEDUP(CURSOR(SELECT * FROM EMPS), ROW(name, empno)))</code>".    */
specifier|public
specifier|static
specifier|final
name|SqlColumnListConstructor
name|COLUMN_LIST
init|=
operator|new
name|SqlColumnListConstructor
argument_list|()
decl_stmt|;
comment|/**    * The<code>UNNEST</code> operator.    */
specifier|public
specifier|static
specifier|final
name|SqlUnnestOperator
name|UNNEST
init|=
operator|new
name|SqlUnnestOperator
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * The<code>UNNEST WITH ORDINALITY</code> operator.    */
specifier|public
specifier|static
specifier|final
name|SqlUnnestOperator
name|UNNEST_WITH_ORDINALITY
init|=
operator|new
name|SqlUnnestOperator
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/**    * The<code>LATERAL</code> operator.    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|LATERAL
init|=
operator|new
name|SqlLateralOperator
argument_list|(
name|SqlKind
operator|.
name|LATERAL
argument_list|)
decl_stmt|;
comment|/**    * The "table function derived table" operator, which a table-valued    * function into a relation, e.g. "<code>SELECT * FROM    * TABLE(ramp(5))</code>".    *    *<p>This operator has function syntax (with one argument), whereas    * {@link #EXPLICIT_TABLE} is a prefix operator.    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|COLLECTION_TABLE
init|=
operator|new
name|SqlCollectionTableOperator
argument_list|(
literal|"TABLE"
argument_list|,
name|SqlModality
operator|.
name|RELATION
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOverlapsOperator
name|OVERLAPS
init|=
operator|new
name|SqlOverlapsOperator
argument_list|(
name|SqlKind
operator|.
name|OVERLAPS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOverlapsOperator
name|CONTAINS
init|=
operator|new
name|SqlOverlapsOperator
argument_list|(
name|SqlKind
operator|.
name|CONTAINS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOverlapsOperator
name|PRECEDES
init|=
operator|new
name|SqlOverlapsOperator
argument_list|(
name|SqlKind
operator|.
name|PRECEDES
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOverlapsOperator
name|IMMEDIATELY_PRECEDES
init|=
operator|new
name|SqlOverlapsOperator
argument_list|(
name|SqlKind
operator|.
name|IMMEDIATELY_PRECEDES
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOverlapsOperator
name|SUCCEEDS
init|=
operator|new
name|SqlOverlapsOperator
argument_list|(
name|SqlKind
operator|.
name|SUCCEEDS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOverlapsOperator
name|IMMEDIATELY_SUCCEEDS
init|=
operator|new
name|SqlOverlapsOperator
argument_list|(
name|SqlKind
operator|.
name|IMMEDIATELY_SUCCEEDS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOverlapsOperator
name|PERIOD_EQUALS
init|=
operator|new
name|SqlOverlapsOperator
argument_list|(
name|SqlKind
operator|.
name|PERIOD_EQUALS
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|VALUES
init|=
operator|new
name|SqlValuesOperator
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlLiteralChainOperator
name|LITERAL_CHAIN
init|=
operator|new
name|SqlLiteralChainOperator
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlThrowOperator
name|THROW
init|=
operator|new
name|SqlThrowOperator
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlBetweenOperator
name|BETWEEN
init|=
operator|new
name|SqlBetweenOperator
argument_list|(
name|SqlBetweenOperator
operator|.
name|Flag
operator|.
name|ASYMMETRIC
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlBetweenOperator
name|SYMMETRIC_BETWEEN
init|=
operator|new
name|SqlBetweenOperator
argument_list|(
name|SqlBetweenOperator
operator|.
name|Flag
operator|.
name|SYMMETRIC
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlBetweenOperator
name|NOT_BETWEEN
init|=
operator|new
name|SqlBetweenOperator
argument_list|(
name|SqlBetweenOperator
operator|.
name|Flag
operator|.
name|ASYMMETRIC
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlBetweenOperator
name|SYMMETRIC_NOT_BETWEEN
init|=
operator|new
name|SqlBetweenOperator
argument_list|(
name|SqlBetweenOperator
operator|.
name|Flag
operator|.
name|SYMMETRIC
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|NOT_LIKE
init|=
operator|new
name|SqlLikeOperator
argument_list|(
literal|"NOT LIKE"
argument_list|,
name|SqlKind
operator|.
name|LIKE
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|LIKE
init|=
operator|new
name|SqlLikeOperator
argument_list|(
literal|"LIKE"
argument_list|,
name|SqlKind
operator|.
name|LIKE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|NOT_SIMILAR_TO
init|=
operator|new
name|SqlLikeOperator
argument_list|(
literal|"NOT SIMILAR TO"
argument_list|,
name|SqlKind
operator|.
name|SIMILAR
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|SIMILAR_TO
init|=
operator|new
name|SqlLikeOperator
argument_list|(
literal|"SIMILAR TO"
argument_list|,
name|SqlKind
operator|.
name|SIMILAR
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Internal operator used to represent the ESCAPE clause of a LIKE or    * SIMILAR TO expression.    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|ESCAPE
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"ESCAPE"
argument_list|,
name|SqlKind
operator|.
name|ESCAPE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlCaseOperator
name|CASE
init|=
name|SqlCaseOperator
operator|.
name|INSTANCE
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOperator
name|PROCEDURE_CALL
init|=
operator|new
name|SqlProcedureCallOperator
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlOperator
name|NEW
init|=
operator|new
name|SqlNewOperator
argument_list|()
decl_stmt|;
comment|/**    * The<code>OVER</code> operator, which applies an aggregate functions to a    * {@link SqlWindow window}.    *    *<p>Operands are as follows:    *    *<ol>    *<li>name of window function ({@link org.apache.calcite.sql.SqlCall})</li>    *<li>window name ({@link org.apache.calcite.sql.SqlLiteral}) or window    * in-line specification (@link SqlWindowOperator})</li>    *</ol>    */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|OVER
init|=
operator|new
name|SqlOverOperator
argument_list|()
decl_stmt|;
comment|/**    * An<code>REINTERPRET</code> operator is internal to the planner. When the    * physical storage of two types is the same, this operator may be used to    * reinterpret values of one type as the other. This operator is similar to    * a cast, except that it does not alter the data value. Like a regular cast    * it accepts one operand and stores the target type as the return type. It    * performs an overflow check if it has<i>any</i> second operand, whether    * true or not.    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|REINTERPRET
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"Reinterpret"
argument_list|,
name|SqlKind
operator|.
name|REINTERPRET
argument_list|)
block|{
specifier|public
name|SqlOperandCountRange
name|getOperandCountRange
parameter_list|()
block|{
return|return
name|SqlOperandCountRanges
operator|.
name|between
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** Internal operator that extracts time periods (year, month, date) from a    * date in internal format (number of days since epoch). */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|EXTRACT_DATE
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"EXTRACT_DATE"
argument_list|,
name|SqlKind
operator|.
name|EXTRACT
argument_list|)
decl_stmt|;
comment|//-------------------------------------------------------------
comment|//                   FUNCTIONS
comment|//-------------------------------------------------------------
comment|/**    * The character substring function:<code>SUBSTRING(string FROM start [FOR    * length])</code>.    *    *<p>If the length parameter is a constant, the length of the result is the    * minimum of the length of the input and that length. Otherwise it is the    * length of the input.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|SUBSTRING
init|=
operator|new
name|SqlSubstringFunction
argument_list|()
decl_stmt|;
comment|/** The {@code REPLACE(string, search, replace)} function. Not standard SQL,    * but in Oracle and Postgres. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|REPLACE
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"REPLACE"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE_VARYING
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|STRING_STRING_STRING
argument_list|,
name|SqlFunctionCategory
operator|.
name|STRING
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CONVERT
init|=
operator|new
name|SqlConvertFunction
argument_list|(
literal|"CONVERT"
argument_list|)
decl_stmt|;
comment|/**    * The<code>TRANSLATE(<i>char_value</i> USING<i>translation_name</i>)</code> function    * alters the character set of a string value from one base character set to another.    *    *<p>It is defined in the SQL standard. See also non-standard    * {@link OracleSqlOperatorTable#TRANSLATE3}.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|TRANSLATE
init|=
operator|new
name|SqlConvertFunction
argument_list|(
literal|"TRANSLATE"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|OVERLAY
init|=
operator|new
name|SqlOverlayFunction
argument_list|()
decl_stmt|;
comment|/** The "TRIM" function. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|TRIM
init|=
name|SqlTrimFunction
operator|.
name|INSTANCE
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|POSITION
init|=
operator|new
name|SqlPositionFunction
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CHAR_LENGTH
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"CHAR_LENGTH"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|INTEGER_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|CHARACTER
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CHARACTER_LENGTH
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"CHARACTER_LENGTH"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|INTEGER_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|CHARACTER
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|UPPER
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"UPPER"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|CHARACTER
argument_list|,
name|SqlFunctionCategory
operator|.
name|STRING
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|LOWER
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"LOWER"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|CHARACTER
argument_list|,
name|SqlFunctionCategory
operator|.
name|STRING
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|INITCAP
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"INITCAP"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|CHARACTER
argument_list|,
name|SqlFunctionCategory
operator|.
name|STRING
argument_list|)
decl_stmt|;
comment|/**    * Uses SqlOperatorTable.useDouble for its return type since we don't know    * what the result type will be by just looking at the operand types. For    * example POW(int, int) can return a non integer if the second operand is    * negative.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|POWER
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"POWER"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|SQRT
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"SQRT"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|MOD
init|=
comment|// Return type is same as divisor (2nd operand)
comment|// SQL2003 Part2 Section 6.27, Syntax Rules 9
operator|new
name|SqlFunction
argument_list|(
literal|"MOD"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG1_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|EXACT_NUMERIC_EXACT_NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|LN
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"LN"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|LOG10
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"LOG10"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|ABS
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ABS"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_OR_INTERVAL
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|ACOS
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ACOS"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|ASIN
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ASIN"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|ATAN
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ATAN"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|ATAN2
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ATAN2"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|COS
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"COS"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|COT
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"COT"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|DEGREES
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"DEGREES"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|EXP
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"EXP"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|RADIANS
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"RADIANS"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|ROUND
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ROUND"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_INTEGER
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|SIGN
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"SIGN"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|SIN
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"SIN"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|TAN
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"TAN"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|TRUNCATE
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"TRUNCATE"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NUMERIC_INTEGER
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|PI
init|=
operator|new
name|SqlBaseContextVariable
argument_list|(
literal|"PI"
argument_list|,
name|ReturnTypes
operator|.
name|DOUBLE
argument_list|,
name|SqlFunctionCategory
operator|.
name|NUMERIC
argument_list|)
decl_stmt|;
comment|/** {@code FIRST} function to be used within {@code MATCH_RECOGNIZE}. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|FIRST
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"FIRST"
argument_list|,
name|SqlKind
operator|.
name|FIRST
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY_NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|MATCH_RECOGNIZE
argument_list|)
decl_stmt|;
comment|/** {@code LAST} function to be used within {@code MATCH_RECOGNIZE}. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|LAST
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"LAST"
argument_list|,
name|SqlKind
operator|.
name|LAST
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY_NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|MATCH_RECOGNIZE
argument_list|)
decl_stmt|;
comment|/** {@code PREV} function to be used within {@code MATCH_RECOGNIZE}. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|PREV
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"PREV"
argument_list|,
name|SqlKind
operator|.
name|PREV
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY_NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|MATCH_RECOGNIZE
argument_list|)
decl_stmt|;
comment|/** {@code NEXT} function to be used within {@code MATCH_RECOGNIZE}. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|NEXT
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"NEXT"
argument_list|,
name|SqlKind
operator|.
name|NEXT
argument_list|,
name|ReturnTypes
operator|.
name|ARG0_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY_NUMERIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|MATCH_RECOGNIZE
argument_list|)
decl_stmt|;
comment|/** {@code CLASSIFIER} function to be used within {@code MATCH_RECOGNIZE}. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CLASSIFIER
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"CLASSIFIER"
argument_list|,
name|SqlKind
operator|.
name|CLASSIFIER
argument_list|,
name|ReturnTypes
operator|.
name|VARCHAR_2000
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NILADIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|MATCH_RECOGNIZE
argument_list|)
decl_stmt|;
comment|/** {@code MATCH_NUMBER} function to be used within {@code MATCH_RECOGNIZE}. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|MATCH_NUMBER
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"MATCH_NUMBER "
argument_list|,
name|SqlKind
operator|.
name|MATCH_NUMBER
argument_list|,
name|ReturnTypes
operator|.
name|BIGINT_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|NILADIC
argument_list|,
name|SqlFunctionCategory
operator|.
name|MATCH_RECOGNIZE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|NULLIF
init|=
operator|new
name|SqlNullifFunction
argument_list|()
decl_stmt|;
comment|/**    * The COALESCE builtin function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|COALESCE
init|=
operator|new
name|SqlCoalesceFunction
argument_list|()
decl_stmt|;
comment|/**    * The<code>FLOOR</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|FLOOR
init|=
operator|new
name|SqlFloorFunction
argument_list|(
name|SqlKind
operator|.
name|FLOOR
argument_list|)
decl_stmt|;
comment|/**    * The<code>CEIL</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CEIL
init|=
operator|new
name|SqlFloorFunction
argument_list|(
name|SqlKind
operator|.
name|CEIL
argument_list|)
decl_stmt|;
comment|/**    * The<code>USER</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|USER
init|=
operator|new
name|SqlStringContextVariable
argument_list|(
literal|"USER"
argument_list|)
decl_stmt|;
comment|/**    * The<code>CURRENT_USER</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CURRENT_USER
init|=
operator|new
name|SqlStringContextVariable
argument_list|(
literal|"CURRENT_USER"
argument_list|)
decl_stmt|;
comment|/**    * The<code>SESSION_USER</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|SESSION_USER
init|=
operator|new
name|SqlStringContextVariable
argument_list|(
literal|"SESSION_USER"
argument_list|)
decl_stmt|;
comment|/**    * The<code>SYSTEM_USER</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|SYSTEM_USER
init|=
operator|new
name|SqlStringContextVariable
argument_list|(
literal|"SYSTEM_USER"
argument_list|)
decl_stmt|;
comment|/**    * The<code>CURRENT_PATH</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CURRENT_PATH
init|=
operator|new
name|SqlStringContextVariable
argument_list|(
literal|"CURRENT_PATH"
argument_list|)
decl_stmt|;
comment|/**    * The<code>CURRENT_ROLE</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CURRENT_ROLE
init|=
operator|new
name|SqlStringContextVariable
argument_list|(
literal|"CURRENT_ROLE"
argument_list|)
decl_stmt|;
comment|/**    * The<code>CURRENT_CATALOG</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CURRENT_CATALOG
init|=
operator|new
name|SqlStringContextVariable
argument_list|(
literal|"CURRENT_CATALOG"
argument_list|)
decl_stmt|;
comment|/**    * The<code>CURRENT_SCHEMA</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CURRENT_SCHEMA
init|=
operator|new
name|SqlStringContextVariable
argument_list|(
literal|"CURRENT_SCHEMA"
argument_list|)
decl_stmt|;
comment|/**    * The<code>LOCALTIME [(<i>precision</i>)]</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|LOCALTIME
init|=
operator|new
name|SqlAbstractTimeFunction
argument_list|(
literal|"LOCALTIME"
argument_list|,
name|SqlTypeName
operator|.
name|TIME
argument_list|)
decl_stmt|;
comment|/**    * The<code>LOCALTIMESTAMP [(<i>precision</i>)]</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|LOCALTIMESTAMP
init|=
operator|new
name|SqlAbstractTimeFunction
argument_list|(
literal|"LOCALTIMESTAMP"
argument_list|,
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
comment|/**    * The<code>CURRENT_TIME [(<i>precision</i>)]</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CURRENT_TIME
init|=
operator|new
name|SqlAbstractTimeFunction
argument_list|(
literal|"CURRENT_TIME"
argument_list|,
name|SqlTypeName
operator|.
name|TIME
argument_list|)
decl_stmt|;
comment|/**    * The<code>CURRENT_TIMESTAMP [(<i>precision</i>)]</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CURRENT_TIMESTAMP
init|=
operator|new
name|SqlAbstractTimeFunction
argument_list|(
literal|"CURRENT_TIMESTAMP"
argument_list|,
name|SqlTypeName
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
comment|/**    * The<code>CURRENT_DATE</code> function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CURRENT_DATE
init|=
operator|new
name|SqlCurrentDateFunction
argument_list|()
decl_stmt|;
comment|/** The<code>TIMESTAMPADD</code> function. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|TIMESTAMP_ADD
init|=
operator|new
name|SqlTimestampAddFunction
argument_list|()
decl_stmt|;
comment|/** The<code>TIMESTAMPDIFF</code> function. */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|TIMESTAMP_DIFF
init|=
operator|new
name|SqlTimestampDiffFunction
argument_list|()
decl_stmt|;
comment|/**    * Use of the<code>IN_FENNEL</code> operator forces the argument to be    * evaluated in Fennel. Otherwise acts as identity function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|IN_FENNEL
init|=
operator|new
name|SqlMonotonicUnaryFunction
argument_list|(
literal|"IN_FENNEL"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|,
name|SqlFunctionCategory
operator|.
name|SYSTEM
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>CAST</code> operator.    *    *<p>The SQL syntax is    *    *<blockquote><code>CAST(<i>expression</i> AS<i>type</i>)</code>    *</blockquote>    *    *<p>When the CAST operator is applies as a {@link SqlCall}, it has two    * arguments: the expression and the type. The type must not include a    * constraint, so<code>CAST(x AS INTEGER NOT NULL)</code>, for instance, is    * invalid.</p>    *    *<p>When the CAST operator is applied as a<code>RexCall</code>, the    * target type is simply stored as the return type, not an explicit operand.    * For example, the expression<code>CAST(1 + 2 AS DOUBLE)</code> will    * become a call to<code>CAST</code> with the expression<code>1 + 2</code>    * as its only operand.</p>    *    *<p>The<code>RexCall</code> form can also have a type which contains a    *<code>NOT NULL</code> constraint. When this expression is implemented, if    * the value is NULL, an exception will be thrown.</p>    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CAST
init|=
operator|new
name|SqlCastFunction
argument_list|()
decl_stmt|;
comment|/**    * The SQL<code>EXTRACT</code> operator. Extracts a specified field value    * from a DATETIME or an INTERVAL. E.g.<br>    *<code>EXTRACT(HOUR FROM INTERVAL '364 23:59:59')</code> returns<code>    * 23</code>    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|EXTRACT
init|=
operator|new
name|SqlExtractFunction
argument_list|()
decl_stmt|;
comment|/**    * The SQL<code>YEAR</code> operator. Returns the Year    * from a DATETIME  E.g.<br>    *<code>YEAR(date '2008-9-23')</code> returns<code>    * 2008</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|YEAR
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"YEAR"
argument_list|,
name|TimeUnit
operator|.
name|YEAR
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>QUARTER</code> operator. Returns the Quarter    * from a DATETIME  E.g.<br>    *<code>QUARTER(date '2008-9-23')</code> returns<code>    * 3</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|QUARTER
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"QUARTER"
argument_list|,
name|TimeUnit
operator|.
name|QUARTER
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>MONTH</code> operator. Returns the Month    * from a DATETIME  E.g.<br>    *<code>MONTH(date '2008-9-23')</code> returns<code>    * 9</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|MONTH
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"MONTH"
argument_list|,
name|TimeUnit
operator|.
name|MONTH
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>WEEK</code> operator. Returns the Week    * from a DATETIME  E.g.<br>    *<code>WEEK(date '2008-9-23')</code> returns<code>    * 39</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|WEEK
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"WEEK"
argument_list|,
name|TimeUnit
operator|.
name|WEEK
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>DAYOFYEAR</code> operator. Returns the DOY    * from a DATETIME  E.g.<br>    *<code>DAYOFYEAR(date '2008-9-23')</code> returns<code>    * 267</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|DAYOFYEAR
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"DAYOFYEAR"
argument_list|,
name|TimeUnit
operator|.
name|DOY
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>DAYOFMONTH</code> operator. Returns the Day    * from a DATETIME  E.g.<br>    *<code>DAYOFMONTH(date '2008-9-23')</code> returns<code>    * 23</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|DAYOFMONTH
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"DAYOFMONTH"
argument_list|,
name|TimeUnit
operator|.
name|DAY
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>DAYOFWEEK</code> operator. Returns the DOW    * from a DATETIME  E.g.<br>    *<code>DAYOFWEEK(date '2008-9-23')</code> returns<code>    * 2</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|DAYOFWEEK
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"DAYOFWEEK"
argument_list|,
name|TimeUnit
operator|.
name|DOW
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>HOUR</code> operator. Returns the Hour    * from a DATETIME  E.g.<br>    *<code>HOUR(timestamp '2008-9-23 01:23:45')</code> returns<code>    * 1</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|HOUR
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"HOUR"
argument_list|,
name|TimeUnit
operator|.
name|HOUR
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>MINUTE</code> operator. Returns the Minute    * from a DATETIME  E.g.<br>    *<code>MINUTE(timestamp '2008-9-23 01:23:45')</code> returns<code>    * 23</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|MINUTE
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"MINUTE"
argument_list|,
name|TimeUnit
operator|.
name|MINUTE
argument_list|)
decl_stmt|;
comment|/**    * The SQL<code>SECOND</code> operator. Returns the Second    * from a DATETIME  E.g.<br>    *<code>SECOND(timestamp '2008-9-23 01:23:45')</code> returns<code>    * 45</code>    */
specifier|public
specifier|static
specifier|final
name|SqlDatePartFunction
name|SECOND
init|=
operator|new
name|SqlDatePartFunction
argument_list|(
literal|"SECOND"
argument_list|,
name|TimeUnit
operator|.
name|SECOND
argument_list|)
decl_stmt|;
comment|/**    * The ELEMENT operator, used to convert a multiset with only one item to a    * "regular" type. Example ... log(ELEMENT(MULTISET[1])) ...    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|ELEMENT
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"ELEMENT"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|MULTISET_ELEMENT_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|COLLECTION
argument_list|,
name|SqlFunctionCategory
operator|.
name|SYSTEM
argument_list|)
decl_stmt|;
comment|/**    * The item operator {@code [ ... ]}, used to access a given element of an    * array or map. For example, {@code myArray[3]} or {@code "myMap['foo']"}.    *    *<p>The SQL standard calls the ARRAY variant a    *&lt;array element reference&gt;. Index is 1-based. The standard says    * to raise "data exception - array element error" but we currently return    * null.</p>    *    *<p>MAP is not standard SQL.</p>    */
specifier|public
specifier|static
specifier|final
name|SqlOperator
name|ITEM
init|=
operator|new
name|SqlItemOperator
argument_list|()
decl_stmt|;
comment|/**    * The ARRAY Value Constructor. e.g. "<code>ARRAY[1, 2, 3]</code>".    */
specifier|public
specifier|static
specifier|final
name|SqlArrayValueConstructor
name|ARRAY_VALUE_CONSTRUCTOR
init|=
operator|new
name|SqlArrayValueConstructor
argument_list|()
decl_stmt|;
comment|/**    * The MAP Value Constructor,    * e.g. "<code>MAP['washington', 1, 'obama', 44]</code>".    */
specifier|public
specifier|static
specifier|final
name|SqlMapValueConstructor
name|MAP_VALUE_CONSTRUCTOR
init|=
operator|new
name|SqlMapValueConstructor
argument_list|()
decl_stmt|;
comment|/**    * The internal "$SLICE" operator takes a multiset of records and returns a    * multiset of the first column of those records.    *    *<p>It is introduced when multisets of scalar types are created, in order    * to keep types consistent. For example,<code>MULTISET [5]</code> has type    *<code>INTEGER MULTISET</code> but is translated to an expression of type    *<code>RECORD(INTEGER EXPR$0) MULTISET</code> because in our internal    * representation of multisets, every element must be a record. Applying the    * "$SLICE" operator to this result converts the type back to an<code>    * INTEGER MULTISET</code> multiset value.    *    *<p><code>$SLICE</code> is often translated away when the multiset type is    * converted back to scalar values.    */
specifier|public
specifier|static
specifier|final
name|SqlInternalOperator
name|SLICE
init|=
operator|new
name|SqlInternalOperator
argument_list|(
literal|"$SLICE"
argument_list|,
name|SqlKind
operator|.
name|OTHER
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|MULTISET_PROJECT0
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|RECORD_COLLECTION
argument_list|)
block|{       }
decl_stmt|;
comment|/**    * The internal "$ELEMENT_SLICE" operator returns the first field of the    * only element of a multiset.    *    *<p>It is introduced when multisets of scalar types are created, in order    * to keep types consistent. For example,<code>ELEMENT(MULTISET [5])</code>    * is translated to<code>$ELEMENT_SLICE(MULTISET (VALUES ROW (5    * EXPR$0))</code> It is translated away when the multiset type is converted    * back to scalar values.</p>    *    *<p>NOTE: jhyde, 2006/1/9: Usages of this operator are commented out, but    * I'm not deleting the operator, because some multiset tests are disabled,    * and we may need this operator to get them working!</p>    */
specifier|public
specifier|static
specifier|final
name|SqlInternalOperator
name|ELEMENT_SLICE
init|=
operator|new
name|SqlInternalOperator
argument_list|(
literal|"$ELEMENT_SLICE"
argument_list|,
name|SqlKind
operator|.
name|OTHER
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|MULTISET_RECORD
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|MULTISET
argument_list|)
block|{
specifier|public
name|void
name|unparse
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|SqlUtil
operator|.
name|unparseFunctionSyntax
argument_list|(
name|this
argument_list|,
name|writer
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/**    * The internal "$SCALAR_QUERY" operator returns a scalar value from a    * record type. It assumes the record type only has one field, and returns    * that field as the output.    */
specifier|public
specifier|static
specifier|final
name|SqlInternalOperator
name|SCALAR_QUERY
init|=
operator|new
name|SqlInternalOperator
argument_list|(
literal|"$SCALAR_QUERY"
argument_list|,
name|SqlKind
operator|.
name|SCALAR_QUERY
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|ReturnTypes
operator|.
name|RECORD_TO_SCALAR
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|RECORD_TO_SCALAR
argument_list|)
block|{
specifier|public
name|void
name|unparse
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
specifier|final
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startList
argument_list|(
literal|"("
argument_list|,
literal|")"
argument_list|)
decl_stmt|;
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|argumentMustBeScalar
parameter_list|(
name|int
name|ordinal
parameter_list|)
block|{
comment|// Obvious, really.
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
comment|/**    * The CARDINALITY operator, used to retrieve the number of elements in a    * MULTISET, ARRAY or MAP.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|CARDINALITY
init|=
operator|new
name|SqlFunction
argument_list|(
literal|"CARDINALITY"
argument_list|,
name|SqlKind
operator|.
name|OTHER_FUNCTION
argument_list|,
name|ReturnTypes
operator|.
name|INTEGER_NULLABLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|COLLECTION_OR_MAP
argument_list|,
name|SqlFunctionCategory
operator|.
name|SYSTEM
argument_list|)
decl_stmt|;
comment|/**    * The COLLECT operator. Multiset aggregator function.    */
specifier|public
specifier|static
specifier|final
name|SqlAggFunction
name|COLLECT
init|=
operator|new
name|SqlAggFunction
argument_list|(
literal|"COLLECT"
argument_list|,
literal|null
argument_list|,
name|SqlKind
operator|.
name|COLLECT
argument_list|,
name|ReturnTypes
operator|.
name|TO_MULTISET
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|ANY
argument_list|,
name|SqlFunctionCategory
operator|.
name|SYSTEM
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|{       }
decl_stmt|;
comment|/**    * The FUSION operator. Multiset aggregator function.    */
specifier|public
specifier|static
specifier|final
name|SqlFunction
name|FUSION
init|=
operator|new
name|SqlAggFunction
argument_list|(
literal|"FUSION"
argument_list|,
literal|null
argument_list|,
name|SqlKind
operator|.
name|FUSION
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|MULTISET
argument_list|,
name|SqlFunctionCategory
operator|.
name|SYSTEM
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|{       }
decl_stmt|;
comment|/**    * The sequence next value function:<code>NEXT VALUE FOR sequence</code>    */
specifier|public
specifier|static
specifier|final
name|SqlOperator
name|NEXT_VALUE
init|=
operator|new
name|SqlSequenceValueOperator
argument_list|(
name|SqlKind
operator|.
name|NEXT_VALUE
argument_list|)
decl_stmt|;
comment|/**    * The sequence current value function:<code>CURRENT VALUE FOR    * sequence</code>    */
specifier|public
specifier|static
specifier|final
name|SqlOperator
name|CURRENT_VALUE
init|=
operator|new
name|SqlSequenceValueOperator
argument_list|(
name|SqlKind
operator|.
name|CURRENT_VALUE
argument_list|)
decl_stmt|;
comment|/**    * The<code>TABLESAMPLE</code> operator.    *    *<p>Examples:    *    *<ul>    *<li><code>&lt;query&gt; TABLESAMPLE SUBSTITUTE('sampleName')</code>    * (non-standard)    *<li><code>&lt;query&gt; TABLESAMPLE BERNOULLI(&lt;percent&gt;)    * [REPEATABLE(&lt;seed&gt;)]</code> (standard, but not implemented for FTRS    * yet)    *<li><code>&lt;query&gt; TABLESAMPLE SYSTEM(&lt;percent&gt;)    * [REPEATABLE(&lt;seed&gt;)]</code> (standard, but not implemented for FTRS    * yet)    *</ul>    *    *<p>Operand #0 is a query or table; Operand #1 is a {@link SqlSampleSpec}    * wrapped in a {@link SqlLiteral}.    */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|TABLESAMPLE
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"TABLESAMPLE"
argument_list|,
name|SqlKind
operator|.
name|TABLESAMPLE
argument_list|,
literal|20
argument_list|,
literal|true
argument_list|,
name|ReturnTypes
operator|.
name|ARG0
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|VARIADIC
argument_list|)
block|{
specifier|public
name|void
name|unparse
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|leftPrec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writer
operator|.
name|keyword
argument_list|(
literal|"TABLESAMPLE"
argument_list|)
expr_stmt|;
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
literal|0
argument_list|,
name|rightPrec
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** The {@code TUMBLE} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|TUMBLE
init|=
operator|new
name|SqlGroupFunction
argument_list|(
name|SqlKind
operator|.
name|TUMBLE
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|or
argument_list|(
name|OperandTypes
operator|.
name|DATETIME_INTERVAL
argument_list|,
name|OperandTypes
operator|.
name|DATETIME_INTERVAL_TIME
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
name|List
argument_list|<
name|SqlGroupFunction
argument_list|>
name|getAuxiliaryFunctions
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|TUMBLE_START
argument_list|,
name|TUMBLE_END
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** The {@code TUMBLE_START} auxiliary function of    * the {@code TUMBLE} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|TUMBLE_START
init|=
name|TUMBLE
operator|.
name|auxiliary
argument_list|(
name|SqlKind
operator|.
name|TUMBLE_START
argument_list|)
decl_stmt|;
comment|/** The {@code TUMBLE_END} auxiliary function of    * the {@code TUMBLE} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|TUMBLE_END
init|=
name|TUMBLE
operator|.
name|auxiliary
argument_list|(
name|SqlKind
operator|.
name|TUMBLE_END
argument_list|)
decl_stmt|;
comment|/** The {@code HOP} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|HOP
init|=
operator|new
name|SqlGroupFunction
argument_list|(
name|SqlKind
operator|.
name|HOP
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|or
argument_list|(
name|OperandTypes
operator|.
name|DATETIME_INTERVAL_INTERVAL
argument_list|,
name|OperandTypes
operator|.
name|DATETIME_INTERVAL_INTERVAL_TIME
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
name|List
argument_list|<
name|SqlGroupFunction
argument_list|>
name|getAuxiliaryFunctions
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|HOP_START
argument_list|,
name|HOP_END
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** The {@code HOP_START} auxiliary function of    * the {@code HOP} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|HOP_START
init|=
name|HOP
operator|.
name|auxiliary
argument_list|(
name|SqlKind
operator|.
name|HOP_START
argument_list|)
decl_stmt|;
comment|/** The {@code HOP_END} auxiliary function of    * the {@code HOP} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|HOP_END
init|=
name|HOP
operator|.
name|auxiliary
argument_list|(
name|SqlKind
operator|.
name|HOP_END
argument_list|)
decl_stmt|;
comment|/** The {@code SESSION} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|SESSION
init|=
operator|new
name|SqlGroupFunction
argument_list|(
name|SqlKind
operator|.
name|SESSION
argument_list|,
literal|null
argument_list|,
name|OperandTypes
operator|.
name|or
argument_list|(
name|OperandTypes
operator|.
name|DATETIME_INTERVAL
argument_list|,
name|OperandTypes
operator|.
name|DATETIME_INTERVAL_TIME
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
name|List
argument_list|<
name|SqlGroupFunction
argument_list|>
name|getAuxiliaryFunctions
parameter_list|()
block|{
return|return
name|ImmutableList
operator|.
name|of
argument_list|(
name|SESSION_START
argument_list|,
name|SESSION_END
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/** The {@code SESSION_START} auxiliary function of    * the {@code SESSION} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|SESSION_START
init|=
name|SESSION
operator|.
name|auxiliary
argument_list|(
name|SqlKind
operator|.
name|SESSION_START
argument_list|)
decl_stmt|;
comment|/** The {@code SESSION_END} auxiliary function of    * the {@code SESSION} group function. */
specifier|public
specifier|static
specifier|final
name|SqlGroupFunction
name|SESSION_END
init|=
name|SESSION
operator|.
name|auxiliary
argument_list|(
name|SqlKind
operator|.
name|SESSION_END
argument_list|)
decl_stmt|;
comment|/** {@code |} operator to create alternate patterns    * within {@code MATCH_RECOGNIZE}.    *    *<p>If {@code p1} and {@code p2} are patterns then {@code p1 | p2} is a    * pattern that matches {@code p1} or {@code p2}. */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|PATTERN_ALTER
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|"|"
argument_list|,
name|SqlKind
operator|.
name|PATTERN_ALTER
argument_list|,
literal|70
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|/** Operator to concatenate patterns within {@code MATCH_RECOGNIZE}.    *    *<p>If {@code p1} and {@code p2} are patterns then {@code p1 p2} is a    * pattern that matches {@code p1} followed by {@code p2}. */
specifier|public
specifier|static
specifier|final
name|SqlBinaryOperator
name|PATTERN_CONCAT
init|=
operator|new
name|SqlBinaryOperator
argument_list|(
literal|""
argument_list|,
name|SqlKind
operator|.
name|PATTERN_CONCAT
argument_list|,
literal|80
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|/** Operator to quantify patterns within {@code MATCH_RECOGNIZE}.    *    *<p>If {@code p} is a pattern then {@code p{3, 5}} is a    * pattern that matches between 3 and 5 occurrences of {@code p}. */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|PATTERN_QUANTIFIER
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"PATTERN_QUANTIFIER"
argument_list|,
name|SqlKind
operator|.
name|PATTERN_QUANTIFIER
argument_list|,
literal|90
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|unparse
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|call
operator|.
name|operand
argument_list|(
literal|0
argument_list|)
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
name|this
operator|.
name|getLeftPrec
argument_list|()
argument_list|,
name|this
operator|.
name|getRightPrec
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|startNum
init|=
operator|(
operator|(
name|SqlNumericLiteral
operator|)
name|call
operator|.
name|operand
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|intValue
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|SqlNumericLiteral
name|endRepNum
init|=
name|call
operator|.
name|operand
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|boolean
name|isReluctant
init|=
operator|(
operator|(
name|SqlLiteral
operator|)
name|call
operator|.
name|operand
argument_list|(
literal|3
argument_list|)
operator|)
operator|.
name|booleanValue
argument_list|()
decl_stmt|;
name|int
name|endNum
init|=
name|endRepNum
operator|.
name|intValue
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|startNum
operator|==
name|endNum
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"{ "
operator|+
name|startNum
operator|+
literal|" }"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|endNum
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|startNum
operator|==
literal|0
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|startNum
operator|==
literal|1
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"{ "
operator|+
name|startNum
operator|+
literal|", }"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|startNum
operator|==
literal|0
operator|&&
name|endNum
operator|==
literal|1
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|startNum
operator|==
operator|-
literal|1
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"{ , "
operator|+
name|endNum
operator|+
literal|" }"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"{ "
operator|+
name|startNum
operator|+
literal|", "
operator|+
name|endNum
operator|+
literal|" }"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isReluctant
condition|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
decl_stmt|;
comment|/** {@code PERMUTE} operator to combine patterns within    * {@code MATCH_RECOGNIZE}.    *    *<p>If {@code p1} and {@code p2} are patterns then {@code PERMUTE (p1, p2)}    * is a pattern that matches all permutations of {@code p1} and    * {@code p2}. */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|PATTERN_PERMUTE
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"PATTERN_PERMUTE"
argument_list|,
name|SqlKind
operator|.
name|PATTERN_PERMUTE
argument_list|,
literal|100
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|unparse
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|writer
operator|.
name|keyword
argument_list|(
literal|"PERMUTE"
argument_list|)
expr_stmt|;
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startList
argument_list|(
literal|"("
argument_list|,
literal|")"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SqlNode
name|pattern
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|pattern
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|writer
operator|.
name|print
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|/** {@code EXCLUDE} operator within {@code MATCH_RECOGNIZE}.    *    *<p>If {@code p} is a pattern then {@code {- p -} }} is a    * pattern that excludes {@code p} from the output. */
specifier|public
specifier|static
specifier|final
name|SqlSpecialOperator
name|PATTERN_EXCLUDE
init|=
operator|new
name|SqlSpecialOperator
argument_list|(
literal|"PATTERN_EXCLUDE"
argument_list|,
name|SqlKind
operator|.
name|PATTERN_EXCLUDED
argument_list|,
literal|100
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|unparse
parameter_list|(
name|SqlWriter
name|writer
parameter_list|,
name|SqlCall
name|call
parameter_list|,
name|int
name|leftPrec
parameter_list|,
name|int
name|rightPrec
parameter_list|)
block|{
name|SqlWriter
operator|.
name|Frame
name|frame
init|=
name|writer
operator|.
name|startList
argument_list|(
literal|"{-"
argument_list|,
literal|"-}"
argument_list|)
decl_stmt|;
name|SqlNode
name|node
init|=
name|call
operator|.
name|getOperandList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|node
operator|.
name|unparse
argument_list|(
name|writer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writer
operator|.
name|endList
argument_list|(
name|frame
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|//~ Methods ----------------------------------------------------------------
comment|/**    * Returns the standard operator table, creating it if necessary.    */
specifier|public
specifier|static
specifier|synchronized
name|SqlStdOperatorTable
name|instance
parameter_list|()
block|{
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
comment|// Creates and initializes the standard operator table.
comment|// Uses two-phase construction, because we can't initialize the
comment|// table until the constructor of the sub-class has completed.
name|instance
operator|=
operator|new
name|SqlStdOperatorTable
argument_list|()
expr_stmt|;
name|instance
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
return|return
name|instance
return|;
block|}
comment|/** Returns the group function for which a given kind is an auxiliary    * function, or null if it is not an auxiliary function. */
specifier|public
specifier|static
name|SqlGroupFunction
name|auxiliaryToGroup
parameter_list|(
name|SqlKind
name|kind
parameter_list|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|TUMBLE_START
case|:
case|case
name|TUMBLE_END
case|:
return|return
name|TUMBLE
return|;
case|case
name|HOP_START
case|:
case|case
name|HOP_END
case|:
return|return
name|HOP
return|;
case|case
name|SESSION_START
case|:
case|case
name|SESSION_END
case|:
return|return
name|SESSION
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/** Converts a call to a grouped auxiliary function    * to a call to the grouped window function. For other calls returns null.    *    *<p>For example, converts {@code TUMBLE_START(rowtime, INTERVAL '1' HOUR))}    * to {@code TUMBLE(rowtime, INTERVAL '1' HOUR))}. */
specifier|public
specifier|static
name|SqlCall
name|convertAuxiliaryToGroupCall
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|SqlGroupFunction
operator|&&
name|op
operator|.
name|isGroupAuxiliary
argument_list|()
condition|)
block|{
return|return
name|copy
argument_list|(
name|call
argument_list|,
operator|(
operator|(
name|SqlGroupFunction
operator|)
name|op
operator|)
operator|.
name|groupFunction
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Converts a call to a grouped window function to a call to its auxiliary    * window function(s). For other calls returns null.    *    *<p>For example, converts {@code TUMBLE_START(rowtime, INTERVAL '1' HOUR))}    * to {@code TUMBLE(rowtime, INTERVAL '1' HOUR))}. */
specifier|public
specifier|static
name|List
argument_list|<
name|Pair
argument_list|<
name|SqlNode
argument_list|,
name|AuxiliaryConverter
argument_list|>
argument_list|>
name|convertGroupToAuxiliaryCalls
parameter_list|(
name|SqlCall
name|call
parameter_list|)
block|{
specifier|final
name|SqlOperator
name|op
init|=
name|call
operator|.
name|getOperator
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|SqlGroupFunction
operator|&&
name|op
operator|.
name|isGroup
argument_list|()
condition|)
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|Pair
argument_list|<
name|SqlNode
argument_list|,
name|AuxiliaryConverter
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|SqlGroupFunction
name|f
range|:
operator|(
operator|(
name|SqlGroupFunction
operator|)
name|op
operator|)
operator|.
name|getAuxiliaryFunctions
argument_list|()
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|Pair
operator|.
expr|<
name|SqlNode
argument_list|,
name|AuxiliaryConverter
operator|>
name|of
argument_list|(
name|copy
argument_list|(
name|call
argument_list|,
name|f
argument_list|)
argument_list|,
operator|new
name|AuxiliaryConverter
operator|.
name|Impl
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
return|return
name|ImmutableList
operator|.
name|of
argument_list|()
return|;
block|}
comment|/** Creates a copy of a call with a new operator. */
specifier|private
specifier|static
name|SqlCall
name|copy
parameter_list|(
name|SqlCall
name|call
parameter_list|,
name|SqlOperator
name|operator
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|SqlNode
argument_list|>
name|list
init|=
name|call
operator|.
name|getOperandList
argument_list|()
decl_stmt|;
return|return
operator|new
name|SqlBasicCall
argument_list|(
name|operator
argument_list|,
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|SqlNode
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|call
operator|.
name|getParserPosition
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns the operator for {@code SOME comparisonKind}. */
specifier|public
specifier|static
name|SqlQuantifyOperator
name|some
parameter_list|(
name|SqlKind
name|comparisonKind
parameter_list|)
block|{
switch|switch
condition|(
name|comparisonKind
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|SOME_EQ
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|SOME_NE
return|;
case|case
name|LESS_THAN
case|:
return|return
name|SOME_LT
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|SOME_LE
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|SOME_GT
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|SOME_GE
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|comparisonKind
argument_list|)
throw|;
block|}
block|}
comment|/** Returns the operator for {@code ALL comparisonKind}. */
specifier|public
specifier|static
name|SqlQuantifyOperator
name|all
parameter_list|(
name|SqlKind
name|comparisonKind
parameter_list|)
block|{
switch|switch
condition|(
name|comparisonKind
condition|)
block|{
case|case
name|EQUALS
case|:
return|return
name|ALL_EQ
return|;
case|case
name|NOT_EQUALS
case|:
return|return
name|ALL_NE
return|;
case|case
name|LESS_THAN
case|:
return|return
name|ALL_LT
return|;
case|case
name|LESS_THAN_OR_EQUAL
case|:
return|return
name|ALL_LE
return|;
case|case
name|GREATER_THAN
case|:
return|return
name|ALL_GT
return|;
case|case
name|GREATER_THAN_OR_EQUAL
case|:
return|return
name|ALL_GE
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
name|comparisonKind
argument_list|)
throw|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End SqlStdOperatorTable.java
end_comment

end_unit

